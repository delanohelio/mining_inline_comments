{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0MjAxNjQy", "number": 1192, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjoyODozMVrOEMJzgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDowMjo1M1rOEMOSyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMTc5MDA4OnYy", "diffSide": "LEFT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/AbstractMessageProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjoyODozMVrOGuGZdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjozMDowNVrOGuGdGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk5MjUwMg==", "bodyText": "It seems like this ended up being redundant, is that right?", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r450992502", "createdAt": "2020-07-07T16:28:31Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/AbstractMessageProcessor.java", "diffHunk": "@@ -155,8 +153,6 @@ protected void completedFailed(final MessageFrame frame) {\n   private void codeExecute(final MessageFrame frame, final OperationTracer operationTracer) {\n     try {\n       evm.runToHalt(frame, operationTracer);\n-    } catch (final ExceptionalHaltException e) {\n-      frame.setState(MessageFrame.State.EXCEPTIONAL_HALT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "488fa4d16207b13a37cb22ba4536ccf7df35ee5c"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk5MzQzMg==", "bodyText": "Yea, exceptional halts are no longer directly signaled via Java exceptions.", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r450993432", "createdAt": "2020-07-07T16:30:05Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/AbstractMessageProcessor.java", "diffHunk": "@@ -155,8 +153,6 @@ protected void completedFailed(final MessageFrame frame) {\n   private void codeExecute(final MessageFrame frame, final OperationTracer operationTracer) {\n     try {\n       evm.runToHalt(frame, operationTracer);\n-    } catch (final ExceptionalHaltException e) {\n-      frame.setState(MessageFrame.State.EXCEPTIONAL_HALT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk5MjUwMg=="}, "originalCommit": {"oid": "488fa4d16207b13a37cb22ba4536ccf7df35ee5c"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMTg4Nzg1OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/Operation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjo1NTowMVrOGuHYnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNzozMToyOVrOGuIsKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwODY2OA==", "bodyText": "Since this now also checks gas, we should reflect the implementer's responsibility in the javadoc if not the name of the method.", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451008668", "createdAt": "2020-07-07T16:55:01Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/Operation.java", "diffHunk": "@@ -20,34 +20,33 @@\n \n public interface Operation {\n \n-  /**\n-   * Gas cost of this operation, in context of the provided frame.\n-   *\n-   * @param frame The frame for execution of this operation.\n-   * @return The gas cost associated with executing this operation given the current {@link\n-   *     MessageFrame}.\n-   */\n-  Gas cost(MessageFrame frame);\n+  class OperationResult {\n+    final Optional<Gas> gasCost;\n+    final Optional<ExceptionalHaltReason> haltReason;\n+\n+    public OperationResult(\n+        final Optional<Gas> gasCost, final Optional<ExceptionalHaltReason> haltReason) {\n+      this.gasCost = gasCost;\n+      this.haltReason = haltReason;\n+    }\n+\n+    public Optional<Gas> getGasCost() {\n+      return gasCost;\n+    }\n+\n+    public Optional<ExceptionalHaltReason> getHaltReason() {\n+      return haltReason;\n+    }\n+  }\n \n   /**\n    * Executes the logic behind this operation.\n    *\n    * @param frame The frame for execution of this operation.\n+   * @param evm The EVM for execution of this operation.\n+   * @return the gas cost and any exeptional halt reasons of the operation.\n    */\n-  void execute(MessageFrame frame);\n-\n-  /**\n-   * Check if an exceptional halt condition should apply\n-   *\n-   * @param frame the current frame\n-   * @param evm the currently executing EVM\n-   * @return an {@link Optional} containing the {@link ExceptionalHaltReason} that applies or empty\n-   *     if no exceptional halt condition applies.\n-   */\n-  default Optional<ExceptionalHaltReason> exceptionalHaltCondition(\n-      final MessageFrame frame, final EVM evm) {\n-    return Optional.empty();\n-  }\n+  OperationResult execute(final MessageFrame frame, final EVM evm);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "488fa4d16207b13a37cb22ba4536ccf7df35ee5c"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAzMDA1OA==", "bodyText": "javadocs updated.", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451030058", "createdAt": "2020-07-07T17:31:29Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/Operation.java", "diffHunk": "@@ -20,34 +20,33 @@\n \n public interface Operation {\n \n-  /**\n-   * Gas cost of this operation, in context of the provided frame.\n-   *\n-   * @param frame The frame for execution of this operation.\n-   * @return The gas cost associated with executing this operation given the current {@link\n-   *     MessageFrame}.\n-   */\n-  Gas cost(MessageFrame frame);\n+  class OperationResult {\n+    final Optional<Gas> gasCost;\n+    final Optional<ExceptionalHaltReason> haltReason;\n+\n+    public OperationResult(\n+        final Optional<Gas> gasCost, final Optional<ExceptionalHaltReason> haltReason) {\n+      this.gasCost = gasCost;\n+      this.haltReason = haltReason;\n+    }\n+\n+    public Optional<Gas> getGasCost() {\n+      return gasCost;\n+    }\n+\n+    public Optional<ExceptionalHaltReason> getHaltReason() {\n+      return haltReason;\n+    }\n+  }\n \n   /**\n    * Executes the logic behind this operation.\n    *\n    * @param frame The frame for execution of this operation.\n+   * @param evm The EVM for execution of this operation.\n+   * @return the gas cost and any exeptional halt reasons of the operation.\n    */\n-  void execute(MessageFrame frame);\n-\n-  /**\n-   * Check if an exceptional halt condition should apply\n-   *\n-   * @param frame the current frame\n-   * @param evm the currently executing EVM\n-   * @return an {@link Optional} containing the {@link ExceptionalHaltReason} that applies or empty\n-   *     if no exceptional halt condition applies.\n-   */\n-  default Optional<ExceptionalHaltReason> exceptionalHaltCondition(\n-      final MessageFrame frame, final EVM evm) {\n-    return Optional.empty();\n-  }\n+  OperationResult execute(final MessageFrame frame, final EVM evm);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwODY2OA=="}, "originalCommit": {"oid": "488fa4d16207b13a37cb22ba4536ccf7df35ee5c"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjAwMDE3OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/operations/BlockHashOperation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNzoyNTo0NVrOGuIfOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNzoyNzo1NFrOGuIj8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAyNjc0NA==", "bodyText": "OVERFLOWFLOW_RESPONSE? Do you want to say OVERFLOW_RESPONSE", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451026744", "createdAt": "2020-07-07T17:25:45Z", "author": {"login": "matkt"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/operations/BlockHashOperation.java", "diffHunk": "@@ -15,55 +15,70 @@\n package org.hyperledger.besu.ethereum.vm.operations;\n \n import org.hyperledger.besu.ethereum.core.BlockHeader;\n-import org.hyperledger.besu.ethereum.core.Gas;\n import org.hyperledger.besu.ethereum.core.Hash;\n import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n-import org.hyperledger.besu.ethereum.vm.AbstractOperation;\n import org.hyperledger.besu.ethereum.vm.BlockHashLookup;\n+import org.hyperledger.besu.ethereum.vm.EVM;\n import org.hyperledger.besu.ethereum.vm.GasCalculator;\n import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.vm.OperandStack.OverflowException;\n+import org.hyperledger.besu.ethereum.vm.OperandStack.UnderflowException;\n \n import org.apache.tuweni.bytes.Bytes32;\n import org.apache.tuweni.units.bigints.UInt256;\n \n-public class BlockHashOperation extends AbstractOperation {\n+public class BlockHashOperation extends AbstractFixedCostOperation {\n \n   private static final int MAX_RELATIVE_BLOCK = 255;\n \n   public BlockHashOperation(final GasCalculator gasCalculator) {\n-    super(0x40, \"BLOCKHASH\", 1, 1, false, 1, gasCalculator);\n+    super(\n+        0x40,\n+        \"BLOCKHASH\",\n+        1,\n+        1,\n+        false,\n+        1,\n+        gasCalculator,\n+        gasCalculator.getBlockHashOperationGasCost());\n   }\n \n   @Override\n-  public Gas cost(final MessageFrame frame) {\n-    return gasCalculator().getBlockHashOperationGasCost();\n-  }\n+  public OperationResult execute(final MessageFrame frame, final EVM evm) {\n+    try {\n+      if (frame.getRemainingGas().compareTo(gasCost) < 0) {\n+        return oogResponse;\n+      }\n+      final UInt256 blockArg = UInt256.fromBytes(frame.popStackItem());\n \n-  @Override\n-  public void execute(final MessageFrame frame) {\n-    final UInt256 blockArg = UInt256.fromBytes(frame.popStackItem());\n+      // Short-circuit if value is unreasonably large\n+      if (!blockArg.fitsLong()) {\n+        frame.pushStackItem(Bytes32.ZERO);\n+        return successResponse;\n+      }\n \n-    // Short-circuit if value is unreasonably large\n-    if (!blockArg.fitsLong()) {\n-      frame.pushStackItem(Bytes32.ZERO);\n-      return;\n-    }\n+      final long soughtBlock = blockArg.toLong();\n+      final ProcessableBlockHeader blockHeader = frame.getBlockHeader();\n+      final long currentBlockNumber = blockHeader.getNumber();\n+      final long mostRecentBlockNumber = currentBlockNumber - 1;\n \n-    final long soughtBlock = blockArg.toLong();\n-    final ProcessableBlockHeader blockHeader = frame.getBlockHeader();\n-    final long currentBlockNumber = blockHeader.getNumber();\n-    final long mostRecentBlockNumber = currentBlockNumber - 1;\n+      // If the current block is the genesis block or the sought block is\n+      // not within the last 256 completed blocks, zero is returned.\n+      if (currentBlockNumber == BlockHeader.GENESIS_BLOCK_NUMBER\n+          || soughtBlock < (mostRecentBlockNumber - MAX_RELATIVE_BLOCK)\n+          || soughtBlock > mostRecentBlockNumber) {\n+        frame.pushStackItem(Bytes32.ZERO);\n+      } else {\n+        final BlockHashLookup blockHashLookup = frame.getBlockHashLookup();\n+        final Hash blockHash = blockHashLookup.getBlockHash(soughtBlock);\n+        frame.pushStackItem(blockHash);\n+      }\n \n-    // If the current block is the genesis block or the sought block is\n-    // not within the last 256 completed blocks, zero is returned.\n-    if (currentBlockNumber == BlockHeader.GENESIS_BLOCK_NUMBER\n-        || soughtBlock < (mostRecentBlockNumber - MAX_RELATIVE_BLOCK)\n-        || soughtBlock > mostRecentBlockNumber) {\n-      frame.pushStackItem(Bytes32.ZERO);\n-    } else {\n-      final BlockHashLookup blockHashLookup = frame.getBlockHashLookup();\n-      final Hash blockHash = blockHashLookup.getBlockHash(soughtBlock);\n-      frame.pushStackItem(blockHash);\n+      return successResponse;\n+    } catch (final UnderflowException ue) {\n+      return UNDERFLOW_RESPONSE;\n+    } catch (final OverflowException oe) {\n+      return OVERFLOWFLOW_RESPONSE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "488fa4d16207b13a37cb22ba4536ccf7df35ee5c"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAyNzk1NA==", "bodyText": "Yep.  Fix pushed.", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451027954", "createdAt": "2020-07-07T17:27:54Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/operations/BlockHashOperation.java", "diffHunk": "@@ -15,55 +15,70 @@\n package org.hyperledger.besu.ethereum.vm.operations;\n \n import org.hyperledger.besu.ethereum.core.BlockHeader;\n-import org.hyperledger.besu.ethereum.core.Gas;\n import org.hyperledger.besu.ethereum.core.Hash;\n import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n-import org.hyperledger.besu.ethereum.vm.AbstractOperation;\n import org.hyperledger.besu.ethereum.vm.BlockHashLookup;\n+import org.hyperledger.besu.ethereum.vm.EVM;\n import org.hyperledger.besu.ethereum.vm.GasCalculator;\n import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.vm.OperandStack.OverflowException;\n+import org.hyperledger.besu.ethereum.vm.OperandStack.UnderflowException;\n \n import org.apache.tuweni.bytes.Bytes32;\n import org.apache.tuweni.units.bigints.UInt256;\n \n-public class BlockHashOperation extends AbstractOperation {\n+public class BlockHashOperation extends AbstractFixedCostOperation {\n \n   private static final int MAX_RELATIVE_BLOCK = 255;\n \n   public BlockHashOperation(final GasCalculator gasCalculator) {\n-    super(0x40, \"BLOCKHASH\", 1, 1, false, 1, gasCalculator);\n+    super(\n+        0x40,\n+        \"BLOCKHASH\",\n+        1,\n+        1,\n+        false,\n+        1,\n+        gasCalculator,\n+        gasCalculator.getBlockHashOperationGasCost());\n   }\n \n   @Override\n-  public Gas cost(final MessageFrame frame) {\n-    return gasCalculator().getBlockHashOperationGasCost();\n-  }\n+  public OperationResult execute(final MessageFrame frame, final EVM evm) {\n+    try {\n+      if (frame.getRemainingGas().compareTo(gasCost) < 0) {\n+        return oogResponse;\n+      }\n+      final UInt256 blockArg = UInt256.fromBytes(frame.popStackItem());\n \n-  @Override\n-  public void execute(final MessageFrame frame) {\n-    final UInt256 blockArg = UInt256.fromBytes(frame.popStackItem());\n+      // Short-circuit if value is unreasonably large\n+      if (!blockArg.fitsLong()) {\n+        frame.pushStackItem(Bytes32.ZERO);\n+        return successResponse;\n+      }\n \n-    // Short-circuit if value is unreasonably large\n-    if (!blockArg.fitsLong()) {\n-      frame.pushStackItem(Bytes32.ZERO);\n-      return;\n-    }\n+      final long soughtBlock = blockArg.toLong();\n+      final ProcessableBlockHeader blockHeader = frame.getBlockHeader();\n+      final long currentBlockNumber = blockHeader.getNumber();\n+      final long mostRecentBlockNumber = currentBlockNumber - 1;\n \n-    final long soughtBlock = blockArg.toLong();\n-    final ProcessableBlockHeader blockHeader = frame.getBlockHeader();\n-    final long currentBlockNumber = blockHeader.getNumber();\n-    final long mostRecentBlockNumber = currentBlockNumber - 1;\n+      // If the current block is the genesis block or the sought block is\n+      // not within the last 256 completed blocks, zero is returned.\n+      if (currentBlockNumber == BlockHeader.GENESIS_BLOCK_NUMBER\n+          || soughtBlock < (mostRecentBlockNumber - MAX_RELATIVE_BLOCK)\n+          || soughtBlock > mostRecentBlockNumber) {\n+        frame.pushStackItem(Bytes32.ZERO);\n+      } else {\n+        final BlockHashLookup blockHashLookup = frame.getBlockHashLookup();\n+        final Hash blockHash = blockHashLookup.getBlockHash(soughtBlock);\n+        frame.pushStackItem(blockHash);\n+      }\n \n-    // If the current block is the genesis block or the sought block is\n-    // not within the last 256 completed blocks, zero is returned.\n-    if (currentBlockNumber == BlockHeader.GENESIS_BLOCK_NUMBER\n-        || soughtBlock < (mostRecentBlockNumber - MAX_RELATIVE_BLOCK)\n-        || soughtBlock > mostRecentBlockNumber) {\n-      frame.pushStackItem(Bytes32.ZERO);\n-    } else {\n-      final BlockHashLookup blockHashLookup = frame.getBlockHashLookup();\n-      final Hash blockHash = blockHashLookup.getBlockHash(soughtBlock);\n-      frame.pushStackItem(blockHash);\n+      return successResponse;\n+    } catch (final UnderflowException ue) {\n+      return UNDERFLOW_RESPONSE;\n+    } catch (final OverflowException oe) {\n+      return OVERFLOWFLOW_RESPONSE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAyNjc0NA=="}, "originalCommit": {"oid": "488fa4d16207b13a37cb22ba4536ccf7df35ee5c"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjAyMTA5OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/operations/SLoadOperation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNzozMToyNlrOGuIsEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNzo1ODo0OFrOGuJpzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAzMDAzNA==", "bodyText": "Maybe be we need to avoid using assert here ?", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451030034", "createdAt": "2020-07-07T17:31:26Z", "author": {"login": "matkt"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/operations/SLoadOperation.java", "diffHunk": "@@ -15,32 +15,40 @@\n package org.hyperledger.besu.ethereum.vm.operations;\n \n import org.hyperledger.besu.ethereum.core.Account;\n-import org.hyperledger.besu.ethereum.core.Gas;\n-import org.hyperledger.besu.ethereum.vm.AbstractOperation;\n+import org.hyperledger.besu.ethereum.vm.EVM;\n import org.hyperledger.besu.ethereum.vm.GasCalculator;\n import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.vm.OperandStack.OverflowException;\n+import org.hyperledger.besu.ethereum.vm.OperandStack.UnderflowException;\n \n import org.apache.tuweni.bytes.Bytes32;\n import org.apache.tuweni.units.bigints.UInt256;\n \n-public class SLoadOperation extends AbstractOperation {\n+public class SLoadOperation extends AbstractFixedCostOperation {\n \n   public SLoadOperation(final GasCalculator gasCalculator) {\n-    super(0x54, \"SLOAD\", 1, 1, false, 1, gasCalculator);\n+    super(0x54, \"SLOAD\", 1, 1, false, 1, gasCalculator, gasCalculator.getSloadOperationGasCost());\n   }\n \n   @Override\n-  public Gas cost(final MessageFrame frame) {\n-    return gasCalculator().getSloadOperationGasCost();\n-  }\n+  public OperationResult execute(final MessageFrame frame, final EVM evm) {\n+    try {\n+      if (frame.getRemainingGas().compareTo(gasCost) < 0) {\n+        return oogResponse;\n+      }\n \n-  @Override\n-  public void execute(final MessageFrame frame) {\n-    final Bytes32 key = frame.popStackItem();\n+      final Bytes32 key = frame.popStackItem();\n+\n+      final Account account = frame.getWorldState().get(frame.getRecipientAddress());\n+      assert account != null : \"VM account should exist\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "488fa4d16207b13a37cb22ba4536ccf7df35ee5c"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA0NTgzNg==", "bodyText": "I deleted it.  The account should exist already as it's an account that should have existed for the call to even be made.  If account is null we will get an NPE 2 lines later, and if it's null something has broken quite severely in the EVM implementation so native NPEs communicate the failure accurately.", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451045836", "createdAt": "2020-07-07T17:58:48Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/operations/SLoadOperation.java", "diffHunk": "@@ -15,32 +15,40 @@\n package org.hyperledger.besu.ethereum.vm.operations;\n \n import org.hyperledger.besu.ethereum.core.Account;\n-import org.hyperledger.besu.ethereum.core.Gas;\n-import org.hyperledger.besu.ethereum.vm.AbstractOperation;\n+import org.hyperledger.besu.ethereum.vm.EVM;\n import org.hyperledger.besu.ethereum.vm.GasCalculator;\n import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.vm.OperandStack.OverflowException;\n+import org.hyperledger.besu.ethereum.vm.OperandStack.UnderflowException;\n \n import org.apache.tuweni.bytes.Bytes32;\n import org.apache.tuweni.units.bigints.UInt256;\n \n-public class SLoadOperation extends AbstractOperation {\n+public class SLoadOperation extends AbstractFixedCostOperation {\n \n   public SLoadOperation(final GasCalculator gasCalculator) {\n-    super(0x54, \"SLOAD\", 1, 1, false, 1, gasCalculator);\n+    super(0x54, \"SLOAD\", 1, 1, false, 1, gasCalculator, gasCalculator.getSloadOperationGasCost());\n   }\n \n   @Override\n-  public Gas cost(final MessageFrame frame) {\n-    return gasCalculator().getSloadOperationGasCost();\n-  }\n+  public OperationResult execute(final MessageFrame frame, final EVM evm) {\n+    try {\n+      if (frame.getRemainingGas().compareTo(gasCost) < 0) {\n+        return oogResponse;\n+      }\n \n-  @Override\n-  public void execute(final MessageFrame frame) {\n-    final Bytes32 key = frame.popStackItem();\n+      final Bytes32 key = frame.popStackItem();\n+\n+      final Account account = frame.getWorldState().get(frame.getRecipientAddress());\n+      assert account != null : \"VM account should exist\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAzMDAzNA=="}, "originalCommit": {"oid": "488fa4d16207b13a37cb22ba4536ccf7df35ee5c"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjMxMzQ4OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/AbstractCallOperation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxODo1Njo1MFrOGuLjPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTozMjoxMFrOGuMqpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA3NjkyNQ==", "bodyText": "Can this ever be true?", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451076925", "createdAt": "2020-07-07T18:56:50Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/AbstractCallOperation.java", "diffHunk": "@@ -146,55 +150,89 @@ protected AbstractCallOperation(\n   protected abstract boolean isStatic(MessageFrame frame);\n \n   @Override\n-  public void execute(final MessageFrame frame) {\n-    frame.clearReturnData();\n-\n-    final Address to = to(frame);\n-    final Account contract = frame.getWorldState().get(to);\n-\n-    final Account account = frame.getWorldState().get(frame.getRecipientAddress());\n-    final Wei balance = account.getBalance();\n-    if (value(frame).compareTo(balance) > 0 || frame.getMessageStackDepth() >= 1024) {\n-      frame.expandMemory(inputDataOffset(frame).intValue(), inputDataLength(frame).intValue());\n-      frame.expandMemory(outputDataOffset(frame).intValue(), outputDataLength(frame).intValue());\n-      frame.incrementRemainingGas(gasAvailableForChildCall(frame));\n-      frame.popStackItems(getStackItemsConsumed());\n-      frame.pushStackItem(Bytes32.ZERO);\n-      return;\n+  public OperationResult execute(final MessageFrame frame, final EVM evm) {\n+    try {\n+      // manual check becasue some reads won't come until the \"complete\" step.\n+      if (frame.stackSize() < getStackItemsConsumed()) {\n+        return UNDERFLOW_RESPONSE;\n+      }\n+      final Optional<ExceptionalHaltReason> haltReason = exceptionalHaltCondition(frame, evm);\n+      if (haltReason.isPresent()) {\n+        return new OperationResult(Optional.empty(), haltReason);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e1b6bb44c2a4f8fd4e7cd77603d5542d364920c"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA5NTIwNg==", "bodyText": "CallOperation can have the exceptionalHaltCondition return an IllegalStateChange when in a static context with value.  I think I can get rid of this by having CallOperation check that first and then call the super.", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451095206", "createdAt": "2020-07-07T19:32:10Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/AbstractCallOperation.java", "diffHunk": "@@ -146,55 +150,89 @@ protected AbstractCallOperation(\n   protected abstract boolean isStatic(MessageFrame frame);\n \n   @Override\n-  public void execute(final MessageFrame frame) {\n-    frame.clearReturnData();\n-\n-    final Address to = to(frame);\n-    final Account contract = frame.getWorldState().get(to);\n-\n-    final Account account = frame.getWorldState().get(frame.getRecipientAddress());\n-    final Wei balance = account.getBalance();\n-    if (value(frame).compareTo(balance) > 0 || frame.getMessageStackDepth() >= 1024) {\n-      frame.expandMemory(inputDataOffset(frame).intValue(), inputDataLength(frame).intValue());\n-      frame.expandMemory(outputDataOffset(frame).intValue(), outputDataLength(frame).intValue());\n-      frame.incrementRemainingGas(gasAvailableForChildCall(frame));\n-      frame.popStackItems(getStackItemsConsumed());\n-      frame.pushStackItem(Bytes32.ZERO);\n-      return;\n+  public OperationResult execute(final MessageFrame frame, final EVM evm) {\n+    try {\n+      // manual check becasue some reads won't come until the \"complete\" step.\n+      if (frame.stackSize() < getStackItemsConsumed()) {\n+        return UNDERFLOW_RESPONSE;\n+      }\n+      final Optional<ExceptionalHaltReason> haltReason = exceptionalHaltCondition(frame, evm);\n+      if (haltReason.isPresent()) {\n+        return new OperationResult(Optional.empty(), haltReason);\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA3NjkyNQ=="}, "originalCommit": {"oid": "7e1b6bb44c2a4f8fd4e7cd77603d5542d364920c"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjMzODUyOnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/AbstractCallOperation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTowNDo0OVrOGuLzIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTozNjozMVrOGuMzNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MDk5NA==", "bodyText": "Could we make cost() just return an Optional?", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451080994", "createdAt": "2020-07-07T19:04:49Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/AbstractCallOperation.java", "diffHunk": "@@ -146,55 +150,89 @@ protected AbstractCallOperation(\n   protected abstract boolean isStatic(MessageFrame frame);\n \n   @Override\n-  public void execute(final MessageFrame frame) {\n-    frame.clearReturnData();\n-\n-    final Address to = to(frame);\n-    final Account contract = frame.getWorldState().get(to);\n-\n-    final Account account = frame.getWorldState().get(frame.getRecipientAddress());\n-    final Wei balance = account.getBalance();\n-    if (value(frame).compareTo(balance) > 0 || frame.getMessageStackDepth() >= 1024) {\n-      frame.expandMemory(inputDataOffset(frame).intValue(), inputDataLength(frame).intValue());\n-      frame.expandMemory(outputDataOffset(frame).intValue(), outputDataLength(frame).intValue());\n-      frame.incrementRemainingGas(gasAvailableForChildCall(frame));\n-      frame.popStackItems(getStackItemsConsumed());\n-      frame.pushStackItem(Bytes32.ZERO);\n-      return;\n+  public OperationResult execute(final MessageFrame frame, final EVM evm) {\n+    try {\n+      // manual check becasue some reads won't come until the \"complete\" step.\n+      if (frame.stackSize() < getStackItemsConsumed()) {\n+        return UNDERFLOW_RESPONSE;\n+      }\n+      final Optional<ExceptionalHaltReason> haltReason = exceptionalHaltCondition(frame, evm);\n+      if (haltReason.isPresent()) {\n+        return new OperationResult(Optional.empty(), haltReason);\n+      }\n+      final Gas cost = cost(frame);\n+      final Optional<Gas> optionalCost = Optional.ofNullable(cost);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e1b6bb44c2a4f8fd4e7cd77603d5542d364920c"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA5NzM5OA==", "bodyText": "We immediately use the unwrapped value of cost, and have a very large block executed if it is non null/present, so an ifPresent lambda would be inappropriate.  So that would be us wrapping, then unwrapping the value, then returning the wrapped value.  Having a plain Gas returned gets rid of the unwrapping step.", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451097398", "createdAt": "2020-07-07T19:36:31Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/AbstractCallOperation.java", "diffHunk": "@@ -146,55 +150,89 @@ protected AbstractCallOperation(\n   protected abstract boolean isStatic(MessageFrame frame);\n \n   @Override\n-  public void execute(final MessageFrame frame) {\n-    frame.clearReturnData();\n-\n-    final Address to = to(frame);\n-    final Account contract = frame.getWorldState().get(to);\n-\n-    final Account account = frame.getWorldState().get(frame.getRecipientAddress());\n-    final Wei balance = account.getBalance();\n-    if (value(frame).compareTo(balance) > 0 || frame.getMessageStackDepth() >= 1024) {\n-      frame.expandMemory(inputDataOffset(frame).intValue(), inputDataLength(frame).intValue());\n-      frame.expandMemory(outputDataOffset(frame).intValue(), outputDataLength(frame).intValue());\n-      frame.incrementRemainingGas(gasAvailableForChildCall(frame));\n-      frame.popStackItems(getStackItemsConsumed());\n-      frame.pushStackItem(Bytes32.ZERO);\n-      return;\n+  public OperationResult execute(final MessageFrame frame, final EVM evm) {\n+    try {\n+      // manual check becasue some reads won't come until the \"complete\" step.\n+      if (frame.stackSize() < getStackItemsConsumed()) {\n+        return UNDERFLOW_RESPONSE;\n+      }\n+      final Optional<ExceptionalHaltReason> haltReason = exceptionalHaltCondition(frame, evm);\n+      if (haltReason.isPresent()) {\n+        return new OperationResult(Optional.empty(), haltReason);\n+      }\n+      final Gas cost = cost(frame);\n+      final Optional<Gas> optionalCost = Optional.ofNullable(cost);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MDk5NA=="}, "originalCommit": {"oid": "7e1b6bb44c2a4f8fd4e7cd77603d5542d364920c"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjM4MzQ2OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/OperandStack.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOToxODoyOFrOGuMPKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTo0Mjo1MVrOGuM_zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4ODE3MA==", "bodyText": "i'm not sure but it seems like an indexoutofbound exception is needed here. this is what is used in line 120 of this class", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451088170", "createdAt": "2020-07-07T19:18:28Z", "author": {"login": "matkt"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/OperandStack.java", "diffHunk": "@@ -24,71 +26,128 @@\n  * <p>The operand stack is responsible for storing the current operands that the EVM can execute. It\n  * is assumed to have a fixed size.\n  */\n-public interface OperandStack {\n+public class OperandStack {\n \n-  /**\n-   * Returns the operand located at the offset from the top of the stack.\n-   *\n-   * @param offset the position relative to the top of the stack of the operand to return\n-   * @return the operand located at the specified offset\n-   * @throws IndexOutOfBoundsException if the offset is out of range (offset &lt; 0 || offset &gt;=\n-   *     {@link #size()})\n-   */\n-  Bytes32 get(int offset);\n+  private final Bytes32[] entries;\n \n-  /**\n-   * Removes the operand at the top of the stack.\n-   *\n-   * @return the operand removed from the top of the stack\n-   * @throws IllegalStateException if the stack is empty (e.g. a stack underflow occurs)\n-   */\n-  Bytes32 pop();\n+  private final int maxSize;\n+\n+  private int top;\n+\n+  public static class UnderflowException extends RuntimeException {\n+    // Don't create a stack trace since these are not \"errors\" per say but are using exceptions to\n+    // throw rare control flow conditions (EVM stack overflow) that are expected to be seen in\n+    // normal\n+    // operations.\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  public static class OverflowException extends RuntimeException {\n+    // Don't create a stack trace since these are not \"errors\" per say but are using exceptions to\n+    // throw rare control flow conditions (EVM stack overflow) that are expected to be seen in\n+    // normal\n+    // operations.\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  public OperandStack(final int maxSize) {\n+    if (maxSize < 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"max size (%d) must be non-negative\", maxSize));\n+    }\n+    this.entries = new Bytes32[maxSize];\n+    this.maxSize = maxSize;\n+    this.top = -1;\n+  }\n+\n+  public Bytes32 get(final int offset) {\n+    if (offset < 0 || offset >= size()) {\n+      throw new UnderflowException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e1b6bb44c2a4f8fd4e7cd77603d5542d364920c"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEwMDYyMg==", "bodyText": "The only times this exception was meaningful was when it was underflow related.  But it can be changed back, I just need to add a few more underflow checks in some key operations.", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451100622", "createdAt": "2020-07-07T19:42:51Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/OperandStack.java", "diffHunk": "@@ -24,71 +26,128 @@\n  * <p>The operand stack is responsible for storing the current operands that the EVM can execute. It\n  * is assumed to have a fixed size.\n  */\n-public interface OperandStack {\n+public class OperandStack {\n \n-  /**\n-   * Returns the operand located at the offset from the top of the stack.\n-   *\n-   * @param offset the position relative to the top of the stack of the operand to return\n-   * @return the operand located at the specified offset\n-   * @throws IndexOutOfBoundsException if the offset is out of range (offset &lt; 0 || offset &gt;=\n-   *     {@link #size()})\n-   */\n-  Bytes32 get(int offset);\n+  private final Bytes32[] entries;\n \n-  /**\n-   * Removes the operand at the top of the stack.\n-   *\n-   * @return the operand removed from the top of the stack\n-   * @throws IllegalStateException if the stack is empty (e.g. a stack underflow occurs)\n-   */\n-  Bytes32 pop();\n+  private final int maxSize;\n+\n+  private int top;\n+\n+  public static class UnderflowException extends RuntimeException {\n+    // Don't create a stack trace since these are not \"errors\" per say but are using exceptions to\n+    // throw rare control flow conditions (EVM stack overflow) that are expected to be seen in\n+    // normal\n+    // operations.\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  public static class OverflowException extends RuntimeException {\n+    // Don't create a stack trace since these are not \"errors\" per say but are using exceptions to\n+    // throw rare control flow conditions (EVM stack overflow) that are expected to be seen in\n+    // normal\n+    // operations.\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  public OperandStack(final int maxSize) {\n+    if (maxSize < 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"max size (%d) must be non-negative\", maxSize));\n+    }\n+    this.entries = new Bytes32[maxSize];\n+    this.maxSize = maxSize;\n+    this.top = -1;\n+  }\n+\n+  public Bytes32 get(final int offset) {\n+    if (offset < 0 || offset >= size()) {\n+      throw new UnderflowException();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4ODE3MA=="}, "originalCommit": {"oid": "7e1b6bb44c2a4f8fd4e7cd77603d5542d364920c"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjM4NTAyOnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/OperandStack.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOToxOTowMVrOGuMQLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMToxNDowM1rOGuP02g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4ODQzMQ==", "bodyText": "What do you think about using these in ReturnStack as well?", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451088431", "createdAt": "2020-07-07T19:19:01Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/OperandStack.java", "diffHunk": "@@ -24,71 +26,128 @@\n  * <p>The operand stack is responsible for storing the current operands that the EVM can execute. It\n  * is assumed to have a fixed size.\n  */\n-public interface OperandStack {\n+public class OperandStack {\n \n-  /**\n-   * Returns the operand located at the offset from the top of the stack.\n-   *\n-   * @param offset the position relative to the top of the stack of the operand to return\n-   * @return the operand located at the specified offset\n-   * @throws IndexOutOfBoundsException if the offset is out of range (offset &lt; 0 || offset &gt;=\n-   *     {@link #size()})\n-   */\n-  Bytes32 get(int offset);\n+  private final Bytes32[] entries;\n \n-  /**\n-   * Removes the operand at the top of the stack.\n-   *\n-   * @return the operand removed from the top of the stack\n-   * @throws IllegalStateException if the stack is empty (e.g. a stack underflow occurs)\n-   */\n-  Bytes32 pop();\n+  private final int maxSize;\n+\n+  private int top;\n+\n+  public static class UnderflowException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e1b6bb44c2a4f8fd4e7cd77603d5542d364920c"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEzMTE3Ng==", "bodyText": "Perhaps in a follow on PR.  If we pull the exceptions out I also want them to be checked since we are removing the callstack (for performance).  That way we either have to handle it or re-wrap it as a runnable.", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451131176", "createdAt": "2020-07-07T20:42:41Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/OperandStack.java", "diffHunk": "@@ -24,71 +26,128 @@\n  * <p>The operand stack is responsible for storing the current operands that the EVM can execute. It\n  * is assumed to have a fixed size.\n  */\n-public interface OperandStack {\n+public class OperandStack {\n \n-  /**\n-   * Returns the operand located at the offset from the top of the stack.\n-   *\n-   * @param offset the position relative to the top of the stack of the operand to return\n-   * @return the operand located at the specified offset\n-   * @throws IndexOutOfBoundsException if the offset is out of range (offset &lt; 0 || offset &gt;=\n-   *     {@link #size()})\n-   */\n-  Bytes32 get(int offset);\n+  private final Bytes32[] entries;\n \n-  /**\n-   * Removes the operand at the top of the stack.\n-   *\n-   * @return the operand removed from the top of the stack\n-   * @throws IllegalStateException if the stack is empty (e.g. a stack underflow occurs)\n-   */\n-  Bytes32 pop();\n+  private final int maxSize;\n+\n+  private int top;\n+\n+  public static class UnderflowException extends RuntimeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4ODQzMQ=="}, "originalCommit": {"oid": "7e1b6bb44c2a4f8fd4e7cd77603d5542d364920c"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0Njk3MA==", "bodyText": "Sure, if we don't do it in this PR, we should make an issue so we can revisit it at some point. Something like Unify Underflow and Overflow Signalling Across Stacks.", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451146970", "createdAt": "2020-07-07T21:14:03Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/OperandStack.java", "diffHunk": "@@ -24,71 +26,128 @@\n  * <p>The operand stack is responsible for storing the current operands that the EVM can execute. It\n  * is assumed to have a fixed size.\n  */\n-public interface OperandStack {\n+public class OperandStack {\n \n-  /**\n-   * Returns the operand located at the offset from the top of the stack.\n-   *\n-   * @param offset the position relative to the top of the stack of the operand to return\n-   * @return the operand located at the specified offset\n-   * @throws IndexOutOfBoundsException if the offset is out of range (offset &lt; 0 || offset &gt;=\n-   *     {@link #size()})\n-   */\n-  Bytes32 get(int offset);\n+  private final Bytes32[] entries;\n \n-  /**\n-   * Removes the operand at the top of the stack.\n-   *\n-   * @return the operand removed from the top of the stack\n-   * @throws IllegalStateException if the stack is empty (e.g. a stack underflow occurs)\n-   */\n-  Bytes32 pop();\n+  private final int maxSize;\n+\n+  private int top;\n+\n+  public static class UnderflowException extends RuntimeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4ODQzMQ=="}, "originalCommit": {"oid": "7e1b6bb44c2a4f8fd4e7cd77603d5542d364920c"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjQwMTM4OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/OperandStack.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOToyNDowN1rOGuMahA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTowMToxNlrOGuPcew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA5MTA3Ng==", "bodyText": "(optional) checkArgument", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451091076", "createdAt": "2020-07-07T19:24:07Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/OperandStack.java", "diffHunk": "@@ -24,71 +26,128 @@\n  * <p>The operand stack is responsible for storing the current operands that the EVM can execute. It\n  * is assumed to have a fixed size.\n  */\n-public interface OperandStack {\n+public class OperandStack {\n \n-  /**\n-   * Returns the operand located at the offset from the top of the stack.\n-   *\n-   * @param offset the position relative to the top of the stack of the operand to return\n-   * @return the operand located at the specified offset\n-   * @throws IndexOutOfBoundsException if the offset is out of range (offset &lt; 0 || offset &gt;=\n-   *     {@link #size()})\n-   */\n-  Bytes32 get(int offset);\n+  private final Bytes32[] entries;\n \n-  /**\n-   * Removes the operand at the top of the stack.\n-   *\n-   * @return the operand removed from the top of the stack\n-   * @throws IllegalStateException if the stack is empty (e.g. a stack underflow occurs)\n-   */\n-  Bytes32 pop();\n+  private final int maxSize;\n+\n+  private int top;\n+\n+  public static class UnderflowException extends RuntimeException {\n+    // Don't create a stack trace since these are not \"errors\" per say but are using exceptions to\n+    // throw rare control flow conditions (EVM stack overflow) that are expected to be seen in\n+    // normal\n+    // operations.\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  public static class OverflowException extends RuntimeException {\n+    // Don't create a stack trace since these are not \"errors\" per say but are using exceptions to\n+    // throw rare control flow conditions (EVM stack overflow) that are expected to be seen in\n+    // normal\n+    // operations.\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  public OperandStack(final int maxSize) {\n+    if (maxSize < 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"max size (%d) must be non-negative\", maxSize));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e1b6bb44c2a4f8fd4e7cd77603d5542d364920c"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0MDczMQ==", "bodyText": "done.", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451140731", "createdAt": "2020-07-07T21:01:16Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/OperandStack.java", "diffHunk": "@@ -24,71 +26,128 @@\n  * <p>The operand stack is responsible for storing the current operands that the EVM can execute. It\n  * is assumed to have a fixed size.\n  */\n-public interface OperandStack {\n+public class OperandStack {\n \n-  /**\n-   * Returns the operand located at the offset from the top of the stack.\n-   *\n-   * @param offset the position relative to the top of the stack of the operand to return\n-   * @return the operand located at the specified offset\n-   * @throws IndexOutOfBoundsException if the offset is out of range (offset &lt; 0 || offset &gt;=\n-   *     {@link #size()})\n-   */\n-  Bytes32 get(int offset);\n+  private final Bytes32[] entries;\n \n-  /**\n-   * Removes the operand at the top of the stack.\n-   *\n-   * @return the operand removed from the top of the stack\n-   * @throws IllegalStateException if the stack is empty (e.g. a stack underflow occurs)\n-   */\n-  Bytes32 pop();\n+  private final int maxSize;\n+\n+  private int top;\n+\n+  public static class UnderflowException extends RuntimeException {\n+    // Don't create a stack trace since these are not \"errors\" per say but are using exceptions to\n+    // throw rare control flow conditions (EVM stack overflow) that are expected to be seen in\n+    // normal\n+    // operations.\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  public static class OverflowException extends RuntimeException {\n+    // Don't create a stack trace since these are not \"errors\" per say but are using exceptions to\n+    // throw rare control flow conditions (EVM stack overflow) that are expected to be seen in\n+    // normal\n+    // operations.\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  public OperandStack(final int maxSize) {\n+    if (maxSize < 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"max size (%d) must be non-negative\", maxSize));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA5MTA3Ng=="}, "originalCommit": {"oid": "7e1b6bb44c2a4f8fd4e7cd77603d5542d364920c"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjQxOTY2OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/OperandStack.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOToyOTo1MlrOGuMmEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMjowNjoxN1rOGuRSfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA5NDAzMg==", "bodyText": "I think we just need to do the upper bounds check, right? Because we'll get the 0 one for free when we try to index.", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451094032", "createdAt": "2020-07-07T19:29:52Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/OperandStack.java", "diffHunk": "@@ -24,71 +26,128 @@\n  * <p>The operand stack is responsible for storing the current operands that the EVM can execute. It\n  * is assumed to have a fixed size.\n  */\n-public interface OperandStack {\n+public class OperandStack {\n \n-  /**\n-   * Returns the operand located at the offset from the top of the stack.\n-   *\n-   * @param offset the position relative to the top of the stack of the operand to return\n-   * @return the operand located at the specified offset\n-   * @throws IndexOutOfBoundsException if the offset is out of range (offset &lt; 0 || offset &gt;=\n-   *     {@link #size()})\n-   */\n-  Bytes32 get(int offset);\n+  private final Bytes32[] entries;\n \n-  /**\n-   * Removes the operand at the top of the stack.\n-   *\n-   * @return the operand removed from the top of the stack\n-   * @throws IllegalStateException if the stack is empty (e.g. a stack underflow occurs)\n-   */\n-  Bytes32 pop();\n+  private final int maxSize;\n+\n+  private int top;\n+\n+  public static class UnderflowException extends RuntimeException {\n+    // Don't create a stack trace since these are not \"errors\" per say but are using exceptions to\n+    // throw rare control flow conditions (EVM stack overflow) that are expected to be seen in\n+    // normal\n+    // operations.\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  public static class OverflowException extends RuntimeException {\n+    // Don't create a stack trace since these are not \"errors\" per say but are using exceptions to\n+    // throw rare control flow conditions (EVM stack overflow) that are expected to be seen in\n+    // normal\n+    // operations.\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  public OperandStack(final int maxSize) {\n+    if (maxSize < 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"max size (%d) must be non-negative\", maxSize));\n+    }\n+    this.entries = new Bytes32[maxSize];\n+    this.maxSize = maxSize;\n+    this.top = -1;\n+  }\n+\n+  public Bytes32 get(final int offset) {\n+    if (offset < 0 || offset >= size()) {\n+      throw new UnderflowException();\n+    }\n+\n+    return entries[top - offset];\n+  }\n+\n+  public Bytes32 pop() {\n+    if (top < 0) {\n+      throw new UnderflowException();\n+    }\n+\n+    final Bytes32 removed = entries[top];\n+    entries[top--] = null;\n+    return removed;\n+  }\n \n   /**\n    * Pops the specified number of operands from the stack.\n    *\n    * @param items the number of operands to pop off the stack\n    * @throws IllegalArgumentException if the items to pop is negative.\n-   * @throws IllegalStateException when the items to pop is greater than {@link #size()}\n+   * @throws UnderflowException when the items to pop is greater than {@link #size()}\n    */\n-  default void bulkPop(final int items) {\n+  void bulkPop(final int items) {\n     if (items < 0) {\n       throw new IllegalArgumentException(\n           String.format(\"requested number of items to bulk pop (%d) is negative\", items));\n     }\n     checkArgument(items > 0, \"number of items to pop must be greater than 0\");\n     if (items > size()) {\n-      throw new IllegalStateException(\n-          String.format(\"requested to bulk pop %d items off a stack of size %d\", items, size()));\n+      throw new UnderflowException();\n     }\n \n     for (int i = 0; i < items; ++i) {\n       pop();\n     }\n   }\n \n-  /**\n-   * Pushes the operand onto the stack.\n-   *\n-   * @param operand the operand to push on the stack\n-   * @throws IllegalStateException when the stack is at capacity (e.g. a stack overflow occurs)\n-   */\n-  public void push(Bytes32 operand);\n+  public void push(final Bytes32 operand) {\n+    final int nextTop = top + 1;\n+    if (nextTop == maxSize) {\n+      throw new OverflowException();\n+    }\n+    entries[nextTop] = operand;\n+    top = nextTop;\n+  }\n \n-  /**\n-   * Sets the ith item from the top of the stack to the value.\n-   *\n-   * @param index the position relative to the top of the stack to set\n-   * @param operand the new operand that replaces the operand at the current offset\n-   * @throws IndexOutOfBoundsException if the offset is out of range (offset &lt; 0 || offset &gt;=\n-   *     {@link #size()})\n-   */\n-  void set(int index, Bytes32 operand);\n+  public void set(final int offset, final Bytes32 operand) {\n+    if (offset < 0 || offset >= size()) {\n+      throw new IndexOutOfBoundsException();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e1b6bb44c2a4f8fd4e7cd77603d5542d364920c"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MDQ2OQ==", "bodyText": "Not quite.  The reference is [top - offset] and a negative offset would usually go into the \"dirty\" part of the stack past the top (when it doesn't go out fo the array, the rare cases it works properly).  So we need to check negative explicitly.", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451170469", "createdAt": "2020-07-07T22:05:06Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/OperandStack.java", "diffHunk": "@@ -24,71 +26,128 @@\n  * <p>The operand stack is responsible for storing the current operands that the EVM can execute. It\n  * is assumed to have a fixed size.\n  */\n-public interface OperandStack {\n+public class OperandStack {\n \n-  /**\n-   * Returns the operand located at the offset from the top of the stack.\n-   *\n-   * @param offset the position relative to the top of the stack of the operand to return\n-   * @return the operand located at the specified offset\n-   * @throws IndexOutOfBoundsException if the offset is out of range (offset &lt; 0 || offset &gt;=\n-   *     {@link #size()})\n-   */\n-  Bytes32 get(int offset);\n+  private final Bytes32[] entries;\n \n-  /**\n-   * Removes the operand at the top of the stack.\n-   *\n-   * @return the operand removed from the top of the stack\n-   * @throws IllegalStateException if the stack is empty (e.g. a stack underflow occurs)\n-   */\n-  Bytes32 pop();\n+  private final int maxSize;\n+\n+  private int top;\n+\n+  public static class UnderflowException extends RuntimeException {\n+    // Don't create a stack trace since these are not \"errors\" per say but are using exceptions to\n+    // throw rare control flow conditions (EVM stack overflow) that are expected to be seen in\n+    // normal\n+    // operations.\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  public static class OverflowException extends RuntimeException {\n+    // Don't create a stack trace since these are not \"errors\" per say but are using exceptions to\n+    // throw rare control flow conditions (EVM stack overflow) that are expected to be seen in\n+    // normal\n+    // operations.\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  public OperandStack(final int maxSize) {\n+    if (maxSize < 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"max size (%d) must be non-negative\", maxSize));\n+    }\n+    this.entries = new Bytes32[maxSize];\n+    this.maxSize = maxSize;\n+    this.top = -1;\n+  }\n+\n+  public Bytes32 get(final int offset) {\n+    if (offset < 0 || offset >= size()) {\n+      throw new UnderflowException();\n+    }\n+\n+    return entries[top - offset];\n+  }\n+\n+  public Bytes32 pop() {\n+    if (top < 0) {\n+      throw new UnderflowException();\n+    }\n+\n+    final Bytes32 removed = entries[top];\n+    entries[top--] = null;\n+    return removed;\n+  }\n \n   /**\n    * Pops the specified number of operands from the stack.\n    *\n    * @param items the number of operands to pop off the stack\n    * @throws IllegalArgumentException if the items to pop is negative.\n-   * @throws IllegalStateException when the items to pop is greater than {@link #size()}\n+   * @throws UnderflowException when the items to pop is greater than {@link #size()}\n    */\n-  default void bulkPop(final int items) {\n+  void bulkPop(final int items) {\n     if (items < 0) {\n       throw new IllegalArgumentException(\n           String.format(\"requested number of items to bulk pop (%d) is negative\", items));\n     }\n     checkArgument(items > 0, \"number of items to pop must be greater than 0\");\n     if (items > size()) {\n-      throw new IllegalStateException(\n-          String.format(\"requested to bulk pop %d items off a stack of size %d\", items, size()));\n+      throw new UnderflowException();\n     }\n \n     for (int i = 0; i < items; ++i) {\n       pop();\n     }\n   }\n \n-  /**\n-   * Pushes the operand onto the stack.\n-   *\n-   * @param operand the operand to push on the stack\n-   * @throws IllegalStateException when the stack is at capacity (e.g. a stack overflow occurs)\n-   */\n-  public void push(Bytes32 operand);\n+  public void push(final Bytes32 operand) {\n+    final int nextTop = top + 1;\n+    if (nextTop == maxSize) {\n+      throw new OverflowException();\n+    }\n+    entries[nextTop] = operand;\n+    top = nextTop;\n+  }\n \n-  /**\n-   * Sets the ith item from the top of the stack to the value.\n-   *\n-   * @param index the position relative to the top of the stack to set\n-   * @param operand the new operand that replaces the operand at the current offset\n-   * @throws IndexOutOfBoundsException if the offset is out of range (offset &lt; 0 || offset &gt;=\n-   *     {@link #size()})\n-   */\n-  void set(int index, Bytes32 operand);\n+  public void set(final int offset, final Bytes32 operand) {\n+    if (offset < 0 || offset >= size()) {\n+      throw new IndexOutOfBoundsException();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA5NDAzMg=="}, "originalCommit": {"oid": "7e1b6bb44c2a4f8fd4e7cd77603d5542d364920c"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MDk0MQ==", "bodyText": "Ahh, got it.", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451170941", "createdAt": "2020-07-07T22:06:17Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/OperandStack.java", "diffHunk": "@@ -24,71 +26,128 @@\n  * <p>The operand stack is responsible for storing the current operands that the EVM can execute. It\n  * is assumed to have a fixed size.\n  */\n-public interface OperandStack {\n+public class OperandStack {\n \n-  /**\n-   * Returns the operand located at the offset from the top of the stack.\n-   *\n-   * @param offset the position relative to the top of the stack of the operand to return\n-   * @return the operand located at the specified offset\n-   * @throws IndexOutOfBoundsException if the offset is out of range (offset &lt; 0 || offset &gt;=\n-   *     {@link #size()})\n-   */\n-  Bytes32 get(int offset);\n+  private final Bytes32[] entries;\n \n-  /**\n-   * Removes the operand at the top of the stack.\n-   *\n-   * @return the operand removed from the top of the stack\n-   * @throws IllegalStateException if the stack is empty (e.g. a stack underflow occurs)\n-   */\n-  Bytes32 pop();\n+  private final int maxSize;\n+\n+  private int top;\n+\n+  public static class UnderflowException extends RuntimeException {\n+    // Don't create a stack trace since these are not \"errors\" per say but are using exceptions to\n+    // throw rare control flow conditions (EVM stack overflow) that are expected to be seen in\n+    // normal\n+    // operations.\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  public static class OverflowException extends RuntimeException {\n+    // Don't create a stack trace since these are not \"errors\" per say but are using exceptions to\n+    // throw rare control flow conditions (EVM stack overflow) that are expected to be seen in\n+    // normal\n+    // operations.\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  public OperandStack(final int maxSize) {\n+    if (maxSize < 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"max size (%d) must be non-negative\", maxSize));\n+    }\n+    this.entries = new Bytes32[maxSize];\n+    this.maxSize = maxSize;\n+    this.top = -1;\n+  }\n+\n+  public Bytes32 get(final int offset) {\n+    if (offset < 0 || offset >= size()) {\n+      throw new UnderflowException();\n+    }\n+\n+    return entries[top - offset];\n+  }\n+\n+  public Bytes32 pop() {\n+    if (top < 0) {\n+      throw new UnderflowException();\n+    }\n+\n+    final Bytes32 removed = entries[top];\n+    entries[top--] = null;\n+    return removed;\n+  }\n \n   /**\n    * Pops the specified number of operands from the stack.\n    *\n    * @param items the number of operands to pop off the stack\n    * @throws IllegalArgumentException if the items to pop is negative.\n-   * @throws IllegalStateException when the items to pop is greater than {@link #size()}\n+   * @throws UnderflowException when the items to pop is greater than {@link #size()}\n    */\n-  default void bulkPop(final int items) {\n+  void bulkPop(final int items) {\n     if (items < 0) {\n       throw new IllegalArgumentException(\n           String.format(\"requested number of items to bulk pop (%d) is negative\", items));\n     }\n     checkArgument(items > 0, \"number of items to pop must be greater than 0\");\n     if (items > size()) {\n-      throw new IllegalStateException(\n-          String.format(\"requested to bulk pop %d items off a stack of size %d\", items, size()));\n+      throw new UnderflowException();\n     }\n \n     for (int i = 0; i < items; ++i) {\n       pop();\n     }\n   }\n \n-  /**\n-   * Pushes the operand onto the stack.\n-   *\n-   * @param operand the operand to push on the stack\n-   * @throws IllegalStateException when the stack is at capacity (e.g. a stack overflow occurs)\n-   */\n-  public void push(Bytes32 operand);\n+  public void push(final Bytes32 operand) {\n+    final int nextTop = top + 1;\n+    if (nextTop == maxSize) {\n+      throw new OverflowException();\n+    }\n+    entries[nextTop] = operand;\n+    top = nextTop;\n+  }\n \n-  /**\n-   * Sets the ith item from the top of the stack to the value.\n-   *\n-   * @param index the position relative to the top of the stack to set\n-   * @param operand the new operand that replaces the operand at the current offset\n-   * @throws IndexOutOfBoundsException if the offset is out of range (offset &lt; 0 || offset &gt;=\n-   *     {@link #size()})\n-   */\n-  void set(int index, Bytes32 operand);\n+  public void set(final int offset, final Bytes32 operand) {\n+    if (offset < 0 || offset >= size()) {\n+      throw new IndexOutOfBoundsException();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA5NDAzMg=="}, "originalCommit": {"oid": "7e1b6bb44c2a4f8fd4e7cd77603d5542d364920c"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjQzMjk1OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/operations/AbstractFixedCostOperation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTozNDowOVrOGuMuXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMjo0MzowMlrOGuSH6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA5NjE1OQ==", "bodyText": "Just to make the code a bit more newbie friendly, I think we should rename oogResponse everywhere to outOfGasResponse.", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451096159", "createdAt": "2020-07-07T19:34:09Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/operations/AbstractFixedCostOperation.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.vm.operations;\n+\n+import org.hyperledger.besu.ethereum.core.Gas;\n+import org.hyperledger.besu.ethereum.vm.AbstractOperation;\n+import org.hyperledger.besu.ethereum.vm.ExceptionalHaltReason;\n+import org.hyperledger.besu.ethereum.vm.GasCalculator;\n+\n+import java.util.Optional;\n+\n+abstract class AbstractFixedCostOperation extends AbstractOperation {\n+\n+  protected final OperationResult successResponse;\n+  protected final OperationResult oogResponse;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e1b6bb44c2a4f8fd4e7cd77603d5542d364920c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE4NDYxNw==", "bodyText": "done", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451184617", "createdAt": "2020-07-07T22:43:02Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/operations/AbstractFixedCostOperation.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.vm.operations;\n+\n+import org.hyperledger.besu.ethereum.core.Gas;\n+import org.hyperledger.besu.ethereum.vm.AbstractOperation;\n+import org.hyperledger.besu.ethereum.vm.ExceptionalHaltReason;\n+import org.hyperledger.besu.ethereum.vm.GasCalculator;\n+\n+import java.util.Optional;\n+\n+abstract class AbstractFixedCostOperation extends AbstractOperation {\n+\n+  protected final OperationResult successResponse;\n+  protected final OperationResult oogResponse;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA5NjE1OQ=="}, "originalCommit": {"oid": "7e1b6bb44c2a4f8fd4e7cd77603d5542d364920c"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjQ2ODU1OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/operations/AndOperation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTo0NTozNFrOGuNFSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMjo0Mjo1NlrOGuSH0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEwMjAyNQ==", "bodyText": "Do you think it'd be worth it to do all of this checking one layer up? We can have execute delegate to an executeOverflowUnderflowUnchecked that each operation implements. It would mean that we were wrapping things that can't over or underflow with the exception handlers but I think it's a small price to pay for that not being a potential slip-of-the-mind for a future opcode.", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451102025", "createdAt": "2020-07-07T19:45:34Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/operations/AndOperation.java", "diffHunk": "@@ -14,31 +14,38 @@\n  */\n package org.hyperledger.besu.ethereum.vm.operations;\n \n-import org.hyperledger.besu.ethereum.core.Gas;\n-import org.hyperledger.besu.ethereum.vm.AbstractOperation;\n+import org.hyperledger.besu.ethereum.vm.EVM;\n import org.hyperledger.besu.ethereum.vm.GasCalculator;\n import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.vm.OperandStack.OverflowException;\n+import org.hyperledger.besu.ethereum.vm.OperandStack.UnderflowException;\n \n import org.apache.tuweni.units.bigints.UInt256;\n \n-public class AndOperation extends AbstractOperation {\n+public class AndOperation extends AbstractFixedCostOperation {\n \n   public AndOperation(final GasCalculator gasCalculator) {\n-    super(0x16, \"AND\", 2, 1, false, 1, gasCalculator);\n+    super(0x16, \"AND\", 2, 1, false, 1, gasCalculator, gasCalculator.getVeryLowTierGasCost());\n   }\n \n   @Override\n-  public Gas cost(final MessageFrame frame) {\n-    return gasCalculator().getVeryLowTierGasCost();\n-  }\n-\n-  @Override\n-  public void execute(final MessageFrame frame) {\n-    final UInt256 value0 = UInt256.fromBytes(frame.popStackItem());\n-    final UInt256 value1 = UInt256.fromBytes(frame.popStackItem());\n-\n-    final UInt256 result = value0.and(value1);\n-\n-    frame.pushStackItem(result.toBytes());\n+  public OperationResult execute(final MessageFrame frame, final EVM evm) {\n+    try {\n+      if (frame.getRemainingGas().compareTo(gasCost) < 0) {\n+        return oogResponse;\n+      }\n+\n+      final UInt256 value0 = UInt256.fromBytes(frame.popStackItem());\n+      final UInt256 value1 = UInt256.fromBytes(frame.popStackItem());\n+\n+      final UInt256 result = value0.and(value1);\n+      frame.pushStackItem(result.toBytes());\n+\n+      return successResponse;\n+    } catch (final UnderflowException ue) {\n+      return UNDERFLOW_RESPONSE;\n+    } catch (final OverflowException oe) {\n+      return OVERFLOW_RESPONSE;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e1b6bb44c2a4f8fd4e7cd77603d5542d364920c"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE4NDU5Mg==", "bodyText": "Let's give it a try.   It also moves us into net negative lines territory", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451184592", "createdAt": "2020-07-07T22:42:56Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/operations/AndOperation.java", "diffHunk": "@@ -14,31 +14,38 @@\n  */\n package org.hyperledger.besu.ethereum.vm.operations;\n \n-import org.hyperledger.besu.ethereum.core.Gas;\n-import org.hyperledger.besu.ethereum.vm.AbstractOperation;\n+import org.hyperledger.besu.ethereum.vm.EVM;\n import org.hyperledger.besu.ethereum.vm.GasCalculator;\n import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.vm.OperandStack.OverflowException;\n+import org.hyperledger.besu.ethereum.vm.OperandStack.UnderflowException;\n \n import org.apache.tuweni.units.bigints.UInt256;\n \n-public class AndOperation extends AbstractOperation {\n+public class AndOperation extends AbstractFixedCostOperation {\n \n   public AndOperation(final GasCalculator gasCalculator) {\n-    super(0x16, \"AND\", 2, 1, false, 1, gasCalculator);\n+    super(0x16, \"AND\", 2, 1, false, 1, gasCalculator, gasCalculator.getVeryLowTierGasCost());\n   }\n \n   @Override\n-  public Gas cost(final MessageFrame frame) {\n-    return gasCalculator().getVeryLowTierGasCost();\n-  }\n-\n-  @Override\n-  public void execute(final MessageFrame frame) {\n-    final UInt256 value0 = UInt256.fromBytes(frame.popStackItem());\n-    final UInt256 value1 = UInt256.fromBytes(frame.popStackItem());\n-\n-    final UInt256 result = value0.and(value1);\n-\n-    frame.pushStackItem(result.toBytes());\n+  public OperationResult execute(final MessageFrame frame, final EVM evm) {\n+    try {\n+      if (frame.getRemainingGas().compareTo(gasCost) < 0) {\n+        return oogResponse;\n+      }\n+\n+      final UInt256 value0 = UInt256.fromBytes(frame.popStackItem());\n+      final UInt256 value1 = UInt256.fromBytes(frame.popStackItem());\n+\n+      final UInt256 result = value0.and(value1);\n+      frame.pushStackItem(result.toBytes());\n+\n+      return successResponse;\n+    } catch (final UnderflowException ue) {\n+      return UNDERFLOW_RESPONSE;\n+    } catch (final OverflowException oe) {\n+      return OVERFLOW_RESPONSE;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEwMjAyNQ=="}, "originalCommit": {"oid": "7e1b6bb44c2a4f8fd4e7cd77603d5542d364920c"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjUyNDcwOnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/test/java/org/hyperledger/besu/ethereum/vm/VMReferenceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDowMjozMlrOGuNoVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMjo0MzoyOFrOGuSIfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExMDk5Ng==", "bodyText": "Why did we have so many more tests ignored before and why are these still ignored?", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451110996", "createdAt": "2020-07-07T20:02:32Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/test/java/org/hyperledger/besu/ethereum/vm/VMReferenceTest.java", "diffHunk": "@@ -65,53 +68,24 @@\n   // fully test these operations and the mocking does not add much value.\n   // Additionally, the GeneralStateTests provide coverage of these\n   // operations so the proper functionality does get tested somewhere.\n-  private static final String[] BLACKLISTED_TESTS = {\n-    \"balance0\",\n-    \"balanceAddressInputTooBig\",\n-    \"balanceCaller3\",\n-    \"balanceAddressInputTooBigRightMyAddress\",\n-    \"ExtCodeSizeAddressInputTooBigRightMyAddress\",\n-    \"env1\",\n-    \"extcodecopy0AddressTooBigRight\",\n-    \"PostToNameRegistrator0\",\n-    \"CallToReturn1\",\n-    \"CallRecursiveBomb0\",\n-    \"createNameRegistratorValueTooHigh\",\n-    \"suicideNotExistingAccount\",\n-    \"callstatelessToReturn1\",\n-    \"CallRecursiveBomb1\",\n-    \"ABAcallsSuicide1\",\n-    \"suicideSendEtherToMe\",\n-    \"suicide0\",\n-    \"CallToNameRegistrator0\",\n-    \"callstatelessToNameRegistrator0\",\n-    \"PostToReturn1\",\n-    \"callcodeToReturn1\",\n-    \"ABAcalls0\",\n-    \"CallRecursiveBomb2\",\n-    \"CallRecursiveBomb3\",\n-    \"ABAcallsSuicide0\",\n-    \"callcodeToNameRegistrator0\",\n-    \"CallToPrecompiledContract\",\n-    \"createNameRegistrator\"\n+  private static final String[] IGNORED_TESTS = {\n+    \"push32AndSuicide\", \"suicide\", \"suicide0\", \"suicideNotExistingAccount\", \"suicideSendEtherToMe\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "631da9cde1b2315f6016a84c36781c65f6fd1cf6"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE4NDc2Ng==", "bodyText": "Self descruct tests are known to be problematic for all clients.", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451184766", "createdAt": "2020-07-07T22:43:28Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/test/java/org/hyperledger/besu/ethereum/vm/VMReferenceTest.java", "diffHunk": "@@ -65,53 +68,24 @@\n   // fully test these operations and the mocking does not add much value.\n   // Additionally, the GeneralStateTests provide coverage of these\n   // operations so the proper functionality does get tested somewhere.\n-  private static final String[] BLACKLISTED_TESTS = {\n-    \"balance0\",\n-    \"balanceAddressInputTooBig\",\n-    \"balanceCaller3\",\n-    \"balanceAddressInputTooBigRightMyAddress\",\n-    \"ExtCodeSizeAddressInputTooBigRightMyAddress\",\n-    \"env1\",\n-    \"extcodecopy0AddressTooBigRight\",\n-    \"PostToNameRegistrator0\",\n-    \"CallToReturn1\",\n-    \"CallRecursiveBomb0\",\n-    \"createNameRegistratorValueTooHigh\",\n-    \"suicideNotExistingAccount\",\n-    \"callstatelessToReturn1\",\n-    \"CallRecursiveBomb1\",\n-    \"ABAcallsSuicide1\",\n-    \"suicideSendEtherToMe\",\n-    \"suicide0\",\n-    \"CallToNameRegistrator0\",\n-    \"callstatelessToNameRegistrator0\",\n-    \"PostToReturn1\",\n-    \"callcodeToReturn1\",\n-    \"ABAcalls0\",\n-    \"CallRecursiveBomb2\",\n-    \"CallRecursiveBomb3\",\n-    \"ABAcallsSuicide0\",\n-    \"callcodeToNameRegistrator0\",\n-    \"CallToPrecompiledContract\",\n-    \"createNameRegistrator\"\n+  private static final String[] IGNORED_TESTS = {\n+    \"push32AndSuicide\", \"suicide\", \"suicide0\", \"suicideNotExistingAccount\", \"suicideSendEtherToMe\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExMDk5Ng=="}, "originalCommit": {"oid": "631da9cde1b2315f6016a84c36781c65f6fd1cf6"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjUyNTU1OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/test/java/org/hyperledger/besu/ethereum/vm/VMReferenceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDowMjo1M1rOGuNo9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMjo1NjozMFrOGuSZpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExMTE1OQ==", "bodyText": "commented out code", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451111159", "createdAt": "2020-07-07T20:02:53Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/test/java/org/hyperledger/besu/ethereum/vm/VMReferenceTest.java", "diffHunk": "@@ -157,15 +131,15 @@ protected void runTest() {\n     // This is normally set inside the containing message executing the code.\n     frame.setState(MessageFrame.State.CODE_EXECUTING);\n \n-    try {\n-      protocolSpec.getEvm().runToHalt(frame, OperationTracer.NO_TRACING);\n-    } catch (final ExceptionalHaltException ehe) {\n-      if (!spec.isExceptionHaltExpected())\n-        System.err.println(\n-            String.format(\n-                \"Test %s incurred in an exceptional halt exception for reasons: %s.\",\n-                name, ehe.getReasons()));\n-    }\n+    //    try {\n+    protocolSpec.getEvm().runToHalt(frame, OperationTracer.NO_TRACING);\n+    //    } catch (final ExceptionalHaltException ehe) {\n+    //      if (!spec.isExceptionHaltExpected())\n+    //        System.err.println(\n+    //            String.format(\n+    //                \"Test %s incurred in an exceptional halt exception for reasons: %s.\",\n+    //                name, ehe.getReasons()));\n+    //    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "631da9cde1b2315f6016a84c36781c65f6fd1cf6"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE4OTE1Ng==", "bodyText": "deleted", "url": "https://github.com/hyperledger/besu/pull/1192#discussion_r451189156", "createdAt": "2020-07-07T22:56:30Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/test/java/org/hyperledger/besu/ethereum/vm/VMReferenceTest.java", "diffHunk": "@@ -157,15 +131,15 @@ protected void runTest() {\n     // This is normally set inside the containing message executing the code.\n     frame.setState(MessageFrame.State.CODE_EXECUTING);\n \n-    try {\n-      protocolSpec.getEvm().runToHalt(frame, OperationTracer.NO_TRACING);\n-    } catch (final ExceptionalHaltException ehe) {\n-      if (!spec.isExceptionHaltExpected())\n-        System.err.println(\n-            String.format(\n-                \"Test %s incurred in an exceptional halt exception for reasons: %s.\",\n-                name, ehe.getReasons()));\n-    }\n+    //    try {\n+    protocolSpec.getEvm().runToHalt(frame, OperationTracer.NO_TRACING);\n+    //    } catch (final ExceptionalHaltException ehe) {\n+    //      if (!spec.isExceptionHaltExpected())\n+    //        System.err.println(\n+    //            String.format(\n+    //                \"Test %s incurred in an exceptional halt exception for reasons: %s.\",\n+    //                name, ehe.getReasons()));\n+    //    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExMTE1OQ=="}, "originalCommit": {"oid": "631da9cde1b2315f6016a84c36781c65f6fd1cf6"}, "originalPosition": 105}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 854, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}