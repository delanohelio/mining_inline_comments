{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MDE0MDcz", "number": 1046, "title": "Move EVM memory to a flat bytes array", "bodyText": "Performance measurements have indicated that the list of Bytes32 for\nmemory is not performant enough. Moving to a byte array reduces wrapper\nobject thrashing as well as simplifying cross-word boundary logic (there\nare no boundaries).\nSigned-off-by: Danno Ferrin danno.ferrin@gmail.com", "createdAt": "2020-06-04T18:26:46Z", "url": "https://github.com/hyperledger/besu/pull/1046", "merged": true, "mergeCommit": {"oid": "dc56bfe88c6eaefc4533f0ceaaeaeed62c445415"}, "closed": true, "closedAt": "2020-06-04T23:44:03Z", "author": {"login": "shemnon"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcoCVShgH2gAyNDI4MDE0MDczOmNkNGUyMWUyMTlkYTU3M2M3OTY4NWZiNzc0MzZkMjc1NmRhZjdlODM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcoFIoEAFqTQyNDg1NjA1OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "cd4e21e219da573c79685fb77436d2756daf7e83", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/cd4e21e219da573c79685fb77436d2756daf7e83", "committedDate": "2020-06-04T18:26:07Z", "message": "Move EVM memory to a flat bytes array\n\nPerformance measurements have indicated that the list of Bytes32 for\nmemory is not performant enough. Moving to a byte array reduces wrapper\nobject thrashing as well as simplifying cross-word boundary logic (there\nare no boundaries).\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4db40c816980e52fbea62100d86ff158220a05bf", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/4db40c816980e52fbea62100d86ff158220a05bf", "committedDate": "2020-06-04T18:26:52Z", "message": "Merge branch 'master' into bytesMemory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3109763a41f8c9e4ecdcc8811f897a9c4996610", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/e3109763a41f8c9e4ecdcc8811f897a9c4996610", "committedDate": "2020-06-04T18:35:48Z", "message": "spotless\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8af503bfe8a56a116812e7f491276cf931d1c65d", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/8af503bfe8a56a116812e7f491276cf931d1c65d", "committedDate": "2020-06-04T21:05:19Z", "message": "tracing likes this copy method better\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0ODE4NDUz", "url": "https://github.com/hyperledger/besu/pull/1046#pullrequestreview-424818453", "createdAt": "2020-06-04T20:51:43Z", "commit": {"oid": "e3109763a41f8c9e4ecdcc8811f897a9c4996610"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDo1MTo0M1rOGfXVww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMToxNDoyMFrOGfYGjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0MTQ0Mw==", "bodyText": "Can we make this int just like we did in  asByteIndex?", "url": "https://github.com/hyperledger/besu/pull/1046#discussion_r435541443", "createdAt": "2020-06-04T20:51:43Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/Memory.java", "diffHunk": "@@ -228,7 +195,7 @@ public int hashCode() {\n    * @return The current number of active bytes stored in memory.\n    */\n   long getActiveBytes() {\n-    return (long) data.size() * Bytes32.SIZE;\n+    return (long) data.length;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3109763a41f8c9e4ecdcc8811f897a9c4996610"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0MTkwOQ==", "bodyText": "Oh cool, I didn't know about this method.", "url": "https://github.com/hyperledger/besu/pull/1046#discussion_r435541909", "createdAt": "2020-06-04T20:52:36Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/Memory.java", "diffHunk": "@@ -190,15 +159,13 @@ void ensureCapacityForBytes(final long address, final int numBytes) {\n    * @param newActiveWords The new number of active words to expand to.\n    */\n   private void maybeExpandCapacity(final int newActiveWords) {\n-    if (data.size() >= newActiveWords) return;\n+    if (dataSize256 >= newActiveWords) return;\n \n     // Require full capacity to guarantee we don't resize more than once.\n-    data.ensureCapacity(newActiveWords);\n-    final int toAdd = newActiveWords - data.size();\n-    for (int i = 0; i < toAdd; i++) {\n-      data.add(MutableBytes32.create());\n-    }\n-    this.activeWords = UInt256.valueOf(data.size());\n+    final byte[] newData = new byte[newActiveWords * Bytes32.SIZE];\n+    System.arraycopy(data, 0, newData, 0, data.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3109763a41f8c9e4ecdcc8811f897a9c4996610"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0MjIyMQ==", "bodyText": "I love seeing so much deleted code!", "url": "https://github.com/hyperledger/besu/pull/1046#discussion_r435542221", "createdAt": "2020-06-04T20:53:04Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/Memory.java", "diffHunk": "@@ -258,42 +225,10 @@ public Bytes getBytes(final UInt256 location, final UInt256 numBytes) {\n       return Bytes.EMPTY;\n     }\n \n-    final long start = asByteIndex(location);\n+    final int start = asByteIndex(location);\n \n     ensureCapacityForBytes(start, length);\n-\n-    // Index of last byte to set.\n-    final long end = start + length - 1;\n-\n-    final int startWord = wordForByte(start);\n-    final int idxInStart = indexInWord(start);\n-    final int endWord = wordForByte(end);\n-    final int idxInEnd = indexInWord(end);\n-\n-    if (startWord == endWord) {\n-      // Bytes within a word, fast-path.\n-      final Bytes bytes = data.get(startWord);\n-      return idxInStart == 0 && length == Bytes32.SIZE\n-          //          ? bytes.copy()\n-          //          : bytes.slice(idxInStart, length).copy();\n-          ? bytes\n-          : bytes.slice(idxInStart, length);\n-    }\n-\n-    // Spans multiple word, slower path.\n-    final int bytesInStartWord = Bytes32.SIZE - idxInStart;\n-    final int bytesInEndWord = idxInEnd + 1;\n-\n-    final MutableBytes result = MutableBytes.create(length);\n-    int resultIdx = 0;\n-    data.get(startWord).slice(idxInStart).copyTo(result, resultIdx);\n-    resultIdx += bytesInStartWord;\n-    for (int i = startWord + 1; i < endWord; i++) {\n-      data.get(i).copyTo(result, resultIdx);\n-      resultIdx += Bytes32.SIZE;\n-    }\n-    data.get(endWord).slice(0, bytesInEndWord).copyTo(result, resultIdx);\n-    return result;\n+    return Bytes.wrap(data, location.intValue(), numBytes.intValue()).copy();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3109763a41f8c9e4ecdcc8811f897a9c4996610"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0NzUwMA==", "bodyText": "Is MAX_BYTES different now that we are using a straight byte[] instead of ArrayList?", "url": "https://github.com/hyperledger/besu/pull/1046#discussion_r435547500", "createdAt": "2020-06-04T21:03:27Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/Memory.java", "diffHunk": "@@ -98,9 +72,9 @@ private void checkByteIndex(final long v) {\n     if (v < 0 || v >= MAX_BYTES) throw overflow(v);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3109763a41f8c9e4ecdcc8811f897a9c4996610"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0NzgxMg==", "bodyText": "Should we use asByteIndex here?", "url": "https://github.com/hyperledger/besu/pull/1046#discussion_r435547812", "createdAt": "2020-06-04T21:04:02Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/Memory.java", "diffHunk": "@@ -341,72 +276,26 @@ public void setBytes(\n    * @param location the location in memory at which to start copying the bytes of {@code value}.\n    * @param numBytes the number of bytes to set in memory. Note that this value may differ from\n    *     {@code value.size()}: if {@code numBytes < value.size()} bytes, only {@code numBytes} will\n-   *     be copied from {@code value}; if {@code numBytes < value.size()}, then only the bytes in\n+   *     be copied from {@code value}; if {@code numBytes > value.size()}, then only the bytes in\n    *     {@code value} will be copied, but the memory will be expanded if necessary to cover {@code\n    *     numBytes} (in other words, {@link #getActiveWords()} will return a value consistent with\n    *     having set {@code numBytes} bytes, even if less than that have been concretely set due to\n    *     {@code value} being smaller).\n    * @param taintedValue the bytes to copy to memory from {@code location}.\n    */\n   public void setBytes(final UInt256 location, final UInt256 numBytes, final Bytes taintedValue) {\n-    if (numBytes.isZero()) {\n-      return;\n-    }\n-\n-    final long start = asByteIndex(location);\n-    final int length = asByteLength(numBytes);\n-\n-    ensureCapacityForBytes(start, length);\n-\n-    // We've properly expanded memory as needed. We now have simply have to copy the\n-    // min(length, value.size()) first bytes of value and clear any bytes that exceed value's length\n-    if (taintedValue.isEmpty()) {\n-      clearBytes(location, numBytes);\n-      return;\n-    }\n-    final Bytes value;\n-    if (taintedValue.size() > length) {\n-      value = taintedValue.slice(0, length);\n-    } else if (taintedValue.size() < length) {\n-      value = taintedValue;\n-      clearBytes(location.add(taintedValue.size()), numBytes.subtract(taintedValue.size()));\n-    } else {\n-      value = taintedValue;\n-    }\n-\n-    // Index of last byte to set.\n-    final long end = start + value.size() - 1;\n-\n-    final int startWord = wordForByte(start);\n-    final int idxInStart = indexInWord(start);\n-    final int endWord = wordForByte(end);\n-\n-    if (startWord == endWord) {\n-      // Bytes within a word, fast-path.\n-      final MutableBytes mb = data.get(startWord).mutableCopy();\n-\n-      value.copyTo(mb, idxInStart);\n-      data.set(startWord, (Bytes32) mb.copy());\n-      return;\n-    }\n-\n-    // Spans multiple word, slower path.\n-    final int bytesInStartWord = Bytes32.SIZE - idxInStart;\n-\n-    int valueIdx = 0;\n-    final MutableBytes startMutable = data.get(startWord).mutableCopy();\n-    value.slice(valueIdx, bytesInStartWord).copyTo(startMutable, idxInStart);\n-    data.set(startWord, (Bytes32) startMutable.copy());\n-    valueIdx += bytesInStartWord;\n-    for (int i = startWord + 1; i < endWord; i++) {\n-      final MutableBytes mb = data.get(i).mutableCopy();\n-      value.slice(valueIdx, Bytes32.SIZE).copyTo(mb);\n-      data.set(i, (Bytes32) mb.copy());\n-      valueIdx += Bytes32.SIZE;\n+    final int copySize = numBytes.intValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3109763a41f8c9e4ecdcc8811f897a9c4996610"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU1MzkzMg==", "bodyText": "Leaving this comment as a marker to myself to get back to understanding why we need this line.", "url": "https://github.com/hyperledger/besu/pull/1046#discussion_r435553932", "createdAt": "2020-06-04T21:14:20Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/Memory.java", "diffHunk": "@@ -341,72 +276,26 @@ public void setBytes(\n    * @param location the location in memory at which to start copying the bytes of {@code value}.\n    * @param numBytes the number of bytes to set in memory. Note that this value may differ from\n    *     {@code value.size()}: if {@code numBytes < value.size()} bytes, only {@code numBytes} will\n-   *     be copied from {@code value}; if {@code numBytes < value.size()}, then only the bytes in\n+   *     be copied from {@code value}; if {@code numBytes > value.size()}, then only the bytes in\n    *     {@code value} will be copied, but the memory will be expanded if necessary to cover {@code\n    *     numBytes} (in other words, {@link #getActiveWords()} will return a value consistent with\n    *     having set {@code numBytes} bytes, even if less than that have been concretely set due to\n    *     {@code value} being smaller).\n    * @param taintedValue the bytes to copy to memory from {@code location}.\n    */\n   public void setBytes(final UInt256 location, final UInt256 numBytes, final Bytes taintedValue) {\n-    if (numBytes.isZero()) {\n-      return;\n-    }\n-\n-    final long start = asByteIndex(location);\n-    final int length = asByteLength(numBytes);\n-\n-    ensureCapacityForBytes(start, length);\n-\n-    // We've properly expanded memory as needed. We now have simply have to copy the\n-    // min(length, value.size()) first bytes of value and clear any bytes that exceed value's length\n-    if (taintedValue.isEmpty()) {\n-      clearBytes(location, numBytes);\n-      return;\n-    }\n-    final Bytes value;\n-    if (taintedValue.size() > length) {\n-      value = taintedValue.slice(0, length);\n-    } else if (taintedValue.size() < length) {\n-      value = taintedValue;\n-      clearBytes(location.add(taintedValue.size()), numBytes.subtract(taintedValue.size()));\n-    } else {\n-      value = taintedValue;\n-    }\n-\n-    // Index of last byte to set.\n-    final long end = start + value.size() - 1;\n-\n-    final int startWord = wordForByte(start);\n-    final int idxInStart = indexInWord(start);\n-    final int endWord = wordForByte(end);\n-\n-    if (startWord == endWord) {\n-      // Bytes within a word, fast-path.\n-      final MutableBytes mb = data.get(startWord).mutableCopy();\n-\n-      value.copyTo(mb, idxInStart);\n-      data.set(startWord, (Bytes32) mb.copy());\n-      return;\n-    }\n-\n-    // Spans multiple word, slower path.\n-    final int bytesInStartWord = Bytes32.SIZE - idxInStart;\n-\n-    int valueIdx = 0;\n-    final MutableBytes startMutable = data.get(startWord).mutableCopy();\n-    value.slice(valueIdx, bytesInStartWord).copyTo(startMutable, idxInStart);\n-    data.set(startWord, (Bytes32) startMutable.copy());\n-    valueIdx += bytesInStartWord;\n-    for (int i = startWord + 1; i < endWord; i++) {\n-      final MutableBytes mb = data.get(i).mutableCopy();\n-      value.slice(valueIdx, Bytes32.SIZE).copyTo(mb);\n-      data.set(i, (Bytes32) mb.copy());\n-      valueIdx += Bytes32.SIZE;\n+    final int copySize = numBytes.intValue();\n+    if (copySize > 0) {\n+      final int srcLength = taintedValue.size();\n+      final int locationInt = location.intValue();\n+      ensureCapacityForBytes(locationInt, copySize);\n+      if (srcLength >= copySize) {\n+        System.arraycopy(taintedValue.toArrayUnsafe(), 0, data, locationInt, copySize);\n+      } else {\n+        Arrays.fill(data, locationInt, locationInt + copySize, (byte) 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3109763a41f8c9e4ecdcc8811f897a9c4996610"}, "originalPosition": 282}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b5535d4dbb18fc5d2764bf648b8405f49201825", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/8b5535d4dbb18fc5d2764bf648b8405f49201825", "committedDate": "2020-06-04T21:30:58Z", "message": "boundary checking\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c31596a30998069076a6cde8e99123ec8cbbb389", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/c31596a30998069076a6cde8e99123ec8cbbb389", "committedDate": "2020-06-04T21:37:41Z", "message": "more boundary checking changes\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16c8a9986bd5918449595364aabc54e4527c5129", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/16c8a9986bd5918449595364aabc54e4527c5129", "committedDate": "2020-06-04T21:38:18Z", "message": "Merge branch 'master' into bytesMemory"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0ODU2MDU5", "url": "https://github.com/hyperledger/besu/pull/1046#pullrequestreview-424856059", "createdAt": "2020-06-04T21:42:00Z", "commit": {"oid": "16c8a9986bd5918449595364aabc54e4527c5129"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1572, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}