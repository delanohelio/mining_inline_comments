{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwNTQ0MTA1", "number": 675, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwNzoxODo0MFrODwSLTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzowMjoyMlrODxvSyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxOTU2MDQ1OnYy", "diffSide": "RIGHT", "path": "crypto/src/main/java/org/hyperledger/besu/crypto/LibSecp256k1.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwNzoxODo0MFrOGDMewA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwNzoxODo0MFrOGDMewA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAwMzM5Mg==", "bodyText": "Maybe an info or debug log statement in findInstance() would make sense, to let the user know that either native is or is not being used?", "url": "https://github.com/hyperledger/besu/pull/675#discussion_r406003392", "createdAt": "2020-04-09T07:18:40Z", "author": {"login": "CjHare"}, "path": "crypto/src/main/java/org/hyperledger/besu/crypto/LibSecp256k1.java", "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+package org.hyperledger.besu.crypto;\n+\n+import java.nio.ByteBuffer;\n+\n+import com.sun.jna.Callback;\n+import com.sun.jna.Library;\n+import com.sun.jna.Native;\n+import com.sun.jna.Pointer;\n+import com.sun.jna.Structure;\n+import com.sun.jna.Structure.FieldOrder;\n+import com.sun.jna.ptr.IntByReference;\n+import com.sun.jna.ptr.LongByReference;\n+import com.sun.jna.ptr.PointerByReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public interface LibSecp256k1 extends Library {\n+\n+  /* Flags to pass to secp256k1_context_create */\n+  public static final int SECP256K1_CONTEXT_VERIFY = 0x0101;\n+  public static final int SECP256K1_CONTEXT_SIGN = 0x0201;\n+\n+  /* Flag to pass to secp256k1_ec_pubkey_serialize. */\n+  public static final int SECP256K1_EC_UNCOMPRESSED = 0x0002;\n+\n+  static final LibSecp256k1 INSTANCE = findInstance();\n+  static final PointerByReference CONTEXT = createContext();\n+\n+  private static LibSecp256k1 findInstance() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d544dcac4aa8c0278cc3147b991fdaa85221abb5"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNDgxNjc0OnYy", "diffSide": "RIGHT", "path": "crypto/src/main/java/org/hyperledger/besu/crypto/SECP256K1.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzowMjoyMlrOGFYU_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNDozNToxMlrOGGUO-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5NDY1NA==", "bodyText": "Will this always return a present Optional? It seems like our implementation can return an empty Optional.", "url": "https://github.com/hyperledger/besu/pull/675#discussion_r408294654", "createdAt": "2020-04-14T17:02:22Z", "author": {"login": "RatanRSur"}, "path": "crypto/src/main/java/org/hyperledger/besu/crypto/SECP256K1.java", "diffHunk": "@@ -308,6 +336,99 @@ public static Bytes calculateECIESKeyAgreement(final PrivateKey privKey, final P\n     return Bytes.wrap(BigIntegers.asUnsignedByteArray(agree.getFieldSize(), z));\n   }\n \n+  private static Signature signNative(final Bytes32 dataHash, final KeyPair keyPair) {\n+    final LibSecp256k1.secp256k1_ecdsa_recoverable_signature signature =\n+        new secp256k1_ecdsa_recoverable_signature();\n+    // sign in internal form\n+    if (LibSecp256k1.INSTANCE.secp256k1_ecdsa_sign_recoverable(\n+            LibSecp256k1.CONTEXT,\n+            signature,\n+            dataHash.toArrayUnsafe(),\n+            keyPair.privateKey.getEncoded(),\n+            null,\n+            null)\n+        == 0) {\n+      throw new RuntimeException(\n+          \"Could not natively sign. Private Key is invalid or default nonce generation failed.\");\n+    }\n+\n+    // encode to compact form\n+    final ByteBuffer compactSig = ByteBuffer.allocate(64);\n+    final IntByReference recId = new IntByReference(0);\n+    LibSecp256k1.INSTANCE.secp256k1_ecdsa_recoverable_signature_serialize_compact(\n+        LibSecp256k1.CONTEXT, compactSig, recId, signature);\n+    compactSig.flip();\n+    final byte[] sig = compactSig.array();\n+\n+    // wrap in signature object\n+    final Bytes32 r = Bytes32.wrap(sig, 0);\n+    final Bytes32 s = Bytes32.wrap(sig, 32);\n+    return Signature.create(\n+        r.toUnsignedBigInteger(), s.toUnsignedBigInteger(), (byte) recId.getValue());\n+  }\n+\n+  private static boolean verifyNative(\n+      final Bytes data, final Signature signature, final PublicKey pub) {\n+\n+    // translate signature\n+    final LibSecp256k1.secp256k1_ecdsa_signature _signature = new secp256k1_ecdsa_signature();\n+    if (LibSecp256k1.INSTANCE.secp256k1_ecdsa_signature_parse_compact(\n+            LibSecp256k1.CONTEXT, _signature, signature.encodedBytes().toArrayUnsafe())\n+        == 0) {\n+      throw new IllegalArgumentException(\"Could not parse signature\");\n+    }\n+\n+    // translate key\n+    final LibSecp256k1.secp256k1_pubkey _pub = new secp256k1_pubkey();\n+    final Bytes encodedPubKey = Bytes.concatenate(Bytes.of(0x04), pub.getEncodedBytes());\n+    if (LibSecp256k1.INSTANCE.secp256k1_ec_pubkey_parse(\n+            LibSecp256k1.CONTEXT, _pub, encodedPubKey.toArrayUnsafe(), encodedPubKey.size())\n+        == 0) {\n+      throw new IllegalArgumentException(\"Could not parse public key\");\n+    }\n+\n+    return LibSecp256k1.INSTANCE.secp256k1_ecdsa_verify(\n+            LibSecp256k1.CONTEXT, _signature, data.toArrayUnsafe(), _pub)\n+        != 0;\n+  }\n+\n+  private static Optional<PublicKey> recoverFromSignatureNative(\n+      final Bytes32 dataHash, final Signature signature) {\n+\n+    // parse the sig\n+    final LibSecp256k1.secp256k1_ecdsa_recoverable_signature parsedSignature =\n+        new LibSecp256k1.secp256k1_ecdsa_recoverable_signature();\n+    final Bytes encodedSig = signature.encodedBytes();\n+    if (LibSecp256k1.INSTANCE.secp256k1_ecdsa_recoverable_signature_parse_compact(\n+            LibSecp256k1.CONTEXT,\n+            parsedSignature,\n+            encodedSig.slice(0, 64).toArrayUnsafe(),\n+            encodedSig.get(64))\n+        == 0) {\n+      throw new IllegalArgumentException(\"Could not parse signature\");\n+    }\n+\n+    // recover the key\n+    final LibSecp256k1.secp256k1_pubkey newPubKey = new LibSecp256k1.secp256k1_pubkey();\n+    if (LibSecp256k1.INSTANCE.secp256k1_ecdsa_recover(\n+            LibSecp256k1.CONTEXT, newPubKey, parsedSignature, dataHash.toArrayUnsafe())\n+        == 0) {\n+      throw new IllegalArgumentException(\"Could not recover public key\");\n+    }\n+\n+    // parse the key\n+    final ByteBuffer recoveredKey = ByteBuffer.allocate(65);\n+    final LongByReference keySize = new LongByReference(recoveredKey.limit());\n+    LibSecp256k1.INSTANCE.secp256k1_ec_pubkey_serialize(\n+        LibSecp256k1.CONTEXT,\n+        recoveredKey,\n+        keySize,\n+        newPubKey,\n+        LibSecp256k1.SECP256K1_EC_UNCOMPRESSED);\n+\n+    return Optional.of(PublicKey.create(Bytes.wrapByteBuffer(recoveredKey).slice(1)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98de29c569da70edaf054b3b304fc2570227617c"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3NjE1NQ==", "bodyText": "Legacy APIs.  The old java method had a way to return emptys, but when I try and return empty from any of the methods that return error I get reference tests that break.  I'm not sure why the java method gets away with it.", "url": "https://github.com/hyperledger/besu/pull/675#discussion_r409276155", "createdAt": "2020-04-16T04:35:12Z", "author": {"login": "shemnon"}, "path": "crypto/src/main/java/org/hyperledger/besu/crypto/SECP256K1.java", "diffHunk": "@@ -308,6 +336,99 @@ public static Bytes calculateECIESKeyAgreement(final PrivateKey privKey, final P\n     return Bytes.wrap(BigIntegers.asUnsignedByteArray(agree.getFieldSize(), z));\n   }\n \n+  private static Signature signNative(final Bytes32 dataHash, final KeyPair keyPair) {\n+    final LibSecp256k1.secp256k1_ecdsa_recoverable_signature signature =\n+        new secp256k1_ecdsa_recoverable_signature();\n+    // sign in internal form\n+    if (LibSecp256k1.INSTANCE.secp256k1_ecdsa_sign_recoverable(\n+            LibSecp256k1.CONTEXT,\n+            signature,\n+            dataHash.toArrayUnsafe(),\n+            keyPair.privateKey.getEncoded(),\n+            null,\n+            null)\n+        == 0) {\n+      throw new RuntimeException(\n+          \"Could not natively sign. Private Key is invalid or default nonce generation failed.\");\n+    }\n+\n+    // encode to compact form\n+    final ByteBuffer compactSig = ByteBuffer.allocate(64);\n+    final IntByReference recId = new IntByReference(0);\n+    LibSecp256k1.INSTANCE.secp256k1_ecdsa_recoverable_signature_serialize_compact(\n+        LibSecp256k1.CONTEXT, compactSig, recId, signature);\n+    compactSig.flip();\n+    final byte[] sig = compactSig.array();\n+\n+    // wrap in signature object\n+    final Bytes32 r = Bytes32.wrap(sig, 0);\n+    final Bytes32 s = Bytes32.wrap(sig, 32);\n+    return Signature.create(\n+        r.toUnsignedBigInteger(), s.toUnsignedBigInteger(), (byte) recId.getValue());\n+  }\n+\n+  private static boolean verifyNative(\n+      final Bytes data, final Signature signature, final PublicKey pub) {\n+\n+    // translate signature\n+    final LibSecp256k1.secp256k1_ecdsa_signature _signature = new secp256k1_ecdsa_signature();\n+    if (LibSecp256k1.INSTANCE.secp256k1_ecdsa_signature_parse_compact(\n+            LibSecp256k1.CONTEXT, _signature, signature.encodedBytes().toArrayUnsafe())\n+        == 0) {\n+      throw new IllegalArgumentException(\"Could not parse signature\");\n+    }\n+\n+    // translate key\n+    final LibSecp256k1.secp256k1_pubkey _pub = new secp256k1_pubkey();\n+    final Bytes encodedPubKey = Bytes.concatenate(Bytes.of(0x04), pub.getEncodedBytes());\n+    if (LibSecp256k1.INSTANCE.secp256k1_ec_pubkey_parse(\n+            LibSecp256k1.CONTEXT, _pub, encodedPubKey.toArrayUnsafe(), encodedPubKey.size())\n+        == 0) {\n+      throw new IllegalArgumentException(\"Could not parse public key\");\n+    }\n+\n+    return LibSecp256k1.INSTANCE.secp256k1_ecdsa_verify(\n+            LibSecp256k1.CONTEXT, _signature, data.toArrayUnsafe(), _pub)\n+        != 0;\n+  }\n+\n+  private static Optional<PublicKey> recoverFromSignatureNative(\n+      final Bytes32 dataHash, final Signature signature) {\n+\n+    // parse the sig\n+    final LibSecp256k1.secp256k1_ecdsa_recoverable_signature parsedSignature =\n+        new LibSecp256k1.secp256k1_ecdsa_recoverable_signature();\n+    final Bytes encodedSig = signature.encodedBytes();\n+    if (LibSecp256k1.INSTANCE.secp256k1_ecdsa_recoverable_signature_parse_compact(\n+            LibSecp256k1.CONTEXT,\n+            parsedSignature,\n+            encodedSig.slice(0, 64).toArrayUnsafe(),\n+            encodedSig.get(64))\n+        == 0) {\n+      throw new IllegalArgumentException(\"Could not parse signature\");\n+    }\n+\n+    // recover the key\n+    final LibSecp256k1.secp256k1_pubkey newPubKey = new LibSecp256k1.secp256k1_pubkey();\n+    if (LibSecp256k1.INSTANCE.secp256k1_ecdsa_recover(\n+            LibSecp256k1.CONTEXT, newPubKey, parsedSignature, dataHash.toArrayUnsafe())\n+        == 0) {\n+      throw new IllegalArgumentException(\"Could not recover public key\");\n+    }\n+\n+    // parse the key\n+    final ByteBuffer recoveredKey = ByteBuffer.allocate(65);\n+    final LongByReference keySize = new LongByReference(recoveredKey.limit());\n+    LibSecp256k1.INSTANCE.secp256k1_ec_pubkey_serialize(\n+        LibSecp256k1.CONTEXT,\n+        recoveredKey,\n+        keySize,\n+        newPubKey,\n+        LibSecp256k1.SECP256K1_EC_UNCOMPRESSED);\n+\n+    return Optional.of(PublicKey.create(Bytes.wrapByteBuffer(recoveredKey).slice(1)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5NDY1NA=="}, "originalCommit": {"oid": "98de29c569da70edaf054b3b304fc2570227617c"}, "originalPosition": 193}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1036, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}