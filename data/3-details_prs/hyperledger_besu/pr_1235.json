{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUxNTUzODg1", "number": 1235, "title": "Backup and Restore", "bodyText": "Generate state backup files with optional compression.\nTODO:\n\n import into a chain from the backup file\n acceptance tests demonstrating backup and restore\n\nfor #1231", "createdAt": "2020-07-17T23:42:09Z", "url": "https://github.com/hyperledger/besu/pull/1235", "merged": true, "mergeCommit": {"oid": "4dbe0c7d145dbadd87c556d58d8e1502dffbc46e"}, "closed": true, "closedAt": "2020-08-10T21:32:06Z", "author": {"login": "shemnon"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc15wHqgH2gAyNDUxNTUzODg1OmY3YWI4NTkwODJkMjFmMDA4M2ExMGJjZTYyNjkwNzBkMjkzN2M4NGM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc9o11aAH2gAyNDUxNTUzODg1Ojg2MTc0MzBhNjBmOGU0NjQ2OGI5YTE3ODVjZDYwMDYzZWJmZGMxMDE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f7ab859082d21f0083a10bce6269070d2937c84c", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/f7ab859082d21f0083a10bce6269070d2937c84c", "committedDate": "2020-07-17T20:21:13Z", "message": "Leaf and Chaindata backup\n\nCreate leaf and chaindata backup files.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3d3b91425e680cce85392e8858aa4cbbb9a406a", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/b3d3b91425e680cce85392e8858aa4cbbb9a406a", "committedDate": "2020-07-17T23:37:59Z", "message": "optional compression\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a75fe8cf1355170d9fb940ee71c49568670424c", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/0a75fe8cf1355170d9fb940ee71c49568670424c", "committedDate": "2020-07-23T14:04:32Z", "message": "add indexing to chain and lead backup\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MDEyODIw", "url": "https://github.com/hyperledger/besu/pull/1235#pullrequestreview-455012820", "createdAt": "2020-07-24T16:11:12Z", "commit": {"oid": "0a75fe8cf1355170d9fb940ee71c49568670424c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNjoxMToxMlrOG21XlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNjoxMToxMlrOG21XlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE1MDY3Ng==", "bodyText": "The error message should be in the negative", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r460150676", "createdAt": "2020-07-24T16:11:12Z", "author": {"login": "RatanRSur"}, "path": "besu/src/main/java/org/hyperledger/besu/cli/subcommands/operator/BackupState.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.cli.subcommands.operator;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static org.hyperledger.besu.cli.DefaultCommandValues.MANDATORY_LONG_FORMAT_HELP;\n+\n+import org.hyperledger.besu.BesuInfo;\n+import org.hyperledger.besu.controller.BesuController;\n+import org.hyperledger.besu.ethereum.api.query.StateBackupService;\n+import org.hyperledger.besu.ethereum.api.query.StateBackupService.BackupStatus;\n+import org.hyperledger.besu.ethereum.chain.MutableBlockchain;\n+import org.hyperledger.besu.ethereum.eth.manager.EthScheduler;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateStorage;\n+import org.hyperledger.besu.metrics.noop.NoOpMetricsSystem;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.LockSupport;\n+\n+import picocli.CommandLine.Command;\n+import picocli.CommandLine.Option;\n+import picocli.CommandLine.ParentCommand;\n+\n+@Command(\n+    name = \"backup-state\",\n+    description = \"Backups up the state and accounts of a specified block.\",\n+    mixinStandardHelpOptions = true)\n+public class BackupState implements Runnable {\n+\n+  @Option(\n+      names = \"--block\",\n+      paramLabel = MANDATORY_LONG_FORMAT_HELP,\n+      description = \"The block to perform the backup at (default: calculated chain head)\",\n+      arity = \"1..1\")\n+  private final Long block = Long.MAX_VALUE;\n+\n+  @Option(\n+      names = \"--backup-path\",\n+      required = true,\n+      paramLabel = MANDATORY_LONG_FORMAT_HELP,\n+      description = \"The path to store the backup files.\",\n+      arity = \"1..1\")\n+  private final File backupDir = null;\n+\n+  @Option(\n+      names = {\"--compression-enabled\"},\n+      description = \"Enable data compression\",\n+      arity = \"1\")\n+  private final Boolean compress = true;\n+\n+  @ParentCommand private OperatorSubCommand parentCommand;\n+\n+  @Override\n+  public void run() {\n+    checkArgument(\n+        backupDir.exists() || backupDir.mkdirs(), \"Backup directory exists or can be created\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a75fe8cf1355170d9fb940ee71c49568670424c"}, "originalPosition": 72}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MDI1NTk2", "url": "https://github.com/hyperledger/besu/pull/1235#pullrequestreview-455025596", "createdAt": "2020-07-24T16:30:28Z", "commit": {"oid": "0a75fe8cf1355170d9fb940ee71c49568670424c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNjozMDoyOFrOG21-yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNjozMDoyOFrOG21-yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MDcxNA==", "bodyText": "Do we need to create a whole EthScheduler for this? Can we just have an ExecutorService? Then we can do CompleteableFuture.supplyAsync(computation, executor).", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r460160714", "createdAt": "2020-07-24T16:30:28Z", "author": {"login": "RatanRSur"}, "path": "besu/src/main/java/org/hyperledger/besu/cli/subcommands/operator/BackupState.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.cli.subcommands.operator;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static org.hyperledger.besu.cli.DefaultCommandValues.MANDATORY_LONG_FORMAT_HELP;\n+\n+import org.hyperledger.besu.BesuInfo;\n+import org.hyperledger.besu.controller.BesuController;\n+import org.hyperledger.besu.ethereum.api.query.StateBackupService;\n+import org.hyperledger.besu.ethereum.api.query.StateBackupService.BackupStatus;\n+import org.hyperledger.besu.ethereum.chain.MutableBlockchain;\n+import org.hyperledger.besu.ethereum.eth.manager.EthScheduler;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateStorage;\n+import org.hyperledger.besu.metrics.noop.NoOpMetricsSystem;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.LockSupport;\n+\n+import picocli.CommandLine.Command;\n+import picocli.CommandLine.Option;\n+import picocli.CommandLine.ParentCommand;\n+\n+@Command(\n+    name = \"backup-state\",\n+    description = \"Backups up the state and accounts of a specified block.\",\n+    mixinStandardHelpOptions = true)\n+public class BackupState implements Runnable {\n+\n+  @Option(\n+      names = \"--block\",\n+      paramLabel = MANDATORY_LONG_FORMAT_HELP,\n+      description = \"The block to perform the backup at (default: calculated chain head)\",\n+      arity = \"1..1\")\n+  private final Long block = Long.MAX_VALUE;\n+\n+  @Option(\n+      names = \"--backup-path\",\n+      required = true,\n+      paramLabel = MANDATORY_LONG_FORMAT_HELP,\n+      description = \"The path to store the backup files.\",\n+      arity = \"1..1\")\n+  private final File backupDir = null;\n+\n+  @Option(\n+      names = {\"--compression-enabled\"},\n+      description = \"Enable data compression\",\n+      arity = \"1\")\n+  private final Boolean compress = true;\n+\n+  @ParentCommand private OperatorSubCommand parentCommand;\n+\n+  @Override\n+  public void run() {\n+    checkArgument(\n+        backupDir.exists() || backupDir.mkdirs(), \"Backup directory exists or can be created\");\n+\n+    final BesuController besuController = createBesuController();\n+    final MutableBlockchain blockchain = besuController.getProtocolContext().getBlockchain();\n+    final WorldStateStorage worldStateStorage =\n+        besuController.getProtocolContext().getWorldStateArchive().getWorldStateStorage();\n+    final EthScheduler scheduler = new EthScheduler(1, 1, 1, 1, new NoOpMetricsSystem());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a75fe8cf1355170d9fb940ee71c49568670424c"}, "originalPosition": 78}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a9276f9db268f58c512713d3b611d30d8d1eb11", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/5a9276f9db268f58c512713d3b611d30d8d1eb11", "committedDate": "2020-07-27T20:07:02Z", "message": "checkpoint\n\nReads in the RLP and stuffs seems to add up so far.\n* add account count\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4489466750449d92ae6bc8240300e8bba41f3aa", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/a4489466750449d92ae6bc8240300e8bba41f3aa", "committedDate": "2020-07-28T15:18:13Z", "message": "Merge branch 'master' of github.com:hyperledger/besu into backupGenerate\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73db4926d4dbc97a6b09a9a03431169089a81385", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/73db4926d4dbc97a6b09a9a03431169089a81385", "committedDate": "2020-07-28T17:03:01Z", "message": "retore checkpoint\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "faafecd38f52c40be2cfab1179885a0a8c2c69e6", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/faafecd38f52c40be2cfab1179885a0a8c2c69e6", "committedDate": "2020-07-28T17:04:20Z", "message": "Merge branch 'master' of github.com:hyperledger/besu into backupGenerate\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e1290129c36e1625b5001725bad149d90b46aa4", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/4e1290129c36e1625b5001725bad149d90b46aa4", "committedDate": "2020-07-30T04:21:08Z", "message": "possibly works now.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9766b972de2465cf98b278c36f2327b7a3fb395", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/d9766b972de2465cf98b278c36f2327b7a3fb395", "committedDate": "2020-07-30T16:45:30Z", "message": "spotless and fix unit test\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77d2fb9e68c9cca0c68e7f17d6ffbe185f504fa7", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/77d2fb9e68c9cca0c68e7f17d6ffbe185f504fa7", "committedDate": "2020-07-31T06:10:09Z", "message": "Acceptance Test refactors\n\nRefactors prior to Backup/Restore\n* Allow multiple extra commands on the command line\n* Extra commands appear at the end of the command line\n* Pull node setup out of DB migration test\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15012eff784c7b350a9c9ab9695a0dda129feed9", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/15012eff784c7b350a9c9ab9695a0dda129feed9", "committedDate": "2020-07-31T06:12:57Z", "message": "Merge branch 'atRefactor' into backupGenerate\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "853f607f2243f132ff364ba5bb43e4a4dd3df77c", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/853f607f2243f132ff364ba5bb43e4a4dd3df77c", "committedDate": "2020-07-31T06:14:44Z", "message": "backup/restore/rebackup acceptance tests\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7af05d221342f4a4f309339c15450f1d2402f7a1", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/7af05d221342f4a4f309339c15450f1d2402f7a1", "committedDate": "2020-07-31T14:58:31Z", "message": "spotless\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "611079d98fe19db124b0ef018cfd6befdfa36d2e", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/611079d98fe19db124b0ef018cfd6befdfa36d2e", "committedDate": "2020-07-31T16:03:12Z", "message": "Merge branch 'master' of github.com:hyperledger/besu into backupGenerate\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c32e96d89b11de7732fd63b41c28c34019aa6639", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/c32e96d89b11de7732fd63b41c28c34019aa6639", "committedDate": "2020-07-31T16:11:16Z", "message": "add AT asserts\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5804852bc98e69ffc5e4a7272083b930001b6b7c", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/5804852bc98e69ffc5e4a7272083b930001b6b7c", "committedDate": "2020-07-31T17:05:37Z", "message": "test name\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2c56bd719285d36033afdebb4debd837823a398", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/a2c56bd719285d36033afdebb4debd837823a398", "committedDate": "2020-08-01T16:34:15Z", "message": "fix ropsten breakage\n\n* Use a null terminated sequence of RLPs for storage, rather than a full\n  list.  The full list may not always fit in memory for large accounts.\n* Change commands to `x-<foo>` commands until we freeze the backup\n  format.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23518eaf00e83b7bee5dd53d75fb269eb9533a98", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/23518eaf00e83b7bee5dd53d75fb269eb9533a98", "committedDate": "2020-08-01T16:45:16Z", "message": "spotless\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7478c2d39cb110aef6a250f09ae2eed616cf6f41", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/7478c2d39cb110aef6a250f09ae2eed616cf6f41", "committedDate": "2020-08-01T17:04:18Z", "message": "acceptance tests had old operator names\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a93472c70b483146a5c615bc28d975b9e9977ef1", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/a93472c70b483146a5c615bc28d975b9e9977ef1", "committedDate": "2020-08-03T21:10:30Z", "message": "unload nodes on backup iteration\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNjg2NTE5", "url": "https://github.com/hyperledger/besu/pull/1235#pullrequestreview-462686519", "createdAt": "2020-08-06T16:36:45Z", "commit": {"oid": "a93472c70b483146a5c615bc28d975b9e9977ef1"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNjozNjo0NVrOG87XyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNjozODo1NVrOG87csg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU0MDQ4OQ==", "bodyText": "why we don't use LogManager here ?", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r466540489", "createdAt": "2020-08-06T16:36:45Z", "author": {"login": "matkt"}, "path": "besu/src/main/java/org/hyperledger/besu/cli/subcommands/operator/BackupState.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.cli.subcommands.operator;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static org.hyperledger.besu.cli.DefaultCommandValues.MANDATORY_LONG_FORMAT_HELP;\n+\n+import org.hyperledger.besu.BesuInfo;\n+import org.hyperledger.besu.controller.BesuController;\n+import org.hyperledger.besu.ethereum.api.query.StateBackupService;\n+import org.hyperledger.besu.ethereum.api.query.StateBackupService.BackupStatus;\n+import org.hyperledger.besu.ethereum.chain.MutableBlockchain;\n+import org.hyperledger.besu.ethereum.eth.manager.EthScheduler;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateStorage;\n+import org.hyperledger.besu.metrics.noop.NoOpMetricsSystem;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.LockSupport;\n+\n+import picocli.CommandLine.Command;\n+import picocli.CommandLine.Option;\n+import picocli.CommandLine.ParentCommand;\n+\n+@Command(\n+    name = \"x-backup-state\",\n+    description = \"Backups up the state and accounts of a specified block.\",\n+    mixinStandardHelpOptions = true)\n+public class BackupState implements Runnable {\n+\n+  @Option(\n+      names = \"--block\",\n+      paramLabel = MANDATORY_LONG_FORMAT_HELP,\n+      description = \"The block to perform the backup at (default: calculated chain head)\",\n+      arity = \"1..1\")\n+  private final Long block = Long.MAX_VALUE;\n+\n+  @Option(\n+      names = \"--backup-path\",\n+      required = true,\n+      paramLabel = MANDATORY_LONG_FORMAT_HELP,\n+      description = \"The path to store the backup files.\",\n+      arity = \"1..1\")\n+  private final File backupDir = null;\n+\n+  @Option(\n+      names = {\"--compression-enabled\"},\n+      description = \"Enable data compression\",\n+      arity = \"1\")\n+  private final Boolean compress = true;\n+\n+  @ParentCommand private OperatorSubCommand parentCommand;\n+\n+  @Override\n+  public void run() {\n+    checkArgument(\n+        parentCommand.parentCommand.dataDir().toFile().exists(),\n+        \"DataDir (the blockchain being backed up) does not exist.\");\n+    checkArgument(\n+        backupDir.exists() || backupDir.mkdirs(),\n+        \"Backup directory does not exist and cannot be created.\");\n+\n+    final BesuController besuController = createBesuController();\n+    final MutableBlockchain blockchain = besuController.getProtocolContext().getBlockchain();\n+    final WorldStateStorage worldStateStorage =\n+        besuController.getProtocolContext().getWorldStateArchive().getWorldStateStorage();\n+    final EthScheduler scheduler = new EthScheduler(1, 1, 1, 1, new NoOpMetricsSystem());\n+    try {\n+      final long targetBlock = Math.min(blockchain.getChainHeadBlockNumber(), this.block);\n+      final StateBackupService backup =\n+          new StateBackupService(\n+              BesuInfo.version(), blockchain, backupDir.toPath(), scheduler, worldStateStorage);\n+      final BackupStatus status = backup.requestBackup(targetBlock, compress, Optional.empty());\n+\n+      final double refValue = Math.pow(2, 256) / 100.0d;\n+      while (status.isBackingUp()) {\n+        if (status.getTargetBlockNum() != status.getStoredBlockNum()) {\n+          System.out.printf(\n+              \"Chain Progress - %,d of %,d (%5.2f%%)%n\",\n+              status.getStoredBlockNum(),\n+              status.getTargetBlockNum(),\n+              status.getStoredBlockNum() * 100.0d / status.getTargetBlockNum());\n+        } else {\n+          System.out.printf(\n+              \"State Progress - %6.3f%% / %,d Accounts / %,d Storage Nodes%n\",\n+              status.getCurrentAccountBytes().toUnsignedBigInteger().doubleValue() / refValue,\n+              status.getAccountCount(),\n+              status.getStorageCount());\n+        }\n+        LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(10));\n+      }\n+\n+      System.out.printf(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a93472c70b483146a5c615bc28d975b9e9977ef1"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU0MTc0Ng==", "bodyText": "Is it not possible to have something like while(len!=0) instead of while (true) ?", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r466541746", "createdAt": "2020-08-06T16:38:55Z", "author": {"login": "matkt"}, "path": "besu/src/main/java/org/hyperledger/besu/cli/subcommands/operator/RestoreState.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.cli.subcommands.operator;\n+\n+import static org.hyperledger.besu.cli.DefaultCommandValues.MANDATORY_LONG_FORMAT_HELP;\n+import static org.hyperledger.besu.ethereum.trie.CompactEncoding.bytesToPath;\n+\n+import org.hyperledger.besu.config.JsonUtil;\n+import org.hyperledger.besu.controller.BesuController;\n+import org.hyperledger.besu.ethereum.api.query.StateBackupService;\n+import org.hyperledger.besu.ethereum.chain.MutableBlockchain;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockBody;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.BlockHeaderFunctions;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.TransactionReceipt;\n+import org.hyperledger.besu.ethereum.mainnet.MainnetBlockHeaderFunctions;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLPInput;\n+import org.hyperledger.besu.ethereum.trie.Node;\n+import org.hyperledger.besu.ethereum.trie.PersistVisitor;\n+import org.hyperledger.besu.ethereum.trie.RestoreVisitor;\n+import org.hyperledger.besu.ethereum.worldstate.StateTrieAccountValue;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateStorage;\n+\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.EOFException;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.xerial.snappy.Snappy;\n+import picocli.CommandLine.Command;\n+import picocli.CommandLine.Option;\n+import picocli.CommandLine.ParentCommand;\n+\n+@Command(\n+    name = \"x-restore-state\",\n+    description = \"Restores the chain from a previously generated backup-state.\",\n+    mixinStandardHelpOptions = true)\n+public class RestoreState implements Runnable {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  @Option(\n+      names = \"--backup-path\",\n+      required = true,\n+      paramLabel = MANDATORY_LONG_FORMAT_HELP,\n+      description = \"The path to store the backup files.\",\n+      arity = \"1..1\")\n+  private final Path backupDir = null;\n+\n+  @ParentCommand private OperatorSubCommand parentCommand;\n+\n+  private static final int TRIE_NODE_COMMIT_BATCH_SIZE = 100;\n+\n+  private long targetBlock;\n+  private long accountCount;\n+  private long trieNodeCount;\n+  private boolean compressed;\n+  private BesuController besuController;\n+  private WorldStateStorage.Updater updater;\n+\n+  private Path accountFileName(final int fileNumber, final boolean compressed) {\n+    return StateBackupService.accountFileName(backupDir, targetBlock, fileNumber, compressed);\n+  }\n+\n+  private Path headerFileName(final int fileNumber, final boolean compressed) {\n+    return StateBackupService.headerFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path bodyFileName(final int fileNumber, final boolean compressed) {\n+    return StateBackupService.bodyFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path receiptFileName(final int fileNumber, final boolean compressed) {\n+    return StateBackupService.receiptFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  @Override\n+  public void run() {\n+    try {\n+      final ObjectNode manifest =\n+          JsonUtil.objectNodeFromString(\n+              Files.readString(backupDir.resolve(\"besu-backup-manifest.json\")));\n+\n+      compressed = manifest.get(\"compressed\").asBoolean(false);\n+      targetBlock = manifest.get(\"targetBlock\").asLong();\n+      accountCount = manifest.get(\"accountCount\").asLong();\n+      besuController = createBesuController();\n+\n+      restoreBlocks();\n+      restoreAccounts();\n+\n+      LOG.info(\"Restore complete\");\n+\n+    } catch (final IOException e) {\n+      LOG.error(\"Error restoring state\", e);\n+    }\n+  }\n+\n+  private void restoreBlocks() throws IOException {\n+    try (final RollingFileReader headerReader =\n+            new RollingFileReader(this::headerFileName, compressed);\n+        final RollingFileReader bodyReader = new RollingFileReader(this::bodyFileName, compressed);\n+        final RollingFileReader receiptReader =\n+            new RollingFileReader(this::receiptFileName, compressed)) {\n+      final MutableBlockchain blockchain = besuController.getProtocolContext().getBlockchain();\n+      // target block is \"including\" the target block, so LE test not LT.\n+      for (int i = 0; i <= targetBlock; i++) {\n+        if (i % 100000 == 0) {\n+          LOG.info(\"Loading chain data {} / {}\", i, targetBlock);\n+        }\n+\n+        final byte[] headerEntry = headerReader.readBytes();\n+        final byte[] bodyEntry = bodyReader.readBytes();\n+        final byte[] receiptEntry = receiptReader.readBytes();\n+        final BlockHeaderFunctions functions = new MainnetBlockHeaderFunctions();\n+\n+        final BlockHeader header =\n+            BlockHeader.readFrom(\n+                new BytesValueRLPInput(Bytes.wrap(headerEntry), false, true), functions);\n+        final BlockBody body =\n+            BlockBody.readFrom(\n+                new BytesValueRLPInput(Bytes.wrap(bodyEntry), false, true), functions);\n+        final RLPInput receiptsRlp = new BytesValueRLPInput(Bytes.wrap(receiptEntry), false, true);\n+        final int receiptsCount = receiptsRlp.enterList();\n+        final List<TransactionReceipt> receipts = new ArrayList<>(receiptsCount);\n+        for (int j = 0; j < receiptsCount; j++) {\n+          receipts.add(TransactionReceipt.readFrom(receiptsRlp, true));\n+        }\n+        receiptsRlp.leaveList();\n+\n+        blockchain.appendBlock(new Block(header, body), receipts);\n+      }\n+    }\n+    LOG.info(\"Chain data loaded\");\n+  }\n+\n+  @SuppressWarnings(\"UnusedVariable\")\n+  private void restoreAccounts() throws IOException {\n+    newWorldStateUpdater();\n+    int storageBranchCount = 0;\n+    int storageExtensionCount = 0;\n+    int storageLeafCount = 0;\n+\n+    final PersistVisitor<Bytes> accountPersistVisitor =\n+        new PersistVisitor<>(this::updateAccountState);\n+    Node<Bytes> root = accountPersistVisitor.initialRoot();\n+\n+    try (final RollingFileReader reader =\n+        new RollingFileReader(this::accountFileName, compressed)) {\n+      for (int i = 0; i < accountCount; i++) {\n+        if (i % 100000 == 0) {\n+          LOG.info(\"Loading account data {} / {}\", i, accountCount);\n+        }\n+        final byte[] accountEntry = reader.readBytes();\n+        final BytesValueRLPInput accountInput =\n+            new BytesValueRLPInput(Bytes.of(accountEntry), false, true);\n+        final int length = accountInput.enterList();\n+        if (length != 3) {\n+          throw new RuntimeException(\"Unexpected account length \" + length);\n+        }\n+        final Bytes32 trieKey = accountInput.readBytes32();\n+        final Bytes accountRlp = accountInput.readBytes();\n+        final Bytes code = accountInput.readBytes();\n+\n+        final StateTrieAccountValue trieAccount =\n+            StateTrieAccountValue.readFrom(new BytesValueRLPInput(accountRlp, false, true));\n+        if (!trieAccount.getCodeHash().equals(Hash.hash(code))) {\n+          throw new RuntimeException(\"Code hash doesn't match\");\n+        }\n+        if (code.size() > 0) {\n+          updateCode(code);\n+        }\n+\n+        final RestoreVisitor<Bytes> accountTrieWriteVisitor =\n+            new RestoreVisitor<>(t -> t, accountRlp, accountPersistVisitor);\n+\n+        root = root.accept(accountTrieWriteVisitor, bytesToPath(trieKey));\n+\n+        final PersistVisitor<Bytes> storagePersistVisitor =\n+            new PersistVisitor<>(this::updateAccountStorage);\n+        Node<Bytes> storageRoot = storagePersistVisitor.initialRoot();\n+\n+        while (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a93472c70b483146a5c615bc28d975b9e9977ef1"}, "originalPosition": 211}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMjEwNjQ4", "url": "https://github.com/hyperledger/besu/pull/1235#pullrequestreview-463210648", "createdAt": "2020-08-07T10:36:53Z", "commit": {"oid": "a93472c70b483146a5c615bc28d975b9e9977ef1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "536dcfcaa84dfa034723ec94a591bf5f90ae50ab", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/536dcfcaa84dfa034723ec94a591bf5f90ae50ab", "committedDate": "2020-08-07T15:20:45Z", "message": "Merge branch 'master' into backupGenerate"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDMzNjIz", "url": "https://github.com/hyperledger/besu/pull/1235#pullrequestreview-463433623", "createdAt": "2020-08-07T16:09:55Z", "commit": {"oid": "536dcfcaa84dfa034723ec94a591bf5f90ae50ab"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjowOTo1NVrOG9fovQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODo0OToxMVrOG9kWzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzNDY1Mw==", "bodyText": "EthScheduler's current role is overkill for just parallelization. It assumes you've got specific subsystem threadpools you're scheduling against. I also don't see how it helps with pipelining more than CompletableFutures do because the only other utility methods are scheduling at a specific time.\nGiven that we're in a self-contained operator that doesn't have subsystems, why not opt for just an ExecutorService?", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r467134653", "createdAt": "2020-08-07T16:09:55Z", "author": {"login": "RatanRSur"}, "path": "besu/src/main/java/org/hyperledger/besu/cli/subcommands/operator/BackupState.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.cli.subcommands.operator;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static org.hyperledger.besu.cli.DefaultCommandValues.MANDATORY_LONG_FORMAT_HELP;\n+\n+import org.hyperledger.besu.BesuInfo;\n+import org.hyperledger.besu.controller.BesuController;\n+import org.hyperledger.besu.ethereum.api.query.StateBackupService;\n+import org.hyperledger.besu.ethereum.api.query.StateBackupService.BackupStatus;\n+import org.hyperledger.besu.ethereum.chain.MutableBlockchain;\n+import org.hyperledger.besu.ethereum.eth.manager.EthScheduler;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateStorage;\n+import org.hyperledger.besu.metrics.noop.NoOpMetricsSystem;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.LockSupport;\n+\n+import picocli.CommandLine.Command;\n+import picocli.CommandLine.Option;\n+import picocli.CommandLine.ParentCommand;\n+\n+@Command(\n+    name = \"backup-state\",\n+    description = \"Backups up the state and accounts of a specified block.\",\n+    mixinStandardHelpOptions = true)\n+public class BackupState implements Runnable {\n+\n+  @Option(\n+      names = \"--block\",\n+      paramLabel = MANDATORY_LONG_FORMAT_HELP,\n+      description = \"The block to perform the backup at (default: calculated chain head)\",\n+      arity = \"1..1\")\n+  private final Long block = Long.MAX_VALUE;\n+\n+  @Option(\n+      names = \"--backup-path\",\n+      required = true,\n+      paramLabel = MANDATORY_LONG_FORMAT_HELP,\n+      description = \"The path to store the backup files.\",\n+      arity = \"1..1\")\n+  private final File backupDir = null;\n+\n+  @Option(\n+      names = {\"--compression-enabled\"},\n+      description = \"Enable data compression\",\n+      arity = \"1\")\n+  private final Boolean compress = true;\n+\n+  @ParentCommand private OperatorSubCommand parentCommand;\n+\n+  @Override\n+  public void run() {\n+    checkArgument(\n+        backupDir.exists() || backupDir.mkdirs(), \"Backup directory exists or can be created\");\n+\n+    final BesuController besuController = createBesuController();\n+    final MutableBlockchain blockchain = besuController.getProtocolContext().getBlockchain();\n+    final WorldStateStorage worldStateStorage =\n+        besuController.getProtocolContext().getWorldStateArchive().getWorldStateStorage();\n+    final EthScheduler scheduler = new EthScheduler(1, 1, 1, 1, new NoOpMetricsSystem());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MDcxNA=="}, "originalCommit": {"oid": "0a75fe8cf1355170d9fb940ee71c49568670424c"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0MjMxMQ==", "bodyText": "At a quick glance I can't see where this is used.", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r467142311", "createdAt": "2020-08-07T16:24:27Z", "author": {"login": "RatanRSur"}, "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/query/StateBackupService.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.api.query;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import org.hyperledger.besu.config.JsonUtil;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.TransactionReceipt;\n+import org.hyperledger.besu.ethereum.eth.manager.EthScheduler;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.Node;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.TrieIterator;\n+import org.hyperledger.besu.ethereum.trie.TrieIterator.State;\n+import org.hyperledger.besu.ethereum.worldstate.StateTrieAccountValue;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateStorage;\n+import org.hyperledger.besu.plugin.data.Hash;\n+\n+import java.io.Closeable;\n+import java.io.DataOutputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import com.fasterxml.jackson.annotation.JsonGetter;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.xerial.snappy.Snappy;\n+\n+public class StateBackupService {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final long MAX_FILE_SIZE = 1 << 28; // 256 MiB max file size\n+  private static final Bytes ACCOUNT_END_MARKER;\n+\n+  static {\n+    final BytesValueRLPOutput endMarker = new BytesValueRLPOutput();\n+    endMarker.startList();\n+    endMarker.endList();\n+    ACCOUNT_END_MARKER = endMarker.encoded();\n+  }\n+\n+  private final String besuVesion;\n+  private final Lock submissionLock = new ReentrantLock();\n+  private final EthScheduler scheduler;\n+  private final Blockchain blockchain;\n+  private final WorldStateStorage worldStateStorage;\n+  private final BackupStatus backupStatus = new BackupStatus();\n+\n+  private Path backupDir;\n+  private RollingFileWriter accountFileWriter;\n+\n+  public StateBackupService(\n+      final String besuVesion,\n+      final Blockchain blockchain,\n+      final Path backupDir,\n+      final EthScheduler scheduler,\n+      final WorldStateStorage worldStateStorage) {\n+    this.besuVesion = besuVesion;\n+    this.blockchain = blockchain;\n+    this.backupDir = backupDir;\n+    this.scheduler = scheduler;\n+    this.worldStateStorage = worldStateStorage;\n+  }\n+\n+  public Path getBackupDir() {\n+    return backupDir;\n+  }\n+\n+  public BackupStatus requestBackup(\n+      final long block, final boolean compress, final Optional<Path> backupDir) {\n+    boolean requestAccepted = false;\n+    try {\n+      if (submissionLock.tryLock(100, TimeUnit.MILLISECONDS)) {\n+        try {\n+          if (!backupStatus.isBackingUp()) {\n+            requestAccepted = true;\n+            this.backupDir = backupDir.orElse(this.backupDir);\n+            backupStatus.targetBlock = block;\n+            backupStatus.compressed = compress;\n+            backupStatus.currentAccount = Bytes32.ZERO;\n+            scheduler.scheduleComputationTask(\n+                () -> {\n+                  try {\n+                    return backup(block, compress);\n+\n+                  } catch (final IOException ioe) {\n+                    LOG.error(\"Error writing backups\", ioe);\n+                    return backupStatus;\n+                  }\n+                });\n+          }\n+        } finally {\n+          submissionLock.unlock();\n+        }\n+      }\n+    } catch (final InterruptedException e) {\n+      // ignore\n+    }\n+    backupStatus.requestAccepted = requestAccepted;\n+    return backupStatus;\n+  }\n+\n+  public static Path dataFileToIndex(final Path dataName) {\n+    return Path.of(dataName.toString().replaceAll(\"(.*)[-.]\\\\d\\\\d\\\\d\\\\d\\\\.(.)dat\", \"$1.$2idx\"));\n+  }\n+\n+  public static Path accountFileName(\n+      final Path backupDir,\n+      final long targetBlock,\n+      final int fileNumber,\n+      final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\n+            \"besu-account-backup-%08d-%04d.%sdat\",\n+            targetBlock, fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path headerFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-header-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path bodyFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-body-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path receiptFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-receipt-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  private Path accountFileName(final int fileNumber, final boolean compressed) {\n+    return accountFileName(backupDir, backupStatus.targetBlock, fileNumber, compressed);\n+  }\n+\n+  private Path headerFileName(final int fileNumber, final boolean compressed) {\n+    return headerFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path bodyFileName(final int fileNumber, final boolean compressed) {\n+    return bodyFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path receiptFileName(final int fileNumber, final boolean compressed) {\n+    return receiptFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private BackupStatus backup(final long block, final boolean compress) throws IOException {\n+    try {\n+      checkArgument(\n+          block >= 0 && block <= blockchain.getChainHeadBlockNumber(),\n+          \"Backup Block must be within blockchain\");\n+      backupStatus.targetBlock = block;\n+      backupStatus.compressed = compress;\n+      backupStatus.currentAccount = Bytes32.ZERO;\n+\n+      backupChaindata();\n+      backupLeaves();\n+\n+      writeManifest();\n+\n+      return backupStatus;\n+    } catch (final Throwable t) {\n+      LOG.error(\"Unexpected error\", t);\n+      throw t;\n+    }\n+  }\n+\n+  private void writeManifest() throws IOException {\n+    final Map<String, Object> manifest = new HashMap<>();\n+    manifest.put(\"clientVersion\", besuVesion);\n+    manifest.put(\"compressed\", backupStatus.compressed);\n+    manifest.put(\"targetBlock\", backupStatus.targetBlock);\n+    manifest.put(\"accountCount\", backupStatus.accountCount);\n+\n+    Files.write(\n+        backupDir.resolve(\"besu-backup-manifest.json\"),\n+        JsonUtil.getJson(manifest).getBytes(StandardCharsets.UTF_8));\n+  }\n+\n+  private void backupLeaves() throws IOException {\n+    final Optional<BlockHeader> header = blockchain.getBlockHeader(backupStatus.targetBlock);\n+    if (header.isEmpty()) {\n+      backupStatus.currentAccount = null;\n+      return;\n+    }\n+    final Optional<Bytes> worldStateRoot =\n+        worldStateStorage.getAccountStateTrieNode(header.get().getStateRoot());\n+    if (worldStateRoot.isEmpty()) {\n+      backupStatus.currentAccount = null;\n+      return;\n+    }\n+\n+    try (final RollingFileWriter accountFileWriter =\n+        new RollingFileWriter(this::accountFileName, backupStatus.compressed)) {\n+      this.accountFileWriter = accountFileWriter;\n+\n+      final StoredMerklePatriciaTrie<Bytes32, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              worldStateStorage::getAccountStateTrieNode,\n+              header.get().getStateRoot(),\n+              Function.identity(),\n+              Function.identity());\n+\n+      accountTrie.visitLeafs(this::visitAccount);\n+      backupStatus.currentAccount = null;\n+    }\n+  }\n+\n+  private TrieIterator.State visitAccount(final Bytes32 nodeKey, final Node<Bytes> node) {\n+    if (node.getValue().isEmpty()) {\n+      return State.CONTINUE;\n+    }\n+\n+    backupStatus.currentAccount = nodeKey;\n+    final Bytes nodeValue = node.getValue().orElse(Hash.EMPTY);\n+    final StateTrieAccountValue account =\n+        StateTrieAccountValue.readFrom(new BytesValueRLPInput(nodeValue, false));\n+\n+    final Bytes code = worldStateStorage.getCode(account.getCodeHash()).orElse(Bytes.EMPTY);\n+    backupStatus.codeSize.addAndGet(code.size());\n+\n+    final BytesValueRLPOutput accountOutput = new BytesValueRLPOutput();\n+    accountOutput.startList();\n+    accountOutput.writeBytes(nodeKey); // trie hash\n+    accountOutput.writeBytes(nodeValue); // account rlp\n+    accountOutput.writeBytes(code); // code\n+    accountOutput.endList();\n+\n+    try {\n+      accountFileWriter.writeBytes(accountOutput.encoded().toArrayUnsafe());\n+    } catch (final IOException ioe) {\n+      LOG.error(\"Failure writing backup\", ioe);\n+      return State.STOP;\n+    }\n+\n+    // storage is written for each leaf, otherwise the whole trie would have to fit in memory\n+    final StoredMerklePatriciaTrie<Bytes32, Bytes> storageTrie =\n+        new StoredMerklePatriciaTrie<>(\n+            worldStateStorage::getAccountStateTrieNode,\n+            account.getStorageRoot(),\n+            Function.identity(),\n+            Function.identity());\n+    storageTrie.visitLeafs(\n+        (storageKey, storageValue) ->\n+            visitAccountStorage(storageKey, storageValue, accountFileWriter));\n+\n+    try {\n+      accountFileWriter.writeBytes(ACCOUNT_END_MARKER.toArrayUnsafe());\n+    } catch (final IOException ioe) {\n+      LOG.error(\"Failure writing backup\", ioe);\n+      return State.STOP;\n+    }\n+\n+    backupStatus.accountCount.incrementAndGet();\n+    return State.CONTINUE;\n+  }\n+\n+  private void backupChaindata() throws IOException {\n+    try (final RollingFileWriter headerWriter =\n+            new RollingFileWriter(this::headerFileName, backupStatus.compressed);\n+        final RollingFileWriter bodyWriter =\n+            new RollingFileWriter(this::bodyFileName, backupStatus.compressed);\n+        final RollingFileWriter receiptsWriter =\n+            new RollingFileWriter(this::receiptFileName, backupStatus.compressed)) {\n+      for (int blockNumber = 0; blockNumber <= backupStatus.targetBlock; blockNumber++) {\n+        final Optional<Block> block = blockchain.getBlockByNumber(blockNumber);\n+        if (block.isEmpty()) {\n+          throw new IllegalStateException(\n+              \"Block data for \" + blockNumber + \" was not found in the archive\");\n+        }\n+        final Optional<List<TransactionReceipt>> receipts =\n+            blockchain.getTxReceipts(block.get().getHash());\n+        if (receipts.isEmpty()) {\n+          throw new IllegalStateException(\n+              \"Receipts for \" + blockNumber + \" was not found in the archive\");\n+        }\n+\n+        final BytesValueRLPOutput headerOutput = new BytesValueRLPOutput();\n+        block.get().getHeader().writeTo(headerOutput);\n+        headerWriter.writeBytes(headerOutput.encoded().toArrayUnsafe());\n+\n+        final BytesValueRLPOutput bodyOutput = new BytesValueRLPOutput();\n+        block.get().getBody().writeTo(bodyOutput);\n+        bodyWriter.writeBytes(bodyOutput.encoded().toArrayUnsafe());\n+\n+        final BytesValueRLPOutput receiptsOutput = new BytesValueRLPOutput();\n+        receiptsOutput.writeList(receipts.get(), TransactionReceipt::writeToWithRevertReason);\n+        receiptsWriter.writeBytes(receiptsOutput.encoded().toArrayUnsafe());\n+\n+        backupStatus.storedBlock = blockNumber;\n+      }\n+    }\n+  }\n+\n+  private TrieIterator.State visitAccountStorage(\n+      final Bytes32 nodeKey, final Node<Bytes> node, final RollingFileWriter accountFileWriter) {\n+    backupStatus.currentStorage = nodeKey;\n+\n+    final BytesValueRLPOutput output = new BytesValueRLPOutput();\n+    output.startList();\n+    output.writeBytes(nodeKey);\n+    output.writeBytes(node.getValue().orElse(Bytes.EMPTY));\n+    output.endList();\n+\n+    try {\n+      accountFileWriter.writeBytes(output.encoded().toArrayUnsafe());\n+    } catch (final IOException ioe) {\n+      LOG.error(\"Failure writing backup\", ioe);\n+      return State.STOP;\n+    }\n+\n+    backupStatus.storageCount.incrementAndGet();\n+    return State.CONTINUE;\n+  }\n+\n+  static class RollingFileWriter implements Closeable {\n+    final BiFunction<Integer, Boolean, Path> filenameGenerator;\n+    final boolean compressed;\n+    int currentSize;\n+    int fileNumber;\n+    FileOutputStream out;\n+    final DataOutputStream index;\n+\n+    RollingFileWriter(\n+        final BiFunction<Integer, Boolean, Path> filenameGenerator, final boolean compressed)\n+        throws FileNotFoundException {\n+      this.filenameGenerator = filenameGenerator;\n+      this.compressed = compressed;\n+      currentSize = 0;\n+      fileNumber = 0;\n+      final Path firstOutputFile = filenameGenerator.apply(fileNumber, compressed);\n+      out = new FileOutputStream(firstOutputFile.toFile());\n+      index = new DataOutputStream(new FileOutputStream(dataFileToIndex(firstOutputFile).toFile()));\n+    }\n+\n+    void writeBytes(final byte[] bytes) throws IOException {\n+      final byte[] finalBytes;\n+      if (compressed) {\n+        finalBytes = Snappy.compress(bytes);\n+      } else {\n+        finalBytes = bytes;\n+      }\n+      int pos = currentSize;\n+      currentSize += finalBytes.length;\n+      if (currentSize > MAX_FILE_SIZE) {\n+        out.close();\n+        out = new FileOutputStream(filenameGenerator.apply(++fileNumber, compressed).toFile());\n+        currentSize = finalBytes.length;\n+        pos = 0;\n+      }\n+      index.writeShort(fileNumber);\n+      index.writeInt(pos);\n+      out.write(finalBytes);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+      out.close();\n+      index.close();\n+    }\n+  }\n+\n+  public static final class BackupStatus {\n+    long targetBlock;\n+    long storedBlock;\n+    boolean compressed;\n+    Bytes32 currentAccount;\n+    Bytes32 currentStorage;\n+    AtomicLong accountCount = new AtomicLong(0);\n+    AtomicLong codeSize = new AtomicLong(0);\n+    AtomicLong storageCount = new AtomicLong(0);\n+    boolean requestAccepted;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "536dcfcaa84dfa034723ec94a591bf5f90ae50ab"}, "originalPosition": 412}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0NjA1OQ==", "bodyText": "(optional) checkState here and below as well", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r467146059", "createdAt": "2020-08-07T16:31:49Z", "author": {"login": "RatanRSur"}, "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/query/StateBackupService.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.api.query;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import org.hyperledger.besu.config.JsonUtil;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.TransactionReceipt;\n+import org.hyperledger.besu.ethereum.eth.manager.EthScheduler;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.Node;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.TrieIterator;\n+import org.hyperledger.besu.ethereum.trie.TrieIterator.State;\n+import org.hyperledger.besu.ethereum.worldstate.StateTrieAccountValue;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateStorage;\n+import org.hyperledger.besu.plugin.data.Hash;\n+\n+import java.io.Closeable;\n+import java.io.DataOutputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import com.fasterxml.jackson.annotation.JsonGetter;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.xerial.snappy.Snappy;\n+\n+public class StateBackupService {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final long MAX_FILE_SIZE = 1 << 28; // 256 MiB max file size\n+  private static final Bytes ACCOUNT_END_MARKER;\n+\n+  static {\n+    final BytesValueRLPOutput endMarker = new BytesValueRLPOutput();\n+    endMarker.startList();\n+    endMarker.endList();\n+    ACCOUNT_END_MARKER = endMarker.encoded();\n+  }\n+\n+  private final String besuVesion;\n+  private final Lock submissionLock = new ReentrantLock();\n+  private final EthScheduler scheduler;\n+  private final Blockchain blockchain;\n+  private final WorldStateStorage worldStateStorage;\n+  private final BackupStatus backupStatus = new BackupStatus();\n+\n+  private Path backupDir;\n+  private RollingFileWriter accountFileWriter;\n+\n+  public StateBackupService(\n+      final String besuVesion,\n+      final Blockchain blockchain,\n+      final Path backupDir,\n+      final EthScheduler scheduler,\n+      final WorldStateStorage worldStateStorage) {\n+    this.besuVesion = besuVesion;\n+    this.blockchain = blockchain;\n+    this.backupDir = backupDir;\n+    this.scheduler = scheduler;\n+    this.worldStateStorage = worldStateStorage;\n+  }\n+\n+  public Path getBackupDir() {\n+    return backupDir;\n+  }\n+\n+  public BackupStatus requestBackup(\n+      final long block, final boolean compress, final Optional<Path> backupDir) {\n+    boolean requestAccepted = false;\n+    try {\n+      if (submissionLock.tryLock(100, TimeUnit.MILLISECONDS)) {\n+        try {\n+          if (!backupStatus.isBackingUp()) {\n+            requestAccepted = true;\n+            this.backupDir = backupDir.orElse(this.backupDir);\n+            backupStatus.targetBlock = block;\n+            backupStatus.compressed = compress;\n+            backupStatus.currentAccount = Bytes32.ZERO;\n+            scheduler.scheduleComputationTask(\n+                () -> {\n+                  try {\n+                    return backup(block, compress);\n+\n+                  } catch (final IOException ioe) {\n+                    LOG.error(\"Error writing backups\", ioe);\n+                    return backupStatus;\n+                  }\n+                });\n+          }\n+        } finally {\n+          submissionLock.unlock();\n+        }\n+      }\n+    } catch (final InterruptedException e) {\n+      // ignore\n+    }\n+    backupStatus.requestAccepted = requestAccepted;\n+    return backupStatus;\n+  }\n+\n+  public static Path dataFileToIndex(final Path dataName) {\n+    return Path.of(dataName.toString().replaceAll(\"(.*)[-.]\\\\d\\\\d\\\\d\\\\d\\\\.(.)dat\", \"$1.$2idx\"));\n+  }\n+\n+  public static Path accountFileName(\n+      final Path backupDir,\n+      final long targetBlock,\n+      final int fileNumber,\n+      final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\n+            \"besu-account-backup-%08d-%04d.%sdat\",\n+            targetBlock, fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path headerFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-header-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path bodyFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-body-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path receiptFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-receipt-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  private Path accountFileName(final int fileNumber, final boolean compressed) {\n+    return accountFileName(backupDir, backupStatus.targetBlock, fileNumber, compressed);\n+  }\n+\n+  private Path headerFileName(final int fileNumber, final boolean compressed) {\n+    return headerFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path bodyFileName(final int fileNumber, final boolean compressed) {\n+    return bodyFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path receiptFileName(final int fileNumber, final boolean compressed) {\n+    return receiptFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private BackupStatus backup(final long block, final boolean compress) throws IOException {\n+    try {\n+      checkArgument(\n+          block >= 0 && block <= blockchain.getChainHeadBlockNumber(),\n+          \"Backup Block must be within blockchain\");\n+      backupStatus.targetBlock = block;\n+      backupStatus.compressed = compress;\n+      backupStatus.currentAccount = Bytes32.ZERO;\n+\n+      backupChaindata();\n+      backupLeaves();\n+\n+      writeManifest();\n+\n+      return backupStatus;\n+    } catch (final Throwable t) {\n+      LOG.error(\"Unexpected error\", t);\n+      throw t;\n+    }\n+  }\n+\n+  private void writeManifest() throws IOException {\n+    final Map<String, Object> manifest = new HashMap<>();\n+    manifest.put(\"clientVersion\", besuVesion);\n+    manifest.put(\"compressed\", backupStatus.compressed);\n+    manifest.put(\"targetBlock\", backupStatus.targetBlock);\n+    manifest.put(\"accountCount\", backupStatus.accountCount);\n+\n+    Files.write(\n+        backupDir.resolve(\"besu-backup-manifest.json\"),\n+        JsonUtil.getJson(manifest).getBytes(StandardCharsets.UTF_8));\n+  }\n+\n+  private void backupLeaves() throws IOException {\n+    final Optional<BlockHeader> header = blockchain.getBlockHeader(backupStatus.targetBlock);\n+    if (header.isEmpty()) {\n+      backupStatus.currentAccount = null;\n+      return;\n+    }\n+    final Optional<Bytes> worldStateRoot =\n+        worldStateStorage.getAccountStateTrieNode(header.get().getStateRoot());\n+    if (worldStateRoot.isEmpty()) {\n+      backupStatus.currentAccount = null;\n+      return;\n+    }\n+\n+    try (final RollingFileWriter accountFileWriter =\n+        new RollingFileWriter(this::accountFileName, backupStatus.compressed)) {\n+      this.accountFileWriter = accountFileWriter;\n+\n+      final StoredMerklePatriciaTrie<Bytes32, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              worldStateStorage::getAccountStateTrieNode,\n+              header.get().getStateRoot(),\n+              Function.identity(),\n+              Function.identity());\n+\n+      accountTrie.visitLeafs(this::visitAccount);\n+      backupStatus.currentAccount = null;\n+    }\n+  }\n+\n+  private TrieIterator.State visitAccount(final Bytes32 nodeKey, final Node<Bytes> node) {\n+    if (node.getValue().isEmpty()) {\n+      return State.CONTINUE;\n+    }\n+\n+    backupStatus.currentAccount = nodeKey;\n+    final Bytes nodeValue = node.getValue().orElse(Hash.EMPTY);\n+    final StateTrieAccountValue account =\n+        StateTrieAccountValue.readFrom(new BytesValueRLPInput(nodeValue, false));\n+\n+    final Bytes code = worldStateStorage.getCode(account.getCodeHash()).orElse(Bytes.EMPTY);\n+    backupStatus.codeSize.addAndGet(code.size());\n+\n+    final BytesValueRLPOutput accountOutput = new BytesValueRLPOutput();\n+    accountOutput.startList();\n+    accountOutput.writeBytes(nodeKey); // trie hash\n+    accountOutput.writeBytes(nodeValue); // account rlp\n+    accountOutput.writeBytes(code); // code\n+    accountOutput.endList();\n+\n+    try {\n+      accountFileWriter.writeBytes(accountOutput.encoded().toArrayUnsafe());\n+    } catch (final IOException ioe) {\n+      LOG.error(\"Failure writing backup\", ioe);\n+      return State.STOP;\n+    }\n+\n+    // storage is written for each leaf, otherwise the whole trie would have to fit in memory\n+    final StoredMerklePatriciaTrie<Bytes32, Bytes> storageTrie =\n+        new StoredMerklePatriciaTrie<>(\n+            worldStateStorage::getAccountStateTrieNode,\n+            account.getStorageRoot(),\n+            Function.identity(),\n+            Function.identity());\n+    storageTrie.visitLeafs(\n+        (storageKey, storageValue) ->\n+            visitAccountStorage(storageKey, storageValue, accountFileWriter));\n+\n+    try {\n+      accountFileWriter.writeBytes(ACCOUNT_END_MARKER.toArrayUnsafe());\n+    } catch (final IOException ioe) {\n+      LOG.error(\"Failure writing backup\", ioe);\n+      return State.STOP;\n+    }\n+\n+    backupStatus.accountCount.incrementAndGet();\n+    return State.CONTINUE;\n+  }\n+\n+  private void backupChaindata() throws IOException {\n+    try (final RollingFileWriter headerWriter =\n+            new RollingFileWriter(this::headerFileName, backupStatus.compressed);\n+        final RollingFileWriter bodyWriter =\n+            new RollingFileWriter(this::bodyFileName, backupStatus.compressed);\n+        final RollingFileWriter receiptsWriter =\n+            new RollingFileWriter(this::receiptFileName, backupStatus.compressed)) {\n+      for (int blockNumber = 0; blockNumber <= backupStatus.targetBlock; blockNumber++) {\n+        final Optional<Block> block = blockchain.getBlockByNumber(blockNumber);\n+        if (block.isEmpty()) {\n+          throw new IllegalStateException(\n+              \"Block data for \" + blockNumber + \" was not found in the archive\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "536dcfcaa84dfa034723ec94a591bf5f90ae50ab"}, "originalPosition": 310}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0NjczNg==", "bodyText": "This is surprising to me, there can't be any blocks without receipts? How does it work for empty blocks?", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r467146736", "createdAt": "2020-08-07T16:33:17Z", "author": {"login": "RatanRSur"}, "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/query/StateBackupService.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.api.query;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import org.hyperledger.besu.config.JsonUtil;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.TransactionReceipt;\n+import org.hyperledger.besu.ethereum.eth.manager.EthScheduler;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.Node;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.TrieIterator;\n+import org.hyperledger.besu.ethereum.trie.TrieIterator.State;\n+import org.hyperledger.besu.ethereum.worldstate.StateTrieAccountValue;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateStorage;\n+import org.hyperledger.besu.plugin.data.Hash;\n+\n+import java.io.Closeable;\n+import java.io.DataOutputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import com.fasterxml.jackson.annotation.JsonGetter;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.xerial.snappy.Snappy;\n+\n+public class StateBackupService {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final long MAX_FILE_SIZE = 1 << 28; // 256 MiB max file size\n+  private static final Bytes ACCOUNT_END_MARKER;\n+\n+  static {\n+    final BytesValueRLPOutput endMarker = new BytesValueRLPOutput();\n+    endMarker.startList();\n+    endMarker.endList();\n+    ACCOUNT_END_MARKER = endMarker.encoded();\n+  }\n+\n+  private final String besuVesion;\n+  private final Lock submissionLock = new ReentrantLock();\n+  private final EthScheduler scheduler;\n+  private final Blockchain blockchain;\n+  private final WorldStateStorage worldStateStorage;\n+  private final BackupStatus backupStatus = new BackupStatus();\n+\n+  private Path backupDir;\n+  private RollingFileWriter accountFileWriter;\n+\n+  public StateBackupService(\n+      final String besuVesion,\n+      final Blockchain blockchain,\n+      final Path backupDir,\n+      final EthScheduler scheduler,\n+      final WorldStateStorage worldStateStorage) {\n+    this.besuVesion = besuVesion;\n+    this.blockchain = blockchain;\n+    this.backupDir = backupDir;\n+    this.scheduler = scheduler;\n+    this.worldStateStorage = worldStateStorage;\n+  }\n+\n+  public Path getBackupDir() {\n+    return backupDir;\n+  }\n+\n+  public BackupStatus requestBackup(\n+      final long block, final boolean compress, final Optional<Path> backupDir) {\n+    boolean requestAccepted = false;\n+    try {\n+      if (submissionLock.tryLock(100, TimeUnit.MILLISECONDS)) {\n+        try {\n+          if (!backupStatus.isBackingUp()) {\n+            requestAccepted = true;\n+            this.backupDir = backupDir.orElse(this.backupDir);\n+            backupStatus.targetBlock = block;\n+            backupStatus.compressed = compress;\n+            backupStatus.currentAccount = Bytes32.ZERO;\n+            scheduler.scheduleComputationTask(\n+                () -> {\n+                  try {\n+                    return backup(block, compress);\n+\n+                  } catch (final IOException ioe) {\n+                    LOG.error(\"Error writing backups\", ioe);\n+                    return backupStatus;\n+                  }\n+                });\n+          }\n+        } finally {\n+          submissionLock.unlock();\n+        }\n+      }\n+    } catch (final InterruptedException e) {\n+      // ignore\n+    }\n+    backupStatus.requestAccepted = requestAccepted;\n+    return backupStatus;\n+  }\n+\n+  public static Path dataFileToIndex(final Path dataName) {\n+    return Path.of(dataName.toString().replaceAll(\"(.*)[-.]\\\\d\\\\d\\\\d\\\\d\\\\.(.)dat\", \"$1.$2idx\"));\n+  }\n+\n+  public static Path accountFileName(\n+      final Path backupDir,\n+      final long targetBlock,\n+      final int fileNumber,\n+      final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\n+            \"besu-account-backup-%08d-%04d.%sdat\",\n+            targetBlock, fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path headerFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-header-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path bodyFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-body-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path receiptFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-receipt-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  private Path accountFileName(final int fileNumber, final boolean compressed) {\n+    return accountFileName(backupDir, backupStatus.targetBlock, fileNumber, compressed);\n+  }\n+\n+  private Path headerFileName(final int fileNumber, final boolean compressed) {\n+    return headerFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path bodyFileName(final int fileNumber, final boolean compressed) {\n+    return bodyFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path receiptFileName(final int fileNumber, final boolean compressed) {\n+    return receiptFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private BackupStatus backup(final long block, final boolean compress) throws IOException {\n+    try {\n+      checkArgument(\n+          block >= 0 && block <= blockchain.getChainHeadBlockNumber(),\n+          \"Backup Block must be within blockchain\");\n+      backupStatus.targetBlock = block;\n+      backupStatus.compressed = compress;\n+      backupStatus.currentAccount = Bytes32.ZERO;\n+\n+      backupChaindata();\n+      backupLeaves();\n+\n+      writeManifest();\n+\n+      return backupStatus;\n+    } catch (final Throwable t) {\n+      LOG.error(\"Unexpected error\", t);\n+      throw t;\n+    }\n+  }\n+\n+  private void writeManifest() throws IOException {\n+    final Map<String, Object> manifest = new HashMap<>();\n+    manifest.put(\"clientVersion\", besuVesion);\n+    manifest.put(\"compressed\", backupStatus.compressed);\n+    manifest.put(\"targetBlock\", backupStatus.targetBlock);\n+    manifest.put(\"accountCount\", backupStatus.accountCount);\n+\n+    Files.write(\n+        backupDir.resolve(\"besu-backup-manifest.json\"),\n+        JsonUtil.getJson(manifest).getBytes(StandardCharsets.UTF_8));\n+  }\n+\n+  private void backupLeaves() throws IOException {\n+    final Optional<BlockHeader> header = blockchain.getBlockHeader(backupStatus.targetBlock);\n+    if (header.isEmpty()) {\n+      backupStatus.currentAccount = null;\n+      return;\n+    }\n+    final Optional<Bytes> worldStateRoot =\n+        worldStateStorage.getAccountStateTrieNode(header.get().getStateRoot());\n+    if (worldStateRoot.isEmpty()) {\n+      backupStatus.currentAccount = null;\n+      return;\n+    }\n+\n+    try (final RollingFileWriter accountFileWriter =\n+        new RollingFileWriter(this::accountFileName, backupStatus.compressed)) {\n+      this.accountFileWriter = accountFileWriter;\n+\n+      final StoredMerklePatriciaTrie<Bytes32, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              worldStateStorage::getAccountStateTrieNode,\n+              header.get().getStateRoot(),\n+              Function.identity(),\n+              Function.identity());\n+\n+      accountTrie.visitLeafs(this::visitAccount);\n+      backupStatus.currentAccount = null;\n+    }\n+  }\n+\n+  private TrieIterator.State visitAccount(final Bytes32 nodeKey, final Node<Bytes> node) {\n+    if (node.getValue().isEmpty()) {\n+      return State.CONTINUE;\n+    }\n+\n+    backupStatus.currentAccount = nodeKey;\n+    final Bytes nodeValue = node.getValue().orElse(Hash.EMPTY);\n+    final StateTrieAccountValue account =\n+        StateTrieAccountValue.readFrom(new BytesValueRLPInput(nodeValue, false));\n+\n+    final Bytes code = worldStateStorage.getCode(account.getCodeHash()).orElse(Bytes.EMPTY);\n+    backupStatus.codeSize.addAndGet(code.size());\n+\n+    final BytesValueRLPOutput accountOutput = new BytesValueRLPOutput();\n+    accountOutput.startList();\n+    accountOutput.writeBytes(nodeKey); // trie hash\n+    accountOutput.writeBytes(nodeValue); // account rlp\n+    accountOutput.writeBytes(code); // code\n+    accountOutput.endList();\n+\n+    try {\n+      accountFileWriter.writeBytes(accountOutput.encoded().toArrayUnsafe());\n+    } catch (final IOException ioe) {\n+      LOG.error(\"Failure writing backup\", ioe);\n+      return State.STOP;\n+    }\n+\n+    // storage is written for each leaf, otherwise the whole trie would have to fit in memory\n+    final StoredMerklePatriciaTrie<Bytes32, Bytes> storageTrie =\n+        new StoredMerklePatriciaTrie<>(\n+            worldStateStorage::getAccountStateTrieNode,\n+            account.getStorageRoot(),\n+            Function.identity(),\n+            Function.identity());\n+    storageTrie.visitLeafs(\n+        (storageKey, storageValue) ->\n+            visitAccountStorage(storageKey, storageValue, accountFileWriter));\n+\n+    try {\n+      accountFileWriter.writeBytes(ACCOUNT_END_MARKER.toArrayUnsafe());\n+    } catch (final IOException ioe) {\n+      LOG.error(\"Failure writing backup\", ioe);\n+      return State.STOP;\n+    }\n+\n+    backupStatus.accountCount.incrementAndGet();\n+    return State.CONTINUE;\n+  }\n+\n+  private void backupChaindata() throws IOException {\n+    try (final RollingFileWriter headerWriter =\n+            new RollingFileWriter(this::headerFileName, backupStatus.compressed);\n+        final RollingFileWriter bodyWriter =\n+            new RollingFileWriter(this::bodyFileName, backupStatus.compressed);\n+        final RollingFileWriter receiptsWriter =\n+            new RollingFileWriter(this::receiptFileName, backupStatus.compressed)) {\n+      for (int blockNumber = 0; blockNumber <= backupStatus.targetBlock; blockNumber++) {\n+        final Optional<Block> block = blockchain.getBlockByNumber(blockNumber);\n+        if (block.isEmpty()) {\n+          throw new IllegalStateException(\n+              \"Block data for \" + blockNumber + \" was not found in the archive\");\n+        }\n+        final Optional<List<TransactionReceipt>> receipts =\n+            blockchain.getTxReceipts(block.get().getHash());\n+        if (receipts.isEmpty()) {\n+          throw new IllegalStateException(\n+              \"Receipts for \" + blockNumber + \" was not found in the archive\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "536dcfcaa84dfa034723ec94a591bf5f90ae50ab"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxMTk4Mg==", "bodyText": "I'm kinda confused about what this does.\nAlso, won't isBackingUp return false when we're backing up the leaves?", "url": "https://github.com/hyperledger/besu/pull/1235#discussion_r467211982", "createdAt": "2020-08-07T18:49:11Z", "author": {"login": "RatanRSur"}, "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/query/StateBackupService.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.api.query;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import org.hyperledger.besu.config.JsonUtil;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.TransactionReceipt;\n+import org.hyperledger.besu.ethereum.eth.manager.EthScheduler;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.Node;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.TrieIterator;\n+import org.hyperledger.besu.ethereum.trie.TrieIterator.State;\n+import org.hyperledger.besu.ethereum.worldstate.StateTrieAccountValue;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateStorage;\n+import org.hyperledger.besu.plugin.data.Hash;\n+\n+import java.io.Closeable;\n+import java.io.DataOutputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import com.fasterxml.jackson.annotation.JsonGetter;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.xerial.snappy.Snappy;\n+\n+public class StateBackupService {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final long MAX_FILE_SIZE = 1 << 28; // 256 MiB max file size\n+  private static final Bytes ACCOUNT_END_MARKER;\n+\n+  static {\n+    final BytesValueRLPOutput endMarker = new BytesValueRLPOutput();\n+    endMarker.startList();\n+    endMarker.endList();\n+    ACCOUNT_END_MARKER = endMarker.encoded();\n+  }\n+\n+  private final String besuVesion;\n+  private final Lock submissionLock = new ReentrantLock();\n+  private final EthScheduler scheduler;\n+  private final Blockchain blockchain;\n+  private final WorldStateStorage worldStateStorage;\n+  private final BackupStatus backupStatus = new BackupStatus();\n+\n+  private Path backupDir;\n+  private RollingFileWriter accountFileWriter;\n+\n+  public StateBackupService(\n+      final String besuVesion,\n+      final Blockchain blockchain,\n+      final Path backupDir,\n+      final EthScheduler scheduler,\n+      final WorldStateStorage worldStateStorage) {\n+    this.besuVesion = besuVesion;\n+    this.blockchain = blockchain;\n+    this.backupDir = backupDir;\n+    this.scheduler = scheduler;\n+    this.worldStateStorage = worldStateStorage;\n+  }\n+\n+  public Path getBackupDir() {\n+    return backupDir;\n+  }\n+\n+  public BackupStatus requestBackup(\n+      final long block, final boolean compress, final Optional<Path> backupDir) {\n+    boolean requestAccepted = false;\n+    try {\n+      if (submissionLock.tryLock(100, TimeUnit.MILLISECONDS)) {\n+        try {\n+          if (!backupStatus.isBackingUp()) {\n+            requestAccepted = true;\n+            this.backupDir = backupDir.orElse(this.backupDir);\n+            backupStatus.targetBlock = block;\n+            backupStatus.compressed = compress;\n+            backupStatus.currentAccount = Bytes32.ZERO;\n+            scheduler.scheduleComputationTask(\n+                () -> {\n+                  try {\n+                    return backup(block, compress);\n+\n+                  } catch (final IOException ioe) {\n+                    LOG.error(\"Error writing backups\", ioe);\n+                    return backupStatus;\n+                  }\n+                });\n+          }\n+        } finally {\n+          submissionLock.unlock();\n+        }\n+      }\n+    } catch (final InterruptedException e) {\n+      // ignore\n+    }\n+    backupStatus.requestAccepted = requestAccepted;\n+    return backupStatus;\n+  }\n+\n+  public static Path dataFileToIndex(final Path dataName) {\n+    return Path.of(dataName.toString().replaceAll(\"(.*)[-.]\\\\d\\\\d\\\\d\\\\d\\\\.(.)dat\", \"$1.$2idx\"));\n+  }\n+\n+  public static Path accountFileName(\n+      final Path backupDir,\n+      final long targetBlock,\n+      final int fileNumber,\n+      final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\n+            \"besu-account-backup-%08d-%04d.%sdat\",\n+            targetBlock, fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path headerFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-header-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path bodyFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-body-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  public static Path receiptFileName(\n+      final Path backupDir, final int fileNumber, final boolean compressed) {\n+    return backupDir.resolve(\n+        String.format(\"besu-receipt-backup-%04d.%sdat\", fileNumber, compressed ? \"c\" : \"r\"));\n+  }\n+\n+  private Path accountFileName(final int fileNumber, final boolean compressed) {\n+    return accountFileName(backupDir, backupStatus.targetBlock, fileNumber, compressed);\n+  }\n+\n+  private Path headerFileName(final int fileNumber, final boolean compressed) {\n+    return headerFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path bodyFileName(final int fileNumber, final boolean compressed) {\n+    return bodyFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private Path receiptFileName(final int fileNumber, final boolean compressed) {\n+    return receiptFileName(backupDir, fileNumber, compressed);\n+  }\n+\n+  private BackupStatus backup(final long block, final boolean compress) throws IOException {\n+    try {\n+      checkArgument(\n+          block >= 0 && block <= blockchain.getChainHeadBlockNumber(),\n+          \"Backup Block must be within blockchain\");\n+      backupStatus.targetBlock = block;\n+      backupStatus.compressed = compress;\n+      backupStatus.currentAccount = Bytes32.ZERO;\n+\n+      backupChaindata();\n+      backupLeaves();\n+\n+      writeManifest();\n+\n+      return backupStatus;\n+    } catch (final Throwable t) {\n+      LOG.error(\"Unexpected error\", t);\n+      throw t;\n+    }\n+  }\n+\n+  private void writeManifest() throws IOException {\n+    final Map<String, Object> manifest = new HashMap<>();\n+    manifest.put(\"clientVersion\", besuVesion);\n+    manifest.put(\"compressed\", backupStatus.compressed);\n+    manifest.put(\"targetBlock\", backupStatus.targetBlock);\n+    manifest.put(\"accountCount\", backupStatus.accountCount);\n+\n+    Files.write(\n+        backupDir.resolve(\"besu-backup-manifest.json\"),\n+        JsonUtil.getJson(manifest).getBytes(StandardCharsets.UTF_8));\n+  }\n+\n+  private void backupLeaves() throws IOException {\n+    final Optional<BlockHeader> header = blockchain.getBlockHeader(backupStatus.targetBlock);\n+    if (header.isEmpty()) {\n+      backupStatus.currentAccount = null;\n+      return;\n+    }\n+    final Optional<Bytes> worldStateRoot =\n+        worldStateStorage.getAccountStateTrieNode(header.get().getStateRoot());\n+    if (worldStateRoot.isEmpty()) {\n+      backupStatus.currentAccount = null;\n+      return;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "536dcfcaa84dfa034723ec94a591bf5f90ae50ab"}, "originalPosition": 231}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fe5c09a3d70e18f3d2d8c91be2ef811c60a16be", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/6fe5c09a3d70e18f3d2d8c91be2ef811c60a16be", "committedDate": "2020-08-07T23:42:12Z", "message": "checkState\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NTE2Nzg3", "url": "https://github.com/hyperledger/besu/pull/1235#pullrequestreview-464516787", "createdAt": "2020-08-10T19:28:10Z", "commit": {"oid": "6fe5c09a3d70e18f3d2d8c91be2ef811c60a16be"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04f51bcdc0dbe64ac7938f8829544a8bcd41677b", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/04f51bcdc0dbe64ac7938f8829544a8bcd41677b", "committedDate": "2020-08-10T20:59:09Z", "message": "Merge branch 'master' into backupGenerate"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cb3c5ea15b37149fb180a7efd787948e4ad0053", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/5cb3c5ea15b37149fb180a7efd787948e4ad0053", "committedDate": "2020-08-10T21:09:41Z", "message": "changelog\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8617430a60f8e46468b9a1785cd60063ebfdc101", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/8617430a60f8e46468b9a1785cd60063ebfdc101", "committedDate": "2020-08-10T21:10:28Z", "message": "a word\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1446, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}