{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyMTAzNDg2", "number": 1664, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMjoyMzoxNFrOFAhheg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxNzo1MDozMFrOFBRvvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MDkzNTYyOnYy", "diffSide": "LEFT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiAccount.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMjoyMzoxNFrOH-3wGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMjoyMzoxNFrOH-3wGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY4NzE5NA==", "bodyText": "\ud83e\udd23", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r535687194", "createdAt": "2020-12-03T22:23:14Z", "author": {"login": "timbeiko"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiAccount.java", "diffHunk": "@@ -251,7 +251,7 @@ public UInt256 getOriginalStorageValue(final UInt256 key) {\n   @Override\n   public NavigableMap<Bytes32, AccountStorageEntry> storageEntriesFrom(\n       final Bytes32 startKeyHash, final int limit) {\n-    throw new RuntimeException(\"LOL no\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ce1bf43aa2de39044b0a277b603e9caabd35408"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MzYyODc3OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMjozNjozNFrOH_PEKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMzo1NzoyOVrOH_SAWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA2OTE2MQ==", "bodyText": "Does this byte32 with SuppressWarnings unused is important ? For future use ?", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536069161", "createdAt": "2020-12-04T12:36:34Z", "author": {"login": "matkt"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static org.hyperledger.besu.ethereum.bonsai.BonsaiAccount.fromRLP;\n+\n+import org.hyperledger.besu.ethereum.core.Account;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.MerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorageTransaction;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import javax.annotation.Nonnull;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiPersistedWorldState implements MutableWorldState, BonsaiWorldState {\n+\n+  private static final byte[] WORLD_ROOT_KEY = \"worldRoot\".getBytes(StandardCharsets.UTF_8);\n+\n+  private final KeyValueStorage accountStorage;\n+  private final KeyValueStorage codeStorage;\n+  private final KeyValueStorage storageStorage;\n+  private final KeyValueStorage trieBranchStorage;\n+  private final KeyValueStorage trieLogStorage;\n+\n+  private Bytes32 worldStateRootHash;\n+\n+  private final BonsaiWorldStateArchive archive;\n+  private BonsaiWorldStateUpdater updater;\n+\n+  public BonsaiPersistedWorldState(\n+      final BonsaiWorldStateArchive archive,\n+      final KeyValueStorage accountStorage,\n+      final KeyValueStorage codeStorage,\n+      final KeyValueStorage storageStorage,\n+      final KeyValueStorage trieBranchStorage,\n+      final KeyValueStorage trieLogStorage) {\n+    this.archive = archive;\n+    this.accountStorage = accountStorage;\n+    this.codeStorage = codeStorage;\n+    this.storageStorage = storageStorage;\n+    this.trieBranchStorage = trieBranchStorage;\n+    this.trieLogStorage = trieLogStorage;\n+    worldStateRootHash =\n+        Bytes32.wrap(\n+            trieBranchStorage.get(WORLD_ROOT_KEY).map(Bytes::wrap).orElse(Hash.EMPTY_TRIE_HASH));\n+  }\n+\n+  public BonsaiWorldStateArchive getArchive() {\n+    return archive;\n+  }\n+\n+  @Override\n+  public MutableWorldState copy() {\n+    throw new UnsupportedOperationException(\n+        \"Bonsai Tries does not support direct duplication of the persisted tries.\");\n+  }\n+\n+  @Override\n+  public Bytes getCode(@Nonnull final Address address) {\n+    return codeStorage.get(address.toArrayUnsafe()).map(Bytes::wrap).orElse(Bytes.EMPTY);\n+  }\n+\n+  @Override\n+  public void persist(final Hash blockHash) {\n+    boolean success = false;\n+    final KeyValueStorageTransaction accountTx = accountStorage.startTransaction();\n+    final KeyValueStorageTransaction codeTx = codeStorage.startTransaction();\n+    final KeyValueStorageTransaction storageTx = storageStorage.startTransaction();\n+    final KeyValueStorageTransaction trieBranchTx = trieBranchStorage.startTransaction();\n+    final KeyValueStorageTransaction trieLogTx = trieLogStorage.startTransaction();\n+\n+    try {\n+      // first clear storage\n+      for (final Address address : updater.getStorageToClear()) {\n+        // because we are clearing persisted values we need the account root as persisted\n+        final BonsaiAccount oldAccount =\n+            accountStorage\n+                .get(address.toArrayUnsafe())\n+                .map(\n+                    bytes ->\n+                        fromRLP(BonsaiPersistedWorldState.this, address, Bytes.wrap(bytes), true))\n+                .orElse(null);\n+        if (oldAccount == null) {\n+          // This is when an account is both created and deleted within the scope of the same\n+          // block.  A not-uncommon DeFi bot pattern.\n+          continue;\n+        }\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(address, location, key),\n+                oldAccount.getStorageRoot(),\n+                Function.identity(),\n+                Function.identity());\n+        Map<Bytes32, Bytes> entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+        while (!entriesToDelete.isEmpty()) {\n+          entriesToDelete\n+              .keySet()\n+              .forEach(k -> storageTx.remove(Bytes.concatenate(address, k).toArrayUnsafe()));\n+          if (entriesToDelete.size() == 256) {\n+            entriesToDelete.keySet().forEach(storageTrie::remove);\n+            entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+          } else {\n+            break;\n+          }\n+        }\n+      }\n+\n+      // second update account storage state.  This must be done before updating the accounts so\n+      // that we can get the storage state hash\n+      for (final Map.Entry<Address, Map<Hash, BonsaiValue<UInt256>>> storageAccountUpdate :\n+          updater.getStorageToUpdate().entrySet()) {\n+        final Address updatedAddress = storageAccountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> accountValue =\n+            updater.getAccountsToUpdate().get(updatedAddress);\n+        final BonsaiAccount accountOriginal = accountValue.getOriginal();\n+        final Hash storageRoot =\n+            (accountOriginal == null) ? Hash.EMPTY_TRIE_HASH : accountOriginal.getStorageRoot();\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(updatedAddress, location, key),\n+                storageRoot,\n+                Function.identity(),\n+                Function.identity());\n+\n+        // for manicured tries and composting, collect branches here (not implemented)\n+\n+        for (final Map.Entry<Hash, BonsaiValue<UInt256>> storageUpdate :\n+            storageAccountUpdate.getValue().entrySet()) {\n+          final Hash keyHash = storageUpdate.getKey();\n+          final byte[] writeAddress = Bytes.concatenate(updatedAddress, keyHash).toArrayUnsafe();\n+          final UInt256 updatedStorage = storageUpdate.getValue().getUpdated();\n+          if (updatedStorage == null || updatedStorage.equals(UInt256.ZERO)) {\n+            storageTx.remove(writeAddress);\n+            storageTrie.remove(keyHash);\n+          } else {\n+            final Bytes32 updatedStorageBytes = updatedStorage.toBytes();\n+            storageTx.put(writeAddress, updatedStorageBytes.toArrayUnsafe());\n+            storageTrie.put(keyHash, rlpEncode(updatedStorageBytes));\n+          }\n+        }\n+\n+        final BonsaiAccount accountUpdated = accountValue.getUpdated();\n+        if (accountUpdated != null) {\n+          storageTrie.commit(\n+              (location, key, value) ->\n+                  writeStorageTrieNode(trieBranchTx, updatedAddress, location, key, value));\n+          final Hash newStorageRoot = Hash.wrap(storageTrie.getRootHash());\n+          accountUpdated.setStorageRoot(newStorageRoot);\n+        }\n+        // for manicured tries and composting, trim and compost here\n+      }\n+\n+      // Third update the code.  This has the side effect of ensuring a code hash is calculated.\n+      for (final Map.Entry<Address, BonsaiValue<Bytes>> codeUpdate :\n+          updater.getCodeToUpdate().entrySet()) {\n+        final Bytes updatedCode = codeUpdate.getValue().getUpdated();\n+        if (updatedCode == null || updatedCode.size() == 0) {\n+          codeTx.remove(codeUpdate.getKey().toArrayUnsafe());\n+        } else {\n+          codeTx.put(codeUpdate.getKey().toArrayUnsafe(), updatedCode.toArrayUnsafe());\n+        }\n+      }\n+\n+      // next collect the branches that will be trimmed\n+      final StoredMerklePatriciaTrie<Bytes, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              this::getTrieNode, worldStateRootHash, Function.identity(), Function.identity());\n+\n+      // for manicured tries and composting, collect branches here (not implemented)\n+\n+      // now add the accounts\n+      for (final Map.Entry<Address, BonsaiValue<BonsaiAccount>> accountUpdate :\n+          updater.getAccountsToUpdate().entrySet()) {\n+        final Bytes accountKey = accountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> bonsaiValue = accountUpdate.getValue();\n+        final BonsaiAccount updatedAccount = bonsaiValue.getUpdated();\n+        if (updatedAccount == null) {\n+          final Hash addressHash = Hash.hash(accountKey);\n+          accountTrie.remove(addressHash);\n+          accountTx.remove(accountKey.toArrayUnsafe());\n+        } else {\n+          final Hash addressHash = updatedAccount.getAddressHash();\n+          final Bytes accountValue = updatedAccount.serializeAccount();\n+          accountTx.put(accountKey.toArrayUnsafe(), accountValue.toArrayUnsafe());\n+          accountTrie.put(addressHash, accountValue);\n+        }\n+      }\n+\n+      accountTrie.commit(\n+          (location, hash, value) -> writeTrieNode(trieBranchTx, location, hash, value));\n+      worldStateRootHash = accountTrie.getRootHash();\n+      trieBranchTx.put(WORLD_ROOT_KEY, worldStateRootHash.toArrayUnsafe());\n+\n+      // for manicured tries and composting, trim and compost branches here\n+\n+      if (blockHash != null) {\n+        final TrieLogLayer trieLog = updater.generateTrieLog(blockHash);\n+        trieLog.freeze();\n+        // TODO add to archive here, but only once we get persisted follow distance implemented\n+        // archive.addLayeredWorldState(new BonsaiLayeredWorldState(this, trieLog));\n+\n+        final BytesValueRLPOutput rlpLog = new BytesValueRLPOutput();\n+        trieLog.writeTo(rlpLog);\n+        trieLogTx.put(blockHash.toArrayUnsafe(), rlpLog.encoded().toArrayUnsafe());\n+      }\n+\n+      success = true;\n+    } finally {\n+      if (success) {\n+        accountTx.commit();\n+        codeTx.commit();\n+        storageTx.commit();\n+        trieBranchTx.commit();\n+        trieLogTx.commit();\n+        updater.reset();\n+      } else {\n+        accountTx.rollback();\n+        codeTx.rollback();\n+        storageTx.rollback();\n+        trieBranchTx.rollback();\n+        trieLogTx.rollback();\n+      }\n+    }\n+  }\n+\n+  private static Bytes rlpEncode(final Bytes bytes) {\n+    final BytesValueRLPOutput out = new BytesValueRLPOutput();\n+    out.writeBytes(bytes.trimLeadingZeros());\n+    return out.encoded();\n+  }\n+\n+  @Override\n+  public WorldUpdater updater() {\n+    if (updater == null) {\n+      updater = new BonsaiWorldStateUpdater(this);\n+    }\n+    return updater;\n+  }\n+\n+  @Override\n+  public Hash rootHash() {\n+    return Hash.wrap(worldStateRootHash);\n+  }\n+\n+  @Override\n+  public Stream<StreamableAccount> streamAccounts(final Bytes32 startKeyHash, final int limit) {\n+    throw new RuntimeException(\"NIY\");\n+  }\n+\n+  @Override\n+  public Account get(final Address address) {\n+    return accountStorage\n+        .get(address.toArrayUnsafe())\n+        .map(bytes -> fromRLP(updater, address, Bytes.wrap(bytes), true))\n+        .orElse(null);\n+  }\n+\n+  private Optional<Bytes> getTrieNode(final Bytes location, final Bytes32 nodeHash) {\n+    if (nodeHash.equals(MerklePatriciaTrie.EMPTY_TRIE_NODE_HASH)) {\n+      return Optional.of(MerklePatriciaTrie.EMPTY_TRIE_NODE);\n+    } else {\n+      return trieBranchStorage.get(location.toArrayUnsafe()).map(Bytes::wrap);\n+    }\n+  }\n+\n+  private void writeTrieNode(\n+      final KeyValueStorageTransaction tx,\n+      final Bytes location,\n+      @SuppressWarnings(\"unused\") final Bytes32 nodeHash,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExNzMzOA==", "bodyText": "It can go since we are creating a custom lambda to call it anyway.", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536117338", "createdAt": "2020-12-04T13:57:29Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static org.hyperledger.besu.ethereum.bonsai.BonsaiAccount.fromRLP;\n+\n+import org.hyperledger.besu.ethereum.core.Account;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.MerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorageTransaction;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import javax.annotation.Nonnull;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiPersistedWorldState implements MutableWorldState, BonsaiWorldState {\n+\n+  private static final byte[] WORLD_ROOT_KEY = \"worldRoot\".getBytes(StandardCharsets.UTF_8);\n+\n+  private final KeyValueStorage accountStorage;\n+  private final KeyValueStorage codeStorage;\n+  private final KeyValueStorage storageStorage;\n+  private final KeyValueStorage trieBranchStorage;\n+  private final KeyValueStorage trieLogStorage;\n+\n+  private Bytes32 worldStateRootHash;\n+\n+  private final BonsaiWorldStateArchive archive;\n+  private BonsaiWorldStateUpdater updater;\n+\n+  public BonsaiPersistedWorldState(\n+      final BonsaiWorldStateArchive archive,\n+      final KeyValueStorage accountStorage,\n+      final KeyValueStorage codeStorage,\n+      final KeyValueStorage storageStorage,\n+      final KeyValueStorage trieBranchStorage,\n+      final KeyValueStorage trieLogStorage) {\n+    this.archive = archive;\n+    this.accountStorage = accountStorage;\n+    this.codeStorage = codeStorage;\n+    this.storageStorage = storageStorage;\n+    this.trieBranchStorage = trieBranchStorage;\n+    this.trieLogStorage = trieLogStorage;\n+    worldStateRootHash =\n+        Bytes32.wrap(\n+            trieBranchStorage.get(WORLD_ROOT_KEY).map(Bytes::wrap).orElse(Hash.EMPTY_TRIE_HASH));\n+  }\n+\n+  public BonsaiWorldStateArchive getArchive() {\n+    return archive;\n+  }\n+\n+  @Override\n+  public MutableWorldState copy() {\n+    throw new UnsupportedOperationException(\n+        \"Bonsai Tries does not support direct duplication of the persisted tries.\");\n+  }\n+\n+  @Override\n+  public Bytes getCode(@Nonnull final Address address) {\n+    return codeStorage.get(address.toArrayUnsafe()).map(Bytes::wrap).orElse(Bytes.EMPTY);\n+  }\n+\n+  @Override\n+  public void persist(final Hash blockHash) {\n+    boolean success = false;\n+    final KeyValueStorageTransaction accountTx = accountStorage.startTransaction();\n+    final KeyValueStorageTransaction codeTx = codeStorage.startTransaction();\n+    final KeyValueStorageTransaction storageTx = storageStorage.startTransaction();\n+    final KeyValueStorageTransaction trieBranchTx = trieBranchStorage.startTransaction();\n+    final KeyValueStorageTransaction trieLogTx = trieLogStorage.startTransaction();\n+\n+    try {\n+      // first clear storage\n+      for (final Address address : updater.getStorageToClear()) {\n+        // because we are clearing persisted values we need the account root as persisted\n+        final BonsaiAccount oldAccount =\n+            accountStorage\n+                .get(address.toArrayUnsafe())\n+                .map(\n+                    bytes ->\n+                        fromRLP(BonsaiPersistedWorldState.this, address, Bytes.wrap(bytes), true))\n+                .orElse(null);\n+        if (oldAccount == null) {\n+          // This is when an account is both created and deleted within the scope of the same\n+          // block.  A not-uncommon DeFi bot pattern.\n+          continue;\n+        }\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(address, location, key),\n+                oldAccount.getStorageRoot(),\n+                Function.identity(),\n+                Function.identity());\n+        Map<Bytes32, Bytes> entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+        while (!entriesToDelete.isEmpty()) {\n+          entriesToDelete\n+              .keySet()\n+              .forEach(k -> storageTx.remove(Bytes.concatenate(address, k).toArrayUnsafe()));\n+          if (entriesToDelete.size() == 256) {\n+            entriesToDelete.keySet().forEach(storageTrie::remove);\n+            entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+          } else {\n+            break;\n+          }\n+        }\n+      }\n+\n+      // second update account storage state.  This must be done before updating the accounts so\n+      // that we can get the storage state hash\n+      for (final Map.Entry<Address, Map<Hash, BonsaiValue<UInt256>>> storageAccountUpdate :\n+          updater.getStorageToUpdate().entrySet()) {\n+        final Address updatedAddress = storageAccountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> accountValue =\n+            updater.getAccountsToUpdate().get(updatedAddress);\n+        final BonsaiAccount accountOriginal = accountValue.getOriginal();\n+        final Hash storageRoot =\n+            (accountOriginal == null) ? Hash.EMPTY_TRIE_HASH : accountOriginal.getStorageRoot();\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(updatedAddress, location, key),\n+                storageRoot,\n+                Function.identity(),\n+                Function.identity());\n+\n+        // for manicured tries and composting, collect branches here (not implemented)\n+\n+        for (final Map.Entry<Hash, BonsaiValue<UInt256>> storageUpdate :\n+            storageAccountUpdate.getValue().entrySet()) {\n+          final Hash keyHash = storageUpdate.getKey();\n+          final byte[] writeAddress = Bytes.concatenate(updatedAddress, keyHash).toArrayUnsafe();\n+          final UInt256 updatedStorage = storageUpdate.getValue().getUpdated();\n+          if (updatedStorage == null || updatedStorage.equals(UInt256.ZERO)) {\n+            storageTx.remove(writeAddress);\n+            storageTrie.remove(keyHash);\n+          } else {\n+            final Bytes32 updatedStorageBytes = updatedStorage.toBytes();\n+            storageTx.put(writeAddress, updatedStorageBytes.toArrayUnsafe());\n+            storageTrie.put(keyHash, rlpEncode(updatedStorageBytes));\n+          }\n+        }\n+\n+        final BonsaiAccount accountUpdated = accountValue.getUpdated();\n+        if (accountUpdated != null) {\n+          storageTrie.commit(\n+              (location, key, value) ->\n+                  writeStorageTrieNode(trieBranchTx, updatedAddress, location, key, value));\n+          final Hash newStorageRoot = Hash.wrap(storageTrie.getRootHash());\n+          accountUpdated.setStorageRoot(newStorageRoot);\n+        }\n+        // for manicured tries and composting, trim and compost here\n+      }\n+\n+      // Third update the code.  This has the side effect of ensuring a code hash is calculated.\n+      for (final Map.Entry<Address, BonsaiValue<Bytes>> codeUpdate :\n+          updater.getCodeToUpdate().entrySet()) {\n+        final Bytes updatedCode = codeUpdate.getValue().getUpdated();\n+        if (updatedCode == null || updatedCode.size() == 0) {\n+          codeTx.remove(codeUpdate.getKey().toArrayUnsafe());\n+        } else {\n+          codeTx.put(codeUpdate.getKey().toArrayUnsafe(), updatedCode.toArrayUnsafe());\n+        }\n+      }\n+\n+      // next collect the branches that will be trimmed\n+      final StoredMerklePatriciaTrie<Bytes, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              this::getTrieNode, worldStateRootHash, Function.identity(), Function.identity());\n+\n+      // for manicured tries and composting, collect branches here (not implemented)\n+\n+      // now add the accounts\n+      for (final Map.Entry<Address, BonsaiValue<BonsaiAccount>> accountUpdate :\n+          updater.getAccountsToUpdate().entrySet()) {\n+        final Bytes accountKey = accountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> bonsaiValue = accountUpdate.getValue();\n+        final BonsaiAccount updatedAccount = bonsaiValue.getUpdated();\n+        if (updatedAccount == null) {\n+          final Hash addressHash = Hash.hash(accountKey);\n+          accountTrie.remove(addressHash);\n+          accountTx.remove(accountKey.toArrayUnsafe());\n+        } else {\n+          final Hash addressHash = updatedAccount.getAddressHash();\n+          final Bytes accountValue = updatedAccount.serializeAccount();\n+          accountTx.put(accountKey.toArrayUnsafe(), accountValue.toArrayUnsafe());\n+          accountTrie.put(addressHash, accountValue);\n+        }\n+      }\n+\n+      accountTrie.commit(\n+          (location, hash, value) -> writeTrieNode(trieBranchTx, location, hash, value));\n+      worldStateRootHash = accountTrie.getRootHash();\n+      trieBranchTx.put(WORLD_ROOT_KEY, worldStateRootHash.toArrayUnsafe());\n+\n+      // for manicured tries and composting, trim and compost branches here\n+\n+      if (blockHash != null) {\n+        final TrieLogLayer trieLog = updater.generateTrieLog(blockHash);\n+        trieLog.freeze();\n+        // TODO add to archive here, but only once we get persisted follow distance implemented\n+        // archive.addLayeredWorldState(new BonsaiLayeredWorldState(this, trieLog));\n+\n+        final BytesValueRLPOutput rlpLog = new BytesValueRLPOutput();\n+        trieLog.writeTo(rlpLog);\n+        trieLogTx.put(blockHash.toArrayUnsafe(), rlpLog.encoded().toArrayUnsafe());\n+      }\n+\n+      success = true;\n+    } finally {\n+      if (success) {\n+        accountTx.commit();\n+        codeTx.commit();\n+        storageTx.commit();\n+        trieBranchTx.commit();\n+        trieLogTx.commit();\n+        updater.reset();\n+      } else {\n+        accountTx.rollback();\n+        codeTx.rollback();\n+        storageTx.rollback();\n+        trieBranchTx.rollback();\n+        trieLogTx.rollback();\n+      }\n+    }\n+  }\n+\n+  private static Bytes rlpEncode(final Bytes bytes) {\n+    final BytesValueRLPOutput out = new BytesValueRLPOutput();\n+    out.writeBytes(bytes.trimLeadingZeros());\n+    return out.encoded();\n+  }\n+\n+  @Override\n+  public WorldUpdater updater() {\n+    if (updater == null) {\n+      updater = new BonsaiWorldStateUpdater(this);\n+    }\n+    return updater;\n+  }\n+\n+  @Override\n+  public Hash rootHash() {\n+    return Hash.wrap(worldStateRootHash);\n+  }\n+\n+  @Override\n+  public Stream<StreamableAccount> streamAccounts(final Bytes32 startKeyHash, final int limit) {\n+    throw new RuntimeException(\"NIY\");\n+  }\n+\n+  @Override\n+  public Account get(final Address address) {\n+    return accountStorage\n+        .get(address.toArrayUnsafe())\n+        .map(bytes -> fromRLP(updater, address, Bytes.wrap(bytes), true))\n+        .orElse(null);\n+  }\n+\n+  private Optional<Bytes> getTrieNode(final Bytes location, final Bytes32 nodeHash) {\n+    if (nodeHash.equals(MerklePatriciaTrie.EMPTY_TRIE_NODE_HASH)) {\n+      return Optional.of(MerklePatriciaTrie.EMPTY_TRIE_NODE);\n+    } else {\n+      return trieBranchStorage.get(location.toArrayUnsafe()).map(Bytes::wrap);\n+    }\n+  }\n+\n+  private void writeTrieNode(\n+      final KeyValueStorageTransaction tx,\n+      final Bytes location,\n+      @SuppressWarnings(\"unused\") final Bytes32 nodeHash,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA2OTE2MQ=="}, "originalCommit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d"}, "originalPosition": 297}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MzYyOTEyOnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMjozNjo0MFrOH_PEXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMzo1ODo0MVrOH_SDdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA2OTIxMw==", "bodyText": "Does this byte32 with SuppressWarnings unused is important ? For future use ?", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536069213", "createdAt": "2020-12-04T12:36:40Z", "author": {"login": "matkt"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static org.hyperledger.besu.ethereum.bonsai.BonsaiAccount.fromRLP;\n+\n+import org.hyperledger.besu.ethereum.core.Account;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.MerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorageTransaction;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import javax.annotation.Nonnull;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiPersistedWorldState implements MutableWorldState, BonsaiWorldState {\n+\n+  private static final byte[] WORLD_ROOT_KEY = \"worldRoot\".getBytes(StandardCharsets.UTF_8);\n+\n+  private final KeyValueStorage accountStorage;\n+  private final KeyValueStorage codeStorage;\n+  private final KeyValueStorage storageStorage;\n+  private final KeyValueStorage trieBranchStorage;\n+  private final KeyValueStorage trieLogStorage;\n+\n+  private Bytes32 worldStateRootHash;\n+\n+  private final BonsaiWorldStateArchive archive;\n+  private BonsaiWorldStateUpdater updater;\n+\n+  public BonsaiPersistedWorldState(\n+      final BonsaiWorldStateArchive archive,\n+      final KeyValueStorage accountStorage,\n+      final KeyValueStorage codeStorage,\n+      final KeyValueStorage storageStorage,\n+      final KeyValueStorage trieBranchStorage,\n+      final KeyValueStorage trieLogStorage) {\n+    this.archive = archive;\n+    this.accountStorage = accountStorage;\n+    this.codeStorage = codeStorage;\n+    this.storageStorage = storageStorage;\n+    this.trieBranchStorage = trieBranchStorage;\n+    this.trieLogStorage = trieLogStorage;\n+    worldStateRootHash =\n+        Bytes32.wrap(\n+            trieBranchStorage.get(WORLD_ROOT_KEY).map(Bytes::wrap).orElse(Hash.EMPTY_TRIE_HASH));\n+  }\n+\n+  public BonsaiWorldStateArchive getArchive() {\n+    return archive;\n+  }\n+\n+  @Override\n+  public MutableWorldState copy() {\n+    throw new UnsupportedOperationException(\n+        \"Bonsai Tries does not support direct duplication of the persisted tries.\");\n+  }\n+\n+  @Override\n+  public Bytes getCode(@Nonnull final Address address) {\n+    return codeStorage.get(address.toArrayUnsafe()).map(Bytes::wrap).orElse(Bytes.EMPTY);\n+  }\n+\n+  @Override\n+  public void persist(final Hash blockHash) {\n+    boolean success = false;\n+    final KeyValueStorageTransaction accountTx = accountStorage.startTransaction();\n+    final KeyValueStorageTransaction codeTx = codeStorage.startTransaction();\n+    final KeyValueStorageTransaction storageTx = storageStorage.startTransaction();\n+    final KeyValueStorageTransaction trieBranchTx = trieBranchStorage.startTransaction();\n+    final KeyValueStorageTransaction trieLogTx = trieLogStorage.startTransaction();\n+\n+    try {\n+      // first clear storage\n+      for (final Address address : updater.getStorageToClear()) {\n+        // because we are clearing persisted values we need the account root as persisted\n+        final BonsaiAccount oldAccount =\n+            accountStorage\n+                .get(address.toArrayUnsafe())\n+                .map(\n+                    bytes ->\n+                        fromRLP(BonsaiPersistedWorldState.this, address, Bytes.wrap(bytes), true))\n+                .orElse(null);\n+        if (oldAccount == null) {\n+          // This is when an account is both created and deleted within the scope of the same\n+          // block.  A not-uncommon DeFi bot pattern.\n+          continue;\n+        }\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(address, location, key),\n+                oldAccount.getStorageRoot(),\n+                Function.identity(),\n+                Function.identity());\n+        Map<Bytes32, Bytes> entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+        while (!entriesToDelete.isEmpty()) {\n+          entriesToDelete\n+              .keySet()\n+              .forEach(k -> storageTx.remove(Bytes.concatenate(address, k).toArrayUnsafe()));\n+          if (entriesToDelete.size() == 256) {\n+            entriesToDelete.keySet().forEach(storageTrie::remove);\n+            entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+          } else {\n+            break;\n+          }\n+        }\n+      }\n+\n+      // second update account storage state.  This must be done before updating the accounts so\n+      // that we can get the storage state hash\n+      for (final Map.Entry<Address, Map<Hash, BonsaiValue<UInt256>>> storageAccountUpdate :\n+          updater.getStorageToUpdate().entrySet()) {\n+        final Address updatedAddress = storageAccountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> accountValue =\n+            updater.getAccountsToUpdate().get(updatedAddress);\n+        final BonsaiAccount accountOriginal = accountValue.getOriginal();\n+        final Hash storageRoot =\n+            (accountOriginal == null) ? Hash.EMPTY_TRIE_HASH : accountOriginal.getStorageRoot();\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(updatedAddress, location, key),\n+                storageRoot,\n+                Function.identity(),\n+                Function.identity());\n+\n+        // for manicured tries and composting, collect branches here (not implemented)\n+\n+        for (final Map.Entry<Hash, BonsaiValue<UInt256>> storageUpdate :\n+            storageAccountUpdate.getValue().entrySet()) {\n+          final Hash keyHash = storageUpdate.getKey();\n+          final byte[] writeAddress = Bytes.concatenate(updatedAddress, keyHash).toArrayUnsafe();\n+          final UInt256 updatedStorage = storageUpdate.getValue().getUpdated();\n+          if (updatedStorage == null || updatedStorage.equals(UInt256.ZERO)) {\n+            storageTx.remove(writeAddress);\n+            storageTrie.remove(keyHash);\n+          } else {\n+            final Bytes32 updatedStorageBytes = updatedStorage.toBytes();\n+            storageTx.put(writeAddress, updatedStorageBytes.toArrayUnsafe());\n+            storageTrie.put(keyHash, rlpEncode(updatedStorageBytes));\n+          }\n+        }\n+\n+        final BonsaiAccount accountUpdated = accountValue.getUpdated();\n+        if (accountUpdated != null) {\n+          storageTrie.commit(\n+              (location, key, value) ->\n+                  writeStorageTrieNode(trieBranchTx, updatedAddress, location, key, value));\n+          final Hash newStorageRoot = Hash.wrap(storageTrie.getRootHash());\n+          accountUpdated.setStorageRoot(newStorageRoot);\n+        }\n+        // for manicured tries and composting, trim and compost here\n+      }\n+\n+      // Third update the code.  This has the side effect of ensuring a code hash is calculated.\n+      for (final Map.Entry<Address, BonsaiValue<Bytes>> codeUpdate :\n+          updater.getCodeToUpdate().entrySet()) {\n+        final Bytes updatedCode = codeUpdate.getValue().getUpdated();\n+        if (updatedCode == null || updatedCode.size() == 0) {\n+          codeTx.remove(codeUpdate.getKey().toArrayUnsafe());\n+        } else {\n+          codeTx.put(codeUpdate.getKey().toArrayUnsafe(), updatedCode.toArrayUnsafe());\n+        }\n+      }\n+\n+      // next collect the branches that will be trimmed\n+      final StoredMerklePatriciaTrie<Bytes, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              this::getTrieNode, worldStateRootHash, Function.identity(), Function.identity());\n+\n+      // for manicured tries and composting, collect branches here (not implemented)\n+\n+      // now add the accounts\n+      for (final Map.Entry<Address, BonsaiValue<BonsaiAccount>> accountUpdate :\n+          updater.getAccountsToUpdate().entrySet()) {\n+        final Bytes accountKey = accountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> bonsaiValue = accountUpdate.getValue();\n+        final BonsaiAccount updatedAccount = bonsaiValue.getUpdated();\n+        if (updatedAccount == null) {\n+          final Hash addressHash = Hash.hash(accountKey);\n+          accountTrie.remove(addressHash);\n+          accountTx.remove(accountKey.toArrayUnsafe());\n+        } else {\n+          final Hash addressHash = updatedAccount.getAddressHash();\n+          final Bytes accountValue = updatedAccount.serializeAccount();\n+          accountTx.put(accountKey.toArrayUnsafe(), accountValue.toArrayUnsafe());\n+          accountTrie.put(addressHash, accountValue);\n+        }\n+      }\n+\n+      accountTrie.commit(\n+          (location, hash, value) -> writeTrieNode(trieBranchTx, location, hash, value));\n+      worldStateRootHash = accountTrie.getRootHash();\n+      trieBranchTx.put(WORLD_ROOT_KEY, worldStateRootHash.toArrayUnsafe());\n+\n+      // for manicured tries and composting, trim and compost branches here\n+\n+      if (blockHash != null) {\n+        final TrieLogLayer trieLog = updater.generateTrieLog(blockHash);\n+        trieLog.freeze();\n+        // TODO add to archive here, but only once we get persisted follow distance implemented\n+        // archive.addLayeredWorldState(new BonsaiLayeredWorldState(this, trieLog));\n+\n+        final BytesValueRLPOutput rlpLog = new BytesValueRLPOutput();\n+        trieLog.writeTo(rlpLog);\n+        trieLogTx.put(blockHash.toArrayUnsafe(), rlpLog.encoded().toArrayUnsafe());\n+      }\n+\n+      success = true;\n+    } finally {\n+      if (success) {\n+        accountTx.commit();\n+        codeTx.commit();\n+        storageTx.commit();\n+        trieBranchTx.commit();\n+        trieLogTx.commit();\n+        updater.reset();\n+      } else {\n+        accountTx.rollback();\n+        codeTx.rollback();\n+        storageTx.rollback();\n+        trieBranchTx.rollback();\n+        trieLogTx.rollback();\n+      }\n+    }\n+  }\n+\n+  private static Bytes rlpEncode(final Bytes bytes) {\n+    final BytesValueRLPOutput out = new BytesValueRLPOutput();\n+    out.writeBytes(bytes.trimLeadingZeros());\n+    return out.encoded();\n+  }\n+\n+  @Override\n+  public WorldUpdater updater() {\n+    if (updater == null) {\n+      updater = new BonsaiWorldStateUpdater(this);\n+    }\n+    return updater;\n+  }\n+\n+  @Override\n+  public Hash rootHash() {\n+    return Hash.wrap(worldStateRootHash);\n+  }\n+\n+  @Override\n+  public Stream<StreamableAccount> streamAccounts(final Bytes32 startKeyHash, final int limit) {\n+    throw new RuntimeException(\"NIY\");\n+  }\n+\n+  @Override\n+  public Account get(final Address address) {\n+    return accountStorage\n+        .get(address.toArrayUnsafe())\n+        .map(bytes -> fromRLP(updater, address, Bytes.wrap(bytes), true))\n+        .orElse(null);\n+  }\n+\n+  private Optional<Bytes> getTrieNode(final Bytes location, final Bytes32 nodeHash) {\n+    if (nodeHash.equals(MerklePatriciaTrie.EMPTY_TRIE_NODE_HASH)) {\n+      return Optional.of(MerklePatriciaTrie.EMPTY_TRIE_NODE);\n+    } else {\n+      return trieBranchStorage.get(location.toArrayUnsafe()).map(Bytes::wrap);\n+    }\n+  }\n+\n+  private void writeTrieNode(\n+      final KeyValueStorageTransaction tx,\n+      final Bytes location,\n+      @SuppressWarnings(\"unused\") final Bytes32 nodeHash,\n+      final Bytes value) {\n+    tx.put(location.toArrayUnsafe(), value.toArrayUnsafe());\n+  }\n+\n+  private Optional<Bytes> getStorageTrieNode(\n+      final Address address, final Bytes location, final Bytes32 nodeHash) {\n+    if (nodeHash.equals(MerklePatriciaTrie.EMPTY_TRIE_NODE_HASH)) {\n+      return Optional.of(MerklePatriciaTrie.EMPTY_TRIE_NODE);\n+    } else {\n+      return trieBranchStorage\n+          .get(Bytes.concatenate(address, location).toArrayUnsafe())\n+          .map(Bytes::wrap);\n+    }\n+  }\n+\n+  private void writeStorageTrieNode(\n+      final KeyValueStorageTransaction tx,\n+      final Address address,\n+      final Bytes location,\n+      @SuppressWarnings(\"unused\") final Bytes32 key,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExODEzNA==", "bodyText": "Same, it was originally a direct lambda but when the KVStorTransaction got added via lambda wrapping it became unneeded.", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536118134", "createdAt": "2020-12-04T13:58:41Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static org.hyperledger.besu.ethereum.bonsai.BonsaiAccount.fromRLP;\n+\n+import org.hyperledger.besu.ethereum.core.Account;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.MerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorageTransaction;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import javax.annotation.Nonnull;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiPersistedWorldState implements MutableWorldState, BonsaiWorldState {\n+\n+  private static final byte[] WORLD_ROOT_KEY = \"worldRoot\".getBytes(StandardCharsets.UTF_8);\n+\n+  private final KeyValueStorage accountStorage;\n+  private final KeyValueStorage codeStorage;\n+  private final KeyValueStorage storageStorage;\n+  private final KeyValueStorage trieBranchStorage;\n+  private final KeyValueStorage trieLogStorage;\n+\n+  private Bytes32 worldStateRootHash;\n+\n+  private final BonsaiWorldStateArchive archive;\n+  private BonsaiWorldStateUpdater updater;\n+\n+  public BonsaiPersistedWorldState(\n+      final BonsaiWorldStateArchive archive,\n+      final KeyValueStorage accountStorage,\n+      final KeyValueStorage codeStorage,\n+      final KeyValueStorage storageStorage,\n+      final KeyValueStorage trieBranchStorage,\n+      final KeyValueStorage trieLogStorage) {\n+    this.archive = archive;\n+    this.accountStorage = accountStorage;\n+    this.codeStorage = codeStorage;\n+    this.storageStorage = storageStorage;\n+    this.trieBranchStorage = trieBranchStorage;\n+    this.trieLogStorage = trieLogStorage;\n+    worldStateRootHash =\n+        Bytes32.wrap(\n+            trieBranchStorage.get(WORLD_ROOT_KEY).map(Bytes::wrap).orElse(Hash.EMPTY_TRIE_HASH));\n+  }\n+\n+  public BonsaiWorldStateArchive getArchive() {\n+    return archive;\n+  }\n+\n+  @Override\n+  public MutableWorldState copy() {\n+    throw new UnsupportedOperationException(\n+        \"Bonsai Tries does not support direct duplication of the persisted tries.\");\n+  }\n+\n+  @Override\n+  public Bytes getCode(@Nonnull final Address address) {\n+    return codeStorage.get(address.toArrayUnsafe()).map(Bytes::wrap).orElse(Bytes.EMPTY);\n+  }\n+\n+  @Override\n+  public void persist(final Hash blockHash) {\n+    boolean success = false;\n+    final KeyValueStorageTransaction accountTx = accountStorage.startTransaction();\n+    final KeyValueStorageTransaction codeTx = codeStorage.startTransaction();\n+    final KeyValueStorageTransaction storageTx = storageStorage.startTransaction();\n+    final KeyValueStorageTransaction trieBranchTx = trieBranchStorage.startTransaction();\n+    final KeyValueStorageTransaction trieLogTx = trieLogStorage.startTransaction();\n+\n+    try {\n+      // first clear storage\n+      for (final Address address : updater.getStorageToClear()) {\n+        // because we are clearing persisted values we need the account root as persisted\n+        final BonsaiAccount oldAccount =\n+            accountStorage\n+                .get(address.toArrayUnsafe())\n+                .map(\n+                    bytes ->\n+                        fromRLP(BonsaiPersistedWorldState.this, address, Bytes.wrap(bytes), true))\n+                .orElse(null);\n+        if (oldAccount == null) {\n+          // This is when an account is both created and deleted within the scope of the same\n+          // block.  A not-uncommon DeFi bot pattern.\n+          continue;\n+        }\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(address, location, key),\n+                oldAccount.getStorageRoot(),\n+                Function.identity(),\n+                Function.identity());\n+        Map<Bytes32, Bytes> entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+        while (!entriesToDelete.isEmpty()) {\n+          entriesToDelete\n+              .keySet()\n+              .forEach(k -> storageTx.remove(Bytes.concatenate(address, k).toArrayUnsafe()));\n+          if (entriesToDelete.size() == 256) {\n+            entriesToDelete.keySet().forEach(storageTrie::remove);\n+            entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+          } else {\n+            break;\n+          }\n+        }\n+      }\n+\n+      // second update account storage state.  This must be done before updating the accounts so\n+      // that we can get the storage state hash\n+      for (final Map.Entry<Address, Map<Hash, BonsaiValue<UInt256>>> storageAccountUpdate :\n+          updater.getStorageToUpdate().entrySet()) {\n+        final Address updatedAddress = storageAccountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> accountValue =\n+            updater.getAccountsToUpdate().get(updatedAddress);\n+        final BonsaiAccount accountOriginal = accountValue.getOriginal();\n+        final Hash storageRoot =\n+            (accountOriginal == null) ? Hash.EMPTY_TRIE_HASH : accountOriginal.getStorageRoot();\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(updatedAddress, location, key),\n+                storageRoot,\n+                Function.identity(),\n+                Function.identity());\n+\n+        // for manicured tries and composting, collect branches here (not implemented)\n+\n+        for (final Map.Entry<Hash, BonsaiValue<UInt256>> storageUpdate :\n+            storageAccountUpdate.getValue().entrySet()) {\n+          final Hash keyHash = storageUpdate.getKey();\n+          final byte[] writeAddress = Bytes.concatenate(updatedAddress, keyHash).toArrayUnsafe();\n+          final UInt256 updatedStorage = storageUpdate.getValue().getUpdated();\n+          if (updatedStorage == null || updatedStorage.equals(UInt256.ZERO)) {\n+            storageTx.remove(writeAddress);\n+            storageTrie.remove(keyHash);\n+          } else {\n+            final Bytes32 updatedStorageBytes = updatedStorage.toBytes();\n+            storageTx.put(writeAddress, updatedStorageBytes.toArrayUnsafe());\n+            storageTrie.put(keyHash, rlpEncode(updatedStorageBytes));\n+          }\n+        }\n+\n+        final BonsaiAccount accountUpdated = accountValue.getUpdated();\n+        if (accountUpdated != null) {\n+          storageTrie.commit(\n+              (location, key, value) ->\n+                  writeStorageTrieNode(trieBranchTx, updatedAddress, location, key, value));\n+          final Hash newStorageRoot = Hash.wrap(storageTrie.getRootHash());\n+          accountUpdated.setStorageRoot(newStorageRoot);\n+        }\n+        // for manicured tries and composting, trim and compost here\n+      }\n+\n+      // Third update the code.  This has the side effect of ensuring a code hash is calculated.\n+      for (final Map.Entry<Address, BonsaiValue<Bytes>> codeUpdate :\n+          updater.getCodeToUpdate().entrySet()) {\n+        final Bytes updatedCode = codeUpdate.getValue().getUpdated();\n+        if (updatedCode == null || updatedCode.size() == 0) {\n+          codeTx.remove(codeUpdate.getKey().toArrayUnsafe());\n+        } else {\n+          codeTx.put(codeUpdate.getKey().toArrayUnsafe(), updatedCode.toArrayUnsafe());\n+        }\n+      }\n+\n+      // next collect the branches that will be trimmed\n+      final StoredMerklePatriciaTrie<Bytes, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              this::getTrieNode, worldStateRootHash, Function.identity(), Function.identity());\n+\n+      // for manicured tries and composting, collect branches here (not implemented)\n+\n+      // now add the accounts\n+      for (final Map.Entry<Address, BonsaiValue<BonsaiAccount>> accountUpdate :\n+          updater.getAccountsToUpdate().entrySet()) {\n+        final Bytes accountKey = accountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> bonsaiValue = accountUpdate.getValue();\n+        final BonsaiAccount updatedAccount = bonsaiValue.getUpdated();\n+        if (updatedAccount == null) {\n+          final Hash addressHash = Hash.hash(accountKey);\n+          accountTrie.remove(addressHash);\n+          accountTx.remove(accountKey.toArrayUnsafe());\n+        } else {\n+          final Hash addressHash = updatedAccount.getAddressHash();\n+          final Bytes accountValue = updatedAccount.serializeAccount();\n+          accountTx.put(accountKey.toArrayUnsafe(), accountValue.toArrayUnsafe());\n+          accountTrie.put(addressHash, accountValue);\n+        }\n+      }\n+\n+      accountTrie.commit(\n+          (location, hash, value) -> writeTrieNode(trieBranchTx, location, hash, value));\n+      worldStateRootHash = accountTrie.getRootHash();\n+      trieBranchTx.put(WORLD_ROOT_KEY, worldStateRootHash.toArrayUnsafe());\n+\n+      // for manicured tries and composting, trim and compost branches here\n+\n+      if (blockHash != null) {\n+        final TrieLogLayer trieLog = updater.generateTrieLog(blockHash);\n+        trieLog.freeze();\n+        // TODO add to archive here, but only once we get persisted follow distance implemented\n+        // archive.addLayeredWorldState(new BonsaiLayeredWorldState(this, trieLog));\n+\n+        final BytesValueRLPOutput rlpLog = new BytesValueRLPOutput();\n+        trieLog.writeTo(rlpLog);\n+        trieLogTx.put(blockHash.toArrayUnsafe(), rlpLog.encoded().toArrayUnsafe());\n+      }\n+\n+      success = true;\n+    } finally {\n+      if (success) {\n+        accountTx.commit();\n+        codeTx.commit();\n+        storageTx.commit();\n+        trieBranchTx.commit();\n+        trieLogTx.commit();\n+        updater.reset();\n+      } else {\n+        accountTx.rollback();\n+        codeTx.rollback();\n+        storageTx.rollback();\n+        trieBranchTx.rollback();\n+        trieLogTx.rollback();\n+      }\n+    }\n+  }\n+\n+  private static Bytes rlpEncode(final Bytes bytes) {\n+    final BytesValueRLPOutput out = new BytesValueRLPOutput();\n+    out.writeBytes(bytes.trimLeadingZeros());\n+    return out.encoded();\n+  }\n+\n+  @Override\n+  public WorldUpdater updater() {\n+    if (updater == null) {\n+      updater = new BonsaiWorldStateUpdater(this);\n+    }\n+    return updater;\n+  }\n+\n+  @Override\n+  public Hash rootHash() {\n+    return Hash.wrap(worldStateRootHash);\n+  }\n+\n+  @Override\n+  public Stream<StreamableAccount> streamAccounts(final Bytes32 startKeyHash, final int limit) {\n+    throw new RuntimeException(\"NIY\");\n+  }\n+\n+  @Override\n+  public Account get(final Address address) {\n+    return accountStorage\n+        .get(address.toArrayUnsafe())\n+        .map(bytes -> fromRLP(updater, address, Bytes.wrap(bytes), true))\n+        .orElse(null);\n+  }\n+\n+  private Optional<Bytes> getTrieNode(final Bytes location, final Bytes32 nodeHash) {\n+    if (nodeHash.equals(MerklePatriciaTrie.EMPTY_TRIE_NODE_HASH)) {\n+      return Optional.of(MerklePatriciaTrie.EMPTY_TRIE_NODE);\n+    } else {\n+      return trieBranchStorage.get(location.toArrayUnsafe()).map(Bytes::wrap);\n+    }\n+  }\n+\n+  private void writeTrieNode(\n+      final KeyValueStorageTransaction tx,\n+      final Bytes location,\n+      @SuppressWarnings(\"unused\") final Bytes32 nodeHash,\n+      final Bytes value) {\n+    tx.put(location.toArrayUnsafe(), value.toArrayUnsafe());\n+  }\n+\n+  private Optional<Bytes> getStorageTrieNode(\n+      final Address address, final Bytes location, final Bytes32 nodeHash) {\n+    if (nodeHash.equals(MerklePatriciaTrie.EMPTY_TRIE_NODE_HASH)) {\n+      return Optional.of(MerklePatriciaTrie.EMPTY_TRIE_NODE);\n+    } else {\n+      return trieBranchStorage\n+          .get(Bytes.concatenate(address, location).toArrayUnsafe())\n+          .map(Bytes::wrap);\n+    }\n+  }\n+\n+  private void writeStorageTrieNode(\n+      final KeyValueStorageTransaction tx,\n+      final Address address,\n+      final Bytes location,\n+      @SuppressWarnings(\"unused\") final Bytes32 key,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA2OTIxMw=="}, "originalCommit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d"}, "originalPosition": 317}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2Mzc0MjMwOnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiWorldStateArchive.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMzowNTo0MFrOH_QEeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNDowMTowMlrOH_SJkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA4NTYyNA==", "bodyText": "Why not doing get(EMPTY_ROOT_HASH).get() like here \n  \n    \n      besu/ethereum/core/src/main/java/org/hyperledger/besu/ethereum/worldstate/DefaultWorldStateArchive.java\n    \n    \n         Line 66\n      in\n      7e52d4d\n    \n    \n    \n    \n\n        \n          \n           return get(EMPTY_ROOT_HASH).get();", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536085624", "createdAt": "2020-12-04T13:05:40Z", "author": {"login": "matkt"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiWorldStateArchive.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldState;\n+import org.hyperledger.besu.ethereum.proof.WorldStateProof;\n+import org.hyperledger.besu.ethereum.storage.StorageProvider;\n+import org.hyperledger.besu.ethereum.storage.keyvalue.KeyValueSegmentIdentifier;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiWorldStateArchive implements WorldStateArchive {\n+\n+  private final BonsaiPersistedWorldState persistedState;\n+  private final Map<Bytes32, BonsaiLayeredWorldState> layeredWorldStates;\n+\n+  public BonsaiWorldStateArchive(final StorageProvider provider) {\n+    persistedState =\n+        new BonsaiPersistedWorldState(\n+            this,\n+            provider.getStorageBySegmentIdentifier(KeyValueSegmentIdentifier.ACCOUNT_INFO_STATE),\n+            provider.getStorageBySegmentIdentifier(KeyValueSegmentIdentifier.CODE_STORAGE),\n+            provider.getStorageBySegmentIdentifier(\n+                KeyValueSegmentIdentifier.ACCOUNT_STORAGE_STORAGE),\n+            provider.getStorageBySegmentIdentifier(KeyValueSegmentIdentifier.TRIE_BRANCH_STORAGE),\n+            provider.getStorageBySegmentIdentifier(KeyValueSegmentIdentifier.TRIE_LOG_STORAGE));\n+    layeredWorldStates = new HashMap<>();\n+  }\n+\n+  @Override\n+  public Optional<WorldState> get(final Hash rootHash) {\n+    if (layeredWorldStates.containsKey(rootHash)) {\n+      return Optional.of(layeredWorldStates.get(rootHash));\n+    } else if (rootHash.equals(persistedState.rootHash())) {\n+      return Optional.of(persistedState);\n+    } else {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  public void addLayeredWorldState(final BonsaiLayeredWorldState worldState) {\n+    layeredWorldStates.put(worldState.rootHash(), worldState);\n+  }\n+\n+  @Override\n+  public boolean isWorldStateAvailable(final Hash rootHash) {\n+    return layeredWorldStates.containsKey(rootHash)\n+        || persistedState.rootHash().equals(rootHash) /* || check disk storage */;\n+  }\n+\n+  @Override\n+  public Optional<MutableWorldState> getMutable(final Hash rootHash) {\n+    if (rootHash.equals(persistedState.rootHash())) {\n+      return Optional.of(persistedState);\n+    } else {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  @Override\n+  public WorldState get() {\n+    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExOTY5Ng==", "bodyText": "org.hyperledger.besu.ethereum.worldstate.WorldStateArchive#get() is a dead method and should be removed.  No one calls it.  I'll remove it from the parent and the Forest world state too.", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536119696", "createdAt": "2020-12-04T14:01:02Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiWorldStateArchive.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldState;\n+import org.hyperledger.besu.ethereum.proof.WorldStateProof;\n+import org.hyperledger.besu.ethereum.storage.StorageProvider;\n+import org.hyperledger.besu.ethereum.storage.keyvalue.KeyValueSegmentIdentifier;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiWorldStateArchive implements WorldStateArchive {\n+\n+  private final BonsaiPersistedWorldState persistedState;\n+  private final Map<Bytes32, BonsaiLayeredWorldState> layeredWorldStates;\n+\n+  public BonsaiWorldStateArchive(final StorageProvider provider) {\n+    persistedState =\n+        new BonsaiPersistedWorldState(\n+            this,\n+            provider.getStorageBySegmentIdentifier(KeyValueSegmentIdentifier.ACCOUNT_INFO_STATE),\n+            provider.getStorageBySegmentIdentifier(KeyValueSegmentIdentifier.CODE_STORAGE),\n+            provider.getStorageBySegmentIdentifier(\n+                KeyValueSegmentIdentifier.ACCOUNT_STORAGE_STORAGE),\n+            provider.getStorageBySegmentIdentifier(KeyValueSegmentIdentifier.TRIE_BRANCH_STORAGE),\n+            provider.getStorageBySegmentIdentifier(KeyValueSegmentIdentifier.TRIE_LOG_STORAGE));\n+    layeredWorldStates = new HashMap<>();\n+  }\n+\n+  @Override\n+  public Optional<WorldState> get(final Hash rootHash) {\n+    if (layeredWorldStates.containsKey(rootHash)) {\n+      return Optional.of(layeredWorldStates.get(rootHash));\n+    } else if (rootHash.equals(persistedState.rootHash())) {\n+      return Optional.of(persistedState);\n+    } else {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  public void addLayeredWorldState(final BonsaiLayeredWorldState worldState) {\n+    layeredWorldStates.put(worldState.rootHash(), worldState);\n+  }\n+\n+  @Override\n+  public boolean isWorldStateAvailable(final Hash rootHash) {\n+    return layeredWorldStates.containsKey(rootHash)\n+        || persistedState.rootHash().equals(rootHash) /* || check disk storage */;\n+  }\n+\n+  @Override\n+  public Optional<MutableWorldState> getMutable(final Hash rootHash) {\n+    if (rootHash.equals(persistedState.rootHash())) {\n+      return Optional.of(persistedState);\n+    } else {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  @Override\n+  public WorldState get() {\n+    return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA4NTYyNA=="}, "originalCommit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MzgzODk1OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMzoyOTowNlrOH_Q6-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNDoxODo1N1rOH_S3bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5OTU3Ng==", "bodyText": "I wonder if an optional wouldn't be an idea to avoid having to call this method with null ?", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536099576", "createdAt": "2020-12-04T13:29:06Z", "author": {"login": "matkt"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -191,7 +191,7 @@ public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n     if (messageFrame.isPersistingPrivateState()) {\n \n       privateWorldStateUpdater.commit();\n-      disposablePrivateState.persist();\n+      disposablePrivateState.persist(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEyMjU0NA==", "bodyText": "The only argument is style really.  The forest ignores it, in bonsai mode Tthe block that switches on whether or not it is null is too large for a good looking lambda.  The bulk of the null calls are in test code.  Another option is two methods, one with no args.  But in the places it's called directly with null it's a good reminder in the code \"this is not a regular commit\".", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536122544", "createdAt": "2020-12-04T14:05:24Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -191,7 +191,7 @@ public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n     if (messageFrame.isPersistingPrivateState()) {\n \n       privateWorldStateUpdater.commit();\n-      disposablePrivateState.persist();\n+      disposablePrivateState.persist(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5OTU3Ng=="}, "originalCommit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEzMTQzNg==", "bodyText": "it's called directly with null it's a good reminder in the code \"this is not a regular commit\".\n\nThat suits me . We can leave it if it provides information and if the majority of calls like this are in the test", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536131436", "createdAt": "2020-12-04T14:18:57Z", "author": {"login": "matkt"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -191,7 +191,7 @@ public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n     if (messageFrame.isPersistingPrivateState()) {\n \n       privateWorldStateUpdater.commit();\n-      disposablePrivateState.persist();\n+      disposablePrivateState.persist(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5OTU3Ng=="}, "originalCommit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2Mzg2NDU3OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMzozNToxOFrOH_RJfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNDowNzoxMFrOH_SZRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEwMzI5NQ==", "bodyText": "NIY ? Not implemented yet ?", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536103295", "createdAt": "2020-12-04T13:35:18Z", "author": {"login": "matkt"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static org.hyperledger.besu.ethereum.bonsai.BonsaiAccount.fromRLP;\n+\n+import org.hyperledger.besu.ethereum.core.Account;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.MerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorageTransaction;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import javax.annotation.Nonnull;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiPersistedWorldState implements MutableWorldState, BonsaiWorldState {\n+\n+  private static final byte[] WORLD_ROOT_KEY = \"worldRoot\".getBytes(StandardCharsets.UTF_8);\n+\n+  private final KeyValueStorage accountStorage;\n+  private final KeyValueStorage codeStorage;\n+  private final KeyValueStorage storageStorage;\n+  private final KeyValueStorage trieBranchStorage;\n+  private final KeyValueStorage trieLogStorage;\n+\n+  private Bytes32 worldStateRootHash;\n+\n+  private final BonsaiWorldStateArchive archive;\n+  private BonsaiWorldStateUpdater updater;\n+\n+  public BonsaiPersistedWorldState(\n+      final BonsaiWorldStateArchive archive,\n+      final KeyValueStorage accountStorage,\n+      final KeyValueStorage codeStorage,\n+      final KeyValueStorage storageStorage,\n+      final KeyValueStorage trieBranchStorage,\n+      final KeyValueStorage trieLogStorage) {\n+    this.archive = archive;\n+    this.accountStorage = accountStorage;\n+    this.codeStorage = codeStorage;\n+    this.storageStorage = storageStorage;\n+    this.trieBranchStorage = trieBranchStorage;\n+    this.trieLogStorage = trieLogStorage;\n+    worldStateRootHash =\n+        Bytes32.wrap(\n+            trieBranchStorage.get(WORLD_ROOT_KEY).map(Bytes::wrap).orElse(Hash.EMPTY_TRIE_HASH));\n+  }\n+\n+  public BonsaiWorldStateArchive getArchive() {\n+    return archive;\n+  }\n+\n+  @Override\n+  public MutableWorldState copy() {\n+    throw new UnsupportedOperationException(\n+        \"Bonsai Tries does not support direct duplication of the persisted tries.\");\n+  }\n+\n+  @Override\n+  public Bytes getCode(@Nonnull final Address address) {\n+    return codeStorage.get(address.toArrayUnsafe()).map(Bytes::wrap).orElse(Bytes.EMPTY);\n+  }\n+\n+  @Override\n+  public void persist(final Hash blockHash) {\n+    boolean success = false;\n+    final KeyValueStorageTransaction accountTx = accountStorage.startTransaction();\n+    final KeyValueStorageTransaction codeTx = codeStorage.startTransaction();\n+    final KeyValueStorageTransaction storageTx = storageStorage.startTransaction();\n+    final KeyValueStorageTransaction trieBranchTx = trieBranchStorage.startTransaction();\n+    final KeyValueStorageTransaction trieLogTx = trieLogStorage.startTransaction();\n+\n+    try {\n+      // first clear storage\n+      for (final Address address : updater.getStorageToClear()) {\n+        // because we are clearing persisted values we need the account root as persisted\n+        final BonsaiAccount oldAccount =\n+            accountStorage\n+                .get(address.toArrayUnsafe())\n+                .map(\n+                    bytes ->\n+                        fromRLP(BonsaiPersistedWorldState.this, address, Bytes.wrap(bytes), true))\n+                .orElse(null);\n+        if (oldAccount == null) {\n+          // This is when an account is both created and deleted within the scope of the same\n+          // block.  A not-uncommon DeFi bot pattern.\n+          continue;\n+        }\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(address, location, key),\n+                oldAccount.getStorageRoot(),\n+                Function.identity(),\n+                Function.identity());\n+        Map<Bytes32, Bytes> entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+        while (!entriesToDelete.isEmpty()) {\n+          entriesToDelete\n+              .keySet()\n+              .forEach(k -> storageTx.remove(Bytes.concatenate(address, k).toArrayUnsafe()));\n+          if (entriesToDelete.size() == 256) {\n+            entriesToDelete.keySet().forEach(storageTrie::remove);\n+            entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+          } else {\n+            break;\n+          }\n+        }\n+      }\n+\n+      // second update account storage state.  This must be done before updating the accounts so\n+      // that we can get the storage state hash\n+      for (final Map.Entry<Address, Map<Hash, BonsaiValue<UInt256>>> storageAccountUpdate :\n+          updater.getStorageToUpdate().entrySet()) {\n+        final Address updatedAddress = storageAccountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> accountValue =\n+            updater.getAccountsToUpdate().get(updatedAddress);\n+        final BonsaiAccount accountOriginal = accountValue.getOriginal();\n+        final Hash storageRoot =\n+            (accountOriginal == null) ? Hash.EMPTY_TRIE_HASH : accountOriginal.getStorageRoot();\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(updatedAddress, location, key),\n+                storageRoot,\n+                Function.identity(),\n+                Function.identity());\n+\n+        // for manicured tries and composting, collect branches here (not implemented)\n+\n+        for (final Map.Entry<Hash, BonsaiValue<UInt256>> storageUpdate :\n+            storageAccountUpdate.getValue().entrySet()) {\n+          final Hash keyHash = storageUpdate.getKey();\n+          final byte[] writeAddress = Bytes.concatenate(updatedAddress, keyHash).toArrayUnsafe();\n+          final UInt256 updatedStorage = storageUpdate.getValue().getUpdated();\n+          if (updatedStorage == null || updatedStorage.equals(UInt256.ZERO)) {\n+            storageTx.remove(writeAddress);\n+            storageTrie.remove(keyHash);\n+          } else {\n+            final Bytes32 updatedStorageBytes = updatedStorage.toBytes();\n+            storageTx.put(writeAddress, updatedStorageBytes.toArrayUnsafe());\n+            storageTrie.put(keyHash, rlpEncode(updatedStorageBytes));\n+          }\n+        }\n+\n+        final BonsaiAccount accountUpdated = accountValue.getUpdated();\n+        if (accountUpdated != null) {\n+          storageTrie.commit(\n+              (location, key, value) ->\n+                  writeStorageTrieNode(trieBranchTx, updatedAddress, location, key, value));\n+          final Hash newStorageRoot = Hash.wrap(storageTrie.getRootHash());\n+          accountUpdated.setStorageRoot(newStorageRoot);\n+        }\n+        // for manicured tries and composting, trim and compost here\n+      }\n+\n+      // Third update the code.  This has the side effect of ensuring a code hash is calculated.\n+      for (final Map.Entry<Address, BonsaiValue<Bytes>> codeUpdate :\n+          updater.getCodeToUpdate().entrySet()) {\n+        final Bytes updatedCode = codeUpdate.getValue().getUpdated();\n+        if (updatedCode == null || updatedCode.size() == 0) {\n+          codeTx.remove(codeUpdate.getKey().toArrayUnsafe());\n+        } else {\n+          codeTx.put(codeUpdate.getKey().toArrayUnsafe(), updatedCode.toArrayUnsafe());\n+        }\n+      }\n+\n+      // next collect the branches that will be trimmed\n+      final StoredMerklePatriciaTrie<Bytes, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              this::getTrieNode, worldStateRootHash, Function.identity(), Function.identity());\n+\n+      // for manicured tries and composting, collect branches here (not implemented)\n+\n+      // now add the accounts\n+      for (final Map.Entry<Address, BonsaiValue<BonsaiAccount>> accountUpdate :\n+          updater.getAccountsToUpdate().entrySet()) {\n+        final Bytes accountKey = accountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> bonsaiValue = accountUpdate.getValue();\n+        final BonsaiAccount updatedAccount = bonsaiValue.getUpdated();\n+        if (updatedAccount == null) {\n+          final Hash addressHash = Hash.hash(accountKey);\n+          accountTrie.remove(addressHash);\n+          accountTx.remove(accountKey.toArrayUnsafe());\n+        } else {\n+          final Hash addressHash = updatedAccount.getAddressHash();\n+          final Bytes accountValue = updatedAccount.serializeAccount();\n+          accountTx.put(accountKey.toArrayUnsafe(), accountValue.toArrayUnsafe());\n+          accountTrie.put(addressHash, accountValue);\n+        }\n+      }\n+\n+      accountTrie.commit(\n+          (location, hash, value) -> writeTrieNode(trieBranchTx, location, hash, value));\n+      worldStateRootHash = accountTrie.getRootHash();\n+      trieBranchTx.put(WORLD_ROOT_KEY, worldStateRootHash.toArrayUnsafe());\n+\n+      // for manicured tries and composting, trim and compost branches here\n+\n+      if (blockHash != null) {\n+        final TrieLogLayer trieLog = updater.generateTrieLog(blockHash);\n+        trieLog.freeze();\n+        // TODO add to archive here, but only once we get persisted follow distance implemented\n+        // archive.addLayeredWorldState(new BonsaiLayeredWorldState(this, trieLog));\n+\n+        final BytesValueRLPOutput rlpLog = new BytesValueRLPOutput();\n+        trieLog.writeTo(rlpLog);\n+        trieLogTx.put(blockHash.toArrayUnsafe(), rlpLog.encoded().toArrayUnsafe());\n+      }\n+\n+      success = true;\n+    } finally {\n+      if (success) {\n+        accountTx.commit();\n+        codeTx.commit();\n+        storageTx.commit();\n+        trieBranchTx.commit();\n+        trieLogTx.commit();\n+        updater.reset();\n+      } else {\n+        accountTx.rollback();\n+        codeTx.rollback();\n+        storageTx.rollback();\n+        trieBranchTx.rollback();\n+        trieLogTx.rollback();\n+      }\n+    }\n+  }\n+\n+  private static Bytes rlpEncode(final Bytes bytes) {\n+    final BytesValueRLPOutput out = new BytesValueRLPOutput();\n+    out.writeBytes(bytes.trimLeadingZeros());\n+    return out.encoded();\n+  }\n+\n+  @Override\n+  public WorldUpdater updater() {\n+    if (updater == null) {\n+      updater = new BonsaiWorldStateUpdater(this);\n+    }\n+    return updater;\n+  }\n+\n+  @Override\n+  public Hash rootHash() {\n+    return Hash.wrap(worldStateRootHash);\n+  }\n+\n+  @Override\n+  public Stream<StreamableAccount> streamAccounts(final Bytes32 startKeyHash, final int limit) {\n+    throw new RuntimeException(\"NIY\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEyMjc2OA==", "bodyText": "Not Implemented Yet.  Yes.  I'll put a more verbose description.", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536122768", "createdAt": "2020-12-04T14:05:45Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static org.hyperledger.besu.ethereum.bonsai.BonsaiAccount.fromRLP;\n+\n+import org.hyperledger.besu.ethereum.core.Account;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.MerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorageTransaction;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import javax.annotation.Nonnull;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiPersistedWorldState implements MutableWorldState, BonsaiWorldState {\n+\n+  private static final byte[] WORLD_ROOT_KEY = \"worldRoot\".getBytes(StandardCharsets.UTF_8);\n+\n+  private final KeyValueStorage accountStorage;\n+  private final KeyValueStorage codeStorage;\n+  private final KeyValueStorage storageStorage;\n+  private final KeyValueStorage trieBranchStorage;\n+  private final KeyValueStorage trieLogStorage;\n+\n+  private Bytes32 worldStateRootHash;\n+\n+  private final BonsaiWorldStateArchive archive;\n+  private BonsaiWorldStateUpdater updater;\n+\n+  public BonsaiPersistedWorldState(\n+      final BonsaiWorldStateArchive archive,\n+      final KeyValueStorage accountStorage,\n+      final KeyValueStorage codeStorage,\n+      final KeyValueStorage storageStorage,\n+      final KeyValueStorage trieBranchStorage,\n+      final KeyValueStorage trieLogStorage) {\n+    this.archive = archive;\n+    this.accountStorage = accountStorage;\n+    this.codeStorage = codeStorage;\n+    this.storageStorage = storageStorage;\n+    this.trieBranchStorage = trieBranchStorage;\n+    this.trieLogStorage = trieLogStorage;\n+    worldStateRootHash =\n+        Bytes32.wrap(\n+            trieBranchStorage.get(WORLD_ROOT_KEY).map(Bytes::wrap).orElse(Hash.EMPTY_TRIE_HASH));\n+  }\n+\n+  public BonsaiWorldStateArchive getArchive() {\n+    return archive;\n+  }\n+\n+  @Override\n+  public MutableWorldState copy() {\n+    throw new UnsupportedOperationException(\n+        \"Bonsai Tries does not support direct duplication of the persisted tries.\");\n+  }\n+\n+  @Override\n+  public Bytes getCode(@Nonnull final Address address) {\n+    return codeStorage.get(address.toArrayUnsafe()).map(Bytes::wrap).orElse(Bytes.EMPTY);\n+  }\n+\n+  @Override\n+  public void persist(final Hash blockHash) {\n+    boolean success = false;\n+    final KeyValueStorageTransaction accountTx = accountStorage.startTransaction();\n+    final KeyValueStorageTransaction codeTx = codeStorage.startTransaction();\n+    final KeyValueStorageTransaction storageTx = storageStorage.startTransaction();\n+    final KeyValueStorageTransaction trieBranchTx = trieBranchStorage.startTransaction();\n+    final KeyValueStorageTransaction trieLogTx = trieLogStorage.startTransaction();\n+\n+    try {\n+      // first clear storage\n+      for (final Address address : updater.getStorageToClear()) {\n+        // because we are clearing persisted values we need the account root as persisted\n+        final BonsaiAccount oldAccount =\n+            accountStorage\n+                .get(address.toArrayUnsafe())\n+                .map(\n+                    bytes ->\n+                        fromRLP(BonsaiPersistedWorldState.this, address, Bytes.wrap(bytes), true))\n+                .orElse(null);\n+        if (oldAccount == null) {\n+          // This is when an account is both created and deleted within the scope of the same\n+          // block.  A not-uncommon DeFi bot pattern.\n+          continue;\n+        }\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(address, location, key),\n+                oldAccount.getStorageRoot(),\n+                Function.identity(),\n+                Function.identity());\n+        Map<Bytes32, Bytes> entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+        while (!entriesToDelete.isEmpty()) {\n+          entriesToDelete\n+              .keySet()\n+              .forEach(k -> storageTx.remove(Bytes.concatenate(address, k).toArrayUnsafe()));\n+          if (entriesToDelete.size() == 256) {\n+            entriesToDelete.keySet().forEach(storageTrie::remove);\n+            entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+          } else {\n+            break;\n+          }\n+        }\n+      }\n+\n+      // second update account storage state.  This must be done before updating the accounts so\n+      // that we can get the storage state hash\n+      for (final Map.Entry<Address, Map<Hash, BonsaiValue<UInt256>>> storageAccountUpdate :\n+          updater.getStorageToUpdate().entrySet()) {\n+        final Address updatedAddress = storageAccountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> accountValue =\n+            updater.getAccountsToUpdate().get(updatedAddress);\n+        final BonsaiAccount accountOriginal = accountValue.getOriginal();\n+        final Hash storageRoot =\n+            (accountOriginal == null) ? Hash.EMPTY_TRIE_HASH : accountOriginal.getStorageRoot();\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(updatedAddress, location, key),\n+                storageRoot,\n+                Function.identity(),\n+                Function.identity());\n+\n+        // for manicured tries and composting, collect branches here (not implemented)\n+\n+        for (final Map.Entry<Hash, BonsaiValue<UInt256>> storageUpdate :\n+            storageAccountUpdate.getValue().entrySet()) {\n+          final Hash keyHash = storageUpdate.getKey();\n+          final byte[] writeAddress = Bytes.concatenate(updatedAddress, keyHash).toArrayUnsafe();\n+          final UInt256 updatedStorage = storageUpdate.getValue().getUpdated();\n+          if (updatedStorage == null || updatedStorage.equals(UInt256.ZERO)) {\n+            storageTx.remove(writeAddress);\n+            storageTrie.remove(keyHash);\n+          } else {\n+            final Bytes32 updatedStorageBytes = updatedStorage.toBytes();\n+            storageTx.put(writeAddress, updatedStorageBytes.toArrayUnsafe());\n+            storageTrie.put(keyHash, rlpEncode(updatedStorageBytes));\n+          }\n+        }\n+\n+        final BonsaiAccount accountUpdated = accountValue.getUpdated();\n+        if (accountUpdated != null) {\n+          storageTrie.commit(\n+              (location, key, value) ->\n+                  writeStorageTrieNode(trieBranchTx, updatedAddress, location, key, value));\n+          final Hash newStorageRoot = Hash.wrap(storageTrie.getRootHash());\n+          accountUpdated.setStorageRoot(newStorageRoot);\n+        }\n+        // for manicured tries and composting, trim and compost here\n+      }\n+\n+      // Third update the code.  This has the side effect of ensuring a code hash is calculated.\n+      for (final Map.Entry<Address, BonsaiValue<Bytes>> codeUpdate :\n+          updater.getCodeToUpdate().entrySet()) {\n+        final Bytes updatedCode = codeUpdate.getValue().getUpdated();\n+        if (updatedCode == null || updatedCode.size() == 0) {\n+          codeTx.remove(codeUpdate.getKey().toArrayUnsafe());\n+        } else {\n+          codeTx.put(codeUpdate.getKey().toArrayUnsafe(), updatedCode.toArrayUnsafe());\n+        }\n+      }\n+\n+      // next collect the branches that will be trimmed\n+      final StoredMerklePatriciaTrie<Bytes, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              this::getTrieNode, worldStateRootHash, Function.identity(), Function.identity());\n+\n+      // for manicured tries and composting, collect branches here (not implemented)\n+\n+      // now add the accounts\n+      for (final Map.Entry<Address, BonsaiValue<BonsaiAccount>> accountUpdate :\n+          updater.getAccountsToUpdate().entrySet()) {\n+        final Bytes accountKey = accountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> bonsaiValue = accountUpdate.getValue();\n+        final BonsaiAccount updatedAccount = bonsaiValue.getUpdated();\n+        if (updatedAccount == null) {\n+          final Hash addressHash = Hash.hash(accountKey);\n+          accountTrie.remove(addressHash);\n+          accountTx.remove(accountKey.toArrayUnsafe());\n+        } else {\n+          final Hash addressHash = updatedAccount.getAddressHash();\n+          final Bytes accountValue = updatedAccount.serializeAccount();\n+          accountTx.put(accountKey.toArrayUnsafe(), accountValue.toArrayUnsafe());\n+          accountTrie.put(addressHash, accountValue);\n+        }\n+      }\n+\n+      accountTrie.commit(\n+          (location, hash, value) -> writeTrieNode(trieBranchTx, location, hash, value));\n+      worldStateRootHash = accountTrie.getRootHash();\n+      trieBranchTx.put(WORLD_ROOT_KEY, worldStateRootHash.toArrayUnsafe());\n+\n+      // for manicured tries and composting, trim and compost branches here\n+\n+      if (blockHash != null) {\n+        final TrieLogLayer trieLog = updater.generateTrieLog(blockHash);\n+        trieLog.freeze();\n+        // TODO add to archive here, but only once we get persisted follow distance implemented\n+        // archive.addLayeredWorldState(new BonsaiLayeredWorldState(this, trieLog));\n+\n+        final BytesValueRLPOutput rlpLog = new BytesValueRLPOutput();\n+        trieLog.writeTo(rlpLog);\n+        trieLogTx.put(blockHash.toArrayUnsafe(), rlpLog.encoded().toArrayUnsafe());\n+      }\n+\n+      success = true;\n+    } finally {\n+      if (success) {\n+        accountTx.commit();\n+        codeTx.commit();\n+        storageTx.commit();\n+        trieBranchTx.commit();\n+        trieLogTx.commit();\n+        updater.reset();\n+      } else {\n+        accountTx.rollback();\n+        codeTx.rollback();\n+        storageTx.rollback();\n+        trieBranchTx.rollback();\n+        trieLogTx.rollback();\n+      }\n+    }\n+  }\n+\n+  private static Bytes rlpEncode(final Bytes bytes) {\n+    final BytesValueRLPOutput out = new BytesValueRLPOutput();\n+    out.writeBytes(bytes.trimLeadingZeros());\n+    return out.encoded();\n+  }\n+\n+  @Override\n+  public WorldUpdater updater() {\n+    if (updater == null) {\n+      updater = new BonsaiWorldStateUpdater(this);\n+    }\n+    return updater;\n+  }\n+\n+  @Override\n+  public Hash rootHash() {\n+    return Hash.wrap(worldStateRootHash);\n+  }\n+\n+  @Override\n+  public Stream<StreamableAccount> streamAccounts(final Bytes32 startKeyHash, final int limit) {\n+    throw new RuntimeException(\"NIY\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEwMzI5NQ=="}, "originalCommit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEyMzcxNw==", "bodyText": "The impact is the debug API and hence remix needs it.  So I would have to do a heavy weight merge operation with the layered modes.  For local debugging I think keeping forest for now is the thing to do.", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536123717", "createdAt": "2020-12-04T14:07:10Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static org.hyperledger.besu.ethereum.bonsai.BonsaiAccount.fromRLP;\n+\n+import org.hyperledger.besu.ethereum.core.Account;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.MerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorageTransaction;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import javax.annotation.Nonnull;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiPersistedWorldState implements MutableWorldState, BonsaiWorldState {\n+\n+  private static final byte[] WORLD_ROOT_KEY = \"worldRoot\".getBytes(StandardCharsets.UTF_8);\n+\n+  private final KeyValueStorage accountStorage;\n+  private final KeyValueStorage codeStorage;\n+  private final KeyValueStorage storageStorage;\n+  private final KeyValueStorage trieBranchStorage;\n+  private final KeyValueStorage trieLogStorage;\n+\n+  private Bytes32 worldStateRootHash;\n+\n+  private final BonsaiWorldStateArchive archive;\n+  private BonsaiWorldStateUpdater updater;\n+\n+  public BonsaiPersistedWorldState(\n+      final BonsaiWorldStateArchive archive,\n+      final KeyValueStorage accountStorage,\n+      final KeyValueStorage codeStorage,\n+      final KeyValueStorage storageStorage,\n+      final KeyValueStorage trieBranchStorage,\n+      final KeyValueStorage trieLogStorage) {\n+    this.archive = archive;\n+    this.accountStorage = accountStorage;\n+    this.codeStorage = codeStorage;\n+    this.storageStorage = storageStorage;\n+    this.trieBranchStorage = trieBranchStorage;\n+    this.trieLogStorage = trieLogStorage;\n+    worldStateRootHash =\n+        Bytes32.wrap(\n+            trieBranchStorage.get(WORLD_ROOT_KEY).map(Bytes::wrap).orElse(Hash.EMPTY_TRIE_HASH));\n+  }\n+\n+  public BonsaiWorldStateArchive getArchive() {\n+    return archive;\n+  }\n+\n+  @Override\n+  public MutableWorldState copy() {\n+    throw new UnsupportedOperationException(\n+        \"Bonsai Tries does not support direct duplication of the persisted tries.\");\n+  }\n+\n+  @Override\n+  public Bytes getCode(@Nonnull final Address address) {\n+    return codeStorage.get(address.toArrayUnsafe()).map(Bytes::wrap).orElse(Bytes.EMPTY);\n+  }\n+\n+  @Override\n+  public void persist(final Hash blockHash) {\n+    boolean success = false;\n+    final KeyValueStorageTransaction accountTx = accountStorage.startTransaction();\n+    final KeyValueStorageTransaction codeTx = codeStorage.startTransaction();\n+    final KeyValueStorageTransaction storageTx = storageStorage.startTransaction();\n+    final KeyValueStorageTransaction trieBranchTx = trieBranchStorage.startTransaction();\n+    final KeyValueStorageTransaction trieLogTx = trieLogStorage.startTransaction();\n+\n+    try {\n+      // first clear storage\n+      for (final Address address : updater.getStorageToClear()) {\n+        // because we are clearing persisted values we need the account root as persisted\n+        final BonsaiAccount oldAccount =\n+            accountStorage\n+                .get(address.toArrayUnsafe())\n+                .map(\n+                    bytes ->\n+                        fromRLP(BonsaiPersistedWorldState.this, address, Bytes.wrap(bytes), true))\n+                .orElse(null);\n+        if (oldAccount == null) {\n+          // This is when an account is both created and deleted within the scope of the same\n+          // block.  A not-uncommon DeFi bot pattern.\n+          continue;\n+        }\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(address, location, key),\n+                oldAccount.getStorageRoot(),\n+                Function.identity(),\n+                Function.identity());\n+        Map<Bytes32, Bytes> entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+        while (!entriesToDelete.isEmpty()) {\n+          entriesToDelete\n+              .keySet()\n+              .forEach(k -> storageTx.remove(Bytes.concatenate(address, k).toArrayUnsafe()));\n+          if (entriesToDelete.size() == 256) {\n+            entriesToDelete.keySet().forEach(storageTrie::remove);\n+            entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+          } else {\n+            break;\n+          }\n+        }\n+      }\n+\n+      // second update account storage state.  This must be done before updating the accounts so\n+      // that we can get the storage state hash\n+      for (final Map.Entry<Address, Map<Hash, BonsaiValue<UInt256>>> storageAccountUpdate :\n+          updater.getStorageToUpdate().entrySet()) {\n+        final Address updatedAddress = storageAccountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> accountValue =\n+            updater.getAccountsToUpdate().get(updatedAddress);\n+        final BonsaiAccount accountOriginal = accountValue.getOriginal();\n+        final Hash storageRoot =\n+            (accountOriginal == null) ? Hash.EMPTY_TRIE_HASH : accountOriginal.getStorageRoot();\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(updatedAddress, location, key),\n+                storageRoot,\n+                Function.identity(),\n+                Function.identity());\n+\n+        // for manicured tries and composting, collect branches here (not implemented)\n+\n+        for (final Map.Entry<Hash, BonsaiValue<UInt256>> storageUpdate :\n+            storageAccountUpdate.getValue().entrySet()) {\n+          final Hash keyHash = storageUpdate.getKey();\n+          final byte[] writeAddress = Bytes.concatenate(updatedAddress, keyHash).toArrayUnsafe();\n+          final UInt256 updatedStorage = storageUpdate.getValue().getUpdated();\n+          if (updatedStorage == null || updatedStorage.equals(UInt256.ZERO)) {\n+            storageTx.remove(writeAddress);\n+            storageTrie.remove(keyHash);\n+          } else {\n+            final Bytes32 updatedStorageBytes = updatedStorage.toBytes();\n+            storageTx.put(writeAddress, updatedStorageBytes.toArrayUnsafe());\n+            storageTrie.put(keyHash, rlpEncode(updatedStorageBytes));\n+          }\n+        }\n+\n+        final BonsaiAccount accountUpdated = accountValue.getUpdated();\n+        if (accountUpdated != null) {\n+          storageTrie.commit(\n+              (location, key, value) ->\n+                  writeStorageTrieNode(trieBranchTx, updatedAddress, location, key, value));\n+          final Hash newStorageRoot = Hash.wrap(storageTrie.getRootHash());\n+          accountUpdated.setStorageRoot(newStorageRoot);\n+        }\n+        // for manicured tries and composting, trim and compost here\n+      }\n+\n+      // Third update the code.  This has the side effect of ensuring a code hash is calculated.\n+      for (final Map.Entry<Address, BonsaiValue<Bytes>> codeUpdate :\n+          updater.getCodeToUpdate().entrySet()) {\n+        final Bytes updatedCode = codeUpdate.getValue().getUpdated();\n+        if (updatedCode == null || updatedCode.size() == 0) {\n+          codeTx.remove(codeUpdate.getKey().toArrayUnsafe());\n+        } else {\n+          codeTx.put(codeUpdate.getKey().toArrayUnsafe(), updatedCode.toArrayUnsafe());\n+        }\n+      }\n+\n+      // next collect the branches that will be trimmed\n+      final StoredMerklePatriciaTrie<Bytes, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              this::getTrieNode, worldStateRootHash, Function.identity(), Function.identity());\n+\n+      // for manicured tries and composting, collect branches here (not implemented)\n+\n+      // now add the accounts\n+      for (final Map.Entry<Address, BonsaiValue<BonsaiAccount>> accountUpdate :\n+          updater.getAccountsToUpdate().entrySet()) {\n+        final Bytes accountKey = accountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> bonsaiValue = accountUpdate.getValue();\n+        final BonsaiAccount updatedAccount = bonsaiValue.getUpdated();\n+        if (updatedAccount == null) {\n+          final Hash addressHash = Hash.hash(accountKey);\n+          accountTrie.remove(addressHash);\n+          accountTx.remove(accountKey.toArrayUnsafe());\n+        } else {\n+          final Hash addressHash = updatedAccount.getAddressHash();\n+          final Bytes accountValue = updatedAccount.serializeAccount();\n+          accountTx.put(accountKey.toArrayUnsafe(), accountValue.toArrayUnsafe());\n+          accountTrie.put(addressHash, accountValue);\n+        }\n+      }\n+\n+      accountTrie.commit(\n+          (location, hash, value) -> writeTrieNode(trieBranchTx, location, hash, value));\n+      worldStateRootHash = accountTrie.getRootHash();\n+      trieBranchTx.put(WORLD_ROOT_KEY, worldStateRootHash.toArrayUnsafe());\n+\n+      // for manicured tries and composting, trim and compost branches here\n+\n+      if (blockHash != null) {\n+        final TrieLogLayer trieLog = updater.generateTrieLog(blockHash);\n+        trieLog.freeze();\n+        // TODO add to archive here, but only once we get persisted follow distance implemented\n+        // archive.addLayeredWorldState(new BonsaiLayeredWorldState(this, trieLog));\n+\n+        final BytesValueRLPOutput rlpLog = new BytesValueRLPOutput();\n+        trieLog.writeTo(rlpLog);\n+        trieLogTx.put(blockHash.toArrayUnsafe(), rlpLog.encoded().toArrayUnsafe());\n+      }\n+\n+      success = true;\n+    } finally {\n+      if (success) {\n+        accountTx.commit();\n+        codeTx.commit();\n+        storageTx.commit();\n+        trieBranchTx.commit();\n+        trieLogTx.commit();\n+        updater.reset();\n+      } else {\n+        accountTx.rollback();\n+        codeTx.rollback();\n+        storageTx.rollback();\n+        trieBranchTx.rollback();\n+        trieLogTx.rollback();\n+      }\n+    }\n+  }\n+\n+  private static Bytes rlpEncode(final Bytes bytes) {\n+    final BytesValueRLPOutput out = new BytesValueRLPOutput();\n+    out.writeBytes(bytes.trimLeadingZeros());\n+    return out.encoded();\n+  }\n+\n+  @Override\n+  public WorldUpdater updater() {\n+    if (updater == null) {\n+      updater = new BonsaiWorldStateUpdater(this);\n+    }\n+    return updater;\n+  }\n+\n+  @Override\n+  public Hash rootHash() {\n+    return Hash.wrap(worldStateRootHash);\n+  }\n+\n+  @Override\n+  public Stream<StreamableAccount> streamAccounts(final Bytes32 startKeyHash, final int limit) {\n+    throw new RuntimeException(\"NIY\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEwMzI5NQ=="}, "originalCommit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d"}, "originalPosition": 275}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2ODgxODUyOnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/TrieLogLayer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxNzozODowMVrOH_9b2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxNzozODowMVrOH_9b2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgyODg4OQ==", "bodyText": "\ud83e\udd23", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536828889", "createdAt": "2020-12-05T17:38:01Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/TrieLogLayer.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.rlp.RLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLPOutput;\n+import org.hyperledger.besu.ethereum.worldstate.StateTrieAccountValue;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+/**\n+ * This class encapsulates the changes that are done to transition one block to the next. This\n+ * includes serialization and deserialization tasks for storing this log to off-memory storage.\n+ *\n+ * <p>In this particular formulation only the \"Leaves\" are tracked\" Future layers may track patrica\n+ * trie changes as well.\n+ */\n+public class TrieLogLayer {\n+\n+  private Hash blockHash;\n+  private final Map<Address, BonsaiValue<StateTrieAccountValue>> accounts = new TreeMap<>();\n+  private final Map<Address, BonsaiValue<Bytes>> code = new TreeMap<>();\n+  private final Map<Address, Map<Hash, BonsaiValue<UInt256>>> storage = new TreeMap<>();\n+  private boolean frozen = false;\n+\n+  /** Locks the layer so no new changes can be added; */\n+  void freeze() {\n+    frozen = true; // The code never bothered me anyway", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624587f9e2e91ef5d39de022facb62cd1e04ef15"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2ODgzNjQ0OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxNzo1MDozMVrOH_9jnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQyMTo1MDo0MFrOIABuOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgzMDg3Nw==", "bodyText": "It felt logically circuitous that the updater comes from a persisted world state (which is like the \"bottom\" layer in my head) but ultimately gets at the layers \"above\" through the context in the BonsaiAccount. AbstractBlockProcessor requires a MutableWorldState and in this implementation that's only the BonsaiPersistedWorldState. I wonder if it would become cleaner if the MutableWorldState was an object that encapsulated the totality of layered and persisted storage?", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536830877", "createdAt": "2020-12-05T17:50:31Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static org.hyperledger.besu.ethereum.bonsai.BonsaiAccount.fromRLP;\n+\n+import org.hyperledger.besu.ethereum.core.Account;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.MerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorageTransaction;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import javax.annotation.Nonnull;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiPersistedWorldState implements MutableWorldState, BonsaiWorldState {\n+\n+  private static final byte[] WORLD_ROOT_KEY = \"worldRoot\".getBytes(StandardCharsets.UTF_8);\n+\n+  private final KeyValueStorage accountStorage;\n+  private final KeyValueStorage codeStorage;\n+  private final KeyValueStorage storageStorage;\n+  private final KeyValueStorage trieBranchStorage;\n+  private final KeyValueStorage trieLogStorage;\n+\n+  private Bytes32 worldStateRootHash;\n+\n+  private final BonsaiWorldStateArchive archive;\n+  private BonsaiWorldStateUpdater updater;\n+\n+  public BonsaiPersistedWorldState(\n+      final BonsaiWorldStateArchive archive,\n+      final KeyValueStorage accountStorage,\n+      final KeyValueStorage codeStorage,\n+      final KeyValueStorage storageStorage,\n+      final KeyValueStorage trieBranchStorage,\n+      final KeyValueStorage trieLogStorage) {\n+    this.archive = archive;\n+    this.accountStorage = accountStorage;\n+    this.codeStorage = codeStorage;\n+    this.storageStorage = storageStorage;\n+    this.trieBranchStorage = trieBranchStorage;\n+    this.trieLogStorage = trieLogStorage;\n+    worldStateRootHash =\n+        Bytes32.wrap(\n+            trieBranchStorage.get(WORLD_ROOT_KEY).map(Bytes::wrap).orElse(Hash.EMPTY_TRIE_HASH));\n+  }\n+\n+  public BonsaiWorldStateArchive getArchive() {\n+    return archive;\n+  }\n+\n+  @Override\n+  public MutableWorldState copy() {\n+    throw new UnsupportedOperationException(\n+        \"Bonsai Tries does not support direct duplication of the persisted tries.\");\n+  }\n+\n+  @Override\n+  public Bytes getCode(@Nonnull final Address address) {\n+    return codeStorage.get(address.toArrayUnsafe()).map(Bytes::wrap).orElse(Bytes.EMPTY);\n+  }\n+\n+  @Override\n+  public void persist(final Hash blockHash) {\n+    boolean success = false;\n+    final KeyValueStorageTransaction accountTx = accountStorage.startTransaction();\n+    final KeyValueStorageTransaction codeTx = codeStorage.startTransaction();\n+    final KeyValueStorageTransaction storageTx = storageStorage.startTransaction();\n+    final KeyValueStorageTransaction trieBranchTx = trieBranchStorage.startTransaction();\n+    final KeyValueStorageTransaction trieLogTx = trieLogStorage.startTransaction();\n+\n+    try {\n+      // first clear storage\n+      for (final Address address : updater.getStorageToClear()) {\n+        // because we are clearing persisted values we need the account root as persisted\n+        final BonsaiAccount oldAccount =\n+            accountStorage\n+                .get(address.toArrayUnsafe())\n+                .map(\n+                    bytes ->\n+                        fromRLP(BonsaiPersistedWorldState.this, address, Bytes.wrap(bytes), true))\n+                .orElse(null);\n+        if (oldAccount == null) {\n+          // This is when an account is both created and deleted within the scope of the same\n+          // block.  A not-uncommon DeFi bot pattern.\n+          continue;\n+        }\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(address, location, key),\n+                oldAccount.getStorageRoot(),\n+                Function.identity(),\n+                Function.identity());\n+        Map<Bytes32, Bytes> entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+        while (!entriesToDelete.isEmpty()) {\n+          entriesToDelete\n+              .keySet()\n+              .forEach(k -> storageTx.remove(Bytes.concatenate(address, k).toArrayUnsafe()));\n+          if (entriesToDelete.size() == 256) {\n+            entriesToDelete.keySet().forEach(storageTrie::remove);\n+            entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+          } else {\n+            break;\n+          }\n+        }\n+      }\n+\n+      // second update account storage state.  This must be done before updating the accounts so\n+      // that we can get the storage state hash\n+      for (final Map.Entry<Address, Map<Hash, BonsaiValue<UInt256>>> storageAccountUpdate :\n+          updater.getStorageToUpdate().entrySet()) {\n+        final Address updatedAddress = storageAccountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> accountValue =\n+            updater.getAccountsToUpdate().get(updatedAddress);\n+        final BonsaiAccount accountOriginal = accountValue.getOriginal();\n+        final Hash storageRoot =\n+            (accountOriginal == null) ? Hash.EMPTY_TRIE_HASH : accountOriginal.getStorageRoot();\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(updatedAddress, location, key),\n+                storageRoot,\n+                Function.identity(),\n+                Function.identity());\n+\n+        // for manicured tries and composting, collect branches here (not implemented)\n+\n+        for (final Map.Entry<Hash, BonsaiValue<UInt256>> storageUpdate :\n+            storageAccountUpdate.getValue().entrySet()) {\n+          final Hash keyHash = storageUpdate.getKey();\n+          final byte[] writeAddress = Bytes.concatenate(updatedAddress, keyHash).toArrayUnsafe();\n+          final UInt256 updatedStorage = storageUpdate.getValue().getUpdated();\n+          if (updatedStorage == null || updatedStorage.equals(UInt256.ZERO)) {\n+            storageTx.remove(writeAddress);\n+            storageTrie.remove(keyHash);\n+          } else {\n+            final Bytes32 updatedStorageBytes = updatedStorage.toBytes();\n+            storageTx.put(writeAddress, updatedStorageBytes.toArrayUnsafe());\n+            storageTrie.put(keyHash, rlpEncode(updatedStorageBytes));\n+          }\n+        }\n+\n+        final BonsaiAccount accountUpdated = accountValue.getUpdated();\n+        if (accountUpdated != null) {\n+          storageTrie.commit(\n+              (location, key, value) ->\n+                  writeStorageTrieNode(trieBranchTx, updatedAddress, location, value));\n+          final Hash newStorageRoot = Hash.wrap(storageTrie.getRootHash());\n+          accountUpdated.setStorageRoot(newStorageRoot);\n+        }\n+        // for manicured tries and composting, trim and compost here\n+      }\n+\n+      // Third update the code.  This has the side effect of ensuring a code hash is calculated.\n+      for (final Map.Entry<Address, BonsaiValue<Bytes>> codeUpdate :\n+          updater.getCodeToUpdate().entrySet()) {\n+        final Bytes updatedCode = codeUpdate.getValue().getUpdated();\n+        if (updatedCode == null || updatedCode.size() == 0) {\n+          codeTx.remove(codeUpdate.getKey().toArrayUnsafe());\n+        } else {\n+          codeTx.put(codeUpdate.getKey().toArrayUnsafe(), updatedCode.toArrayUnsafe());\n+        }\n+      }\n+\n+      // next collect the branches that will be trimmed\n+      final StoredMerklePatriciaTrie<Bytes, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              this::getTrieNode, worldStateRootHash, Function.identity(), Function.identity());\n+\n+      // for manicured tries and composting, collect branches here (not implemented)\n+\n+      // now add the accounts\n+      for (final Map.Entry<Address, BonsaiValue<BonsaiAccount>> accountUpdate :\n+          updater.getAccountsToUpdate().entrySet()) {\n+        final Bytes accountKey = accountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> bonsaiValue = accountUpdate.getValue();\n+        final BonsaiAccount updatedAccount = bonsaiValue.getUpdated();\n+        if (updatedAccount == null) {\n+          final Hash addressHash = Hash.hash(accountKey);\n+          accountTrie.remove(addressHash);\n+          accountTx.remove(accountKey.toArrayUnsafe());\n+        } else {\n+          final Hash addressHash = updatedAccount.getAddressHash();\n+          final Bytes accountValue = updatedAccount.serializeAccount();\n+          accountTx.put(accountKey.toArrayUnsafe(), accountValue.toArrayUnsafe());\n+          accountTrie.put(addressHash, accountValue);\n+        }\n+      }\n+\n+      accountTrie.commit((location, hash, value) -> writeTrieNode(trieBranchTx, location, value));\n+      worldStateRootHash = accountTrie.getRootHash();\n+      trieBranchTx.put(WORLD_ROOT_KEY, worldStateRootHash.toArrayUnsafe());\n+\n+      // for manicured tries and composting, trim and compost branches here\n+\n+      if (blockHash != null) {\n+        final TrieLogLayer trieLog = updater.generateTrieLog(blockHash);\n+        trieLog.freeze();\n+        // TODO add to archive here, but only once we get persisted follow distance implemented\n+        // archive.addLayeredWorldState(new BonsaiLayeredWorldState(this, trieLog));\n+\n+        final BytesValueRLPOutput rlpLog = new BytesValueRLPOutput();\n+        trieLog.writeTo(rlpLog);\n+        trieLogTx.put(blockHash.toArrayUnsafe(), rlpLog.encoded().toArrayUnsafe());\n+      }\n+\n+      success = true;\n+    } finally {\n+      if (success) {\n+        accountTx.commit();\n+        codeTx.commit();\n+        storageTx.commit();\n+        trieBranchTx.commit();\n+        trieLogTx.commit();\n+        updater.reset();\n+      } else {\n+        accountTx.rollback();\n+        codeTx.rollback();\n+        storageTx.rollback();\n+        trieBranchTx.rollback();\n+        trieLogTx.rollback();\n+      }\n+    }\n+  }\n+\n+  private static Bytes rlpEncode(final Bytes bytes) {\n+    final BytesValueRLPOutput out = new BytesValueRLPOutput();\n+    out.writeBytes(bytes.trimLeadingZeros());\n+    return out.encoded();\n+  }\n+\n+  @Override\n+  public WorldUpdater updater() {\n+    if (updater == null) {\n+      updater = new BonsaiWorldStateUpdater(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624587f9e2e91ef5d39de022facb62cd1e04ef15"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5OTEzMQ==", "bodyText": "As I get to the full lagging persisted state this will change.  Right now no layered world states sit between the updater and the persisted state, and there is only one persisted and one pending state.  Expect this to change dramatically.", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536899131", "createdAt": "2020-12-05T21:50:40Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static org.hyperledger.besu.ethereum.bonsai.BonsaiAccount.fromRLP;\n+\n+import org.hyperledger.besu.ethereum.core.Account;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.MerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorageTransaction;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import javax.annotation.Nonnull;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiPersistedWorldState implements MutableWorldState, BonsaiWorldState {\n+\n+  private static final byte[] WORLD_ROOT_KEY = \"worldRoot\".getBytes(StandardCharsets.UTF_8);\n+\n+  private final KeyValueStorage accountStorage;\n+  private final KeyValueStorage codeStorage;\n+  private final KeyValueStorage storageStorage;\n+  private final KeyValueStorage trieBranchStorage;\n+  private final KeyValueStorage trieLogStorage;\n+\n+  private Bytes32 worldStateRootHash;\n+\n+  private final BonsaiWorldStateArchive archive;\n+  private BonsaiWorldStateUpdater updater;\n+\n+  public BonsaiPersistedWorldState(\n+      final BonsaiWorldStateArchive archive,\n+      final KeyValueStorage accountStorage,\n+      final KeyValueStorage codeStorage,\n+      final KeyValueStorage storageStorage,\n+      final KeyValueStorage trieBranchStorage,\n+      final KeyValueStorage trieLogStorage) {\n+    this.archive = archive;\n+    this.accountStorage = accountStorage;\n+    this.codeStorage = codeStorage;\n+    this.storageStorage = storageStorage;\n+    this.trieBranchStorage = trieBranchStorage;\n+    this.trieLogStorage = trieLogStorage;\n+    worldStateRootHash =\n+        Bytes32.wrap(\n+            trieBranchStorage.get(WORLD_ROOT_KEY).map(Bytes::wrap).orElse(Hash.EMPTY_TRIE_HASH));\n+  }\n+\n+  public BonsaiWorldStateArchive getArchive() {\n+    return archive;\n+  }\n+\n+  @Override\n+  public MutableWorldState copy() {\n+    throw new UnsupportedOperationException(\n+        \"Bonsai Tries does not support direct duplication of the persisted tries.\");\n+  }\n+\n+  @Override\n+  public Bytes getCode(@Nonnull final Address address) {\n+    return codeStorage.get(address.toArrayUnsafe()).map(Bytes::wrap).orElse(Bytes.EMPTY);\n+  }\n+\n+  @Override\n+  public void persist(final Hash blockHash) {\n+    boolean success = false;\n+    final KeyValueStorageTransaction accountTx = accountStorage.startTransaction();\n+    final KeyValueStorageTransaction codeTx = codeStorage.startTransaction();\n+    final KeyValueStorageTransaction storageTx = storageStorage.startTransaction();\n+    final KeyValueStorageTransaction trieBranchTx = trieBranchStorage.startTransaction();\n+    final KeyValueStorageTransaction trieLogTx = trieLogStorage.startTransaction();\n+\n+    try {\n+      // first clear storage\n+      for (final Address address : updater.getStorageToClear()) {\n+        // because we are clearing persisted values we need the account root as persisted\n+        final BonsaiAccount oldAccount =\n+            accountStorage\n+                .get(address.toArrayUnsafe())\n+                .map(\n+                    bytes ->\n+                        fromRLP(BonsaiPersistedWorldState.this, address, Bytes.wrap(bytes), true))\n+                .orElse(null);\n+        if (oldAccount == null) {\n+          // This is when an account is both created and deleted within the scope of the same\n+          // block.  A not-uncommon DeFi bot pattern.\n+          continue;\n+        }\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(address, location, key),\n+                oldAccount.getStorageRoot(),\n+                Function.identity(),\n+                Function.identity());\n+        Map<Bytes32, Bytes> entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+        while (!entriesToDelete.isEmpty()) {\n+          entriesToDelete\n+              .keySet()\n+              .forEach(k -> storageTx.remove(Bytes.concatenate(address, k).toArrayUnsafe()));\n+          if (entriesToDelete.size() == 256) {\n+            entriesToDelete.keySet().forEach(storageTrie::remove);\n+            entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+          } else {\n+            break;\n+          }\n+        }\n+      }\n+\n+      // second update account storage state.  This must be done before updating the accounts so\n+      // that we can get the storage state hash\n+      for (final Map.Entry<Address, Map<Hash, BonsaiValue<UInt256>>> storageAccountUpdate :\n+          updater.getStorageToUpdate().entrySet()) {\n+        final Address updatedAddress = storageAccountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> accountValue =\n+            updater.getAccountsToUpdate().get(updatedAddress);\n+        final BonsaiAccount accountOriginal = accountValue.getOriginal();\n+        final Hash storageRoot =\n+            (accountOriginal == null) ? Hash.EMPTY_TRIE_HASH : accountOriginal.getStorageRoot();\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(updatedAddress, location, key),\n+                storageRoot,\n+                Function.identity(),\n+                Function.identity());\n+\n+        // for manicured tries and composting, collect branches here (not implemented)\n+\n+        for (final Map.Entry<Hash, BonsaiValue<UInt256>> storageUpdate :\n+            storageAccountUpdate.getValue().entrySet()) {\n+          final Hash keyHash = storageUpdate.getKey();\n+          final byte[] writeAddress = Bytes.concatenate(updatedAddress, keyHash).toArrayUnsafe();\n+          final UInt256 updatedStorage = storageUpdate.getValue().getUpdated();\n+          if (updatedStorage == null || updatedStorage.equals(UInt256.ZERO)) {\n+            storageTx.remove(writeAddress);\n+            storageTrie.remove(keyHash);\n+          } else {\n+            final Bytes32 updatedStorageBytes = updatedStorage.toBytes();\n+            storageTx.put(writeAddress, updatedStorageBytes.toArrayUnsafe());\n+            storageTrie.put(keyHash, rlpEncode(updatedStorageBytes));\n+          }\n+        }\n+\n+        final BonsaiAccount accountUpdated = accountValue.getUpdated();\n+        if (accountUpdated != null) {\n+          storageTrie.commit(\n+              (location, key, value) ->\n+                  writeStorageTrieNode(trieBranchTx, updatedAddress, location, value));\n+          final Hash newStorageRoot = Hash.wrap(storageTrie.getRootHash());\n+          accountUpdated.setStorageRoot(newStorageRoot);\n+        }\n+        // for manicured tries and composting, trim and compost here\n+      }\n+\n+      // Third update the code.  This has the side effect of ensuring a code hash is calculated.\n+      for (final Map.Entry<Address, BonsaiValue<Bytes>> codeUpdate :\n+          updater.getCodeToUpdate().entrySet()) {\n+        final Bytes updatedCode = codeUpdate.getValue().getUpdated();\n+        if (updatedCode == null || updatedCode.size() == 0) {\n+          codeTx.remove(codeUpdate.getKey().toArrayUnsafe());\n+        } else {\n+          codeTx.put(codeUpdate.getKey().toArrayUnsafe(), updatedCode.toArrayUnsafe());\n+        }\n+      }\n+\n+      // next collect the branches that will be trimmed\n+      final StoredMerklePatriciaTrie<Bytes, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              this::getTrieNode, worldStateRootHash, Function.identity(), Function.identity());\n+\n+      // for manicured tries and composting, collect branches here (not implemented)\n+\n+      // now add the accounts\n+      for (final Map.Entry<Address, BonsaiValue<BonsaiAccount>> accountUpdate :\n+          updater.getAccountsToUpdate().entrySet()) {\n+        final Bytes accountKey = accountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> bonsaiValue = accountUpdate.getValue();\n+        final BonsaiAccount updatedAccount = bonsaiValue.getUpdated();\n+        if (updatedAccount == null) {\n+          final Hash addressHash = Hash.hash(accountKey);\n+          accountTrie.remove(addressHash);\n+          accountTx.remove(accountKey.toArrayUnsafe());\n+        } else {\n+          final Hash addressHash = updatedAccount.getAddressHash();\n+          final Bytes accountValue = updatedAccount.serializeAccount();\n+          accountTx.put(accountKey.toArrayUnsafe(), accountValue.toArrayUnsafe());\n+          accountTrie.put(addressHash, accountValue);\n+        }\n+      }\n+\n+      accountTrie.commit((location, hash, value) -> writeTrieNode(trieBranchTx, location, value));\n+      worldStateRootHash = accountTrie.getRootHash();\n+      trieBranchTx.put(WORLD_ROOT_KEY, worldStateRootHash.toArrayUnsafe());\n+\n+      // for manicured tries and composting, trim and compost branches here\n+\n+      if (blockHash != null) {\n+        final TrieLogLayer trieLog = updater.generateTrieLog(blockHash);\n+        trieLog.freeze();\n+        // TODO add to archive here, but only once we get persisted follow distance implemented\n+        // archive.addLayeredWorldState(new BonsaiLayeredWorldState(this, trieLog));\n+\n+        final BytesValueRLPOutput rlpLog = new BytesValueRLPOutput();\n+        trieLog.writeTo(rlpLog);\n+        trieLogTx.put(blockHash.toArrayUnsafe(), rlpLog.encoded().toArrayUnsafe());\n+      }\n+\n+      success = true;\n+    } finally {\n+      if (success) {\n+        accountTx.commit();\n+        codeTx.commit();\n+        storageTx.commit();\n+        trieBranchTx.commit();\n+        trieLogTx.commit();\n+        updater.reset();\n+      } else {\n+        accountTx.rollback();\n+        codeTx.rollback();\n+        storageTx.rollback();\n+        trieBranchTx.rollback();\n+        trieLogTx.rollback();\n+      }\n+    }\n+  }\n+\n+  private static Bytes rlpEncode(final Bytes bytes) {\n+    final BytesValueRLPOutput out = new BytesValueRLPOutput();\n+    out.writeBytes(bytes.trimLeadingZeros());\n+    return out.encoded();\n+  }\n+\n+  @Override\n+  public WorldUpdater updater() {\n+    if (updater == null) {\n+      updater = new BonsaiWorldStateUpdater(this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgzMDg3Nw=="}, "originalCommit": {"oid": "624587f9e2e91ef5d39de022facb62cd1e04ef15"}, "originalPosition": 262}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1242, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}