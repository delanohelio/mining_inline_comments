{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzMjUzNDAy", "number": 981, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNDo1NzoyM1rOD_tl7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNDo1NzoyM1rOD_tl7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MTMzODcxOnYy", "diffSide": "RIGHT", "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/manager/ForkIdManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNDo1NzoyM1rOGaiSHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNToyNDo0MlrOGajkNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ3Nzg1Mg==", "bodyText": "Maybe we can use !forks.isEmpty() instead of  size() > 0", "url": "https://github.com/hyperledger/besu/pull/981#discussion_r430477852", "createdAt": "2020-05-26T14:57:23Z", "author": {"login": "matkt"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/manager/ForkIdManager.java", "diffHunk": "@@ -32,38 +34,71 @@\n \n public class ForkIdManager {\n \n-  private final Blockchain blockchain;\n   private final Hash genesisHash;\n-  private final List<Long> forks;\n-  private long forkNext;\n-  private final long highestKnownFork;\n-  private List<ForkId> forkAndHashList;\n+\n+  private final List<ForkId> legacyForkAndHashList;\n+  private final List<ForkId> forkAndHashList;\n+\n   private final List<ForkIDChecker> forkIDCheckers;\n \n   public ForkIdManager(final Blockchain blockchain, final List<Long> forks) {\n     assert blockchain != null && forks != null;\n-    this.blockchain = blockchain;\n     this.genesisHash = blockchain.getGenesisBlock().getHash();\n+    this.legacyForkAndHashList = new ArrayList<>();\n+    this.forkAndHashList = new ArrayList<>();\n     // if the fork list contains only zeros then we may be in a consortium/dev network\n     if (onlyZerosForkBlocks(forks)) {\n       this.forkIDCheckers = singletonList(forkId -> true);\n     } else {\n-      this.forkIDCheckers = singletonList(this::eip2124Checker);\n+      final ForkIDChecker legacyForkIdChecker =\n+          createForkIDChecker(\n+              blockchain,\n+              genesisHash,\n+              forks,\n+              fs ->\n+                  fs.stream()\n+                      .filter(fork -> fork > 0)\n+                      .distinct()\n+                      .collect(Collectors.toUnmodifiableList()),\n+              legacyForkAndHashList);\n+      final ForkIDChecker newForkIdChecker =\n+          createForkIDChecker(\n+              blockchain,\n+              genesisHash,\n+              forks,\n+              fs -> fs.stream().distinct().collect(Collectors.toUnmodifiableList()),\n+              forkAndHashList);\n+      this.forkIDCheckers = Arrays.asList(newForkIdChecker, legacyForkIdChecker);\n     }\n-    // de-dupe and sanitize forks\n-    this.forks = forks.stream().distinct().collect(Collectors.toUnmodifiableList());\n-    highestKnownFork = forks.size() > 0 ? forks.get(forks.size() - 1) : 0L;\n-    createForkIds();\n   }\n \n-  private boolean onlyZerosForkBlocks(final List<Long> forks) {\n+  private static ForkIDChecker createForkIDChecker(\n+      final Blockchain blockchain,\n+      final Hash genesisHash,\n+      final List<Long> forks,\n+      final Function<List<Long>, List<Long>> sanitizer,\n+      final List<ForkId> forkIds) {\n+    final List<Long> sanitizedForks = sanitizer.apply(forks);\n+    final long forkNext = createForkIds(genesisHash, sanitizedForks, forkIds);\n+    return eip2124(blockchain, forkNext, forkIds, highestKnownFork(sanitizedForks));\n+  }\n+\n+  private static boolean onlyZerosForkBlocks(final List<Long> forks) {\n     return forks.stream().allMatch(value -> 0L == value);\n   }\n \n+  private static long highestKnownFork(final List<Long> forks) {\n+    return forks.size() > 0 ? forks.get(forks.size() - 1) : 0L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2069ab219533a3146757a0c5c1c3db07dd6879b"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ5NTc3MA==", "bodyText": "Yes", "url": "https://github.com/hyperledger/besu/pull/981#discussion_r430495770", "createdAt": "2020-05-26T15:21:28Z", "author": {"login": "abdelhamidbakhta"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/manager/ForkIdManager.java", "diffHunk": "@@ -32,38 +34,71 @@\n \n public class ForkIdManager {\n \n-  private final Blockchain blockchain;\n   private final Hash genesisHash;\n-  private final List<Long> forks;\n-  private long forkNext;\n-  private final long highestKnownFork;\n-  private List<ForkId> forkAndHashList;\n+\n+  private final List<ForkId> legacyForkAndHashList;\n+  private final List<ForkId> forkAndHashList;\n+\n   private final List<ForkIDChecker> forkIDCheckers;\n \n   public ForkIdManager(final Blockchain blockchain, final List<Long> forks) {\n     assert blockchain != null && forks != null;\n-    this.blockchain = blockchain;\n     this.genesisHash = blockchain.getGenesisBlock().getHash();\n+    this.legacyForkAndHashList = new ArrayList<>();\n+    this.forkAndHashList = new ArrayList<>();\n     // if the fork list contains only zeros then we may be in a consortium/dev network\n     if (onlyZerosForkBlocks(forks)) {\n       this.forkIDCheckers = singletonList(forkId -> true);\n     } else {\n-      this.forkIDCheckers = singletonList(this::eip2124Checker);\n+      final ForkIDChecker legacyForkIdChecker =\n+          createForkIDChecker(\n+              blockchain,\n+              genesisHash,\n+              forks,\n+              fs ->\n+                  fs.stream()\n+                      .filter(fork -> fork > 0)\n+                      .distinct()\n+                      .collect(Collectors.toUnmodifiableList()),\n+              legacyForkAndHashList);\n+      final ForkIDChecker newForkIdChecker =\n+          createForkIDChecker(\n+              blockchain,\n+              genesisHash,\n+              forks,\n+              fs -> fs.stream().distinct().collect(Collectors.toUnmodifiableList()),\n+              forkAndHashList);\n+      this.forkIDCheckers = Arrays.asList(newForkIdChecker, legacyForkIdChecker);\n     }\n-    // de-dupe and sanitize forks\n-    this.forks = forks.stream().distinct().collect(Collectors.toUnmodifiableList());\n-    highestKnownFork = forks.size() > 0 ? forks.get(forks.size() - 1) : 0L;\n-    createForkIds();\n   }\n \n-  private boolean onlyZerosForkBlocks(final List<Long> forks) {\n+  private static ForkIDChecker createForkIDChecker(\n+      final Blockchain blockchain,\n+      final Hash genesisHash,\n+      final List<Long> forks,\n+      final Function<List<Long>, List<Long>> sanitizer,\n+      final List<ForkId> forkIds) {\n+    final List<Long> sanitizedForks = sanitizer.apply(forks);\n+    final long forkNext = createForkIds(genesisHash, sanitizedForks, forkIds);\n+    return eip2124(blockchain, forkNext, forkIds, highestKnownFork(sanitizedForks));\n+  }\n+\n+  private static boolean onlyZerosForkBlocks(final List<Long> forks) {\n     return forks.stream().allMatch(value -> 0L == value);\n   }\n \n+  private static long highestKnownFork(final List<Long> forks) {\n+    return forks.size() > 0 ? forks.get(forks.size() - 1) : 0L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ3Nzg1Mg=="}, "originalCommit": {"oid": "b2069ab219533a3146757a0c5c1c3db07dd6879b"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ5ODg2OQ==", "bodyText": "Done.", "url": "https://github.com/hyperledger/besu/pull/981#discussion_r430498869", "createdAt": "2020-05-26T15:24:42Z", "author": {"login": "abdelhamidbakhta"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/manager/ForkIdManager.java", "diffHunk": "@@ -32,38 +34,71 @@\n \n public class ForkIdManager {\n \n-  private final Blockchain blockchain;\n   private final Hash genesisHash;\n-  private final List<Long> forks;\n-  private long forkNext;\n-  private final long highestKnownFork;\n-  private List<ForkId> forkAndHashList;\n+\n+  private final List<ForkId> legacyForkAndHashList;\n+  private final List<ForkId> forkAndHashList;\n+\n   private final List<ForkIDChecker> forkIDCheckers;\n \n   public ForkIdManager(final Blockchain blockchain, final List<Long> forks) {\n     assert blockchain != null && forks != null;\n-    this.blockchain = blockchain;\n     this.genesisHash = blockchain.getGenesisBlock().getHash();\n+    this.legacyForkAndHashList = new ArrayList<>();\n+    this.forkAndHashList = new ArrayList<>();\n     // if the fork list contains only zeros then we may be in a consortium/dev network\n     if (onlyZerosForkBlocks(forks)) {\n       this.forkIDCheckers = singletonList(forkId -> true);\n     } else {\n-      this.forkIDCheckers = singletonList(this::eip2124Checker);\n+      final ForkIDChecker legacyForkIdChecker =\n+          createForkIDChecker(\n+              blockchain,\n+              genesisHash,\n+              forks,\n+              fs ->\n+                  fs.stream()\n+                      .filter(fork -> fork > 0)\n+                      .distinct()\n+                      .collect(Collectors.toUnmodifiableList()),\n+              legacyForkAndHashList);\n+      final ForkIDChecker newForkIdChecker =\n+          createForkIDChecker(\n+              blockchain,\n+              genesisHash,\n+              forks,\n+              fs -> fs.stream().distinct().collect(Collectors.toUnmodifiableList()),\n+              forkAndHashList);\n+      this.forkIDCheckers = Arrays.asList(newForkIdChecker, legacyForkIdChecker);\n     }\n-    // de-dupe and sanitize forks\n-    this.forks = forks.stream().distinct().collect(Collectors.toUnmodifiableList());\n-    highestKnownFork = forks.size() > 0 ? forks.get(forks.size() - 1) : 0L;\n-    createForkIds();\n   }\n \n-  private boolean onlyZerosForkBlocks(final List<Long> forks) {\n+  private static ForkIDChecker createForkIDChecker(\n+      final Blockchain blockchain,\n+      final Hash genesisHash,\n+      final List<Long> forks,\n+      final Function<List<Long>, List<Long>> sanitizer,\n+      final List<ForkId> forkIds) {\n+    final List<Long> sanitizedForks = sanitizer.apply(forks);\n+    final long forkNext = createForkIds(genesisHash, sanitizedForks, forkIds);\n+    return eip2124(blockchain, forkNext, forkIds, highestKnownFork(sanitizedForks));\n+  }\n+\n+  private static boolean onlyZerosForkBlocks(final List<Long> forks) {\n     return forks.stream().allMatch(value -> 0L == value);\n   }\n \n+  private static long highestKnownFork(final List<Long> forks) {\n+    return forks.size() > 0 ? forks.get(forks.size() - 1) : 0L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ3Nzg1Mg=="}, "originalCommit": {"oid": "b2069ab219533a3146757a0c5c1c3db07dd6879b"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 886, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}