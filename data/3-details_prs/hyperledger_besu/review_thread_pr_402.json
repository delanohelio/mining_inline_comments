{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1MTkyMTkw", "number": 402, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNDozNDoxNFrODfxuOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNDo0MzowMlrODfxxzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjQ3MDk3OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/storage/migration/PrivateStorageMigration.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNDozNDoxNFrOFprZ6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNjowNDoyMVrOFpsZVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI0NzA4Mg==", "bodyText": "are you sure about the index+1? I would have thought that index is the actual index to use for the pmt ...\nNot that it really matters, we would only execute one transaction that we don't have to execute ...", "url": "https://github.com/hyperledger/besu/pull/402#discussion_r379247082", "createdAt": "2020-02-14T04:34:14Z", "author": {"login": "pinges"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/storage/migration/PrivateStorageMigration.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy.storage.migration;\n+\n+import static org.hyperledger.besu.ethereum.privacy.storage.PrivateStateKeyValueStorage.SCHEMA_VERSION_1_4_x;\n+\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.mainnet.ProtocolSchedule;\n+import org.hyperledger.besu.ethereum.mainnet.ProtocolSpec;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.storage.LegacyPrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class PrivateStorageMigration {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Blockchain blockchain;\n+  private final Address privacyPrecompileAddress;\n+  private final ProtocolSchedule<?> protocolSchedule;\n+  private final WorldStateArchive publicWorldStateArchive;\n+  private final PrivateStateStorage privateStateStorage;\n+  private final PrivateStateRootResolver privateStateRootResolver;\n+  private final LegacyPrivateStateStorage legacyPrivateStateStorage;\n+  private final Function<ProtocolSpec<?>, PrivateMigrationBlockProcessor>\n+      privateMigrationBlockProcessorBuilder;\n+\n+  public PrivateStorageMigration(\n+      final Blockchain blockchain,\n+      final Address privacyPrecompileAddress,\n+      final ProtocolSchedule<?> protocolSchedule,\n+      final WorldStateArchive publicWorldStateArchive,\n+      final PrivateStateStorage privateStateStorage,\n+      final PrivateStateRootResolver privateStateRootResolver,\n+      final LegacyPrivateStateStorage legacyPrivateStateStorage,\n+      final Function<ProtocolSpec<?>, PrivateMigrationBlockProcessor>\n+          privateMigrationBlockProcessorBuilder) {\n+    this.privateStateStorage = privateStateStorage;\n+    this.blockchain = blockchain;\n+    this.privacyPrecompileAddress = privacyPrecompileAddress;\n+    this.protocolSchedule = protocolSchedule;\n+    this.publicWorldStateArchive = publicWorldStateArchive;\n+    this.privateStateRootResolver = privateStateRootResolver;\n+    this.legacyPrivateStateStorage = legacyPrivateStateStorage;\n+    this.privateMigrationBlockProcessorBuilder = privateMigrationBlockProcessorBuilder;\n+  }\n+\n+  public void migratePrivateStorage() {\n+    final long migrationStartTimestamp = System.currentTimeMillis();\n+    final long chainHeadBlockNumber = blockchain.getChainHeadBlockNumber();\n+\n+    LOG.info(\"Migrating private storage database...\");\n+\n+    for (int blockNumber = 0; blockNumber <= chainHeadBlockNumber; blockNumber++) {\n+      final Block block =\n+          blockchain\n+              .getBlockByNumber(blockNumber)\n+              .orElseThrow(PrivateStorageMigrationException::new);\n+      final Hash blockHash = block.getHash();\n+      final BlockHeader blockHeader = block.getHeader();\n+      LOG.info(\"Processing block {} ({}/{})\", blockHash, blockNumber, chainHeadBlockNumber);\n+\n+      createPrivacyGroupHeadBlockMap(blockHeader);\n+\n+      final int lastPmtIndex = findLastPMTIndexInBlock(block);\n+      if (lastPmtIndex >= 0) {\n+        final ProtocolSpec<?> protocolSpec = protocolSchedule.getByBlockNumber(blockNumber);\n+        final PrivateMigrationBlockProcessor privateMigrationBlockProcessor =\n+            privateMigrationBlockProcessorBuilder.apply(protocolSpec);\n+\n+        final MutableWorldState publicWorldState =\n+            blockchain\n+                .getBlockHeader(blockHeader.getParentHash())\n+                .map(BlockHeader::getStateRoot)\n+                .flatMap(publicWorldStateArchive::getMutable)\n+                .orElseThrow(PrivateStorageMigrationException::new);\n+\n+        final List<Transaction> transactionsToProcess =\n+            block.getBody().getTransactions().subList(0, lastPmtIndex + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b193c14221bd3067c3a16eb1e4b4cd140d02c5b"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI2MzMxOA==", "bodyText": "The sublist params are (inclusive, exclusive). We have a unit test checking the logic :)", "url": "https://github.com/hyperledger/besu/pull/402#discussion_r379263318", "createdAt": "2020-02-14T06:04:21Z", "author": {"login": "lucassaldanha"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/storage/migration/PrivateStorageMigration.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy.storage.migration;\n+\n+import static org.hyperledger.besu.ethereum.privacy.storage.PrivateStateKeyValueStorage.SCHEMA_VERSION_1_4_x;\n+\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.mainnet.ProtocolSchedule;\n+import org.hyperledger.besu.ethereum.mainnet.ProtocolSpec;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.storage.LegacyPrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class PrivateStorageMigration {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Blockchain blockchain;\n+  private final Address privacyPrecompileAddress;\n+  private final ProtocolSchedule<?> protocolSchedule;\n+  private final WorldStateArchive publicWorldStateArchive;\n+  private final PrivateStateStorage privateStateStorage;\n+  private final PrivateStateRootResolver privateStateRootResolver;\n+  private final LegacyPrivateStateStorage legacyPrivateStateStorage;\n+  private final Function<ProtocolSpec<?>, PrivateMigrationBlockProcessor>\n+      privateMigrationBlockProcessorBuilder;\n+\n+  public PrivateStorageMigration(\n+      final Blockchain blockchain,\n+      final Address privacyPrecompileAddress,\n+      final ProtocolSchedule<?> protocolSchedule,\n+      final WorldStateArchive publicWorldStateArchive,\n+      final PrivateStateStorage privateStateStorage,\n+      final PrivateStateRootResolver privateStateRootResolver,\n+      final LegacyPrivateStateStorage legacyPrivateStateStorage,\n+      final Function<ProtocolSpec<?>, PrivateMigrationBlockProcessor>\n+          privateMigrationBlockProcessorBuilder) {\n+    this.privateStateStorage = privateStateStorage;\n+    this.blockchain = blockchain;\n+    this.privacyPrecompileAddress = privacyPrecompileAddress;\n+    this.protocolSchedule = protocolSchedule;\n+    this.publicWorldStateArchive = publicWorldStateArchive;\n+    this.privateStateRootResolver = privateStateRootResolver;\n+    this.legacyPrivateStateStorage = legacyPrivateStateStorage;\n+    this.privateMigrationBlockProcessorBuilder = privateMigrationBlockProcessorBuilder;\n+  }\n+\n+  public void migratePrivateStorage() {\n+    final long migrationStartTimestamp = System.currentTimeMillis();\n+    final long chainHeadBlockNumber = blockchain.getChainHeadBlockNumber();\n+\n+    LOG.info(\"Migrating private storage database...\");\n+\n+    for (int blockNumber = 0; blockNumber <= chainHeadBlockNumber; blockNumber++) {\n+      final Block block =\n+          blockchain\n+              .getBlockByNumber(blockNumber)\n+              .orElseThrow(PrivateStorageMigrationException::new);\n+      final Hash blockHash = block.getHash();\n+      final BlockHeader blockHeader = block.getHeader();\n+      LOG.info(\"Processing block {} ({}/{})\", blockHash, blockNumber, chainHeadBlockNumber);\n+\n+      createPrivacyGroupHeadBlockMap(blockHeader);\n+\n+      final int lastPmtIndex = findLastPMTIndexInBlock(block);\n+      if (lastPmtIndex >= 0) {\n+        final ProtocolSpec<?> protocolSpec = protocolSchedule.getByBlockNumber(blockNumber);\n+        final PrivateMigrationBlockProcessor privateMigrationBlockProcessor =\n+            privateMigrationBlockProcessorBuilder.apply(protocolSpec);\n+\n+        final MutableWorldState publicWorldState =\n+            blockchain\n+                .getBlockHeader(blockHeader.getParentHash())\n+                .map(BlockHeader::getStateRoot)\n+                .flatMap(publicWorldStateArchive::getMutable)\n+                .orElseThrow(PrivateStorageMigrationException::new);\n+\n+        final List<Transaction> transactionsToProcess =\n+            block.getBody().getTransactions().subList(0, lastPmtIndex + 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI0NzA4Mg=="}, "originalCommit": {"oid": "6b193c14221bd3067c3a16eb1e4b4cd140d02c5b"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjQ4MDE1OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/storage/migration/PrivateStorageMigration.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNDo0MzowMlrOFprflQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNjowNToyOFrOFpsaJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI0ODUzMw==", "bodyText": "I'm not sure about the constant name for the schema version. This is going to be the version from 1.4 onwards, but maybe we are going to change the schema within the 1.4 versions again ...\nMaybe introduce an Enum for the version number that could be used to match the version number to a String that could be used to have meaningful error messages ...", "url": "https://github.com/hyperledger/besu/pull/402#discussion_r379248533", "createdAt": "2020-02-14T04:43:02Z", "author": {"login": "pinges"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/storage/migration/PrivateStorageMigration.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy.storage.migration;\n+\n+import static org.hyperledger.besu.ethereum.privacy.storage.PrivateStateKeyValueStorage.SCHEMA_VERSION_1_4_x;\n+\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.mainnet.ProtocolSchedule;\n+import org.hyperledger.besu.ethereum.mainnet.ProtocolSpec;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.storage.LegacyPrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class PrivateStorageMigration {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Blockchain blockchain;\n+  private final Address privacyPrecompileAddress;\n+  private final ProtocolSchedule<?> protocolSchedule;\n+  private final WorldStateArchive publicWorldStateArchive;\n+  private final PrivateStateStorage privateStateStorage;\n+  private final PrivateStateRootResolver privateStateRootResolver;\n+  private final LegacyPrivateStateStorage legacyPrivateStateStorage;\n+  private final Function<ProtocolSpec<?>, PrivateMigrationBlockProcessor>\n+      privateMigrationBlockProcessorBuilder;\n+\n+  public PrivateStorageMigration(\n+      final Blockchain blockchain,\n+      final Address privacyPrecompileAddress,\n+      final ProtocolSchedule<?> protocolSchedule,\n+      final WorldStateArchive publicWorldStateArchive,\n+      final PrivateStateStorage privateStateStorage,\n+      final PrivateStateRootResolver privateStateRootResolver,\n+      final LegacyPrivateStateStorage legacyPrivateStateStorage,\n+      final Function<ProtocolSpec<?>, PrivateMigrationBlockProcessor>\n+          privateMigrationBlockProcessorBuilder) {\n+    this.privateStateStorage = privateStateStorage;\n+    this.blockchain = blockchain;\n+    this.privacyPrecompileAddress = privacyPrecompileAddress;\n+    this.protocolSchedule = protocolSchedule;\n+    this.publicWorldStateArchive = publicWorldStateArchive;\n+    this.privateStateRootResolver = privateStateRootResolver;\n+    this.legacyPrivateStateStorage = legacyPrivateStateStorage;\n+    this.privateMigrationBlockProcessorBuilder = privateMigrationBlockProcessorBuilder;\n+  }\n+\n+  public void migratePrivateStorage() {\n+    final long migrationStartTimestamp = System.currentTimeMillis();\n+    final long chainHeadBlockNumber = blockchain.getChainHeadBlockNumber();\n+\n+    LOG.info(\"Migrating private storage database...\");\n+\n+    for (int blockNumber = 0; blockNumber <= chainHeadBlockNumber; blockNumber++) {\n+      final Block block =\n+          blockchain\n+              .getBlockByNumber(blockNumber)\n+              .orElseThrow(PrivateStorageMigrationException::new);\n+      final Hash blockHash = block.getHash();\n+      final BlockHeader blockHeader = block.getHeader();\n+      LOG.info(\"Processing block {} ({}/{})\", blockHash, blockNumber, chainHeadBlockNumber);\n+\n+      createPrivacyGroupHeadBlockMap(blockHeader);\n+\n+      final int lastPmtIndex = findLastPMTIndexInBlock(block);\n+      if (lastPmtIndex >= 0) {\n+        final ProtocolSpec<?> protocolSpec = protocolSchedule.getByBlockNumber(blockNumber);\n+        final PrivateMigrationBlockProcessor privateMigrationBlockProcessor =\n+            privateMigrationBlockProcessorBuilder.apply(protocolSpec);\n+\n+        final MutableWorldState publicWorldState =\n+            blockchain\n+                .getBlockHeader(blockHeader.getParentHash())\n+                .map(BlockHeader::getStateRoot)\n+                .flatMap(publicWorldStateArchive::getMutable)\n+                .orElseThrow(PrivateStorageMigrationException::new);\n+\n+        final List<Transaction> transactionsToProcess =\n+            block.getBody().getTransactions().subList(0, lastPmtIndex + 1);\n+        final List<BlockHeader> ommers = block.getBody().getOmmers();\n+\n+        privateMigrationBlockProcessor.processBlock(\n+            blockchain, publicWorldState, blockHeader, transactionsToProcess, ommers);\n+      }\n+    }\n+\n+    if (isResultingPrivateStateRootAtHeadValid()) {\n+      privateStateStorage.updater().putDatabaseVersion(SCHEMA_VERSION_1_4_x).commit();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b193c14221bd3067c3a16eb1e4b4cd140d02c5b"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI2MzUyNg==", "bodyText": "I'll rename the constants to SCHEMA_VERSION_1_0_0 and SCHEMA_VERSION_1_4_0 to make it clearer that they are specific to this release. Let's save the enum idea for when we need to change the version again! :)", "url": "https://github.com/hyperledger/besu/pull/402#discussion_r379263526", "createdAt": "2020-02-14T06:05:28Z", "author": {"login": "lucassaldanha"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/storage/migration/PrivateStorageMigration.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy.storage.migration;\n+\n+import static org.hyperledger.besu.ethereum.privacy.storage.PrivateStateKeyValueStorage.SCHEMA_VERSION_1_4_x;\n+\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.mainnet.ProtocolSchedule;\n+import org.hyperledger.besu.ethereum.mainnet.ProtocolSpec;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.storage.LegacyPrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class PrivateStorageMigration {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Blockchain blockchain;\n+  private final Address privacyPrecompileAddress;\n+  private final ProtocolSchedule<?> protocolSchedule;\n+  private final WorldStateArchive publicWorldStateArchive;\n+  private final PrivateStateStorage privateStateStorage;\n+  private final PrivateStateRootResolver privateStateRootResolver;\n+  private final LegacyPrivateStateStorage legacyPrivateStateStorage;\n+  private final Function<ProtocolSpec<?>, PrivateMigrationBlockProcessor>\n+      privateMigrationBlockProcessorBuilder;\n+\n+  public PrivateStorageMigration(\n+      final Blockchain blockchain,\n+      final Address privacyPrecompileAddress,\n+      final ProtocolSchedule<?> protocolSchedule,\n+      final WorldStateArchive publicWorldStateArchive,\n+      final PrivateStateStorage privateStateStorage,\n+      final PrivateStateRootResolver privateStateRootResolver,\n+      final LegacyPrivateStateStorage legacyPrivateStateStorage,\n+      final Function<ProtocolSpec<?>, PrivateMigrationBlockProcessor>\n+          privateMigrationBlockProcessorBuilder) {\n+    this.privateStateStorage = privateStateStorage;\n+    this.blockchain = blockchain;\n+    this.privacyPrecompileAddress = privacyPrecompileAddress;\n+    this.protocolSchedule = protocolSchedule;\n+    this.publicWorldStateArchive = publicWorldStateArchive;\n+    this.privateStateRootResolver = privateStateRootResolver;\n+    this.legacyPrivateStateStorage = legacyPrivateStateStorage;\n+    this.privateMigrationBlockProcessorBuilder = privateMigrationBlockProcessorBuilder;\n+  }\n+\n+  public void migratePrivateStorage() {\n+    final long migrationStartTimestamp = System.currentTimeMillis();\n+    final long chainHeadBlockNumber = blockchain.getChainHeadBlockNumber();\n+\n+    LOG.info(\"Migrating private storage database...\");\n+\n+    for (int blockNumber = 0; blockNumber <= chainHeadBlockNumber; blockNumber++) {\n+      final Block block =\n+          blockchain\n+              .getBlockByNumber(blockNumber)\n+              .orElseThrow(PrivateStorageMigrationException::new);\n+      final Hash blockHash = block.getHash();\n+      final BlockHeader blockHeader = block.getHeader();\n+      LOG.info(\"Processing block {} ({}/{})\", blockHash, blockNumber, chainHeadBlockNumber);\n+\n+      createPrivacyGroupHeadBlockMap(blockHeader);\n+\n+      final int lastPmtIndex = findLastPMTIndexInBlock(block);\n+      if (lastPmtIndex >= 0) {\n+        final ProtocolSpec<?> protocolSpec = protocolSchedule.getByBlockNumber(blockNumber);\n+        final PrivateMigrationBlockProcessor privateMigrationBlockProcessor =\n+            privateMigrationBlockProcessorBuilder.apply(protocolSpec);\n+\n+        final MutableWorldState publicWorldState =\n+            blockchain\n+                .getBlockHeader(blockHeader.getParentHash())\n+                .map(BlockHeader::getStateRoot)\n+                .flatMap(publicWorldStateArchive::getMutable)\n+                .orElseThrow(PrivateStorageMigrationException::new);\n+\n+        final List<Transaction> transactionsToProcess =\n+            block.getBody().getTransactions().subList(0, lastPmtIndex + 1);\n+        final List<BlockHeader> ommers = block.getBody().getOmmers();\n+\n+        privateMigrationBlockProcessor.processBlock(\n+            blockchain, publicWorldState, blockHeader, transactionsToProcess, ommers);\n+      }\n+    }\n+\n+    if (isResultingPrivateStateRootAtHeadValid()) {\n+      privateStateStorage.updater().putDatabaseVersion(SCHEMA_VERSION_1_4_x).commit();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI0ODUzMw=="}, "originalCommit": {"oid": "6b193c14221bd3067c3a16eb1e4b4cd140d02c5b"}, "originalPosition": 117}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1096, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}