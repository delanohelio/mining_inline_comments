{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg2NTY2NzEz", "number": 1381, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOTo1NDo1MlrOEktBNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOTo1NDo1MlrOEktBNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTIxNzgwOnYy", "diffSide": "RIGHT", "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/query/cache/TransactionLogBloomCacher.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOTo1NDo1MlrOHTzQTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwNjo0Mjo1M1rOHUAEQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUyNDc1MQ==", "bodyText": "nit: Feels a bit weird to use .map and then .isPresent here. Would be worth considering using .ifPresent:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      final Optional<Long> ancestorBlockNumber =\n          \n          \n            \n                          commonAncestorBlockHeader.map(ProcessableBlockHeader::getNumber);\n          \n          \n            \n                      if (ancestorBlockNumber.isPresent()) {\n          \n          \n            \n                        // walk through the blocks from the common ancestor to the received block in order to\n          \n          \n            \n                        // reload the cache in case of reorg\n          \n          \n            \n                        for (long number = ancestorBlockNumber.get() + 1;\n          \n          \n            \n                            number < blockHeader.getNumber();\n          \n          \n            \n                            number++) {\n          \n          \n            \n                          Optional<BlockHeader> ancestorBlockHeader = blockchain.getBlockHeader(number);\n          \n          \n            \n                          if (ancestorBlockHeader.isPresent()) {\n          \n          \n            \n                            cacheSingleBlock(ancestorBlockHeader.get(), cacheFile);\n          \n          \n            \n                          }\n          \n          \n            \n                        }\n          \n          \n            \n                      }\n          \n          \n            \n                      commonAncestorBlockHeader\n          \n          \n            \n                          .map(ProcessableBlockHeader::getNumber)\n          \n          \n            \n                          .ifPresent(ancestorBlockNumber -> {\n          \n          \n            \n                              // walk through the blocks from the common ancestor to the received block in order to\n          \n          \n            \n                             // reload the cache in case of reorg\n          \n          \n            \n                             for (long number = ancestorBlockNumber.get() + 1;\n          \n          \n            \n                                number < blockHeader.getNumber();\n          \n          \n            \n                                number++) {\n          \n          \n            \n                                blockchain.getBlockHeader(number).ifPresent(\n          \n          \n            \n                                    header -> cacheSingleBlock(ancestorBlockHeader.get(), cacheFile));\n          \n          \n            \n                              }\n          \n          \n            \n                        });", "url": "https://github.com/hyperledger/besu/pull/1381#discussion_r490524751", "createdAt": "2020-09-17T19:54:52Z", "author": {"login": "ajsutton"}, "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/query/cache/TransactionLogBloomCacher.java", "diffHunk": "@@ -151,6 +156,20 @@ void cacheLogsBloomForBlockHeader(\n       final File cacheFile = reusedCacheFile.orElse(calculateCacheFileName(blockNumber, cacheDir));\n       if (cacheFile.exists()) {\n         try {\n+          final Optional<Long> ancestorBlockNumber =\n+              commonAncestorBlockHeader.map(ProcessableBlockHeader::getNumber);\n+          if (ancestorBlockNumber.isPresent()) {\n+            // walk through the blocks from the common ancestor to the received block in order to\n+            // reload the cache in case of reorg\n+            for (long number = ancestorBlockNumber.get() + 1;\n+                number < blockHeader.getNumber();\n+                number++) {\n+              Optional<BlockHeader> ancestorBlockHeader = blockchain.getBlockHeader(number);\n+              if (ancestorBlockHeader.isPresent()) {\n+                cacheSingleBlock(ancestorBlockHeader.get(), cacheFile);\n+              }\n+            }\n+          }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "931f3c2a3c56fa489b62a0a872aa54edc412bce4"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUyNTcwMQ==", "bodyText": "Also, this isn't removing logs from the cache correctly when a reorg makes the chain shorter.  It needs to delete all cache entries between the new chain head number and the old one if the new head number is less.", "url": "https://github.com/hyperledger/besu/pull/1381#discussion_r490525701", "createdAt": "2020-09-17T19:56:31Z", "author": {"login": "ajsutton"}, "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/query/cache/TransactionLogBloomCacher.java", "diffHunk": "@@ -151,6 +156,20 @@ void cacheLogsBloomForBlockHeader(\n       final File cacheFile = reusedCacheFile.orElse(calculateCacheFileName(blockNumber, cacheDir));\n       if (cacheFile.exists()) {\n         try {\n+          final Optional<Long> ancestorBlockNumber =\n+              commonAncestorBlockHeader.map(ProcessableBlockHeader::getNumber);\n+          if (ancestorBlockNumber.isPresent()) {\n+            // walk through the blocks from the common ancestor to the received block in order to\n+            // reload the cache in case of reorg\n+            for (long number = ancestorBlockNumber.get() + 1;\n+                number < blockHeader.getNumber();\n+                number++) {\n+              Optional<BlockHeader> ancestorBlockHeader = blockchain.getBlockHeader(number);\n+              if (ancestorBlockHeader.isPresent()) {\n+                cacheSingleBlock(ancestorBlockHeader.get(), cacheFile);\n+              }\n+            }\n+          }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUyNDc1MQ=="}, "originalCommit": {"oid": "931f3c2a3c56fa489b62a0a872aa54edc412bce4"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUzNjA5MQ==", "bodyText": "Actually, if this index is only used as the initial filter, you wouldn't need to remove the later blocks when a reorg makes the chain shorter - you'd potentially check the blocks in this range when you didn't need to but it would just be treated as a false positive and sorted out once you're pulling logs out of the actual blocks.\nIn that case I think this should work.  Will deploy it and test it out.", "url": "https://github.com/hyperledger/besu/pull/1381#discussion_r490536091", "createdAt": "2020-09-17T20:16:34Z", "author": {"login": "ajsutton"}, "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/query/cache/TransactionLogBloomCacher.java", "diffHunk": "@@ -151,6 +156,20 @@ void cacheLogsBloomForBlockHeader(\n       final File cacheFile = reusedCacheFile.orElse(calculateCacheFileName(blockNumber, cacheDir));\n       if (cacheFile.exists()) {\n         try {\n+          final Optional<Long> ancestorBlockNumber =\n+              commonAncestorBlockHeader.map(ProcessableBlockHeader::getNumber);\n+          if (ancestorBlockNumber.isPresent()) {\n+            // walk through the blocks from the common ancestor to the received block in order to\n+            // reload the cache in case of reorg\n+            for (long number = ancestorBlockNumber.get() + 1;\n+                number < blockHeader.getNumber();\n+                number++) {\n+              Optional<BlockHeader> ancestorBlockHeader = blockchain.getBlockHeader(number);\n+              if (ancestorBlockHeader.isPresent()) {\n+                cacheSingleBlock(ancestorBlockHeader.get(), cacheFile);\n+              }\n+            }\n+          }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUyNDc1MQ=="}, "originalCommit": {"oid": "931f3c2a3c56fa489b62a0a872aa54edc412bce4"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDczMDA5OA==", "bodyText": "in fact in case of a shorter reorg the cache will be truncated the first time cacheSingleBlock is used.  this is why I did not add anything else here.\n\n  \n    \n      besu/ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/query/cache/TransactionLogBloomCacher.java\n    \n    \n         Line 184\n      in\n      be89cd9\n    \n    \n    \n    \n\n        \n          \n           final long validCacheSize = offset + BLOOM_BITS_LENGTH;", "url": "https://github.com/hyperledger/besu/pull/1381#discussion_r490730098", "createdAt": "2020-09-18T06:31:04Z", "author": {"login": "matkt"}, "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/query/cache/TransactionLogBloomCacher.java", "diffHunk": "@@ -151,6 +156,20 @@ void cacheLogsBloomForBlockHeader(\n       final File cacheFile = reusedCacheFile.orElse(calculateCacheFileName(blockNumber, cacheDir));\n       if (cacheFile.exists()) {\n         try {\n+          final Optional<Long> ancestorBlockNumber =\n+              commonAncestorBlockHeader.map(ProcessableBlockHeader::getNumber);\n+          if (ancestorBlockNumber.isPresent()) {\n+            // walk through the blocks from the common ancestor to the received block in order to\n+            // reload the cache in case of reorg\n+            for (long number = ancestorBlockNumber.get() + 1;\n+                number < blockHeader.getNumber();\n+                number++) {\n+              Optional<BlockHeader> ancestorBlockHeader = blockchain.getBlockHeader(number);\n+              if (ancestorBlockHeader.isPresent()) {\n+                cacheSingleBlock(ancestorBlockHeader.get(), cacheFile);\n+              }\n+            }\n+          }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUyNDc1MQ=="}, "originalCommit": {"oid": "931f3c2a3c56fa489b62a0a872aa54edc412bce4"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDczNDY1Ng==", "bodyText": "I always use ifpresent but in this case cacheSingleBlock can throw an exception and there is a catch here.  if I use ifPresent I should put 2 catch with the same implementation.  this is the main reason for using isPresent here\nhttps://github.com/matkt/besu/blob/931f3c2a3c56fa489b62a0a872aa54edc412bce4/ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/query/cache/TransactionLogBloomCacher.java#L174", "url": "https://github.com/hyperledger/besu/pull/1381#discussion_r490734656", "createdAt": "2020-09-18T06:42:53Z", "author": {"login": "matkt"}, "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/query/cache/TransactionLogBloomCacher.java", "diffHunk": "@@ -151,6 +156,20 @@ void cacheLogsBloomForBlockHeader(\n       final File cacheFile = reusedCacheFile.orElse(calculateCacheFileName(blockNumber, cacheDir));\n       if (cacheFile.exists()) {\n         try {\n+          final Optional<Long> ancestorBlockNumber =\n+              commonAncestorBlockHeader.map(ProcessableBlockHeader::getNumber);\n+          if (ancestorBlockNumber.isPresent()) {\n+            // walk through the blocks from the common ancestor to the received block in order to\n+            // reload the cache in case of reorg\n+            for (long number = ancestorBlockNumber.get() + 1;\n+                number < blockHeader.getNumber();\n+                number++) {\n+              Optional<BlockHeader> ancestorBlockHeader = blockchain.getBlockHeader(number);\n+              if (ancestorBlockHeader.isPresent()) {\n+                cacheSingleBlock(ancestorBlockHeader.get(), cacheFile);\n+              }\n+            }\n+          }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUyNDc1MQ=="}, "originalCommit": {"oid": "931f3c2a3c56fa489b62a0a872aa54edc412bce4"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 784, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}