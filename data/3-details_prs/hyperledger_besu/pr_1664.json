{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyMTAzNDg2", "number": 1664, "title": "Bonsai Tries early prototype", "bodyText": "PR description\nThis is a not-fully-functional prototype of Bonsai Tries.\nBonsai tries is a flat leaf storage, branch-by-location, and diff based reorgs\nrefactoring of the existing forest based trie storage mechanism aimed at\ncreating sustainable performance at mainnet loads.\n\nSince it is experimental a feature flag of --Xdata-storage-format=BONSAI\ncontrols activation.\n\nSome required changes have a long reach:\n\nTo accommodate location based storage many Trie operations accept both a\nlocation and hash value.  Each data storage format is keyed off of only\none of the fields, so many tests will pass in null to the other field.\nMutableWorldStateUpdater.persist now takes an argument of a block hash.\nIf this is a natural progression of blocks the hash of the new block is\npassed in.  Otherwise null should be passed in.\n\nChangelog\n\n I thought about the changelog and included a changelog update if\nrequired.", "createdAt": "2020-12-03T20:39:06Z", "url": "https://github.com/hyperledger/besu/pull/1664", "merged": true, "mergeCommit": {"oid": "5241747ba4a62e08953b9584ae03732196b69795"}, "closed": true, "closedAt": "2020-12-07T15:59:45Z", "author": {"login": "shemnon"}, "timelineItems": {"totalCount": 73, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdNd3bBAH2gAyNTMyMTAzNDg2OmE5MDYxMWIxZGJmYzNkODNiZjZlNDU5MTNlYmQ1NTBmYjc0YzdkN2Y=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdjQZNWAFqTU0NTYxMTc0OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a90611b1dbfc3d83bf6e45913ebd550fb74c7d7f", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/a90611b1dbfc3d83bf6e45913ebd550fb74c7d7f", "committedDate": "2020-09-29T01:26:02Z", "message": "Change Native AltBN library\n\nUse the MatterLabs AltBN library.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78a63f160a79fdcdee64b96042de55cbd61244fe", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/78a63f160a79fdcdee64b96042de55cbd61244fe", "committedDate": "2020-09-29T23:33:27Z", "message": "checkpoint - up to SLOAD on Goerli\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "931ad4e0f6fc654f38f032100ae8fc93870feedf", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/931ad4e0f6fc654f38f032100ae8fc93870feedf", "committedDate": "2020-09-29T23:33:27Z", "message": "write stuff to disk\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "900e0794ee19ff4dbdb1e99eac8c2a67d3e97cb3", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/900e0794ee19ff4dbdb1e99eac8c2a67d3e97cb3", "committedDate": "2020-09-29T23:33:27Z", "message": "works up until a TX reverts\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2663065a3005f9ee86c340ef18c377c09ff3445", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/e2663065a3005f9ee86c340ef18c377c09ff3445", "committedDate": "2020-09-29T23:33:27Z", "message": "Refactors:\n\n* Move UpdateTracingAccount to package level\n* Rename DefaultEvmAccount to WrappedEvmAccount\n* Change some method signatures to use ? extends Account\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e6ad5de4cd3e25a3f625b1d5602ce3caaa264f5", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/6e6ad5de4cd3e25a3f625b1d5602ce3caaa264f5", "committedDate": "2020-09-29T23:33:28Z", "message": "BonsaiUpdater uses stacked updater and abstract updater\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc5fe7cb07fc99cdcbbba4e7c822cc5dea26d78c", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/cc5fe7cb07fc99cdcbbba4e7c822cc5dea26d78c", "committedDate": "2020-09-29T23:33:44Z", "message": "non-threaded block import\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3b0d48fb307af5aa633492768f9bb55c3c67199", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/d3b0d48fb307af5aa633492768f9bb55c3c67199", "committedDate": "2020-09-29T23:34:36Z", "message": "works up to requireing storage clearing.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6de579673ec94fa95a4393df97c5ada05057e202", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/6de579673ec94fa95a4393df97c5ada05057e202", "committedDate": "2020-09-29T23:34:39Z", "message": "proper account clearing\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6927d6be7a123ec7d1d1644bdffac2c3b3c31c9a", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/6927d6be7a123ec7d1d1644bdffac2c3b3c31c9a", "committedDate": "2020-09-29T23:34:39Z", "message": "goerli syncs leaf piles\n\n* fix last sstore original value issues\n* manicure trie\n* reformat\n* remove logging\n* fix broken tests\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eaab141b665fec06ef7471ce79bfd28d607572ea", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/eaab141b665fec06ef7471ce79bfd28d607572ea", "committedDate": "2020-09-29T23:39:39Z", "message": "follow standard experimental flags rules\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c5185eb3cb939a7c708ffd4cf6f1c96b9fa3a3f", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/8c5185eb3cb939a7c708ffd4cf6f1c96b9fa3a3f", "committedDate": "2020-10-01T22:49:38Z", "message": "EIP-2999\n\nUpdate costs to 2999\nUpdate benchmark\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bd5ea9d3260a11ee18b6317046b47c20cbf14b3", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/8bd5ea9d3260a11ee18b6317046b47c20cbf14b3", "committedDate": "2020-10-02T14:28:24Z", "message": "update g2add vector.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8063cf8829224f7084d9ff5485d424883569b2a", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/a8063cf8829224f7084d9ff5485d424883569b2a", "committedDate": "2020-10-02T15:15:50Z", "message": "use library's input padding.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38072c77bde7c4b1e591cbe413a48e10a188a380", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/38072c77bde7c4b1e591cbe413a48e10a188a380", "committedDate": "2020-10-02T19:30:09Z", "message": "modexp bench and repricing\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d813f2e02d5ff4623da8579749215573e003058e", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/d813f2e02d5ff4623da8579749215573e003058e", "committedDate": "2020-10-05T19:42:38Z", "message": "Merge branch 'master' into bonsai\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>\n\n# Conflicts:\n#\tbesu/src/main/java/org/hyperledger/besu/controller/BesuControllerBuilder.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/core/AbstractWorldUpdater.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5443698ff922cb7ef11da11f27466d1bef4b4b2a", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/5443698ff922cb7ef11da11f27466d1bef4b4b2a", "committedDate": "2020-10-05T20:07:27Z", "message": "cleanup\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab3fd49e7105d4ee13a23677ce7a5185e89c9efc", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/ab3fd49e7105d4ee13a23677ce7a5185e89c9efc", "committedDate": "2020-10-07T14:44:47Z", "message": "trie log writes\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd3011c1bd8493f8e21b37401081ccc6a349c4ca", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/cd3011c1bd8493f8e21b37401081ccc6a349c4ca", "committedDate": "2020-10-09T21:38:09Z", "message": "use bonsaivalue for account changes instead of toUpdate/toDelete\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e9fb7ddcd172ad4af5567d8b759dcf93dfdf3dc", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/8e9fb7ddcd172ad4af5567d8b759dcf93dfdf3dc", "committedDate": "2020-10-12T22:44:39Z", "message": "factor out rolling writers\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41c3ec6e59ecdcd9c6361c7d6c99b86317812b6b", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/41c3ec6e59ecdcd9c6361c7d6c99b86317812b6b", "committedDate": "2020-10-12T22:45:06Z", "message": "rollforward simple one and stacked\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec94d735c85c81993450063e5c7f8e7034e902b5", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/ec94d735c85c81993450063e5c7f8e7034e902b5", "committedDate": "2020-10-15T14:45:04Z", "message": "account trie didn't commit.  fix that.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "789a030e3aa0ebab401a48f63a9e49c6ce3897d6", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/789a030e3aa0ebab401a48f63a9e49c6ce3897d6", "committedDate": "2020-10-15T20:44:50Z", "message": "just an order issue\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5d129c854e713a142b68bd1017cc0b44019b5bf", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/a5d129c854e713a142b68bd1017cc0b44019b5bf", "committedDate": "2020-10-16T02:44:42Z", "message": "cleanup\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a9d8fa162eaef8b0a3862a1d7c40225f518ad7a", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/1a9d8fa162eaef8b0a3862a1d7c40225f518ad7a", "committedDate": "2020-10-16T02:44:59Z", "message": "Merge branch 'master' of github.com:hyperledger/besu into bonsai\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "daebbcab63e96836ad5cd48833cd0c521c213e3f", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/daebbcab63e96836ad5cd48833cd0c521c213e3f", "committedDate": "2020-10-16T05:22:39Z", "message": "formatting fixes and errorprone\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebb840755a120c80f8fa9946f7c8e54dce38c521", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/ebb840755a120c80f8fa9946f7c8e54dce38c521", "committedDate": "2020-10-16T15:15:30Z", "message": "rollback was easy.  Still need to fix trie log to block hash plumbing.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a967b4707e5521d4c311e5db4467256b49a20502", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/a967b4707e5521d4c311e5db4467256b49a20502", "committedDate": "2020-10-16T18:36:23Z", "message": "fix table flub\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a4f9202462facb2f1da301e50de64ae12c1597b", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/5a4f9202462facb2f1da301e50de64ae12c1597b", "committedDate": "2020-10-16T23:24:03Z", "message": "persist by blokc hash\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59f0cb8f05b27f6e235110e871b9dbb0747bbf6a", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/59f0cb8f05b27f6e235110e871b9dbb0747bbf6a", "committedDate": "2020-10-21T05:51:39Z", "message": "goerli roll-forward to 1M blocks\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb5d110c1a9ecf2efbc6313fca653e439614d756", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/fb5d110c1a9ecf2efbc6313fca653e439614d756", "committedDate": "2020-10-22T01:22:38Z", "message": "full roll of 3.5MM of bonsai\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8166ee4fe806d873453e3192f34431f5a88ae766", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/8166ee4fe806d873453e3192f34431f5a88ae766", "committedDate": "2020-10-22T15:58:37Z", "message": "add mgps stats\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bae33cef7e088fdfcd501db65aa0ed940bfae1bf", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/bae33cef7e088fdfcd501db65aa0ed940bfae1bf", "committedDate": "2020-10-23T05:59:48Z", "message": "restore threaded block importer\n\nfix build errors.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85cbbf8790136e8620cc5a5d0a7ab625624334ed", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/85cbbf8790136e8620cc5a5d0a7ab625624334ed", "committedDate": "2020-10-23T15:34:26Z", "message": "Merge branch 'master' of github.com:hyperledger/besu into bonsai\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95ad665e7cfe0a339755de1873332ca340f9de95", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/95ad665e7cfe0a339755de1873332ca340f9de95", "committedDate": "2020-10-23T21:36:14Z", "message": "spotless and one benchmark\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36ee810f5281b59ca60ef4c4395d62384d937169", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/36ee810f5281b59ca60ef4c4395d62384d937169", "committedDate": "2020-10-23T21:39:04Z", "message": "Merge branch 'master' of github.com:hyperledger/besu into matterLabsAltBN\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2dc7b4f51aa920ab68d9ca30254307cb6e4d0e1b", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/2dc7b4f51aa920ab68d9ca30254307cb6e4d0e1b", "committedDate": "2020-10-23T21:47:33Z", "message": "Merge branch 'matterLabsAltBN' of github.com:shemnon/besu into bonsai\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "652b1d4caa5ecec91e483f52e975262f210d5828", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/652b1d4caa5ecec91e483f52e975262f210d5828", "committedDate": "2020-10-29T22:13:45Z", "message": "no really, write the layer file\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "372da84a402cf3f5c4702a34a9b636c06eea2547", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/372da84a402cf3f5c4702a34a9b636c06eea2547", "committedDate": "2020-11-03T04:24:01Z", "message": "merge\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d31fbf14814aa894d4494b38af2e9fa86e8ece4", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/9d31fbf14814aa894d4494b38af2e9fa86e8ece4", "committedDate": "2020-11-03T20:49:46Z", "message": "add location to nodeloader and nodeupdater\n\nAdd the trie location as args to NodeLoader and NodeUpdater.  Tried to\nmake sensible changes to all the tendrils but likely this will have far\nreaching impacts.  Tests _currently_ pass.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7323aa4c75906d8b330339bec0a453d0696bb988", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/7323aa4c75906d8b330339bec0a453d0696bb988", "committedDate": "2020-11-09T22:15:48Z", "message": "merge\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad6a4648a9b57c17b5f7f2fd60b6ca670e25a506", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/ad6a4648a9b57c17b5f7f2fd60b6ca670e25a506", "committedDate": "2020-11-09T22:42:20Z", "message": "by location storage\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a51b98320b5edc87d51c3743bdb9a969b0b89f4c", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/a51b98320b5edc87d51c3743bdb9a969b0b89f4c", "committedDate": "2020-11-09T23:12:53Z", "message": "cleanup\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a794af8b17c66904391f7fc264f7d5960590cb5", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/7a794af8b17c66904391f7fc264f7d5960590cb5", "committedDate": "2020-11-09T23:42:17Z", "message": "fix forest fast sync\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2651166106ea383fc08fda03dc84d1698224e506", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/2651166106ea383fc08fda03dc84d1698224e506", "committedDate": "2020-11-10T19:44:12Z", "message": "speling and other cleanup\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46bdc4267210158483e4f7819ef45fa2d5c53373", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/46bdc4267210158483e4f7819ef45fa2d5c53373", "committedDate": "2020-11-10T20:44:25Z", "message": "cleanup\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfbfd8068b7151c72a24f966f943b269814565e3", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/cfbfd8068b7151c72a24f966f943b269814565e3", "committedDate": "2020-11-10T23:19:54Z", "message": "logging formatting\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07893e870b4ad47803029bfd1cbb63a46b4e3107", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/07893e870b4ad47803029bfd1cbb63a46b4e3107", "committedDate": "2020-11-11T00:16:54Z", "message": "one more place for duration.  Up to 1 sec/block\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc32a55c00fb773063d8d73c7e3807b30dbf430b", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/bc32a55c00fb773063d8d73c7e3807b30dbf430b", "committedDate": "2020-11-11T01:44:55Z", "message": "one more place for gas, 12.5MMx1K = 12.5B\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40dda02915492b3d80df9576d136823b2e8d0ca6", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/40dda02915492b3d80df9576d136823b2e8d0ca6", "committedDate": "2020-11-24T22:49:37Z", "message": "split out mutable state into BonsaiWorldStateUpdater and DB access into\nBonsaiPersistedWorldState\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8f7c7a5c4c4d83d9e444d763eb44033ca61cbd4", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/e8f7c7a5c4c4d83d9e444d763eb44033ca61cbd4", "committedDate": "2020-11-25T07:28:19Z", "message": "merge\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb628222ae814f36737786457745d6e9c825284f", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/cb628222ae814f36737786457745d6e9c825284f", "committedDate": "2020-11-25T15:58:03Z", "message": "unneeded change\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf9acaeaa127a0c1f7aa6b5b87862f31028dc3f5", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/cf9acaeaa127a0c1f7aa6b5b87862f31028dc3f5", "committedDate": "2020-11-25T16:50:31Z", "message": "javadoc\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1765a29aacd48a4dbd84e7c16c680b1857810fdf", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/1765a29aacd48a4dbd84e7c16c680b1857810fdf", "committedDate": "2020-11-28T03:32:40Z", "message": "Merge branch 'master' of github.com:hyperledger/besu into bonsai\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19bce4a437441342f7d49219b0f0338ab8218e44", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/19bce4a437441342f7d49219b0f0338ab8218e44", "committedDate": "2020-11-30T18:35:23Z", "message": "Merge branch 'master' of github.com:hyperledger/besu into bonsai\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b8015b97eb05b7882893a12b68a1f24e98c2af0", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/8b8015b97eb05b7882893a12b68a1f24e98c2af0", "committedDate": "2020-12-01T15:25:42Z", "message": "merge\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56fa83e1cbcd2a86bacbe87357e39d364c4f83c2", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/56fa83e1cbcd2a86bacbe87357e39d364c4f83c2", "committedDate": "2020-12-01T23:22:32Z", "message": "run form layered data\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abfc47f27a822e64fd85b02369c245de4db96ecd", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/abfc47f27a822e64fd85b02369c245de4db96ecd", "committedDate": "2020-12-02T22:46:23Z", "message": "merge\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "508457808b61bd40b9c83b3d46a1a259f954962a", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/508457808b61bd40b9c83b3d46a1a259f954962a", "committedDate": "2020-12-03T06:41:22Z", "message": "deletes were not getting rolled forward\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c43ec5a44488483e38d8ce205db65c239dff7634", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/c43ec5a44488483e38d8ce205db65c239dff7634", "committedDate": "2020-12-03T06:41:51Z", "message": "Merge branch 'master' of github.com:hyperledger/besu into bonsai\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f00806d75c18c3d48043c3dbf7e1ebecdc25ec3d", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/f00806d75c18c3d48043c3dbf7e1ebecdc25ec3d", "committedDate": "2020-12-03T20:22:00Z", "message": "merge cleanup\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbbc1465c97b96dfc23e9e72d80c64fe40bffaf4", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/dbbc1465c97b96dfc23e9e72d80c64fe40bffaf4", "committedDate": "2020-12-03T20:25:56Z", "message": "missed a FIXME\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd172d3bfc76ff65ff2067b3023fa2e9877d4d04", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/bd172d3bfc76ff65ff2067b3023fa2e9877d4d04", "committedDate": "2020-12-03T20:28:42Z", "message": "more FIXMEs\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59fc091f99c97138ebea7d85508338acbff836dc", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/59fc091f99c97138ebea7d85508338acbff836dc", "committedDate": "2020-12-03T20:54:16Z", "message": "spotless\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ce1bf43aa2de39044b0a277b603e9caabd35408", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/9ce1bf43aa2de39044b0a277b603e9caabd35408", "committedDate": "2020-12-03T21:16:52Z", "message": "fix two exception messages and the plugin API hash\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NTAyNTMw", "url": "https://github.com/hyperledger/besu/pull/1664#pullrequestreview-544502530", "createdAt": "2020-12-03T22:23:14Z", "commit": {"oid": "9ce1bf43aa2de39044b0a277b603e9caabd35408"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMjoyMzoxNFrOH-3wGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMjoyMzoxNFrOH-3wGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY4NzE5NA==", "bodyText": "\ud83e\udd23", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r535687194", "createdAt": "2020-12-03T22:23:14Z", "author": {"login": "timbeiko"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiAccount.java", "diffHunk": "@@ -251,7 +251,7 @@ public UInt256 getOriginalStorageValue(final UInt256 key) {\n   @Override\n   public NavigableMap<Bytes32, AccountStorageEntry> storageEntriesFrom(\n       final Bytes32 startKeyHash, final int limit) {\n-    throw new RuntimeException(\"LOL no\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ce1bf43aa2de39044b0a277b603e9caabd35408"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/a9bd8d5200aae80bd1b6643b996130975eafb94d", "committedDate": "2020-12-03T22:34:25Z", "message": "semmle fixes\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0OTIxMTg1", "url": "https://github.com/hyperledger/besu/pull/1664#pullrequestreview-544921185", "createdAt": "2020-12-04T12:36:34Z", "commit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMjozNjozNFrOH_PEKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMzozNToxOFrOH_RJfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA2OTE2MQ==", "bodyText": "Does this byte32 with SuppressWarnings unused is important ? For future use ?", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536069161", "createdAt": "2020-12-04T12:36:34Z", "author": {"login": "matkt"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static org.hyperledger.besu.ethereum.bonsai.BonsaiAccount.fromRLP;\n+\n+import org.hyperledger.besu.ethereum.core.Account;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.MerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorageTransaction;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import javax.annotation.Nonnull;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiPersistedWorldState implements MutableWorldState, BonsaiWorldState {\n+\n+  private static final byte[] WORLD_ROOT_KEY = \"worldRoot\".getBytes(StandardCharsets.UTF_8);\n+\n+  private final KeyValueStorage accountStorage;\n+  private final KeyValueStorage codeStorage;\n+  private final KeyValueStorage storageStorage;\n+  private final KeyValueStorage trieBranchStorage;\n+  private final KeyValueStorage trieLogStorage;\n+\n+  private Bytes32 worldStateRootHash;\n+\n+  private final BonsaiWorldStateArchive archive;\n+  private BonsaiWorldStateUpdater updater;\n+\n+  public BonsaiPersistedWorldState(\n+      final BonsaiWorldStateArchive archive,\n+      final KeyValueStorage accountStorage,\n+      final KeyValueStorage codeStorage,\n+      final KeyValueStorage storageStorage,\n+      final KeyValueStorage trieBranchStorage,\n+      final KeyValueStorage trieLogStorage) {\n+    this.archive = archive;\n+    this.accountStorage = accountStorage;\n+    this.codeStorage = codeStorage;\n+    this.storageStorage = storageStorage;\n+    this.trieBranchStorage = trieBranchStorage;\n+    this.trieLogStorage = trieLogStorage;\n+    worldStateRootHash =\n+        Bytes32.wrap(\n+            trieBranchStorage.get(WORLD_ROOT_KEY).map(Bytes::wrap).orElse(Hash.EMPTY_TRIE_HASH));\n+  }\n+\n+  public BonsaiWorldStateArchive getArchive() {\n+    return archive;\n+  }\n+\n+  @Override\n+  public MutableWorldState copy() {\n+    throw new UnsupportedOperationException(\n+        \"Bonsai Tries does not support direct duplication of the persisted tries.\");\n+  }\n+\n+  @Override\n+  public Bytes getCode(@Nonnull final Address address) {\n+    return codeStorage.get(address.toArrayUnsafe()).map(Bytes::wrap).orElse(Bytes.EMPTY);\n+  }\n+\n+  @Override\n+  public void persist(final Hash blockHash) {\n+    boolean success = false;\n+    final KeyValueStorageTransaction accountTx = accountStorage.startTransaction();\n+    final KeyValueStorageTransaction codeTx = codeStorage.startTransaction();\n+    final KeyValueStorageTransaction storageTx = storageStorage.startTransaction();\n+    final KeyValueStorageTransaction trieBranchTx = trieBranchStorage.startTransaction();\n+    final KeyValueStorageTransaction trieLogTx = trieLogStorage.startTransaction();\n+\n+    try {\n+      // first clear storage\n+      for (final Address address : updater.getStorageToClear()) {\n+        // because we are clearing persisted values we need the account root as persisted\n+        final BonsaiAccount oldAccount =\n+            accountStorage\n+                .get(address.toArrayUnsafe())\n+                .map(\n+                    bytes ->\n+                        fromRLP(BonsaiPersistedWorldState.this, address, Bytes.wrap(bytes), true))\n+                .orElse(null);\n+        if (oldAccount == null) {\n+          // This is when an account is both created and deleted within the scope of the same\n+          // block.  A not-uncommon DeFi bot pattern.\n+          continue;\n+        }\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(address, location, key),\n+                oldAccount.getStorageRoot(),\n+                Function.identity(),\n+                Function.identity());\n+        Map<Bytes32, Bytes> entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+        while (!entriesToDelete.isEmpty()) {\n+          entriesToDelete\n+              .keySet()\n+              .forEach(k -> storageTx.remove(Bytes.concatenate(address, k).toArrayUnsafe()));\n+          if (entriesToDelete.size() == 256) {\n+            entriesToDelete.keySet().forEach(storageTrie::remove);\n+            entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+          } else {\n+            break;\n+          }\n+        }\n+      }\n+\n+      // second update account storage state.  This must be done before updating the accounts so\n+      // that we can get the storage state hash\n+      for (final Map.Entry<Address, Map<Hash, BonsaiValue<UInt256>>> storageAccountUpdate :\n+          updater.getStorageToUpdate().entrySet()) {\n+        final Address updatedAddress = storageAccountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> accountValue =\n+            updater.getAccountsToUpdate().get(updatedAddress);\n+        final BonsaiAccount accountOriginal = accountValue.getOriginal();\n+        final Hash storageRoot =\n+            (accountOriginal == null) ? Hash.EMPTY_TRIE_HASH : accountOriginal.getStorageRoot();\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(updatedAddress, location, key),\n+                storageRoot,\n+                Function.identity(),\n+                Function.identity());\n+\n+        // for manicured tries and composting, collect branches here (not implemented)\n+\n+        for (final Map.Entry<Hash, BonsaiValue<UInt256>> storageUpdate :\n+            storageAccountUpdate.getValue().entrySet()) {\n+          final Hash keyHash = storageUpdate.getKey();\n+          final byte[] writeAddress = Bytes.concatenate(updatedAddress, keyHash).toArrayUnsafe();\n+          final UInt256 updatedStorage = storageUpdate.getValue().getUpdated();\n+          if (updatedStorage == null || updatedStorage.equals(UInt256.ZERO)) {\n+            storageTx.remove(writeAddress);\n+            storageTrie.remove(keyHash);\n+          } else {\n+            final Bytes32 updatedStorageBytes = updatedStorage.toBytes();\n+            storageTx.put(writeAddress, updatedStorageBytes.toArrayUnsafe());\n+            storageTrie.put(keyHash, rlpEncode(updatedStorageBytes));\n+          }\n+        }\n+\n+        final BonsaiAccount accountUpdated = accountValue.getUpdated();\n+        if (accountUpdated != null) {\n+          storageTrie.commit(\n+              (location, key, value) ->\n+                  writeStorageTrieNode(trieBranchTx, updatedAddress, location, key, value));\n+          final Hash newStorageRoot = Hash.wrap(storageTrie.getRootHash());\n+          accountUpdated.setStorageRoot(newStorageRoot);\n+        }\n+        // for manicured tries and composting, trim and compost here\n+      }\n+\n+      // Third update the code.  This has the side effect of ensuring a code hash is calculated.\n+      for (final Map.Entry<Address, BonsaiValue<Bytes>> codeUpdate :\n+          updater.getCodeToUpdate().entrySet()) {\n+        final Bytes updatedCode = codeUpdate.getValue().getUpdated();\n+        if (updatedCode == null || updatedCode.size() == 0) {\n+          codeTx.remove(codeUpdate.getKey().toArrayUnsafe());\n+        } else {\n+          codeTx.put(codeUpdate.getKey().toArrayUnsafe(), updatedCode.toArrayUnsafe());\n+        }\n+      }\n+\n+      // next collect the branches that will be trimmed\n+      final StoredMerklePatriciaTrie<Bytes, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              this::getTrieNode, worldStateRootHash, Function.identity(), Function.identity());\n+\n+      // for manicured tries and composting, collect branches here (not implemented)\n+\n+      // now add the accounts\n+      for (final Map.Entry<Address, BonsaiValue<BonsaiAccount>> accountUpdate :\n+          updater.getAccountsToUpdate().entrySet()) {\n+        final Bytes accountKey = accountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> bonsaiValue = accountUpdate.getValue();\n+        final BonsaiAccount updatedAccount = bonsaiValue.getUpdated();\n+        if (updatedAccount == null) {\n+          final Hash addressHash = Hash.hash(accountKey);\n+          accountTrie.remove(addressHash);\n+          accountTx.remove(accountKey.toArrayUnsafe());\n+        } else {\n+          final Hash addressHash = updatedAccount.getAddressHash();\n+          final Bytes accountValue = updatedAccount.serializeAccount();\n+          accountTx.put(accountKey.toArrayUnsafe(), accountValue.toArrayUnsafe());\n+          accountTrie.put(addressHash, accountValue);\n+        }\n+      }\n+\n+      accountTrie.commit(\n+          (location, hash, value) -> writeTrieNode(trieBranchTx, location, hash, value));\n+      worldStateRootHash = accountTrie.getRootHash();\n+      trieBranchTx.put(WORLD_ROOT_KEY, worldStateRootHash.toArrayUnsafe());\n+\n+      // for manicured tries and composting, trim and compost branches here\n+\n+      if (blockHash != null) {\n+        final TrieLogLayer trieLog = updater.generateTrieLog(blockHash);\n+        trieLog.freeze();\n+        // TODO add to archive here, but only once we get persisted follow distance implemented\n+        // archive.addLayeredWorldState(new BonsaiLayeredWorldState(this, trieLog));\n+\n+        final BytesValueRLPOutput rlpLog = new BytesValueRLPOutput();\n+        trieLog.writeTo(rlpLog);\n+        trieLogTx.put(blockHash.toArrayUnsafe(), rlpLog.encoded().toArrayUnsafe());\n+      }\n+\n+      success = true;\n+    } finally {\n+      if (success) {\n+        accountTx.commit();\n+        codeTx.commit();\n+        storageTx.commit();\n+        trieBranchTx.commit();\n+        trieLogTx.commit();\n+        updater.reset();\n+      } else {\n+        accountTx.rollback();\n+        codeTx.rollback();\n+        storageTx.rollback();\n+        trieBranchTx.rollback();\n+        trieLogTx.rollback();\n+      }\n+    }\n+  }\n+\n+  private static Bytes rlpEncode(final Bytes bytes) {\n+    final BytesValueRLPOutput out = new BytesValueRLPOutput();\n+    out.writeBytes(bytes.trimLeadingZeros());\n+    return out.encoded();\n+  }\n+\n+  @Override\n+  public WorldUpdater updater() {\n+    if (updater == null) {\n+      updater = new BonsaiWorldStateUpdater(this);\n+    }\n+    return updater;\n+  }\n+\n+  @Override\n+  public Hash rootHash() {\n+    return Hash.wrap(worldStateRootHash);\n+  }\n+\n+  @Override\n+  public Stream<StreamableAccount> streamAccounts(final Bytes32 startKeyHash, final int limit) {\n+    throw new RuntimeException(\"NIY\");\n+  }\n+\n+  @Override\n+  public Account get(final Address address) {\n+    return accountStorage\n+        .get(address.toArrayUnsafe())\n+        .map(bytes -> fromRLP(updater, address, Bytes.wrap(bytes), true))\n+        .orElse(null);\n+  }\n+\n+  private Optional<Bytes> getTrieNode(final Bytes location, final Bytes32 nodeHash) {\n+    if (nodeHash.equals(MerklePatriciaTrie.EMPTY_TRIE_NODE_HASH)) {\n+      return Optional.of(MerklePatriciaTrie.EMPTY_TRIE_NODE);\n+    } else {\n+      return trieBranchStorage.get(location.toArrayUnsafe()).map(Bytes::wrap);\n+    }\n+  }\n+\n+  private void writeTrieNode(\n+      final KeyValueStorageTransaction tx,\n+      final Bytes location,\n+      @SuppressWarnings(\"unused\") final Bytes32 nodeHash,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA2OTIxMw==", "bodyText": "Does this byte32 with SuppressWarnings unused is important ? For future use ?", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536069213", "createdAt": "2020-12-04T12:36:40Z", "author": {"login": "matkt"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static org.hyperledger.besu.ethereum.bonsai.BonsaiAccount.fromRLP;\n+\n+import org.hyperledger.besu.ethereum.core.Account;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.MerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorageTransaction;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import javax.annotation.Nonnull;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiPersistedWorldState implements MutableWorldState, BonsaiWorldState {\n+\n+  private static final byte[] WORLD_ROOT_KEY = \"worldRoot\".getBytes(StandardCharsets.UTF_8);\n+\n+  private final KeyValueStorage accountStorage;\n+  private final KeyValueStorage codeStorage;\n+  private final KeyValueStorage storageStorage;\n+  private final KeyValueStorage trieBranchStorage;\n+  private final KeyValueStorage trieLogStorage;\n+\n+  private Bytes32 worldStateRootHash;\n+\n+  private final BonsaiWorldStateArchive archive;\n+  private BonsaiWorldStateUpdater updater;\n+\n+  public BonsaiPersistedWorldState(\n+      final BonsaiWorldStateArchive archive,\n+      final KeyValueStorage accountStorage,\n+      final KeyValueStorage codeStorage,\n+      final KeyValueStorage storageStorage,\n+      final KeyValueStorage trieBranchStorage,\n+      final KeyValueStorage trieLogStorage) {\n+    this.archive = archive;\n+    this.accountStorage = accountStorage;\n+    this.codeStorage = codeStorage;\n+    this.storageStorage = storageStorage;\n+    this.trieBranchStorage = trieBranchStorage;\n+    this.trieLogStorage = trieLogStorage;\n+    worldStateRootHash =\n+        Bytes32.wrap(\n+            trieBranchStorage.get(WORLD_ROOT_KEY).map(Bytes::wrap).orElse(Hash.EMPTY_TRIE_HASH));\n+  }\n+\n+  public BonsaiWorldStateArchive getArchive() {\n+    return archive;\n+  }\n+\n+  @Override\n+  public MutableWorldState copy() {\n+    throw new UnsupportedOperationException(\n+        \"Bonsai Tries does not support direct duplication of the persisted tries.\");\n+  }\n+\n+  @Override\n+  public Bytes getCode(@Nonnull final Address address) {\n+    return codeStorage.get(address.toArrayUnsafe()).map(Bytes::wrap).orElse(Bytes.EMPTY);\n+  }\n+\n+  @Override\n+  public void persist(final Hash blockHash) {\n+    boolean success = false;\n+    final KeyValueStorageTransaction accountTx = accountStorage.startTransaction();\n+    final KeyValueStorageTransaction codeTx = codeStorage.startTransaction();\n+    final KeyValueStorageTransaction storageTx = storageStorage.startTransaction();\n+    final KeyValueStorageTransaction trieBranchTx = trieBranchStorage.startTransaction();\n+    final KeyValueStorageTransaction trieLogTx = trieLogStorage.startTransaction();\n+\n+    try {\n+      // first clear storage\n+      for (final Address address : updater.getStorageToClear()) {\n+        // because we are clearing persisted values we need the account root as persisted\n+        final BonsaiAccount oldAccount =\n+            accountStorage\n+                .get(address.toArrayUnsafe())\n+                .map(\n+                    bytes ->\n+                        fromRLP(BonsaiPersistedWorldState.this, address, Bytes.wrap(bytes), true))\n+                .orElse(null);\n+        if (oldAccount == null) {\n+          // This is when an account is both created and deleted within the scope of the same\n+          // block.  A not-uncommon DeFi bot pattern.\n+          continue;\n+        }\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(address, location, key),\n+                oldAccount.getStorageRoot(),\n+                Function.identity(),\n+                Function.identity());\n+        Map<Bytes32, Bytes> entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+        while (!entriesToDelete.isEmpty()) {\n+          entriesToDelete\n+              .keySet()\n+              .forEach(k -> storageTx.remove(Bytes.concatenate(address, k).toArrayUnsafe()));\n+          if (entriesToDelete.size() == 256) {\n+            entriesToDelete.keySet().forEach(storageTrie::remove);\n+            entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+          } else {\n+            break;\n+          }\n+        }\n+      }\n+\n+      // second update account storage state.  This must be done before updating the accounts so\n+      // that we can get the storage state hash\n+      for (final Map.Entry<Address, Map<Hash, BonsaiValue<UInt256>>> storageAccountUpdate :\n+          updater.getStorageToUpdate().entrySet()) {\n+        final Address updatedAddress = storageAccountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> accountValue =\n+            updater.getAccountsToUpdate().get(updatedAddress);\n+        final BonsaiAccount accountOriginal = accountValue.getOriginal();\n+        final Hash storageRoot =\n+            (accountOriginal == null) ? Hash.EMPTY_TRIE_HASH : accountOriginal.getStorageRoot();\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(updatedAddress, location, key),\n+                storageRoot,\n+                Function.identity(),\n+                Function.identity());\n+\n+        // for manicured tries and composting, collect branches here (not implemented)\n+\n+        for (final Map.Entry<Hash, BonsaiValue<UInt256>> storageUpdate :\n+            storageAccountUpdate.getValue().entrySet()) {\n+          final Hash keyHash = storageUpdate.getKey();\n+          final byte[] writeAddress = Bytes.concatenate(updatedAddress, keyHash).toArrayUnsafe();\n+          final UInt256 updatedStorage = storageUpdate.getValue().getUpdated();\n+          if (updatedStorage == null || updatedStorage.equals(UInt256.ZERO)) {\n+            storageTx.remove(writeAddress);\n+            storageTrie.remove(keyHash);\n+          } else {\n+            final Bytes32 updatedStorageBytes = updatedStorage.toBytes();\n+            storageTx.put(writeAddress, updatedStorageBytes.toArrayUnsafe());\n+            storageTrie.put(keyHash, rlpEncode(updatedStorageBytes));\n+          }\n+        }\n+\n+        final BonsaiAccount accountUpdated = accountValue.getUpdated();\n+        if (accountUpdated != null) {\n+          storageTrie.commit(\n+              (location, key, value) ->\n+                  writeStorageTrieNode(trieBranchTx, updatedAddress, location, key, value));\n+          final Hash newStorageRoot = Hash.wrap(storageTrie.getRootHash());\n+          accountUpdated.setStorageRoot(newStorageRoot);\n+        }\n+        // for manicured tries and composting, trim and compost here\n+      }\n+\n+      // Third update the code.  This has the side effect of ensuring a code hash is calculated.\n+      for (final Map.Entry<Address, BonsaiValue<Bytes>> codeUpdate :\n+          updater.getCodeToUpdate().entrySet()) {\n+        final Bytes updatedCode = codeUpdate.getValue().getUpdated();\n+        if (updatedCode == null || updatedCode.size() == 0) {\n+          codeTx.remove(codeUpdate.getKey().toArrayUnsafe());\n+        } else {\n+          codeTx.put(codeUpdate.getKey().toArrayUnsafe(), updatedCode.toArrayUnsafe());\n+        }\n+      }\n+\n+      // next collect the branches that will be trimmed\n+      final StoredMerklePatriciaTrie<Bytes, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              this::getTrieNode, worldStateRootHash, Function.identity(), Function.identity());\n+\n+      // for manicured tries and composting, collect branches here (not implemented)\n+\n+      // now add the accounts\n+      for (final Map.Entry<Address, BonsaiValue<BonsaiAccount>> accountUpdate :\n+          updater.getAccountsToUpdate().entrySet()) {\n+        final Bytes accountKey = accountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> bonsaiValue = accountUpdate.getValue();\n+        final BonsaiAccount updatedAccount = bonsaiValue.getUpdated();\n+        if (updatedAccount == null) {\n+          final Hash addressHash = Hash.hash(accountKey);\n+          accountTrie.remove(addressHash);\n+          accountTx.remove(accountKey.toArrayUnsafe());\n+        } else {\n+          final Hash addressHash = updatedAccount.getAddressHash();\n+          final Bytes accountValue = updatedAccount.serializeAccount();\n+          accountTx.put(accountKey.toArrayUnsafe(), accountValue.toArrayUnsafe());\n+          accountTrie.put(addressHash, accountValue);\n+        }\n+      }\n+\n+      accountTrie.commit(\n+          (location, hash, value) -> writeTrieNode(trieBranchTx, location, hash, value));\n+      worldStateRootHash = accountTrie.getRootHash();\n+      trieBranchTx.put(WORLD_ROOT_KEY, worldStateRootHash.toArrayUnsafe());\n+\n+      // for manicured tries and composting, trim and compost branches here\n+\n+      if (blockHash != null) {\n+        final TrieLogLayer trieLog = updater.generateTrieLog(blockHash);\n+        trieLog.freeze();\n+        // TODO add to archive here, but only once we get persisted follow distance implemented\n+        // archive.addLayeredWorldState(new BonsaiLayeredWorldState(this, trieLog));\n+\n+        final BytesValueRLPOutput rlpLog = new BytesValueRLPOutput();\n+        trieLog.writeTo(rlpLog);\n+        trieLogTx.put(blockHash.toArrayUnsafe(), rlpLog.encoded().toArrayUnsafe());\n+      }\n+\n+      success = true;\n+    } finally {\n+      if (success) {\n+        accountTx.commit();\n+        codeTx.commit();\n+        storageTx.commit();\n+        trieBranchTx.commit();\n+        trieLogTx.commit();\n+        updater.reset();\n+      } else {\n+        accountTx.rollback();\n+        codeTx.rollback();\n+        storageTx.rollback();\n+        trieBranchTx.rollback();\n+        trieLogTx.rollback();\n+      }\n+    }\n+  }\n+\n+  private static Bytes rlpEncode(final Bytes bytes) {\n+    final BytesValueRLPOutput out = new BytesValueRLPOutput();\n+    out.writeBytes(bytes.trimLeadingZeros());\n+    return out.encoded();\n+  }\n+\n+  @Override\n+  public WorldUpdater updater() {\n+    if (updater == null) {\n+      updater = new BonsaiWorldStateUpdater(this);\n+    }\n+    return updater;\n+  }\n+\n+  @Override\n+  public Hash rootHash() {\n+    return Hash.wrap(worldStateRootHash);\n+  }\n+\n+  @Override\n+  public Stream<StreamableAccount> streamAccounts(final Bytes32 startKeyHash, final int limit) {\n+    throw new RuntimeException(\"NIY\");\n+  }\n+\n+  @Override\n+  public Account get(final Address address) {\n+    return accountStorage\n+        .get(address.toArrayUnsafe())\n+        .map(bytes -> fromRLP(updater, address, Bytes.wrap(bytes), true))\n+        .orElse(null);\n+  }\n+\n+  private Optional<Bytes> getTrieNode(final Bytes location, final Bytes32 nodeHash) {\n+    if (nodeHash.equals(MerklePatriciaTrie.EMPTY_TRIE_NODE_HASH)) {\n+      return Optional.of(MerklePatriciaTrie.EMPTY_TRIE_NODE);\n+    } else {\n+      return trieBranchStorage.get(location.toArrayUnsafe()).map(Bytes::wrap);\n+    }\n+  }\n+\n+  private void writeTrieNode(\n+      final KeyValueStorageTransaction tx,\n+      final Bytes location,\n+      @SuppressWarnings(\"unused\") final Bytes32 nodeHash,\n+      final Bytes value) {\n+    tx.put(location.toArrayUnsafe(), value.toArrayUnsafe());\n+  }\n+\n+  private Optional<Bytes> getStorageTrieNode(\n+      final Address address, final Bytes location, final Bytes32 nodeHash) {\n+    if (nodeHash.equals(MerklePatriciaTrie.EMPTY_TRIE_NODE_HASH)) {\n+      return Optional.of(MerklePatriciaTrie.EMPTY_TRIE_NODE);\n+    } else {\n+      return trieBranchStorage\n+          .get(Bytes.concatenate(address, location).toArrayUnsafe())\n+          .map(Bytes::wrap);\n+    }\n+  }\n+\n+  private void writeStorageTrieNode(\n+      final KeyValueStorageTransaction tx,\n+      final Address address,\n+      final Bytes location,\n+      @SuppressWarnings(\"unused\") final Bytes32 key,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA4NTYyNA==", "bodyText": "Why not doing get(EMPTY_ROOT_HASH).get() like here \n  \n    \n      besu/ethereum/core/src/main/java/org/hyperledger/besu/ethereum/worldstate/DefaultWorldStateArchive.java\n    \n    \n         Line 66\n      in\n      7e52d4d\n    \n    \n    \n    \n\n        \n          \n           return get(EMPTY_ROOT_HASH).get();", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536085624", "createdAt": "2020-12-04T13:05:40Z", "author": {"login": "matkt"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiWorldStateArchive.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldState;\n+import org.hyperledger.besu.ethereum.proof.WorldStateProof;\n+import org.hyperledger.besu.ethereum.storage.StorageProvider;\n+import org.hyperledger.besu.ethereum.storage.keyvalue.KeyValueSegmentIdentifier;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiWorldStateArchive implements WorldStateArchive {\n+\n+  private final BonsaiPersistedWorldState persistedState;\n+  private final Map<Bytes32, BonsaiLayeredWorldState> layeredWorldStates;\n+\n+  public BonsaiWorldStateArchive(final StorageProvider provider) {\n+    persistedState =\n+        new BonsaiPersistedWorldState(\n+            this,\n+            provider.getStorageBySegmentIdentifier(KeyValueSegmentIdentifier.ACCOUNT_INFO_STATE),\n+            provider.getStorageBySegmentIdentifier(KeyValueSegmentIdentifier.CODE_STORAGE),\n+            provider.getStorageBySegmentIdentifier(\n+                KeyValueSegmentIdentifier.ACCOUNT_STORAGE_STORAGE),\n+            provider.getStorageBySegmentIdentifier(KeyValueSegmentIdentifier.TRIE_BRANCH_STORAGE),\n+            provider.getStorageBySegmentIdentifier(KeyValueSegmentIdentifier.TRIE_LOG_STORAGE));\n+    layeredWorldStates = new HashMap<>();\n+  }\n+\n+  @Override\n+  public Optional<WorldState> get(final Hash rootHash) {\n+    if (layeredWorldStates.containsKey(rootHash)) {\n+      return Optional.of(layeredWorldStates.get(rootHash));\n+    } else if (rootHash.equals(persistedState.rootHash())) {\n+      return Optional.of(persistedState);\n+    } else {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  public void addLayeredWorldState(final BonsaiLayeredWorldState worldState) {\n+    layeredWorldStates.put(worldState.rootHash(), worldState);\n+  }\n+\n+  @Override\n+  public boolean isWorldStateAvailable(final Hash rootHash) {\n+    return layeredWorldStates.containsKey(rootHash)\n+        || persistedState.rootHash().equals(rootHash) /* || check disk storage */;\n+  }\n+\n+  @Override\n+  public Optional<MutableWorldState> getMutable(final Hash rootHash) {\n+    if (rootHash.equals(persistedState.rootHash())) {\n+      return Optional.of(persistedState);\n+    } else {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  @Override\n+  public WorldState get() {\n+    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5OTU3Ng==", "bodyText": "I wonder if an optional wouldn't be an idea to avoid having to call this method with null ?", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536099576", "createdAt": "2020-12-04T13:29:06Z", "author": {"login": "matkt"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -191,7 +191,7 @@ public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n     if (messageFrame.isPersistingPrivateState()) {\n \n       privateWorldStateUpdater.commit();\n-      disposablePrivateState.persist();\n+      disposablePrivateState.persist(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEwMzI5NQ==", "bodyText": "NIY ? Not implemented yet ?", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536103295", "createdAt": "2020-12-04T13:35:18Z", "author": {"login": "matkt"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static org.hyperledger.besu.ethereum.bonsai.BonsaiAccount.fromRLP;\n+\n+import org.hyperledger.besu.ethereum.core.Account;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.MerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorageTransaction;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import javax.annotation.Nonnull;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiPersistedWorldState implements MutableWorldState, BonsaiWorldState {\n+\n+  private static final byte[] WORLD_ROOT_KEY = \"worldRoot\".getBytes(StandardCharsets.UTF_8);\n+\n+  private final KeyValueStorage accountStorage;\n+  private final KeyValueStorage codeStorage;\n+  private final KeyValueStorage storageStorage;\n+  private final KeyValueStorage trieBranchStorage;\n+  private final KeyValueStorage trieLogStorage;\n+\n+  private Bytes32 worldStateRootHash;\n+\n+  private final BonsaiWorldStateArchive archive;\n+  private BonsaiWorldStateUpdater updater;\n+\n+  public BonsaiPersistedWorldState(\n+      final BonsaiWorldStateArchive archive,\n+      final KeyValueStorage accountStorage,\n+      final KeyValueStorage codeStorage,\n+      final KeyValueStorage storageStorage,\n+      final KeyValueStorage trieBranchStorage,\n+      final KeyValueStorage trieLogStorage) {\n+    this.archive = archive;\n+    this.accountStorage = accountStorage;\n+    this.codeStorage = codeStorage;\n+    this.storageStorage = storageStorage;\n+    this.trieBranchStorage = trieBranchStorage;\n+    this.trieLogStorage = trieLogStorage;\n+    worldStateRootHash =\n+        Bytes32.wrap(\n+            trieBranchStorage.get(WORLD_ROOT_KEY).map(Bytes::wrap).orElse(Hash.EMPTY_TRIE_HASH));\n+  }\n+\n+  public BonsaiWorldStateArchive getArchive() {\n+    return archive;\n+  }\n+\n+  @Override\n+  public MutableWorldState copy() {\n+    throw new UnsupportedOperationException(\n+        \"Bonsai Tries does not support direct duplication of the persisted tries.\");\n+  }\n+\n+  @Override\n+  public Bytes getCode(@Nonnull final Address address) {\n+    return codeStorage.get(address.toArrayUnsafe()).map(Bytes::wrap).orElse(Bytes.EMPTY);\n+  }\n+\n+  @Override\n+  public void persist(final Hash blockHash) {\n+    boolean success = false;\n+    final KeyValueStorageTransaction accountTx = accountStorage.startTransaction();\n+    final KeyValueStorageTransaction codeTx = codeStorage.startTransaction();\n+    final KeyValueStorageTransaction storageTx = storageStorage.startTransaction();\n+    final KeyValueStorageTransaction trieBranchTx = trieBranchStorage.startTransaction();\n+    final KeyValueStorageTransaction trieLogTx = trieLogStorage.startTransaction();\n+\n+    try {\n+      // first clear storage\n+      for (final Address address : updater.getStorageToClear()) {\n+        // because we are clearing persisted values we need the account root as persisted\n+        final BonsaiAccount oldAccount =\n+            accountStorage\n+                .get(address.toArrayUnsafe())\n+                .map(\n+                    bytes ->\n+                        fromRLP(BonsaiPersistedWorldState.this, address, Bytes.wrap(bytes), true))\n+                .orElse(null);\n+        if (oldAccount == null) {\n+          // This is when an account is both created and deleted within the scope of the same\n+          // block.  A not-uncommon DeFi bot pattern.\n+          continue;\n+        }\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(address, location, key),\n+                oldAccount.getStorageRoot(),\n+                Function.identity(),\n+                Function.identity());\n+        Map<Bytes32, Bytes> entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+        while (!entriesToDelete.isEmpty()) {\n+          entriesToDelete\n+              .keySet()\n+              .forEach(k -> storageTx.remove(Bytes.concatenate(address, k).toArrayUnsafe()));\n+          if (entriesToDelete.size() == 256) {\n+            entriesToDelete.keySet().forEach(storageTrie::remove);\n+            entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+          } else {\n+            break;\n+          }\n+        }\n+      }\n+\n+      // second update account storage state.  This must be done before updating the accounts so\n+      // that we can get the storage state hash\n+      for (final Map.Entry<Address, Map<Hash, BonsaiValue<UInt256>>> storageAccountUpdate :\n+          updater.getStorageToUpdate().entrySet()) {\n+        final Address updatedAddress = storageAccountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> accountValue =\n+            updater.getAccountsToUpdate().get(updatedAddress);\n+        final BonsaiAccount accountOriginal = accountValue.getOriginal();\n+        final Hash storageRoot =\n+            (accountOriginal == null) ? Hash.EMPTY_TRIE_HASH : accountOriginal.getStorageRoot();\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(updatedAddress, location, key),\n+                storageRoot,\n+                Function.identity(),\n+                Function.identity());\n+\n+        // for manicured tries and composting, collect branches here (not implemented)\n+\n+        for (final Map.Entry<Hash, BonsaiValue<UInt256>> storageUpdate :\n+            storageAccountUpdate.getValue().entrySet()) {\n+          final Hash keyHash = storageUpdate.getKey();\n+          final byte[] writeAddress = Bytes.concatenate(updatedAddress, keyHash).toArrayUnsafe();\n+          final UInt256 updatedStorage = storageUpdate.getValue().getUpdated();\n+          if (updatedStorage == null || updatedStorage.equals(UInt256.ZERO)) {\n+            storageTx.remove(writeAddress);\n+            storageTrie.remove(keyHash);\n+          } else {\n+            final Bytes32 updatedStorageBytes = updatedStorage.toBytes();\n+            storageTx.put(writeAddress, updatedStorageBytes.toArrayUnsafe());\n+            storageTrie.put(keyHash, rlpEncode(updatedStorageBytes));\n+          }\n+        }\n+\n+        final BonsaiAccount accountUpdated = accountValue.getUpdated();\n+        if (accountUpdated != null) {\n+          storageTrie.commit(\n+              (location, key, value) ->\n+                  writeStorageTrieNode(trieBranchTx, updatedAddress, location, key, value));\n+          final Hash newStorageRoot = Hash.wrap(storageTrie.getRootHash());\n+          accountUpdated.setStorageRoot(newStorageRoot);\n+        }\n+        // for manicured tries and composting, trim and compost here\n+      }\n+\n+      // Third update the code.  This has the side effect of ensuring a code hash is calculated.\n+      for (final Map.Entry<Address, BonsaiValue<Bytes>> codeUpdate :\n+          updater.getCodeToUpdate().entrySet()) {\n+        final Bytes updatedCode = codeUpdate.getValue().getUpdated();\n+        if (updatedCode == null || updatedCode.size() == 0) {\n+          codeTx.remove(codeUpdate.getKey().toArrayUnsafe());\n+        } else {\n+          codeTx.put(codeUpdate.getKey().toArrayUnsafe(), updatedCode.toArrayUnsafe());\n+        }\n+      }\n+\n+      // next collect the branches that will be trimmed\n+      final StoredMerklePatriciaTrie<Bytes, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              this::getTrieNode, worldStateRootHash, Function.identity(), Function.identity());\n+\n+      // for manicured tries and composting, collect branches here (not implemented)\n+\n+      // now add the accounts\n+      for (final Map.Entry<Address, BonsaiValue<BonsaiAccount>> accountUpdate :\n+          updater.getAccountsToUpdate().entrySet()) {\n+        final Bytes accountKey = accountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> bonsaiValue = accountUpdate.getValue();\n+        final BonsaiAccount updatedAccount = bonsaiValue.getUpdated();\n+        if (updatedAccount == null) {\n+          final Hash addressHash = Hash.hash(accountKey);\n+          accountTrie.remove(addressHash);\n+          accountTx.remove(accountKey.toArrayUnsafe());\n+        } else {\n+          final Hash addressHash = updatedAccount.getAddressHash();\n+          final Bytes accountValue = updatedAccount.serializeAccount();\n+          accountTx.put(accountKey.toArrayUnsafe(), accountValue.toArrayUnsafe());\n+          accountTrie.put(addressHash, accountValue);\n+        }\n+      }\n+\n+      accountTrie.commit(\n+          (location, hash, value) -> writeTrieNode(trieBranchTx, location, hash, value));\n+      worldStateRootHash = accountTrie.getRootHash();\n+      trieBranchTx.put(WORLD_ROOT_KEY, worldStateRootHash.toArrayUnsafe());\n+\n+      // for manicured tries and composting, trim and compost branches here\n+\n+      if (blockHash != null) {\n+        final TrieLogLayer trieLog = updater.generateTrieLog(blockHash);\n+        trieLog.freeze();\n+        // TODO add to archive here, but only once we get persisted follow distance implemented\n+        // archive.addLayeredWorldState(new BonsaiLayeredWorldState(this, trieLog));\n+\n+        final BytesValueRLPOutput rlpLog = new BytesValueRLPOutput();\n+        trieLog.writeTo(rlpLog);\n+        trieLogTx.put(blockHash.toArrayUnsafe(), rlpLog.encoded().toArrayUnsafe());\n+      }\n+\n+      success = true;\n+    } finally {\n+      if (success) {\n+        accountTx.commit();\n+        codeTx.commit();\n+        storageTx.commit();\n+        trieBranchTx.commit();\n+        trieLogTx.commit();\n+        updater.reset();\n+      } else {\n+        accountTx.rollback();\n+        codeTx.rollback();\n+        storageTx.rollback();\n+        trieBranchTx.rollback();\n+        trieLogTx.rollback();\n+      }\n+    }\n+  }\n+\n+  private static Bytes rlpEncode(final Bytes bytes) {\n+    final BytesValueRLPOutput out = new BytesValueRLPOutput();\n+    out.writeBytes(bytes.trimLeadingZeros());\n+    return out.encoded();\n+  }\n+\n+  @Override\n+  public WorldUpdater updater() {\n+    if (updater == null) {\n+      updater = new BonsaiWorldStateUpdater(this);\n+    }\n+    return updater;\n+  }\n+\n+  @Override\n+  public Hash rootHash() {\n+    return Hash.wrap(worldStateRootHash);\n+  }\n+\n+  @Override\n+  public Stream<StreamableAccount> streamAccounts(final Bytes32 startKeyHash, final int limit) {\n+    throw new RuntimeException(\"NIY\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9bd8d5200aae80bd1b6643b996130975eafb94d"}, "originalPosition": 275}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78bc7200d64f19cfa93f1be765cb53afa3cee451", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/78bc7200d64f19cfa93f1be765cb53afa3cee451", "committedDate": "2020-12-04T14:07:49Z", "message": "review changes.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0OTk4Nzk1", "url": "https://github.com/hyperledger/besu/pull/1664#pullrequestreview-544998795", "createdAt": "2020-12-04T14:20:47Z", "commit": {"oid": "78bc7200d64f19cfa93f1be765cb53afa3cee451"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6bf59a6060ad3f577368a329a008fc3bc248651", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/f6bf59a6060ad3f577368a329a008fc3bc248651", "committedDate": "2020-12-04T14:39:44Z", "message": "Merge branch 'master' of github.com:hyperledger/besu into bonsai\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "624587f9e2e91ef5d39de022facb62cd1e04ef15", "author": {"user": {"login": "shemnon", "name": "Danno Ferrin"}}, "url": "https://github.com/hyperledger/besu/commit/624587f9e2e91ef5d39de022facb62cd1e04ef15", "committedDate": "2020-12-04T14:59:35Z", "message": "spotless\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NjExNzQ4", "url": "https://github.com/hyperledger/besu/pull/1664#pullrequestreview-545611748", "createdAt": "2020-12-05T17:38:01Z", "commit": {"oid": "624587f9e2e91ef5d39de022facb62cd1e04ef15"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxNzozODowMVrOH_9b2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxNzo1MDozMVrOH_9jnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgyODg4OQ==", "bodyText": "\ud83e\udd23", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536828889", "createdAt": "2020-12-05T17:38:01Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/TrieLogLayer.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.rlp.RLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLPOutput;\n+import org.hyperledger.besu.ethereum.worldstate.StateTrieAccountValue;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+/**\n+ * This class encapsulates the changes that are done to transition one block to the next. This\n+ * includes serialization and deserialization tasks for storing this log to off-memory storage.\n+ *\n+ * <p>In this particular formulation only the \"Leaves\" are tracked\" Future layers may track patrica\n+ * trie changes as well.\n+ */\n+public class TrieLogLayer {\n+\n+  private Hash blockHash;\n+  private final Map<Address, BonsaiValue<StateTrieAccountValue>> accounts = new TreeMap<>();\n+  private final Map<Address, BonsaiValue<Bytes>> code = new TreeMap<>();\n+  private final Map<Address, Map<Hash, BonsaiValue<UInt256>>> storage = new TreeMap<>();\n+  private boolean frozen = false;\n+\n+  /** Locks the layer so no new changes can be added; */\n+  void freeze() {\n+    frozen = true; // The code never bothered me anyway", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624587f9e2e91ef5d39de022facb62cd1e04ef15"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgzMDg3Nw==", "bodyText": "It felt logically circuitous that the updater comes from a persisted world state (which is like the \"bottom\" layer in my head) but ultimately gets at the layers \"above\" through the context in the BonsaiAccount. AbstractBlockProcessor requires a MutableWorldState and in this implementation that's only the BonsaiPersistedWorldState. I wonder if it would become cleaner if the MutableWorldState was an object that encapsulated the totality of layered and persisted storage?", "url": "https://github.com/hyperledger/besu/pull/1664#discussion_r536830877", "createdAt": "2020-12-05T17:50:31Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/bonsai/BonsaiPersistedWorldState.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+package org.hyperledger.besu.ethereum.bonsai;\n+\n+import static org.hyperledger.besu.ethereum.bonsai.BonsaiAccount.fromRLP;\n+\n+import org.hyperledger.besu.ethereum.core.Account;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;\n+import org.hyperledger.besu.ethereum.trie.MerklePatriciaTrie;\n+import org.hyperledger.besu.ethereum.trie.StoredMerklePatriciaTrie;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;\n+import org.hyperledger.besu.plugin.services.storage.KeyValueStorageTransaction;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import javax.annotation.Nonnull;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class BonsaiPersistedWorldState implements MutableWorldState, BonsaiWorldState {\n+\n+  private static final byte[] WORLD_ROOT_KEY = \"worldRoot\".getBytes(StandardCharsets.UTF_8);\n+\n+  private final KeyValueStorage accountStorage;\n+  private final KeyValueStorage codeStorage;\n+  private final KeyValueStorage storageStorage;\n+  private final KeyValueStorage trieBranchStorage;\n+  private final KeyValueStorage trieLogStorage;\n+\n+  private Bytes32 worldStateRootHash;\n+\n+  private final BonsaiWorldStateArchive archive;\n+  private BonsaiWorldStateUpdater updater;\n+\n+  public BonsaiPersistedWorldState(\n+      final BonsaiWorldStateArchive archive,\n+      final KeyValueStorage accountStorage,\n+      final KeyValueStorage codeStorage,\n+      final KeyValueStorage storageStorage,\n+      final KeyValueStorage trieBranchStorage,\n+      final KeyValueStorage trieLogStorage) {\n+    this.archive = archive;\n+    this.accountStorage = accountStorage;\n+    this.codeStorage = codeStorage;\n+    this.storageStorage = storageStorage;\n+    this.trieBranchStorage = trieBranchStorage;\n+    this.trieLogStorage = trieLogStorage;\n+    worldStateRootHash =\n+        Bytes32.wrap(\n+            trieBranchStorage.get(WORLD_ROOT_KEY).map(Bytes::wrap).orElse(Hash.EMPTY_TRIE_HASH));\n+  }\n+\n+  public BonsaiWorldStateArchive getArchive() {\n+    return archive;\n+  }\n+\n+  @Override\n+  public MutableWorldState copy() {\n+    throw new UnsupportedOperationException(\n+        \"Bonsai Tries does not support direct duplication of the persisted tries.\");\n+  }\n+\n+  @Override\n+  public Bytes getCode(@Nonnull final Address address) {\n+    return codeStorage.get(address.toArrayUnsafe()).map(Bytes::wrap).orElse(Bytes.EMPTY);\n+  }\n+\n+  @Override\n+  public void persist(final Hash blockHash) {\n+    boolean success = false;\n+    final KeyValueStorageTransaction accountTx = accountStorage.startTransaction();\n+    final KeyValueStorageTransaction codeTx = codeStorage.startTransaction();\n+    final KeyValueStorageTransaction storageTx = storageStorage.startTransaction();\n+    final KeyValueStorageTransaction trieBranchTx = trieBranchStorage.startTransaction();\n+    final KeyValueStorageTransaction trieLogTx = trieLogStorage.startTransaction();\n+\n+    try {\n+      // first clear storage\n+      for (final Address address : updater.getStorageToClear()) {\n+        // because we are clearing persisted values we need the account root as persisted\n+        final BonsaiAccount oldAccount =\n+            accountStorage\n+                .get(address.toArrayUnsafe())\n+                .map(\n+                    bytes ->\n+                        fromRLP(BonsaiPersistedWorldState.this, address, Bytes.wrap(bytes), true))\n+                .orElse(null);\n+        if (oldAccount == null) {\n+          // This is when an account is both created and deleted within the scope of the same\n+          // block.  A not-uncommon DeFi bot pattern.\n+          continue;\n+        }\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(address, location, key),\n+                oldAccount.getStorageRoot(),\n+                Function.identity(),\n+                Function.identity());\n+        Map<Bytes32, Bytes> entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+        while (!entriesToDelete.isEmpty()) {\n+          entriesToDelete\n+              .keySet()\n+              .forEach(k -> storageTx.remove(Bytes.concatenate(address, k).toArrayUnsafe()));\n+          if (entriesToDelete.size() == 256) {\n+            entriesToDelete.keySet().forEach(storageTrie::remove);\n+            entriesToDelete = storageTrie.entriesFrom(Bytes32.ZERO, 256);\n+          } else {\n+            break;\n+          }\n+        }\n+      }\n+\n+      // second update account storage state.  This must be done before updating the accounts so\n+      // that we can get the storage state hash\n+      for (final Map.Entry<Address, Map<Hash, BonsaiValue<UInt256>>> storageAccountUpdate :\n+          updater.getStorageToUpdate().entrySet()) {\n+        final Address updatedAddress = storageAccountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> accountValue =\n+            updater.getAccountsToUpdate().get(updatedAddress);\n+        final BonsaiAccount accountOriginal = accountValue.getOriginal();\n+        final Hash storageRoot =\n+            (accountOriginal == null) ? Hash.EMPTY_TRIE_HASH : accountOriginal.getStorageRoot();\n+        final StoredMerklePatriciaTrie<Bytes, Bytes> storageTrie =\n+            new StoredMerklePatriciaTrie<>(\n+                (location, key) -> getStorageTrieNode(updatedAddress, location, key),\n+                storageRoot,\n+                Function.identity(),\n+                Function.identity());\n+\n+        // for manicured tries and composting, collect branches here (not implemented)\n+\n+        for (final Map.Entry<Hash, BonsaiValue<UInt256>> storageUpdate :\n+            storageAccountUpdate.getValue().entrySet()) {\n+          final Hash keyHash = storageUpdate.getKey();\n+          final byte[] writeAddress = Bytes.concatenate(updatedAddress, keyHash).toArrayUnsafe();\n+          final UInt256 updatedStorage = storageUpdate.getValue().getUpdated();\n+          if (updatedStorage == null || updatedStorage.equals(UInt256.ZERO)) {\n+            storageTx.remove(writeAddress);\n+            storageTrie.remove(keyHash);\n+          } else {\n+            final Bytes32 updatedStorageBytes = updatedStorage.toBytes();\n+            storageTx.put(writeAddress, updatedStorageBytes.toArrayUnsafe());\n+            storageTrie.put(keyHash, rlpEncode(updatedStorageBytes));\n+          }\n+        }\n+\n+        final BonsaiAccount accountUpdated = accountValue.getUpdated();\n+        if (accountUpdated != null) {\n+          storageTrie.commit(\n+              (location, key, value) ->\n+                  writeStorageTrieNode(trieBranchTx, updatedAddress, location, value));\n+          final Hash newStorageRoot = Hash.wrap(storageTrie.getRootHash());\n+          accountUpdated.setStorageRoot(newStorageRoot);\n+        }\n+        // for manicured tries and composting, trim and compost here\n+      }\n+\n+      // Third update the code.  This has the side effect of ensuring a code hash is calculated.\n+      for (final Map.Entry<Address, BonsaiValue<Bytes>> codeUpdate :\n+          updater.getCodeToUpdate().entrySet()) {\n+        final Bytes updatedCode = codeUpdate.getValue().getUpdated();\n+        if (updatedCode == null || updatedCode.size() == 0) {\n+          codeTx.remove(codeUpdate.getKey().toArrayUnsafe());\n+        } else {\n+          codeTx.put(codeUpdate.getKey().toArrayUnsafe(), updatedCode.toArrayUnsafe());\n+        }\n+      }\n+\n+      // next collect the branches that will be trimmed\n+      final StoredMerklePatriciaTrie<Bytes, Bytes> accountTrie =\n+          new StoredMerklePatriciaTrie<>(\n+              this::getTrieNode, worldStateRootHash, Function.identity(), Function.identity());\n+\n+      // for manicured tries and composting, collect branches here (not implemented)\n+\n+      // now add the accounts\n+      for (final Map.Entry<Address, BonsaiValue<BonsaiAccount>> accountUpdate :\n+          updater.getAccountsToUpdate().entrySet()) {\n+        final Bytes accountKey = accountUpdate.getKey();\n+        final BonsaiValue<BonsaiAccount> bonsaiValue = accountUpdate.getValue();\n+        final BonsaiAccount updatedAccount = bonsaiValue.getUpdated();\n+        if (updatedAccount == null) {\n+          final Hash addressHash = Hash.hash(accountKey);\n+          accountTrie.remove(addressHash);\n+          accountTx.remove(accountKey.toArrayUnsafe());\n+        } else {\n+          final Hash addressHash = updatedAccount.getAddressHash();\n+          final Bytes accountValue = updatedAccount.serializeAccount();\n+          accountTx.put(accountKey.toArrayUnsafe(), accountValue.toArrayUnsafe());\n+          accountTrie.put(addressHash, accountValue);\n+        }\n+      }\n+\n+      accountTrie.commit((location, hash, value) -> writeTrieNode(trieBranchTx, location, value));\n+      worldStateRootHash = accountTrie.getRootHash();\n+      trieBranchTx.put(WORLD_ROOT_KEY, worldStateRootHash.toArrayUnsafe());\n+\n+      // for manicured tries and composting, trim and compost branches here\n+\n+      if (blockHash != null) {\n+        final TrieLogLayer trieLog = updater.generateTrieLog(blockHash);\n+        trieLog.freeze();\n+        // TODO add to archive here, but only once we get persisted follow distance implemented\n+        // archive.addLayeredWorldState(new BonsaiLayeredWorldState(this, trieLog));\n+\n+        final BytesValueRLPOutput rlpLog = new BytesValueRLPOutput();\n+        trieLog.writeTo(rlpLog);\n+        trieLogTx.put(blockHash.toArrayUnsafe(), rlpLog.encoded().toArrayUnsafe());\n+      }\n+\n+      success = true;\n+    } finally {\n+      if (success) {\n+        accountTx.commit();\n+        codeTx.commit();\n+        storageTx.commit();\n+        trieBranchTx.commit();\n+        trieLogTx.commit();\n+        updater.reset();\n+      } else {\n+        accountTx.rollback();\n+        codeTx.rollback();\n+        storageTx.rollback();\n+        trieBranchTx.rollback();\n+        trieLogTx.rollback();\n+      }\n+    }\n+  }\n+\n+  private static Bytes rlpEncode(final Bytes bytes) {\n+    final BytesValueRLPOutput out = new BytesValueRLPOutput();\n+    out.writeBytes(bytes.trimLeadingZeros());\n+    return out.encoded();\n+  }\n+\n+  @Override\n+  public WorldUpdater updater() {\n+    if (updater == null) {\n+      updater = new BonsaiWorldStateUpdater(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624587f9e2e91ef5d39de022facb62cd1e04ef15"}, "originalPosition": 262}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1948, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}