{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1Mzc0MzIx", "number": 1406, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDowMjozNlrOEpC74w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNzowMzo1NlrOEsIXEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDc1MTcxOnYy", "diffSide": "RIGHT", "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/PendingBlocks.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDowMjozNlrOHafI3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDowMjowNFrOHcefrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUzNTE5Nw==", "bodyText": "Probably should make it clear in the variable name that this is a default like DEFAULT_PENDING_BLOCKS_CACHE_SIZE", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r497535197", "createdAt": "2020-09-30T14:02:36Z", "author": {"login": "RatanRSur"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/PendingBlocks.java", "diffHunk": "@@ -27,24 +27,49 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n \n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.RemovalListener;\n+\n public class PendingBlocks {\n \n-  private final Map<Hash, Block> pendingBlocks = new ConcurrentHashMap<>();\n+  // If more than 100 behind, Besu switch to full synchronization mode. 150 because it is possible\n+  // to have multiple versions of the same block number\n+  private static final int CACHE_PENDING_BLOCKS_SIZE = 150;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a1cf811df724f76c92b3ae38ec20f778462eb41"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyMTgwNg==", "bodyText": "Removed", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r499621806", "createdAt": "2020-10-05T14:02:04Z", "author": {"login": "matkt"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/PendingBlocks.java", "diffHunk": "@@ -27,24 +27,49 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n \n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.RemovalListener;\n+\n public class PendingBlocks {\n \n-  private final Map<Hash, Block> pendingBlocks = new ConcurrentHashMap<>();\n+  // If more than 100 behind, Besu switch to full synchronization mode. 150 because it is possible\n+  // to have multiple versions of the same block number\n+  private static final int CACHE_PENDING_BLOCKS_SIZE = 150;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUzNTE5Nw=="}, "originalCommit": {"oid": "8a1cf811df724f76c92b3ae38ec20f778462eb41"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDgwNTIzOnYy", "diffSide": "RIGHT", "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/PendingBlocks.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDoxNDozMlrOHafrxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDowMTo1N1rOHcefZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU0NDEzNA==", "bodyText": "Can this be private?", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r497544134", "createdAt": "2020-09-30T14:14:32Z", "author": {"login": "RatanRSur"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/PendingBlocks.java", "diffHunk": "@@ -64,27 +89,33 @@ public boolean registerPendingBlock(final Block pendingBlock) {\n    * Stop tracking the given block.\n    *\n    * @param block the block that is no longer pending\n-   * @return true if this block was removed\n    */\n-  public boolean deregisterPendingBlock(final Block block) {\n+  public void deregisterPendingBlock(final Block block) {\n+    pendingBlocks.invalidate(block.getHash());\n+  }\n+\n+  /**\n+   * Stop keeping this block in the list of pending blocks by parent hash\n+   *\n+   * @param block the block that is no longer pending\n+   */\n+  public void removePendingBlockByParentHashForBlock(final Block block) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a1cf811df724f76c92b3ae38ec20f778462eb41"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyMTczNQ==", "bodyText": "Removed", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r499621735", "createdAt": "2020-10-05T14:01:57Z", "author": {"login": "matkt"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/PendingBlocks.java", "diffHunk": "@@ -64,27 +89,33 @@ public boolean registerPendingBlock(final Block pendingBlock) {\n    * Stop tracking the given block.\n    *\n    * @param block the block that is no longer pending\n-   * @return true if this block was removed\n    */\n-  public boolean deregisterPendingBlock(final Block block) {\n+  public void deregisterPendingBlock(final Block block) {\n+    pendingBlocks.invalidate(block.getHash());\n+  }\n+\n+  /**\n+   * Stop keeping this block in the list of pending blocks by parent hash\n+   *\n+   * @param block the block that is no longer pending\n+   */\n+  public void removePendingBlockByParentHashForBlock(final Block block) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU0NDEzNA=="}, "originalCommit": {"oid": "8a1cf811df724f76c92b3ae38ec20f778462eb41"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDg2MjY3OnYy", "diffSide": "RIGHT", "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/PendingBlocks.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDoyNjoxNFrOHagPkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDowNDoxNFrOHceleA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU1MzI5OQ==", "bodyText": "Can you point me to where this switch happens?", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r497553299", "createdAt": "2020-09-30T14:26:14Z", "author": {"login": "RatanRSur"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/PendingBlocks.java", "diffHunk": "@@ -27,24 +27,49 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n \n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.RemovalListener;\n+\n public class PendingBlocks {\n \n-  private final Map<Hash, Block> pendingBlocks = new ConcurrentHashMap<>();\n+  // If more than 100 behind, Besu switch to full synchronization mode. 150 because it is possible\n+  // to have multiple versions of the same block number", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a1cf811df724f76c92b3ae38ec20f778462eb41"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyMzI4OA==", "bodyText": "the implementation has changed and is no longer based on this behavior. The node does not restart a FullSync if the distance to the head chain is >100 but when it connects to a new peer.", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r499623288", "createdAt": "2020-10-05T14:04:14Z", "author": {"login": "matkt"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/PendingBlocks.java", "diffHunk": "@@ -27,24 +27,49 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n \n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.RemovalListener;\n+\n public class PendingBlocks {\n \n-  private final Map<Hash, Block> pendingBlocks = new ConcurrentHashMap<>();\n+  // If more than 100 behind, Besu switch to full synchronization mode. 150 because it is possible\n+  // to have multiple versions of the same block number", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU1MzI5OQ=="}, "originalCommit": {"oid": "8a1cf811df724f76c92b3ae38ec20f778462eb41"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODMxNDc1OnYy", "diffSide": "RIGHT", "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/PendingBlocksManager.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDoxODo0NlrOHcfM_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzowNDoyOVrOHcmDEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzMzQwNw==", "bodyText": "I'm not sure we need a REORG_CACHE_SIZE_MUTIPLICATOR. Couldn't we leave it the size of the inverval (40 in this case) and use a bounded priority queue? The highest priority blocks would be those that are lowest in block height and then higher priority if they were sent more recently.", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r499633407", "createdAt": "2020-10-05T14:18:46Z", "author": {"login": "RatanRSur"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/PendingBlocksManager.java", "diffHunk": "@@ -27,35 +30,54 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n \n-public class PendingBlocks {\n+import org.apache.tuweni.bytes.Bytes;\n \n-  private final Map<Hash, Block> pendingBlocks = new ConcurrentHashMap<>();\n+public class PendingBlocksManager {\n+\n+  private static final int REORG_CACHE_SIZE_FACTOR = 2;\n+\n+  private final PendingBlockCache pendingBlocks;\n   private final Map<Hash, Set<Hash>> pendingBlocksByParentHash = new ConcurrentHashMap<>();\n \n+  public PendingBlocksManager(final SynchronizerConfiguration synchronizerConfiguration) {\n+    pendingBlocks =\n+        new PendingBlockCache(\n+            (Math.abs(synchronizerConfiguration.getBlockPropagationRange().lowerEndpoint())\n+                    + Math.abs(\n+                        synchronizerConfiguration.getBlockPropagationRange().upperEndpoint()))\n+                * REORG_CACHE_SIZE_FACTOR);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2150ed673052177abe3777fa1376c32a29f3e961"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4MjE2Mw==", "bodyText": "I don't think a queue is the best choice in this case because in my opinion we need to stay on a Map to be able to search for a block by its hash and not just browse the elements. But a priority mechanism could be a good idea.  I can add this mechanism to my cache by creating a custom comparator and instead of refusing to add a block, I will replace the one that has the highest number and which is the older. What do you think ?", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r499682163", "createdAt": "2020-10-05T15:24:28Z", "author": {"login": "matkt"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/PendingBlocksManager.java", "diffHunk": "@@ -27,35 +30,54 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n \n-public class PendingBlocks {\n+import org.apache.tuweni.bytes.Bytes;\n \n-  private final Map<Hash, Block> pendingBlocks = new ConcurrentHashMap<>();\n+public class PendingBlocksManager {\n+\n+  private static final int REORG_CACHE_SIZE_FACTOR = 2;\n+\n+  private final PendingBlockCache pendingBlocks;\n   private final Map<Hash, Set<Hash>> pendingBlocksByParentHash = new ConcurrentHashMap<>();\n \n+  public PendingBlocksManager(final SynchronizerConfiguration synchronizerConfiguration) {\n+    pendingBlocks =\n+        new PendingBlockCache(\n+            (Math.abs(synchronizerConfiguration.getBlockPropagationRange().lowerEndpoint())\n+                    + Math.abs(\n+                        synchronizerConfiguration.getBlockPropagationRange().upperEndpoint()))\n+                * REORG_CACHE_SIZE_FACTOR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzMzQwNw=="}, "originalCommit": {"oid": "2150ed673052177abe3777fa1376c32a29f3e961"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyMzY0NQ==", "bodyText": "I checked the SortedMap and knowing that the order must depend on the nodeId, the block Number and the timestamp. It would seem easier to get the lowest priority block using code like this when trying to add a new block (I need to verify that it works).\nprivate Optional<ImmutablePendingBlock> getLowestPriorityBlock(\n      final ImmutablePendingBlock pendingBlock) {\n    \n\n    // get all blocks from the nodeId\n    final Stream<ImmutablePendingBlock> nodeIdBlocks =\n        values().stream().filter(value -> value.nodeId() == pendingBlock.nodeId());\n\n    // get the oldest block\n    final Optional<ImmutablePendingBlock> oldestBlock =\n        nodeIdBlocks.filter(value -> value.nodeId() == pendingBlock.nodeId())\n            .max(Comparator.comparingLong(o -> o.block().getHeader().getNumber())).stream()\n            .findFirst();\n    \n    // filter by number and timestamp\n    return oldestBlock.flatMap(\n        immutablePendingBlock ->\n            nodeIdBlocks\n                .filter(\n                    block ->\n                        block.block().getHeader().getNumber()\n                            == immutablePendingBlock.block().getHeader().getNumber())\n                .min(Comparator.comparingLong(o -> o.block().getHeader().getTimestamp())));\n  }\n\nIn addition, the sorting on a SortedMap seems to be done only on the key during insertion. You have to browse the whole map if you want to sort by value.", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r499723645", "createdAt": "2020-10-05T16:26:33Z", "author": {"login": "matkt"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/PendingBlocksManager.java", "diffHunk": "@@ -27,35 +30,54 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n \n-public class PendingBlocks {\n+import org.apache.tuweni.bytes.Bytes;\n \n-  private final Map<Hash, Block> pendingBlocks = new ConcurrentHashMap<>();\n+public class PendingBlocksManager {\n+\n+  private static final int REORG_CACHE_SIZE_FACTOR = 2;\n+\n+  private final PendingBlockCache pendingBlocks;\n   private final Map<Hash, Set<Hash>> pendingBlocksByParentHash = new ConcurrentHashMap<>();\n \n+  public PendingBlocksManager(final SynchronizerConfiguration synchronizerConfiguration) {\n+    pendingBlocks =\n+        new PendingBlockCache(\n+            (Math.abs(synchronizerConfiguration.getBlockPropagationRange().lowerEndpoint())\n+                    + Math.abs(\n+                        synchronizerConfiguration.getBlockPropagationRange().upperEndpoint()))\n+                * REORG_CACHE_SIZE_FACTOR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzMzQwNw=="}, "originalCommit": {"oid": "2150ed673052177abe3777fa1376c32a29f3e961"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyNjM0Ng==", "bodyText": "What do you think about using a queue anyways since it's going to be max of 40 blocks. O(n) with n=40 shouldn't be too bad when searching for hashes and it would make the code less complicated I think. Not sure.", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r499726346", "createdAt": "2020-10-05T16:31:03Z", "author": {"login": "RatanRSur"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/PendingBlocksManager.java", "diffHunk": "@@ -27,35 +30,54 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n \n-public class PendingBlocks {\n+import org.apache.tuweni.bytes.Bytes;\n \n-  private final Map<Hash, Block> pendingBlocks = new ConcurrentHashMap<>();\n+public class PendingBlocksManager {\n+\n+  private static final int REORG_CACHE_SIZE_FACTOR = 2;\n+\n+  private final PendingBlockCache pendingBlocks;\n   private final Map<Hash, Set<Hash>> pendingBlocksByParentHash = new ConcurrentHashMap<>();\n \n+  public PendingBlocksManager(final SynchronizerConfiguration synchronizerConfiguration) {\n+    pendingBlocks =\n+        new PendingBlockCache(\n+            (Math.abs(synchronizerConfiguration.getBlockPropagationRange().lowerEndpoint())\n+                    + Math.abs(\n+                        synchronizerConfiguration.getBlockPropagationRange().upperEndpoint()))\n+                * REORG_CACHE_SIZE_FACTOR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzMzQwNw=="}, "originalCommit": {"oid": "2150ed673052177abe3777fa1376c32a29f3e961"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczNjA5MQ==", "bodyText": "not necessarily 40 because if we are looking for a block we will not only search for a single peer but for all the peers so 40 * nbPeers. I will continue to search and see if another solution is possible. The initial idea of \u200b\u200bhaving only a simple implementation that refuse the new blocks was precisely to not impact performance by sorting everytime. Because the case where we have more than 40 blocks will be relatively rare but the sort will be done each time.", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r499736091", "createdAt": "2020-10-05T16:47:58Z", "author": {"login": "matkt"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/PendingBlocksManager.java", "diffHunk": "@@ -27,35 +30,54 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n \n-public class PendingBlocks {\n+import org.apache.tuweni.bytes.Bytes;\n \n-  private final Map<Hash, Block> pendingBlocks = new ConcurrentHashMap<>();\n+public class PendingBlocksManager {\n+\n+  private static final int REORG_CACHE_SIZE_FACTOR = 2;\n+\n+  private final PendingBlockCache pendingBlocks;\n   private final Map<Hash, Set<Hash>> pendingBlocksByParentHash = new ConcurrentHashMap<>();\n \n+  public PendingBlocksManager(final SynchronizerConfiguration synchronizerConfiguration) {\n+    pendingBlocks =\n+        new PendingBlockCache(\n+            (Math.abs(synchronizerConfiguration.getBlockPropagationRange().lowerEndpoint())\n+                    + Math.abs(\n+                        synchronizerConfiguration.getBlockPropagationRange().upperEndpoint()))\n+                * REORG_CACHE_SIZE_FACTOR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzMzQwNw=="}, "originalCommit": {"oid": "2150ed673052177abe3777fa1376c32a29f3e961"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczODUwNg==", "bodyText": "another solution would be to add a priority queue for each peer next to the global map. and when adding check in this queue. maybe that's the solution. it will just be necessary to work in the synchronization of these two component. But it doesn't seem complicated because there is already \"pendingBlocksByParentHash\" which is synchronized.\nbut that may be a bit too much", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r499738506", "createdAt": "2020-10-05T16:52:04Z", "author": {"login": "matkt"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/PendingBlocksManager.java", "diffHunk": "@@ -27,35 +30,54 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n \n-public class PendingBlocks {\n+import org.apache.tuweni.bytes.Bytes;\n \n-  private final Map<Hash, Block> pendingBlocks = new ConcurrentHashMap<>();\n+public class PendingBlocksManager {\n+\n+  private static final int REORG_CACHE_SIZE_FACTOR = 2;\n+\n+  private final PendingBlockCache pendingBlocks;\n   private final Map<Hash, Set<Hash>> pendingBlocksByParentHash = new ConcurrentHashMap<>();\n \n+  public PendingBlocksManager(final SynchronizerConfiguration synchronizerConfiguration) {\n+    pendingBlocks =\n+        new PendingBlockCache(\n+            (Math.abs(synchronizerConfiguration.getBlockPropagationRange().lowerEndpoint())\n+                    + Math.abs(\n+                        synchronizerConfiguration.getBlockPropagationRange().upperEndpoint()))\n+                * REORG_CACHE_SIZE_FACTOR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzMzQwNw=="}, "originalCommit": {"oid": "2150ed673052177abe3777fa1376c32a29f3e961"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0NTU1NQ==", "bodyText": "I think I may have a way to simplify the code like this\nprivate Optional<ImmutablePendingBlock> getLowestPriorityBlock(\n      final ImmutablePendingBlock pendingBlock) {\n    final Comparator<ImmutablePendingBlock> comparator =\n        Comparator.comparing(s -> s.block().getHeader().getNumber());\n    return values().stream()\n        .filter(value -> value.nodeId() == pendingBlock.nodeId())\n        .min(comparator.reversed().thenComparing(s -> s.block().getHeader().getTimestamp()));\n  }", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r499745555", "createdAt": "2020-10-05T17:04:29Z", "author": {"login": "matkt"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/PendingBlocksManager.java", "diffHunk": "@@ -27,35 +30,54 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n \n-public class PendingBlocks {\n+import org.apache.tuweni.bytes.Bytes;\n \n-  private final Map<Hash, Block> pendingBlocks = new ConcurrentHashMap<>();\n+public class PendingBlocksManager {\n+\n+  private static final int REORG_CACHE_SIZE_FACTOR = 2;\n+\n+  private final PendingBlockCache pendingBlocks;\n   private final Map<Hash, Set<Hash>> pendingBlocksByParentHash = new ConcurrentHashMap<>();\n \n+  public PendingBlocksManager(final SynchronizerConfiguration synchronizerConfiguration) {\n+    pendingBlocks =\n+        new PendingBlockCache(\n+            (Math.abs(synchronizerConfiguration.getBlockPropagationRange().lowerEndpoint())\n+                    + Math.abs(\n+                        synchronizerConfiguration.getBlockPropagationRange().upperEndpoint()))\n+                * REORG_CACHE_SIZE_FACTOR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzMzQwNw=="}, "originalCommit": {"oid": "2150ed673052177abe3777fa1376c32a29f3e961"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NjY3NTc5OnYy", "diffSide": "RIGHT", "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/cache/PendingBlockCache.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNTowODozN1rOHfN9AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNDo1ODozM1rOHgCTuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ5NjUxMg==", "bodyText": "I think I'm missing something, why do we need the reversed? Don't we want to keep the lowest block numbers?", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r502496512", "createdAt": "2020-10-09T15:08:37Z", "author": {"login": "RatanRSur"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/cache/PendingBlockCache.java", "diffHunk": "@@ -34,25 +37,39 @@ public PendingBlockCache(final long cacheSizePerPeer) {\n    *\n    * @return the previous value associated with the specified key, or {@code null} if there was no\n    *     mapping for the hash\n-   * @throws IndexOutOfBoundsException if the limit of the number of blocks has been reached for\n-   *     this nodeId\n    */\n   @Override\n   public ImmutablePendingBlock putIfAbsent(\n-      final Hash hash, final ImmutablePendingBlock pendingBlock) throws IndexOutOfBoundsException {\n-    if (getPeerWeight(pendingBlock.nodeId()) >= cacheSizePerPeer) {\n-      throw new IndexOutOfBoundsException();\n+      final Hash hash, final ImmutablePendingBlock pendingBlock) {\n+    final ImmutablePendingBlock foundBlock = super.putIfAbsent(hash, pendingBlock);\n+    if (foundBlock == null) {\n+      removeLowestPriorityBlockWhenCacheFull(pendingBlock.nodeId());\n     }\n-    return super.putIfAbsent(hash, pendingBlock);\n+    return foundBlock;\n   }\n \n   /**\n-   * Returns the number of pending blocks from a node that are stored in the cache\n+   * Removes the lowest priority block if a peer has reached the cache limit it is allowed to use\n+   * The highest priority blocks are those that are lowest in block height and then higher priority\n+   * if they were sent more recently.\n    *\n-   * @param nodeId the peer ID\n-   * @return the number of elements in the cache coming from this node\n+   * @param nodeId id of the peer\n    */\n-  private long getPeerWeight(final Bytes nodeId) {\n-    return values().stream().filter(value -> value.nodeId() == nodeId).count();\n+  private void removeLowestPriorityBlockWhenCacheFull(final Bytes nodeId) {\n+    final List<ImmutablePendingBlock> blockByNodeId =\n+        values().stream().filter(value -> value.nodeId() == nodeId).collect(Collectors.toList());\n+    if (blockByNodeId.size() > cacheSizePerPeer) {\n+      blockByNodeId.stream()\n+          .min(getComparatorByBlockNumber().reversed().thenComparing(getComparatorByTimeStamp()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e49e14b60f3881163016315c23c2c5373c6432"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUxOTY2Ng==", "bodyText": "Yes The minimum will be done on the result after the two comparators.\n\nSorting by block number is by ascending\nReversing order (now it's descending)\nSorting by timestamp is also by ascending .\nGet the minimum\n\nOtherwise the result would be the smallest number block with the smallest timestamp\nLive sample code : sample code to execute\nfinal List<Block> list = new ArrayList<>();\nlist.add(new Block(4,111111));\nlist.add(new Block(1,2222222));\nlist.add(new Block(4,2222222));\nlist.add(new Block(3,3333333));\nWithout reversed :\nBlock{number=1, timestamp=2222222}\nWith reversed:\nBlock{number=4, timestamp=111111}", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r502519666", "createdAt": "2020-10-09T15:45:07Z", "author": {"login": "matkt"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/cache/PendingBlockCache.java", "diffHunk": "@@ -34,25 +37,39 @@ public PendingBlockCache(final long cacheSizePerPeer) {\n    *\n    * @return the previous value associated with the specified key, or {@code null} if there was no\n    *     mapping for the hash\n-   * @throws IndexOutOfBoundsException if the limit of the number of blocks has been reached for\n-   *     this nodeId\n    */\n   @Override\n   public ImmutablePendingBlock putIfAbsent(\n-      final Hash hash, final ImmutablePendingBlock pendingBlock) throws IndexOutOfBoundsException {\n-    if (getPeerWeight(pendingBlock.nodeId()) >= cacheSizePerPeer) {\n-      throw new IndexOutOfBoundsException();\n+      final Hash hash, final ImmutablePendingBlock pendingBlock) {\n+    final ImmutablePendingBlock foundBlock = super.putIfAbsent(hash, pendingBlock);\n+    if (foundBlock == null) {\n+      removeLowestPriorityBlockWhenCacheFull(pendingBlock.nodeId());\n     }\n-    return super.putIfAbsent(hash, pendingBlock);\n+    return foundBlock;\n   }\n \n   /**\n-   * Returns the number of pending blocks from a node that are stored in the cache\n+   * Removes the lowest priority block if a peer has reached the cache limit it is allowed to use\n+   * The highest priority blocks are those that are lowest in block height and then higher priority\n+   * if they were sent more recently.\n    *\n-   * @param nodeId the peer ID\n-   * @return the number of elements in the cache coming from this node\n+   * @param nodeId id of the peer\n    */\n-  private long getPeerWeight(final Bytes nodeId) {\n-    return values().stream().filter(value -> value.nodeId() == nodeId).count();\n+  private void removeLowestPriorityBlockWhenCacheFull(final Bytes nodeId) {\n+    final List<ImmutablePendingBlock> blockByNodeId =\n+        values().stream().filter(value -> value.nodeId() == nodeId).collect(Collectors.toList());\n+    if (blockByNodeId.size() > cacheSizePerPeer) {\n+      blockByNodeId.stream()\n+          .min(getComparatorByBlockNumber().reversed().thenComparing(getComparatorByTimeStamp()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ5NjUxMg=="}, "originalCommit": {"oid": "c3e49e14b60f3881163016315c23c2c5373c6432"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1OTIxMg==", "bodyText": "Right, that's what I thought we wanted. If there's a reorg and a node is sending us new blocks we want to make sure that we keep the ones that are lower because they're the ones we're going to need to import sooner.", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r502559212", "createdAt": "2020-10-09T16:57:48Z", "author": {"login": "RatanRSur"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/cache/PendingBlockCache.java", "diffHunk": "@@ -34,25 +37,39 @@ public PendingBlockCache(final long cacheSizePerPeer) {\n    *\n    * @return the previous value associated with the specified key, or {@code null} if there was no\n    *     mapping for the hash\n-   * @throws IndexOutOfBoundsException if the limit of the number of blocks has been reached for\n-   *     this nodeId\n    */\n   @Override\n   public ImmutablePendingBlock putIfAbsent(\n-      final Hash hash, final ImmutablePendingBlock pendingBlock) throws IndexOutOfBoundsException {\n-    if (getPeerWeight(pendingBlock.nodeId()) >= cacheSizePerPeer) {\n-      throw new IndexOutOfBoundsException();\n+      final Hash hash, final ImmutablePendingBlock pendingBlock) {\n+    final ImmutablePendingBlock foundBlock = super.putIfAbsent(hash, pendingBlock);\n+    if (foundBlock == null) {\n+      removeLowestPriorityBlockWhenCacheFull(pendingBlock.nodeId());\n     }\n-    return super.putIfAbsent(hash, pendingBlock);\n+    return foundBlock;\n   }\n \n   /**\n-   * Returns the number of pending blocks from a node that are stored in the cache\n+   * Removes the lowest priority block if a peer has reached the cache limit it is allowed to use\n+   * The highest priority blocks are those that are lowest in block height and then higher priority\n+   * if they were sent more recently.\n    *\n-   * @param nodeId the peer ID\n-   * @return the number of elements in the cache coming from this node\n+   * @param nodeId id of the peer\n    */\n-  private long getPeerWeight(final Bytes nodeId) {\n-    return values().stream().filter(value -> value.nodeId() == nodeId).count();\n+  private void removeLowestPriorityBlockWhenCacheFull(final Bytes nodeId) {\n+    final List<ImmutablePendingBlock> blockByNodeId =\n+        values().stream().filter(value -> value.nodeId() == nodeId).collect(Collectors.toList());\n+    if (blockByNodeId.size() > cacheSizePerPeer) {\n+      blockByNodeId.stream()\n+          .min(getComparatorByBlockNumber().reversed().thenComparing(getComparatorByTimeStamp()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ5NjUxMg=="}, "originalCommit": {"oid": "c3e49e14b60f3881163016315c23c2c5373c6432"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1OTY3NA==", "bodyText": "They're also the ones we can throw out sooner when they fall out of our import range.", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r502559674", "createdAt": "2020-10-09T16:58:42Z", "author": {"login": "RatanRSur"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/cache/PendingBlockCache.java", "diffHunk": "@@ -34,25 +37,39 @@ public PendingBlockCache(final long cacheSizePerPeer) {\n    *\n    * @return the previous value associated with the specified key, or {@code null} if there was no\n    *     mapping for the hash\n-   * @throws IndexOutOfBoundsException if the limit of the number of blocks has been reached for\n-   *     this nodeId\n    */\n   @Override\n   public ImmutablePendingBlock putIfAbsent(\n-      final Hash hash, final ImmutablePendingBlock pendingBlock) throws IndexOutOfBoundsException {\n-    if (getPeerWeight(pendingBlock.nodeId()) >= cacheSizePerPeer) {\n-      throw new IndexOutOfBoundsException();\n+      final Hash hash, final ImmutablePendingBlock pendingBlock) {\n+    final ImmutablePendingBlock foundBlock = super.putIfAbsent(hash, pendingBlock);\n+    if (foundBlock == null) {\n+      removeLowestPriorityBlockWhenCacheFull(pendingBlock.nodeId());\n     }\n-    return super.putIfAbsent(hash, pendingBlock);\n+    return foundBlock;\n   }\n \n   /**\n-   * Returns the number of pending blocks from a node that are stored in the cache\n+   * Removes the lowest priority block if a peer has reached the cache limit it is allowed to use\n+   * The highest priority blocks are those that are lowest in block height and then higher priority\n+   * if they were sent more recently.\n    *\n-   * @param nodeId the peer ID\n-   * @return the number of elements in the cache coming from this node\n+   * @param nodeId id of the peer\n    */\n-  private long getPeerWeight(final Bytes nodeId) {\n-    return values().stream().filter(value -> value.nodeId() == nodeId).count();\n+  private void removeLowestPriorityBlockWhenCacheFull(final Bytes nodeId) {\n+    final List<ImmutablePendingBlock> blockByNodeId =\n+        values().stream().filter(value -> value.nodeId() == nodeId).collect(Collectors.toList());\n+    if (blockByNodeId.size() > cacheSizePerPeer) {\n+      blockByNodeId.stream()\n+          .min(getComparatorByBlockNumber().reversed().thenComparing(getComparatorByTimeStamp()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ5NjUxMg=="}, "originalCommit": {"oid": "c3e49e14b60f3881163016315c23c2c5373c6432"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU2ODA0MA==", "bodyText": "yes that's what this code does.  we get the block that we want to replace", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r502568040", "createdAt": "2020-10-09T17:15:32Z", "author": {"login": "matkt"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/cache/PendingBlockCache.java", "diffHunk": "@@ -34,25 +37,39 @@ public PendingBlockCache(final long cacheSizePerPeer) {\n    *\n    * @return the previous value associated with the specified key, or {@code null} if there was no\n    *     mapping for the hash\n-   * @throws IndexOutOfBoundsException if the limit of the number of blocks has been reached for\n-   *     this nodeId\n    */\n   @Override\n   public ImmutablePendingBlock putIfAbsent(\n-      final Hash hash, final ImmutablePendingBlock pendingBlock) throws IndexOutOfBoundsException {\n-    if (getPeerWeight(pendingBlock.nodeId()) >= cacheSizePerPeer) {\n-      throw new IndexOutOfBoundsException();\n+      final Hash hash, final ImmutablePendingBlock pendingBlock) {\n+    final ImmutablePendingBlock foundBlock = super.putIfAbsent(hash, pendingBlock);\n+    if (foundBlock == null) {\n+      removeLowestPriorityBlockWhenCacheFull(pendingBlock.nodeId());\n     }\n-    return super.putIfAbsent(hash, pendingBlock);\n+    return foundBlock;\n   }\n \n   /**\n-   * Returns the number of pending blocks from a node that are stored in the cache\n+   * Removes the lowest priority block if a peer has reached the cache limit it is allowed to use\n+   * The highest priority blocks are those that are lowest in block height and then higher priority\n+   * if they were sent more recently.\n    *\n-   * @param nodeId the peer ID\n-   * @return the number of elements in the cache coming from this node\n+   * @param nodeId id of the peer\n    */\n-  private long getPeerWeight(final Bytes nodeId) {\n-    return values().stream().filter(value -> value.nodeId() == nodeId).count();\n+  private void removeLowestPriorityBlockWhenCacheFull(final Bytes nodeId) {\n+    final List<ImmutablePendingBlock> blockByNodeId =\n+        values().stream().filter(value -> value.nodeId() == nodeId).collect(Collectors.toList());\n+    if (blockByNodeId.size() > cacheSizePerPeer) {\n+      blockByNodeId.stream()\n+          .min(getComparatorByBlockNumber().reversed().thenComparing(getComparatorByTimeStamp()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ5NjUxMg=="}, "originalCommit": {"oid": "c3e49e14b60f3881163016315c23c2c5373c6432"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI4MjYxMw==", "bodyText": "Step by step :\nAt the beginning :\nlist.add(new Block(4,111111));\nlist.add(new Block(1,2222222));\nlist.add(new Block(4,2222222));\nlist.add(new Block(3,3333333));\n1- After getComparatorByBlockNumber:\nBlock{number=1, timestamp=2222222}\nBlock{number=3, timestamp=3333333}\nBlock{number=4, timestamp=111111}\nBlock{number=4, timestamp=2222222}\n2- After reversed :\nBlock{number=4, timestamp=2222222}\nBlock{number=4, timestamp=111111}\nBlock{number=3, timestamp=3333333}\nBlock{number=1, timestamp=2222222}\n3- After getComparatorByTimeStamp :\nBlock{number=4, timestamp=111111}\nBlock{number=4, timestamp=2222222}\nBlock{number=3, timestamp=3333333}\nBlock{number=1, timestamp=2222222}\n4- After min\nBlock{number=4, timestamp=111111}\n-> Replace Block{number=4, timestamp=111111} (lowest priority)", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r503282613", "createdAt": "2020-10-12T13:05:44Z", "author": {"login": "matkt"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/cache/PendingBlockCache.java", "diffHunk": "@@ -34,25 +37,39 @@ public PendingBlockCache(final long cacheSizePerPeer) {\n    *\n    * @return the previous value associated with the specified key, or {@code null} if there was no\n    *     mapping for the hash\n-   * @throws IndexOutOfBoundsException if the limit of the number of blocks has been reached for\n-   *     this nodeId\n    */\n   @Override\n   public ImmutablePendingBlock putIfAbsent(\n-      final Hash hash, final ImmutablePendingBlock pendingBlock) throws IndexOutOfBoundsException {\n-    if (getPeerWeight(pendingBlock.nodeId()) >= cacheSizePerPeer) {\n-      throw new IndexOutOfBoundsException();\n+      final Hash hash, final ImmutablePendingBlock pendingBlock) {\n+    final ImmutablePendingBlock foundBlock = super.putIfAbsent(hash, pendingBlock);\n+    if (foundBlock == null) {\n+      removeLowestPriorityBlockWhenCacheFull(pendingBlock.nodeId());\n     }\n-    return super.putIfAbsent(hash, pendingBlock);\n+    return foundBlock;\n   }\n \n   /**\n-   * Returns the number of pending blocks from a node that are stored in the cache\n+   * Removes the lowest priority block if a peer has reached the cache limit it is allowed to use\n+   * The highest priority blocks are those that are lowest in block height and then higher priority\n+   * if they were sent more recently.\n    *\n-   * @param nodeId the peer ID\n-   * @return the number of elements in the cache coming from this node\n+   * @param nodeId id of the peer\n    */\n-  private long getPeerWeight(final Bytes nodeId) {\n-    return values().stream().filter(value -> value.nodeId() == nodeId).count();\n+  private void removeLowestPriorityBlockWhenCacheFull(final Bytes nodeId) {\n+    final List<ImmutablePendingBlock> blockByNodeId =\n+        values().stream().filter(value -> value.nodeId() == nodeId).collect(Collectors.toList());\n+    if (blockByNodeId.size() > cacheSizePerPeer) {\n+      blockByNodeId.stream()\n+          .min(getComparatorByBlockNumber().reversed().thenComparing(getComparatorByTimeStamp()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ5NjUxMg=="}, "originalCommit": {"oid": "c3e49e14b60f3881163016315c23c2c5373c6432"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM1NDI5Nw==", "bodyText": "Oh yeah, you're right :)", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r503354297", "createdAt": "2020-10-12T14:58:33Z", "author": {"login": "RatanRSur"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/cache/PendingBlockCache.java", "diffHunk": "@@ -34,25 +37,39 @@ public PendingBlockCache(final long cacheSizePerPeer) {\n    *\n    * @return the previous value associated with the specified key, or {@code null} if there was no\n    *     mapping for the hash\n-   * @throws IndexOutOfBoundsException if the limit of the number of blocks has been reached for\n-   *     this nodeId\n    */\n   @Override\n   public ImmutablePendingBlock putIfAbsent(\n-      final Hash hash, final ImmutablePendingBlock pendingBlock) throws IndexOutOfBoundsException {\n-    if (getPeerWeight(pendingBlock.nodeId()) >= cacheSizePerPeer) {\n-      throw new IndexOutOfBoundsException();\n+      final Hash hash, final ImmutablePendingBlock pendingBlock) {\n+    final ImmutablePendingBlock foundBlock = super.putIfAbsent(hash, pendingBlock);\n+    if (foundBlock == null) {\n+      removeLowestPriorityBlockWhenCacheFull(pendingBlock.nodeId());\n     }\n-    return super.putIfAbsent(hash, pendingBlock);\n+    return foundBlock;\n   }\n \n   /**\n-   * Returns the number of pending blocks from a node that are stored in the cache\n+   * Removes the lowest priority block if a peer has reached the cache limit it is allowed to use\n+   * The highest priority blocks are those that are lowest in block height and then higher priority\n+   * if they were sent more recently.\n    *\n-   * @param nodeId the peer ID\n-   * @return the number of elements in the cache coming from this node\n+   * @param nodeId id of the peer\n    */\n-  private long getPeerWeight(final Bytes nodeId) {\n-    return values().stream().filter(value -> value.nodeId() == nodeId).count();\n+  private void removeLowestPriorityBlockWhenCacheFull(final Bytes nodeId) {\n+    final List<ImmutablePendingBlock> blockByNodeId =\n+        values().stream().filter(value -> value.nodeId() == nodeId).collect(Collectors.toList());\n+    if (blockByNodeId.size() > cacheSizePerPeer) {\n+      blockByNodeId.stream()\n+          .min(getComparatorByBlockNumber().reversed().thenComparing(getComparatorByTimeStamp()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ5NjUxMg=="}, "originalCommit": {"oid": "c3e49e14b60f3881163016315c23c2c5373c6432"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NzA5Nzc4OnYy", "diffSide": "RIGHT", "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/cache/PendingBlockCache.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNzowMzo1NlrOHfR-ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNzowMzo1NlrOHfR-ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU2MjQwNA==", "bodyText": "(optional) Regardless of the outcome of the other thread, if you want you can also represent this with stream operations:\n    values().stream()\n        .filter(value -> value.nodeId() == nodeId)\n        .sorted(comparatorThatHasTheHighestPriorityFirst)\n        .skip(cacheSizePerPeer)\n        .forEach(value -> remove(value.block().getHash()));", "url": "https://github.com/hyperledger/besu/pull/1406#discussion_r502562404", "createdAt": "2020-10-09T17:03:56Z", "author": {"login": "RatanRSur"}, "path": "ethereum/eth/src/main/java/org/hyperledger/besu/ethereum/eth/sync/state/cache/PendingBlockCache.java", "diffHunk": "@@ -34,25 +37,39 @@ public PendingBlockCache(final long cacheSizePerPeer) {\n    *\n    * @return the previous value associated with the specified key, or {@code null} if there was no\n    *     mapping for the hash\n-   * @throws IndexOutOfBoundsException if the limit of the number of blocks has been reached for\n-   *     this nodeId\n    */\n   @Override\n   public ImmutablePendingBlock putIfAbsent(\n-      final Hash hash, final ImmutablePendingBlock pendingBlock) throws IndexOutOfBoundsException {\n-    if (getPeerWeight(pendingBlock.nodeId()) >= cacheSizePerPeer) {\n-      throw new IndexOutOfBoundsException();\n+      final Hash hash, final ImmutablePendingBlock pendingBlock) {\n+    final ImmutablePendingBlock foundBlock = super.putIfAbsent(hash, pendingBlock);\n+    if (foundBlock == null) {\n+      removeLowestPriorityBlockWhenCacheFull(pendingBlock.nodeId());\n     }\n-    return super.putIfAbsent(hash, pendingBlock);\n+    return foundBlock;\n   }\n \n   /**\n-   * Returns the number of pending blocks from a node that are stored in the cache\n+   * Removes the lowest priority block if a peer has reached the cache limit it is allowed to use\n+   * The highest priority blocks are those that are lowest in block height and then higher priority\n+   * if they were sent more recently.\n    *\n-   * @param nodeId the peer ID\n-   * @return the number of elements in the cache coming from this node\n+   * @param nodeId id of the peer\n    */\n-  private long getPeerWeight(final Bytes nodeId) {\n-    return values().stream().filter(value -> value.nodeId() == nodeId).count();\n+  private void removeLowestPriorityBlockWhenCacheFull(final Bytes nodeId) {\n+    final List<ImmutablePendingBlock> blockByNodeId =\n+        values().stream().filter(value -> value.nodeId() == nodeId).collect(Collectors.toList());\n+    if (blockByNodeId.size() > cacheSizePerPeer) {\n+      blockByNodeId.stream()\n+          .min(getComparatorByBlockNumber().reversed().thenComparing(getComparatorByTimeStamp()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e49e14b60f3881163016315c23c2c5373c6432"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1405, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}