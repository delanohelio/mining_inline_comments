{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwNjM4NzA4", "number": 1440, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMTowOToyMlrOEsMqtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMToxNTowN1rOEsMvzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NzgwMzQzOnYy", "diffSide": "RIGHT", "path": "ethereum/p2p/src/main/java/org/hyperledger/besu/ethereum/p2p/rlpx/RlpxAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMTowOToyMlrOHfYrpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMTowOToyMlrOHfYrpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY3MjI5NQ==", "bodyText": "I'd add some commentary about the purpose.  Something about the scope (per agent) and purpose (to thwart external gaming of the random comparison).", "url": "https://github.com/hyperledger/besu/pull/1440#discussion_r502672295", "createdAt": "2020-10-09T21:09:22Z", "author": {"login": "shemnon"}, "path": "ethereum/p2p/src/main/java/org/hyperledger/besu/ethereum/p2p/rlpx/RlpxAgent.java", "diffHunk": "@@ -67,7 +68,9 @@\n   private final PeerRlpxPermissions peerPermissions;\n   private final PeerPrivileges peerPrivileges;\n   private final int maxConnections;\n+  private final boolean randomPeerPriority;\n   private final int maxRemotelyInitiatedConnections;\n+  private final Bytes nodeIdMask = Bytes.random(SECP256K1.PublicKey.BYTE_LENGTH);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09cbfbfc84a27c8c357eade9c94d50862d122702"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NzgwNjczOnYy", "diffSide": "RIGHT", "path": "ethereum/p2p/src/main/java/org/hyperledger/besu/ethereum/p2p/rlpx/RlpxAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMToxMDozOVrOHfYtlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNDo1Mjo1NVrOHgCFBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY3Mjc5MA==", "bodyText": "Randomly feels like the wrong name.  While the mask is random once it's set it doesn't change. compareByMaskedNodeId?", "url": "https://github.com/hyperledger/besu/pull/1440#discussion_r502672790", "createdAt": "2020-10-09T21:10:39Z", "author": {"login": "shemnon"}, "path": "ethereum/p2p/src/main/java/org/hyperledger/besu/ethereum/p2p/rlpx/RlpxAgent.java", "diffHunk": "@@ -463,21 +471,29 @@ private void enforceConnectionLimits() {\n   private Stream<RlpxConnection> getActivePrioritizedConnections() {\n     return connectionsById.values().stream()\n         .filter(RlpxConnection::isActive)\n-        .sorted(this::prioritizeConnections);\n+        .sorted(this::comparePeerPriorities);\n   }\n \n-  private int prioritizeConnections(final RlpxConnection a, final RlpxConnection b) {\n+  private int comparePeerPriorities(final RlpxConnection a, final RlpxConnection b) {\n     final boolean aIgnoresPeerLimits = peerPrivileges.canExceedConnectionLimits(a.getPeer());\n     final boolean bIgnoresPeerLimits = peerPrivileges.canExceedConnectionLimits(b.getPeer());\n     if (aIgnoresPeerLimits && !bIgnoresPeerLimits) {\n       return -1;\n     } else if (bIgnoresPeerLimits && !aIgnoresPeerLimits) {\n       return 1;\n     } else {\n-      return Math.toIntExact(a.getInitiatedAt() - b.getInitiatedAt());\n+      return randomPeerPriority ? compareRandomly(a, b) : compareConnectionInitiationTimes(a, b);\n     }\n   }\n \n+  private int compareConnectionInitiationTimes(final RlpxConnection a, final RlpxConnection b) {\n+    return Math.toIntExact(a.getInitiatedAt() - b.getInitiatedAt());\n+  }\n+\n+  private int compareRandomly(final RlpxConnection a, final RlpxConnection b) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09cbfbfc84a27c8c357eade9c94d50862d122702"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM1MDUzNA==", "bodyText": "Yeah, I felt similarly when writing it. I like your suggestion.", "url": "https://github.com/hyperledger/besu/pull/1440#discussion_r503350534", "createdAt": "2020-10-12T14:52:55Z", "author": {"login": "RatanRSur"}, "path": "ethereum/p2p/src/main/java/org/hyperledger/besu/ethereum/p2p/rlpx/RlpxAgent.java", "diffHunk": "@@ -463,21 +471,29 @@ private void enforceConnectionLimits() {\n   private Stream<RlpxConnection> getActivePrioritizedConnections() {\n     return connectionsById.values().stream()\n         .filter(RlpxConnection::isActive)\n-        .sorted(this::prioritizeConnections);\n+        .sorted(this::comparePeerPriorities);\n   }\n \n-  private int prioritizeConnections(final RlpxConnection a, final RlpxConnection b) {\n+  private int comparePeerPriorities(final RlpxConnection a, final RlpxConnection b) {\n     final boolean aIgnoresPeerLimits = peerPrivileges.canExceedConnectionLimits(a.getPeer());\n     final boolean bIgnoresPeerLimits = peerPrivileges.canExceedConnectionLimits(b.getPeer());\n     if (aIgnoresPeerLimits && !bIgnoresPeerLimits) {\n       return -1;\n     } else if (bIgnoresPeerLimits && !aIgnoresPeerLimits) {\n       return 1;\n     } else {\n-      return Math.toIntExact(a.getInitiatedAt() - b.getInitiatedAt());\n+      return randomPeerPriority ? compareRandomly(a, b) : compareConnectionInitiationTimes(a, b);\n     }\n   }\n \n+  private int compareConnectionInitiationTimes(final RlpxConnection a, final RlpxConnection b) {\n+    return Math.toIntExact(a.getInitiatedAt() - b.getInitiatedAt());\n+  }\n+\n+  private int compareRandomly(final RlpxConnection a, final RlpxConnection b) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY3Mjc5MA=="}, "originalCommit": {"oid": "09cbfbfc84a27c8c357eade9c94d50862d122702"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NzgxNjQ1OnYy", "diffSide": "RIGHT", "path": "ethereum/p2p/src/test/java/org/hyperledger/besu/ethereum/p2p/rlpx/RlpxAgentTest.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMToxNTowN1rOHfYzog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNjo0Nzo1NFrOHgGGvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY3NDMzOA==", "bodyText": "Perhaps we should white box this test.\nGo ahead and set up the pool and the peer randomly, but then get the peer that would be evicted (sorted last), then generate peers until we get one that we see is higher priority than the one to be evicted, and then only once do the add check loop.  We would need to get at the peers list and the nodeIdMask to do this, hence the white boxing.", "url": "https://github.com/hyperledger/besu/pull/1440#discussion_r502674338", "createdAt": "2020-10-09T21:15:07Z", "author": {"login": "shemnon"}, "path": "ethereum/p2p/src/test/java/org/hyperledger/besu/ethereum/p2p/rlpx/RlpxAgentTest.java", "diffHunk": "@@ -321,6 +323,41 @@ public void incomingConnection_maxPeersExceeded()\n     }\n   }\n \n+  @Test\n+  public void incomingConnection_succeedsEventuallyWithRandomPeerPrioritization() {\n+    // Saturate connections with one local and one remote\n+    startAgentWithMaxPeers(2, builder -> builder.randomPeerPriority(true));\n+    agent.connect(createPeer());\n+    connectionInitializer.simulateIncomingConnection(connection(createPeer()));\n+    // Sanity check\n+    assertThat(agent.getConnectionCount()).isEqualTo(2);\n+\n+    boolean newConnectionDisconnected = false;\n+    boolean oldConnectionDisconnected = false;\n+    // With very high probability we should see the connections churn\n+    for (int i = 0; i < 1000; ++i) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09cbfbfc84a27c8c357eade9c94d50862d122702"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY3NDg3NA==", "bodyText": "We also need a test case where the new node doesn't get added because it's going to sort below all the other nodes.  So we need another test with the same white box setup but instead we search for a node that will rank below all other nodes.", "url": "https://github.com/hyperledger/besu/pull/1440#discussion_r502674874", "createdAt": "2020-10-09T21:16:31Z", "author": {"login": "shemnon"}, "path": "ethereum/p2p/src/test/java/org/hyperledger/besu/ethereum/p2p/rlpx/RlpxAgentTest.java", "diffHunk": "@@ -321,6 +323,41 @@ public void incomingConnection_maxPeersExceeded()\n     }\n   }\n \n+  @Test\n+  public void incomingConnection_succeedsEventuallyWithRandomPeerPrioritization() {\n+    // Saturate connections with one local and one remote\n+    startAgentWithMaxPeers(2, builder -> builder.randomPeerPriority(true));\n+    agent.connect(createPeer());\n+    connectionInitializer.simulateIncomingConnection(connection(createPeer()));\n+    // Sanity check\n+    assertThat(agent.getConnectionCount()).isEqualTo(2);\n+\n+    boolean newConnectionDisconnected = false;\n+    boolean oldConnectionDisconnected = false;\n+    // With very high probability we should see the connections churn\n+    for (int i = 0; i < 1000; ++i) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY3NDMzOA=="}, "originalCommit": {"oid": "09cbfbfc84a27c8c357eade9c94d50862d122702"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM2Mzg3Nw==", "bodyText": "Is the only reason to make the test deterministic?", "url": "https://github.com/hyperledger/besu/pull/1440#discussion_r503363877", "createdAt": "2020-10-12T15:14:17Z", "author": {"login": "RatanRSur"}, "path": "ethereum/p2p/src/test/java/org/hyperledger/besu/ethereum/p2p/rlpx/RlpxAgentTest.java", "diffHunk": "@@ -321,6 +323,41 @@ public void incomingConnection_maxPeersExceeded()\n     }\n   }\n \n+  @Test\n+  public void incomingConnection_succeedsEventuallyWithRandomPeerPrioritization() {\n+    // Saturate connections with one local and one remote\n+    startAgentWithMaxPeers(2, builder -> builder.randomPeerPriority(true));\n+    agent.connect(createPeer());\n+    connectionInitializer.simulateIncomingConnection(connection(createPeer()));\n+    // Sanity check\n+    assertThat(agent.getConnectionCount()).isEqualTo(2);\n+\n+    boolean newConnectionDisconnected = false;\n+    boolean oldConnectionDisconnected = false;\n+    // With very high probability we should see the connections churn\n+    for (int i = 0; i < 1000; ++i) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY3NDMzOA=="}, "originalCommit": {"oid": "09cbfbfc84a27c8c357eade9c94d50862d122702"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM3MTI2OA==", "bodyText": "If that's the only benefit, I think I prefer black boxing it because I've run into a lot of problems with changing code that has very whiteboxed testing in p2p. With the number of iterations we do here and the number of remote connections (1), this is an intermittent test with a very very low probability of failing.", "url": "https://github.com/hyperledger/besu/pull/1440#discussion_r503371268", "createdAt": "2020-10-12T15:26:22Z", "author": {"login": "RatanRSur"}, "path": "ethereum/p2p/src/test/java/org/hyperledger/besu/ethereum/p2p/rlpx/RlpxAgentTest.java", "diffHunk": "@@ -321,6 +323,41 @@ public void incomingConnection_maxPeersExceeded()\n     }\n   }\n \n+  @Test\n+  public void incomingConnection_succeedsEventuallyWithRandomPeerPrioritization() {\n+    // Saturate connections with one local and one remote\n+    startAgentWithMaxPeers(2, builder -> builder.randomPeerPriority(true));\n+    agent.connect(createPeer());\n+    connectionInitializer.simulateIncomingConnection(connection(createPeer()));\n+    // Sanity check\n+    assertThat(agent.getConnectionCount()).isEqualTo(2);\n+\n+    boolean newConnectionDisconnected = false;\n+    boolean oldConnectionDisconnected = false;\n+    // With very high probability we should see the connections churn\n+    for (int i = 0; i < 1000; ++i) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY3NDMzOA=="}, "originalCommit": {"oid": "09cbfbfc84a27c8c357eade9c94d50862d122702"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQxNjUwOQ==", "bodyText": "If we are going to black box it we still need to detect connection accepted and connection rejected.", "url": "https://github.com/hyperledger/besu/pull/1440#discussion_r503416509", "createdAt": "2020-10-12T16:47:54Z", "author": {"login": "shemnon"}, "path": "ethereum/p2p/src/test/java/org/hyperledger/besu/ethereum/p2p/rlpx/RlpxAgentTest.java", "diffHunk": "@@ -321,6 +323,41 @@ public void incomingConnection_maxPeersExceeded()\n     }\n   }\n \n+  @Test\n+  public void incomingConnection_succeedsEventuallyWithRandomPeerPrioritization() {\n+    // Saturate connections with one local and one remote\n+    startAgentWithMaxPeers(2, builder -> builder.randomPeerPriority(true));\n+    agent.connect(createPeer());\n+    connectionInitializer.simulateIncomingConnection(connection(createPeer()));\n+    // Sanity check\n+    assertThat(agent.getConnectionCount()).isEqualTo(2);\n+\n+    boolean newConnectionDisconnected = false;\n+    boolean oldConnectionDisconnected = false;\n+    // With very high probability we should see the connections churn\n+    for (int i = 0; i < 1000; ++i) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY3NDMzOA=="}, "originalCommit": {"oid": "09cbfbfc84a27c8c357eade9c94d50862d122702"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1433, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}