{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwNjUwODM5", "number": 5495, "title": "Add TestMemSqlDistributedQueries and implement gaps", "bodyText": "Fixes #5369.", "createdAt": "2020-10-09T15:02:06Z", "url": "https://github.com/trinodb/trino/pull/5495", "merged": true, "mergeCommit": {"oid": "79e5ec8a3edf41d127a0221fd2c1b22dd859233c"}, "closed": true, "closedAt": "2020-10-22T14:50:42Z", "author": {"login": "hashhar"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdRwmlSAFqTUwNjQwOTI0Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdVAX-fAH2gAyNTAwNjUwODM5OjUzM2E4NjNmNjJiYzM3YmYzMTUyNjQ5YjJkYWI2ZDU3MjM1NTg1ZDQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NDA5MjQy", "url": "https://github.com/trinodb/trino/pull/5495#pullrequestreview-506409242", "createdAt": "2020-10-12T08:38:19Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwODozODoxOVrOHf0qQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwOTozMDo1MlrOHf2r-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEzMDY5MA==", "bodyText": "Fixes #5263", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r503130690", "createdAt": "2020-10-12T08:38:19Z", "author": {"login": "hashhar"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -88,6 +132,118 @@ protected String getTableSchemaName(ResultSet resultSet)\n         return resultSet.getString(\"TABLE_CAT\");\n     }\n \n+    @Override\n+    public Optional<ColumnMapping> toPrestoType(ConnectorSession session, Connection connection, JdbcTypeHandle typeHandle)\n+    {\n+        String jdbcTypeName = typeHandle.getJdbcTypeName()\n+                .orElseThrow(() -> new PrestoException(JDBC_ERROR, \"Type name is missing: \" + typeHandle));\n+\n+        Optional<ColumnMapping> mapping = getForcedMappingToVarchar(typeHandle);\n+        if (mapping.isPresent()) {\n+            return mapping;\n+        }\n+        Optional<ColumnMapping> unsignedMapping = getUnsignedMapping(typeHandle);\n+        if (unsignedMapping.isPresent()) {\n+            return unsignedMapping;\n+        }\n+\n+        if (jdbcTypeName.equalsIgnoreCase(\"json\")) {\n+            return Optional.of(jsonColumnMapping());\n+        }\n+\n+        int columnSize = typeHandle.getColumnSize();\n+        switch (typeHandle.getJdbcType()) {\n+            // TODO not all these type constants are necessarily used by the JDBC driver\n+            case Types.VARCHAR:\n+            case Types.NVARCHAR:\n+            case Types.LONGVARCHAR:\n+            case Types.LONGNVARCHAR:\n+                VarcharType varcharType = (columnSize <= VarcharType.MAX_LENGTH) ? createVarcharType(columnSize) : createUnboundedVarcharType();\n+                // Remote database can be case insensitive.\n+                PredicatePushdownController predicatePushdownController = PUSHDOWN_AND_KEEP;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE0MjYwOA==", "bodyText": "Have skipped implementing decimal_rounding_mode in this PR since I wasn't clear on the purpose.", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r503142608", "createdAt": "2020-10-12T08:57:32Z", "author": {"login": "hashhar"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -88,6 +132,118 @@ protected String getTableSchemaName(ResultSet resultSet)\n         return resultSet.getString(\"TABLE_CAT\");\n     }\n \n+    @Override\n+    public Optional<ColumnMapping> toPrestoType(ConnectorSession session, Connection connection, JdbcTypeHandle typeHandle)\n+    {\n+        String jdbcTypeName = typeHandle.getJdbcTypeName()\n+                .orElseThrow(() -> new PrestoException(JDBC_ERROR, \"Type name is missing: \" + typeHandle));\n+\n+        Optional<ColumnMapping> mapping = getForcedMappingToVarchar(typeHandle);\n+        if (mapping.isPresent()) {\n+            return mapping;\n+        }\n+        Optional<ColumnMapping> unsignedMapping = getUnsignedMapping(typeHandle);\n+        if (unsignedMapping.isPresent()) {\n+            return unsignedMapping;\n+        }\n+\n+        if (jdbcTypeName.equalsIgnoreCase(\"json\")) {\n+            return Optional.of(jsonColumnMapping());\n+        }\n+\n+        int columnSize = typeHandle.getColumnSize();\n+        switch (typeHandle.getJdbcType()) {\n+            // TODO not all these type constants are necessarily used by the JDBC driver\n+            case Types.VARCHAR:\n+            case Types.NVARCHAR:\n+            case Types.LONGVARCHAR:\n+            case Types.LONGNVARCHAR:\n+                VarcharType varcharType = (columnSize <= VarcharType.MAX_LENGTH) ? createVarcharType(columnSize) : createUnboundedVarcharType();\n+                // Remote database can be case insensitive.\n+                PredicatePushdownController predicatePushdownController = PUSHDOWN_AND_KEEP;\n+                return Optional.of(ColumnMapping.sliceMapping(varcharType, varcharReadFunction(varcharType), varcharWriteFunction(), predicatePushdownController));\n+            // TODO handle decimals if decimal_rounding_mode session property is needed", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE1MjcyMw==", "bodyText": "The SQL State constants are not present in MariaDB client (or I wasn't able to find them).", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r503152723", "createdAt": "2020-10-12T09:13:24Z", "author": {"login": "hashhar"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -88,6 +132,118 @@ protected String getTableSchemaName(ResultSet resultSet)\n         return resultSet.getString(\"TABLE_CAT\");\n     }\n \n+    @Override\n+    public Optional<ColumnMapping> toPrestoType(ConnectorSession session, Connection connection, JdbcTypeHandle typeHandle)\n+    {\n+        String jdbcTypeName = typeHandle.getJdbcTypeName()\n+                .orElseThrow(() -> new PrestoException(JDBC_ERROR, \"Type name is missing: \" + typeHandle));\n+\n+        Optional<ColumnMapping> mapping = getForcedMappingToVarchar(typeHandle);\n+        if (mapping.isPresent()) {\n+            return mapping;\n+        }\n+        Optional<ColumnMapping> unsignedMapping = getUnsignedMapping(typeHandle);\n+        if (unsignedMapping.isPresent()) {\n+            return unsignedMapping;\n+        }\n+\n+        if (jdbcTypeName.equalsIgnoreCase(\"json\")) {\n+            return Optional.of(jsonColumnMapping());\n+        }\n+\n+        int columnSize = typeHandle.getColumnSize();\n+        switch (typeHandle.getJdbcType()) {\n+            // TODO not all these type constants are necessarily used by the JDBC driver\n+            case Types.VARCHAR:\n+            case Types.NVARCHAR:\n+            case Types.LONGVARCHAR:\n+            case Types.LONGNVARCHAR:\n+                VarcharType varcharType = (columnSize <= VarcharType.MAX_LENGTH) ? createVarcharType(columnSize) : createUnboundedVarcharType();\n+                // Remote database can be case insensitive.\n+                PredicatePushdownController predicatePushdownController = PUSHDOWN_AND_KEEP;\n+                return Optional.of(ColumnMapping.sliceMapping(varcharType, varcharReadFunction(varcharType), varcharWriteFunction(), predicatePushdownController));\n+            // TODO handle decimals if decimal_rounding_mode session property is needed\n+        }\n+\n+        // TODO add explicit mappings\n+        return super.toPrestoType(session, connection, typeHandle);\n+    }\n+\n+    @Override\n+    public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n+    {\n+        if (REAL.equals(type)) {\n+            return WriteMapping.longMapping(\"float\", realWriteFunction());\n+        }\n+        // TODO implement TIME types\n+        // TODO add support for other TIMESTAMP precisions\n+        if (TIMESTAMP_MILLIS.equals(type)) {\n+            return WriteMapping.longMapping(\"datetime\", timestampWriteFunction(TIMESTAMP_MILLIS));\n+        }\n+        if (VARBINARY.equals(type)) {\n+            return WriteMapping.sliceMapping(\"mediumblob\", varbinaryWriteFunction());\n+        }\n+        if (type instanceof VarcharType) {\n+            VarcharType varcharType = (VarcharType) type;\n+            String dataType;\n+            if (varcharType.isUnbounded()) {\n+                dataType = \"longtext\";\n+            }\n+            else if (varcharType.getBoundedLength() <= 255) {\n+                dataType = \"tinytext\";\n+            }\n+            else if (varcharType.getBoundedLength() <= 65535) {\n+                dataType = \"text\";\n+            }\n+            else if (varcharType.getBoundedLength() <= 16777215) {\n+                dataType = \"mediumtext\";\n+            }\n+            else {\n+                dataType = \"longtext\";\n+            }\n+            return WriteMapping.sliceMapping(dataType, varcharWriteFunction());\n+        }\n+        if (type.equals(jsonType)) {\n+            return WriteMapping.sliceMapping(\"json\", varcharWriteFunction());\n+        }\n+\n+        return super.toWriteMapping(session, type);\n+    }\n+\n+    @Override\n+    public void renameColumn(JdbcIdentity identity, JdbcTableHandle handle, JdbcColumnHandle jdbcColumn, String newColumnName)\n+    {\n+        try (Connection connection = connectionFactory.openConnection(identity)) {\n+            DatabaseMetaData metadata = connection.getMetaData();\n+            if (metadata.storesUpperCaseIdentifiers()) {\n+                newColumnName = newColumnName.toUpperCase(ENGLISH);\n+            }\n+            String sql = format(\n+                    \"ALTER TABLE %s CHANGE %s %s\",\n+                    quoted(handle.getCatalogName(), handle.getSchemaName(), handle.getTableName()),\n+                    quoted(jdbcColumn.getColumnName()),\n+                    quoted(newColumnName));\n+            execute(connection, sql);\n+        }\n+        catch (SQLException e) {\n+            // MemSQL versions earlier than 5.7 do not support the above CHANGE syntax\n+            // TODO Does importing MySQL driver just for SQL_STATE_SYNTAX_ERROR make sense?\n+            if (\"42000\".equals(e.getSQLState())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE1NDc3OA==", "bodyText": "This test is overridden from AbstractTestDistributedQueries since the TPCH catalog in MemSQL has non-standard VARCHAR types. eg. orderpriority varchar(1) shows up as varchar(255) etc.\nShould this test be skipped with a comment?", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r503154778", "createdAt": "2020-10-12T09:16:34Z", "author": {"login": "hashhar"}, "path": "presto-memsql/src/test/java/io/prestosql/plugin/memsql/TestMemSqlDistributedQueries.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.memsql;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.testing.AbstractTestDistributedQueries;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.sql.SqlExecutor;\n+import io.prestosql.testing.sql.TestTable;\n+import io.prestosql.tpch.TpchTable;\n+import org.testng.SkipException;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.memsql.MemSqlQueryRunner.createMemSqlQueryRunner;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.testing.MaterializedResult.resultBuilder;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestMemSqlDistributedQueries\n+        extends AbstractTestDistributedQueries\n+{\n+    protected TestingMemSqlServer memSqlServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        memSqlServer = new TestingMemSqlServer();\n+        closeAfterClass(() -> {\n+            memSqlServer.close();\n+            memSqlServer = null;\n+        });\n+        return createMemSqlQueryRunner(\n+                memSqlServer,\n+                ImmutableMap.<String, String>builder()\n+                        // caching here speeds up tests highly, caching is not used in smoke tests\n+                        .put(\"metadata.cache-ttl\", \"10m\")\n+                        .put(\"metadata.cache-missing\", \"true\")\n+                        .build(),\n+                TpchTable.getTables());\n+    }\n+\n+    @Override\n+    protected boolean supportsDelete()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean supportsViews()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean supportsArrays()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean supportsCommentOnTable()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean supportsCommentOnColumn()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected TestTable createTableWithDefaultColumns()\n+    {\n+        return new TestTable(\n+                createJdbcSqlExecutor(),\n+                \"tpch.table\",\n+                \"(col_required BIGINT NOT NULL,\" +\n+                        \"col_nullable BIGINT,\" +\n+                        \"col_default BIGINT DEFAULT 43,\" +\n+                        \"col_nonnull_default BIGINT NOT NULL DEFAULT 42,\" +\n+                        \"col_required2 BIGINT NOT NULL)\");\n+    }\n+\n+    @Override\n+    public void testShowColumns()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE1NTU5NQ==", "bodyText": "This test works for MySQL but fails for MemSQL. Manually running the generated SQL against MemSQL doesn't throw this error. Will need to dig deeper for this.", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r503155595", "createdAt": "2020-10-12T09:17:57Z", "author": {"login": "hashhar"}, "path": "presto-memsql/src/test/java/io/prestosql/plugin/memsql/TestMemSqlDistributedQueries.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.memsql;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.testing.AbstractTestDistributedQueries;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.sql.SqlExecutor;\n+import io.prestosql.testing.sql.TestTable;\n+import io.prestosql.tpch.TpchTable;\n+import org.testng.SkipException;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.memsql.MemSqlQueryRunner.createMemSqlQueryRunner;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.testing.MaterializedResult.resultBuilder;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestMemSqlDistributedQueries\n+        extends AbstractTestDistributedQueries\n+{\n+    protected TestingMemSqlServer memSqlServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        memSqlServer = new TestingMemSqlServer();\n+        closeAfterClass(() -> {\n+            memSqlServer.close();\n+            memSqlServer = null;\n+        });\n+        return createMemSqlQueryRunner(\n+                memSqlServer,\n+                ImmutableMap.<String, String>builder()\n+                        // caching here speeds up tests highly, caching is not used in smoke tests\n+                        .put(\"metadata.cache-ttl\", \"10m\")\n+                        .put(\"metadata.cache-missing\", \"true\")\n+                        .build(),\n+                TpchTable.getTables());\n+    }\n+\n+    @Override\n+    protected boolean supportsDelete()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean supportsViews()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean supportsArrays()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean supportsCommentOnTable()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean supportsCommentOnColumn()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected TestTable createTableWithDefaultColumns()\n+    {\n+        return new TestTable(\n+                createJdbcSqlExecutor(),\n+                \"tpch.table\",\n+                \"(col_required BIGINT NOT NULL,\" +\n+                        \"col_nullable BIGINT,\" +\n+                        \"col_default BIGINT DEFAULT 43,\" +\n+                        \"col_nonnull_default BIGINT NOT NULL DEFAULT 42,\" +\n+                        \"col_required2 BIGINT NOT NULL)\");\n+    }\n+\n+    @Override\n+    public void testShowColumns()\n+    {\n+        MaterializedResult actual = computeActual(\"SHOW COLUMNS FROM orders\");\n+\n+        MaterializedResult expectedParametrizedVarchar = resultBuilder(getSession(), VARCHAR, VARCHAR, VARCHAR, VARCHAR)\n+                .row(\"orderkey\", \"bigint\", \"\", \"\")\n+                .row(\"custkey\", \"bigint\", \"\", \"\")\n+                .row(\"orderstatus\", \"varchar(255)\", \"\", \"\")\n+                .row(\"totalprice\", \"double\", \"\", \"\")\n+                .row(\"orderdate\", \"date\", \"\", \"\")\n+                .row(\"orderpriority\", \"varchar(255)\", \"\", \"\")\n+                .row(\"clerk\", \"varchar(255)\", \"\", \"\")\n+                .row(\"shippriority\", \"integer\", \"\", \"\")\n+                .row(\"comment\", \"varchar(255)\", \"\", \"\")\n+                .build();\n+\n+        assertEquals(actual, expectedParametrizedVarchar);\n+    }\n+\n+    @Override\n+    protected Optional<DataMappingTestSetup> filterDataMappingSmokeTestData(DataMappingTestSetup dataMappingTestSetup)\n+    {\n+        String typeName = dataMappingTestSetup.getPrestoTypeName();\n+        if (typeName.equals(\"time\")\n+                || typeName.equals(\"timestamp(3) with time zone\")) {\n+            return Optional.of(dataMappingTestSetup.asUnsupported());\n+        }\n+\n+        if (typeName.equals(\"real\")\n+                || typeName.equals(\"timestamp\")) {\n+            // TODO this should either work or fail cleanly\n+            return Optional.empty();\n+        }\n+\n+        if (typeName.equals(\"varchar\")) {\n+            // TODO fails due to case insensitive UTF-8 comparisions\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(dataMappingTestSetup);\n+    }\n+\n+    @Override\n+    protected Optional<String> filterColumnNameTestData(String columnName)\n+    {\n+        // TODO fails with \"Multiple statements detected in a single query.\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE1NjA0OA==", "bodyText": "I opted to skip this test instead of modifying the test container since I don't think there's any point in making this test pass if it will actually fail in practice for most people.", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r503156048", "createdAt": "2020-10-12T09:18:38Z", "author": {"login": "hashhar"}, "path": "presto-memsql/src/test/java/io/prestosql/plugin/memsql/TestMemSqlDistributedQueries.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.memsql;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.testing.AbstractTestDistributedQueries;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.sql.SqlExecutor;\n+import io.prestosql.testing.sql.TestTable;\n+import io.prestosql.tpch.TpchTable;\n+import org.testng.SkipException;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.memsql.MemSqlQueryRunner.createMemSqlQueryRunner;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.testing.MaterializedResult.resultBuilder;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestMemSqlDistributedQueries\n+        extends AbstractTestDistributedQueries\n+{\n+    protected TestingMemSqlServer memSqlServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        memSqlServer = new TestingMemSqlServer();\n+        closeAfterClass(() -> {\n+            memSqlServer.close();\n+            memSqlServer = null;\n+        });\n+        return createMemSqlQueryRunner(\n+                memSqlServer,\n+                ImmutableMap.<String, String>builder()\n+                        // caching here speeds up tests highly, caching is not used in smoke tests\n+                        .put(\"metadata.cache-ttl\", \"10m\")\n+                        .put(\"metadata.cache-missing\", \"true\")\n+                        .build(),\n+                TpchTable.getTables());\n+    }\n+\n+    @Override\n+    protected boolean supportsDelete()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean supportsViews()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean supportsArrays()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean supportsCommentOnTable()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean supportsCommentOnColumn()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected TestTable createTableWithDefaultColumns()\n+    {\n+        return new TestTable(\n+                createJdbcSqlExecutor(),\n+                \"tpch.table\",\n+                \"(col_required BIGINT NOT NULL,\" +\n+                        \"col_nullable BIGINT,\" +\n+                        \"col_default BIGINT DEFAULT 43,\" +\n+                        \"col_nonnull_default BIGINT NOT NULL DEFAULT 42,\" +\n+                        \"col_required2 BIGINT NOT NULL)\");\n+    }\n+\n+    @Override\n+    public void testShowColumns()\n+    {\n+        MaterializedResult actual = computeActual(\"SHOW COLUMNS FROM orders\");\n+\n+        MaterializedResult expectedParametrizedVarchar = resultBuilder(getSession(), VARCHAR, VARCHAR, VARCHAR, VARCHAR)\n+                .row(\"orderkey\", \"bigint\", \"\", \"\")\n+                .row(\"custkey\", \"bigint\", \"\", \"\")\n+                .row(\"orderstatus\", \"varchar(255)\", \"\", \"\")\n+                .row(\"totalprice\", \"double\", \"\", \"\")\n+                .row(\"orderdate\", \"date\", \"\", \"\")\n+                .row(\"orderpriority\", \"varchar(255)\", \"\", \"\")\n+                .row(\"clerk\", \"varchar(255)\", \"\", \"\")\n+                .row(\"shippriority\", \"integer\", \"\", \"\")\n+                .row(\"comment\", \"varchar(255)\", \"\", \"\")\n+                .build();\n+\n+        assertEquals(actual, expectedParametrizedVarchar);\n+    }\n+\n+    @Override\n+    protected Optional<DataMappingTestSetup> filterDataMappingSmokeTestData(DataMappingTestSetup dataMappingTestSetup)\n+    {\n+        String typeName = dataMappingTestSetup.getPrestoTypeName();\n+        if (typeName.equals(\"time\")\n+                || typeName.equals(\"timestamp(3) with time zone\")) {\n+            return Optional.of(dataMappingTestSetup.asUnsupported());\n+        }\n+\n+        if (typeName.equals(\"real\")\n+                || typeName.equals(\"timestamp\")) {\n+            // TODO this should either work or fail cleanly\n+            return Optional.empty();\n+        }\n+\n+        if (typeName.equals(\"varchar\")) {\n+            // TODO fails due to case insensitive UTF-8 comparisions\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(dataMappingTestSetup);\n+    }\n+\n+    @Override\n+    protected Optional<String> filterColumnNameTestData(String columnName)\n+    {\n+        // TODO fails with \"Multiple statements detected in a single query.\"\n+        if (columnName.equalsIgnoreCase(\"a;semicolon\")) {\n+            return Optional.empty();\n+        }\n+        return super.filterColumnNameTestData(columnName);\n+    }\n+\n+    @Override\n+    public void testLargeIn()\n+    {\n+        // TODO Caused by: java.sql.SQLException: Thread stack overrun:  Used: 1048713 of a 1048576 stack. Use 'memsqld --thread_stack=#' to specify a bigger stack if needed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE1ODU4NQ==", "bodyText": "Fixes #5263", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r503158585", "createdAt": "2020-10-12T09:22:45Z", "author": {"login": "hashhar"}, "path": "presto-memsql/src/test/java/io/prestosql/plugin/memsql/TestMemSqlIntegrationSmokeTest.java", "diffHunk": "@@ -193,8 +207,7 @@ public void testLimitPushdown()\n         assertThat(query(\"SELECT name FROM nation WHERE regionkey = 3 LIMIT 5\")).isCorrectlyPushedDown();\n \n         // with filter over varchar column\n-        // TODO (https://github.com/prestosql/presto/issues/5263) should be `.isNotFullyPushedDown(FilterNode.class)`\n-        assertThat(query(\"SELECT name FROM nation WHERE name < 'EEE' LIMIT 5\")).isCorrectlyPushedDown();\n+        assertThat(query(\"SELECT name FROM nation WHERE name < 'EEE' LIMIT 5\")).isNotFullyPushedDown(FilterNode.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE2Mjc2Mg==", "bodyText": "This seems to be due to MemSQL's FLOAT type having low precision rather than rounding errors.", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r503162762", "createdAt": "2020-10-12T09:29:13Z", "author": {"login": "hashhar"}, "path": "presto-memsql/src/test/java/io/prestosql/plugin/memsql/TestMemSqlTypeMapping.java", "diffHunk": "@@ -95,7 +106,8 @@ private static DataTypeTest singlePrecisionFloatingPointTests(DataType<Float> fl\n         // we are not testing Nan/-Infinity/+Infinity as those are not supported by MemSQL\n         return DataTypeTest.create()\n                 .addRoundTrip(floatType, 3.14f)\n-                // .addRoundTrip(floatType, 3.1415927f) // Overeagerly rounded by MemSQL to 3.14159 TODO\n+                // TODO Overeagerly rounded by MemSQL to 3.14159", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE2Mzg5Nw==", "bodyText": "CAST to JSON doesn't exist. There's a TO_JSON function but that parses strings into JSON values. ie. strings get converted into double quoted JSON strings. Passing strings that are valid JSON seem to get parsed into JSON during INSERT.", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r503163897", "createdAt": "2020-10-12T09:30:52Z", "author": {"login": "hashhar"}, "path": "presto-memsql/src/test/java/io/prestosql/plugin/memsql/TestMemSqlTypeMapping.java", "diffHunk": "@@ -300,6 +309,31 @@ public void testTimestamp()\n         throw new SkipException(\"TODO\");\n     }\n \n+    @Test\n+    public void testJson()\n+    {\n+        jsonTestCases(jsonDataType(value -> \"JSON \" + formatStringLiteral(value)))\n+                .execute(getQueryRunner(), prestoCreateAsSelect(\"presto_test_json\"));\n+        // TODO MemSQL doesn't support CAST to JSON but accepts string literals as JSON values", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 131}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NTg3Mzgy", "url": "https://github.com/trinodb/trino/pull/5495#pullrequestreview-506587382", "createdAt": "2020-10-12T12:47:15Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjo0NzoxNVrOHf9RJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjo0NzoxNVrOHf9RJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3MTcxNw==", "bodyText": "We can replace this with\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        else if (varcharType.getBoundedLength() <= 255) {\n          \n          \n            \n                        else if (varcharType.getBoundedLength() <= 21845) {\n          \n          \n            \n                            dataType = format(\"varchar(%s)\", varcharType.getBoundedLength());\n          \n          \n            \n                        }\n          \n      \n    \n    \n  \n\nThis will allow the varchars in TPCH to look correct (ie. varchar(1) etc.). I kept it this way because MySQL has a similar implementation even though we can do the same thing there.", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r503271717", "createdAt": "2020-10-12T12:47:15Z", "author": {"login": "hashhar"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -88,6 +132,118 @@ protected String getTableSchemaName(ResultSet resultSet)\n         return resultSet.getString(\"TABLE_CAT\");\n     }\n \n+    @Override\n+    public Optional<ColumnMapping> toPrestoType(ConnectorSession session, Connection connection, JdbcTypeHandle typeHandle)\n+    {\n+        String jdbcTypeName = typeHandle.getJdbcTypeName()\n+                .orElseThrow(() -> new PrestoException(JDBC_ERROR, \"Type name is missing: \" + typeHandle));\n+\n+        Optional<ColumnMapping> mapping = getForcedMappingToVarchar(typeHandle);\n+        if (mapping.isPresent()) {\n+            return mapping;\n+        }\n+        Optional<ColumnMapping> unsignedMapping = getUnsignedMapping(typeHandle);\n+        if (unsignedMapping.isPresent()) {\n+            return unsignedMapping;\n+        }\n+\n+        if (jdbcTypeName.equalsIgnoreCase(\"json\")) {\n+            return Optional.of(jsonColumnMapping());\n+        }\n+\n+        int columnSize = typeHandle.getColumnSize();\n+        switch (typeHandle.getJdbcType()) {\n+            // TODO not all these type constants are necessarily used by the JDBC driver\n+            case Types.VARCHAR:\n+            case Types.NVARCHAR:\n+            case Types.LONGVARCHAR:\n+            case Types.LONGNVARCHAR:\n+                VarcharType varcharType = (columnSize <= VarcharType.MAX_LENGTH) ? createVarcharType(columnSize) : createUnboundedVarcharType();\n+                // Remote database can be case insensitive.\n+                PredicatePushdownController predicatePushdownController = PUSHDOWN_AND_KEEP;\n+                return Optional.of(ColumnMapping.sliceMapping(varcharType, varcharReadFunction(varcharType), varcharWriteFunction(), predicatePushdownController));\n+            // TODO handle decimals if decimal_rounding_mode session property is needed\n+        }\n+\n+        // TODO add explicit mappings\n+        return super.toPrestoType(session, connection, typeHandle);\n+    }\n+\n+    @Override\n+    public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n+    {\n+        if (REAL.equals(type)) {\n+            return WriteMapping.longMapping(\"float\", realWriteFunction());\n+        }\n+        // TODO implement TIME types\n+        // TODO add support for other TIMESTAMP precisions\n+        if (TIMESTAMP_MILLIS.equals(type)) {\n+            return WriteMapping.longMapping(\"datetime\", timestampWriteFunction(TIMESTAMP_MILLIS));\n+        }\n+        if (VARBINARY.equals(type)) {\n+            return WriteMapping.sliceMapping(\"mediumblob\", varbinaryWriteFunction());\n+        }\n+        if (type instanceof VarcharType) {\n+            VarcharType varcharType = (VarcharType) type;\n+            String dataType;\n+            if (varcharType.isUnbounded()) {\n+                dataType = \"longtext\";\n+            }\n+            else if (varcharType.getBoundedLength() <= 255) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2Njg3ODcx", "url": "https://github.com/trinodb/trino/pull/5495#pullrequestreview-506687871", "createdAt": "2020-10-12T14:49:11Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNDo0OToxMVrOHgB7jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNDo1NDoyOVrOHgCJBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM0ODEwOA==", "bodyText": "can we eliminate those not needed (along with this TODO)?", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r503348108", "createdAt": "2020-10-12T14:49:11Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -88,6 +132,118 @@ protected String getTableSchemaName(ResultSet resultSet)\n         return resultSet.getString(\"TABLE_CAT\");\n     }\n \n+    @Override\n+    public Optional<ColumnMapping> toPrestoType(ConnectorSession session, Connection connection, JdbcTypeHandle typeHandle)\n+    {\n+        String jdbcTypeName = typeHandle.getJdbcTypeName()\n+                .orElseThrow(() -> new PrestoException(JDBC_ERROR, \"Type name is missing: \" + typeHandle));\n+\n+        Optional<ColumnMapping> mapping = getForcedMappingToVarchar(typeHandle);\n+        if (mapping.isPresent()) {\n+            return mapping;\n+        }\n+        Optional<ColumnMapping> unsignedMapping = getUnsignedMapping(typeHandle);\n+        if (unsignedMapping.isPresent()) {\n+            return unsignedMapping;\n+        }\n+\n+        if (jdbcTypeName.equalsIgnoreCase(\"json\")) {\n+            return Optional.of(jsonColumnMapping());\n+        }\n+\n+        int columnSize = typeHandle.getColumnSize();\n+        switch (typeHandle.getJdbcType()) {\n+            // TODO not all these type constants are necessarily used by the JDBC driver", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM0ODU5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // TODO implement TIME types\n          \n          \n            \n                    // TODO implement TIME type", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r503348599", "createdAt": "2020-10-12T14:49:55Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -88,6 +132,118 @@ protected String getTableSchemaName(ResultSet resultSet)\n         return resultSet.getString(\"TABLE_CAT\");\n     }\n \n+    @Override\n+    public Optional<ColumnMapping> toPrestoType(ConnectorSession session, Connection connection, JdbcTypeHandle typeHandle)\n+    {\n+        String jdbcTypeName = typeHandle.getJdbcTypeName()\n+                .orElseThrow(() -> new PrestoException(JDBC_ERROR, \"Type name is missing: \" + typeHandle));\n+\n+        Optional<ColumnMapping> mapping = getForcedMappingToVarchar(typeHandle);\n+        if (mapping.isPresent()) {\n+            return mapping;\n+        }\n+        Optional<ColumnMapping> unsignedMapping = getUnsignedMapping(typeHandle);\n+        if (unsignedMapping.isPresent()) {\n+            return unsignedMapping;\n+        }\n+\n+        if (jdbcTypeName.equalsIgnoreCase(\"json\")) {\n+            return Optional.of(jsonColumnMapping());\n+        }\n+\n+        int columnSize = typeHandle.getColumnSize();\n+        switch (typeHandle.getJdbcType()) {\n+            // TODO not all these type constants are necessarily used by the JDBC driver\n+            case Types.VARCHAR:\n+            case Types.NVARCHAR:\n+            case Types.LONGVARCHAR:\n+            case Types.LONGNVARCHAR:\n+                VarcharType varcharType = (columnSize <= VarcharType.MAX_LENGTH) ? createVarcharType(columnSize) : createUnboundedVarcharType();\n+                // Remote database can be case insensitive.\n+                PredicatePushdownController predicatePushdownController = PUSHDOWN_AND_KEEP;\n+                return Optional.of(ColumnMapping.sliceMapping(varcharType, varcharReadFunction(varcharType), varcharWriteFunction(), predicatePushdownController));\n+            // TODO handle decimals if decimal_rounding_mode session property is needed\n+        }\n+\n+        // TODO add explicit mappings\n+        return super.toPrestoType(session, connection, typeHandle);\n+    }\n+\n+    @Override\n+    public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n+    {\n+        if (REAL.equals(type)) {\n+            return WriteMapping.longMapping(\"float\", realWriteFunction());\n+        }\n+        // TODO implement TIME types", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM0OTIzMw==", "bodyText": "order types from simplest first:\n\nmove varchar before varbinary\nmove both before temporal types", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r503349233", "createdAt": "2020-10-12T14:50:55Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -88,6 +132,118 @@ protected String getTableSchemaName(ResultSet resultSet)\n         return resultSet.getString(\"TABLE_CAT\");\n     }\n \n+    @Override\n+    public Optional<ColumnMapping> toPrestoType(ConnectorSession session, Connection connection, JdbcTypeHandle typeHandle)\n+    {\n+        String jdbcTypeName = typeHandle.getJdbcTypeName()\n+                .orElseThrow(() -> new PrestoException(JDBC_ERROR, \"Type name is missing: \" + typeHandle));\n+\n+        Optional<ColumnMapping> mapping = getForcedMappingToVarchar(typeHandle);\n+        if (mapping.isPresent()) {\n+            return mapping;\n+        }\n+        Optional<ColumnMapping> unsignedMapping = getUnsignedMapping(typeHandle);\n+        if (unsignedMapping.isPresent()) {\n+            return unsignedMapping;\n+        }\n+\n+        if (jdbcTypeName.equalsIgnoreCase(\"json\")) {\n+            return Optional.of(jsonColumnMapping());\n+        }\n+\n+        int columnSize = typeHandle.getColumnSize();\n+        switch (typeHandle.getJdbcType()) {\n+            // TODO not all these type constants are necessarily used by the JDBC driver\n+            case Types.VARCHAR:\n+            case Types.NVARCHAR:\n+            case Types.LONGVARCHAR:\n+            case Types.LONGNVARCHAR:\n+                VarcharType varcharType = (columnSize <= VarcharType.MAX_LENGTH) ? createVarcharType(columnSize) : createUnboundedVarcharType();\n+                // Remote database can be case insensitive.\n+                PredicatePushdownController predicatePushdownController = PUSHDOWN_AND_KEEP;\n+                return Optional.of(ColumnMapping.sliceMapping(varcharType, varcharReadFunction(varcharType), varcharWriteFunction(), predicatePushdownController));\n+            // TODO handle decimals if decimal_rounding_mode session property is needed\n+        }\n+\n+        // TODO add explicit mappings\n+        return super.toPrestoType(session, connection, typeHandle);\n+    }\n+\n+    @Override\n+    public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n+    {\n+        if (REAL.equals(type)) {\n+            return WriteMapping.longMapping(\"float\", realWriteFunction());\n+        }\n+        // TODO implement TIME types\n+        // TODO add support for other TIMESTAMP precisions\n+        if (TIMESTAMP_MILLIS.equals(type)) {\n+            return WriteMapping.longMapping(\"datetime\", timestampWriteFunction(TIMESTAMP_MILLIS));\n+        }\n+        if (VARBINARY.equals(type)) {\n+            return WriteMapping.sliceMapping(\"mediumblob\", varbinaryWriteFunction());\n+        }\n+        if (type instanceof VarcharType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM0OTk4Ng==", "bodyText": "Mysql thing seems like legacy, i dont see a reason to follow it here\ndefine a constant like MEMSQL_VARCHAR_MAX_LENGTH", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r503349986", "createdAt": "2020-10-12T14:52:01Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -88,6 +132,118 @@ protected String getTableSchemaName(ResultSet resultSet)\n         return resultSet.getString(\"TABLE_CAT\");\n     }\n \n+    @Override\n+    public Optional<ColumnMapping> toPrestoType(ConnectorSession session, Connection connection, JdbcTypeHandle typeHandle)\n+    {\n+        String jdbcTypeName = typeHandle.getJdbcTypeName()\n+                .orElseThrow(() -> new PrestoException(JDBC_ERROR, \"Type name is missing: \" + typeHandle));\n+\n+        Optional<ColumnMapping> mapping = getForcedMappingToVarchar(typeHandle);\n+        if (mapping.isPresent()) {\n+            return mapping;\n+        }\n+        Optional<ColumnMapping> unsignedMapping = getUnsignedMapping(typeHandle);\n+        if (unsignedMapping.isPresent()) {\n+            return unsignedMapping;\n+        }\n+\n+        if (jdbcTypeName.equalsIgnoreCase(\"json\")) {\n+            return Optional.of(jsonColumnMapping());\n+        }\n+\n+        int columnSize = typeHandle.getColumnSize();\n+        switch (typeHandle.getJdbcType()) {\n+            // TODO not all these type constants are necessarily used by the JDBC driver\n+            case Types.VARCHAR:\n+            case Types.NVARCHAR:\n+            case Types.LONGVARCHAR:\n+            case Types.LONGNVARCHAR:\n+                VarcharType varcharType = (columnSize <= VarcharType.MAX_LENGTH) ? createVarcharType(columnSize) : createUnboundedVarcharType();\n+                // Remote database can be case insensitive.\n+                PredicatePushdownController predicatePushdownController = PUSHDOWN_AND_KEEP;\n+                return Optional.of(ColumnMapping.sliceMapping(varcharType, varcharReadFunction(varcharType), varcharWriteFunction(), predicatePushdownController));\n+            // TODO handle decimals if decimal_rounding_mode session property is needed\n+        }\n+\n+        // TODO add explicit mappings\n+        return super.toPrestoType(session, connection, typeHandle);\n+    }\n+\n+    @Override\n+    public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n+    {\n+        if (REAL.equals(type)) {\n+            return WriteMapping.longMapping(\"float\", realWriteFunction());\n+        }\n+        // TODO implement TIME types\n+        // TODO add support for other TIMESTAMP precisions\n+        if (TIMESTAMP_MILLIS.equals(type)) {\n+            return WriteMapping.longMapping(\"datetime\", timestampWriteFunction(TIMESTAMP_MILLIS));\n+        }\n+        if (VARBINARY.equals(type)) {\n+            return WriteMapping.sliceMapping(\"mediumblob\", varbinaryWriteFunction());\n+        }\n+        if (type instanceof VarcharType) {\n+            VarcharType varcharType = (VarcharType) type;\n+            String dataType;\n+            if (varcharType.isUnbounded()) {\n+                dataType = \"longtext\";\n+            }\n+            else if (varcharType.getBoundedLength() <= 255) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3MTcxNw=="}, "originalCommit": null, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM1MTA5Nw==", "bodyText": "this is nice (not supported vs error), but may be an overkill, as memsql 5.7 is hopefully passe.\ni'd move MemSQL versions earlier than 5.7 do not support the above CHANGE syntax as a comment above where the syntax is used and remove the if  here.", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r503351097", "createdAt": "2020-10-12T14:53:44Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -88,6 +132,118 @@ protected String getTableSchemaName(ResultSet resultSet)\n         return resultSet.getString(\"TABLE_CAT\");\n     }\n \n+    @Override\n+    public Optional<ColumnMapping> toPrestoType(ConnectorSession session, Connection connection, JdbcTypeHandle typeHandle)\n+    {\n+        String jdbcTypeName = typeHandle.getJdbcTypeName()\n+                .orElseThrow(() -> new PrestoException(JDBC_ERROR, \"Type name is missing: \" + typeHandle));\n+\n+        Optional<ColumnMapping> mapping = getForcedMappingToVarchar(typeHandle);\n+        if (mapping.isPresent()) {\n+            return mapping;\n+        }\n+        Optional<ColumnMapping> unsignedMapping = getUnsignedMapping(typeHandle);\n+        if (unsignedMapping.isPresent()) {\n+            return unsignedMapping;\n+        }\n+\n+        if (jdbcTypeName.equalsIgnoreCase(\"json\")) {\n+            return Optional.of(jsonColumnMapping());\n+        }\n+\n+        int columnSize = typeHandle.getColumnSize();\n+        switch (typeHandle.getJdbcType()) {\n+            // TODO not all these type constants are necessarily used by the JDBC driver\n+            case Types.VARCHAR:\n+            case Types.NVARCHAR:\n+            case Types.LONGVARCHAR:\n+            case Types.LONGNVARCHAR:\n+                VarcharType varcharType = (columnSize <= VarcharType.MAX_LENGTH) ? createVarcharType(columnSize) : createUnboundedVarcharType();\n+                // Remote database can be case insensitive.\n+                PredicatePushdownController predicatePushdownController = PUSHDOWN_AND_KEEP;\n+                return Optional.of(ColumnMapping.sliceMapping(varcharType, varcharReadFunction(varcharType), varcharWriteFunction(), predicatePushdownController));\n+            // TODO handle decimals if decimal_rounding_mode session property is needed\n+        }\n+\n+        // TODO add explicit mappings\n+        return super.toPrestoType(session, connection, typeHandle);\n+    }\n+\n+    @Override\n+    public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n+    {\n+        if (REAL.equals(type)) {\n+            return WriteMapping.longMapping(\"float\", realWriteFunction());\n+        }\n+        // TODO implement TIME types\n+        // TODO add support for other TIMESTAMP precisions\n+        if (TIMESTAMP_MILLIS.equals(type)) {\n+            return WriteMapping.longMapping(\"datetime\", timestampWriteFunction(TIMESTAMP_MILLIS));\n+        }\n+        if (VARBINARY.equals(type)) {\n+            return WriteMapping.sliceMapping(\"mediumblob\", varbinaryWriteFunction());\n+        }\n+        if (type instanceof VarcharType) {\n+            VarcharType varcharType = (VarcharType) type;\n+            String dataType;\n+            if (varcharType.isUnbounded()) {\n+                dataType = \"longtext\";\n+            }\n+            else if (varcharType.getBoundedLength() <= 255) {\n+                dataType = \"tinytext\";\n+            }\n+            else if (varcharType.getBoundedLength() <= 65535) {\n+                dataType = \"text\";\n+            }\n+            else if (varcharType.getBoundedLength() <= 16777215) {\n+                dataType = \"mediumtext\";\n+            }\n+            else {\n+                dataType = \"longtext\";\n+            }\n+            return WriteMapping.sliceMapping(dataType, varcharWriteFunction());\n+        }\n+        if (type.equals(jsonType)) {\n+            return WriteMapping.sliceMapping(\"json\", varcharWriteFunction());\n+        }\n+\n+        return super.toWriteMapping(session, type);\n+    }\n+\n+    @Override\n+    public void renameColumn(JdbcIdentity identity, JdbcTableHandle handle, JdbcColumnHandle jdbcColumn, String newColumnName)\n+    {\n+        try (Connection connection = connectionFactory.openConnection(identity)) {\n+            DatabaseMetaData metadata = connection.getMetaData();\n+            if (metadata.storesUpperCaseIdentifiers()) {\n+                newColumnName = newColumnName.toUpperCase(ENGLISH);\n+            }\n+            String sql = format(\n+                    \"ALTER TABLE %s CHANGE %s %s\",\n+                    quoted(handle.getCatalogName(), handle.getSchemaName(), handle.getTableName()),\n+                    quoted(jdbcColumn.getColumnName()),\n+                    quoted(newColumnName));\n+            execute(connection, sql);\n+        }\n+        catch (SQLException e) {\n+            // MemSQL versions earlier than 5.7 do not support the above CHANGE syntax\n+            // TODO Does importing MySQL driver just for SQL_STATE_SYNTAX_ERROR make sense?\n+            if (\"42000\".equals(e.getSQLState())) {\n+                throw new PrestoException(NOT_SUPPORTED, format(\"Rename column not supported in catalog: '%s'\", handle.getCatalogName()), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM1MTU1OA==", "bodyText": "move above jsonColumnMapping, as numeric types are handled before json type in the toPrestoTy[e", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r503351558", "createdAt": "2020-10-12T14:54:29Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -99,4 +255,36 @@ public boolean isLimitGuaranteed(ConnectorSession session)\n     {\n         return true;\n     }\n+\n+    private ColumnMapping jsonColumnMapping()\n+    {\n+        return ColumnMapping.sliceMapping(\n+                jsonType,\n+                (resultSet, columnIndex) -> jsonParse(utf8Slice(resultSet.getString(columnIndex))),\n+                varcharWriteFunction(),\n+                DISABLE_PUSHDOWN);\n+    }\n+\n+    private static Optional<ColumnMapping> getUnsignedMapping(JdbcTypeHandle typeHandle)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 205}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4MjAyODI1", "url": "https://github.com/trinodb/trino/pull/5495#pullrequestreview-508202825", "createdAt": "2020-10-14T10:21:09Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDoyMTowOVrOHhMShg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDoyMTowOVrOHhMShg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU2NjQwNg==", "bodyText": "can we know if it is and react accordingly?", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r504566406", "createdAt": "2020-10-14T10:21:09Z", "author": {"login": "losipiuk"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -88,6 +149,116 @@ protected String getTableSchemaName(ResultSet resultSet)\n         return resultSet.getString(\"TABLE_CAT\");\n     }\n \n+    @Override\n+    public Optional<ColumnMapping> toPrestoType(ConnectorSession session, Connection connection, JdbcTypeHandle typeHandle)\n+    {\n+        String jdbcTypeName = typeHandle.getJdbcTypeName()\n+                .orElseThrow(() -> new PrestoException(JDBC_ERROR, \"Type name is missing: \" + typeHandle));\n+\n+        Optional<ColumnMapping> mapping = getForcedMappingToVarchar(typeHandle);\n+        if (mapping.isPresent()) {\n+            return mapping;\n+        }\n+        Optional<ColumnMapping> unsignedMapping = getUnsignedMapping(typeHandle);\n+        if (unsignedMapping.isPresent()) {\n+            return unsignedMapping;\n+        }\n+\n+        if (jdbcTypeName.equalsIgnoreCase(\"json\")) {\n+            return Optional.of(jsonColumnMapping());\n+        }\n+\n+        int columnSize = typeHandle.getColumnSize();\n+        switch (typeHandle.getJdbcType()) {\n+            case Types.VARCHAR:\n+                VarcharType varcharType = (columnSize <= VarcharType.MAX_LENGTH) ? createVarcharType(columnSize) : createUnboundedVarcharType();\n+                // Remote database can be case insensitive.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNzkyMTg5", "url": "https://github.com/trinodb/trino/pull/5495#pullrequestreview-513792189", "createdAt": "2020-10-21T15:05:17Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNTowNToxN1rOHlxVAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNToxNzozOFrOHlx8AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2NzU1NQ==", "bodyText": "Override seems redundant?", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r509367555", "createdAt": "2020-10-21T15:05:17Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -67,6 +121,13 @@ protected boolean filterSchema(String schemaName)\n         return super.filterSchema(schemaName);\n     }\n \n+    @Override\n+    public PreparedStatement getPreparedStatement(Connection connection, String sql)\n+            throws SQLException\n+    {\n+        return connection.prepareStatement(sql);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2ODUyMg==", "bodyText": "define constatns for these numbers, like you did for MEMSQL_VARCHAR_MAX_LENGTH", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r509368522", "createdAt": "2020-10-21T15:06:32Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -88,6 +149,116 @@ protected String getTableSchemaName(ResultSet resultSet)\n         return resultSet.getString(\"TABLE_CAT\");\n     }\n \n+    @Override\n+    public Optional<ColumnMapping> toPrestoType(ConnectorSession session, Connection connection, JdbcTypeHandle typeHandle)\n+    {\n+        String jdbcTypeName = typeHandle.getJdbcTypeName()\n+                .orElseThrow(() -> new PrestoException(JDBC_ERROR, \"Type name is missing: \" + typeHandle));\n+\n+        Optional<ColumnMapping> mapping = getForcedMappingToVarchar(typeHandle);\n+        if (mapping.isPresent()) {\n+            return mapping;\n+        }\n+        Optional<ColumnMapping> unsignedMapping = getUnsignedMapping(typeHandle);\n+        if (unsignedMapping.isPresent()) {\n+            return unsignedMapping;\n+        }\n+\n+        if (jdbcTypeName.equalsIgnoreCase(\"json\")) {\n+            return Optional.of(jsonColumnMapping());\n+        }\n+\n+        int columnSize = typeHandle.getColumnSize();\n+        switch (typeHandle.getJdbcType()) {\n+            case Types.VARCHAR:\n+                VarcharType varcharType = (columnSize <= VarcharType.MAX_LENGTH) ? createVarcharType(columnSize) : createUnboundedVarcharType();\n+                // Remote database can be case insensitive.\n+                PredicatePushdownController predicatePushdownController = PUSHDOWN_AND_KEEP;\n+                return Optional.of(ColumnMapping.sliceMapping(varcharType, varcharReadFunction(varcharType), varcharWriteFunction(), predicatePushdownController));\n+            case Types.DECIMAL:\n+                int precision = columnSize;\n+                int decimalDigits = typeHandle.getDecimalDigits().orElseThrow(() -> new IllegalStateException(\"decimal digits not present\"));\n+                if (getDecimalRounding(session) == ALLOW_OVERFLOW && precision > Decimals.MAX_PRECISION) {\n+                    int scale = min(decimalDigits, getDecimalDefaultScale(session));\n+                    return Optional.of(decimalColumnMapping(createDecimalType(Decimals.MAX_PRECISION, scale), getDecimalRoundingMode(session)));\n+                }\n+        }\n+\n+        // TODO add explicit mappings\n+        return super.toPrestoType(session, connection, typeHandle);\n+    }\n+\n+    @Override\n+    public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n+    {\n+        if (type instanceof VarcharType) {\n+            VarcharType varcharType = (VarcharType) type;\n+            String dataType;\n+            if (varcharType.isUnbounded()) {\n+                dataType = \"longtext\";\n+            }\n+            else if (varcharType.getBoundedLength() <= MEMSQL_VARCHAR_MAX_LENGTH) {\n+                dataType = \"varchar(\" + varcharType.getBoundedLength() + \")\";\n+            }\n+            else if (varcharType.getBoundedLength() <= 65535) {\n+                dataType = \"text\";\n+            }\n+            else if (varcharType.getBoundedLength() <= 16777215) {\n+                dataType = \"mediumtext\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2ODY3Mg==", "bodyText": "medium or longblob?", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r509368672", "createdAt": "2020-10-21T15:06:45Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -88,6 +149,116 @@ protected String getTableSchemaName(ResultSet resultSet)\n         return resultSet.getString(\"TABLE_CAT\");\n     }\n \n+    @Override\n+    public Optional<ColumnMapping> toPrestoType(ConnectorSession session, Connection connection, JdbcTypeHandle typeHandle)\n+    {\n+        String jdbcTypeName = typeHandle.getJdbcTypeName()\n+                .orElseThrow(() -> new PrestoException(JDBC_ERROR, \"Type name is missing: \" + typeHandle));\n+\n+        Optional<ColumnMapping> mapping = getForcedMappingToVarchar(typeHandle);\n+        if (mapping.isPresent()) {\n+            return mapping;\n+        }\n+        Optional<ColumnMapping> unsignedMapping = getUnsignedMapping(typeHandle);\n+        if (unsignedMapping.isPresent()) {\n+            return unsignedMapping;\n+        }\n+\n+        if (jdbcTypeName.equalsIgnoreCase(\"json\")) {\n+            return Optional.of(jsonColumnMapping());\n+        }\n+\n+        int columnSize = typeHandle.getColumnSize();\n+        switch (typeHandle.getJdbcType()) {\n+            case Types.VARCHAR:\n+                VarcharType varcharType = (columnSize <= VarcharType.MAX_LENGTH) ? createVarcharType(columnSize) : createUnboundedVarcharType();\n+                // Remote database can be case insensitive.\n+                PredicatePushdownController predicatePushdownController = PUSHDOWN_AND_KEEP;\n+                return Optional.of(ColumnMapping.sliceMapping(varcharType, varcharReadFunction(varcharType), varcharWriteFunction(), predicatePushdownController));\n+            case Types.DECIMAL:\n+                int precision = columnSize;\n+                int decimalDigits = typeHandle.getDecimalDigits().orElseThrow(() -> new IllegalStateException(\"decimal digits not present\"));\n+                if (getDecimalRounding(session) == ALLOW_OVERFLOW && precision > Decimals.MAX_PRECISION) {\n+                    int scale = min(decimalDigits, getDecimalDefaultScale(session));\n+                    return Optional.of(decimalColumnMapping(createDecimalType(Decimals.MAX_PRECISION, scale), getDecimalRoundingMode(session)));\n+                }\n+        }\n+\n+        // TODO add explicit mappings\n+        return super.toPrestoType(session, connection, typeHandle);\n+    }\n+\n+    @Override\n+    public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n+    {\n+        if (type instanceof VarcharType) {\n+            VarcharType varcharType = (VarcharType) type;\n+            String dataType;\n+            if (varcharType.isUnbounded()) {\n+                dataType = \"longtext\";\n+            }\n+            else if (varcharType.getBoundedLength() <= MEMSQL_VARCHAR_MAX_LENGTH) {\n+                dataType = \"varchar(\" + varcharType.getBoundedLength() + \")\";\n+            }\n+            else if (varcharType.getBoundedLength() <= 65535) {\n+                dataType = \"text\";\n+            }\n+            else if (varcharType.getBoundedLength() <= 16777215) {\n+                dataType = \"mediumtext\";\n+            }\n+            else {\n+                dataType = \"longtext\";\n+            }\n+            return WriteMapping.sliceMapping(dataType, varcharWriteFunction());\n+        }\n+        if (VARBINARY.equals(type)) {\n+            return WriteMapping.sliceMapping(\"mediumblob\", varbinaryWriteFunction());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2ODg3Mg==", "bodyText": "// TODO add explicit mappings", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r509368872", "createdAt": "2020-10-21T15:06:59Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -88,6 +149,116 @@ protected String getTableSchemaName(ResultSet resultSet)\n         return resultSet.getString(\"TABLE_CAT\");\n     }\n \n+    @Override\n+    public Optional<ColumnMapping> toPrestoType(ConnectorSession session, Connection connection, JdbcTypeHandle typeHandle)\n+    {\n+        String jdbcTypeName = typeHandle.getJdbcTypeName()\n+                .orElseThrow(() -> new PrestoException(JDBC_ERROR, \"Type name is missing: \" + typeHandle));\n+\n+        Optional<ColumnMapping> mapping = getForcedMappingToVarchar(typeHandle);\n+        if (mapping.isPresent()) {\n+            return mapping;\n+        }\n+        Optional<ColumnMapping> unsignedMapping = getUnsignedMapping(typeHandle);\n+        if (unsignedMapping.isPresent()) {\n+            return unsignedMapping;\n+        }\n+\n+        if (jdbcTypeName.equalsIgnoreCase(\"json\")) {\n+            return Optional.of(jsonColumnMapping());\n+        }\n+\n+        int columnSize = typeHandle.getColumnSize();\n+        switch (typeHandle.getJdbcType()) {\n+            case Types.VARCHAR:\n+                VarcharType varcharType = (columnSize <= VarcharType.MAX_LENGTH) ? createVarcharType(columnSize) : createUnboundedVarcharType();\n+                // Remote database can be case insensitive.\n+                PredicatePushdownController predicatePushdownController = PUSHDOWN_AND_KEEP;\n+                return Optional.of(ColumnMapping.sliceMapping(varcharType, varcharReadFunction(varcharType), varcharWriteFunction(), predicatePushdownController));\n+            case Types.DECIMAL:\n+                int precision = columnSize;\n+                int decimalDigits = typeHandle.getDecimalDigits().orElseThrow(() -> new IllegalStateException(\"decimal digits not present\"));\n+                if (getDecimalRounding(session) == ALLOW_OVERFLOW && precision > Decimals.MAX_PRECISION) {\n+                    int scale = min(decimalDigits, getDecimalDefaultScale(session));\n+                    return Optional.of(decimalColumnMapping(createDecimalType(Decimals.MAX_PRECISION, scale), getDecimalRoundingMode(session)));\n+                }\n+        }\n+\n+        // TODO add explicit mappings\n+        return super.toPrestoType(session, connection, typeHandle);\n+    }\n+\n+    @Override\n+    public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n+    {\n+        if (type instanceof VarcharType) {\n+            VarcharType varcharType = (VarcharType) type;\n+            String dataType;\n+            if (varcharType.isUnbounded()) {\n+                dataType = \"longtext\";\n+            }\n+            else if (varcharType.getBoundedLength() <= MEMSQL_VARCHAR_MAX_LENGTH) {\n+                dataType = \"varchar(\" + varcharType.getBoundedLength() + \")\";\n+            }\n+            else if (varcharType.getBoundedLength() <= 65535) {\n+                dataType = \"text\";\n+            }\n+            else if (varcharType.getBoundedLength() <= 16777215) {\n+                dataType = \"mediumtext\";\n+            }\n+            else {\n+                dataType = \"longtext\";\n+            }\n+            return WriteMapping.sliceMapping(dataType, varcharWriteFunction());\n+        }\n+        if (VARBINARY.equals(type)) {\n+            return WriteMapping.sliceMapping(\"mediumblob\", varbinaryWriteFunction());\n+        }\n+        if (type.equals(jsonType)) {\n+            return WriteMapping.sliceMapping(\"json\", varcharWriteFunction());\n+        }\n+        if (REAL.equals(type)) {\n+            return WriteMapping.longMapping(\"float\", realWriteFunction());\n+        }\n+        // TODO implement TIME type\n+        // TODO add support for other TIMESTAMP precisions\n+        if (TIMESTAMP_MILLIS.equals(type)) {\n+            return WriteMapping.longMapping(\"datetime\", timestampWriteFunction(TIMESTAMP_MILLIS));\n+        }\n+\n+        return super.toWriteMapping(session, type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2OTkzMw==", "bodyText": "move this above renameColumn (ideally, keep order as in superclass)", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r509369933", "createdAt": "2020-10-21T15:08:20Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -88,6 +149,116 @@ protected String getTableSchemaName(ResultSet resultSet)\n         return resultSet.getString(\"TABLE_CAT\");\n     }\n \n+    @Override\n+    public Optional<ColumnMapping> toPrestoType(ConnectorSession session, Connection connection, JdbcTypeHandle typeHandle)\n+    {\n+        String jdbcTypeName = typeHandle.getJdbcTypeName()\n+                .orElseThrow(() -> new PrestoException(JDBC_ERROR, \"Type name is missing: \" + typeHandle));\n+\n+        Optional<ColumnMapping> mapping = getForcedMappingToVarchar(typeHandle);\n+        if (mapping.isPresent()) {\n+            return mapping;\n+        }\n+        Optional<ColumnMapping> unsignedMapping = getUnsignedMapping(typeHandle);\n+        if (unsignedMapping.isPresent()) {\n+            return unsignedMapping;\n+        }\n+\n+        if (jdbcTypeName.equalsIgnoreCase(\"json\")) {\n+            return Optional.of(jsonColumnMapping());\n+        }\n+\n+        int columnSize = typeHandle.getColumnSize();\n+        switch (typeHandle.getJdbcType()) {\n+            case Types.VARCHAR:\n+                VarcharType varcharType = (columnSize <= VarcharType.MAX_LENGTH) ? createVarcharType(columnSize) : createUnboundedVarcharType();\n+                // Remote database can be case insensitive.\n+                PredicatePushdownController predicatePushdownController = PUSHDOWN_AND_KEEP;\n+                return Optional.of(ColumnMapping.sliceMapping(varcharType, varcharReadFunction(varcharType), varcharWriteFunction(), predicatePushdownController));\n+            case Types.DECIMAL:\n+                int precision = columnSize;\n+                int decimalDigits = typeHandle.getDecimalDigits().orElseThrow(() -> new IllegalStateException(\"decimal digits not present\"));\n+                if (getDecimalRounding(session) == ALLOW_OVERFLOW && precision > Decimals.MAX_PRECISION) {\n+                    int scale = min(decimalDigits, getDecimalDefaultScale(session));\n+                    return Optional.of(decimalColumnMapping(createDecimalType(Decimals.MAX_PRECISION, scale), getDecimalRoundingMode(session)));\n+                }\n+        }\n+\n+        // TODO add explicit mappings\n+        return super.toPrestoType(session, connection, typeHandle);\n+    }\n+\n+    @Override\n+    public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n+    {\n+        if (type instanceof VarcharType) {\n+            VarcharType varcharType = (VarcharType) type;\n+            String dataType;\n+            if (varcharType.isUnbounded()) {\n+                dataType = \"longtext\";\n+            }\n+            else if (varcharType.getBoundedLength() <= MEMSQL_VARCHAR_MAX_LENGTH) {\n+                dataType = \"varchar(\" + varcharType.getBoundedLength() + \")\";\n+            }\n+            else if (varcharType.getBoundedLength() <= 65535) {\n+                dataType = \"text\";\n+            }\n+            else if (varcharType.getBoundedLength() <= 16777215) {\n+                dataType = \"mediumtext\";\n+            }\n+            else {\n+                dataType = \"longtext\";\n+            }\n+            return WriteMapping.sliceMapping(dataType, varcharWriteFunction());\n+        }\n+        if (VARBINARY.equals(type)) {\n+            return WriteMapping.sliceMapping(\"mediumblob\", varbinaryWriteFunction());\n+        }\n+        if (type.equals(jsonType)) {\n+            return WriteMapping.sliceMapping(\"json\", varcharWriteFunction());\n+        }\n+        if (REAL.equals(type)) {\n+            return WriteMapping.longMapping(\"float\", realWriteFunction());\n+        }\n+        // TODO implement TIME type\n+        // TODO add support for other TIMESTAMP precisions\n+        if (TIMESTAMP_MILLIS.equals(type)) {\n+            return WriteMapping.longMapping(\"datetime\", timestampWriteFunction(TIMESTAMP_MILLIS));\n+        }\n+\n+        return super.toWriteMapping(session, type);\n+    }\n+\n+    @Override\n+    public void renameColumn(JdbcIdentity identity, JdbcTableHandle handle, JdbcColumnHandle jdbcColumn, String newColumnName)\n+    {\n+        try (Connection connection = connectionFactory.openConnection(identity)) {\n+            DatabaseMetaData metadata = connection.getMetaData();\n+            if (metadata.storesUpperCaseIdentifiers()) {\n+                newColumnName = newColumnName.toUpperCase(ENGLISH);\n+            }\n+            // MemSQL versions earlier than 5.7 do not support the CHANGE syntax\n+            String sql = format(\n+                    \"ALTER TABLE %s CHANGE %s %s\",\n+                    quoted(handle.getCatalogName(), handle.getSchemaName(), handle.getTableName()),\n+                    quoted(jdbcColumn.getColumnName()),\n+                    quoted(newColumnName));\n+            execute(connection, sql);\n+        }\n+        catch (SQLException e) {\n+            throw new PrestoException(JDBC_ERROR, e);\n+        }\n+    }\n+\n+    @Override\n+    public void renameTable(JdbcIdentity identity, JdbcTableHandle handle, SchemaTableName newTableName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3MTY0MQ==", "bodyText": "You did PUSHDOWN_AND_KEEP. Does it still fail?", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r509371641", "createdAt": "2020-10-21T15:10:15Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/test/java/io/prestosql/plugin/memsql/TestMemSqlDistributedQueries.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.memsql;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.testing.AbstractTestDistributedQueries;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.sql.SqlExecutor;\n+import io.prestosql.testing.sql.TestTable;\n+import io.prestosql.tpch.TpchTable;\n+import org.testng.SkipException;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.memsql.MemSqlQueryRunner.createMemSqlQueryRunner;\n+\n+public class TestMemSqlDistributedQueries\n+        extends AbstractTestDistributedQueries\n+{\n+    protected TestingMemSqlServer memSqlServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        memSqlServer = new TestingMemSqlServer();\n+        closeAfterClass(() -> {\n+            memSqlServer.close();\n+            memSqlServer = null;\n+        });\n+        return createMemSqlQueryRunner(\n+                memSqlServer,\n+                ImmutableMap.<String, String>builder()\n+                        // caching here speeds up tests highly, caching is not used in smoke tests\n+                        .put(\"metadata.cache-ttl\", \"10m\")\n+                        .put(\"metadata.cache-missing\", \"true\")\n+                        .build(),\n+                TpchTable.getTables());\n+    }\n+\n+    @Override\n+    protected boolean supportsDelete()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean supportsViews()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean supportsArrays()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean supportsCommentOnTable()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean supportsCommentOnColumn()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    protected TestTable createTableWithDefaultColumns()\n+    {\n+        return new TestTable(\n+                createJdbcSqlExecutor(),\n+                \"tpch.table\",\n+                \"(col_required BIGINT NOT NULL,\" +\n+                        \"col_nullable BIGINT,\" +\n+                        \"col_default BIGINT DEFAULT 43,\" +\n+                        \"col_nonnull_default BIGINT NOT NULL DEFAULT 42,\" +\n+                        \"col_required2 BIGINT NOT NULL)\");\n+    }\n+\n+    @Override\n+    protected Optional<DataMappingTestSetup> filterDataMappingSmokeTestData(DataMappingTestSetup dataMappingTestSetup)\n+    {\n+        String typeName = dataMappingTestSetup.getPrestoTypeName();\n+        if (typeName.equals(\"time\")\n+                || typeName.equals(\"timestamp(3) with time zone\")) {\n+            return Optional.of(dataMappingTestSetup.asUnsupported());\n+        }\n+\n+        if (typeName.equals(\"real\")\n+                || typeName.equals(\"timestamp\")) {\n+            // TODO this should either work or fail cleanly\n+            return Optional.empty();\n+        }\n+\n+        if (typeName.equals(\"varchar\")) {\n+            // TODO fails due to case insensitive UTF-8 comparisons", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3MzQ1MA==", "bodyText": "Having comment is good, but this shouldn't be a TODO, because that's nor our problem.", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r509373450", "createdAt": "2020-10-21T15:12:32Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/test/java/io/prestosql/plugin/memsql/TestMemSqlTypeMapping.java", "diffHunk": "@@ -300,6 +309,31 @@ public void testTimestamp()\n         throw new SkipException(\"TODO\");\n     }\n \n+    @Test\n+    public void testJson()\n+    {\n+        jsonTestCases(jsonDataType(value -> \"JSON \" + formatStringLiteral(value)))\n+                .execute(getQueryRunner(), prestoCreateAsSelect(\"presto_test_json\"));\n+        // TODO MemSQL doesn't support CAST to JSON but accepts string literals as JSON values", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE2Mzg5Nw=="}, "originalCommit": null, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NDc0Nw==", "bodyText": "Please do the static import in the commit which introduced this method.", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r509374747", "createdAt": "2020-10-21T15:14:17Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/test/java/io/prestosql/plugin/memsql/TestMemSqlTypeMapping.java", "diffHunk": "@@ -145,11 +154,11 @@ private static DataTypeTest doublePrecisionFloatingPointTests(DataType<Double> d\n     @Test\n     public void testUnsignedTypes()\n     {\n-        DataType<Short> memSqlUnsignedTinyInt = DataType.dataType(\"TINYINT UNSIGNED\", SmallintType.SMALLINT, Objects::toString);\n-        DataType<Integer> memSqlUnsignedSmallInt = DataType.dataType(\"SMALLINT UNSIGNED\", IntegerType.INTEGER, Objects::toString);\n-        DataType<Long> memSqlUnsignedInt = DataType.dataType(\"INT UNSIGNED\", BigintType.BIGINT, Objects::toString);\n-        DataType<Long> memSqlUnsignedInteger = DataType.dataType(\"INTEGER UNSIGNED\", BigintType.BIGINT, Objects::toString);\n-        DataType<BigDecimal> memSqlUnsignedBigint = DataType.dataType(\"BIGINT UNSIGNED\", createDecimalType(20), Objects::toString);\n+        DataType<Short> memSqlUnsignedTinyInt = dataType(\"TINYINT UNSIGNED\", SmallintType.SMALLINT, Objects::toString);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NTMyNg==", "bodyText": "please do the rename jsonDataType -> memSqlJsonDataType\nin the commit which intro'd the function", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r509375326", "createdAt": "2020-10-21T15:14:58Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/test/java/io/prestosql/plugin/memsql/TestMemSqlTypeMapping.java", "diffHunk": "@@ -517,18 +563,24 @@ private DataSetup prestoCreateAsSelect(Session session, String tableNamePrefix)\n         return new CreateAsSelectDataSetup(new PrestoSqlExecutor(getQueryRunner(), session), tableNamePrefix);\n     }\n \n+    private DataSetup prestoCreateAndInsert(Session session, String tableNamePrefix)\n+    {\n+        return new CreateAndInsertDataSetup(new PrestoSqlExecutor(getQueryRunner(), session), tableNamePrefix);\n+    }\n+\n     private DataSetup memSqlCreateAndInsert(String tableNamePrefix)\n     {\n         return new CreateAndInsertDataSetup(memSqlServer::execute, tableNamePrefix);\n     }\n \n-    private static DataType<String> jsonDataType(Function<String, String> toLiteral)\n+    private static DataType<LocalDate> memSqlDateDataType(Function<LocalDate, String> toLiteral)\n+    {\n+        return dataType(\"date\", DATE, toLiteral, identity());\n+    }\n+\n+    private static DataType<String> memSqlJsonDataType(Function<String, String> toLiteral)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NjAwNw==", "bodyText": "braces in the pattern are redundant.", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r509376007", "createdAt": "2020-10-21T15:15:47Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/test/java/io/prestosql/plugin/memsql/TestMemSqlDistributedQueries.java", "diffHunk": "@@ -116,13 +117,9 @@ protected TestTable createTableWithDefaultColumns()\n     }\n \n     @Override\n-    protected Optional<String> filterColumnNameTestData(String columnName)\n+    protected boolean isColumnNameRejected(Exception exception, String columnName, boolean delimited)\n     {\n-        // TODO fails with \"Multiple statements detected in a single query.\"\n-        if (columnName.equalsIgnoreCase(\"a;semicolon\")) {\n-            return Optional.empty();\n-        }\n-        return super.filterColumnNameTestData(columnName);\n+        return nullToEmpty(exception.getMessage()).matches(\".*(Incorrect column name).*\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NjU4OQ==", "bodyText": "let's remove the TODO. I wouldn't spent time on it\nsame for copyTableSchema", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r509376589", "createdAt": "2020-10-21T15:16:32Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -92,6 +95,33 @@ public MemSqlClient(BaseJdbcConfig config, ConnectionFactory connectionFactory,\n         this.jsonType = typeManager.getType(new TypeSignature(StandardTypes.JSON));\n     }\n \n+    @Override\n+    public void createTable(ConnectorSession session, ConnectorTableMetadata tableMetadata)\n+    {\n+        // MemSQL doesn't accept `some;column` in CTAS statements - so we explicitly block it and throw a proper error message\n+        // TODO figure out how to quote ; in column names", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NzM1Mg==", "bodyText": "you can get away without an assigment\n.findAny()\n.ifPresent(illegalColumnName -> {\n    throw ...\n\nsame in the other method", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r509377352", "createdAt": "2020-10-21T15:17:26Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -92,6 +95,33 @@ public MemSqlClient(BaseJdbcConfig config, ConnectionFactory connectionFactory,\n         this.jsonType = typeManager.getType(new TypeSignature(StandardTypes.JSON));\n     }\n \n+    @Override\n+    public void createTable(ConnectorSession session, ConnectorTableMetadata tableMetadata)\n+    {\n+        // MemSQL doesn't accept `some;column` in CTAS statements - so we explicitly block it and throw a proper error message\n+        // TODO figure out how to quote ; in column names\n+        Optional<String> illegalColumnName = tableMetadata.getColumns().stream()\n+                .map(ColumnMetadata::getName)\n+                .filter(s -> s.contains(\";\"))\n+                .findAny();\n+        if (illegalColumnName.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NzUzNw==", "bodyText": "break the line before .filter and .findAny", "url": "https://github.com/trinodb/trino/pull/5495#discussion_r509377537", "createdAt": "2020-10-21T15:17:38Z", "author": {"login": "findepi"}, "path": "presto-memsql/src/main/java/io/prestosql/plugin/memsql/MemSqlClient.java", "diffHunk": "@@ -92,6 +95,33 @@ public MemSqlClient(BaseJdbcConfig config, ConnectionFactory connectionFactory,\n         this.jsonType = typeManager.getType(new TypeSignature(StandardTypes.JSON));\n     }\n \n+    @Override\n+    public void createTable(ConnectorSession session, ConnectorTableMetadata tableMetadata)\n+    {\n+        // MemSQL doesn't accept `some;column` in CTAS statements - so we explicitly block it and throw a proper error message\n+        // TODO figure out how to quote ; in column names\n+        Optional<String> illegalColumnName = tableMetadata.getColumns().stream()\n+                .map(ColumnMetadata::getName)\n+                .filter(s -> s.contains(\";\"))\n+                .findAny();\n+        if (illegalColumnName.isPresent()) {\n+            throw new PrestoException(JDBC_ERROR, format(\"Incorrect column name '%s'\", illegalColumnName.get()));\n+        }\n+        super.createTable(session, tableMetadata);\n+    }\n+\n+    @Override\n+    protected void copyTableSchema(Connection connection, String catalogName, String schemaName, String tableName, String newTableName, List<String> columnNames)\n+    {\n+        // MemSQL doesn't accept `some;column` in CTAS statements - so we explicitly block it and throw a proper error message\n+        // TODO figure out how to quote ; in column names\n+        Optional<String> illegalColumnName = columnNames.stream().filter(s -> s.contains(\";\")).findAny();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f53576dcdc492889892cedba2d3c3900cb36fb8e", "author": {"user": {"login": "hashhar", "name": "Ashhar Hasan"}}, "url": "https://github.com/trinodb/trino/commit/f53576dcdc492889892cedba2d3c3900cb36fb8e", "committedDate": "2020-10-22T11:35:49Z", "message": "Add TestMemSqlDistributedQueries and implement gaps\n\nFixes #5263\nFixes #5369\nFixes #5452\nFixes #5453\nFixes #5454"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05d30409d9f99c33303ef72d95986d1f2a66dac1", "author": {"user": {"login": "hashhar", "name": "Ashhar Hasan"}}, "url": "https://github.com/trinodb/trino/commit/05d30409d9f99c33303ef72d95986d1f2a66dac1", "committedDate": "2020-10-22T11:35:49Z", "message": "Add MemSQL case-insensitive-name-matching tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42cc099f292b18a412775dde5e1860f5f096df2a", "author": {"user": {"login": "hashhar", "name": "Ashhar Hasan"}}, "url": "https://github.com/trinodb/trino/commit/42cc099f292b18a412775dde5e1860f5f096df2a", "committedDate": "2020-10-22T11:35:49Z", "message": "Add MemSQL predicate pushdown tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06dca4a1a5e3f5c02d2dbf55554926d65a2e6364", "author": {"user": {"login": "hashhar", "name": "Ashhar Hasan"}}, "url": "https://github.com/trinodb/trino/commit/06dca4a1a5e3f5c02d2dbf55554926d65a2e6364", "committedDate": "2020-10-22T11:35:49Z", "message": "Add MemSQL DATE tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "533a863f62bc37bf3152649b2dab6d57235585d4", "author": {"user": {"login": "hashhar", "name": "Ashhar Hasan"}}, "url": "https://github.com/trinodb/trino/commit/533a863f62bc37bf3152649b2dab6d57235585d4", "committedDate": "2020-10-22T11:35:50Z", "message": "Disallow columns with ; in MemSQL"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3374, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}