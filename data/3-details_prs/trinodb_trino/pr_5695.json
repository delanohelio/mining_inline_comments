{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwMjA4MDc5", "number": 5695, "title": "Add support for variable precision timestamps in Hive array, map, and struct", "bodyText": "Fixes #5195.", "createdAt": "2020-10-26T17:57:51Z", "url": "https://github.com/trinodb/trino/pull/5695", "merged": true, "mergeCommit": {"oid": "8e3b9af221f28d26f0a35c9622971f4398b1ef17"}, "closed": true, "closedAt": "2021-01-06T22:23:26Z", "author": {"login": "jirassimok"}, "timelineItems": {"totalCount": 44, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdWahS0AFqTUxNzE1NTgzOQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdtVFyGgFqTU2MjI2MzM5NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MTU1ODM5", "url": "https://github.com/trinodb/trino/pull/5695#pullrequestreview-517155839", "createdAt": "2020-10-26T20:37:27Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDozNzoyOFrOHohakQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDozNzoyOFrOHohakQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1MjU2MQ==", "bodyText": "This check was already in the class, but when does it come up? SerDeUtils is only used to read structural types in GenericHiveRecordCursor, and that class always assumes that the object can be read by the associated inspector, as in the else block a few lines down.", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r512252561", "createdAt": "2020-10-26T20:37:28Z", "author": {"login": "jirassimok"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/util/SerDeUtils.java", "diffHunk": "@@ -312,11 +321,22 @@ private static long formatDateAsLong(Object object, DateObjectInspector inspecto\n         return inspector.getPrimitiveJavaObject(object).toEpochDay();\n     }\n \n-    private static long formatTimestampAsLong(Object object, TimestampObjectInspector inspector)\n+    private static DecodedTimestamp formatTimestamp(TimestampType type, Object object, TimestampObjectInspector inspector)\n     {\n+        long seconds;\n+        int nanos;\n+\n         if (object instanceof TimestampWritable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 65}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MTk1MzUw", "url": "https://github.com/trinodb/trino/pull/5695#pullrequestreview-519195350", "createdAt": "2020-10-29T00:14:41Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwMDoxNDo0MVrOHqCCxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwMDoxNDo0MVrOHqCCxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgzNTcxNg==", "bodyText": "I prefer the SQL comma style from the earlier commits because it makes it easier to avoid missing commas. But it also looks weird, so here's a commit I can squash if other people don't like it.\n(The \\ns are there for similar reasons, to make it easier to see when there is or isn't whitespace between the lines.)", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r513835716", "createdAt": "2020-10-29T00:14:41Z", "author": {"login": "jirassimok"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -443,11 +443,11 @@ public void testStructTimestamps(StorageFormat format)\n \n         onPresto().executeQuery(format(\n                 \"CREATE TABLE %s (\\n\"\n-                        + \"id INTEGER\\n\"\n-                        + \",arr ARRAY(TIMESTAMP)\\n\"\n-                        + \",map MAP(TIMESTAMP, TIMESTAMP)\\n\"\n-                        + \",row ROW(col TIMESTAMP)\\n\"\n-                        + \",nested ARRAY(MAP(TIMESTAMP, ROW(col ARRAY(TIMESTAMP))))\\n\"\n+                        + \"id INTEGER,\\n\"\n+                        + \"arr ARRAY(TIMESTAMP),\\n\"\n+                        + \"map MAP(TIMESTAMP, TIMESTAMP),\\n\"\n+                        + \"row ROW(col TIMESTAMP),\\n\"\n+                        + \"nested ARRAY(MAP(TIMESTAMP, ROW(col ARRAY(TIMESTAMP))))\\n\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NDczODc0", "url": "https://github.com/trinodb/trino/pull/5695#pullrequestreview-529473874", "createdAt": "2020-11-12T20:31:21Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMDozMToyMVrOHyNP5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMDozMToyMVrOHyNP5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQwNzkwOQ==", "bodyText": "This is concerning, and I don't know what caused it.", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r522407909", "createdAt": "2020-11-12T20:31:21Z", "author": {"login": "jirassimok"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -453,22 +453,23 @@ public void testStructTimestamps(StorageFormat format)\n                 tableName,\n                 format.getStoragePropertiesAsSql()));\n \n-        onHive().executeQuery(format(\n-                \"INSERT INTO %s %s\",\n-                tableName,\n-                TIMESTAMPS_FROM_HIVE.stream()\n-                        .map(entry -> format(\n-                                \"SELECT\\n\"\n-                                        + \"%s\\n\"\n-                                        + \",arr(%2$s)\\n\"\n-                                        + \",map(%2$s, %2$s)\\n\"\n-                                        + \",named_struct('col', %2$s)\\n\"\n-                                        + \",array(map(%2$s, named_struct('col', array(%2$s))))\\n\"\n-                                        // some hive versions don't allow insert from bare select\n-                                        + \"FROM (SELECT 1) t\\n\",\n-                                entry.getId(),\n-                                format(\"TIMESTAMP '%s'\", entry.getWriteValue())))\n-                        .collect(Collectors.joining(\" UNION ALL \"))));\n+        // Insert in a loop because inserting with UNION ALL sometimes makes values invisible to Presto", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5Mzk2MTI5", "url": "https://github.com/trinodb/trino/pull/5695#pullrequestreview-539396129", "createdAt": "2020-11-26T15:12:41Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNToxMjo0MVrOH6fUNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNToyMjowNFrOH6fpuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA5MjUzNA==", "bodyText": "inline", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r531092534", "createdAt": "2020-11-26T15:12:41Z", "author": {"login": "findepi"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestBackgroundHiveSplitLoader.java", "diffHunk": "@@ -123,6 +123,7 @@\n public class TestBackgroundHiveSplitLoader\n {\n     private static final int BUCKET_COUNT = 2;\n+    private static final HiveTimestampPrecision TIMESTAMP_PRECISION = HiveTimestampPrecision.MILLISECONDS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA5MzkxOA==", "bodyText": "\"Use the passed type to serialize in SerDeUtils\" commit looks good. Can you split it out to a separate PR to reduce scope of this PR?", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r531093918", "createdAt": "2020-11-26T15:15:03Z", "author": {"login": "findepi"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/util/SerDeUtils.java", "diffHunk": "@@ -114,25 +104,25 @@ private static void serializePrimitive(Type type, BlockBuilder builder, Object o\n \n         switch (inspector.getPrimitiveCategory()) {\n             case BOOLEAN:\n-                BooleanType.BOOLEAN.writeBoolean(builder, ((BooleanObjectInspector) inspector).get(object));\n+                type.writeBoolean(builder, ((BooleanObjectInspector) inspector).get(object));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA5NDkyOA==", "bodyText": "keep this line directly below this elaborate comment adorning it", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r531094928", "createdAt": "2020-11-26T15:16:41Z", "author": {"login": "findepi"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveType.java", "diffHunk": "@@ -258,26 +256,26 @@ private static TypeSignature getTypeSignature(TypeInfo typeInfo)\n                 }\n                 ImmutableList.Builder<TypeSignatureParameter> typeSignatureBuilder = ImmutableList.builder();\n                 for (int i = 0; i < structFieldTypeInfos.size(); i++) {\n-                    TypeSignature typeSignature = getTypeSignature(structFieldTypeInfos.get(i));\n                     // Lower case the struct field names.\n                     // Otherwise, Presto will refuse to write to columns whose struct type has field names containing upper case characters.\n                     // Users can't work around this by casting in their queries because Presto parser always lower case types.\n                     // TODO: This is a hack. Presto engine should be able to handle identifiers in a case insensitive way where necessary.\n-                    String rowFieldName = structFieldNames.get(i).toLowerCase(Locale.US);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA5NjYwMQ==", "bodyText": "\"Simplify HiveType.getTypeSignature with factory methods\" also looks good % one comment.\nYou can split it out together with \"Use the passed type to serialize in SerDeUtils\"", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r531096601", "createdAt": "2020-11-26T15:19:38Z", "author": {"login": "findepi"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveType.java", "diffHunk": "@@ -238,17 +240,13 @@ private static TypeSignature getTypeSignature(TypeInfo typeInfo)\n                 return primitiveType.getTypeSignature();\n             case MAP:\n                 MapTypeInfo mapTypeInfo = (MapTypeInfo) typeInfo;\n-                TypeSignature keyType = getTypeSignature(mapTypeInfo.getMapKeyTypeInfo());\n-                TypeSignature valueType = getTypeSignature(mapTypeInfo.getMapValueTypeInfo());\n-                return new TypeSignature(\n-                        StandardTypes.MAP,\n-                        ImmutableList.of(TypeSignatureParameter.typeParameter(keyType), TypeSignatureParameter.typeParameter(valueType)));\n+                return mapType(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA5NzYwMw==", "bodyText": "Streams.zip does not necessarily improve readability, because i need to think what's the behavior when zipped streams have different lengths. I'd suggest dropping this change.", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r531097603", "createdAt": "2020-11-26T15:21:19Z", "author": {"login": "findepi"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveType.java", "diffHunk": "@@ -254,17 +256,15 @@ private static TypeSignature getTypeSignature(TypeInfo typeInfo)\n                 if (fieldTypes.size() != fieldNames.size()) {\n                     throw new PrestoException(HiveErrorCode.HIVE_INVALID_METADATA, format(\"Invalid Hive struct type: %s\", typeInfo));\n                 }\n-                ImmutableList.Builder<TypeSignatureParameter> typeSignatureBuilder = ImmutableList.builder();\n-                for (int i = 0; i < fieldTypes.size(); i++) {\n-                    // Lower case the struct field names.\n-                    // Otherwise, Presto will refuse to write to columns whose struct type has field names containing upper case characters.\n-                    // Users can't work around this by casting in their queries because Presto parser always lower case types.\n-                    // TODO: This is a hack. Presto engine should be able to handle identifiers in a case insensitive way where necessary.\n-                    typeSignatureBuilder.add(namedField(\n-                            fieldNames.get(i).toLowerCase(Locale.US),\n-                            getTypeSignature(fieldTypes.get(i))));\n-                }\n-                return rowType(typeSignatureBuilder.build());\n+                // We lower case the struct field names.\n+                // Otherwise, Presto will refuse to write to columns whose struct type has field names containing upper case characters.\n+                // Users can't work around this by casting in their queries because Presto parser always lower case types.\n+                // TODO: This is a hack. Presto engine should be able to handle identifiers in a case insensitive way where necessary.\n+                return rowType(Streams.zip(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA5ODA0MQ==", "bodyText": "the name of the class is \"translator\", so \"translate\" is not a bad name, is it?", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r531098041", "createdAt": "2020-11-26T15:22:04Z", "author": {"login": "findepi"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/util/HiveTypeTranslator.java", "diffHunk": "@@ -64,7 +64,7 @@\n {\n     private HiveTypeTranslator() {}\n \n-    public static TypeInfo translate(Type type)\n+    public static TypeInfo toTypeInfo(Type type)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTcxMTA0", "url": "https://github.com/trinodb/trino/pull/5695#pullrequestreview-549971104", "createdAt": "2020-12-11T10:20:39Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTcyMDk1", "url": "https://github.com/trinodb/trino/pull/5695#pullrequestreview-549972095", "createdAt": "2020-12-11T10:21:59Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTczMDQz", "url": "https://github.com/trinodb/trino/pull/5695#pullrequestreview-549973043", "createdAt": "2020-12-11T10:23:20Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDoyMzoyMFrOIDycFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDoyMzoyMFrOIDycFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MzAzMQ==", "bodyText": "Annotate the method @Nullable", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r540843031", "createdAt": "2020-12-11T10:23:20Z", "author": {"login": "findepi"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/util/HiveTypeTranslator.java", "diffHunk": "@@ -149,4 +173,90 @@ public static TypeInfo toTypeInfo(Type type)\n         }\n         throw new PrestoException(NOT_SUPPORTED, format(\"Unsupported Hive type: %s\", type));\n     }\n+\n+    public static TypeSignature toTypeSignature(TypeInfo typeInfo)\n+    {\n+        switch (typeInfo.getCategory()) {\n+            case PRIMITIVE:\n+                Type primitiveType = fromPrimitiveType((PrimitiveTypeInfo) typeInfo);\n+                if (primitiveType == null) {\n+                    break;\n+                }\n+                return primitiveType.getTypeSignature();\n+            case MAP:\n+                MapTypeInfo mapTypeInfo = (MapTypeInfo) typeInfo;\n+                return mapType(\n+                        toTypeSignature(mapTypeInfo.getMapKeyTypeInfo()),\n+                        toTypeSignature(mapTypeInfo.getMapValueTypeInfo()));\n+            case LIST:\n+                ListTypeInfo listTypeInfo = (ListTypeInfo) typeInfo;\n+                TypeSignature elementType = toTypeSignature(listTypeInfo.getListElementTypeInfo());\n+                return arrayType(typeParameter(elementType));\n+            case STRUCT:\n+                StructTypeInfo structTypeInfo = (StructTypeInfo) typeInfo;\n+                List<TypeInfo> fieldTypes = structTypeInfo.getAllStructFieldTypeInfos();\n+                List<String> fieldNames = structTypeInfo.getAllStructFieldNames();\n+                if (fieldTypes.size() != fieldNames.size()) {\n+                    throw new PrestoException(HiveErrorCode.HIVE_INVALID_METADATA, format(\"Invalid Hive struct type: %s\", typeInfo));\n+                }\n+                return rowType(Streams.zip(\n+                        // We lower case the struct field names.\n+                        // Otherwise, Presto will refuse to write to columns whose struct type has field names containing upper case characters.\n+                        // Users can't work around this by casting in their queries because Presto parser always lower case types.\n+                        // TODO: This is a hack. Presto engine should be able to handle identifiers in a case insensitive way where necessary.\n+                        fieldNames.stream().map(s -> s.toLowerCase(Locale.US)),\n+                        fieldTypes.stream().map(HiveTypeTranslator::toTypeSignature),\n+                        TypeSignatureParameter::namedField)\n+                        .collect(Collectors.toList()));\n+            case UNION:\n+                // Use a row type to represent a union type in Hive for reading\n+                UnionTypeInfo unionTypeInfo = (UnionTypeInfo) typeInfo;\n+                List<TypeInfo> unionObjectTypes = unionTypeInfo.getAllUnionObjectTypeInfos();\n+                ImmutableList.Builder<TypeSignatureParameter> typeSignatures = ImmutableList.builder();\n+                typeSignatures.add(namedField(\"tag\", TINYINT.getTypeSignature()));\n+                for (int i = 0; i < unionObjectTypes.size(); i++) {\n+                    TypeInfo unionObjectType = unionObjectTypes.get(i);\n+                    typeSignatures.add(namedField(\"field\" + i, toTypeSignature(unionObjectType)));\n+                }\n+                return rowType(typeSignatures.build());\n+        }\n+        throw new PrestoException(NOT_SUPPORTED, format(\"Unsupported Hive type: %s\", typeInfo));\n+    }\n+\n+    public static Type fromPrimitiveType(PrimitiveTypeInfo typeInfo)\n+    {\n+        switch (typeInfo.getPrimitiveCategory()) {\n+            case BOOLEAN:\n+                return BOOLEAN;\n+            case BYTE:\n+                return TINYINT;\n+            case SHORT:\n+                return SMALLINT;\n+            case INT:\n+                return INTEGER;\n+            case LONG:\n+                return BIGINT;\n+            case FLOAT:\n+                return REAL;\n+            case DOUBLE:\n+                return DOUBLE;\n+            case STRING:\n+                return createUnboundedVarcharType();\n+            case VARCHAR:\n+                return createVarcharType(((VarcharTypeInfo) typeInfo).getLength());\n+            case CHAR:\n+                return createCharType(((CharTypeInfo) typeInfo).getLength());\n+            case DATE:\n+                return DATE;\n+            case TIMESTAMP:\n+                return TIMESTAMP_MILLIS;\n+            case BINARY:\n+                return VARBINARY;\n+            case DECIMAL:\n+                DecimalTypeInfo decimalTypeInfo = (DecimalTypeInfo) typeInfo;\n+                return createDecimalType(decimalTypeInfo.precision(), decimalTypeInfo.scale());\n+            default:\n+                return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 144}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTc2NzY0", "url": "https://github.com/trinodb/trino/pull/5695#pullrequestreview-549976764", "createdAt": "2020-12-11T10:28:29Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDoyODoyOVrOIDyopg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDozMDoxNFrOIDysow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NjI0Ng==", "bodyText": "you can replace the Map with an ordinary switch (keep it simple), which will allow you to add default case throwing cleanly in case of a new, unsupported HiveTimestampPrecision.", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r540846246", "createdAt": "2020-12-11T10:28:29Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -675,18 +554,42 @@ public String toString()\n         }\n     }\n \n+    /**\n+     * Create {@code TimestampAndPrecision} with specified write precision and rounded fractional seconds.\n+     * @param precision Precision for writing value.\n+     * @param writeValue The literal value to write.\n+     * @param milliFraction Expected fraction when reading with millisecond precision.\n+     * @param microFraction Expected fraction when reading with microsecond precision.\n+     * @param nanoFraction Expected fraction when reading with nanosecond precision.\n+     */\n+    private static TimestampAndPrecision timestampAndPrecision(\n+            HiveTimestampPrecision precision,\n+            String writeValue,\n+            String milliFraction,\n+            String microFraction,\n+            String nanoFraction)\n+    {\n+        // Remove fractional second from write value\n+        String writeValueNoFraction = writeValue.split(\"\\\\.\")[0];\n+        Map<HiveTimestampPrecision, String> readValues = Map.of(\n+                MILLISECONDS, writeValueNoFraction + \".\" + milliFraction,\n+                MICROSECONDS, writeValueNoFraction + \".\" + microFraction,\n+                NANOSECONDS, writeValueNoFraction + \".\" + nanoFraction);\n+        return new TimestampAndPrecision(precision, readValues.get(precision), readValues);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NzI2Nw==", "bodyText": "This is not correct, but we do not have such a test case yet.\nWe should have test cases:\n\nwhen written value has .9995 second fraction and read back will milli precision comes as +1 second\nwhen written value has .9999995 second fraction and read back will micros precision comes as +1 second\nwhen written value has .999999999 second fraction", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r540847267", "createdAt": "2020-12-11T10:30:14Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -675,18 +554,42 @@ public String toString()\n         }\n     }\n \n+    /**\n+     * Create {@code TimestampAndPrecision} with specified write precision and rounded fractional seconds.\n+     * @param precision Precision for writing value.\n+     * @param writeValue The literal value to write.\n+     * @param milliFraction Expected fraction when reading with millisecond precision.\n+     * @param microFraction Expected fraction when reading with microsecond precision.\n+     * @param nanoFraction Expected fraction when reading with nanosecond precision.\n+     */\n+    private static TimestampAndPrecision timestampAndPrecision(\n+            HiveTimestampPrecision precision,\n+            String writeValue,\n+            String milliFraction,\n+            String microFraction,\n+            String nanoFraction)\n+    {\n+        // Remove fractional second from write value\n+        String writeValueNoFraction = writeValue.split(\"\\\\.\")[0];\n+        Map<HiveTimestampPrecision, String> readValues = Map.of(\n+                MILLISECONDS, writeValueNoFraction + \".\" + milliFraction,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 262}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTgwNjgz", "url": "https://github.com/trinodb/trino/pull/5695#pullrequestreview-549980683", "createdAt": "2020-12-11T10:33:52Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDozMzo1MlrOIDy1lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMToyMzoyNVrOID0mdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0OTU1OA==", "bodyText": "My intellij automatically reformats this line into multiline form.", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r540849558", "createdAt": "2020-12-11T10:33:52Z", "author": {"login": "findepi"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveType.java", "diffHunk": "@@ -93,11 +93,19 @@ public TypeInfo getTypeInfo()\n         return typeInfo;\n     }\n \n+    /** @deprecated Prefer {@link #getTypeSignature(HiveTimestampPrecision)}. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2MjE3NQ==", "bodyText": "instead of passing \"unchecked\" DEFAULT_PRECISION, we should pass Optional<HiveTimestampPrecision>\n\nthere are places where hive.timestamp-precision doesn't matter --  a bunch of places dealing with bucketing columns, and timestamp cannot be bucketed on in Presto\n\nit will be hard to find motivation to fix those cases, we will be tempted to use the now-deprecated methods\n\n\npassing Optional.empty will allow us to signal \"timestamp precision cannot matter here\"; and will also allow us to validate this in fromPrimitiveType(PrimitiveTypeInfo typeInfo, below\n\nProbably the Optional-taking method should be a public overload, so that we can call it directly in those places where we deal with bucketing columns. Currently we call the deprecated overload there, which looks not good, if we don't have plans to \"fix\" it.", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r540862175", "createdAt": "2020-12-11T10:54:57Z", "author": {"login": "findepi"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveType.java", "diffHunk": "@@ -93,11 +93,19 @@ public TypeInfo getTypeInfo()\n         return typeInfo;\n     }\n \n+    /** @deprecated Prefer {@link #getTypeSignature(HiveTimestampPrecision)}. */\n+    @Deprecated\n     public TypeSignature getTypeSignature()\n     {\n-        return toTypeSignature(typeInfo);\n+        return getTypeSignature(DEFAULT_PRECISION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NTM0Ng==", "bodyText": "epochSecond", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r540865346", "createdAt": "2020-12-11T11:00:16Z", "author": {"login": "findepi"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/util/SerDeUtils.java", "diffHunk": "@@ -312,11 +321,22 @@ private static long formatDateAsLong(Object object, DateObjectInspector inspecto\n         return inspector.getPrimitiveJavaObject(object).toEpochDay();\n     }\n \n-    private static long formatTimestampAsLong(Object object, TimestampObjectInspector inspector)\n+    private static DecodedTimestamp formatTimestamp(TimestampType type, Object object, TimestampObjectInspector inspector)\n     {\n+        long seconds;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NTUyOQ==", "bodyText": "nanosOfSecond", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r540865529", "createdAt": "2020-12-11T11:00:35Z", "author": {"login": "findepi"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/util/SerDeUtils.java", "diffHunk": "@@ -312,11 +321,22 @@ private static long formatDateAsLong(Object object, DateObjectInspector inspecto\n         return inspector.getPrimitiveJavaObject(object).toEpochDay();\n     }\n \n-    private static long formatTimestampAsLong(Object object, TimestampObjectInspector inspector)\n+    private static DecodedTimestamp formatTimestamp(TimestampType type, Object object, TimestampObjectInspector inspector)\n     {\n+        long seconds;\n+        int nanos;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NjQ3NQ==", "bodyText": "rounding here may move you to next second (ie may return NANOS_PER_SECOND)\nthis needs to be handled here before invoking the DecodedTimestamp ctor", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r540866475", "createdAt": "2020-12-11T11:02:10Z", "author": {"login": "findepi"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/util/SerDeUtils.java", "diffHunk": "@@ -312,11 +321,22 @@ private static long formatDateAsLong(Object object, DateObjectInspector inspecto\n         return inspector.getPrimitiveJavaObject(object).toEpochDay();\n     }\n \n-    private static long formatTimestampAsLong(Object object, TimestampObjectInspector inspector)\n+    private static DecodedTimestamp formatTimestamp(TimestampType type, Object object, TimestampObjectInspector inspector)\n     {\n+        long seconds;\n+        int nanos;\n+\n         if (object instanceof TimestampWritable) {\n-            return ((TimestampWritable) object).getTimestamp().getTime() * MICROSECONDS_PER_MILLISECOND;\n+            LocalDateTime datetime = ((TimestampWritable) object).getTimestamp().toLocalDateTime();\n+            seconds = datetime.toEpochSecond(UTC);\n+            nanos = datetime.getNano();\n+        }\n+        else {\n+            Timestamp timestamp = inspector.getPrimitiveJavaObject(object);\n+            seconds = timestamp.toEpochSecond();\n+            nanos = timestamp.getNanos();\n         }\n-        return inspector.getPrimitiveJavaObject(object).toEpochMilli() * MICROSECONDS_PER_MILLISECOND;\n+\n+        return new DecodedTimestamp(seconds, (int) round(nanos, 9 - type.getPrecision()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NjczNA==", "bodyText": "I don't understand this comment", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r540866734", "createdAt": "2020-12-11T11:02:32Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -68,6 +71,32 @@\n     @Named(\"databases.presto.admin_role_enabled\")\n     private boolean adminRoleEnabled;\n \n+    // Declare these statically so they have the same IDs in every test", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NzcxMg==", "bodyText": "Is the data visible in Hive, but not in Presto?\nor, is it just a bug in INSERT + UNION ALL in (some version(s) of) Hive?", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r540867712", "createdAt": "2020-12-11T11:04:15Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -453,22 +453,23 @@ public void testStructTimestamps(StorageFormat format)\n                 tableName,\n                 format.getStoragePropertiesAsSql()));\n \n-        onHive().executeQuery(format(\n-                \"INSERT INTO %s %s\",\n-                tableName,\n-                TIMESTAMPS_FROM_HIVE.stream()\n-                        .map(entry -> format(\n-                                \"SELECT\\n\"\n-                                        + \"%s\\n\"\n-                                        + \",arr(%2$s)\\n\"\n-                                        + \",map(%2$s, %2$s)\\n\"\n-                                        + \",named_struct('col', %2$s)\\n\"\n-                                        + \",array(map(%2$s, named_struct('col', array(%2$s))))\\n\"\n-                                        // some hive versions don't allow insert from bare select\n-                                        + \"FROM (SELECT 1) t\\n\",\n-                                entry.getId(),\n-                                format(\"TIMESTAMP '%s'\", entry.getWriteValue())))\n-                        .collect(Collectors.joining(\" UNION ALL \"))));\n+        // Insert in a loop because inserting with UNION ALL sometimes makes values invisible to Presto", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQwNzkwOQ=="}, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2ODA2NQ==", "bodyText": "bans -> does not support", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r540868065", "createdAt": "2020-12-11T11:04:51Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -430,6 +434,83 @@ private void runTimestampQueries(String tableName, List<TimestampAndPrecision> d\n         onPresto().executeQuery(\"DROP TABLE \" + tableName);\n     }\n \n+    @Test(dataProvider = \"storageFormatsWithNanosecondPrecision\", groups = STORAGE_FORMATS)\n+    public void testStructTimestamps(StorageFormat format)\n+            throws SQLException\n+    {\n+        setAdminRole(onPresto().getConnection());\n+        ensureDummyExists();\n+\n+        String tableName = format(\"test_struct_timestamp_precision_%s_%s\", format.getName().toLowerCase(Locale.ENGLISH), randomTableSuffix());\n+\n+        onPresto().executeQuery(format(\n+                \"CREATE TABLE %s (\\n\"\n+                        + \"id INTEGER\\n\"\n+                        + \",arr ARRAY(TIMESTAMP)\\n\"\n+                        + \",map MAP(TIMESTAMP, TIMESTAMP)\\n\"\n+                        + \",row ROW(col TIMESTAMP)\\n\"\n+                        + \",nested ARRAY(MAP(TIMESTAMP, ROW(col ARRAY(TIMESTAMP))))\\n\"\n+                        + \") WITH (%s)\",\n+                tableName,\n+                format.getStoragePropertiesAsSql()));\n+\n+        // Insert in a loop because inserting with UNION ALL sometimes makes values invisible to Presto\n+        for (TimestampAndPrecision entry : TIMESTAMPS_FROM_HIVE) {\n+            onHive().executeQuery(format(\n+                    \"INSERT INTO %1$s\\n\"\n+                            // insert with SELECT because hive bans array/map/struct functions in VALUES", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2ODgzNQ==", "bodyText": "i like the convention of , at the line start because it allows be to add new line without modifying the previous line, resulting in cleaner diff\nthis is not a convention in the project though, so i'd recommend putting the comma at line's end\nalso, \\n is redundant, and reads worse than just a space", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r540868835", "createdAt": "2020-12-11T11:06:14Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -430,6 +434,83 @@ private void runTimestampQueries(String tableName, List<TimestampAndPrecision> d\n         onPresto().executeQuery(\"DROP TABLE \" + tableName);\n     }\n \n+    @Test(dataProvider = \"storageFormatsWithNanosecondPrecision\", groups = STORAGE_FORMATS)\n+    public void testStructTimestamps(StorageFormat format)\n+            throws SQLException\n+    {\n+        setAdminRole(onPresto().getConnection());\n+        ensureDummyExists();\n+\n+        String tableName = format(\"test_struct_timestamp_precision_%s_%s\", format.getName().toLowerCase(Locale.ENGLISH), randomTableSuffix());\n+\n+        onPresto().executeQuery(format(\n+                \"CREATE TABLE %s (\\n\"\n+                        + \"id INTEGER\\n\"\n+                        + \",arr ARRAY(TIMESTAMP)\\n\"\n+                        + \",map MAP(TIMESTAMP, TIMESTAMP)\\n\"\n+                        + \",row ROW(col TIMESTAMP)\\n\"\n+                        + \",nested ARRAY(MAP(TIMESTAMP, ROW(col ARRAY(TIMESTAMP))))\\n\"\n+                        + \") WITH (%s)\",\n+                tableName,\n+                format.getStoragePropertiesAsSql()));\n+\n+        // Insert in a loop because inserting with UNION ALL sometimes makes values invisible to Presto\n+        for (TimestampAndPrecision entry : TIMESTAMPS_FROM_HIVE) {\n+            onHive().executeQuery(format(\n+                    \"INSERT INTO %1$s\\n\"\n+                            // insert with SELECT because hive bans array/map/struct functions in VALUES\n+                            + \"SELECT\\n\"\n+                            + \"%3$s\\n\"\n+                            + \",array(%2$s)\\n\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2OTk3OQ==", "bodyText": "That's hard to read. Why not just read the value and check it is exactly as expected?\nSee also #6297", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r540869979", "createdAt": "2020-12-11T11:08:08Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -430,6 +434,83 @@ private void runTimestampQueries(String tableName, List<TimestampAndPrecision> d\n         onPresto().executeQuery(\"DROP TABLE \" + tableName);\n     }\n \n+    @Test(dataProvider = \"storageFormatsWithNanosecondPrecision\", groups = STORAGE_FORMATS)\n+    public void testStructTimestamps(StorageFormat format)\n+            throws SQLException\n+    {\n+        setAdminRole(onPresto().getConnection());\n+        ensureDummyExists();\n+\n+        String tableName = format(\"test_struct_timestamp_precision_%s_%s\", format.getName().toLowerCase(Locale.ENGLISH), randomTableSuffix());\n+\n+        onPresto().executeQuery(format(\n+                \"CREATE TABLE %s (\\n\"\n+                        + \"id INTEGER\\n\"\n+                        + \",arr ARRAY(TIMESTAMP)\\n\"\n+                        + \",map MAP(TIMESTAMP, TIMESTAMP)\\n\"\n+                        + \",row ROW(col TIMESTAMP)\\n\"\n+                        + \",nested ARRAY(MAP(TIMESTAMP, ROW(col ARRAY(TIMESTAMP))))\\n\"\n+                        + \") WITH (%s)\",\n+                tableName,\n+                format.getStoragePropertiesAsSql()));\n+\n+        // Insert in a loop because inserting with UNION ALL sometimes makes values invisible to Presto\n+        for (TimestampAndPrecision entry : TIMESTAMPS_FROM_HIVE) {\n+            onHive().executeQuery(format(\n+                    \"INSERT INTO %1$s\\n\"\n+                            // insert with SELECT because hive bans array/map/struct functions in VALUES\n+                            + \"SELECT\\n\"\n+                            + \"%3$s\\n\"\n+                            + \",array(%2$s)\\n\"\n+                            + \",map(%2$s, %2$s)\\n\"\n+                            + \",named_struct('col', %2$s)\\n\"\n+                            + \",array(map(%2$s, named_struct('col', array(%2$s))))\\n\"\n+                            // some hive versions don't allow INSERT from SELECT without FROM\n+                            + \"FROM dummy\\n\",\n+                    tableName,\n+                    format(\"TIMESTAMP '%s'\", entry.getWriteValue()),\n+                    entry.getId()));\n+        }\n+\n+        for (HiveTimestampPrecision precision : HiveTimestampPrecision.values()) {\n+            setSessionProperty(onPresto().getConnection(), \"hive.timestamp_precision\", precision.name());\n+            assertThat(onPresto()\n+                    .executeQuery(format(\n+                            \"SELECT\\n\"\n+                                    + \"id\\n\"\n+                                    + \",arr[1]\\n\"\n+                                    + \",map_entries(map)[1][1]\\n\" // key\n+                                    + \",map_entries(map)[1][2]\\n\" // value\n+                                    + \",row.col\\n\"\n+                                    + \",map_entries(nested[1])[1][1]\\n\" // key\n+                                    + \",map_entries(nested[1])[1][2].col[1]\\n\" // value\n+                                    + \"FROM %s\\n\"\n+                                    + \"ORDER BY id\\n\",\n+                            tableName)))\n+                    .as(\"timestamp containers on %s\", format.getName().toLowerCase(Locale.ENGLISH))\n+                    .containsExactly(TIMESTAMPS_FROM_HIVE.stream()\n+                            .sorted(comparingInt(TimestampAndPrecision::getId))\n+                            .map(e -> new Row(Lists.asList(\n+                                    e.getId(),\n+                                    nCopies(6, Timestamp.valueOf(e.getReadValue(precision))).toArray())))\n+                            .collect(toList()));\n+\n+            for (TimestampAndPrecision entry : TIMESTAMPS_FROM_HIVE) {\n+                if (entry.isRounded(precision)) {\n+                    // Check rounding in the array column\n+                    assertThat(onPresto()\n+                            .executeQuery(format(\n+                                    \"SELECT id FROM %2$s WHERE id = %3$s AND TIMESTAMP '%4$s' %1$c arr[1]\",\n+                                    entry.isRoundedUp(precision) ? '<' : '>',", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3MDMxMA==", "bodyText": "Is it related to authentication?", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r540870310", "createdAt": "2020-12-11T11:08:45Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -465,6 +546,21 @@ private void setAdminRole(Connection connection)\n         }\n     }\n \n+    /**\n+     * Ensures that a view named \"dummy\" with exactly one row exists in the default schema.\n+     */\n+    // These tests run on versions of Hive (1.0.0 on CDH 5) that don't fully support SELECT without FROM\n+    // (particularly when using certain forms of authentication).", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3MDUwNQ==", "bodyText": "i think CDH 5 uses Hive 1.1.x, not 1.0.0 ?", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r540870505", "createdAt": "2020-12-11T11:09:03Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -465,6 +546,21 @@ private void setAdminRole(Connection connection)\n         }\n     }\n \n+    /**\n+     * Ensures that a view named \"dummy\" with exactly one row exists in the default schema.\n+     */\n+    // These tests run on versions of Hive (1.0.0 on CDH 5) that don't fully support SELECT without FROM", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3MTQxMQ==", "bodyText": "Let's not implicate views here. Let's just have single-row table.\nI see you're concerned someone will add a second row to the table and thus it won't be single-row table anymore, but that would be rogue and tests would fail telling us about that. thus i wouldn't be concerned about that.", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r540871411", "createdAt": "2020-12-11T11:10:33Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -465,6 +546,21 @@ private void setAdminRole(Connection connection)\n         }\n     }\n \n+    /**\n+     * Ensures that a view named \"dummy\" with exactly one row exists in the default schema.\n+     */\n+    // These tests run on versions of Hive (1.0.0 on CDH 5) that don't fully support SELECT without FROM\n+    // (particularly when using certain forms of authentication).\n+    private void ensureDummyExists()\n+            throws SQLException\n+    {\n+        onHive().executeQuery(\"CREATE TABLE IF NOT EXISTS `_dummy_table_` (`_dummy_column_` varchar(1))\");\n+        onHive().executeQuery(\"INSERT INTO `_dummy_table_` VALUES ('x')\");\n+        onHive().executeQuery(\n+                \"CREATE VIEW IF NOT EXISTS dummy (`_dummy_column_`)\"\n+                        + \"AS SELECT 'x' FROM `_dummy_table_` LIMIT 1\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3ODQ1Mw==", "bodyText": "The JDBC representation may or may not play tricks on us.\nWould be nice to also (first) validate the typeof(the_array) and CAST(the_array AS varchar).\nSee also #6297. I use this technique in some other upcoming (unrelated) PR as well.", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r540878453", "createdAt": "2020-12-11T11:23:25Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -430,6 +434,83 @@ private void runTimestampQueries(String tableName, List<TimestampAndPrecision> d\n         onPresto().executeQuery(\"DROP TABLE \" + tableName);\n     }\n \n+    @Test(dataProvider = \"storageFormatsWithNanosecondPrecision\", groups = STORAGE_FORMATS)\n+    public void testStructTimestamps(StorageFormat format)\n+            throws SQLException\n+    {\n+        setAdminRole(onPresto().getConnection());\n+        ensureDummyExists();\n+\n+        String tableName = format(\"test_struct_timestamp_precision_%s_%s\", format.getName().toLowerCase(Locale.ENGLISH), randomTableSuffix());\n+\n+        onPresto().executeQuery(format(\n+                \"CREATE TABLE %s (\\n\"\n+                        + \"id INTEGER\\n\"\n+                        + \",arr ARRAY(TIMESTAMP)\\n\"\n+                        + \",map MAP(TIMESTAMP, TIMESTAMP)\\n\"\n+                        + \",row ROW(col TIMESTAMP)\\n\"\n+                        + \",nested ARRAY(MAP(TIMESTAMP, ROW(col ARRAY(TIMESTAMP))))\\n\"\n+                        + \") WITH (%s)\",\n+                tableName,\n+                format.getStoragePropertiesAsSql()));\n+\n+        // Insert in a loop because inserting with UNION ALL sometimes makes values invisible to Presto\n+        for (TimestampAndPrecision entry : TIMESTAMPS_FROM_HIVE) {\n+            onHive().executeQuery(format(\n+                    \"INSERT INTO %1$s\\n\"\n+                            // insert with SELECT because hive bans array/map/struct functions in VALUES\n+                            + \"SELECT\\n\"\n+                            + \"%3$s\\n\"\n+                            + \",array(%2$s)\\n\"\n+                            + \",map(%2$s, %2$s)\\n\"\n+                            + \",named_struct('col', %2$s)\\n\"\n+                            + \",array(map(%2$s, named_struct('col', array(%2$s))))\\n\"\n+                            // some hive versions don't allow INSERT from SELECT without FROM\n+                            + \"FROM dummy\\n\",\n+                    tableName,\n+                    format(\"TIMESTAMP '%s'\", entry.getWriteValue()),\n+                    entry.getId()));\n+        }\n+\n+        for (HiveTimestampPrecision precision : HiveTimestampPrecision.values()) {\n+            setSessionProperty(onPresto().getConnection(), \"hive.timestamp_precision\", precision.name());\n+            assertThat(onPresto()\n+                    .executeQuery(format(\n+                            \"SELECT\\n\"\n+                                    + \"id\\n\"\n+                                    + \",arr[1]\\n\"\n+                                    + \",map_entries(map)[1][1]\\n\" // key\n+                                    + \",map_entries(map)[1][2]\\n\" // value\n+                                    + \",row.col\\n\"\n+                                    + \",map_entries(nested[1])[1][1]\\n\" // key\n+                                    + \",map_entries(nested[1])[1][2].col[1]\\n\" // value\n+                                    + \"FROM %s\\n\"\n+                                    + \"ORDER BY id\\n\",\n+                            tableName)))\n+                    .as(\"timestamp containers on %s\", format.getName().toLowerCase(Locale.ENGLISH))\n+                    .containsExactly(TIMESTAMPS_FROM_HIVE.stream()\n+                            .sorted(comparingInt(TimestampAndPrecision::getId))\n+                            .map(e -> new Row(Lists.asList(\n+                                    e.getId(),\n+                                    nCopies(6, Timestamp.valueOf(e.getReadValue(precision))).toArray())))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 194}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNjQ4MTY4", "url": "https://github.com/trinodb/trino/pull/5695#pullrequestreview-553648168", "createdAt": "2020-12-16T12:41:33Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNjQ5OTU5", "url": "https://github.com/trinodb/trino/pull/5695#pullrequestreview-553649959", "createdAt": "2020-12-16T12:44:12Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMjo0NDoxM1rOIHDh5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMjo1MDowMVrOIHDwSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI2ODc3NA==", "bodyText": "The cmt msg says:\n\n\nRename two methods in TestHiveStorageFormats\n\nsetupTimestampData to setupTimestampTable\n\n\n\n\nI guess it would need an update", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r544268774", "createdAt": "2020-12-16T12:44:13Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -338,107 +346,93 @@ public void testTimestampCreatedFromHive(StorageFormat storageFormat)\n             throws Exception\n     {\n         String tableName = \"test_timestamp_\" + storageFormat.getName().toLowerCase(Locale.ENGLISH);\n-        setupTimestampData(tableName, storageFormat);\n+        createSimpleTimestampTable(tableName, storageFormat);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI3MTgwMA==", "bodyText": "I like this change.\nMind that the changes being discussed here, mainly change from using eg milliFraction to milliReadValue went in  Allow custom timestamp precision in Hive structural types.  They should be part of Clean up TestHiveStorageFormats commit. (Actually, in Clean up TestHiveStorageFormats the invocations are correct, but the timestampAndPrecision impl is wrong)", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r544271800", "createdAt": "2020-12-16T12:49:02Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -675,18 +554,42 @@ public String toString()\n         }\n     }\n \n+    /**\n+     * Create {@code TimestampAndPrecision} with specified write precision and rounded fractional seconds.\n+     * @param precision Precision for writing value.\n+     * @param writeValue The literal value to write.\n+     * @param milliFraction Expected fraction when reading with millisecond precision.\n+     * @param microFraction Expected fraction when reading with microsecond precision.\n+     * @param nanoFraction Expected fraction when reading with nanosecond precision.\n+     */\n+    private static TimestampAndPrecision timestampAndPrecision(\n+            HiveTimestampPrecision precision,\n+            String writeValue,\n+            String milliFraction,\n+            String microFraction,\n+            String nanoFraction)\n+    {\n+        // Remove fractional second from write value\n+        String writeValueNoFraction = writeValue.split(\"\\\\.\")[0];\n+        Map<HiveTimestampPrecision, String> readValues = Map.of(\n+                MILLISECONDS, writeValueNoFraction + \".\" + milliFraction,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NzI2Nw=="}, "originalCommit": null, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI3MjQ1OQ==", "bodyText": "The getPrecision could return the precision and let the (only) caller apply name() on their own.", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r544272459", "createdAt": "2020-12-16T12:50:01Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -693,22 +705,22 @@ public int getId()\n \n         public String getPrecision()\n         {\n-            return precision;\n+            return precision.name();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 398}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MDEwMTA0", "url": "https://github.com/trinodb/trino/pull/5695#pullrequestreview-557010104", "createdAt": "2020-12-22T11:26:16Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMToyNjoxN1rOIJ34hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMTo0OToyMlrOIJ4fKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIyMzY4Nw==", "bodyText": "Let's add // TODO https://github.com/prestosql/presto/issues/6350\nAs a temporary workaround, let's use cast to JSON:\npresto:default> SELECT CAST(col AS json) FROM test;\n              _col0\n---------------------------------\n [\"2020-12-22 12:19:45.7786160\"]\n\nand then\npresto:default> SELECT regexp_replace(json_format(CAST(col AS json)), '^\\[\"|\"\\]$') FROM test;\n            _col0\n-----------------------------\n 2020-12-22 12:19:45.7786160", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r547223687", "createdAt": "2020-12-22T11:26:17Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -600,30 +600,30 @@ public void testStructTimestamps(StorageFormat format)\n                             format(\"row(col %s)\", type),\n                             format(\"array(map(%1$s, row(col array(%1$s))))\", type)));\n \n-            // Check the values as varchar\n-            String query = format(\n-                    \"SELECT\"\n-                            + \"   id,\"\n-                            + \"   CAST(arr[1] AS VARCHAR),\"\n-                            + \"   CAST(map_entries(map)[1][1] AS VARCHAR),\" // key\n-                            + \"   CAST(map_entries(map)[1][2] AS VARCHAR),\" // value\n-                            + \"   CAST(row.col AS VARCHAR),\"\n-                            + \"   CAST(map_entries(nested[1])[1][1] AS VARCHAR),\" // key\n-                            + \"   CAST(map_entries(nested[1])[1][2].col[1] AS VARCHAR)\" // value\n-                            + \" FROM %s\"\n-                            + \" ORDER BY id\",\n-                    tableName);\n-            System.out.println(query);\n-            onPresto().executeQuery(query);\n-            assertThat(onPresto()\n-                    .executeQuery(query))\n-                    .as(\"timestamp containers on %s\", format.getName().toLowerCase(Locale.ENGLISH))\n-                    .containsExactly(TIMESTAMPS_FROM_HIVE.stream()\n-                            .sorted(comparingInt(TimestampAndPrecision::getId))\n-                            .map(e -> new Row(Lists.asList(\n-                                    e.getId(),\n-                                    nCopies(6, e.getReadValue(precision)).toArray())))\n-                            .collect(toList()));\n+            // // Check the values as varchar\n+            // String query = format(\n+            //         \"SELECT\"\n+            //                 + \"   id,\"\n+            //                 + \"   CAST(arr[1] AS VARCHAR),\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIyNTY0NA==", "bodyText": "do not abbreviate prec", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r547225644", "createdAt": "2020-12-22T11:30:33Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -67,6 +67,138 @@\n     @Named(\"databases.presto.admin_role_enabled\")\n     private boolean adminRoleEnabled;\n \n+    private static final List<TimestampAndPrecision> TIMESTAMPS_FROM_HIVE;\n+\n+    static {\n+        // Tests set from 1960 to 1968 are duplicated below as tests in the 2020s\n+        List<TimestampAndPrecision> preEpoch = List.of(\n+                // write precision is not relevant here, as Hive always uses nanos\n+                timestampAndPrecision(\n+                        \"1967-01-02 12:01:00.111\", // millis, no rounding\n+                        NANOSECONDS,\n+                        \"1967-01-02 12:01:00.111\",\n+                        \"1967-01-02 12:01:00.111000\",\n+                        \"1967-01-02 12:01:00.111000000\"),\n+                timestampAndPrecision(\n+                        \"1967-01-02 12:01:00.1114\", // hundreds of micros, rounds down in millis\n+                        NANOSECONDS,\n+                        \"1967-01-02 12:01:00.111\",\n+                        \"1967-01-02 12:01:00.111400\",\n+                        \"1967-01-02 12:01:00.111400000\"),\n+                timestampAndPrecision(\n+                        \"1967-01-02 12:01:00.1115\", // hundreds of micros, rounds up in millis (smallest)\n+                        NANOSECONDS,\n+                        \"1967-01-02 12:01:00.112\",\n+                        \"1967-01-02 12:01:00.111500\",\n+                        \"1967-01-02 12:01:00.111500000\"),\n+                timestampAndPrecision(\n+                        \"1967-01-02 12:01:00.111499\", // micros, rounds down (largest)\n+                        NANOSECONDS,\n+                        \"1967-01-02 12:01:00.111\",\n+                        \"1967-01-02 12:01:00.111499\",\n+                        \"1967-01-02 12:01:00.111499000\"),\n+                timestampAndPrecision(\n+                        \"1967-01-02 12:01:00.1113334\", // hundreds of nanos, rounds down\n+                        NANOSECONDS,\n+                        \"1967-01-02 12:01:00.111\",\n+                        \"1967-01-02 12:01:00.111333\",\n+                        \"1967-01-02 12:01:00.111333400\"),\n+                timestampAndPrecision(\n+                        \"1967-01-02 12:01:00.1110019\", // hundreds of nanos, rounds down in millis and up in micros\n+                        NANOSECONDS,\n+                        \"1967-01-02 12:01:00.111\",\n+                        \"1967-01-02 12:01:00.111002\",\n+                        \"1967-01-02 12:01:00.111001900\"),\n+                timestampAndPrecision(\n+                        \"1967-01-02 12:01:00.111901001\", // nanos, rounds up in millis and down in micros\n+                        NANOSECONDS,\n+                        \"1967-01-02 12:01:00.112\",\n+                        \"1967-01-02 12:01:00.111901\",\n+                        \"1967-01-02 12:01:00.111901001\"),\n+                timestampAndPrecision(\n+                        \"1967-01-02 23:59:59.999999999\", // nanos, rounds up to next day\n+                        NANOSECONDS,\n+                        \"1967-01-03 00:00:00.000\",\n+                        \"1967-01-03 00:00:00.000000\",\n+                        \"1967-01-02 23:59:59.999999999\"),\n+                timestampAndPrecision(\n+                        \"1967-12-31 23:59:59.999999499\", // nanos, rounds micros down (largest), rounds millis up to next year\n+                        NANOSECONDS,\n+                        \"1968-01-01 00:00:00.000\",\n+                        \"1967-12-31 23:59:59.999999\",\n+                        \"1967-12-31 23:59:59.999999499\"));\n+\n+        // Make post-epoch tests\n+        Stream<TimestampAndPrecision> postEpoch = preEpoch.stream()\n+                // Exclude years outside of 1960-1968\n+                .filter(timePrec -> !timePrec.getWriteValue().matches(\"^196[^9]\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIyNjExNg==", "bodyText": "This makes it not so explicit about what's actually tested.\nLet's enumerate the test cases explicitly, without generating them on the fly.", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r547226116", "createdAt": "2020-12-22T11:31:45Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -67,6 +67,138 @@\n     @Named(\"databases.presto.admin_role_enabled\")\n     private boolean adminRoleEnabled;\n \n+    private static final List<TimestampAndPrecision> TIMESTAMPS_FROM_HIVE;\n+\n+    static {\n+        // Tests set from 1960 to 1968 are duplicated below as tests in the 2020s\n+        List<TimestampAndPrecision> preEpoch = List.of(\n+                // write precision is not relevant here, as Hive always uses nanos\n+                timestampAndPrecision(\n+                        \"1967-01-02 12:01:00.111\", // millis, no rounding\n+                        NANOSECONDS,\n+                        \"1967-01-02 12:01:00.111\",\n+                        \"1967-01-02 12:01:00.111000\",\n+                        \"1967-01-02 12:01:00.111000000\"),\n+                timestampAndPrecision(\n+                        \"1967-01-02 12:01:00.1114\", // hundreds of micros, rounds down in millis\n+                        NANOSECONDS,\n+                        \"1967-01-02 12:01:00.111\",\n+                        \"1967-01-02 12:01:00.111400\",\n+                        \"1967-01-02 12:01:00.111400000\"),\n+                timestampAndPrecision(\n+                        \"1967-01-02 12:01:00.1115\", // hundreds of micros, rounds up in millis (smallest)\n+                        NANOSECONDS,\n+                        \"1967-01-02 12:01:00.112\",\n+                        \"1967-01-02 12:01:00.111500\",\n+                        \"1967-01-02 12:01:00.111500000\"),\n+                timestampAndPrecision(\n+                        \"1967-01-02 12:01:00.111499\", // micros, rounds down (largest)\n+                        NANOSECONDS,\n+                        \"1967-01-02 12:01:00.111\",\n+                        \"1967-01-02 12:01:00.111499\",\n+                        \"1967-01-02 12:01:00.111499000\"),\n+                timestampAndPrecision(\n+                        \"1967-01-02 12:01:00.1113334\", // hundreds of nanos, rounds down\n+                        NANOSECONDS,\n+                        \"1967-01-02 12:01:00.111\",\n+                        \"1967-01-02 12:01:00.111333\",\n+                        \"1967-01-02 12:01:00.111333400\"),\n+                timestampAndPrecision(\n+                        \"1967-01-02 12:01:00.1110019\", // hundreds of nanos, rounds down in millis and up in micros\n+                        NANOSECONDS,\n+                        \"1967-01-02 12:01:00.111\",\n+                        \"1967-01-02 12:01:00.111002\",\n+                        \"1967-01-02 12:01:00.111001900\"),\n+                timestampAndPrecision(\n+                        \"1967-01-02 12:01:00.111901001\", // nanos, rounds up in millis and down in micros\n+                        NANOSECONDS,\n+                        \"1967-01-02 12:01:00.112\",\n+                        \"1967-01-02 12:01:00.111901\",\n+                        \"1967-01-02 12:01:00.111901001\"),\n+                timestampAndPrecision(\n+                        \"1967-01-02 23:59:59.999999999\", // nanos, rounds up to next day\n+                        NANOSECONDS,\n+                        \"1967-01-03 00:00:00.000\",\n+                        \"1967-01-03 00:00:00.000000\",\n+                        \"1967-01-02 23:59:59.999999999\"),\n+                timestampAndPrecision(\n+                        \"1967-12-31 23:59:59.999999499\", // nanos, rounds micros down (largest), rounds millis up to next year\n+                        NANOSECONDS,\n+                        \"1968-01-01 00:00:00.000\",\n+                        \"1967-12-31 23:59:59.999999\",\n+                        \"1967-12-31 23:59:59.999999499\"));\n+\n+        // Make post-epoch tests\n+        Stream<TimestampAndPrecision> postEpoch = preEpoch.stream()\n+                // Exclude years outside of 1960-1968\n+                .filter(timePrec -> !timePrec.getWriteValue().matches(\"^196[^9]\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIyNjg5Mw==", "bodyText": "let's address this as a followup", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r547226893", "createdAt": "2020-12-22T11:33:30Z", "author": {"login": "findepi"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveType.java", "diffHunk": "@@ -93,11 +93,19 @@ public TypeInfo getTypeInfo()\n         return typeInfo;\n     }\n \n+    /** @deprecated Prefer {@link #getTypeSignature(HiveTimestampPrecision)}. */\n+    @Deprecated\n     public TypeSignature getTypeSignature()\n     {\n-        return toTypeSignature(typeInfo);\n+        return getTypeSignature(DEFAULT_PRECISION);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2MjE3NQ=="}, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIyNzI2MA==", "bodyText": "public static Type fromPrimitiveType(PrimitiveTypeInfo typeInfo) should be deprecated now, right?", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r547227260", "createdAt": "2020-12-22T11:34:20Z", "author": {"login": "findepi"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/util/HiveTypeTranslator.java", "diffHunk": "@@ -227,6 +229,12 @@ public static TypeSignature toTypeSignature(TypeInfo typeInfo)\n \n     @Nullable\n     public static Type fromPrimitiveType(PrimitiveTypeInfo typeInfo)\n+    {\n+        return fromPrimitiveType(typeInfo, DEFAULT_PRECISION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIyODgzNQ==", "bodyText": "This is probably a change in behavior, but probably a correct one.\nThe old code\n((TimestampWritable) object).getTimestamp().getTime() * MICROSECONDS_PER_MILLISECOND\n\ninspector.getPrimitiveJavaObject(object).toEpochMilli() * MICROSECONDS_PER_MILLISECOND;\n\nwas probably truncating.\nAm i correct?\nDoes it apply to timestamp outside of structural types as well?\nDo we have a test for this?", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r547228835", "createdAt": "2020-12-22T11:37:47Z", "author": {"login": "findepi"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/util/SerDeUtils.java", "diffHunk": "@@ -312,11 +320,28 @@ private static long formatDateAsLong(Object object, DateObjectInspector inspecto\n         return inspector.getPrimitiveJavaObject(object).toEpochDay();\n     }\n \n-    private static long formatTimestampAsLong(Object object, TimestampObjectInspector inspector)\n+    private static DecodedTimestamp formatTimestamp(TimestampType type, Object object, TimestampObjectInspector inspector)\n     {\n+        long epochSecond;\n+        int nanoOfSecond;\n+\n         if (object instanceof TimestampWritable) {\n-            return ((TimestampWritable) object).getTimestamp().getTime() * MICROSECONDS_PER_MILLISECOND;\n+            TimestampWritable timestamp = (TimestampWritable) object;\n+            epochSecond = timestamp.getSeconds();\n+            nanoOfSecond = timestamp.getNanos();\n         }\n-        return inspector.getPrimitiveJavaObject(object).toEpochMilli() * MICROSECONDS_PER_MILLISECOND;\n+        else {\n+            Timestamp timestamp = inspector.getPrimitiveJavaObject(object);\n+            epochSecond = timestamp.toEpochSecond();\n+            nanoOfSecond = timestamp.getNanos();\n+        }\n+\n+        nanoOfSecond = (int) round(nanoOfSecond, 9 - type.getPrecision());\n+        if (nanoOfSecond == NANOSECONDS_PER_SECOND) { // round nanos up to seconds\n+            epochSecond += 1;\n+            nanoOfSecond = 0;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIyOTMwNg==", "bodyText": "move the TIMESTAMP case back here, after DATE case.", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r547229306", "createdAt": "2020-12-22T11:38:51Z", "author": {"login": "findepi"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/util/SerDeUtils.java", "diffHunk": "@@ -137,12 +143,14 @@ private static void serializePrimitive(Type type, BlockBuilder builder, Object o\n             case DATE:\n                 type.writeLong(builder, formatDateAsLong(object, (DateObjectInspector) inspector));\n                 return;\n-            case TIMESTAMP:", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIzMTQzNA==", "bodyText": "Pre-existing, but would be good to have storageFormatsWithNanosecondPrecision be defined in terms of storageFormats + exclusions, eg\n@DataProvider\npublic static Object[][] storageFormatsWithNanosecondPrecision()\n{\n    return Stream.of(storageFormats())\n            .map(array -> (StorageFormat) getOnlyElement(Arrays.asList(array)))\n            .filter(storageFormat -> !storageFormat.getName().equals(\"AVRO\"))\n            .map(storageFormat -> new Object[] {storageFormat})\n            .toArray(Object[][]::new);\n}", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r547231434", "createdAt": "2020-12-22T11:44:02Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -537,6 +540,117 @@ private void runTimestampQueries(String tableName, List<TimestampAndPrecision> d\n         onPresto().executeQuery(\"DROP TABLE \" + tableName);\n     }\n \n+    @Test(dataProvider = \"storageFormatsWithNanosecondPrecision\", groups = STORAGE_FORMATS)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIzMTkzMQ==", "bodyText": "This sounds like a bug (in Presto) then.\nCan you please file an issue (and link it here)?", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r547231931", "createdAt": "2020-12-22T11:45:14Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -453,22 +453,23 @@ public void testStructTimestamps(StorageFormat format)\n                 tableName,\n                 format.getStoragePropertiesAsSql()));\n \n-        onHive().executeQuery(format(\n-                \"INSERT INTO %s %s\",\n-                tableName,\n-                TIMESTAMPS_FROM_HIVE.stream()\n-                        .map(entry -> format(\n-                                \"SELECT\\n\"\n-                                        + \"%s\\n\"\n-                                        + \",arr(%2$s)\\n\"\n-                                        + \",map(%2$s, %2$s)\\n\"\n-                                        + \",named_struct('col', %2$s)\\n\"\n-                                        + \",array(map(%2$s, named_struct('col', array(%2$s))))\\n\"\n-                                        // some hive versions don't allow insert from bare select\n-                                        + \"FROM (SELECT 1) t\\n\",\n-                                entry.getId(),\n-                                format(\"TIMESTAMP '%s'\", entry.getWriteValue())))\n-                        .collect(Collectors.joining(\" UNION ALL \"))));\n+        // Insert in a loop because inserting with UNION ALL sometimes makes values invisible to Presto", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQwNzkwOQ=="}, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIzMzU3Nw==", "bodyText": "How much time does the test take?\nHow many times do we run the test on CI?\nstorage formats are run in multiple configurations -- for good reason. Since HDFS access patterns vary between formats, we run these tests for all supported HDFS authentication/impersonation configurations. This one, however, doesn't need to be run for all of them. Thus --and especially if it takes significant amount of time -- we should change its group definiion. Perhaps, it would be enough to a) remove storage_format group and b) add a comment why the test is not in that group.\n(this applies to existing test for nonstructural timestamp as well)", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r547233577", "createdAt": "2020-12-22T11:49:22Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -537,6 +540,117 @@ private void runTimestampQueries(String tableName, List<TimestampAndPrecision> d\n         onPresto().executeQuery(\"DROP TABLE \" + tableName);\n     }\n \n+    @Test(dataProvider = \"storageFormatsWithNanosecondPrecision\", groups = STORAGE_FORMATS)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "6003c6eeefbc32cfb7e615c9f36c99aa2653efd1", "author": {"user": {"login": "jirassimok", "name": "Jacob Ilias Komissar"}}, "url": "https://github.com/trinodb/trino/commit/6003c6eeefbc32cfb7e615c9f36c99aa2653efd1", "committedDate": "2021-01-05T17:10:12Z", "message": "Improve timestamp test cases used in Hive storage format tests\n\n- Update timestamp values\n  - Use values with visually-clearer rounding behavior (like \"1113339\"\n    instead of \"1234567\").\n    - This also includes rounding up from 5 and down from 499.\n  - Add timestamp that round up to the next day/year\n  - Add comments indicating each test's purpose\n\n- Move test data out of timestamp tests\n\n  The TimestampAndPrecision data container uses a static,\n  auto-incrementing ID. Making the data static ensures that the IDs\n  will be the same for each storage format."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "732d42237b47e3e9f94082ba65afd8b997046449", "author": {"user": {"login": "jirassimok", "name": "Jacob Ilias Komissar"}}, "url": "https://github.com/trinodb/trino/commit/732d42237b47e3e9f94082ba65afd8b997046449", "committedDate": "2021-01-05T17:21:46Z", "message": "Allow custom timestamp precision in Hive structural types\n\nAlso, mark methods not taking timestamp precision as deprecated:\n- HiveTypeTranslator.fromPrimitiveType(PrimitiveTypeInfo)\n- HiveType.getTypeSignature()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "426273bdc8585d9b5cd743c9bfe1f6dc9c97330a", "author": {"user": {"login": "jirassimok", "name": "Jacob Ilias Komissar"}}, "url": "https://github.com/trinodb/trino/commit/426273bdc8585d9b5cd743c9bfe1f6dc9c97330a", "committedDate": "2021-01-05T17:21:53Z", "message": "Fix type of TimestampAndPrecision.getPrecision"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4aff1cc9a4aabaeb485be89d9c30dd1a5e0e16d8", "author": {"user": {"login": "jirassimok", "name": "Jacob Ilias Komissar"}}, "url": "https://github.com/trinodb/trino/commit/4aff1cc9a4aabaeb485be89d9c30dd1a5e0e16d8", "committedDate": "2021-01-05T17:21:53Z", "message": "Improve data providers in TestHiveStorageFormats\n\n- Generate list of storage formats with nanosecond precision by\n  filtering the list of all tested storage formats.\n- Use explicit data provider return types (to facilitate the above)\n- Use data provider method names instead of assigning custom names"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "4aff1cc9a4aabaeb485be89d9c30dd1a5e0e16d8", "author": {"user": {"login": "jirassimok", "name": "Jacob Ilias Komissar"}}, "url": "https://github.com/trinodb/trino/commit/4aff1cc9a4aabaeb485be89d9c30dd1a5e0e16d8", "committedDate": "2021-01-05T17:21:53Z", "message": "Improve data providers in TestHiveStorageFormats\n\n- Generate list of storage formats with nanosecond precision by\n  filtering the list of all tested storage formats.\n- Use explicit data provider return types (to facilitate the above)\n- Use data provider method names instead of assigning custom names"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMjYzMzk1", "url": "https://github.com/trinodb/trino/pull/5695#pullrequestreview-562263395", "createdAt": "2021-01-06T01:18:08Z", "commit": {"oid": "732d42237b47e3e9f94082ba65afd8b997046449"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwMToxODowOVrOIOuUwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwMToxODowOVrOIOuUwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMwOTk1Mw==", "bodyText": "Can you do this with VALUES?", "url": "https://github.com/trinodb/trino/pull/5695#discussion_r552309953", "createdAt": "2021-01-06T01:18:09Z", "author": {"login": "electrum"}, "path": "testing/trino-product-tests/src/main/java/io/trino/tests/hive/TestHiveStorageFormats.java", "diffHunk": "@@ -543,6 +546,114 @@ private void runTimestampQueries(String tableName, List<TimestampAndPrecision> d\n         onPresto().executeQuery(\"DROP TABLE \" + tableName);\n     }\n \n+    @Test(dataProvider = \"storageFormatsWithNanosecondPrecision\", groups = STORAGE_FORMATS)\n+    public void testStructTimestamps(StorageFormat format)\n+            throws SQLException\n+    {\n+        setAdminRole(onPresto().getConnection());\n+        ensureDummyExists();\n+\n+        String tableName = format(\"test_struct_timestamp_precision_%s_%s\", format.getName().toLowerCase(Locale.ENGLISH), randomTableSuffix());\n+\n+        onPresto().executeQuery(format(\n+                \"CREATE TABLE %s (\"\n+                        + \"   id INTEGER,\"\n+                        + \"   arr ARRAY(TIMESTAMP),\"\n+                        + \"   map MAP(TIMESTAMP, TIMESTAMP),\"\n+                        + \"   row ROW(col TIMESTAMP),\"\n+                        + \"   nested ARRAY(MAP(TIMESTAMP, ROW(col ARRAY(TIMESTAMP))))\"\n+                        + \") WITH (%s)\",\n+                tableName,\n+                format.getStoragePropertiesAsSql()));\n+\n+        // Insert in a loop because inserting with UNION ALL sometimes makes values invisible to Presto", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "732d42237b47e3e9f94082ba65afd8b997046449"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3146, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}