{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5ODM1NDQy", "number": 3780, "title": "Clean up datetime operators", "bodyText": "", "createdAt": "2020-05-19T02:17:05Z", "url": "https://github.com/trinodb/trino/pull/3780", "merged": true, "mergeCommit": {"oid": "db2ae9bccc8229b0fa8e110d9f12f41654fcae64"}, "closed": true, "closedAt": "2020-05-24T15:36:44Z", "author": {"login": "martint"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABci6n8lABqjMzNTM2MjI2MTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABckRLc5gBqjMzNjc1NTg2MDk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MDc5NDg3", "url": "https://github.com/trinodb/trino/pull/3780#pullrequestreview-416079487", "createdAt": "2020-05-21T11:42:27Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMTo0MjoyN1rOGYvyOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMjozOToyMFrOGYxRBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwMTkxNQ==", "bodyText": "We generally avoid UDF impl calling other UDF, to safeguard against incorrect error messages.\nAlso, datePlusIntervalDayToSecond and intervalDayToSecondPlusDate could produce different messages (when millis of day != 0), reversing param order.\nYou could address that by keeping arg validation inline and having a shared method for the actual math (or keeping everything inline (basically dropping this commit)).\nI am leaning toward \"validate inline and shared method for the math\".\ncc @electrum as this is a general comment about functions impls", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428601915", "createdAt": "2020-05-21T11:42:27Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/type/DateTimeOperators.java", "diffHunk": "@@ -54,10 +54,7 @@ public static long datePlusIntervalDayToSecond(@SqlType(StandardTypes.DATE) long\n     @SqlType(StandardTypes.DATE)\n     public static long intervalDayToSecondPlusDate(@SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval, @SqlType(StandardTypes.DATE) long date)\n     {\n-        if (MILLIS_OF_DAY.get(interval) != 0) {\n-            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Cannot add hour, minutes or seconds to a date\");\n-        }\n-        return TimeUnit.MILLISECONDS.toDays(interval) + date;\n+        return datePlusIntervalDayToSecond(date, interval);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwMjg0OQ==", "bodyText": "static createConstantAnalyzer", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428602849", "createdAt": "2020-05-21T11:44:48Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/cost/ScalarStatsCalculator.java", "diffHunk": "@@ -112,8 +112,10 @@ protected SymbolStatsEstimate visitNullLiteral(NullLiteral node, Void context)\n         @Override\n         protected SymbolStatsEstimate visitLiteral(Literal node, Void context)\n         {\n-            Object value = evaluate(metadata, session.toConnectorSession(), node);\n-            Type type = ExpressionAnalyzer.createConstantAnalyzer(metadata, new AllowAllAccessControl(), session, ImmutableMap.of(), WarningCollector.NOOP).analyze(node, Scope.create());\n+            ExpressionAnalyzer analyzer = ExpressionAnalyzer.createConstantAnalyzer(metadata, new AllowAllAccessControl(), session, ImmutableMap.of(), WarningCollector.NOOP);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwNDk5OQ==", "bodyText": "Removing isLegacyTimestamp check from here is not correct.\nThis code needs to verify the literal is correct (well formed valid value), and this depends on the isLegacyTimestamp + session zone.\nFor example 1970-01:01 00:30:00 is not a valid timestamp literal if legacy timestamp and session zone is Bahia_Banderas", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428604999", "createdAt": "2020-05-21T11:49:50Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -824,25 +824,21 @@ protected Type visitTimeLiteral(TimeLiteral node, StackableAstVisitorContext<Con\n         @Override\n         protected Type visitTimestampLiteral(TimestampLiteral node, StackableAstVisitorContext<Context> context)\n         {\n+            Type type;\n             try {\n-                if (SystemSessionProperties.isLegacyTimestamp(session)) {\n-                    parseTimestampLiteral(session.getTimeZoneKey(), node.getValue());\n+                if (timestampHasTimeZone(node.getValue())) {\n+                    type = TIMESTAMP_WITH_TIME_ZONE;\n+                    parseTimestampWithTimeZone(node.getValue());\n                 }\n                 else {\n-                    parseTimestampLiteral(node.getValue());\n+                    type = TIMESTAMP;\n+                    parseTimestamp(node.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwNTIyMw==", "bodyText": "parse or convert?\n(i am not sure about this code, but you are using convert* on two cases below)", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428605223", "createdAt": "2020-05-21T11:50:32Z", "author": {"login": "findepi"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/util/KafkaLoader.java", "diffHunk": "@@ -143,13 +143,13 @@ private Object convertValue(Object value, Type type)\n                 return value;\n             }\n             if (TIME.equals(type)) {\n-                return ISO8601_FORMATTER.print(parseTimeLiteral(timeZoneKey, (String) value));\n+                return ISO8601_FORMATTER.print(parseLegacyTime(timeZoneKey, (String) value));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwNTQ2Mw==", "bodyText": "rnn", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428605463", "createdAt": "2020-05-21T11:51:06Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LiteralInterpreter.java", "diffHunk": "@@ -47,32 +54,38 @@\n import static io.prestosql.sql.analyzer.TypeSignatureProvider.fromTypes;\n import static io.prestosql.type.JsonType.JSON;\n import static io.prestosql.util.DateTimeUtils.parseDayTimeInterval;\n-import static io.prestosql.util.DateTimeUtils.parseTimeLiteral;\n-import static io.prestosql.util.DateTimeUtils.parseTimestampLiteral;\n+import static io.prestosql.util.DateTimeUtils.parseLegacyTime;\n+import static io.prestosql.util.DateTimeUtils.parseLegacyTimestamp;\n+import static io.prestosql.util.DateTimeUtils.parseTimeWithTimeZone;\n+import static io.prestosql.util.DateTimeUtils.parseTimeWithoutTimeZone;\n+import static io.prestosql.util.DateTimeUtils.parseTimestamp;\n+import static io.prestosql.util.DateTimeUtils.parseTimestampWithTimeZone;\n import static io.prestosql.util.DateTimeUtils.parseYearMonthInterval;\n \n public final class LiteralInterpreter\n {\n     private LiteralInterpreter() {}\n \n-    public static Object evaluate(Metadata metadata, ConnectorSession session, Expression node)\n+    public static Object evaluate(Metadata metadata, ConnectorSession session, Map<NodeRef<Expression>, Type> types, Expression node)\n     {\n         if (!(node instanceof Literal)) {\n             throw new IllegalArgumentException(\"node must be a Literal\");\n         }\n-        return new LiteralVisitor(metadata).process(node, session);\n+        return new LiteralVisitor(metadata, types).process(node, session);\n     }\n \n     private static class LiteralVisitor\n             extends AstVisitor<Object, ConnectorSession>\n     {\n         private final Metadata metadata;\n         private final InterpretedFunctionInvoker functionInvoker;\n+        private final Map<NodeRef<Expression>, Type> types;\n \n-        private LiteralVisitor(Metadata metadata)\n+        private LiteralVisitor(Metadata metadata, Map<NodeRef<Expression>, Type> types)\n         {\n             this.metadata = metadata;\n             this.functionInvoker = new InterpretedFunctionInvoker(metadata);\n+            this.types = types;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwOTQxOQ==", "bodyText": "Specify in the javadoc what happens when\n\ntimestamp is a gap in the provided zone (rejected or shifted)\nvalue contains a zone specifier -- is it converted to provided zone with \"same zone\" or \"same instant\" semantics\n\nand what happens if it cannot be", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428609419", "createdAt": "2020-05-21T12:00:43Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/util/DateTimeUtils.java", "diffHunk": "@@ -143,58 +143,37 @@ public static String printDate(int days)\n     }\n \n     /**\n-     * Parse a string (optionally containing a zone) as a value of either TIMESTAMP or TIMESTAMP WITH TIME ZONE type.\n-     * <p>\n-     * For example: {@code \"2000-01-01 01:23:00\"} is parsed to TIMESTAMP {@code 2000-01-01T01:23:00}\n-     * and {@code \"2000-01-01 01:23:00 +01:23\"} is parsed to TIMESTAMP WITH TIME ZONE\n-     * {@code 2000-01-01T01:23:00.000+01:23}.\n-     *\n-     * @return stack representation of TIMESTAMP or TIMESTAMP WITH TIME ZONE type, depending on input\n+     * Parse a legacy TIMESTAMP type. The string is interpreted in {@code timeZoneKey} zone.\n      */\n-    public static long parseTimestampLiteral(String value)\n+    @Deprecated\n+    public static long parseLegacyTimestamp(TimeZoneKey timeZoneKey, String value)\n     {\n-        try {\n-            DateTime dateTime = TIMESTAMP_WITH_TIME_ZONE_FORMATTER.parseDateTime(value);\n-            return packDateTimeWithZone(dateTime);\n-        }\n-        catch (Exception e) {\n-            return TIMESTAMP_WITHOUT_TIME_ZONE_FORMATTER.parseMillis(value);\n-        }\n+        return LEGACY_TIMESTAMP_WITHOUT_TIME_ZONE_FORMATTER.withChronology(getChronology(timeZoneKey)).parseMillis(value);\n     }\n \n     /**\n-     * Parse a string (optionally containing a zone) as a value of either TIMESTAMP or TIMESTAMP WITH TIME ZONE type.\n-     * If the string doesn't specify a zone, it is interpreted in {@code timeZoneKey} zone.\n-     *\n-     * @return stack representation of legacy TIMESTAMP or TIMESTAMP WITH TIME ZONE type, depending on input\n-     * @deprecated applicable in legacy timestamp semantics only\n+     * Parse a string (optionally containing a zone) as a value of TIMESTAMP type using legacy semantics.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyMTEzMw==", "bodyText": "BTW this looks like you're fixing a bug. Previously the code was using parseTimeLiteral which @return stack representation of legacy TIME or TIME WITH TIME ZONE type, depending on input, yet it was handling the return value as being of TIME type.\nAs such, this deserves a separate commit and a test.", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428621133", "createdAt": "2020-05-21T12:28:22Z", "author": {"login": "findepi"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/util/KafkaLoader.java", "diffHunk": "@@ -143,13 +143,13 @@ private Object convertValue(Object value, Type type)\n                 return value;\n             }\n             if (TIME.equals(type)) {\n-                return ISO8601_FORMATTER.print(parseTimeLiteral(timeZoneKey, (String) value));\n+                return ISO8601_FORMATTER.print(parseLegacyTime(timeZoneKey, (String) value));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwNTIyMw=="}, "originalCommit": null, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyMTYxOQ==", "bodyText": "redundant else, below too", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428621619", "createdAt": "2020-05-21T12:29:24Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LiteralInterpreter.java", "diffHunk": "@@ -151,27 +164,38 @@ protected Object visitGenericLiteral(GenericLiteral node, ConnectorSession sessi\n         @Override\n         protected Long visitTimeLiteral(TimeLiteral node, ConnectorSession session)\n         {\n-            if (session.isLegacyTimestamp()) {\n-                return parseTimeLiteral(session.getTimeZoneKey(), node.getValue());\n+            Type type = types.get(NodeRef.of(node));\n+\n+            if (type instanceof TimeType) {\n+                if (session.isLegacyTimestamp()) {\n+                    return parseLegacyTime(session.getTimeZoneKey(), node.getValue());\n+                }\n+                return parseTimeWithoutTimeZone(node.getValue());\n+            }\n+            else if (type instanceof TimeWithTimeZoneType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyMTcxOQ==", "bodyText": "redundant else", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428621719", "createdAt": "2020-05-21T12:29:37Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LiteralInterpreter.java", "diffHunk": "@@ -151,27 +164,38 @@ protected Object visitGenericLiteral(GenericLiteral node, ConnectorSession sessi\n         @Override\n         protected Long visitTimeLiteral(TimeLiteral node, ConnectorSession session)\n         {\n-            if (session.isLegacyTimestamp()) {\n-                return parseTimeLiteral(session.getTimeZoneKey(), node.getValue());\n+            Type type = types.get(NodeRef.of(node));\n+\n+            if (type instanceof TimeType) {\n+                if (session.isLegacyTimestamp()) {\n+                    return parseLegacyTime(session.getTimeZoneKey(), node.getValue());\n+                }\n+                return parseTimeWithoutTimeZone(node.getValue());\n+            }\n+            else if (type instanceof TimeWithTimeZoneType) {\n+                return parseTimeWithTimeZone(node.getValue());\n             }\n             else {\n-                return parseTimeLiteral(node.getValue());\n+                throw new IllegalStateException(\"Unexpected type: \" + type);\n             }\n         }\n \n         @Override\n         protected Long visitTimestampLiteral(TimestampLiteral node, ConnectorSession session)\n         {\n-            try {\n+            Type type = types.get(NodeRef.of(node));\n+\n+            if (type instanceof TimestampType) {\n                 if (session.isLegacyTimestamp()) {\n-                    return parseTimestampLiteral(session.getTimeZoneKey(), node.getValue());\n-                }\n-                else {\n-                    return parseTimestampLiteral(node.getValue());\n+                    return parseLegacyTimestamp(session.getTimeZoneKey(), node.getValue());\n                 }\n+                return parseTimestamp(node.getValue());\n             }\n-            catch (RuntimeException e) {\n-                throw semanticException(INVALID_LITERAL, node, \"'%s' is not a valid timestamp literal\", node.getValue());\n+            else if (type instanceof TimestampWithTimeZoneType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyNDk2NA==", "bodyText": "This is a javadoc of something else, not this method.", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428624964", "createdAt": "2020-05-21T12:36:39Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/util/DateTimeUtils.java", "diffHunk": "@@ -217,19 +196,35 @@ public static long parseTimestampWithoutTimeZone(String value)\n         }\n     }\n \n+    public static long parseTimestampWithTimeZone(String value)\n+    {\n+        DateTime dateTime = TIMESTAMP_WITH_TIME_ZONE_FORMATTER.withOffsetParsed().parseDateTime(value);\n+        return packDateTimeWithZone(dateTime);\n+    }\n+\n     /**\n-     * Parse a string (optionally containing a zone) as a value of TIMESTAMP type.\n+     * Parse a string (optionally containing a zone) as a value of TIMESTAMP WITH TIME ZONE type.\n      * If the string doesn't specify a zone, it is interpreted in {@code timeZoneKey} zone.\n+     * <p>\n+     * For example: {@code \"2000-01-01 01:23:00\"} is parsed to TIMESTAMP WITH TIME ZONE\n+     * {@code 2000-01-01T01:23:00 <provided zone>} and {@code \"2000-01-01 01:23:00 +01:23\"}\n+     * is parsed to TIMESTAMP WITH TIME ZONE {@code 2000-01-01T01:23:00.000+01:23}.\n      *\n-     * @return stack representation of legacy TIMESTAMP type\n-     * @deprecated applicable in legacy timestamp semantics only\n+     * @return stack representation of TIMESTAMP WITH TIME ZONE type\n      */\n-    @Deprecated\n-    public static long parseTimestampWithoutTimeZone(TimeZoneKey timeZoneKey, String value)\n+    public static long convertToTimestampWithTimeZone(TimeZoneKey timeZoneKey, String timestampWithTimeZone)\n     {\n-        return TIMESTAMP_WITH_OR_WITHOUT_TIME_ZONE_FORMATTER.withChronology(getChronology(timeZoneKey)).parseMillis(value);\n+        DateTime dateTime = TIMESTAMP_WITH_OR_WITHOUT_TIME_ZONE_FORMATTER.withChronology(getChronology(timeZoneKey)).withOffsetParsed().parseDateTime(timestampWithTimeZone);\n+        return packDateTimeWithZone(dateTime);\n     }\n \n+    /**\n+     * Parse a string (optionally containing a zone) as a value of TIMESTAMP type.\n+     * If the string doesn't specify a zone, it is interpreted in {@code timeZoneKey} zone.\n+     *\n+     * @return stack representation of legacy TIMESTAMP type\n+     * @deprecated applicable in legacy timestamp semantics only\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyNTUxMw==", "bodyText": "The code here used to be known as parseTimestampWithTimeZone(TimeZoneKey timeZoneKey, String timestampWithTimeZone), but in the diff it appears as a new code.", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428625513", "createdAt": "2020-05-21T12:37:55Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/util/DateTimeUtils.java", "diffHunk": "@@ -217,19 +196,35 @@ public static long parseTimestampWithoutTimeZone(String value)\n         }\n     }\n \n+    public static long parseTimestampWithTimeZone(String value)\n+    {\n+        DateTime dateTime = TIMESTAMP_WITH_TIME_ZONE_FORMATTER.withOffsetParsed().parseDateTime(value);\n+        return packDateTimeWithZone(dateTime);\n+    }\n+\n     /**\n-     * Parse a string (optionally containing a zone) as a value of TIMESTAMP type.\n+     * Parse a string (optionally containing a zone) as a value of TIMESTAMP WITH TIME ZONE type.\n      * If the string doesn't specify a zone, it is interpreted in {@code timeZoneKey} zone.\n+     * <p>\n+     * For example: {@code \"2000-01-01 01:23:00\"} is parsed to TIMESTAMP WITH TIME ZONE\n+     * {@code 2000-01-01T01:23:00 <provided zone>} and {@code \"2000-01-01 01:23:00 +01:23\"}\n+     * is parsed to TIMESTAMP WITH TIME ZONE {@code 2000-01-01T01:23:00.000+01:23}.\n      *\n-     * @return stack representation of legacy TIMESTAMP type\n-     * @deprecated applicable in legacy timestamp semantics only\n+     * @return stack representation of TIMESTAMP WITH TIME ZONE type\n      */\n-    @Deprecated\n-    public static long parseTimestampWithoutTimeZone(TimeZoneKey timeZoneKey, String value)\n+    public static long convertToTimestampWithTimeZone(TimeZoneKey timeZoneKey, String timestampWithTimeZone)\n     {\n-        return TIMESTAMP_WITH_OR_WITHOUT_TIME_ZONE_FORMATTER.withChronology(getChronology(timeZoneKey)).parseMillis(value);\n+        DateTime dateTime = TIMESTAMP_WITH_OR_WITHOUT_TIME_ZONE_FORMATTER.withChronology(getChronology(timeZoneKey)).withOffsetParsed().parseDateTime(timestampWithTimeZone);\n+        return packDateTimeWithZone(dateTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyNjE4MA==", "bodyText": "Fix legacy/new timestamp cast to json\n\nThis should probably be \"Fix timestamp CAST to JSON in new semantics\" or something, as you are not fixing anything in the legacy semantics (right?)", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428626180", "createdAt": "2020-05-21T12:39:20Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/JsonOperators.java", "diffHunk": "@@ -340,7 +340,12 @@ public static Slice castFromTimestamp(ConnectorSession session, @SqlType(TIMESTA\n         try {\n             SliceOutput output = new DynamicSliceOutput(25);\n             try (JsonGenerator jsonGenerator = createJsonGenerator(JSON_FACTORY, output)) {\n-                jsonGenerator.writeString(printTimestampWithoutTimeZone(session.getTimeZoneKey(), value));\n+                if (session.isLegacyTimestamp()) {\n+                    jsonGenerator.writeString(printTimestampWithoutTimeZone(session.getTimeZoneKey(), value));\n+                }\n+                else {\n+                    jsonGenerator.writeString(printTimestampWithoutTimeZone(value));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 9}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NzQzMjUx", "url": "https://github.com/trinodb/trino/pull/3780#pullrequestreview-416743251", "createdAt": "2020-05-22T08:37:57Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwODozNzo1OFrOGZPSAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwODo0MDoxMVrOGZPV7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTExNzk1NA==", "bodyText": "Same in RedisLoader (there is same code there)", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r429117954", "createdAt": "2020-05-22T08:37:58Z", "author": {"login": "findepi"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/util/KafkaLoader.java", "diffHunk": "@@ -143,7 +143,7 @@ private Object convertValue(Object value, Type type)\n                 return value;\n             }\n             if (TIME.equals(type)) {\n-                return ISO8601_FORMATTER.print(parseTimeLiteral(timeZoneKey, (String) value));\n+                return ISO8601_FORMATTER.print(parseTimeWithoutTimeZone(timeZoneKey, (String) value));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTExODk1Nw==", "bodyText": "I assume the changes in this class in fixup: Clarify parsing of timestamps and time types are just reorder.", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r429118957", "createdAt": "2020-05-22T08:40:11Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/util/DateTimeUtils.java", "diffHunk": "@@ -196,35 +184,42 @@ public static long convertToTimestamp(String value)\n         }\n     }\n \n-    public static long parseTimestampWithTimeZone(String value)\n+    /**\n+     * Parse a legacy TIMESTAMP type. The string is interpreted in {@code timeZoneKey} zone.\n+     */\n+    @Deprecated\n+    public static long parseLegacyTimestamp(TimeZoneKey timeZoneKey, String value)\n     {\n-        DateTime dateTime = TIMESTAMP_WITH_TIME_ZONE_FORMATTER.withOffsetParsed().parseDateTime(value);\n-        return packDateTimeWithZone(dateTime);\n+        return LEGACY_TIMESTAMP_WITHOUT_TIME_ZONE_FORMATTER.withChronology(getChronology(timeZoneKey)).parseMillis(value);\n     }\n \n     /**\n-     * Parse a string (optionally containing a zone) as a value of TIMESTAMP WITH TIME ZONE type.\n+     * Parse a string (optionally containing a zone) as a value of TIMESTAMP type using legacy semantics.\n      * If the string doesn't specify a zone, it is interpreted in {@code timeZoneKey} zone.\n-     * <p>\n-     * For example: {@code \"2000-01-01 01:23:00\"} is parsed to TIMESTAMP WITH TIME ZONE\n-     * {@code 2000-01-01T01:23:00 <provided zone>} and {@code \"2000-01-01 01:23:00 +01:23\"}\n-     * is parsed to TIMESTAMP WITH TIME ZONE {@code 2000-01-01T01:23:00.000+01:23}.\n-     *\n-     * @return stack representation of TIMESTAMP WITH TIME ZONE type\n+     * If the timestamp is in a gap in the provided timezone, the method throws an exception.\n      */\n-    public static long convertToTimestampWithTimeZone(TimeZoneKey timeZoneKey, String timestampWithTimeZone)\n+    @Deprecated\n+    public static long convertToLegacyTimestamp(TimeZoneKey timeZoneKey, String value)\n     {\n-        DateTime dateTime = TIMESTAMP_WITH_OR_WITHOUT_TIME_ZONE_FORMATTER.withChronology(getChronology(timeZoneKey)).withOffsetParsed().parseDateTime(timestampWithTimeZone);\n-        return packDateTimeWithZone(dateTime);\n+        return TIMESTAMP_WITH_OR_WITHOUT_TIME_ZONE_FORMATTER.withChronology(getChronology(timeZoneKey)).parseMillis(value);\n     }\n \n     /**\n-     * Parse a string (optionally containing a zone) as a value of TIMESTAMP type.\n-     * If the string doesn't specify a zone, it is interpreted in {@code timeZoneKey} zone.\n+     * Parse a string as a value of TIMESTAMP type.\n      *\n-     * @return stack representation of legacy TIMESTAMP type\n-     * @deprecated applicable in legacy timestamp semantics only\n+     * @return stack representation of TIMESTAMP type\n      */\n+    public static long parseTimestamp(String value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 98}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTk2Njkx", "url": "https://github.com/trinodb/trino/pull/3780#pullrequestreview-416996691", "createdAt": "2020-05-22T15:24:15Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNToyNDoxNlrOGZbHCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNToyNDoxNlrOGZbHCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxMTc1NA==", "bodyText": "Use a zone different from test jvm zone (to cover the fact that jvm zone doesn't impact this).\neg Vilnius\nhttps://github.com/prestosql/presto/blob/ca878d471740c07155ea29fb74fe8be0ba855a68/presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java#L129-L130\n(i used Bahia in my previous comment, because i remember when some gap is in Bahia, sorry for misguiding you)", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r429311754", "createdAt": "2020-05-22T15:24:16Z", "author": {"login": "findepi"}, "path": "presto-main/src/test/java/io/prestosql/type/TestTimestampLegacy.java", "diffHunk": "@@ -62,4 +69,17 @@ public void testCastFromSlice()\n                 TIMESTAMP,\n                 sqlTimestampOf(2001, 1, 21, 9, 0, 0, 0, session));\n     }\n+\n+    @Test\n+    public void testInvalidLiteral()\n+    {\n+        Session session = testSessionBuilder()\n+                .setSystemProperty(\"legacy_timestamp\", \"true\")\n+                .setTimeZoneKey(TimeZoneKey.getTimeZoneKey(\"America/Bahia_Banderas\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MTc3NzIw", "url": "https://github.com/trinodb/trino/pull/3780#pullrequestreview-417177720", "createdAt": "2020-05-22T20:53:44Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMDo1Mzo0NFrOGZjYpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMDo1Mzo0NFrOGZjYpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ0NzMzMw==", "bodyText": "It does matter. For example timestamp could be detected as invalid if it's invalid in JVM zone, but then could be shifted if it is invalid in the session zone.\nActually, i hope we also do have a test that parses timestamp being  a gap in JVM zone (but not in the session zone) and verifies it was succesful. We definitely do this in connector tests, but not sure if here.", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r429447333", "createdAt": "2020-05-22T20:53:44Z", "author": {"login": "findepi"}, "path": "presto-main/src/test/java/io/prestosql/type/TestTimestampLegacy.java", "diffHunk": "@@ -62,4 +69,17 @@ public void testCastFromSlice()\n                 TIMESTAMP,\n                 sqlTimestampOf(2001, 1, 21, 9, 0, 0, 0, session));\n     }\n+\n+    @Test\n+    public void testInvalidLiteral()\n+    {\n+        Session session = testSessionBuilder()\n+                .setSystemProperty(\"legacy_timestamp\", \"true\")\n+                .setTimeZoneKey(TimeZoneKey.getTimeZoneKey(\"America/Bahia_Banderas\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxMTc1NA=="}, "originalCommit": null, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8cb5152f82d4cd888013bfd87a13cf55c2914a20", "author": {"user": {"login": "martint", "name": "Martin Traverso"}}, "url": "https://github.com/trinodb/trino/commit/8cb5152f82d4cd888013bfd87a13cf55c2914a20", "committedDate": "2020-05-24T00:59:40Z", "message": "Fix parsing of time in Kafka and Redis\n\nparseTimeLiteral handles both time w/o timezone and time w/ timezone and\nreturns a value of the corresponding type. This is not appropriate for\nthis callsite, since we know the value has to be of type time w/o timezone."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89aac4ea636cb49cabb0b893e8fff191042e7d76", "author": {"user": {"login": "martint", "name": "Martin Traverso"}}, "url": "https://github.com/trinodb/trino/commit/89aac4ea636cb49cabb0b893e8fff191042e7d76", "committedDate": "2020-05-24T01:27:57Z", "message": "Add test for invalid legacy timestamp literal"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f95dd21c55ca102d3f3379b0ee3f7eead6578b2", "author": {"user": {"login": "martint", "name": "Martin Traverso"}}, "url": "https://github.com/trinodb/trino/commit/0f95dd21c55ca102d3f3379b0ee3f7eead6578b2", "committedDate": "2020-05-24T01:27:57Z", "message": "Clarify variable names in DateTimeOperators"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77c8b116cd2219678d809ecd0f548e812130f92e", "author": {"user": {"login": "martint", "name": "Martin Traverso"}}, "url": "https://github.com/trinodb/trino/commit/77c8b116cd2219678d809ecd0f548e812130f92e", "committedDate": "2020-05-24T01:27:57Z", "message": "Simplify implementation of datetime operations\n\nImplement subtractions in terms of addition with a negative term,\nand commutative variants in terms of a canonical implementation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "753d7c77531eaebc83ab0ea92e2be2557f483dc9", "author": {"user": {"login": "martint", "name": "Martin Traverso"}}, "url": "https://github.com/trinodb/trino/commit/753d7c77531eaebc83ab0ea92e2be2557f483dc9", "committedDate": "2020-05-24T01:27:57Z", "message": "Clarify parsing of timestamps and time types\n\nSeparate between parse (strict) vs convert (which can include a timezone) for timestamp types.\nParsing is used when we know it's a timestamp. convertXXX is used for the purpose of casting\nfrom a datetime string to a timestamp."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be8b2593cab6430f8b64409fb837598f48b72c05", "author": {"user": {"login": "martint", "name": "Martin Traverso"}}, "url": "https://github.com/trinodb/trino/commit/be8b2593cab6430f8b64409fb837598f48b72c05", "committedDate": "2020-05-24T01:27:57Z", "message": "Fix timestamp CAST to JSON in new semantics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52679d0206e32d0e6a256652be4415c2e5c0d01b", "author": {"user": {"login": "martint", "name": "Martin Traverso"}}, "url": "https://github.com/trinodb/trino/commit/52679d0206e32d0e6a256652be4415c2e5c0d01b", "committedDate": "2020-05-24T01:27:57Z", "message": "Reorder methods in DateTimeUtils"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "52679d0206e32d0e6a256652be4415c2e5c0d01b", "author": {"user": {"login": "martint", "name": "Martin Traverso"}}, "url": "https://github.com/trinodb/trino/commit/52679d0206e32d0e6a256652be4415c2e5c0d01b", "committedDate": "2020-05-24T01:27:57Z", "message": "Reorder methods in DateTimeUtils"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1169, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}