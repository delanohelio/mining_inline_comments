{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3NTQyNTM0", "number": 6097, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzoyNjoyMlrOFCCjVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMDoxMToxOFrOFCDX-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NjgzMjg2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/execution/buffer/LazyOutputBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzoyNjoyMlrOIA_lgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMjo1Mjo0NlrOIBZPAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxMjcwNg==", "bodyText": "I think this needs more explanation.  This is a write once field, so an unsynchronized volatile read that returns a non-null value is safe, but it returns null, you have to do a synchronized read. At least, I think that is how all of the code is written", "url": "https://github.com/trinodb/trino/pull/6097#discussion_r537912706", "createdAt": "2020-12-07T23:26:22Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/execution/buffer/LazyOutputBuffer.java", "diffHunk": "@@ -54,8 +55,9 @@\n     private final Executor executor;\n     private final Runnable notifyStatusChanged;\n \n+    // Note: this field is safe to read without synchronizing but must only be written to from a synchronized block", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODMzMjkzMQ==", "bodyText": "Updated the comment.", "url": "https://github.com/trinodb/trino/pull/6097#discussion_r538332931", "createdAt": "2020-12-08T12:52:46Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/io/prestosql/execution/buffer/LazyOutputBuffer.java", "diffHunk": "@@ -54,8 +55,9 @@\n     private final Executor executor;\n     private final Runnable notifyStatusChanged;\n \n+    // Note: this field is safe to read without synchronizing but must only be written to from a synchronized block", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxMjcwNg=="}, "originalCommit": null, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Njk2NzYyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/execution/buffer/ClientBuffer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMDoxMToxOFrOIBAwAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMjo1NDo0MVrOIBZWBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzMTc3Nw==", "bodyText": "why manually count pages when you can just use pages.size()?", "url": "https://github.com/trinodb/trino/pull/6097#discussion_r537931777", "createdAt": "2020-12-08T00:11:18Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/execution/buffer/ClientBuffer.java", "diffHunk": "@@ -151,14 +155,18 @@ public void enqueuePages(Collection<SerializedPageReference> pages)\n \n     private synchronized void addPages(Collection<SerializedPageReference> pages)\n     {\n-        pages.forEach(SerializedPageReference::addReference);\n+        long rowCount = 0;\n+        long bytesAdded = 0;\n+        int pageCount = 0;\n+        for (SerializedPageReference page : pages) {\n+            page.addReference();\n+            pageCount++;\n+            rowCount += page.getPositionCount();\n+            bytesAdded += page.getRetainedSizeInBytes();\n+        }\n         this.pages.addAll(pages);\n-\n-        long rowCount = pages.stream().mapToLong(SerializedPageReference::getPositionCount).sum();\n         rowsAdded.addAndGet(rowCount);\n-        pagesAdded.addAndGet(pages.size());\n-\n-        long bytesAdded = pages.stream().mapToLong(SerializedPageReference::getRetainedSizeInBytes).sum();\n+        pagesAdded.addAndGet(pageCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODMzNDcyNw==", "bodyText": "Since we're accepting any Collection<SerializedPageReference> implemetation and iterating through it already it seemed safer in terms of the performance cliff to count during iteration than to assume a (cheap) O(1) Collection#size() implementation.", "url": "https://github.com/trinodb/trino/pull/6097#discussion_r538334727", "createdAt": "2020-12-08T12:54:41Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/io/prestosql/execution/buffer/ClientBuffer.java", "diffHunk": "@@ -151,14 +155,18 @@ public void enqueuePages(Collection<SerializedPageReference> pages)\n \n     private synchronized void addPages(Collection<SerializedPageReference> pages)\n     {\n-        pages.forEach(SerializedPageReference::addReference);\n+        long rowCount = 0;\n+        long bytesAdded = 0;\n+        int pageCount = 0;\n+        for (SerializedPageReference page : pages) {\n+            page.addReference();\n+            pageCount++;\n+            rowCount += page.getPositionCount();\n+            bytesAdded += page.getRetainedSizeInBytes();\n+        }\n         this.pages.addAll(pages);\n-\n-        long rowCount = pages.stream().mapToLong(SerializedPageReference::getPositionCount).sum();\n         rowsAdded.addAndGet(rowCount);\n-        pagesAdded.addAndGet(pages.size());\n-\n-        long bytesAdded = pages.stream().mapToLong(SerializedPageReference::getRetainedSizeInBytes).sum();\n+        pagesAdded.addAndGet(pageCount);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzMTc3Nw=="}, "originalCommit": null, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4677, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}