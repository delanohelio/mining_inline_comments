{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc5NTkyMjY5", "number": 5081, "title": "Push dynamic filters into DynamicFilterService", "bodyText": "Depends on: #4988", "createdAt": "2020-09-04T11:20:53Z", "url": "https://github.com/trinodb/trino/pull/5081", "merged": true, "mergeCommit": {"oid": "e5234faa27988b711d0be6ae814e38d8c4e26503"}, "closed": true, "closedAt": "2020-09-28T09:30:06Z", "author": {"login": "sopel39"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdFlHixgBqjM3Mjk3MzQ4NzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdNQKPXgBqjM4MTM1NDUyMTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NjQ1NDAx", "url": "https://github.com/trinodb/trino/pull/5081#pullrequestreview-485645401", "createdAt": "2020-09-10T07:17:36Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNzoxNzozNlrOHPmRXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNzoxNzozNlrOHPmRXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjExNzcyNg==", "bodyText": "there's a utility for this in guava : Runnables.doNothing", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r486117726", "createdAt": "2020-09-10T07:17:36Z", "author": {"login": "rohangarg"}, "path": "presto-main/src/test/java/io/prestosql/execution/TestMemoryRevokingScheduler.java", "diffHunk": "@@ -117,15 +117,15 @@ public void testScheduleMemoryRevoking()\n         SqlTask sqlTask1 = newSqlTask();\n         SqlTask sqlTask2 = newSqlTask();\n \n-        TaskContext taskContext1 = sqlTask1.getQueryContext().addTaskContext(new TaskStateMachine(new TaskId(\"q1\", 1, 1), executor), session, false, false, OptionalInt.empty());\n+        TaskContext taskContext1 = sqlTask1.getQueryContext().addTaskContext(new TaskStateMachine(new TaskId(\"q1\", 1, 1), executor), session, () -> {}, false, false, OptionalInt.empty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "319c4f169818cb1732eee90ec46030acbf49f20c", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/319c4f169818cb1732eee90ec46030acbf49f20c", "committedDate": "2020-09-17T10:58:12Z", "message": "Collect dynamic filters based on notification in DynamicFilterService"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "319c4f169818cb1732eee90ec46030acbf49f20c", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/319c4f169818cb1732eee90ec46030acbf49f20c", "committedDate": "2020-09-17T10:58:12Z", "message": "Collect dynamic filters based on notification in DynamicFilterService"}, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNjk4MDMy", "url": "https://github.com/trinodb/trino/pull/5081#pullrequestreview-491698032", "createdAt": "2020-09-18T18:36:40Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxODozNjo0MVrOHUX75w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxOTo0OTo1MVrOHUZ7sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEyNTczNQ==", "bodyText": "Depending on what is happening inside of addTaskDynamicFilters this could result in an overwrite with an older version since this is outside of the synchronized block. As safer API would pass the version through to the addTaskDynamicFilters method so the receiver can deal with out of order notifications.", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491125735", "createdAt": "2020-09-18T18:36:41Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/server/remotetask/DynamicFiltersFetcher.java", "diffHunk": "@@ -216,20 +207,19 @@ public void fatal(Throwable cause)\n         }\n     }\n \n-    private synchronized void updateDynamicFilterDomains(VersionedDynamicFilterDomains newDynamicFilterDomains)\n+    private void updateDynamicFilterDomains(VersionedDynamicFilterDomains newDynamicFilterDomains)\n     {\n-        if (localDynamicFiltersVersion >= newDynamicFilterDomains.getVersion()) {\n-            // newer dynamic filters were already received\n-            return;\n-        }\n+        synchronized (this) {\n+            if (localDynamicFiltersVersion >= newDynamicFilterDomains.getVersion()) {\n+                // newer dynamic filters were already received\n+                return;\n+            }\n \n-        dynamicFilterDomains = concat(\n-                dynamicFilterDomains.entrySet().stream(),\n-                newDynamicFilterDomains.getDynamicFilterDomains().entrySet().stream())\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue, Domain::intersect));\n+            localDynamicFiltersVersion = newDynamicFilterDomains.getVersion();\n+            updateDynamicFiltersVersion(localDynamicFiltersVersion);\n+        }\n \n-        localDynamicFiltersVersion = newDynamicFilterDomains.getVersion();\n-        updateDynamicFiltersVersion(localDynamicFiltersVersion);\n+        dynamicFilterService.addTaskDynamicFilters(taskId, newDynamicFilterDomains.getDynamicFilterDomains());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEyNjY3MA==", "bodyText": "no ned to wrap for this", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491126670", "createdAt": "2020-09-18T18:38:52Z", "author": {"login": "dain"}, "path": "presto-main/src/test/java/io/prestosql/server/TestDynamicFilterService.java", "diffHunk": "@@ -464,10 +410,52 @@ public void testReplicatedDynamicFilter()\n                                 Domain.singleValue(INTEGER, 1L).toString(session.toConnectorSession()),\n                                 1,\n                                 0)));\n+    }\n \n-        // all dynamic filters have been collected, no need for more requests\n+    @Test\n+    public void testStageCannotScheduleMoreTasks()\n+    {\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(new FeaturesConfig());\n+        DynamicFilterId filterId1 = new DynamicFilterId(\"df1\");\n+        Expression df1 = expression(\"DF_SYMBOL1\");\n+        QueryId queryId = new QueryId(\"query\");\n+        StageId stageId1 = new StageId(queryId, 1);\n+\n+        dynamicFilterService.registerQuery(\n+                queryId,\n+                ImmutableSet.of(filterId1),\n+                ImmutableSet.of(filterId1),\n+                ImmutableSet.of());\n+\n+        DynamicFilter dynamicFilter = dynamicFilterService.createDynamicFilter(\n+                queryId,\n+                ImmutableList.of(new DynamicFilters.Descriptor(filterId1, df1)),\n+                ImmutableMap.of(\n+                        Symbol.from(df1), new TestingColumnHandle(\"probeColumnA\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 339}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEyNjk2MQ==", "bodyText": "I'd put this comment before the call to add the filter", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491126961", "createdAt": "2020-09-18T18:39:31Z", "author": {"login": "dain"}, "path": "presto-main/src/test/java/io/prestosql/server/TestDynamicFilterService.java", "diffHunk": "@@ -464,10 +410,52 @@ public void testReplicatedDynamicFilter()\n                                 Domain.singleValue(INTEGER, 1L).toString(session.toConnectorSession()),\n                                 1,\n                                 0)));\n+    }\n \n-        // all dynamic filters have been collected, no need for more requests\n+    @Test\n+    public void testStageCannotScheduleMoreTasks()\n+    {\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(new FeaturesConfig());\n+        DynamicFilterId filterId1 = new DynamicFilterId(\"df1\");\n+        Expression df1 = expression(\"DF_SYMBOL1\");\n+        QueryId queryId = new QueryId(\"query\");\n+        StageId stageId1 = new StageId(queryId, 1);\n+\n+        dynamicFilterService.registerQuery(\n+                queryId,\n+                ImmutableSet.of(filterId1),\n+                ImmutableSet.of(filterId1),\n+                ImmutableSet.of());\n+\n+        DynamicFilter dynamicFilter = dynamicFilterService.createDynamicFilter(\n+                queryId,\n+                ImmutableList.of(new DynamicFilters.Descriptor(filterId1, df1)),\n+                ImmutableMap.of(\n+                        Symbol.from(df1), new TestingColumnHandle(\"probeColumnA\")));\n+        assertTrue(dynamicFilter.getCurrentPredicate().isAll());\n+        assertFalse(dynamicFilter.isComplete());\n+        CompletableFuture<?> blockedFuture = dynamicFilter.isBlocked();\n+        assertFalse(blockedFuture.isDone());\n+\n+        dynamicFilterService.addTaskDynamicFilters(\n+                new TaskId(stageId1, 0),\n+                ImmutableMap.of(filterId1, singleValue(INTEGER, 1L)));\n+        dynamicFilterService.collectDynamicFilters();\n+\n+        // adding task dynamic filters shouldn't complete dynamic filter", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 350}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEyNzQ3NQ==", "bodyText": "you might want to do a get to verify the completable future doesn't contain an exception", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491127475", "createdAt": "2020-09-18T18:40:35Z", "author": {"login": "dain"}, "path": "presto-main/src/test/java/io/prestosql/server/TestDynamicFilterService.java", "diffHunk": "@@ -464,10 +410,52 @@ public void testReplicatedDynamicFilter()\n                                 Domain.singleValue(INTEGER, 1L).toString(session.toConnectorSession()),\n                                 1,\n                                 0)));\n+    }\n \n-        // all dynamic filters have been collected, no need for more requests\n+    @Test\n+    public void testStageCannotScheduleMoreTasks()\n+    {\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(new FeaturesConfig());\n+        DynamicFilterId filterId1 = new DynamicFilterId(\"df1\");\n+        Expression df1 = expression(\"DF_SYMBOL1\");\n+        QueryId queryId = new QueryId(\"query\");\n+        StageId stageId1 = new StageId(queryId, 1);\n+\n+        dynamicFilterService.registerQuery(\n+                queryId,\n+                ImmutableSet.of(filterId1),\n+                ImmutableSet.of(filterId1),\n+                ImmutableSet.of());\n+\n+        DynamicFilter dynamicFilter = dynamicFilterService.createDynamicFilter(\n+                queryId,\n+                ImmutableList.of(new DynamicFilters.Descriptor(filterId1, df1)),\n+                ImmutableMap.of(\n+                        Symbol.from(df1), new TestingColumnHandle(\"probeColumnA\")));\n+        assertTrue(dynamicFilter.getCurrentPredicate().isAll());\n+        assertFalse(dynamicFilter.isComplete());\n+        CompletableFuture<?> blockedFuture = dynamicFilter.isBlocked();\n+        assertFalse(blockedFuture.isDone());\n+\n+        dynamicFilterService.addTaskDynamicFilters(\n+                new TaskId(stageId1, 0),\n+                ImmutableMap.of(filterId1, singleValue(INTEGER, 1L)));\n+        dynamicFilterService.collectDynamicFilters();\n+\n+        // adding task dynamic filters shouldn't complete dynamic filter\n+        assertTrue(dynamicFilter.getCurrentPredicate().isAll());\n+        assertFalse(dynamicFilter.isComplete());\n+        assertFalse(blockedFuture.isDone());\n+\n+        dynamicFilterService.stageCannotScheduleMoreTasks(stageId1, 1);\n         dynamicFilterService.collectDynamicFilters();\n-        assertEquals(dynamicFiltersStageSupplier.getRequestCount(), 1);\n+\n+        // dynamic filter should be completed when stage won't have more tasks\n+        assertEquals(dynamicFilter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(\n+                new TestingColumnHandle(\"probeColumnA\"),\n+                singleValue(INTEGER, 1L))));\n+        assertTrue(dynamicFilter.isComplete());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 363}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzMDAzMA==", "bodyText": "Is a single thread enough for this service?", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491130030", "createdAt": "2020-09-18T18:46:12Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -83,33 +78,29 @@\n import static io.prestosql.sql.planner.SystemPartitioningHandle.SOURCE_DISTRIBUTION;\n import static io.prestosql.util.MorePredicates.isInstanceOfAny;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;\n-import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.Executors.newSingleThreadExecutor;\n \n @ThreadSafe\n public class DynamicFilterService\n {\n-    private final Duration dynamicFilteringRefreshInterval;\n-    private final ScheduledExecutorService collectDynamicFiltersExecutor = newSingleThreadScheduledExecutor(daemonThreadsNamed(\"DynamicFilterService\"));\n-\n+    private final ExecutorService executor;\n     private final Map<QueryId, DynamicFilterContext> dynamicFilterContexts = new ConcurrentHashMap<>();\n \n-    @Inject\n-    public DynamicFilterService(FeaturesConfig featuresConfig)\n+    public DynamicFilterService()\n     {\n-        this.dynamicFilteringRefreshInterval = requireNonNull(featuresConfig, \"featuresConfig is null\").getDynamicFilteringRefreshInterval();\n+        this(newSingleThreadExecutor(daemonThreadsNamed(\"DynamicFilterService\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzMjQxMQ==", "bodyText": "This formatting is a little confusing.  I'd pu the orElse on the previous like so you see this as a single command to start the stream like this:\nreturn selectedFilters.orElseGet(() -> stageDynamicFilters.get(stageId)).stream()\n        .collect(toImmutableMap(...", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491132411", "createdAt": "2020-09-18T18:51:14Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -616,21 +605,17 @@ private int getTotalDynamicFilters()\n             return dynamicFilters.size();\n         }\n \n-        private Set<StageId> getStages()\n-        {\n-            return stageDynamicFilters.keySet();\n-        }\n-\n         private OptionalInt getNumberOfTasks(StageId stageId)\n         {\n             return Optional.ofNullable(stageNumberOfTasks.get(stageId))\n                     .map(OptionalInt::of)\n                     .orElse(OptionalInt.empty());\n         }\n \n-        private Map<DynamicFilterId, List<Domain>> getTaskDynamicFilters(StageId stageId)\n+        private Map<DynamicFilterId, List<Domain>> getTaskDynamicFilters(StageId stageId, Optional<Set<DynamicFilterId>> selectedFilters)\n         {\n-            return stageDynamicFilters.get(stageId).stream()\n+            return selectedFilters\n+                    .orElseGet(() -> stageDynamicFilters.get(stageId)).stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzNDU5NA==", "bodyText": "Add this to the defunct configs", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491134594", "createdAt": "2020-09-18T18:55:57Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/FeaturesConfig.java", "diffHunk": "@@ -782,21 +778,6 @@ public FeaturesConfig setDynamicFilteringMaxPerDriverSize(DataSize dynamicFilter\n         return this;\n     }\n \n-    @MinDuration(\"1ms\")\n-    @MaxDuration(\"10s\")\n-    @NotNull\n-    public Duration getDynamicFilteringRefreshInterval()\n-    {\n-        return dynamicFilteringRefreshInterval;\n-    }\n-\n-    @Config(\"experimental.dynamic-filtering-refresh-interval\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE1NzMwNQ==", "bodyText": "Functions::identity", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491157305", "createdAt": "2020-09-18T19:46:50Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -605,55 +590,88 @@ public int hashCode()\n     private static class DynamicFilterContext\n     {\n         private final Map<DynamicFilterId, Domain> dynamicFilterSummaries = new ConcurrentHashMap<>();\n-        private final Supplier<List<StageDynamicFilters>> dynamicFilterSupplier;\n         private final Set<DynamicFilterId> dynamicFilters;\n         private final Map<DynamicFilterId, SettableFuture<?>> lazyDynamicFilters;\n         private final Set<DynamicFilterId> replicatedDynamicFilters;\n         private final AtomicBoolean completed = new AtomicBoolean();\n+        private final Map<StageId, Set<DynamicFilterId>> stageDynamicFilters = new ConcurrentHashMap<>();\n+        private final Map<StageId, Integer> stageNumberOfTasks = new ConcurrentHashMap<>();\n+        // when map value for given filter id is empty it means that dynamic filter has already been collected\n+        // and no partial task domains are required\n+        private final Map<DynamicFilterId, Map<TaskId, Domain>> taskDynamicFilters = new ConcurrentHashMap<>();\n \n         private DynamicFilterContext(\n-                Supplier<List<StageDynamicFilters>> dynamicFilterSupplier,\n                 Set<DynamicFilterId> dynamicFilters,\n                 Map<DynamicFilterId, SettableFuture<?>> lazyDynamicFilters,\n                 Set<DynamicFilterId> replicatedDynamicFilters)\n         {\n-            this.dynamicFilterSupplier = requireNonNull(dynamicFilterSupplier, \"dynamicFilterSupplier is null\");\n             this.dynamicFilters = requireNonNull(dynamicFilters, \"dynamicFilters is null\");\n             this.lazyDynamicFilters = requireNonNull(lazyDynamicFilters, \"lazyDynamicFilters is null\");\n             this.replicatedDynamicFilters = requireNonNull(replicatedDynamicFilters, \"replicatedDynamicFilters is null\");\n+            dynamicFilters.forEach(filter -> taskDynamicFilters.put(filter, new ConcurrentHashMap<>()));\n         }\n \n         private int getTotalDynamicFilters()\n         {\n             return dynamicFilters.size();\n         }\n \n-        private Set<DynamicFilterId> getUncollectedDynamicFilters()\n+        private Set<StageId> getStages()\n+        {\n+            return stageDynamicFilters.keySet();\n+        }\n+\n+        private OptionalInt getNumberOfTasks(StageId stageId)\n         {\n-            return dynamicFilters.stream()\n-                    .filter(filter -> !dynamicFilterSummaries.containsKey(filter))\n-                    .collect(toImmutableSet());\n+            return Optional.ofNullable(stageNumberOfTasks.get(stageId))\n+                    .map(OptionalInt::of)\n+                    .orElse(OptionalInt.empty());\n+        }\n+\n+        private Map<DynamicFilterId, List<Domain>> getTaskDynamicFilters(StageId stageId)\n+        {\n+            return stageDynamicFilters.get(stageId).stream()\n+                    .collect(toImmutableMap(\n+                            filter -> filter,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE1ODQ1MQ==", "bodyText": "The currency of this class isn't really clear.  The fields use concurrent data structures, but the methods make coordinated changes between these data structures without synchronization.  Maybe the methods are safe but there aren't any comments on why it is a safe or warnings to be careful about changes.", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491158451", "createdAt": "2020-09-18T19:49:51Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -605,55 +590,88 @@ public int hashCode()\n     private static class DynamicFilterContext\n     {\n         private final Map<DynamicFilterId, Domain> dynamicFilterSummaries = new ConcurrentHashMap<>();\n-        private final Supplier<List<StageDynamicFilters>> dynamicFilterSupplier;\n         private final Set<DynamicFilterId> dynamicFilters;\n         private final Map<DynamicFilterId, SettableFuture<?>> lazyDynamicFilters;\n         private final Set<DynamicFilterId> replicatedDynamicFilters;\n         private final AtomicBoolean completed = new AtomicBoolean();\n+        private final Map<StageId, Set<DynamicFilterId>> stageDynamicFilters = new ConcurrentHashMap<>();\n+        private final Map<StageId, Integer> stageNumberOfTasks = new ConcurrentHashMap<>();\n+        // when map value for given filter id is empty it means that dynamic filter has already been collected\n+        // and no partial task domains are required\n+        private final Map<DynamicFilterId, Map<TaskId, Domain>> taskDynamicFilters = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 181}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNTE4NDU1", "url": "https://github.com/trinodb/trino/pull/5081#pullrequestreview-492518455", "createdAt": "2020-09-21T11:50:04Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMTo1MDowNVrOHVMHrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMjo1NDo1OFrOHVOlvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk4MDcxOQ==", "bodyText": "added comment", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491980719", "createdAt": "2020-09-21T11:50:05Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/server/remotetask/DynamicFiltersFetcher.java", "diffHunk": "@@ -216,20 +207,19 @@ public void fatal(Throwable cause)\n         }\n     }\n \n-    private synchronized void updateDynamicFilterDomains(VersionedDynamicFilterDomains newDynamicFilterDomains)\n+    private void updateDynamicFilterDomains(VersionedDynamicFilterDomains newDynamicFilterDomains)\n     {\n-        if (localDynamicFiltersVersion >= newDynamicFilterDomains.getVersion()) {\n-            // newer dynamic filters were already received\n-            return;\n-        }\n+        synchronized (this) {\n+            if (localDynamicFiltersVersion >= newDynamicFilterDomains.getVersion()) {\n+                // newer dynamic filters were already received\n+                return;\n+            }\n \n-        dynamicFilterDomains = concat(\n-                dynamicFilterDomains.entrySet().stream(),\n-                newDynamicFilterDomains.getDynamicFilterDomains().entrySet().stream())\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue, Domain::intersect));\n+            localDynamicFiltersVersion = newDynamicFilterDomains.getVersion();\n+            updateDynamicFiltersVersion(localDynamicFiltersVersion);\n+        }\n \n-        localDynamicFiltersVersion = newDynamicFilterDomains.getVersion();\n-        updateDynamicFiltersVersion(localDynamicFiltersVersion);\n+        dynamicFilterService.addTaskDynamicFilters(taskId, newDynamicFilterDomains.getDynamicFilterDomains());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEyNTczNQ=="}, "originalCommit": null, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAyMTE4MA==", "bodyText": "Added comments", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r492021180", "createdAt": "2020-09-21T12:54:58Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -605,55 +590,88 @@ public int hashCode()\n     private static class DynamicFilterContext\n     {\n         private final Map<DynamicFilterId, Domain> dynamicFilterSummaries = new ConcurrentHashMap<>();\n-        private final Supplier<List<StageDynamicFilters>> dynamicFilterSupplier;\n         private final Set<DynamicFilterId> dynamicFilters;\n         private final Map<DynamicFilterId, SettableFuture<?>> lazyDynamicFilters;\n         private final Set<DynamicFilterId> replicatedDynamicFilters;\n         private final AtomicBoolean completed = new AtomicBoolean();\n+        private final Map<StageId, Set<DynamicFilterId>> stageDynamicFilters = new ConcurrentHashMap<>();\n+        private final Map<StageId, Integer> stageNumberOfTasks = new ConcurrentHashMap<>();\n+        // when map value for given filter id is empty it means that dynamic filter has already been collected\n+        // and no partial task domains are required\n+        private final Map<DynamicFilterId, Map<TaskId, Domain>> taskDynamicFilters = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE1ODQ1MQ=="}, "originalCommit": null, "originalPosition": 181}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2OTA3Njgy", "url": "https://github.com/trinodb/trino/pull/5081#pullrequestreview-496907682", "createdAt": "2020-09-25T23:09:41Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMzowOTo0MVrOHYXIgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMzoyNjo1N1rOHYXo9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMwNjg4Mg==", "bodyText": "If it's not CPU intensive, does it need to be done asynchronously?", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r495306882", "createdAt": "2020-09-25T23:09:41Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -83,33 +78,29 @@\n import static io.prestosql.sql.planner.SystemPartitioningHandle.SOURCE_DISTRIBUTION;\n import static io.prestosql.util.MorePredicates.isInstanceOfAny;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;\n-import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.Executors.newSingleThreadExecutor;\n \n @ThreadSafe\n public class DynamicFilterService\n {\n-    private final Duration dynamicFilteringRefreshInterval;\n-    private final ScheduledExecutorService collectDynamicFiltersExecutor = newSingleThreadScheduledExecutor(daemonThreadsNamed(\"DynamicFilterService\"));\n-\n+    private final ExecutorService executor;\n     private final Map<QueryId, DynamicFilterContext> dynamicFilterContexts = new ConcurrentHashMap<>();\n \n-    @Inject\n-    public DynamicFilterService(FeaturesConfig featuresConfig)\n+    public DynamicFilterService()\n     {\n-        this.dynamicFilteringRefreshInterval = requireNonNull(featuresConfig, \"featuresConfig is null\").getDynamicFilteringRefreshInterval();\n+        this(newSingleThreadExecutor(daemonThreadsNamed(\"DynamicFilterService\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzMDAzMA=="}, "originalCommit": null, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMwODc3OQ==", "bodyText": "Why ImmutableList.copyOf?", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r495308779", "createdAt": "2020-09-25T23:13:01Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -311,33 +331,28 @@ void collectDynamicFilters()\n                 continue;\n             }\n \n-            Set<DynamicFilterId> uncollectedFilters = context.getUncollectedDynamicFilters();\n             ImmutableMap.Builder<DynamicFilterId, Domain> newDynamicFiltersBuilder = ImmutableMap.builder();\n-            for (StageDynamicFilters stageDynamicFilters : context.getDynamicFilterSupplier().get()) {\n-                StageState stageState = stageDynamicFilters.getStageState();\n-                stageDynamicFilters.getTaskDynamicFilters().stream()\n-                        .flatMap(taskDomains -> taskDomains.entrySet().stream())\n-                        .filter(domain -> uncollectedFilters.contains(domain.getKey()))\n-                        .collect(groupingBy(Map.Entry::getKey, mapping(Map.Entry::getValue, toImmutableList())))\n-                        .entrySet().stream()\n+            for (StageId stageId : context.getStages()) {\n+                OptionalInt stageNumberOfTasks = context.getNumberOfTasks(stageId);\n+                context.getTaskDynamicFilters(stageId).entrySet().stream()\n                         .filter(stageDomains -> {\n                             if (stageDomains.getValue().stream().anyMatch(Domain::isAll)) {\n                                 // if one of the domains is all, we don't need to get dynamic filters from all tasks\n                                 return true;\n                             }\n \n-                            if (context.getReplicatedDynamicFilters().contains(stageDomains.getKey())) {\n+                            if (!stageDomains.getValue().isEmpty() && context.getReplicatedDynamicFilters().contains(stageDomains.getKey())) {\n+                                // for replicated dynamic filters it's enough to get dynamic filter from a single task\n                                 checkState(\n                                         stageDomains.getValue().size() == 1,\n                                         \"Replicated dynamic filter should be collected from single task\");\n-                                // for replicated dynamic filters it's enough to get dynamic filter from a single task\n                                 return true;\n                             }\n \n                             // check if all tasks of a dynamic filter source have reported dynamic filter summary\n-                            return !stageState.canScheduleMoreTasks() && stageDomains.getValue().size() == stageDynamicFilters.getNumberOfTasks();\n+                            return stageNumberOfTasks.isPresent() && stageDomains.getValue().size() == stageNumberOfTasks.getAsInt();\n                         })\n-                        .forEach(stageDomains -> newDynamicFiltersBuilder.put(stageDomains.getKey(), union(stageDomains.getValue())));\n+                        .forEach(stageDomains -> newDynamicFiltersBuilder.put(stageDomains.getKey(), union(ImmutableList.copyOf(stageDomains.getValue()))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMxNTE5MA==", "bodyText": "formatting:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        stageDynamicFilters.computeIfAbsent(taskId.getStageId(), ignored -> newConcurrentHashSet()).addAll(newDynamicFilters.keySet());\n          \n          \n            \n                        stageDynamicFilters.computeIfAbsent(taskId.getStageId(), ignored -> newConcurrentHashSet())\n          \n          \n            \n                                           .addAll(newDynamicFilters.keySet());", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r495315190", "createdAt": "2020-09-25T23:26:57Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -605,58 +591,100 @@ public int hashCode()\n         }\n     }\n \n+    /*\n+     * DynamicFilterContext can be fully lock-free since computing dynamic filter summaries\n+     * is idempotent. Concurrent computations of DF summaries should produce exact same result\n+     * when partial (from tasks) DFs are available. Partial DFs are only removed when\n+     * final dynamic filter summary is computed.\n+     */\n     private static class DynamicFilterContext\n     {\n         private final Map<DynamicFilterId, Domain> dynamicFilterSummaries = new ConcurrentHashMap<>();\n-        private final Supplier<List<StageDynamicFilters>> dynamicFilterSupplier;\n         private final Set<DynamicFilterId> dynamicFilters;\n         private final Map<DynamicFilterId, SettableFuture<?>> lazyDynamicFilters;\n         private final Set<DynamicFilterId> replicatedDynamicFilters;\n         private final AtomicBoolean completed = new AtomicBoolean();\n+        private final Map<StageId, Set<DynamicFilterId>> stageDynamicFilters = new ConcurrentHashMap<>();\n+        private final Map<StageId, Integer> stageNumberOfTasks = new ConcurrentHashMap<>();\n+        // when map value for given filter id is empty it means that dynamic filter has already been collected\n+        // and no partial task domains are required\n+        private final Map<DynamicFilterId, Map<TaskId, Domain>> taskDynamicFilters = new ConcurrentHashMap<>();\n \n         private DynamicFilterContext(\n-                Supplier<List<StageDynamicFilters>> dynamicFilterSupplier,\n                 Set<DynamicFilterId> dynamicFilters,\n                 Map<DynamicFilterId, SettableFuture<?>> lazyDynamicFilters,\n                 Set<DynamicFilterId> replicatedDynamicFilters)\n         {\n-            this.dynamicFilterSupplier = requireNonNull(dynamicFilterSupplier, \"dynamicFilterSupplier is null\");\n             this.dynamicFilters = requireNonNull(dynamicFilters, \"dynamicFilters is null\");\n             this.lazyDynamicFilters = requireNonNull(lazyDynamicFilters, \"lazyDynamicFilters is null\");\n             this.replicatedDynamicFilters = requireNonNull(replicatedDynamicFilters, \"replicatedDynamicFilters is null\");\n+            dynamicFilters.forEach(filter -> taskDynamicFilters.put(filter, new ConcurrentHashMap<>()));\n         }\n \n         private int getTotalDynamicFilters()\n         {\n             return dynamicFilters.size();\n         }\n \n-        private Set<DynamicFilterId> getUncollectedDynamicFilters()\n+        private Set<StageId> getStages()\n+        {\n+            return stageDynamicFilters.keySet();\n+        }\n+\n+        private OptionalInt getNumberOfTasks(StageId stageId)\n         {\n-            return dynamicFilters.stream()\n-                    .filter(filter -> !dynamicFilterSummaries.containsKey(filter))\n-                    .collect(toImmutableSet());\n+            return Optional.ofNullable(stageNumberOfTasks.get(stageId))\n+                    .map(OptionalInt::of)\n+                    .orElse(OptionalInt.empty());\n+        }\n+\n+        private Map<DynamicFilterId, List<Domain>> getTaskDynamicFilters(StageId stageId)\n+        {\n+            return stageDynamicFilters.get(stageId).stream()\n+                    .collect(toImmutableMap(\n+                            identity(),\n+                            filter -> Optional.ofNullable(taskDynamicFilters.get(filter))\n+                                    .map(taskDomains -> ImmutableList.copyOf(taskDomains.values()))\n+                                    // return empty list in case filter has already been collected and task domains have been removed\n+                                    .orElse(ImmutableList.of())));\n         }\n \n         private void addDynamicFilters(Map<DynamicFilterId, Domain> newDynamicFilters)\n         {\n             newDynamicFilters.forEach((filter, domain) -> {\n                 dynamicFilterSummaries.put(filter, domain);\n+                taskDynamicFilters.remove(filter);\n                 Optional.ofNullable(lazyDynamicFilters.get(filter)).ifPresent(future -> future.set(null));\n             });\n \n             // stop collecting dynamic filters for query when all dynamic filters have been collected\n             completed.set(dynamicFilters.stream().allMatch(dynamicFilterSummaries::containsKey));\n         }\n \n-        private Map<DynamicFilterId, Domain> getDynamicFilterSummaries()\n+        private void addTaskDynamicFilters(TaskId taskId, Map<DynamicFilterId, Domain> newDynamicFilters)\n         {\n-            return dynamicFilterSummaries;\n+            stageDynamicFilters.computeIfAbsent(taskId.getStageId(), ignored -> newConcurrentHashSet()).addAll(newDynamicFilters.keySet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 259}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e54b06c717fd6b1b0d14df5903e8223b9979f211", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/e54b06c717fd6b1b0d14df5903e8223b9979f211", "committedDate": "2020-09-28T08:58:25Z", "message": "Rename method to acknowledgeAndGetNewDynamicFilterDomains"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "322a3c2681828215a22a7ede75bd6cddf6f464f0", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/322a3c2681828215a22a7ede75bd6cddf6f464f0", "committedDate": "2020-09-28T09:14:57Z", "message": "Push dynamic filters into DynamicFilterService"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7ed592ef53e11102d9ab305e2ea857bc9cfc2fa", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/b7ed592ef53e11102d9ab305e2ea857bc9cfc2fa", "committedDate": "2020-09-28T09:24:28Z", "message": "Collect dynamic filters based on notification in DynamicFilterService"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e1e6c2dfd24a648ae7bf3f5d0a6abac22e3ca6b", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/4e1e6c2dfd24a648ae7bf3f5d0a6abac22e3ca6b", "committedDate": "2020-09-28T09:24:28Z", "message": "Assert that future did not finish exceptionally"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "480f8f5fde4bdbe8e5391540384aaa0a168bf253", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/480f8f5fde4bdbe8e5391540384aaa0a168bf253", "committedDate": "2020-09-28T09:25:12Z", "message": "Remove unused variable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "993876bdfbc223fd4569bf847366b2eb796a3d9a", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/993876bdfbc223fd4569bf847366b2eb796a3d9a", "committedDate": "2020-09-28T09:25:26Z", "message": "Fix formatting"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "993876bdfbc223fd4569bf847366b2eb796a3d9a", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/993876bdfbc223fd4569bf847366b2eb796a3d9a", "committedDate": "2020-09-28T09:25:26Z", "message": "Fix formatting"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3885, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}