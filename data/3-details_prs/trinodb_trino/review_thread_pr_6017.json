{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzOTY1MzU1", "number": 6017, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxODowMDozNVrOE824qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNzoxNToyMFrOE_uUwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjQ5MjU4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxODowMDozNVrOH5OzKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxODowMDozNVrOH5OzKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc3MzM1NQ==", "bodyText": "I don't like that this is deferring the analysis until planning time. One downside is that it can mess tracking of analysis timings, mask or hide certain issues (e.g, if the mask contains complex queries, analyzing it will require accessing metadata, resolving tables, etc)", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r529773355", "createdAt": "2020-11-24T18:00:35Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1284,7 +1284,12 @@ private void analyzeFiltersAndMasks(Table table, QualifiedObjectName name, Optio\n                     List<ViewExpression> masks = accessControl.getColumnMasks(session.toSecurityContext(), name, field.getName().get(), field.getType());\n                     columnMasks.put(field, masks);\n \n-                    masks.forEach(mask -> analyzeColumnMask(session.getIdentity().getUser(), table, name, field, accessControlScope, mask));\n+                    masks.forEach(mask -> analysis.addColumnMask(\n+                            table,\n+                            field.getName().get(),\n+                            new ColumnMask(\n+                                    () -> analyzeColumnMask(session.getIdentity().getUser(), table, name, field, accessControlScope, mask),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMzQ5MjkxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/query/TestColumnMask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwODo0NjoyM1rOH61ktg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMzo0MjoyM1rOH9bc8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ1NzIwNg==", "bodyText": "Why is it forbidden to insert or delete from table with a mask?", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r531457206", "createdAt": "2020-11-27T08:46:23Z", "author": {"login": "skrzypo987"}, "path": "presto-main/src/test/java/io/prestosql/sql/query/TestColumnMask.java", "diffHunk": "@@ -492,4 +494,44 @@ public void testJoin()\n \n         assertThat(assertions.query(\"SELECT count(*) FROM orders JOIN orders USING (orderkey)\")).matches(\"VALUES BIGINT '15000'\");\n     }\n+\n+    @Test\n+    public void testColumnMaskingUsingRestrictedColumn()\n+    {\n+        accessControl.reset();\n+        accessControl.deny(privilege(\"orders.custkey\", SELECT_COLUMN));\n+        accessControl.columnMask(\n+                new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                \"orderkey\",\n+                USER,\n+                new ViewExpression(USER, Optional.empty(), Optional.empty(), \"custkey\"));\n+        assertThatThrownBy(() -> assertions.query(\"SELECT orderkey FROM orders\"))\n+                .hasMessageMatching(\"\\\\QAccess Denied: Cannot select from columns [orderkey, custkey] in table or view local.tiny.orders\");\n+    }\n+\n+    @Test\n+    public void testInsertWithColumnMasking()\n+    {\n+        accessControl.reset();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3NDk2MQ==", "bodyText": "Because to INSERT row you would need to unmask the value :)\nAnything that has row filters or column masks is a bit similar to views, and you cannot simply insert or delete from view. See: #6154 (comment)", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r534174961", "createdAt": "2020-12-02T13:42:23Z", "author": {"login": "kokosing"}, "path": "presto-main/src/test/java/io/prestosql/sql/query/TestColumnMask.java", "diffHunk": "@@ -492,4 +494,44 @@ public void testJoin()\n \n         assertThat(assertions.query(\"SELECT count(*) FROM orders JOIN orders USING (orderkey)\")).matches(\"VALUES BIGINT '15000'\");\n     }\n+\n+    @Test\n+    public void testColumnMaskingUsingRestrictedColumn()\n+    {\n+        accessControl.reset();\n+        accessControl.deny(privilege(\"orders.custkey\", SELECT_COLUMN));\n+        accessControl.columnMask(\n+                new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                \"orderkey\",\n+                USER,\n+                new ViewExpression(USER, Optional.empty(), Optional.empty(), \"custkey\"));\n+        assertThatThrownBy(() -> assertions.query(\"SELECT orderkey FROM orders\"))\n+                .hasMessageMatching(\"\\\\QAccess Denied: Cannot select from columns [orderkey, custkey] in table or view local.tiny.orders\");\n+    }\n+\n+    @Test\n+    public void testInsertWithColumnMasking()\n+    {\n+        accessControl.reset();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ1NzIwNg=="}, "originalCommit": null, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMzUwMzMzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwODo0OTozNFrOH61rRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwODo0OTozNFrOH61rRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ1ODg4NQ==", "bodyText": "You can replace those two lines with:\n`flatMap(field -> field.getName().stream())", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r531458885", "createdAt": "2020-11-27T08:49:34Z", "author": {"login": "skrzypo987"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1278,14 +1278,27 @@ private void analyzeFiltersAndMasks(Table table, QualifiedObjectName name, Optio\n                     .withRelationType(RelationId.anonymous(), new RelationType(fields))\n                     .build();\n \n+            Set<String> allColumns = fields.stream()\n+                    .filter(field -> field.getName().isPresent())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MjUzNDI0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNzoxMjoyNFrOH9lbZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNzoxMjoyNFrOH9lbZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMzODQwNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (field.getName().isEmpty()) {\n          \n          \n            \n                                continue;\n          \n          \n            \n                            }\n          \n          \n            \n                            // do not collect mask for not accessible columns to prevent unnecessary semantic analysis\n          \n          \n            \n                            if (!visibleColumns.contains(field.getName().orElseThrow())) {\n          \n          \n            \n                                continue;\n          \n          \n            \n                            }\n          \n          \n            \n                            if (field.getName().isPresent() && visibleColumns.contains(field.getName().orElseThrow())) {", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r534338404", "createdAt": "2020-12-02T17:12:24Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1278,14 +1278,26 @@ private void analyzeFiltersAndMasks(Table table, QualifiedObjectName name, Optio\n                     .withRelationType(RelationId.anonymous(), new RelationType(fields))\n                     .build();\n \n+            Set<String> allColumns = fields.stream()\n+                    .flatMap(field -> field.getName().stream())\n+                    .collect(toImmutableSet());\n+\n+            Set<String> visibleColumns = accessControl.filterColumns(session.toSecurityContext(), name.asCatalogSchemaTableName(), allColumns);\n+\n             ImmutableMap.Builder<Field, List<ViewExpression>> columnMasks = ImmutableMap.builder();\n             for (Field field : fields) {\n-                if (field.getName().isPresent()) {\n-                    List<ViewExpression> masks = accessControl.getColumnMasks(session.toSecurityContext(), name, field.getName().get(), field.getType());\n-                    columnMasks.put(field, masks);\n-\n-                    masks.forEach(mask -> analyzeColumnMask(session.getIdentity().getUser(), table, name, field, accessControlScope, mask));\n+                if (field.getName().isEmpty()) {\n+                    continue;\n+                }\n+                // do not collect mask for not accessible columns to prevent unnecessary semantic analysis\n+                if (!visibleColumns.contains(field.getName().orElseThrow())) {\n+                    continue;\n                 }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MjU0NzIwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNzoxNToyMVrOH9ljYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNToxMToyNVrOID8-3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0MDQ1MA==", "bodyText": "This assumes that filterColumns agrees with the \"has select permissions\" on those columns. I'm not sure that's guaranteed to be always true. In the worst case (if filterColumns is more restrictive), we might miss adding a mask over a field that has one.", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r534340450", "createdAt": "2020-12-02T17:15:21Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1278,14 +1278,26 @@ private void analyzeFiltersAndMasks(Table table, QualifiedObjectName name, Optio\n                     .withRelationType(RelationId.anonymous(), new RelationType(fields))\n                     .build();\n \n+            Set<String> allColumns = fields.stream()\n+                    .flatMap(field -> field.getName().stream())\n+                    .collect(toImmutableSet());\n+\n+            Set<String> visibleColumns = accessControl.filterColumns(session.toSecurityContext(), name.asCatalogSchemaTableName(), allColumns);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3ODAwOA==", "bodyText": "Identity can see the column if they has any privilege to that column. Typically select. But it could be insert too. So we don't collect masks only if identity is not allowed to see a columns, when they has no access to column.", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r534378008", "createdAt": "2020-12-02T18:11:05Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1278,14 +1278,26 @@ private void analyzeFiltersAndMasks(Table table, QualifiedObjectName name, Optio\n                     .withRelationType(RelationId.anonymous(), new RelationType(fields))\n                     .build();\n \n+            Set<String> allColumns = fields.stream()\n+                    .flatMap(field -> field.getName().stream())\n+                    .collect(toImmutableSet());\n+\n+            Set<String> visibleColumns = accessControl.filterColumns(session.toSecurityContext(), name.asCatalogSchemaTableName(), allColumns);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0MDQ1MA=="}, "originalCommit": null, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxODY0Ng==", "bodyText": "The case you are describing might cause that DESCRIBE x could return less columns than SELECT * FROM x, which does not make sense to me.", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r534418646", "createdAt": "2020-12-02T19:15:39Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1278,14 +1278,26 @@ private void analyzeFiltersAndMasks(Table table, QualifiedObjectName name, Optio\n                     .withRelationType(RelationId.anonymous(), new RelationType(fields))\n                     .build();\n \n+            Set<String> allColumns = fields.stream()\n+                    .flatMap(field -> field.getName().stream())\n+                    .collect(toImmutableSet());\n+\n+            Set<String> visibleColumns = accessControl.filterColumns(session.toSecurityContext(), name.asCatalogSchemaTableName(), allColumns);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0MDQ1MA=="}, "originalCommit": null, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ2NTg4Nw==", "bodyText": "There's nothing preventing that from happening, though. I think that's a deficiency in the access control APIs -- there should be a single method to get/check for permissions for columns.", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r534465887", "createdAt": "2020-12-02T20:38:53Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1278,14 +1278,26 @@ private void analyzeFiltersAndMasks(Table table, QualifiedObjectName name, Optio\n                     .withRelationType(RelationId.anonymous(), new RelationType(fields))\n                     .build();\n \n+            Set<String> allColumns = fields.stream()\n+                    .flatMap(field -> field.getName().stream())\n+                    .collect(toImmutableSet());\n+\n+            Set<String> visibleColumns = accessControl.filterColumns(session.toSecurityContext(), name.asCatalogSchemaTableName(), allColumns);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0MDQ1MA=="}, "originalCommit": null, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAwNTg0OA==", "bodyText": "That is correct, the custom SPI implementation is out of our control. However we do require certain contract in many SPI parts. To me it is one place like that. The only problem here is that we don't have generic tests for access controls, where one could verify contract implementation. Such tests are impossible to write at the moment because, we can't simply \"insert\" authorization rules.\nWhat do you suggest then? Previously I had called checkCanSelectFromColumns with one column at a time in a loop, but this was so ugly...", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r535005848", "createdAt": "2020-12-03T09:32:36Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1278,14 +1278,26 @@ private void analyzeFiltersAndMasks(Table table, QualifiedObjectName name, Optio\n                     .withRelationType(RelationId.anonymous(), new RelationType(fields))\n                     .build();\n \n+            Set<String> allColumns = fields.stream()\n+                    .flatMap(field -> field.getName().stream())\n+                    .collect(toImmutableSet());\n+\n+            Set<String> visibleColumns = accessControl.filterColumns(session.toSecurityContext(), name.asCatalogSchemaTableName(), allColumns);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0MDQ1MA=="}, "originalCommit": null, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTAxNTc3NA==", "bodyText": "I think it\u2019s better to rely on chrckCanSelect. Someone may choose to use filterColumns as a way to obfuscate the available columns without preventing access to them, and the result would be a security bypass if there are column masks involved.", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r541015774", "createdAt": "2020-12-11T15:11:25Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1278,14 +1278,26 @@ private void analyzeFiltersAndMasks(Table table, QualifiedObjectName name, Optio\n                     .withRelationType(RelationId.anonymous(), new RelationType(fields))\n                     .build();\n \n+            Set<String> allColumns = fields.stream()\n+                    .flatMap(field -> field.getName().stream())\n+                    .collect(toImmutableSet());\n+\n+            Set<String> visibleColumns = accessControl.filterColumns(session.toSecurityContext(), name.asCatalogSchemaTableName(), allColumns);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0MDQ1MA=="}, "originalCommit": null, "originalPosition": 8}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4835, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}