{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwMDY0MTk4", "number": 5692, "title": "Fix timestamp with time zone coercion", "bodyText": "Fixes #5685\nFixes #5683\nFixes #5793", "createdAt": "2020-10-26T14:20:53Z", "url": "https://github.com/trinodb/trino/pull/5692", "merged": true, "mergeCommit": {"oid": "2aa2f15d465da39c0bdeaf94125b145bf07caba3"}, "closed": true, "closedAt": "2020-11-04T09:17:35Z", "author": {"login": "findepi"}, "timelineItems": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdWVJslABqjM5MjA5ODAyMTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdY_rBtAH2gAyNTEwMDY0MTk4OjBkODJiMzRiMDFlNTBlMDJhMzNjNGMxN2VlNDQ1NWU5MTYxMGRjM2U=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTAwNTgx", "url": "https://github.com/trinodb/trino/pull/5692#pullrequestreview-516900581", "createdAt": "2020-10-26T15:31:41Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTozMTo0MVrOHoVPPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTozOTo1M1rOHoVoqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzA1Mw==", "bodyText": "A comment will be helpful for why this check is needed. From what I understood this is to make sure we provide a TimestampLiteral only for cases where roundtrip is possible.", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512053053", "createdAt": "2020-10-26T15:31:41Z", "author": {"login": "hashhar"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LiteralEncoder.java", "diffHunk": "@@ -210,6 +218,32 @@ public Expression toExpression(Object object, Type type)\n             return new GenericLiteral(\"DATE\", new SqlDate(toIntExact((Long) object)).toString());\n         }\n \n+        if (type instanceof TimestampType) {\n+            TimestampType timestampType = (TimestampType) type;\n+            String representation;\n+            if (timestampType.isShort()) {\n+                representation = TimestampToVarcharCast.cast(timestampType.getPrecision(), (Long) object).toStringUtf8();\n+            }\n+            else {\n+                representation = TimestampToVarcharCast.cast(timestampType.getPrecision(), (LongTimestamp) object).toStringUtf8();\n+            }\n+            return new TimestampLiteral(representation);\n+        }\n+\n+        if (type instanceof TimestampWithTimeZoneType) {\n+            TimestampWithTimeZoneType timestampWithTimeZoneType = (TimestampWithTimeZoneType) type;\n+            String representation;\n+            if (timestampWithTimeZoneType.isShort()) {\n+                representation = TimestampWithTimeZoneToVarcharCast.cast(timestampWithTimeZoneType.getPrecision(), (long) object).toStringUtf8();\n+            }\n+            else {\n+                representation = TimestampWithTimeZoneToVarcharCast.cast(timestampWithTimeZoneType.getPrecision(), (LongTimestampWithTimeZone) object).toStringUtf8();\n+            }\n+            if (object.equals(parseTimestampWithTimeZone(timestampWithTimeZoneType.getPrecision(), representation))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1NzQ1MA==", "bodyText": "If this is something the SQL spec says then I would like if the comment ended with must be considered equal.\nFrom what I can see the spec says equality is when the UTC Instants are same (regardless of offset used).", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512057450", "createdAt": "2020-10-26T15:37:16Z", "author": {"login": "hashhar"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -196,6 +210,11 @@ private Expression unwrapCast(ComparisonExpression expression)\n             Type sourceType = typeAnalyzer.getType(session, types, cast.getExpression());\n             Type targetType = typeAnalyzer.getType(session, types, expression.getRight());\n \n+            if (targetType instanceof TimestampWithTimeZoneType) {\n+                // Note: two TIMESTAMP WITH TIME ZONE values differing in zone only are considered equal.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1OTU2MA==", "bodyText": "nit: I'd like the null timestamp and timestamptz changes to also go here. Or move the BIGINT case into testEncodeBigint.", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512059560", "createdAt": "2020-10-26T15:39:53Z", "author": {"login": "hashhar"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLiteralEncoder.java", "diffHunk": "@@ -90,28 +98,154 @@\n             ImmutableSet.of());\n \n     @Test\n-    public void testEncode()\n+    public void testEncodeNull()\n     {\n-        assertEncodeCaseInsensitively(utf8Slice(\"hello\"), VARBINARY, literalVarbinary(\"hello\".getBytes(UTF_8)));\n         assertEncode(null, UNKNOWN, \"null\");\n         assertEncode(null, BIGINT, \"CAST(null AS bigint)\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTk3NzI5", "url": "https://github.com/trinodb/trino/pull/5692#pullrequestreview-516997729", "createdAt": "2020-10-26T17:08:54Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNzowODo1NFrOHoZ0wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNzowODo1NFrOHoZ0wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEyODE5NA==", "bodyText": "typo in Rpresent TIMESTAMP constants readably in EXPLAIN commit message", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512128194", "createdAt": "2020-10-26T17:08:54Z", "author": {"login": "losipiuk"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LiteralEncoder.java", "diffHunk": "@@ -23,11 +23,14 @@\n import io.prestosql.metadata.Metadata;\n import io.prestosql.metadata.ResolvedFunction;\n import io.prestosql.operator.scalar.VarbinaryFunctions;\n+import io.prestosql.operator.scalar.timestamp.TimestampToVarcharCast;\n import io.prestosql.spi.block.Block;\n import io.prestosql.spi.type.CharType;\n import io.prestosql.spi.type.DecimalType;\n import io.prestosql.spi.type.Decimals;\n+import io.prestosql.spi.type.LongTimestamp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MDAwMjU3", "url": "https://github.com/trinodb/trino/pull/5692#pullrequestreview-517000257", "createdAt": "2020-10-26T17:11:44Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNzoxMTo0NFrOHoZ8aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNzoxMTo0NFrOHoZ8aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEzMDE1Mw==", "bodyText": "typo in Rpresent TIMESTAMP WITH TIME ZONE constants readably in EXPLAIN commit message", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512130153", "createdAt": "2020-10-26T17:11:44Z", "author": {"login": "losipiuk"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LiteralEncoder.java", "diffHunk": "@@ -24,13 +24,16 @@\n import io.prestosql.metadata.ResolvedFunction;\n import io.prestosql.operator.scalar.VarbinaryFunctions;\n import io.prestosql.operator.scalar.timestamp.TimestampToVarcharCast;\n+import io.prestosql.operator.scalar.timestamptz.TimestampWithTimeZoneToVarcharCast;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MDA2ODU3", "url": "https://github.com/trinodb/trino/pull/5692#pullrequestreview-517006857", "createdAt": "2020-10-26T17:19:09Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNzoxOToxMFrOHoaQhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNzoxOToxMFrOHoaQhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEzNTMwMA==", "bodyText": "should assertEncode also call assertRoundTrip internally?", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512135300", "createdAt": "2020-10-26T17:19:10Z", "author": {"login": "losipiuk"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLiteralEncoder.java", "diffHunk": "@@ -168,6 +173,62 @@ public void testEncodeTimestamp()\n         assertEncode(new LongTimestamp(1603710138_000000L, 0), createTimestampType(12), \"TIMESTAMP '2020-10-26 11:02:18.000000000000'\");\n     }\n \n+    @Test\n+    public void testEncodeTimestampWithTimeZone()\n+    {\n+        for (int precision = 0; precision <= 12; precision++) {\n+            assertEncode(null, createTimestampWithTimeZoneType(precision), format(\"CAST(null AS timestamp(%s) with time zone)\", precision));\n+        }\n+\n+        assertEncode(packDateTimeWithZone(1603710138_000L, UTC_KEY), createTimestampWithTimeZoneType(0), \"TIMESTAMP '2020-10-26 11:02:18 UTC'\");\n+        assertEncode(packDateTimeWithZone(1603710138_100L, UTC_KEY), createTimestampWithTimeZoneType(1), \"TIMESTAMP '2020-10-26 11:02:18.1 UTC'\");\n+        assertEncode(packDateTimeWithZone(1603710138_120L, UTC_KEY), createTimestampWithTimeZoneType(2), \"TIMESTAMP '2020-10-26 11:02:18.12 UTC'\");\n+        assertEncode(packDateTimeWithZone(1603710138_123L, UTC_KEY), createTimestampWithTimeZoneType(3), \"TIMESTAMP '2020-10-26 11:02:18.123 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 100000000, UTC_KEY), createTimestampWithTimeZoneType(4), \"TIMESTAMP '2020-10-26 11:02:18.1231 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 120000000, UTC_KEY), createTimestampWithTimeZoneType(5), \"TIMESTAMP '2020-10-26 11:02:18.12312 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123000000, UTC_KEY), createTimestampWithTimeZoneType(6), \"TIMESTAMP '2020-10-26 11:02:18.123123 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123400000, UTC_KEY), createTimestampWithTimeZoneType(7), \"TIMESTAMP '2020-10-26 11:02:18.1231234 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123450000, UTC_KEY), createTimestampWithTimeZoneType(8), \"TIMESTAMP '2020-10-26 11:02:18.12312345 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123456000, UTC_KEY), createTimestampWithTimeZoneType(9), \"TIMESTAMP '2020-10-26 11:02:18.123123456 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123456700, UTC_KEY), createTimestampWithTimeZoneType(10), \"TIMESTAMP '2020-10-26 11:02:18.1231234567 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123456780, UTC_KEY), createTimestampWithTimeZoneType(11), \"TIMESTAMP '2020-10-26 11:02:18.12312345678 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123456789, UTC_KEY), createTimestampWithTimeZoneType(12), \"TIMESTAMP '2020-10-26 11:02:18.123123456789 UTC'\");\n+\n+        assertEncode(packDateTimeWithZone(1603710138_000L, UTC_KEY), createTimestampWithTimeZoneType(1), \"TIMESTAMP '2020-10-26 11:02:18.0 UTC'\");\n+        assertEncode(packDateTimeWithZone(1603710138_000L, UTC_KEY), createTimestampWithTimeZoneType(2), \"TIMESTAMP '2020-10-26 11:02:18.00 UTC'\");\n+        assertEncode(packDateTimeWithZone(1603710138_000L, UTC_KEY), createTimestampWithTimeZoneType(3), \"TIMESTAMP '2020-10-26 11:02:18.000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(4), \"TIMESTAMP '2020-10-26 11:02:18.0000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(5), \"TIMESTAMP '2020-10-26 11:02:18.00000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(6), \"TIMESTAMP '2020-10-26 11:02:18.000000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(7), \"TIMESTAMP '2020-10-26 11:02:18.0000000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(8), \"TIMESTAMP '2020-10-26 11:02:18.00000000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(9), \"TIMESTAMP '2020-10-26 11:02:18.000000000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(10), \"TIMESTAMP '2020-10-26 11:02:18.0000000000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(11), \"TIMESTAMP '2020-10-26 11:02:18.00000000000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(12), \"TIMESTAMP '2020-10-26 11:02:18.000000000000 UTC'\");\n+\n+        // with zone\n+        assertEncode(packDateTimeWithZone(1603710138_000L, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(0), \"TIMESTAMP '2020-10-26 12:02:18 Europe/Warsaw'\");\n+        assertEncode(packDateTimeWithZone(1603710138_123L, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(3), \"TIMESTAMP '2020-10-26 12:02:18.123 Europe/Warsaw'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123000000, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(6), \"TIMESTAMP '2020-10-26 12:02:18.123123 Europe/Warsaw'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123456000, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(9), \"TIMESTAMP '2020-10-26 12:02:18.123123456 Europe/Warsaw'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123456789, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(12), \"TIMESTAMP '2020-10-26 12:02:18.123123456789 Europe/Warsaw'\");\n+\n+        // DST change forward\n+        assertEncode(packDateTimeWithZone(1585445478_000L, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(0), \"TIMESTAMP '2020-03-29 03:31:18 Europe/Warsaw'\");\n+        assertEncode(packDateTimeWithZone(1585445478_123L, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(3), \"TIMESTAMP '2020-03-29 03:31:18.123 Europe/Warsaw'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1585445478_123L, 123000000, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(6), \"TIMESTAMP '2020-03-29 03:31:18.123123 Europe/Warsaw'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1585445478_123L, 123456000, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(9), \"TIMESTAMP '2020-03-29 03:31:18.123123456 Europe/Warsaw'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1585445478_123L, 123456789, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(12), \"TIMESTAMP '2020-03-29 03:31:18.123123456789 Europe/Warsaw'\");\n+\n+        // DST change backward - no direct representation\n+        assertRoundTrip(packDateTimeWithZone(1603589478_000L, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(0), Long::equals);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MDI2NDAy", "url": "https://github.com/trinodb/trino/pull/5692#pullrequestreview-517026402", "createdAt": "2020-10-26T17:41:49Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MDk3OTU3", "url": "https://github.com/trinodb/trino/pull/5692#pullrequestreview-517097957", "createdAt": "2020-10-26T19:14:32Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxOToxNDozMlrOHoeoCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDowNDo1MVrOHogVOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwNjg1OA==", "bodyText": "Agreed. The \"as varchar\" representation for a timestamp w/ tz is unambiguous, so this check is unnecessary.", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512206858", "createdAt": "2020-10-26T19:14:32Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LiteralEncoder.java", "diffHunk": "@@ -210,6 +218,32 @@ public Expression toExpression(Object object, Type type)\n             return new GenericLiteral(\"DATE\", new SqlDate(toIntExact((Long) object)).toString());\n         }\n \n+        if (type instanceof TimestampType) {\n+            TimestampType timestampType = (TimestampType) type;\n+            String representation;\n+            if (timestampType.isShort()) {\n+                representation = TimestampToVarcharCast.cast(timestampType.getPrecision(), (Long) object).toStringUtf8();\n+            }\n+            else {\n+                representation = TimestampToVarcharCast.cast(timestampType.getPrecision(), (LongTimestamp) object).toStringUtf8();\n+            }\n+            return new TimestampLiteral(representation);\n+        }\n+\n+        if (type instanceof TimestampWithTimeZoneType) {\n+            TimestampWithTimeZoneType timestampWithTimeZoneType = (TimestampWithTimeZoneType) type;\n+            String representation;\n+            if (timestampWithTimeZoneType.isShort()) {\n+                representation = TimestampWithTimeZoneToVarcharCast.cast(timestampWithTimeZoneType.getPrecision(), (long) object).toStringUtf8();\n+            }\n+            else {\n+                representation = TimestampWithTimeZoneToVarcharCast.cast(timestampWithTimeZoneType.getPrecision(), (LongTimestampWithTimeZone) object).toStringUtf8();\n+            }\n+            if (object.equals(parseTimestampWithTimeZone(timestampWithTimeZoneType.getPrecision(), representation))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzA1Mw=="}, "originalCommit": null, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIxMTMxNw==", "bodyText": "This is probably something we should address separately. It shouldn't be possible to construct a timestamp w/ tz from a value that falls in a DST gap. The cast from varchar -> timestamp w/ tz already prevents it, but it's possible other places are not as strict.", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512211317", "createdAt": "2020-10-26T19:22:42Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLiteralEncoder.java", "diffHunk": "@@ -168,6 +173,62 @@ public void testEncodeTimestamp()\n         assertEncode(new LongTimestamp(1603710138_000000L, 0), createTimestampType(12), \"TIMESTAMP '2020-10-26 11:02:18.000000000000'\");\n     }\n \n+    @Test\n+    public void testEncodeTimestampWithTimeZone()\n+    {\n+        for (int precision = 0; precision <= 12; precision++) {\n+            assertEncode(null, createTimestampWithTimeZoneType(precision), format(\"CAST(null AS timestamp(%s) with time zone)\", precision));\n+        }\n+\n+        assertEncode(packDateTimeWithZone(1603710138_000L, UTC_KEY), createTimestampWithTimeZoneType(0), \"TIMESTAMP '2020-10-26 11:02:18 UTC'\");\n+        assertEncode(packDateTimeWithZone(1603710138_100L, UTC_KEY), createTimestampWithTimeZoneType(1), \"TIMESTAMP '2020-10-26 11:02:18.1 UTC'\");\n+        assertEncode(packDateTimeWithZone(1603710138_120L, UTC_KEY), createTimestampWithTimeZoneType(2), \"TIMESTAMP '2020-10-26 11:02:18.12 UTC'\");\n+        assertEncode(packDateTimeWithZone(1603710138_123L, UTC_KEY), createTimestampWithTimeZoneType(3), \"TIMESTAMP '2020-10-26 11:02:18.123 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 100000000, UTC_KEY), createTimestampWithTimeZoneType(4), \"TIMESTAMP '2020-10-26 11:02:18.1231 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 120000000, UTC_KEY), createTimestampWithTimeZoneType(5), \"TIMESTAMP '2020-10-26 11:02:18.12312 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123000000, UTC_KEY), createTimestampWithTimeZoneType(6), \"TIMESTAMP '2020-10-26 11:02:18.123123 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123400000, UTC_KEY), createTimestampWithTimeZoneType(7), \"TIMESTAMP '2020-10-26 11:02:18.1231234 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123450000, UTC_KEY), createTimestampWithTimeZoneType(8), \"TIMESTAMP '2020-10-26 11:02:18.12312345 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123456000, UTC_KEY), createTimestampWithTimeZoneType(9), \"TIMESTAMP '2020-10-26 11:02:18.123123456 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123456700, UTC_KEY), createTimestampWithTimeZoneType(10), \"TIMESTAMP '2020-10-26 11:02:18.1231234567 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123456780, UTC_KEY), createTimestampWithTimeZoneType(11), \"TIMESTAMP '2020-10-26 11:02:18.12312345678 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123456789, UTC_KEY), createTimestampWithTimeZoneType(12), \"TIMESTAMP '2020-10-26 11:02:18.123123456789 UTC'\");\n+\n+        assertEncode(packDateTimeWithZone(1603710138_000L, UTC_KEY), createTimestampWithTimeZoneType(1), \"TIMESTAMP '2020-10-26 11:02:18.0 UTC'\");\n+        assertEncode(packDateTimeWithZone(1603710138_000L, UTC_KEY), createTimestampWithTimeZoneType(2), \"TIMESTAMP '2020-10-26 11:02:18.00 UTC'\");\n+        assertEncode(packDateTimeWithZone(1603710138_000L, UTC_KEY), createTimestampWithTimeZoneType(3), \"TIMESTAMP '2020-10-26 11:02:18.000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(4), \"TIMESTAMP '2020-10-26 11:02:18.0000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(5), \"TIMESTAMP '2020-10-26 11:02:18.00000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(6), \"TIMESTAMP '2020-10-26 11:02:18.000000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(7), \"TIMESTAMP '2020-10-26 11:02:18.0000000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(8), \"TIMESTAMP '2020-10-26 11:02:18.00000000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(9), \"TIMESTAMP '2020-10-26 11:02:18.000000000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(10), \"TIMESTAMP '2020-10-26 11:02:18.0000000000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(11), \"TIMESTAMP '2020-10-26 11:02:18.00000000000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(12), \"TIMESTAMP '2020-10-26 11:02:18.000000000000 UTC'\");\n+\n+        // with zone\n+        assertEncode(packDateTimeWithZone(1603710138_000L, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(0), \"TIMESTAMP '2020-10-26 12:02:18 Europe/Warsaw'\");\n+        assertEncode(packDateTimeWithZone(1603710138_123L, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(3), \"TIMESTAMP '2020-10-26 12:02:18.123 Europe/Warsaw'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123000000, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(6), \"TIMESTAMP '2020-10-26 12:02:18.123123 Europe/Warsaw'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123456000, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(9), \"TIMESTAMP '2020-10-26 12:02:18.123123456 Europe/Warsaw'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123456789, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(12), \"TIMESTAMP '2020-10-26 12:02:18.123123456789 Europe/Warsaw'\");\n+\n+        // DST change forward\n+        assertEncode(packDateTimeWithZone(1585445478_000L, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(0), \"TIMESTAMP '2020-03-29 03:31:18 Europe/Warsaw'\");\n+        assertEncode(packDateTimeWithZone(1585445478_123L, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(3), \"TIMESTAMP '2020-03-29 03:31:18.123 Europe/Warsaw'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1585445478_123L, 123000000, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(6), \"TIMESTAMP '2020-03-29 03:31:18.123123 Europe/Warsaw'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1585445478_123L, 123456000, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(9), \"TIMESTAMP '2020-03-29 03:31:18.123123456 Europe/Warsaw'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1585445478_123L, 123456789, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(12), \"TIMESTAMP '2020-03-29 03:31:18.123123456789 Europe/Warsaw'\");\n+\n+        // DST change backward - no direct representation\n+        assertRoundTrip(packDateTimeWithZone(1603589478_000L, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(0), Long::equals);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEzNTMwMA=="}, "originalCommit": null, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIxMzQwMQ==", "bodyText": "Indeed, that comment is incorrect. They are considered equal if their instant in the same.\nThis deserves a better comment, too. The reason we reinterpret the value in the session timezone is so that the conversion roundtrips properly when going from timestamp w/ tz -> timestamp -> timestamp w/ tz.", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512213401", "createdAt": "2020-10-26T19:26:19Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -196,6 +210,11 @@ private Expression unwrapCast(ComparisonExpression expression)\n             Type sourceType = typeAnalyzer.getType(session, types, cast.getExpression());\n             Type targetType = typeAnalyzer.getType(session, types, expression.getRight());\n \n+            if (targetType instanceof TimestampWithTimeZoneType) {\n+                // Note: two TIMESTAMP WITH TIME ZONE values differing in zone only are considered equal.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1NzQ1MA=="}, "originalCommit": null, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIxNDE3NA==", "bodyText": "The commit message needs an explanation of why it's broken.", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512214174", "createdAt": "2020-10-26T19:27:36Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -13,6 +13,7 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIzNDQ5NA==", "bodyText": "What does \"instant truncation\" refer to here?", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512234494", "createdAt": "2020-10-26T20:04:19Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -462,6 +506,48 @@ private int compare(Type type, Object first, Object second)\n         }\n     }\n \n+    /**\n+     * Replace time zone component of a {@link TimestampWithTimeZoneType} value with a given one.\n+     */\n+    private static Object withTimeZone(TimestampWithTimeZoneType type, Object value, TimeZoneKey newZone)\n+    {\n+        if (type.isShort()) {\n+            return packDateTimeWithZone(unpackMillisUtc((long) value), newZone);\n+        }\n+        LongTimestampWithTimeZone longTimestampWithTimeZone = (LongTimestampWithTimeZone) value;\n+        return LongTimestampWithTimeZone.fromEpochMillisAndFraction(longTimestampWithTimeZone.getEpochMillis(), longTimestampWithTimeZone.getPicosOfMilli(), newZone);\n+    }\n+\n+    private static TimeZoneKey getTimeZone(TimestampWithTimeZoneType type, Object value)\n+    {\n+        if (type.isShort()) {\n+            return unpackZoneKey(((long) value));\n+        }\n+        return TimeZoneKey.getTimeZoneKey(((LongTimestampWithTimeZone) value).getTimeZoneKey());\n+    }\n+\n+    @VisibleForTesting\n+    static boolean isTimestampToTimestampWithTimeZoneInjectiveAt(ZoneId zone, Instant instant)\n+    {\n+        ZoneOffsetTransition transition = zone.getRules().previousTransition(instant);\n+        if (transition != null && !transition.getDuration().isNegative() &&\n+                transition.getDateTimeAfter().minusNanos(1).atZone(zone).toInstant().isAfter(instant)) {\n+            // DST change forward and the instant is ambiguous, being within the 'gap' area non-monotoic remapping\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private static Instant getInstantTruncation(TimestampWithTimeZoneType type, Object value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIzNDgwOA==", "bodyText": "return ...", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512234808", "createdAt": "2020-10-26T20:04:51Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -462,6 +506,48 @@ private int compare(Type type, Object first, Object second)\n         }\n     }\n \n+    /**\n+     * Replace time zone component of a {@link TimestampWithTimeZoneType} value with a given one.\n+     */\n+    private static Object withTimeZone(TimestampWithTimeZoneType type, Object value, TimeZoneKey newZone)\n+    {\n+        if (type.isShort()) {\n+            return packDateTimeWithZone(unpackMillisUtc((long) value), newZone);\n+        }\n+        LongTimestampWithTimeZone longTimestampWithTimeZone = (LongTimestampWithTimeZone) value;\n+        return LongTimestampWithTimeZone.fromEpochMillisAndFraction(longTimestampWithTimeZone.getEpochMillis(), longTimestampWithTimeZone.getPicosOfMilli(), newZone);\n+    }\n+\n+    private static TimeZoneKey getTimeZone(TimestampWithTimeZoneType type, Object value)\n+    {\n+        if (type.isShort()) {\n+            return unpackZoneKey(((long) value));\n+        }\n+        return TimeZoneKey.getTimeZoneKey(((LongTimestampWithTimeZone) value).getTimeZoneKey());\n+    }\n+\n+    @VisibleForTesting\n+    static boolean isTimestampToTimestampWithTimeZoneInjectiveAt(ZoneId zone, Instant instant)\n+    {\n+        ZoneOffsetTransition transition = zone.getRules().previousTransition(instant);\n+        if (transition != null && !transition.getDuration().isNegative() &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 118}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3NTE0MTg4", "url": "https://github.com/trinodb/trino/pull/5692#pullrequestreview-517514188", "createdAt": "2020-10-27T09:46:50Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwOTQxNDMy", "url": "https://github.com/trinodb/trino/pull/5692#pullrequestreview-520941432", "createdAt": "2020-10-30T18:41:11Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODo0MToxMVrOHrbzXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxOTowNToyNlrOHrcgzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwNjMzMg==", "bodyText": "I don't think this abstraction buys us much. I would just inline this in the few places where it's used.", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r515306332", "createdAt": "2020-10-30T18:41:11Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestUnwrapCastInComparison.java", "diffHunk": "@@ -977,4 +1053,29 @@ public void testNoEffect()\n                         filter(\"CAST(A AS INTEGER) = 1\",\n                                 values(\"A\"))));\n     }\n+\n+    private void testNoUnwrap(Session session, String inputType, String inputPredicate, String expectedCastType)\n+    {\n+        assertPlan(format(\"SELECT * FROM (VALUES CAST(NULL AS %s)) t(a) WHERE a %s\", inputType, inputPredicate),\n+                session,\n+                anyTree(\n+                        filter(format(\"CAST(A AS %s) %s\", expectedCastType, inputPredicate),\n+                                values(\"A\"))));\n+    }\n+\n+    private void testUnwrap(Session session, String inputType, String inputPredicate, String expectedPredicate)\n+    {\n+        assertPlan(format(\"SELECT * FROM (VALUES CAST(NULL AS %s)) t(a) WHERE a %s\", inputType, inputPredicate),\n+                session,\n+                anyTree(\n+                        filter(\"A \" + expectedPredicate,\n+                                values(\"A\"))));\n+    }\n+\n+    private static Session withZone(Session session, TimeZoneKey timeZoneKey)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwODcxNg==", "bodyText": "Maybe it's just me, but I find this less readable than having the explicit query in each of the cases, as in the other tests in this class. I keep having to reverse engineer what each of inputType, inputPredicate and expectedCastType mean in the context of a query that would benefit from this optimization. Yes, there is some repetition, but the test cases are self-evident, easier to understand at first glance, and easier to copy/paste when testing with a live server.", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r515308716", "createdAt": "2020-10-30T18:46:06Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestUnwrapCastInComparison.java", "diffHunk": "@@ -977,4 +1053,29 @@ public void testNoEffect()\n                         filter(\"CAST(A AS INTEGER) = 1\",\n                                 values(\"A\"))));\n     }\n+\n+    private void testNoUnwrap(Session session, String inputType, String inputPredicate, String expectedCastType)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxMDQ5Ng==", "bodyText": "Is this still pending?", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r515310496", "createdAt": "2020-10-30T18:49:46Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -433,6 +452,31 @@ private boolean hasInjectiveImplicitCoercion(Type source, Type target, Object va\n                 }\n             }\n \n+            if (target instanceof TimestampWithTimeZoneType) {\n+                TimestampWithTimeZoneType timestampWithTimeZoneType = (TimestampWithTimeZoneType) target;\n+                if (source instanceof TimestampType) {\n+                    // Cast from TIMESTAMP WITH TIME ZONE to TIMESTAMP and back to TIMESTAMP WITH TIME ZONE does not round trip, unless the value's zone is equal to sesion zone\n+                    if (!getTimeZone(timestampWithTimeZoneType, value).equals(session.getTimeZoneKey())) {\n+                        return false;\n+                    }\n+\n+                    // Cast from TIMESTAMP to TIMESTAMP WITH TIME ZONE is not monotonic when there is a forward DST change in the session zone\n+                    if (!isTimestampToTimestampWithTimeZoneInjectiveAt(session.getTimeZoneKey().getZoneId(), getInstantWithTruncation(timestampWithTimeZoneType, value))) {\n+                        return false;\n+                    }\n+\n+                    return true;\n+                }\n+                // CAST from TIMESTAMP WITH TIME ZONE to d and back to TIMESTAMP WITH TIME ZONE does not round trip for most types d\n+                // TODO add test coverage", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxNDExNg==", "bodyText": "The question is how do we ever end up with a timestamp w/ tz that falls in the gap or that has dual representation.\nPlease, add a comment and TODO to evaluate that behavior. We may want to disallow that in general.", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r515314116", "createdAt": "2020-10-30T18:57:12Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LiteralEncoder.java", "diffHunk": "@@ -210,6 +218,32 @@ public Expression toExpression(Object object, Type type)\n             return new GenericLiteral(\"DATE\", new SqlDate(toIntExact((Long) object)).toString());\n         }\n \n+        if (type instanceof TimestampType) {\n+            TimestampType timestampType = (TimestampType) type;\n+            String representation;\n+            if (timestampType.isShort()) {\n+                representation = TimestampToVarcharCast.cast(timestampType.getPrecision(), (Long) object).toStringUtf8();\n+            }\n+            else {\n+                representation = TimestampToVarcharCast.cast(timestampType.getPrecision(), (LongTimestamp) object).toStringUtf8();\n+            }\n+            return new TimestampLiteral(representation);\n+        }\n+\n+        if (type instanceof TimestampWithTimeZoneType) {\n+            TimestampWithTimeZoneType timestampWithTimeZoneType = (TimestampWithTimeZoneType) type;\n+            String representation;\n+            if (timestampWithTimeZoneType.isShort()) {\n+                representation = TimestampWithTimeZoneToVarcharCast.cast(timestampWithTimeZoneType.getPrecision(), (long) object).toStringUtf8();\n+            }\n+            else {\n+                representation = TimestampWithTimeZoneToVarcharCast.cast(timestampWithTimeZoneType.getPrecision(), (LongTimestampWithTimeZone) object).toStringUtf8();\n+            }\n+            if (object.equals(parseTimestampWithTimeZone(timestampWithTimeZoneType.getPrecision(), representation))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzA1Mw=="}, "originalCommit": null, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxNzk2Nw==", "bodyText": "This is being used in the call to isTimestampToTimestampWithTimeZoneInjectiveAt. What is the implication of truncation in determining if there is a transition if the instant is at the edge? What if the actual value is right outside of the transition by a few picoseconds? What does previousTransition return if the instant in nanoseconds is exactly at upper edge of a transition?", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r515317967", "createdAt": "2020-10-30T19:05:26Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -462,6 +506,48 @@ private int compare(Type type, Object first, Object second)\n         }\n     }\n \n+    /**\n+     * Replace time zone component of a {@link TimestampWithTimeZoneType} value with a given one, preserving point in time\n+     * (equivalent to {@link java.time.ZonedDateTime#withZoneSameInstant}.\n+     */\n+    private static Object withTimeZone(TimestampWithTimeZoneType type, Object value, TimeZoneKey newZone)\n+    {\n+        if (type.isShort()) {\n+            return packDateTimeWithZone(unpackMillisUtc((long) value), newZone);\n+        }\n+        LongTimestampWithTimeZone longTimestampWithTimeZone = (LongTimestampWithTimeZone) value;\n+        return LongTimestampWithTimeZone.fromEpochMillisAndFraction(longTimestampWithTimeZone.getEpochMillis(), longTimestampWithTimeZone.getPicosOfMilli(), newZone);\n+    }\n+\n+    private static TimeZoneKey getTimeZone(TimestampWithTimeZoneType type, Object value)\n+    {\n+        if (type.isShort()) {\n+            return unpackZoneKey(((long) value));\n+        }\n+        return TimeZoneKey.getTimeZoneKey(((LongTimestampWithTimeZone) value).getTimeZoneKey());\n+    }\n+\n+    @VisibleForTesting\n+    static boolean isTimestampToTimestampWithTimeZoneInjectiveAt(ZoneId zone, Instant instant)\n+    {\n+        ZoneOffsetTransition transition = zone.getRules().previousTransition(instant);\n+        if (transition == null) {\n+            return true;\n+        }\n+        // DST change forward and the instant is ambiguous, being within the 'gap' area non-monotonic remapping\n+        return transition.getDuration().isNegative() || !transition.getDateTimeAfter().minusNanos(1).atZone(zone).toInstant().isAfter(instant);\n+    }\n+\n+    private static Instant getInstantWithTruncation(TimestampWithTimeZoneType type, Object value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 126}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1dfa2046f7e2887ef46b2e32b89ee8f11a7ed831", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/1dfa2046f7e2887ef46b2e32b89ee8f11a7ed831", "committedDate": "2020-11-03T12:10:35Z", "message": "Import asList statically"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "814f2c809ad169d780024b3e4f73f0b47816f3fc", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/814f2c809ad169d780024b3e4f73f0b47816f3fc", "committedDate": "2020-11-03T12:10:38Z", "message": "Fix class/method names"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dcbf398aeaae8994521910ea461a792fe80bb3a0", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/dcbf398aeaae8994521910ea461a792fe80bb3a0", "committedDate": "2020-11-03T12:10:38Z", "message": "Remove unused parameter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d540e1a57c3d7eb4804f986b0eee6bbe0daa70c", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/8d540e1a57c3d7eb4804f986b0eee6bbe0daa70c", "committedDate": "2020-11-03T12:10:38Z", "message": "Split test method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd903dfed90452119bdb2476d01d12035824d4c9", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/dd903dfed90452119bdb2476d01d12035824d4c9", "committedDate": "2020-11-03T12:10:38Z", "message": "Represent TIMESTAMP constants readably in EXPLAIN"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNTkxNDE3", "url": "https://github.com/trinodb/trino/pull/5692#pullrequestreview-522591417", "createdAt": "2020-11-03T15:08:31Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNTowODozMVrOHszKlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNTowODozMVrOHszKlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjczNzY4NA==", "bodyText": "#5798", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516737684", "createdAt": "2020-11-03T15:08:31Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -433,6 +452,34 @@ private boolean hasInjectiveImplicitCoercion(Type source, Type target, Object va\n                 }\n             }\n \n+            if (target instanceof TimestampWithTimeZoneType) {\n+                TimestampWithTimeZoneType timestampWithTimeZoneType = (TimestampWithTimeZoneType) target;\n+                if (source instanceof TimestampType) {\n+                    // Cast from TIMESTAMP WITH TIME ZONE to TIMESTAMP and back to TIMESTAMP WITH TIME ZONE does not round trip, unless the value's zone is equal to sesion zone\n+                    if (!getTimeZone(timestampWithTimeZoneType, value).equals(session.getTimeZoneKey())) {\n+                        return false;\n+                    }\n+\n+                    // Cast from TIMESTAMP to TIMESTAMP WITH TIME ZONE is not monotonic when there is a forward DST change in the session zone\n+                    if (!isTimestampToTimestampWithTimeZoneInjectiveAt(session.getTimeZoneKey().getZoneId(), getInstantWithTruncation(timestampWithTimeZoneType, value))) {\n+                        return false;\n+                    }\n+\n+                    return true;\n+                }\n+                // CAST from TIMESTAMP WITH TIME ZONE to d and back to TIMESTAMP WITH TIME ZONE does not round trip for most types d\n+                // TODO add test coverage\n+                // TODO (https://github.com/prestosql/presto/issues/5798) handle DATE -> TIMESTAMP WITH TIME ZONE", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNjk5NjIx", "url": "https://github.com/trinodb/trino/pull/5692#pullrequestreview-522699621", "createdAt": "2020-11-03T16:58:17Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNjo1ODoxOFrOHs4FFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxODowMjoxN1rOHs6hTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxODE5OA==", "bodyText": "Mention in the commit message that these were in a separate class to be able to test legacy timestamp semantics", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516818198", "createdAt": "2020-11-03T16:58:18Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/operator/scalar/timestamptz/TestTimestampWithTimeZone.java", "diffHunk": "@@ -1310,6 +1310,298 @@ public void testCastToTimeWithTimeZone()\n         assertThat(assertions.expression(\"CAST(TIMESTAMP '2020-03-08 01:23:45.123456789123 -00:35' AS TIME(12) WITH TIME ZONE)\")).matches(\"TIME '01:23:45.123456789123-00:35'\");\n     }\n \n+    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxOTk0Mg==", "bodyText": "These should already be covered in testRoundDown and testRoundUp", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516819942", "createdAt": "2020-11-03T17:00:52Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/operator/scalar/timestamp/TestTimestamp.java", "diffHunk": "@@ -1165,6 +1165,298 @@ public void testCastToTimeWithTimeZone()\n         assertThat(assertions.expression(\"CAST(TIMESTAMP '2020-05-01 23:59:59.999999999999' AS TIME(11) WITH TIME ZONE)\", session)).matches(\"TIME '00:00:00.00000000000+08:35'\");\n     }\n \n+    @Test\n+    public void testCastToTimestamp()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0MTAyMQ==", "bodyText": "Unrelated to this commit.", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516841021", "createdAt": "2020-11-03T17:33:56Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/operator/scalar/timestamp/TestTimestamp.java", "diffHunk": "@@ -1183,6 +1183,19 @@ public void testCastToTimestamp()\n         assertThat(assertions.expression(\"CAST(TIMESTAMP '2020-05-01 12:34:56.12345678912' AS TIMESTAMP(11))\")).matches(\"TIMESTAMP '2020-05-01 12:34:56.12345678912'\");\n         assertThat(assertions.expression(\"CAST(TIMESTAMP '2020-05-01 12:34:56.123456789123' AS TIMESTAMP(12))\")).matches(\"TIMESTAMP '2020-05-01 12:34:56.123456789123'\");\n \n+        assertThat(assertions.expression(\"CAST(TIMESTAMP '2020-05-01 12:34:56.9' AS TIMESTAMP(1))\")).matches(\"TIMESTAMP '2020-05-01 12:34:56.9'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1MzE5Mg==", "bodyText": "one day we will add constant folding for Filter on top of VALUES ...\nor we will just add additional assertion where the VALUES are replaced with a temporary test table in eg memory connector\n\n... and we'll adjust the code to match, then. But ok, leave it.", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516853192", "createdAt": "2020-11-03T17:54:06Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestUnwrapCastInComparison.java", "diffHunk": "@@ -977,4 +1053,29 @@ public void testNoEffect()\n                         filter(\"CAST(A AS INTEGER) = 1\",\n                                 values(\"A\"))));\n     }\n+\n+    private void testNoUnwrap(Session session, String inputType, String inputPredicate, String expectedCastType)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwODcxNg=="}, "originalCommit": null, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1NzExNA==", "bodyText": "Link to #5781", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516857114", "createdAt": "2020-11-03T18:00:23Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LiteralEncoder.java", "diffHunk": "@@ -226,6 +230,25 @@ public Expression toExpression(Object object, Type type)\n             return new TimestampLiteral(representation);\n         }\n \n+        if (type instanceof TimestampWithTimeZoneType) {\n+            TimestampWithTimeZoneType timestampWithTimeZoneType = (TimestampWithTimeZoneType) type;\n+            String representation;\n+            if (timestampWithTimeZoneType.isShort()) {\n+                representation = TimestampWithTimeZoneToVarcharCast.cast(timestampWithTimeZoneType.getPrecision(), (long) object).toStringUtf8();\n+            }\n+            else {\n+                representation = TimestampWithTimeZoneToVarcharCast.cast(timestampWithTimeZoneType.getPrecision(), (LongTimestampWithTimeZone) object).toStringUtf8();\n+            }\n+            if (!object.equals(parseTimestampWithTimeZone(timestampWithTimeZoneType.getPrecision(), representation))) {\n+                // Certain (point in time, time zone) pairs cannot be represented as a TIMESTAMP literal, as the literal uses local date/time in given time zone.\n+                // Thus, during DST backwards change by e.g. 1 hour, the local time is \"repeated\" twice and thus one local date/time logically corresponds to two\n+                // points in time, leaving one of them non-referencable.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1ODE4OQ==", "bodyText": "Why not build a session with that time zone instead? Then, the test won't depend on external factors and will be self-contained.", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516858189", "createdAt": "2020-11-03T18:02:17Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/sql/query/TestUnwrapCastInComparison.java", "diffHunk": "@@ -214,6 +218,107 @@ public void testVarchar()\n         }\n     }\n \n+    @Test\n+    public void testCastTimestampToTimestampWithTimeZone()\n+    {\n+        ZoneId sessionZone = assertions.getDefaultSession().getTimeZoneKey().getZoneId();\n+        verify(sessionZone.getId().equals(\"Pacific/Apia\"), \"The values in this test assume Pacific/Apia is the session zone\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e1605dd05ef0f4b77dfd71d7dc2bda717810758", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/3e1605dd05ef0f4b77dfd71d7dc2bda717810758", "committedDate": "2020-11-03T19:18:31Z", "message": "Represent TIMESTAMP WITH TIME ZONE constants readably in EXPLAIN"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1660fac59c576c70567d6de954b777b6394080c9", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/1660fac59c576c70567d6de954b777b6394080c9", "committedDate": "2020-11-03T19:18:31Z", "message": "Move TIMESTAMP TZ to TIMESTAMP cast tests to TestTimestampWithTimeZone class\n\nThey were in a separate class for when we had to parameterize the tests\nfor legacy vs new timestamp semantics. That's no longer necessary."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40855c69b8c045e55e8dfb4ee2d7fd1b13ec5361", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/40855c69b8c045e55e8dfb4ee2d7fd1b13ec5361", "committedDate": "2020-11-03T19:18:31Z", "message": "Fix rounding in TIMESTAMP TZ to TIMESTAMP cast"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0bd26cdc8f014f1ce17aacb15301c7d846f2a15", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/d0bd26cdc8f014f1ce17aacb15301c7d846f2a15", "committedDate": "2020-11-03T19:18:31Z", "message": "Extract operator list constant"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODA1Mzc3", "url": "https://github.com/trinodb/trino/pull/5692#pullrequestreview-522805377", "createdAt": "2020-11-03T19:18:36Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "254db18c2efc213ed13f57b20971654d8ddfa9e3", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/254db18c2efc213ed13f57b20971654d8ddfa9e3", "committedDate": "2020-11-03T19:21:18Z", "message": "Fix unwrap for TIMESTAMP and TIMESTAMP WITH TIME ZONE\n\nBefore the change, a predicate\n\n    timestamp_column > TIMESTAMP 'date-time some-zone'\n\nwas being converted to\n\n    timestamp_column > TIMESTAMP 'date-time'\n\nHowever, the conversion is correct only when some-zone = session zone.\n\nNote: this seems to be a behavior regression since 341, the\n53bafb41da3b36f923f57f995b012bec9b85be4c commit."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "254db18c2efc213ed13f57b20971654d8ddfa9e3", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/254db18c2efc213ed13f57b20971654d8ddfa9e3", "committedDate": "2020-11-03T19:21:18Z", "message": "Fix unwrap for TIMESTAMP and TIMESTAMP WITH TIME ZONE\n\nBefore the change, a predicate\n\n    timestamp_column > TIMESTAMP 'date-time some-zone'\n\nwas being converted to\n\n    timestamp_column > TIMESTAMP 'date-time'\n\nHowever, the conversion is correct only when some-zone = session zone.\n\nNote: this seems to be a behavior regression since 341, the\n53bafb41da3b36f923f57f995b012bec9b85be4c commit."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d82b34b01e50e02a33c4c17ee4455e91610dc3e", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/0d82b34b01e50e02a33c4c17ee4455e91610dc3e", "committedDate": "2020-11-03T21:02:26Z", "message": "empty"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3140, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}