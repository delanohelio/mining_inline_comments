{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY5MjI5NTY2", "number": 2685, "title": "Fix LocalDynamicFiltersCollector#getPredicate for multiple co-located joins", "bodyText": "", "createdAt": "2020-01-30T18:48:01Z", "url": "https://github.com/trinodb/trino/pull/2685", "merged": true, "mergeCommit": {"oid": "2cdc587c9591b14d4dac7cca25a65ba3b4fb364d"}, "closed": true, "closedAt": "2020-02-06T10:59:58Z", "author": {"login": "raunaqmorarka"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb_qJ7ggBqjI5OTYwOTkyODI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcBoMfRgBqjMwMTMzMjM0Nzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxOTIxMjg1", "url": "https://github.com/trinodb/trino/pull/2685#pullrequestreview-351921285", "createdAt": "2020-02-02T06:24:13Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQwNjoyNDoxNFrOFkgUbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQwNjo0NjoxN1rOFkgYrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMjU3Mg==", "bodyText": "nit: consider renaming scanAssignments to probeSymbols (since \"assignments\" term is usually used for Assignments instances, IIUC).", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r373822572", "createdAt": "2020-02-02T06:24:14Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -26,20 +32,32 @@\n      * (e.g. in case of co-located joins).\n      */\n     @GuardedBy(\"this\")\n-    private TupleDomain<Symbol> predicate;\n-\n-    public LocalDynamicFiltersCollector()\n-    {\n-        this.predicate = TupleDomain.all();\n-    }\n+    private Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n \n-    public synchronized TupleDomain<Symbol> getPredicate()\n+    public synchronized TupleDomain<Symbol> getPredicate(Collection<Symbol> scanAssignments)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMjc2Ng==", "bodyText": "nit: consider using Map#merge() here, e.g.:\ndynamicFilterDomains.merge(entry.getKey(), entry.getValue(), Domain::intersect);", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r373822766", "createdAt": "2020-02-02T06:27:59Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -26,20 +32,32 @@\n      * (e.g. in case of co-located joins).\n      */\n     @GuardedBy(\"this\")\n-    private TupleDomain<Symbol> predicate;\n-\n-    public LocalDynamicFiltersCollector()\n-    {\n-        this.predicate = TupleDomain.all();\n-    }\n+    private Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n \n-    public synchronized TupleDomain<Symbol> getPredicate()\n+    public synchronized TupleDomain<Symbol> getPredicate(Collection<Symbol> scanAssignments)\n     {\n-        return predicate;\n+        ImmutableMap.Builder<Symbol, Domain> builder = ImmutableMap.builder();\n+        for (Symbol symbol : scanAssignments) {\n+            Domain domain = dynamicFilterDomainsResult.get(symbol);\n+            if (domain != null) {\n+                builder.put(symbol, domain);\n+            }\n+        }\n+        return TupleDomain.withColumnDomains(builder.build());\n     }\n \n-    public synchronized void intersect(TupleDomain<Symbol> predicate)\n+    // Domains for different subset of dynamic filters maybe requested by different table scans,\n+    // therefore we record and intersect Domain of each dynamic filter separately instead of in a combined TupleDomain\n+    public synchronized void intersect(Map<Symbol, Domain> dynamicFilterDomains)\n     {\n-        this.predicate = this.predicate.intersect(predicate);\n+        for (Map.Entry<Symbol, Domain> entry : dynamicFilterDomains.entrySet()) {\n+            Domain intersectionDomain = dynamicFilterDomainsResult.get(entry.getKey());\n+            if (intersectionDomain == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMzY2MQ==", "bodyText": "nit: consider using Map#getOrDefault here.", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r373823661", "createdAt": "2020-02-02T06:46:17Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFilter.java", "diffHunk": "@@ -82,29 +89,43 @@ private synchronized void addPartition(TupleDomain<String> tupleDomain)\n         result = TupleDomain.columnWiseUnion(result, tupleDomain);\n         if (partitionsLeft == 0) {\n             // No more partitions are left to be processed.\n-            verify(resultFuture.set(convertTupleDomain(result)), \"dynamic filter result is provided more than once\");\n+            verify(resultFuture.set(toDomainMap(result)), \"dynamic filter result is provided more than once\");\n         }\n     }\n \n-    private TupleDomain<Symbol> convertTupleDomain(TupleDomain<String> result)\n+    // We convert TupleDomain to Map<dynamic filter, Domain> with Domain.all/none stored explicitly\n+    // so that LocalDynamicFiltersCollector can correctly report Domains for any subset of dynamic filters\n+    private Map<Symbol, Domain> toDomainMap(TupleDomain<String> result)\n     {\n+        // Convert the predicate to use probe symbols (instead of dynamic filter IDs).\n+        // Note that in case of a probe-side union, a single dynamic filter may match multiple probe symbols.\n         if (result.isNone()) {\n-            return TupleDomain.none();\n+            ImmutableMap.Builder<Symbol, Domain> builder = ImmutableMap.builder();\n+            for (Map.Entry<String, Type> entry : filterTypes.entrySet()) {\n+                // Store all matching symbols for each build channel index.\n+                for (Symbol probeSymbol : probeSymbols.get(entry.getKey())) {\n+                    builder.put(probeSymbol, Domain.none(entry.getValue()));\n+                }\n+            }\n+            return builder.build();\n         }\n-        // Convert the predicate to use probe symbols (instead dynamic filter IDs).\n-        // Note that in case of a probe-side union, a single dynamic filter may match multiple probe symbols.\n+\n         ImmutableMap.Builder<Symbol, Domain> builder = ImmutableMap.builder();\n-        for (Map.Entry<String, Domain> entry : result.getDomains().get().entrySet()) {\n-            Domain domain = entry.getValue();\n+        Map<String, Domain> domains = result.getDomains().get();\n+        for (Map.Entry<String, Type> entry : filterTypes.entrySet()) {\n+            Domain domain = domains.get(entry.getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 72}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMjAzMDcy", "url": "https://github.com/trinodb/trino/pull/2685#pullrequestreview-352203072", "createdAt": "2020-02-03T11:59:21Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTo1OToyMlrOFkvC1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMjozNjo1OVrOFkv7og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA2MzgyOQ==", "bodyText": "commit message is too long", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r374063829", "createdAt": "2020-02-03T11:59:22Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFilter.java", "diffHunk": "@@ -21,6 +21,7 @@\n import io.airlift.log.Logger;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA3ODM3MA==", "bodyText": "Make probeSymbols a Set to explicitly avoid duplicates", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r374078370", "createdAt": "2020-02-03T12:36:59Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -26,20 +32,26 @@\n      * (e.g. in case of co-located joins).\n      */\n     @GuardedBy(\"this\")\n-    private TupleDomain<Symbol> predicate;\n-\n-    public LocalDynamicFiltersCollector()\n-    {\n-        this.predicate = TupleDomain.all();\n-    }\n+    private Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n \n-    public synchronized TupleDomain<Symbol> getPredicate()\n+    public synchronized TupleDomain<Symbol> getPredicate(Collection<Symbol> probeSymbols)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMjIzNjM0", "url": "https://github.com/trinodb/trino/pull/2685#pullrequestreview-352223634", "createdAt": "2020-02-03T12:40:26Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMjo0MDoyNlrOFkwA1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMjo0MDoyNlrOFkwA1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA3OTcwMA==", "bodyText": "LocalDynamicFilter is created per join node. Therefore TupleDomain should be fine here (empty domain means join filters everything)", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r374079700", "createdAt": "2020-02-03T12:40:26Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFilter.java", "diffHunk": "@@ -52,20 +53,26 @@\n     // Mapping from dynamic filter ID to its build channel indices.\n     private final Map<String, Integer> buildChannels;\n \n-    private final SettableFuture<TupleDomain<Symbol>> resultFuture;\n+    // Mapping from dynamic filter ID to its build channel type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyODQxMzU3", "url": "https://github.com/trinodb/trino/pull/2685#pullrequestreview-352841357", "createdAt": "2020-02-04T09:47:31Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwOTo0ODozMlrOFlN1-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxMDoxMTozNlrOFlOlRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2ODQ0Mg==", "bodyText": "let's rename this method to addDynamicFilter ane make it accept Map<Symbol, Domain>\nMake io.prestosql.sql.planner.LocalDynamicFilter#getResultFuture return Map<Symbol, Domain>, but make conversion from TupleDomain<String> to Map<Symbol, Domain> in io.prestosql.sql.planner.LocalDynamicFilter#convertTupleDomain", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r374568442", "createdAt": "2020-02-04T09:48:32Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -26,20 +33,37 @@\n      * (e.g. in case of co-located joins).\n      */\n     @GuardedBy(\"this\")\n-    private TupleDomain<Symbol> predicate;\n-\n-    public LocalDynamicFiltersCollector()\n-    {\n-        this.predicate = TupleDomain.all();\n-    }\n+    private Optional<Map<Symbol, Domain>> dynamicFilterDomainsResult = Optional.of(new HashMap<>());\n \n-    public synchronized TupleDomain<Symbol> getPredicate()\n+    public synchronized TupleDomain<Symbol> getPredicate(Set<Symbol> probeSymbols)\n     {\n-        return predicate;\n+        if (!dynamicFilterDomainsResult.isPresent()) {\n+            return TupleDomain.none();\n+        }\n+        ImmutableMap.Builder<Symbol, Domain> builder = ImmutableMap.builder();\n+        Map<Symbol, Domain> domains = dynamicFilterDomainsResult.get();\n+        for (Symbol symbol : probeSymbols) {\n+            Domain domain = domains.get(symbol);\n+            if (domain != null) {\n+                builder.put(symbol, domain);\n+            }\n+        }\n+        return TupleDomain.withColumnDomains(builder.build());\n     }\n \n+    // Domains for different subset of dynamic filters maybe requested by different table scans,\n+    // therefore we record and intersect Domain of each dynamic filter separately instead of in a combined TupleDomain\n     public synchronized void intersect(TupleDomain<Symbol> predicate)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2ODc5NQ==", "bodyText": "you shouldn't set entire map to empty. It might contain predicates for other joins", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r374568795", "createdAt": "2020-02-04T09:49:11Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -26,20 +33,37 @@\n      * (e.g. in case of co-located joins).\n      */\n     @GuardedBy(\"this\")\n-    private TupleDomain<Symbol> predicate;\n-\n-    public LocalDynamicFiltersCollector()\n-    {\n-        this.predicate = TupleDomain.all();\n-    }\n+    private Optional<Map<Symbol, Domain>> dynamicFilterDomainsResult = Optional.of(new HashMap<>());\n \n-    public synchronized TupleDomain<Symbol> getPredicate()\n+    public synchronized TupleDomain<Symbol> getPredicate(Set<Symbol> probeSymbols)\n     {\n-        return predicate;\n+        if (!dynamicFilterDomainsResult.isPresent()) {\n+            return TupleDomain.none();\n+        }\n+        ImmutableMap.Builder<Symbol, Domain> builder = ImmutableMap.builder();\n+        Map<Symbol, Domain> domains = dynamicFilterDomainsResult.get();\n+        for (Symbol symbol : probeSymbols) {\n+            Domain domain = domains.get(symbol);\n+            if (domain != null) {\n+                builder.put(symbol, domain);\n+            }\n+        }\n+        return TupleDomain.withColumnDomains(builder.build());\n     }\n \n+    // Domains for different subset of dynamic filters maybe requested by different table scans,\n+    // therefore we record and intersect Domain of each dynamic filter separately instead of in a combined TupleDomain\n     public synchronized void intersect(TupleDomain<Symbol> predicate)\n     {\n-        this.predicate = this.predicate.intersect(predicate);\n+        if (predicate.isNone()) {\n+            dynamicFilterDomainsResult = Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU3MDM1MA==", "bodyText": "I would rename this method to be more explicit, e.g\ngetDynamicFilter", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r374570350", "createdAt": "2020-02-04T09:51:58Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -26,20 +33,37 @@\n      * (e.g. in case of co-located joins).\n      */\n     @GuardedBy(\"this\")\n-    private TupleDomain<Symbol> predicate;\n-\n-    public LocalDynamicFiltersCollector()\n-    {\n-        this.predicate = TupleDomain.all();\n-    }\n+    private Optional<Map<Symbol, Domain>> dynamicFilterDomainsResult = Optional.of(new HashMap<>());\n \n-    public synchronized TupleDomain<Symbol> getPredicate()\n+    public synchronized TupleDomain<Symbol> getPredicate(Set<Symbol> probeSymbols)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU3MzE4NQ==", "bodyText": "comment for the future\nTBH: now I think LocalDynamicFilter has too big responsibility. It should produce TupleDomain<String> (where string is filter id) instead of TupleDomain<Symbol>.\nEach table scan should translate String -> Symbol itself.", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r374573185", "createdAt": "2020-02-04T09:57:20Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,11 +13,18 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n @ThreadSafe\n class LocalDynamicFiltersCollector", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU3NzA3OQ==", "bodyText": "Don't need optional here, use empty map initially.", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r374577079", "createdAt": "2020-02-04T10:04:49Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -26,20 +33,37 @@\n      * (e.g. in case of co-located joins).\n      */\n     @GuardedBy(\"this\")\n-    private TupleDomain<Symbol> predicate;\n-\n-    public LocalDynamicFiltersCollector()\n-    {\n-        this.predicate = TupleDomain.all();\n-    }\n+    private Optional<Map<Symbol, Domain>> dynamicFilterDomainsResult = Optional.of(new HashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU4MDU1MA==", "bodyText": "remove this comment (I don't think it will be relevant)", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r374580550", "createdAt": "2020-02-04T10:11:36Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -26,20 +33,37 @@\n      * (e.g. in case of co-located joins).\n      */\n     @GuardedBy(\"this\")\n-    private TupleDomain<Symbol> predicate;\n-\n-    public LocalDynamicFiltersCollector()\n-    {\n-        this.predicate = TupleDomain.all();\n-    }\n+    private Optional<Map<Symbol, Domain>> dynamicFilterDomainsResult = Optional.of(new HashMap<>());\n \n-    public synchronized TupleDomain<Symbol> getPredicate()\n+    public synchronized TupleDomain<Symbol> getPredicate(Set<Symbol> probeSymbols)\n     {\n-        return predicate;\n+        if (!dynamicFilterDomainsResult.isPresent()) {\n+            return TupleDomain.none();\n+        }\n+        ImmutableMap.Builder<Symbol, Domain> builder = ImmutableMap.builder();\n+        Map<Symbol, Domain> domains = dynamicFilterDomainsResult.get();\n+        for (Symbol symbol : probeSymbols) {\n+            Domain domain = domains.get(symbol);\n+            if (domain != null) {\n+                builder.put(symbol, domain);\n+            }\n+        }\n+        return TupleDomain.withColumnDomains(builder.build());\n     }\n \n+    // Domains for different subset of dynamic filters maybe requested by different table scans,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 49}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNTY5ODY5", "url": "https://github.com/trinodb/trino/pull/2685#pullrequestreview-353569869", "createdAt": "2020-02-05T09:27:48Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwOToyNzo0OVrOFlw41A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwOTozNjo0MVrOFlxKNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE0MjYxMg==", "bodyText": "you could use stream here:\nbuildChannels.keySet().stream()\n  .flatMap(filterId -> probeSymbols.get(filderId).stream())\n  .collect(toImmutableMap(probeSymbol -> probeSymbol, omain.none(types.get(probeSymbol)));", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r375142612", "createdAt": "2020-02-05T09:27:49Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFilter.java", "diffHunk": "@@ -86,10 +89,17 @@ private synchronized void addPartition(TupleDomain<String> tupleDomain)\n         }\n     }\n \n-    private TupleDomain<Symbol> convertTupleDomain(TupleDomain<String> result)\n+    private Map<Symbol, Domain> convertTupleDomain(TupleDomain<String> result)\n     {\n         if (result.isNone()) {\n-            return TupleDomain.none();\n+            ImmutableMap.Builder<Symbol, Domain> builder = ImmutableMap.builder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE0Mjg1NA==", "bodyText": "use stream here also.", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r375142854", "createdAt": "2020-02-05T09:28:16Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFilter.java", "diffHunk": "@@ -86,10 +89,17 @@ private synchronized void addPartition(TupleDomain<String> tupleDomain)\n         }\n     }\n \n-    private TupleDomain<Symbol> convertTupleDomain(TupleDomain<String> result)\n+    private Map<Symbol, Domain> convertTupleDomain(TupleDomain<String> result)\n     {\n         if (result.isNone()) {\n-            return TupleDomain.none();\n+            ImmutableMap.Builder<Symbol, Domain> builder = ImmutableMap.builder();\n+            for (String filterId : buildChannels.keySet()) {\n+                // Store all matching symbols for each build channel index.\n+                for (Symbol probeSymbol : probeSymbols.get(filterId)) {\n+                    builder.put(probeSymbol, Domain.none(types.get(probeSymbol)));\n+                }\n+            }\n+            return builder.build();\n         }\n         // Convert the predicate to use probe symbols (instead dynamic filter IDs).\n         // Note that in case of a probe-side union, a single dynamic filter may match multiple probe symbols.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE0MzgyMQ==", "bodyText": "you could add a similar comment:\none of the join build symbols has no non-null values, therefore no symbols can match predicate", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r375143821", "createdAt": "2020-02-05T09:30:14Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFilter.java", "diffHunk": "@@ -86,10 +89,17 @@ private synchronized void addPartition(TupleDomain<String> tupleDomain)\n         }\n     }\n \n-    private TupleDomain<Symbol> convertTupleDomain(TupleDomain<String> result)\n+    private Map<Symbol, Domain> convertTupleDomain(TupleDomain<String> result)\n     {\n         if (result.isNone()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE0Mzk4Ng==", "bodyText": "use streams here", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r375143986", "createdAt": "2020-02-05T09:30:36Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -26,20 +32,24 @@\n      * (e.g. in case of co-located joins).\n      */\n     @GuardedBy(\"this\")\n-    private TupleDomain<Symbol> predicate;\n-\n-    public LocalDynamicFiltersCollector()\n-    {\n-        this.predicate = TupleDomain.all();\n-    }\n+    private Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n \n-    public synchronized TupleDomain<Symbol> getPredicate()\n+    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n     {\n-        return predicate;\n+        ImmutableMap.Builder<Symbol, Domain> builder = ImmutableMap.builder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE0NTkzOQ==", "bodyText": "Please also make sure that adding none domain for particular symbol doesn't affect other symbols (set them to none domain too)", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r375145939", "createdAt": "2020-02-05T09:34:27Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "diffHunk": "@@ -29,25 +33,64 @@\n     public void testCollector()\n     {\n         Symbol symbol = new Symbol(\"symbol\");\n+        Set<Symbol> probeSymbols = ImmutableSet.of(symbol);\n \n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getPredicate(), TupleDomain.all());\n+        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.all());\n \n-        collector.intersect(TupleDomain.all());\n-        assertEquals(collector.getPredicate(), TupleDomain.all());\n+        collector.addDynamicFilter(ImmutableMap.of());\n+        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.all());\n \n-        collector.intersect(tupleDomain(symbol, 1L, 2L));\n-        assertEquals(collector.getPredicate(), tupleDomain(symbol, 1L, 2L));\n+        collector.addDynamicFilter(toDomainMap(symbol, 1L, 2L));\n+        assertEquals(collector.getDynamicFilter(probeSymbols), tupleDomain(symbol, 1L, 2L));\n \n-        collector.intersect(tupleDomain(symbol, 2L, 3L));\n-        assertEquals(collector.getPredicate(), tupleDomain(symbol, 2L));\n+        collector.addDynamicFilter(toDomainMap(symbol, 2L, 3L));\n+        assertEquals(collector.getDynamicFilter(probeSymbols), tupleDomain(symbol, 2L));\n \n-        collector.intersect(tupleDomain(symbol, 0L));\n-        assertEquals(collector.getPredicate(), TupleDomain.none());\n+        collector.addDynamicFilter(toDomainMap(symbol, 0L));\n+        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.none());\n+    }\n+\n+    @Test\n+    public void testCollectorMultipleScans()\n+    {\n+        Symbol symbol1 = new Symbol(\"symbol1\");\n+        Symbol symbol2 = new Symbol(\"symbol2\");\n+        Set<Symbol> probeSymbols1 = ImmutableSet.of(symbol1);\n+        Set<Symbol> probeSymbols2 = ImmutableSet.of(symbol2);\n+\n+        LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n+        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.all());\n+        assertEquals(collector.getDynamicFilter(probeSymbols2), TupleDomain.all());\n+\n+        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n+        collector.addDynamicFilter(toDomainMap(symbol2, 2L, 3L));\n+        assertEquals(collector.getDynamicFilter(probeSymbols1), tupleDomain(symbol1, 1L, 2L));\n+        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n+        assertEquals(collector.getDynamicFilter(\n+                ImmutableSet.of(symbol1, symbol2)),\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        symbol1, Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L)),\n+                        symbol2, Domain.multipleValues(BIGINT, ImmutableList.of(2L, 3L)))));\n+\n+        collector.addDynamicFilter(toDomainMap(symbol1, 0L));\n+        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n+        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n+        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n+\n+        collector.addDynamicFilter(ImmutableMap.of(symbol2, Domain.none(BIGINT)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE0NzA2MQ==", "bodyText": "change it to consumer.accept(TupleDomain.none())", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r375147061", "createdAt": "2020-02-05T09:36:41Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFilter.java", "diffHunk": "@@ -128,17 +132,18 @@ public void testNone()\n         LocalDynamicFilter filter = new LocalDynamicFilter(\n                 ImmutableMultimap.of(\"123\", new Symbol(\"a\")),\n                 ImmutableMap.of(\"123\", 0),\n+                TypeProvider.copyOf(ImmutableMap.of(new Symbol(\"a\"), INTEGER)),\n                 1);\n         assertEquals(filter.getBuildChannels(), ImmutableMap.of(\"123\", 0));\n         Consumer<TupleDomain<String>> consumer = filter.getTupleDomainConsumer();\n-        ListenableFuture<TupleDomain<Symbol>> result = filter.getResultFuture();\n+        ListenableFuture<Map<Symbol, Domain>> result = filter.getResultFuture();\n \n         assertFalse(result.isDone());\n         consumer.accept(TupleDomain.withColumnDomains(ImmutableMap.of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 87}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MzA2Mjg0", "url": "https://github.com/trinodb/trino/pull/2685#pullrequestreview-354306284", "createdAt": "2020-02-06T09:31:56Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwOTozMTo1NlrOFmUbZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwOTozMTo1NlrOFmUbZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcyNDkwMg==", "bodyText": "I think loop was better here, please revert. Sorry", "url": "https://github.com/trinodb/trino/pull/2685#discussion_r375724902", "createdAt": "2020-02-06T09:31:56Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFilter.java", "diffHunk": "@@ -86,25 +90,23 @@ private synchronized void addPartition(TupleDomain<String> tupleDomain)\n         }\n     }\n \n-    private TupleDomain<Symbol> convertTupleDomain(TupleDomain<String> result)\n+    private Map<Symbol, Domain> convertTupleDomain(TupleDomain<String> result)\n     {\n         if (result.isNone()) {\n-            return TupleDomain.none();\n+            // One of the join build symbols has no non-null values, therefore no symbols can match predicate\n+            return buildChannels.keySet().stream()\n+                    .flatMap(filterId -> probeSymbols.get(filterId).stream())\n+                    .collect(toImmutableMap(identity(), probeSymbol -> Domain.none(types.get(probeSymbol))));\n         }\n         // Convert the predicate to use probe symbols (instead dynamic filter IDs).\n         // Note that in case of a probe-side union, a single dynamic filter may match multiple probe symbols.\n-        ImmutableMap.Builder<Symbol, Domain> builder = ImmutableMap.builder();\n-        for (Map.Entry<String, Domain> entry : result.getDomains().get().entrySet()) {\n-            Domain domain = entry.getValue();\n-            // Store all matching symbols for each build channel index.\n-            for (Symbol probeSymbol : probeSymbols.get(entry.getKey())) {\n-                builder.put(probeSymbol, domain);\n-            }\n-        }\n-        return TupleDomain.withColumnDomains(builder.build());\n+        return result.getDomains().get().entrySet().stream()\n+                .flatMap(entry -> probeSymbols.get(entry.getKey()).stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 80}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edf7fbf59523a7570c7ddb279abbd5dd23729f7f", "author": {"user": {"login": "raunaqmorarka", "name": "Raunaq Morarka"}}, "url": "https://github.com/trinodb/trino/commit/edf7fbf59523a7570c7ddb279abbd5dd23729f7f", "committedDate": "2020-02-06T10:29:35Z", "message": "Fix LocalDynamicFiltersCollector#getPredicate for multiple co-located joins"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "edf7fbf59523a7570c7ddb279abbd5dd23729f7f", "author": {"user": {"login": "raunaqmorarka", "name": "Raunaq Morarka"}}, "url": "https://github.com/trinodb/trino/commit/edf7fbf59523a7570c7ddb279abbd5dd23729f7f", "committedDate": "2020-02-06T10:29:35Z", "message": "Fix LocalDynamicFiltersCollector#getPredicate for multiple co-located joins"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1745, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}