{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI1MTg5NDUy", "number": 6042, "title": "Aggregation simplify declarations", "bodyText": "", "createdAt": "2020-11-21T21:02:44Z", "url": "https://github.com/trinodb/trino/pull/6042", "merged": true, "mergeCommit": {"oid": "aec7351483dd7dd6b8788adac0a77a1bf9c8aa2f"}, "closed": true, "closedAt": "2021-10-09T07:19:10Z", "author": {"login": "dain"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABde0U5TgBqjQwMjQyODkyOTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABfGOgDTABqjU0Mzc2OTUyMDc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzMjIwMDM0", "url": "https://github.com/trinodb/trino/pull/6042#pullrequestreview-543220034", "createdAt": "2020-12-02T20:41:52Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMTowNDo0NVrOH9uF9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMTowNDo0NVrOH9uF9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ4MDM3NQ==", "bodyText": "for consistency, maybe call \"toParse\" => \"outputFunction\" or \"outputFunctionToParse? especially since you are calling getName and getAliases functions that require that input", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r534480375", "createdAt": "2020-12-02T21:04:45Z", "author": {"login": "erichwang"}, "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AggregationFromAnnotationsParser.java", "diffHunk": "@@ -70,89 +70,104 @@ public static ParametricAggregation parseFunctionDefinitionWithTypesConstraint(C\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        ImmutableList.Builder<ParametricAggregation> builder = ImmutableList.builder();\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n-                for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                    Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                    for (AggregationHeader header : parseHeaders(aggregationDefinition, outputFunction)) {\n-                        AggregationImplementation onlyImplementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                        ParametricImplementationsGroup<AggregationImplementation> implementations = ParametricImplementationsGroup.of(onlyImplementation);\n-                        builder.add(new ParametricAggregation(implementations.getSignature(), header, implementations, deprecated));\n-                    }\n+\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        Class<?> stateClass = getStateClass(aggregationDefinition);\n+        Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n+        for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n+            AggregationHeader header = parseHeader(aggregationDefinition, outputFunction);\n+\n+            List<AggregationImplementation> exactImplementations = new ArrayList<>();\n+            List<AggregationImplementation> nonExactImplementations = new ArrayList<>();\n+            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n+                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n+                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header.getName(), inputFunction, removeInputFunction, outputFunction, combineFunction);\n+                if (isExact(implementation.getSignature())) {\n+                    exactImplementations.add(implementation);\n+                }\n+                else {\n+                    nonExactImplementations.add(implementation);\n                 }\n             }\n+\n+            functions.addAll(buildFunctions(header.getName(), header, stateClass, exactImplementations, nonExactImplementations));\n+            for (String alias : getAliases(aggregationDefinition.getAnnotation(AggregationFunction.class), outputFunction)) {\n+                functions.addAll(buildFunctions(alias, header, stateClass, exactImplementations, nonExactImplementations));\n+            }\n         }\n \n-        return builder.build();\n+        return functions.build();\n     }\n \n-    public static ParametricAggregation parseFunctionDefinition(Class<?> aggregationDefinition)\n+    private static List<ParametricAggregation> buildFunctions(\n+            String name,\n+            AggregationHeader header,\n+            Class<?> stateClass,\n+            List<AggregationImplementation> exactImplementations,\n+            List<AggregationImplementation> nonExactImplementations)\n     {\n-        ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n-        AggregationHeader header = parseHeader(aggregationDefinition);\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            Method outputFunction = getOnlyElement(getOutputFunctions(aggregationDefinition, stateClass));\n-            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                implementationsBuilder.addImplementation(implementation);\n-            }\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // create a separate function for each exact implementation\n+        for (AggregationImplementation exactImplementation : exactImplementations) {\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, exactImplementation.getSignature()),\n+                    header,\n+                    stateClass,\n+                    ParametricImplementationsGroup.of(exactImplementation).withAlias(name)));\n         }\n+        // if there are non-exact functions, create a generic function\n+        if (!nonExactImplementations.isEmpty()) {\n+            ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n+            nonExactImplementations.forEach(implementationsBuilder::addImplementation);\n+            ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, implementations.getSignature()),\n+                    header,\n+                    stateClass,\n+                    implementations.withAlias(name)));\n+        }\n+        return functions.build();\n+    }\n \n-        ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n-        return new ParametricAggregation(implementations.getSignature(), header, implementations, deprecated);\n+    private static boolean isExact(Signature signature)\n+    {\n+        return signature.getTypeVariableConstraints().isEmpty()\n+                && signature.getArgumentTypes().stream().noneMatch(TypeSignature::isCalculated)\n+                && !signature.getReturnType().isCalculated();\n     }\n \n-    private static AggregationHeader parseHeader(AnnotatedElement aggregationDefinition)\n+    private static AggregationHeader parseHeader(AnnotatedElement aggregationDefinition, AnnotatedElement toParse)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzMzYxODUy", "url": "https://github.com/trinodb/trino/pull/6042#pullrequestreview-543361852", "createdAt": "2020-12-03T01:03:23Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMTowMzoyM1rOH90rcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMTowNDozNVrOH90tUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU4ODI3NA==", "bodyText": "Typo in commit message \"aggergation\" => \"aggregation\"", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r534588274", "createdAt": "2020-12-03T01:03:23Z", "author": {"login": "erichwang"}, "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AbstractMinMaxAggregationFunction.java", "diffHunk": "@@ -26,9 +26,12 @@\n import io.prestosql.operator.aggregation.AggregationMetadata.AccumulatorStateDescriptor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU4ODUzNQ==", "bodyText": "Typo in commit message \"aggergation\" => \"aggregation\"", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r534588535", "createdAt": "2020-12-03T01:04:05Z", "author": {"login": "erichwang"}, "path": "presto-main/src/main/java/io/prestosql/metadata/FunctionListBuilder.java", "diffHunk": "@@ -33,12 +33,6 @@ public FunctionListBuilder window(Class<? extends WindowFunction> clazz)\n         return this;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU4ODc1Mg==", "bodyText": "Commit message type: \"genertic\" => \"generic\"", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r534588752", "createdAt": "2020-12-03T01:04:35Z", "author": {"login": "erichwang"}, "path": "presto-main/src/main/java/io/prestosql/metadata/AggregationFunctionMetadata.java", "diffHunk": "@@ -13,18 +13,39 @@\n  */", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0Mzk0Nzc5", "url": "https://github.com/trinodb/trino/pull/6042#pullrequestreview-544394779", "createdAt": "2020-12-03T20:28:11Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMDoyODoxMVrOH-wr5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMTo0NzozM1rOH-2FMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU3MTQzMQ==", "bodyText": "@SuppressWarnings(\"unchecked\")", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535571431", "createdAt": "2020-12-03T20:28:11Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/ParametricImplementationsGroup.java", "diffHunk": "@@ -114,6 +118,30 @@ public Signature getSignature()\n         return signature;\n     }\n \n+    public ParametricImplementationsGroup<T> withAlias(String alias)\n+    {\n+        if (alias.equals(signature.getName())) {\n+            return this;\n+        }\n+        return new ParametricImplementationsGroup<T>(\n+                exactImplementations.values().stream()\n+                        .map(implementation -> withAlias(alias, implementation))\n+                        .collect(toImmutableMap(T::getSignature, Function.identity())),\n+                specializedImplementations.stream()\n+                        .map(implementation1 -> withAlias(alias, implementation1))\n+                        .collect(toImmutableList()),\n+                genericImplementations.stream()\n+                        .map(implementation2 -> this.withAlias(alias, implementation2))\n+                        .collect(toImmutableList()),\n+                signatureWithName(alias, signature));\n+    }\n+\n+    private T withAlias(String name, T implementation)\n+    {\n+        //noinspection unchecked", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU4MDUwNA==", "bodyText": "This method can be static.\n(BTW, it's not clear to me why this class has to be generic, but I haven't looked at all the uses)", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535580504", "createdAt": "2020-12-03T20:36:31Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/ParametricImplementationsGroup.java", "diffHunk": "@@ -114,6 +118,30 @@ public Signature getSignature()\n         return signature;\n     }\n \n+    public ParametricImplementationsGroup<T> withAlias(String alias)\n+    {\n+        if (alias.equals(signature.getName())) {\n+            return this;\n+        }\n+        return new ParametricImplementationsGroup<T>(\n+                exactImplementations.values().stream()\n+                        .map(implementation -> withAlias(alias, implementation))\n+                        .collect(toImmutableMap(T::getSignature, Function.identity())),\n+                specializedImplementations.stream()\n+                        .map(implementation1 -> withAlias(alias, implementation1))\n+                        .collect(toImmutableList()),\n+                genericImplementations.stream()\n+                        .map(implementation2 -> this.withAlias(alias, implementation2))\n+                        .collect(toImmutableList()),\n+                signatureWithName(alias, signature));\n+    }\n+\n+    private T withAlias(String name, T implementation)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU4MDg1Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    .map(implementation1 -> withAlias(alias, implementation1))\n          \n          \n            \n                                    .map(implementation -> withAlias(alias, implementation))", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535580852", "createdAt": "2020-12-03T20:36:48Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/ParametricImplementationsGroup.java", "diffHunk": "@@ -114,6 +118,30 @@ public Signature getSignature()\n         return signature;\n     }\n \n+    public ParametricImplementationsGroup<T> withAlias(String alias)\n+    {\n+        if (alias.equals(signature.getName())) {\n+            return this;\n+        }\n+        return new ParametricImplementationsGroup<T>(\n+                exactImplementations.values().stream()\n+                        .map(implementation -> withAlias(alias, implementation))\n+                        .collect(toImmutableMap(T::getSignature, Function.identity())),\n+                specializedImplementations.stream()\n+                        .map(implementation1 -> withAlias(alias, implementation1))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU4MTQ4OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    .map(implementation2 -> this.withAlias(alias, implementation2))\n          \n          \n            \n                                    .map(implementation -> withAlias(alias, implementation))", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535581489", "createdAt": "2020-12-03T20:37:19Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/ParametricImplementationsGroup.java", "diffHunk": "@@ -114,6 +118,30 @@ public Signature getSignature()\n         return signature;\n     }\n \n+    public ParametricImplementationsGroup<T> withAlias(String alias)\n+    {\n+        if (alias.equals(signature.getName())) {\n+            return this;\n+        }\n+        return new ParametricImplementationsGroup<T>(\n+                exactImplementations.values().stream()\n+                        .map(implementation -> withAlias(alias, implementation))\n+                        .collect(toImmutableMap(T::getSignature, Function.identity())),\n+                specializedImplementations.stream()\n+                        .map(implementation1 -> withAlias(alias, implementation1))\n+                        .collect(toImmutableList()),\n+                genericImplementations.stream()\n+                        .map(implementation2 -> this.withAlias(alias, implementation2))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY0Njk4NQ==", "bodyText": "I'm not sure I understand what notion this method is trying to capture (and hence, whether isExact is a good name for it)", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535646985", "createdAt": "2020-12-03T21:35:02Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AggregationFromAnnotationsParser.java", "diffHunk": "@@ -70,89 +70,104 @@ public static ParametricAggregation parseFunctionDefinitionWithTypesConstraint(C\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        ImmutableList.Builder<ParametricAggregation> builder = ImmutableList.builder();\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n-                for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                    Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                    for (AggregationHeader header : parseHeaders(aggregationDefinition, outputFunction)) {\n-                        AggregationImplementation onlyImplementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                        ParametricImplementationsGroup<AggregationImplementation> implementations = ParametricImplementationsGroup.of(onlyImplementation);\n-                        builder.add(new ParametricAggregation(implementations.getSignature(), header, implementations, deprecated));\n-                    }\n+\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        Class<?> stateClass = getStateClass(aggregationDefinition);\n+        Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n+        for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n+            AggregationHeader header = parseHeader(aggregationDefinition, outputFunction);\n+\n+            List<AggregationImplementation> exactImplementations = new ArrayList<>();\n+            List<AggregationImplementation> nonExactImplementations = new ArrayList<>();\n+            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n+                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n+                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header.getName(), inputFunction, removeInputFunction, outputFunction, combineFunction);\n+                if (isExact(implementation.getSignature())) {\n+                    exactImplementations.add(implementation);\n+                }\n+                else {\n+                    nonExactImplementations.add(implementation);\n                 }\n             }\n+\n+            functions.addAll(buildFunctions(header.getName(), header, stateClass, exactImplementations, nonExactImplementations));\n+            for (String alias : getAliases(aggregationDefinition.getAnnotation(AggregationFunction.class), outputFunction)) {\n+                functions.addAll(buildFunctions(alias, header, stateClass, exactImplementations, nonExactImplementations));\n+            }\n         }\n \n-        return builder.build();\n+        return functions.build();\n     }\n \n-    public static ParametricAggregation parseFunctionDefinition(Class<?> aggregationDefinition)\n+    private static List<ParametricAggregation> buildFunctions(\n+            String name,\n+            AggregationHeader header,\n+            Class<?> stateClass,\n+            List<AggregationImplementation> exactImplementations,\n+            List<AggregationImplementation> nonExactImplementations)\n     {\n-        ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n-        AggregationHeader header = parseHeader(aggregationDefinition);\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            Method outputFunction = getOnlyElement(getOutputFunctions(aggregationDefinition, stateClass));\n-            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                implementationsBuilder.addImplementation(implementation);\n-            }\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // create a separate function for each exact implementation\n+        for (AggregationImplementation exactImplementation : exactImplementations) {\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, exactImplementation.getSignature()),\n+                    header,\n+                    stateClass,\n+                    ParametricImplementationsGroup.of(exactImplementation).withAlias(name)));\n         }\n+        // if there are non-exact functions, create a generic function\n+        if (!nonExactImplementations.isEmpty()) {\n+            ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n+            nonExactImplementations.forEach(implementationsBuilder::addImplementation);\n+            ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, implementations.getSignature()),\n+                    header,\n+                    stateClass,\n+                    implementations.withAlias(name)));\n+        }\n+        return functions.build();\n+    }\n \n-        ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n-        return new ParametricAggregation(implementations.getSignature(), header, implementations, deprecated);\n+    private static boolean isExact(Signature signature)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1NDE4NA==", "bodyText": "Should we get rid of these classes? There shouldn't be any reason to keep them around now that there's a replacement, no?", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535654184", "createdAt": "2020-12-03T21:42:20Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AbstractMinMaxAggregationFunction.java", "diffHunk": "@@ -26,9 +26,12 @@\n import io.prestosql.operator.aggregation.AggregationMetadata.AccumulatorStateDescriptor;\n import io.prestosql.operator.aggregation.state.BlockPositionState;\n import io.prestosql.operator.aggregation.state.BlockPositionStateSerializer;\n-import io.prestosql.operator.aggregation.state.NullableBooleanState;\n-import io.prestosql.operator.aggregation.state.NullableDoubleState;\n-import io.prestosql.operator.aggregation.state.NullableLongState;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1NzAyNw==", "bodyText": "How can an aggregation not have an intermediate type?", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535657027", "createdAt": "2020-12-03T21:45:13Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/AggregationFunctionMetadata.java", "diffHunk": "@@ -13,18 +13,39 @@\n  */\n package io.prestosql.metadata;\n \n+import io.prestosql.spi.type.StandardTypes;\n import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.TypeSignatureParameter;\n \n+import java.util.Arrays;\n import java.util.Optional;\n \n import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static java.util.Objects.requireNonNull;\n \n public class AggregationFunctionMetadata\n {\n     private final boolean orderSensitive;\n     private final Optional<TypeSignature> intermediateType;\n \n+    public AggregationFunctionMetadata(boolean orderSensitive, TypeSignature... intermediateTypes)\n+    {\n+        this.orderSensitive = orderSensitive;\n+\n+        if (intermediateTypes.length == 0) {\n+            intermediateType = Optional.empty();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1OTgyNw==", "bodyText": "I think it'd be cleaner, more explicit, and symmetric (what gets passed here would match what gets returned by getIntermediateType() below) to take a single type here and make the caller build a row type if necessary. That could be done with a helper function on the caller side.", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535659827", "createdAt": "2020-12-03T21:47:33Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/AggregationFunctionMetadata.java", "diffHunk": "@@ -13,18 +13,39 @@\n  */\n package io.prestosql.metadata;\n \n+import io.prestosql.spi.type.StandardTypes;\n import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.TypeSignatureParameter;\n \n+import java.util.Arrays;\n import java.util.Optional;\n \n import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static java.util.Objects.requireNonNull;\n \n public class AggregationFunctionMetadata\n {\n     private final boolean orderSensitive;\n     private final Optional<TypeSignature> intermediateType;\n \n+    public AggregationFunctionMetadata(boolean orderSensitive, TypeSignature... intermediateTypes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "532ff583e780db131b7771c705e613757ec3f0cd", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/532ff583e780db131b7771c705e613757ec3f0cd", "committedDate": "2021-09-06T19:46:03Z", "message": "Require aggregation metadata at construction\n\nRequire full aggregation function metadata during construction of aggregation.\nChange intermediate types to allow generic type signatures."}}, {"__typename": "PullRequestReview", "id": "PRR_kwDOCezRTs4tzfn3", "url": "https://github.com/trinodb/trino/pull/6042#pullrequestreview-768473591", "createdAt": "2021-10-01T00:29:31Z", "commit": {"oid": "8317c1c369ef96fce3ed80347f87aba5a8f08b9d"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0xMC0wMVQwMDoyOTozMVrOKugxow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0xMC0wMVQwMDozMTo0MFrOKug0LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "PRRC_kwDOCezRTs4q6DGj", "bodyText": "This needs a better name. If you can you describe what concept this represents I can help come up with another name.", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r719860131", "createdAt": "2021-10-01T00:29:31Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/operator/aggregation/AggregationFromAnnotationsParser.java", "diffHunk": "@@ -72,101 +70,112 @@ public static ParametricAggregation parseFunctionDefinitionWithTypesConstraint(C\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        ImmutableList.Builder<ParametricAggregation> builder = ImmutableList.builder();\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n-                for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                    Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                    for (AggregationHeader header : parseHeaders(aggregationDefinition, outputFunction)) {\n-                        AggregationImplementation onlyImplementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                        ParametricImplementationsGroup<AggregationImplementation> implementations = ParametricImplementationsGroup.of(onlyImplementation);\n-                        builder.add(new ParametricAggregation(signatureWithName(header.getName(), implementations.getSignature()), header, implementations, deprecated));\n-                    }\n+\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // There must be a single state class and combine function\n+        Class<?> stateClass = getStateClass(aggregationDefinition);\n+        Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n+\n+        // Each output function defines a new aggregation function\n+        for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n+            AggregationHeader header = parseHeader(aggregationDefinition, outputFunction);\n+\n+            // Input functions can have either an exact signature, or generic/calculate signature\n+            List<AggregationImplementation> exactImplementations = new ArrayList<>();\n+            List<AggregationImplementation> nonExactImplementations = new ArrayList<>();\n+            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n+                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n+                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header.getName(), inputFunction, removeInputFunction, outputFunction, combineFunction);\n+                if (isExact(implementation.getSignature())) {\n+                    exactImplementations.add(implementation);\n+                }\n+                else {\n+                    nonExactImplementations.add(implementation);\n                 }\n             }\n+\n+            // register a set functions for the canonical name, and each alias\n+            functions.addAll(buildFunctions(header.getName(), header, stateClass, exactImplementations, nonExactImplementations));\n+            for (String alias : getAliases(aggregationDefinition.getAnnotation(AggregationFunction.class), outputFunction)) {\n+                functions.addAll(buildFunctions(alias, header, stateClass, exactImplementations, nonExactImplementations));\n+            }\n         }\n \n-        return builder.build();\n+        return functions.build();\n     }\n \n-    public static ParametricAggregation parseFunctionDefinition(Class<?> aggregationDefinition)\n+    private static List<ParametricAggregation> buildFunctions(\n+            String name,\n+            AggregationHeader header,\n+            Class<?> stateClass,\n+            List<AggregationImplementation> exactImplementations,\n+            List<AggregationImplementation> nonExactImplementations)\n     {\n-        ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n-        AggregationHeader header = parseHeader(aggregationDefinition);\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // create a separate function for each exact implementation\n+        for (AggregationImplementation exactImplementation : exactImplementations) {\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, exactImplementation.getSignature()),\n+                    header,\n+                    stateClass,\n+                    ParametricImplementationsGroup.of(exactImplementation).withAlias(name)));\n+        }\n \n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            Method outputFunction = getOnlyElement(getOutputFunctions(aggregationDefinition, stateClass));\n-            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                implementationsBuilder.addImplementation(implementation);\n-            }\n+        // if there are non-exact functions, create a single generic/calculated function using these implementations\n+        if (!nonExactImplementations.isEmpty()) {\n+            ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n+            nonExactImplementations.forEach(implementationsBuilder::addImplementation);\n+            ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, implementations.getSignature()),\n+                    header,\n+                    stateClass,\n+                    implementations.withAlias(name)));\n         }\n \n-        ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n-        return new ParametricAggregation(signatureWithName(header.getName(), implementations.getSignature()), header, implementations, deprecated);\n+        return functions.build();\n+    }\n+\n+    private static boolean isExact(Signature signature)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8317c1c369ef96fce3ed80347f87aba5a8f08b9d"}, "originalPosition": 121}, {"id": "PRRC_kwDOCezRTs4q6DQs", "bodyText": "Move arguments to the same line", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r719860780", "createdAt": "2021-10-01T00:31:40Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/operator/aggregation/AggregationFromAnnotationsParser.java", "diffHunk": "@@ -72,101 +70,112 @@ public static ParametricAggregation parseFunctionDefinitionWithTypesConstraint(C\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        ImmutableList.Builder<ParametricAggregation> builder = ImmutableList.builder();\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n-                for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                    Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                    for (AggregationHeader header : parseHeaders(aggregationDefinition, outputFunction)) {\n-                        AggregationImplementation onlyImplementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                        ParametricImplementationsGroup<AggregationImplementation> implementations = ParametricImplementationsGroup.of(onlyImplementation);\n-                        builder.add(new ParametricAggregation(signatureWithName(header.getName(), implementations.getSignature()), header, implementations, deprecated));\n-                    }\n+\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // There must be a single state class and combine function\n+        Class<?> stateClass = getStateClass(aggregationDefinition);\n+        Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n+\n+        // Each output function defines a new aggregation function\n+        for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n+            AggregationHeader header = parseHeader(aggregationDefinition, outputFunction);\n+\n+            // Input functions can have either an exact signature, or generic/calculate signature\n+            List<AggregationImplementation> exactImplementations = new ArrayList<>();\n+            List<AggregationImplementation> nonExactImplementations = new ArrayList<>();\n+            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n+                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n+                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header.getName(), inputFunction, removeInputFunction, outputFunction, combineFunction);\n+                if (isExact(implementation.getSignature())) {\n+                    exactImplementations.add(implementation);\n+                }\n+                else {\n+                    nonExactImplementations.add(implementation);\n                 }\n             }\n+\n+            // register a set functions for the canonical name, and each alias\n+            functions.addAll(buildFunctions(header.getName(), header, stateClass, exactImplementations, nonExactImplementations));\n+            for (String alias : getAliases(aggregationDefinition.getAnnotation(AggregationFunction.class), outputFunction)) {\n+                functions.addAll(buildFunctions(alias, header, stateClass, exactImplementations, nonExactImplementations));\n+            }\n         }\n \n-        return builder.build();\n+        return functions.build();\n     }\n \n-    public static ParametricAggregation parseFunctionDefinition(Class<?> aggregationDefinition)\n+    private static List<ParametricAggregation> buildFunctions(\n+            String name,\n+            AggregationHeader header,\n+            Class<?> stateClass,\n+            List<AggregationImplementation> exactImplementations,\n+            List<AggregationImplementation> nonExactImplementations)\n     {\n-        ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n-        AggregationHeader header = parseHeader(aggregationDefinition);\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // create a separate function for each exact implementation\n+        for (AggregationImplementation exactImplementation : exactImplementations) {\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, exactImplementation.getSignature()),\n+                    header,\n+                    stateClass,\n+                    ParametricImplementationsGroup.of(exactImplementation).withAlias(name)));\n+        }\n \n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            Method outputFunction = getOnlyElement(getOutputFunctions(aggregationDefinition, stateClass));\n-            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                implementationsBuilder.addImplementation(implementation);\n-            }\n+        // if there are non-exact functions, create a single generic/calculated function using these implementations\n+        if (!nonExactImplementations.isEmpty()) {\n+            ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n+            nonExactImplementations.forEach(implementationsBuilder::addImplementation);\n+            ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, implementations.getSignature()),\n+                    header,\n+                    stateClass,\n+                    implementations.withAlias(name)));\n         }\n \n-        ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n-        return new ParametricAggregation(signatureWithName(header.getName(), implementations.getSignature()), header, implementations, deprecated);\n+        return functions.build();\n+    }\n+\n+    private static boolean isExact(Signature signature)\n+    {\n+        return signature.getTypeVariableConstraints().isEmpty()\n+                && signature.getArgumentTypes().stream().noneMatch(TypeSignature::isCalculated)\n+                && !signature.getReturnType().isCalculated();\n     }\n \n-    private static AggregationHeader parseHeader(AnnotatedElement aggregationDefinition)\n+    private static AggregationHeader parseHeader(AnnotatedElement aggregationDefinition, AnnotatedElement outputFunction)\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n+        String name = getName(aggregationAnnotation, outputFunction);\n         return new AggregationHeader(\n-                aggregationAnnotation.value(),\n-                aggregationAnnotation.value(),\n-                parseDescription(aggregationDefinition),\n+                name,\n+                parseDescription(aggregationDefinition, outputFunction),\n                 aggregationAnnotation.decomposable(),\n                 aggregationAnnotation.isOrderSensitive(),\n-                aggregationAnnotation.hidden());\n+                aggregationAnnotation.hidden(),\n+                aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0);\n     }\n \n-    private static List<AggregationHeader> parseHeaders(AnnotatedElement aggregationDefinition, AnnotatedElement toParse)\n+    private static String getName(AggregationFunction aggregationAnnotation, AnnotatedElement outputFunction)\n     {\n-        AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n-\n-        return getNames(toParse, aggregationAnnotation).stream()\n-                .map(aggregationFunctionName ->\n-                        new AggregationHeader(\n-                                aggregationFunctionName.getActualName(),\n-                                aggregationFunctionName.getCanonicalName(),\n-                                parseDescription(aggregationDefinition, toParse),\n-                                aggregationAnnotation.decomposable(),\n-                                aggregationAnnotation.isOrderSensitive(),\n-                                aggregationAnnotation.hidden()))\n-                .collect(toImmutableList());\n+        AggregationFunction annotation = outputFunction.getAnnotation(AggregationFunction.class);\n+        if (annotation != null && !annotation.value().isEmpty()) {\n+            return emptyToNull(annotation.value());\n+        }\n+        return emptyToNull(aggregationAnnotation.value());\n     }\n \n-    private static List<AggregationFunctionName> getNames(@Nullable AnnotatedElement outputFunction, AggregationFunction aggregationAnnotation)\n+    private static List<String> getAliases(AggregationFunction aggregationAnnotation,\n+            AnnotatedElement outputFunction)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8317c1c369ef96fce3ed80347f87aba5a8f08b9d"}, "originalPosition": 171}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "532ff583e780db131b7771c705e613757ec3f0cd", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/532ff583e780db131b7771c705e613757ec3f0cd", "committedDate": "2021-09-06T19:46:03Z", "message": "Require aggregation metadata at construction\n\nRequire full aggregation function metadata during construction of aggregation.\nChange intermediate types to allow generic type signatures."}, "afterCommit": {"oid": "250227ffda48a4ba1eedc7c2c83daa163bbc9607", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/250227ffda48a4ba1eedc7c2c83daa163bbc9607", "committedDate": "2021-10-09T03:50:55Z", "message": "Require aggregation metadata at construction\n\nRequire full aggregation function metadata during construction of aggregation.\nChange intermediate types to allow generic type signatures."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "250227ffda48a4ba1eedc7c2c83daa163bbc9607", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/250227ffda48a4ba1eedc7c2c83daa163bbc9607", "committedDate": "2021-10-09T03:50:55Z", "message": "Require aggregation metadata at construction\n\nRequire full aggregation function metadata during construction of aggregation.\nChange intermediate types to allow generic type signatures."}, "afterCommit": {"oid": "b87377002fbb1a6b8061def4da4de34b37b140a7", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/b87377002fbb1a6b8061def4da4de34b37b140a7", "committedDate": "2021-10-09T05:36:04Z", "message": "Require aggregation metadata at construction\n\nRequire full aggregation function metadata during construction of aggregation.\nChange intermediate types to allow generic type signatures."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e02559f6a43715557b15e643cc5f11c5b1bb91c", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/6e02559f6a43715557b15e643cc5f11c5b1bb91c", "committedDate": "2021-10-09T05:38:42Z", "message": "Change FunctionMetadata signature to be the actual caller signature\n\nRemove actual name field since signature carries actual name\nAdd canonical name field so push down can use canonical name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "770d3fe1bc83a346775ef180287ba4fbace925c0", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/770d3fe1bc83a346775ef180287ba4fbace925c0", "committedDate": "2021-10-09T05:38:42Z", "message": "Move boolean approx_distinct to separate class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db0c4be1912a140e8311dd3020c16de886aceff4", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/db0c4be1912a140e8311dd3020c16de886aceff4", "committedDate": "2021-10-09T05:38:42Z", "message": "Move legacy approx_percentile to separate classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c1ea5696b20f1d76494f4308b5e01d7fba09b2e", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/5c1ea5696b20f1d76494f4308b5e01d7fba09b2e", "committedDate": "2021-10-09T05:38:42Z", "message": "Simplify parametric aggregation\n\nConsolidate the two annotation processing strategy into a single strategy\nSimplify handling of function aliases\nMove deprecated flag to AggregationHeader"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6f8536601cb1e55a30fce8a4cf2e6c4137ad13e", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/c6f8536601cb1e55a30fce8a4cf2e6c4137ad13e", "committedDate": "2021-10-09T05:38:42Z", "message": "Add generic aggregation state holders\n\nGeneric state holders can use an explicit type as opposed to only\nBIGINT, DOUBLE, and BOOLEAN"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7818e667cdf132092d473ac32f03dab625ce6d7", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/e7818e667cdf132092d473ac32f03dab625ce6d7", "committedDate": "2021-10-09T05:54:21Z", "message": "Require aggregation metadata at construction\n\nRequire full aggregation function metadata during construction of aggregation.\nChange intermediate types to allow generic type signatures."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b87377002fbb1a6b8061def4da4de34b37b140a7", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/b87377002fbb1a6b8061def4da4de34b37b140a7", "committedDate": "2021-10-09T05:36:04Z", "message": "Require aggregation metadata at construction\n\nRequire full aggregation function metadata during construction of aggregation.\nChange intermediate types to allow generic type signatures."}, "afterCommit": {"oid": "e7818e667cdf132092d473ac32f03dab625ce6d7", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/e7818e667cdf132092d473ac32f03dab625ce6d7", "committedDate": "2021-10-09T05:54:21Z", "message": "Require aggregation metadata at construction\n\nRequire full aggregation function metadata during construction of aggregation.\nChange intermediate types to allow generic type signatures."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2224, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}