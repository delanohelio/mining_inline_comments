{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3OTUyNTY5", "number": 2891, "title": "Add support for row filtering and column masking", "bodyText": "Fixes #1480", "createdAt": "2020-02-20T20:14:56Z", "url": "https://github.com/trinodb/trino/pull/2891", "merged": true, "mergeCommit": {"oid": "7e0d88e6906cb91387d707f8daf9dc46095ad0bf"}, "closed": true, "closedAt": "2020-02-25T16:43:55Z", "author": {"login": "martint"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcGR-lDABqjMwNTgyODQyNDM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcHxMRJAFqTM2NDA5ODkwMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNDY1MTE2", "url": "https://github.com/trinodb/trino/pull/2891#pullrequestreview-362465116", "createdAt": "2020-02-21T08:29:15Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwODoyOToxNVrOFsvCpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwOToyMDowNFrOFswYOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ1MjM4OA==", "bodyText": "rnn, because you don't support null values in equals method", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382452388", "createdAt": "2020-02-21T08:29:15Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java", "diffHunk": "@@ -895,4 +927,36 @@ public String toString()\n             return format(\"AccessControl: %s, Identity: %s\", accessControl.getClass(), identity);\n         }\n     }\n+\n+    private static class RowFilterScopeEntry\n+    {\n+        private final QualifiedObjectName table;\n+        private final String identity;\n+\n+        public RowFilterScopeEntry(QualifiedObjectName table, String identity)\n+        {\n+            this.table = table;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ1NDgyMg==", "bodyText": "these 3 variables are not used in this commit (row filter support)", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382454822", "createdAt": "2020-02-21T08:35:48Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -479,6 +484,18 @@ protected Scope visitDelete(Delete node, Optional<Scope> scope)\n \n             accessControl.checkCanDeleteFromTable(session.toSecurityContext(), tableName);\n \n+            if (!accessControl.getRowFilters(session.toSecurityContext(), tableName).isEmpty()) {\n+                throw semanticException(NOT_SUPPORTED, node, \"Delete from table with row filter\");\n+            }\n+\n+            TableHandle handle = metadata.getTableHandle(session, tableName)\n+                    .orElseThrow(() -> new TableNotFoundException(tableName.asSchemaTableName()));\n+\n+            TableMetadata tableMetadata = metadata.getTableMetadata(session, handle);\n+            List<String> columns = tableMetadata.getColumns().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ1NjA4OA==", "bodyText": "do you have a test where row filter tries to access symbols that are within query, but shouldn't be visible row filter (because they are not table output symbols)?", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382456088", "createdAt": "2020-02-21T08:38:53Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -991,9 +1008,15 @@ protected Scope visitTable(Table table, Optional<Scope> scope)\n                 analysis.setColumn(field, columnHandle);\n             }\n \n+            List<Field> outputFields = fields.build();\n+            Scope accessControlScope = createAndAssignScope(table, Optional.empty(), outputFields);\n+\n+            accessControl.getRowFilters(session.toSecurityContext(), name)\n+                    .forEach(filter -> analyzeRowFilter(session.getIdentity().getUser(), table, name, accessControlScope, filter));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ1NjgzOA==", "bodyText": "Do you have a test where row filters are applied to tables used within the table defined with WITH?", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382456838", "createdAt": "2020-02-21T08:40:54Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1083,6 +1106,11 @@ private Scope createScopeForView(Table table, QualifiedObjectName name, Optional\n \n             analysis.addRelationCoercion(table, outputFields.stream().map(Field::getType).toArray(Type[]::new));\n \n+            Scope accessControlScope = createAndAssignScope(table, Optional.empty(), outputFields);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ1OTM0Mg==", "bodyText": "Can you please add a test where RowFilterScopeEntry#identity matters. Like there would be 2 level recursive row filter but each row filter would be applied for different identity.", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382459342", "createdAt": "2020-02-21T08:46:41Z", "author": {"login": "kokosing"}, "path": "presto-main/src/test/java/io/prestosql/sql/query/TestRowFilter.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.query;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.plugin.tpch.TpchConnectorFactory;\n+import io.prestosql.spi.security.Identity;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.testing.LocalQueryRunner;\n+import io.prestosql.testing.TestingAccessControlManager;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.tpch.TpchMetadata.TINY_SCHEMA_NAME;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestRowFilter", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ1OTkyMg==", "bodyText": "maybe extract the below block as method, so you don't have uninitialized variable.", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382459922", "createdAt": "2020-02-21T08:48:08Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -2357,6 +2371,58 @@ private ExpressionAnalysis analyzeExpression(Expression expression, Scope scope)\n                     warningCollector);\n         }\n \n+        private void analyzeRowFilter(String currentIdentity, Table table, QualifiedObjectName name, Scope scope, ViewExpression filter)\n+        {\n+            if (analysis.hasRowFilter(name, currentIdentity)) {\n+                throw new PrestoException(INVALID_ROW_FILTER, extractLocation(table), format(\"Row filter for '%s' is recursive\", name), null);\n+            }\n+\n+            Expression expression;\n+            try {\n+                expression = sqlParser.createExpression(filter.getExpression(), createParsingOptions(session));\n+            }\n+            catch (ParsingException e) {\n+                throw new PrestoException(INVALID_ROW_FILTER, extractLocation(table), format(\"Invalid row filter for '%s': %s\", name, e.getErrorMessage()), e);\n+            }\n+\n+            ExpressionAnalysis expressionAnalysis;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2MDI0Mg==", "bodyText": "can you please add a test for this?", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382460242", "createdAt": "2020-02-21T08:48:56Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -2357,6 +2371,58 @@ private ExpressionAnalysis analyzeExpression(Expression expression, Scope scope)\n                     warningCollector);\n         }\n \n+        private void analyzeRowFilter(String currentIdentity, Table table, QualifiedObjectName name, Scope scope, ViewExpression filter)\n+        {\n+            if (analysis.hasRowFilter(name, currentIdentity)) {\n+                throw new PrestoException(INVALID_ROW_FILTER, extractLocation(table), format(\"Row filter for '%s' is recursive\", name), null);\n+            }\n+\n+            Expression expression;\n+            try {\n+                expression = sqlParser.createExpression(filter.getExpression(), createParsingOptions(session));\n+            }\n+            catch (ParsingException e) {\n+                throw new PrestoException(INVALID_ROW_FILTER, extractLocation(table), format(\"Invalid row filter for '%s': %s\", name, e.getErrorMessage()), e);\n+            }\n+\n+            ExpressionAnalysis expressionAnalysis;\n+            analysis.registerTableForRowFiltering(name, currentIdentity);\n+            try {\n+                expressionAnalysis = ExpressionAnalyzer.analyzeExpression(\n+                        createViewSession(filter.getCatalog(), filter.getSchema(), Identity.forUser(filter.getIdentity()).build(), session.getPath()), // TODO: path should be included in row filter\n+                        metadata,\n+                        accessControl,\n+                        sqlParser,\n+                        scope,\n+                        analysis,\n+                        expression,\n+                        warningCollector);\n+            }\n+            catch (PrestoException e) {\n+                throw new PrestoException(e::getErrorCode, extractLocation(table), format(\"Invalid row filter for '%s': %s\", name, e.getRawMessage()), e);\n+            }\n+            finally {\n+                analysis.unregisterTableForRowFiltering(name, currentIdentity);\n+            }\n+\n+            verifyNoAggregateWindowOrGroupingFunctions(metadata, expression, format(\"Row filter for '%s'\", name));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2MTE2MQ==", "bodyText": "rnn", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382461161", "createdAt": "2020-02-21T08:51:16Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/testing/TestingAccessControlManager.java", "diffHunk": "@@ -443,4 +463,36 @@ public String toString()\n                     .toString();\n         }\n     }\n+\n+    private static class RowFilterKey\n+    {\n+        private final String identity;\n+        private final QualifiedObjectName table;\n+\n+        public RowFilterKey(String identity, QualifiedObjectName table)\n+        {\n+            this.identity = identity;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2MTk5NA==", "bodyText": "move this constructor down as last constructor", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382461994", "createdAt": "2020-02-21T08:53:11Z", "author": {"login": "kokosing"}, "path": "presto-main/src/test/java/io/prestosql/sql/query/QueryAssertions.java", "diffHunk": "@@ -42,6 +43,11 @@\n {\n     private final QueryRunner runner;\n \n+    public QueryAssertions(QueryRunner runner)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2MzcwNQ==", "bodyText": "it would be nice to pass session here, so it would be obvious from reading the test which row filter is going to be applied", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382463705", "createdAt": "2020-02-21T08:57:04Z", "author": {"login": "kokosing"}, "path": "presto-main/src/test/java/io/prestosql/sql/query/TestRowFilter.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.query;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.plugin.tpch.TpchConnectorFactory;\n+import io.prestosql.spi.security.Identity;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.testing.LocalQueryRunner;\n+import io.prestosql.testing.TestingAccessControlManager;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.tpch.TpchMetadata.TINY_SCHEMA_NAME;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestRowFilter\n+{\n+    private static final String CATALOG = \"local\";\n+    private static final String USER = \"user\";\n+    private static final String RUN_AS_USER = \"run-as-user\";\n+\n+    private QueryAssertions assertions;\n+    private TestingAccessControlManager accessControl;\n+\n+    @BeforeClass\n+    public void init()\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(CATALOG)\n+                .setSchema(TINY_SCHEMA_NAME)\n+                .setIdentity(Identity.forUser(USER).build())\n+                .build();\n+\n+        LocalQueryRunner runner = LocalQueryRunner.builder(session)\n+                .build();\n+\n+        runner.createCatalog(CATALOG, new TpchConnectorFactory(1), ImmutableMap.of());\n+\n+        assertions = new QueryAssertions(runner);\n+        accessControl = assertions.getQueryRunner().getAccessControl();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void teardown()\n+    {\n+        assertions.close();\n+        assertions = null;\n+    }\n+\n+    @Test\n+    public void testSimpleFilter()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.empty(), Optional.empty(), \"orderkey < 10\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '7'\");\n+        });\n+\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.empty(), Optional.empty(), \"NULL\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '0'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testCorrelatedSubquery()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"EXISTS (SELECT 1 FROM nation WHERE nationkey = orderkey)\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '7'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testRecursion()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey IN (SELECT orderkey FROM orders)\"));\n+\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \".*\\\\QRow filter for 'local.tiny.orders' is recursive\\\\E.*\");\n+        });\n+\n+        // different reference style to same table\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey IN (SELECT local.tiny.orderkey FROM orders)\"));\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \".*\\\\QRow filter for 'local.tiny.orders' is recursive\\\\E.*\");\n+        });\n+    }\n+\n+    @Test\n+    public void testOtherSchema()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"sf1\"), \"(SELECT count(*) FROM customer) = 150000\")); // Filter is TRUE only if evaluating against sf1.customer\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '15000'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testDifferentIdentity()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    RUN_AS_USER,\n+                    new ViewExpression(RUN_AS_USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey = 1\"));\n+\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(RUN_AS_USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey IN (SELECT orderkey FROM orders)\"));\n+\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '1'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NDY5OQ==", "bodyText": "Consider a test case like:\n     // subquery \"sql-injection\"\n        assertRowFiltering(\n                \"WITH region(regionkey, name) AS (VALUES (0, 'ASIA'), (1, 'ASIA'), (2, 'ASIA'), (3, 'ASIA'), (4, 'ASIA'))\" +\n                        \"SELECT name FROM nation ORDER BY name LIMIT 1\",\n                \"SELECT 'CHINA'\", // if sql-injection would work then query would return ALGERIA\n                rowFilter(\"nation\", \"regionkey IN (SELECT regionkey FROM region WHERE name = 'ASIA')\", getSession().getUser()));", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382464699", "createdAt": "2020-02-21T08:59:06Z", "author": {"login": "kokosing"}, "path": "presto-main/src/test/java/io/prestosql/sql/query/TestRowFilter.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.query;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.plugin.tpch.TpchConnectorFactory;\n+import io.prestosql.spi.security.Identity;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.testing.LocalQueryRunner;\n+import io.prestosql.testing.TestingAccessControlManager;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.tpch.TpchMetadata.TINY_SCHEMA_NAME;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestRowFilter\n+{\n+    private static final String CATALOG = \"local\";\n+    private static final String USER = \"user\";\n+    private static final String RUN_AS_USER = \"run-as-user\";\n+\n+    private QueryAssertions assertions;\n+    private TestingAccessControlManager accessControl;\n+\n+    @BeforeClass\n+    public void init()\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(CATALOG)\n+                .setSchema(TINY_SCHEMA_NAME)\n+                .setIdentity(Identity.forUser(USER).build())\n+                .build();\n+\n+        LocalQueryRunner runner = LocalQueryRunner.builder(session)\n+                .build();\n+\n+        runner.createCatalog(CATALOG, new TpchConnectorFactory(1), ImmutableMap.of());\n+\n+        assertions = new QueryAssertions(runner);\n+        accessControl = assertions.getQueryRunner().getAccessControl();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void teardown()\n+    {\n+        assertions.close();\n+        assertions = null;\n+    }\n+\n+    @Test\n+    public void testSimpleFilter()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.empty(), Optional.empty(), \"orderkey < 10\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '7'\");\n+        });\n+\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.empty(), Optional.empty(), \"NULL\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '0'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testCorrelatedSubquery()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"EXISTS (SELECT 1 FROM nation WHERE nationkey = orderkey)\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '7'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testRecursion()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey IN (SELECT orderkey FROM orders)\"));\n+\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \".*\\\\QRow filter for 'local.tiny.orders' is recursive\\\\E.*\");\n+        });\n+\n+        // different reference style to same table\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey IN (SELECT local.tiny.orderkey FROM orders)\"));\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \".*\\\\QRow filter for 'local.tiny.orders' is recursive\\\\E.*\");\n+        });\n+    }\n+\n+    @Test\n+    public void testOtherSchema()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"sf1\"), \"(SELECT count(*) FROM customer) = 150000\")); // Filter is TRUE only if evaluating against sf1.customer\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '15000'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testDifferentIdentity()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    RUN_AS_USER,\n+                    new ViewExpression(RUN_AS_USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey = 1\"));\n+\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(RUN_AS_USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey IN (SELECT orderkey FROM orders)\"));\n+\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '1'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testInvalidFilter()\n+    {\n+        // parse error\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(RUN_AS_USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"$$$\"));\n+\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \"\\\\Qline 1:22: Invalid row filter for 'local.tiny.orders': mismatched input '$'. Expecting: <expression>\\\\E\");\n+        });\n+\n+        // unknown column\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(RUN_AS_USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"unknown_column\"));\n+\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \"\\\\Qline 1:22: Invalid row filter for 'local.tiny.orders': Column 'unknown_column' cannot be resolved\\\\E\");\n+        });\n+\n+        // invalid type\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(RUN_AS_USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"1\"));\n+\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \"\\\\Qline 1:22: Expected row filter for 'local.tiny.orders' to be of type BOOLEAN, but was integer\\\\E\");\n+        });\n+    }\n+\n+    @Test\n+    public void testMultipleFilters()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.empty(), Optional.empty(), \"orderkey < 10\"));\n+\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.empty(), Optional.empty(), \"orderkey > 5\"));\n+\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '2'\");\n+        });\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NTc2MA==", "bodyText": "As I understand it will use RowFilterKey from TestingAccessControlManager. It would be nice to have a test that would require using different keys in analysis based on identity.", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382465760", "createdAt": "2020-02-21T09:01:23Z", "author": {"login": "kokosing"}, "path": "presto-main/src/test/java/io/prestosql/sql/query/TestRowFilter.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.query;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.plugin.tpch.TpchConnectorFactory;\n+import io.prestosql.spi.security.Identity;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.testing.LocalQueryRunner;\n+import io.prestosql.testing.TestingAccessControlManager;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.tpch.TpchMetadata.TINY_SCHEMA_NAME;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestRowFilter\n+{\n+    private static final String CATALOG = \"local\";\n+    private static final String USER = \"user\";\n+    private static final String RUN_AS_USER = \"run-as-user\";\n+\n+    private QueryAssertions assertions;\n+    private TestingAccessControlManager accessControl;\n+\n+    @BeforeClass\n+    public void init()\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(CATALOG)\n+                .setSchema(TINY_SCHEMA_NAME)\n+                .setIdentity(Identity.forUser(USER).build())\n+                .build();\n+\n+        LocalQueryRunner runner = LocalQueryRunner.builder(session)\n+                .build();\n+\n+        runner.createCatalog(CATALOG, new TpchConnectorFactory(1), ImmutableMap.of());\n+\n+        assertions = new QueryAssertions(runner);\n+        accessControl = assertions.getQueryRunner().getAccessControl();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void teardown()\n+    {\n+        assertions.close();\n+        assertions = null;\n+    }\n+\n+    @Test\n+    public void testSimpleFilter()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.empty(), Optional.empty(), \"orderkey < 10\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '7'\");\n+        });\n+\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.empty(), Optional.empty(), \"NULL\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '0'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testCorrelatedSubquery()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"EXISTS (SELECT 1 FROM nation WHERE nationkey = orderkey)\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '7'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testRecursion()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey IN (SELECT orderkey FROM orders)\"));\n+\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \".*\\\\QRow filter for 'local.tiny.orders' is recursive\\\\E.*\");\n+        });\n+\n+        // different reference style to same table\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey IN (SELECT local.tiny.orderkey FROM orders)\"));\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \".*\\\\QRow filter for 'local.tiny.orders' is recursive\\\\E.*\");\n+        });\n+    }\n+\n+    @Test\n+    public void testOtherSchema()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"sf1\"), \"(SELECT count(*) FROM customer) = 150000\")); // Filter is TRUE only if evaluating against sf1.customer\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '15000'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testDifferentIdentity()\n+    {\n+        assertions.executeExclusively(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NjEwMw==", "bodyText": "s/identity/user\nhere and everywhere else", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382466103", "createdAt": "2020-02-21T09:02:01Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java", "diffHunk": "@@ -663,6 +669,32 @@ public boolean isOrderByRedundant(OrderBy orderBy)\n         return redundantOrderBy.contains(NodeRef.of(orderBy));\n     }\n \n+    public boolean hasRowFilter(QualifiedObjectName table, String identity)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NjYwMg==", "bodyText": "s/identity/user", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382466602", "createdAt": "2020-02-21T09:03:08Z", "author": {"login": "kokosing"}, "path": "presto-spi/src/main/java/io/prestosql/spi/security/ViewExpression.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.security;\n+\n+import java.util.Optional;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class ViewExpression\n+{\n+    private final String identity;\n+    private final Optional<String> catalog;\n+    private final Optional<String> schema;\n+    private final String expression;\n+\n+    public ViewExpression(String identity, Optional<String> catalog, Optional<String> schema, String expression)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NzUwMw==", "bodyText": "I don't think that connector should return catalog. Connector is only aware of catalog name it is using, don't know anything about other catalogs. Do we need ConnectorViewExpression and SystemViewExpression?", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382467503", "createdAt": "2020-02-21T09:05:15Z", "author": {"login": "kokosing"}, "path": "presto-spi/src/main/java/io/prestosql/spi/security/ViewExpression.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.security;\n+\n+import java.util.Optional;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class ViewExpression\n+{\n+    private final String identity;\n+    private final Optional<String> catalog;\n+    private final Optional<String> schema;\n+    private final String expression;\n+\n+    public ViewExpression(String identity, Optional<String> catalog, Optional<String> schema, String expression)\n+    {\n+        this.identity = requireNonNull(identity, \"identity is null\");\n+        this.catalog = requireNonNull(catalog, \"catalog is null\");\n+        this.schema = requireNonNull(schema, \"schema is null\");\n+        this.expression = requireNonNull(expression, \"expression is null\");\n+\n+        if (!catalog.isPresent() && schema.isPresent()) {\n+            throw new IllegalArgumentException(\"catalog must be present if schema is present\");\n+        }\n+    }\n+\n+    public String getIdentity()\n+    {\n+        return identity;\n+    }\n+\n+    public Optional<String> getCatalog()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2OTAyNA==", "bodyText": "if row filters and column masks are using same mechanism during semantic analysis, should we extract common code as some entity?", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382469024", "createdAt": "2020-02-21T09:08:49Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java", "diffHunk": "@@ -139,6 +139,9 @@\n     private final Multiset<RowFilterScopeEntry> rowFilterScopes = HashMultiset.create();\n     private final Map<NodeRef<Table>, List<Expression>> rowFilters = new LinkedHashMap<>();\n \n+    private final Multiset<ColumnMaskScopeEntry> columnMaskScopes = HashMultiset.create();\n+    private final Map<NodeRef<Table>, Map<String, List<Expression>>> columnMasks = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3MDY2Nw==", "bodyText": "rnn", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382470667", "createdAt": "2020-02-21T09:12:27Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java", "diffHunk": "@@ -959,4 +989,39 @@ public int hashCode()\n             return Objects.hash(table, identity);\n         }\n     }\n+\n+    private static class ColumnMaskScopeEntry\n+    {\n+        private final QualifiedObjectName table;\n+        private final String column;\n+        private final String identity;\n+\n+        public ColumnMaskScopeEntry(QualifiedObjectName table, String column, String identity)\n+        {\n+            this.table = table;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3MjU3NQ==", "bodyText": "Shouldn't getColumnMasks() return Multimap?", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382472575", "createdAt": "2020-02-21T09:16:34Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/RelationPlanner.java", "diffHunk": "@@ -192,6 +194,40 @@ private RelationPlan addRowFilters(Table node, RelationPlan plan)\n         return new RelationPlan(planBuilder.getRoot(), plan.getScope(), plan.getFieldMappings());\n     }\n \n+    private RelationPlan addColumnMasks(Table table, RelationPlan plan)\n+    {\n+        Map<String, List<Expression>> columnMasks = analysis.getColumnMasks(table);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3NDI5Nw==", "bodyText": "Add a test where there are two column masks (one connector level and one system level) and where we could notice the order in which they were applied.", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382474297", "createdAt": "2020-02-21T09:20:04Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/RelationPlanner.java", "diffHunk": "@@ -192,6 +194,40 @@ private RelationPlan addRowFilters(Table node, RelationPlan plan)\n         return new RelationPlan(planBuilder.getRoot(), plan.getScope(), plan.getFieldMappings());\n     }\n \n+    private RelationPlan addColumnMasks(Table table, RelationPlan plan)\n+    {\n+        Map<String, List<Expression>> columnMasks = analysis.getColumnMasks(table);\n+\n+        PlanNode root = plan.getRoot();\n+        List<Symbol> mappings = plan.getFieldMappings();\n+\n+        TranslationMap translations = new TranslationMap(plan, analysis, lambdaDeclarationToSymbolMap);\n+        translations.setFieldMappings(mappings);\n+\n+        PlanBuilder planBuilder = new PlanBuilder(translations, root);\n+\n+        for (int i = 0; i < plan.getDescriptor().getAllFieldCount(); i++) {\n+            Field field = plan.getDescriptor().getFieldByIndex(i);\n+\n+            for (Expression mask : columnMasks.getOrDefault(field.getName().get(), ImmutableList.of())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 42}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMzI2ODIw", "url": "https://github.com/trinodb/trino/pull/2891#pullrequestreview-363326820", "createdAt": "2020-02-24T11:35:33Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMTozNTozM1rOFtdn8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMzo0NTozNlrOFthE_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxNTYwMg==", "bodyText": "So then I think you should use io.prestosql.spi.security.PrestoPrincipal", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r383215602", "createdAt": "2020-02-24T11:35:33Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java", "diffHunk": "@@ -663,6 +669,32 @@ public boolean isOrderByRedundant(OrderBy orderBy)\n         return redundantOrderBy.contains(NodeRef.of(orderBy));\n     }\n \n+    public boolean hasRowFilter(QualifiedObjectName table, String identity)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NjEwMw=="}, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyMTY4NA==", "bodyText": "yes, but you return only a single row filter from TestingAccessControlManager basing on identity.\nI was thinking about using view together with regular table, so during single query execution there would be two row filters collected for the same table but for different identities (query user and view owner).\n       assertions.executeExclusively(() -> {\n            accessControl.reset();\n            accessControl.rowFilter(\n                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n                    USER,\n                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"sf1\"), \"orderkey = 1\"));\n            accessControl.rowFilter(\n                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n                    VIEW_OWNER,\n                    new ViewExpression(VIEW_OWNER, Optional.of(CATALOG), Optional.of(\"sf1\"), \"orderkey = 2\"));\n             assertions.assertUpdate(VIEW_OWNER, \"CREATE VIEW v_orders AS SELECT * FROM orders\");\n             assertions.assertQuery(USER, \"SELECT o1.orderkey, o2.orderkey FROM orders o1, v_orders o2\", \"SELECT 1,2\");\n        });", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r383221684", "createdAt": "2020-02-24T11:50:40Z", "author": {"login": "kokosing"}, "path": "presto-main/src/test/java/io/prestosql/sql/query/TestRowFilter.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.query;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.plugin.tpch.TpchConnectorFactory;\n+import io.prestosql.spi.security.Identity;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.testing.LocalQueryRunner;\n+import io.prestosql.testing.TestingAccessControlManager;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.tpch.TpchMetadata.TINY_SCHEMA_NAME;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestRowFilter\n+{\n+    private static final String CATALOG = \"local\";\n+    private static final String USER = \"user\";\n+    private static final String RUN_AS_USER = \"run-as-user\";\n+\n+    private QueryAssertions assertions;\n+    private TestingAccessControlManager accessControl;\n+\n+    @BeforeClass\n+    public void init()\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(CATALOG)\n+                .setSchema(TINY_SCHEMA_NAME)\n+                .setIdentity(Identity.forUser(USER).build())\n+                .build();\n+\n+        LocalQueryRunner runner = LocalQueryRunner.builder(session)\n+                .build();\n+\n+        runner.createCatalog(CATALOG, new TpchConnectorFactory(1), ImmutableMap.of());\n+\n+        assertions = new QueryAssertions(runner);\n+        accessControl = assertions.getQueryRunner().getAccessControl();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void teardown()\n+    {\n+        assertions.close();\n+        assertions = null;\n+    }\n+\n+    @Test\n+    public void testSimpleFilter()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.empty(), Optional.empty(), \"orderkey < 10\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '7'\");\n+        });\n+\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.empty(), Optional.empty(), \"NULL\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '0'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testCorrelatedSubquery()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"EXISTS (SELECT 1 FROM nation WHERE nationkey = orderkey)\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '7'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testRecursion()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey IN (SELECT orderkey FROM orders)\"));\n+\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \".*\\\\QRow filter for 'local.tiny.orders' is recursive\\\\E.*\");\n+        });\n+\n+        // different reference style to same table\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey IN (SELECT local.tiny.orderkey FROM orders)\"));\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \".*\\\\QRow filter for 'local.tiny.orders' is recursive\\\\E.*\");\n+        });\n+    }\n+\n+    @Test\n+    public void testOtherSchema()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"sf1\"), \"(SELECT count(*) FROM customer) = 150000\")); // Filter is TRUE only if evaluating against sf1.customer\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '15000'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testDifferentIdentity()\n+    {\n+        assertions.executeExclusively(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NTc2MA=="}, "originalCommit": null, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyMjk5NQ==", "bodyText": "Why ViewExpression contains identity? We are already passing identity to access control. It is like \"give me a row filter for bob\", and getting a response \"here is a row filter FOR BOB\" (instead of just \"here is a row filter that you requested\").", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r383222995", "createdAt": "2020-02-24T11:53:52Z", "author": {"login": "kokosing"}, "path": "presto-spi/src/main/java/io/prestosql/spi/security/ViewExpression.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.security;\n+\n+import java.util.Optional;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class ViewExpression\n+{\n+    private final String identity;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI3MjE4OQ==", "bodyText": "Then I think we need to write TestAccessControl unit tests where you could inject some fake system and connector access control to test (concrete) the order.", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r383272189", "createdAt": "2020-02-24T13:45:36Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/RelationPlanner.java", "diffHunk": "@@ -192,6 +194,40 @@ private RelationPlan addRowFilters(Table node, RelationPlan plan)\n         return new RelationPlan(planBuilder.getRoot(), plan.getScope(), plan.getFieldMappings());\n     }\n \n+    private RelationPlan addColumnMasks(Table table, RelationPlan plan)\n+    {\n+        Map<String, List<Expression>> columnMasks = analysis.getColumnMasks(table);\n+\n+        PlanNode root = plan.getRoot();\n+        List<Symbol> mappings = plan.getFieldMappings();\n+\n+        TranslationMap translations = new TranslationMap(plan, analysis, lambdaDeclarationToSymbolMap);\n+        translations.setFieldMappings(mappings);\n+\n+        PlanBuilder planBuilder = new PlanBuilder(translations, root);\n+\n+        for (int i = 0; i < plan.getDescriptor().getAllFieldCount(); i++) {\n+            Field field = plan.getDescriptor().getFieldByIndex(i);\n+\n+            for (Expression mask : columnMasks.getOrDefault(field.getName().get(), ImmutableList.of())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3NDI5Nw=="}, "originalCommit": null, "originalPosition": 42}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d80f748a5239adfd5c05b0b5d641adb249a2163", "author": {"user": {"login": "martint", "name": "Martin Traverso"}}, "url": "https://github.com/trinodb/trino/commit/7d80f748a5239adfd5c05b0b5d641adb249a2163", "committedDate": "2020-02-24T17:37:53Z", "message": "Import method statically"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7efb49ca76782ef83b347b8d51ea422057bca1e0", "author": {"user": {"login": "martint", "name": "Martin Traverso"}}, "url": "https://github.com/trinodb/trino/commit/7efb49ca76782ef83b347b8d51ea422057bca1e0", "committedDate": "2020-02-24T17:37:53Z", "message": "Add support for row filtering"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "b03700bc0b0a1b2ccdcb368f052b371813456dc4", "author": {"user": {"login": "martint", "name": "Martin Traverso"}}, "url": "https://github.com/trinodb/trino/commit/b03700bc0b0a1b2ccdcb368f052b371813456dc4", "committedDate": "2020-02-24T17:39:40Z", "message": "Add support for column masking"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "b03700bc0b0a1b2ccdcb368f052b371813456dc4", "author": {"user": {"login": "martint", "name": "Martin Traverso"}}, "url": "https://github.com/trinodb/trino/commit/b03700bc0b0a1b2ccdcb368f052b371813456dc4", "committedDate": "2020-02-24T17:39:40Z", "message": "Add support for column masking"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MDk4OTAz", "url": "https://github.com/trinodb/trino/pull/2891#pullrequestreview-364098903", "createdAt": "2020-02-25T12:22:18Z", "commit": {"oid": "b03700bc0b0a1b2ccdcb368f052b371813456dc4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1592, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}