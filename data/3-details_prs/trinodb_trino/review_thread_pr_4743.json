{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0Nzk5MTIy", "number": 4743, "reviewThreads": {"totalCount": 69, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMTowMDo0MFrOEW9lXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMjowNTo1MVrOEhek-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTEzMTE3OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMTowMDo0MVrOG-foog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjoxODozMlrOG-_Ykg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4MzIwMg==", "bodyText": "I guess, in preparation for the removal of legacy semantics, you can drop the check altogether.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r468183202", "createdAt": "2020-08-10T21:00:41Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -42,37 +56,84 @@\n {\n     private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n             BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n \n     public static final String NAME = \"json\";\n \n     private final ObjectMapper objectMapper;\n     private final ObjectNode node;\n+    private final List<JsonDateTimeFormatter> dateTimeFormatters;\n \n     JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n     {\n         super(session, columnHandles);\n+        checkArgument(!this.session.isLegacyTimestamp(), \"The JSON encoder does not support legacy timestamp semantics\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2OTUzMQ==", "bodyText": "I should probably remove the session from the encoders as well, because it isn't used anywhere else", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r468669531", "createdAt": "2020-08-11T15:28:02Z", "author": {"login": "charlesjmorgan"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -42,37 +56,84 @@\n {\n     private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n             BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n \n     public static final String NAME = \"json\";\n \n     private final ObjectMapper objectMapper;\n     private final ObjectNode node;\n+    private final List<JsonDateTimeFormatter> dateTimeFormatters;\n \n     JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n     {\n         super(session, columnHandles);\n+        checkArgument(!this.session.isLegacyTimestamp(), \"The JSON encoder does not support legacy timestamp semantics\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4MzIwMg=="}, "originalCommit": null, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcwMzM3OA==", "bodyText": "wait nvm", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r468703378", "createdAt": "2020-08-11T16:18:32Z", "author": {"login": "charlesjmorgan"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -42,37 +56,84 @@\n {\n     private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n             BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n \n     public static final String NAME = \"json\";\n \n     private final ObjectMapper objectMapper;\n     private final ObjectNode node;\n+    private final List<JsonDateTimeFormatter> dateTimeFormatters;\n \n     JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n     {\n         super(session, columnHandles);\n+        checkArgument(!this.session.isLegacyTimestamp(), \"The JSON encoder does not support legacy timestamp semantics\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4MzIwMg=="}, "originalCommit": null, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTc3NjY0OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/CustomDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMTo0ODo1MlrOG-liWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMTo0ODo1MlrOG-liWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI3OTg5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (pattern.isPresent()) {\n          \n          \n            \n                        return pattern.get();\n          \n          \n            \n                    }\n          \n          \n            \n                    throw new IllegalArgumentException(\"No pattern defined for custom date time format\");\n          \n          \n            \n                    return pattern.orElseThrow(() -> new IllegalArgumentException(\"No pattern defined for custom date time format\"));", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r468279899", "createdAt": "2020-08-11T01:48:52Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/CustomDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static org.joda.time.DateTimeZone.UTC;\n+\n+public class CustomDateTimeFormatter\n+        extends JsonDateTimeFormatter\n+{\n+    private String cachedPattern;\n+    private DateTimeFormatter cachedFormatter;\n+\n+    private boolean checkCachedPatternEquals(String pattern)\n+    {\n+        return pattern.equals(cachedPattern);\n+    }\n+\n+    private void setCachedFormatter(String pattern)\n+    {\n+        try {\n+            cachedFormatter = DateTimeFormat.forPattern(pattern).withLocale(Locale.ENGLISH).withZoneUTC();\n+            cachedPattern = pattern;\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new IllegalArgumentException(format(\"Invalid Joda Time pattern '%s' passed as format hint\", pattern), e);\n+        }\n+    }\n+\n+    private DateTimeFormatter getFormatter(String pattern)\n+    {\n+        if (checkCachedPatternEquals(pattern)) {\n+            return cachedFormatter;\n+        }\n+        setCachedFormatter(pattern);\n+        return cachedFormatter;\n+    }\n+\n+    private static String getPattern(Optional<String> pattern)\n+    {\n+        if (pattern.isPresent()) {\n+            return pattern.get();\n+        }\n+        throw new IllegalArgumentException(\"No pattern defined for custom date time format\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTgwMzc1OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/CustomDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjowNDozOVrOG-lx5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjowNDozOVrOG-lx5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI4Mzg3Ng==", "bodyText": "This doesn't look right  The formatter should be immutable and should get its pattern at construction time.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r468283876", "createdAt": "2020-08-11T02:04:39Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/CustomDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static org.joda.time.DateTimeZone.UTC;\n+\n+public class CustomDateTimeFormatter\n+        extends JsonDateTimeFormatter\n+{\n+    private String cachedPattern;\n+    private DateTimeFormatter cachedFormatter;\n+\n+    private boolean checkCachedPatternEquals(String pattern)\n+    {\n+        return pattern.equals(cachedPattern);\n+    }\n+\n+    private void setCachedFormatter(String pattern)\n+    {\n+        try {\n+            cachedFormatter = DateTimeFormat.forPattern(pattern).withLocale(Locale.ENGLISH).withZoneUTC();\n+            cachedPattern = pattern;\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new IllegalArgumentException(format(\"Invalid Joda Time pattern '%s' passed as format hint\", pattern), e);\n+        }\n+    }\n+\n+    private DateTimeFormatter getFormatter(String pattern)\n+    {\n+        if (checkCachedPatternEquals(pattern)) {\n+            return cachedFormatter;\n+        }\n+        setCachedFormatter(pattern);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTg1MzM4OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/FormatType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjozMTo0N1rOG-mN8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjozMTo0N1rOG-mN8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5MTA1Ng==", "bodyText": "Instead of a formatter class, the second argument could be a functional interface taking as an argument an optional patter and producing a formatter.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                FormatType(boolean supportsDate, Class<? extends JsonDateTimeFormatter> formatter)\n          \n          \n            \n                FormatType(boolean supportsDate, Function<Optional<String>, ? extends JsonDateTimeFormatter> supplier)", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r468291056", "createdAt": "2020-08-11T02:31:47Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/FormatType.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Locale;\n+\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static java.util.Objects.requireNonNull;\n+\n+public enum FormatType\n+{\n+    CUSTOM_DATE_TIME(true, CustomDateTimeFormatter.class),\n+    ISO8601(true, ISO8601DateTimeFormatter.class),\n+    RFC2822(true, RFC2822DateTimeFormatter.class),\n+    MILLISECONDS_SINCE_EPOCH(false, MillisecondsSinceEpochFormatter.class),\n+    SECONDS_SINCE_EPOCH(false, SecondsSinceEpochFormatter.class);\n+\n+    private final boolean supportsDate;\n+    private final Class<? extends JsonDateTimeFormatter> formatter;\n+\n+    FormatType(boolean supportsDate, Class<? extends JsonDateTimeFormatter> formatter)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTg1OTE0OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/FormatType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjozNToxOVrOG-mRWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjozNToxOVrOG-mRWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5MTkzMA==", "bodyText": "If you have the enum define a way to construct the formatter, this would become:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                CUSTOM_DATE_TIME(true, CustomDateTimeFormatter.class),\n          \n          \n            \n                CUSTOM_DATE_TIME(true, CustomDateTimeFormatter::new),", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r468291930", "createdAt": "2020-08-11T02:35:19Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/FormatType.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Locale;\n+\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static java.util.Objects.requireNonNull;\n+\n+public enum FormatType\n+{\n+    CUSTOM_DATE_TIME(true, CustomDateTimeFormatter.class),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTg2MzMxOnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/FormatType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjozNzoxOVrOG-mTqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjozNzoxOVrOG-mTqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5MjUyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ISO8601(true, ISO8601DateTimeFormatter.class),\n          \n          \n            \n                ISO8601(true, pattern -> new ISO8601DateTimeFormatter()),\n          \n      \n    \n    \n  \n\netc", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r468292520", "createdAt": "2020-08-11T02:37:19Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/FormatType.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Locale;\n+\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static java.util.Objects.requireNonNull;\n+\n+public enum FormatType\n+{\n+    CUSTOM_DATE_TIME(true, CustomDateTimeFormatter.class),\n+    ISO8601(true, ISO8601DateTimeFormatter.class),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTg2OTM4OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/FormatType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjo0MDozOFrOG-mXDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjo0MDozOFrOG-mXDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5MzM5MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public JsonDateTimeFormatter getFormatter()\n          \n          \n            \n                {\n          \n          \n            \n                    try {\n          \n          \n            \n                        return formatter.getConstructor().newInstance();\n          \n          \n            \n                    }\n          \n          \n            \n                public JsonDateTimeFormatter getFormatter(Optional<String> pattern)\n          \n          \n            \n                {\n          \n          \n            \n                    return supplier.apply(pattern);\n          \n          \n            \n                }\n          \n      \n    \n    \n  \n\nAnd if you provide the pattern at construction time, the formatXXX() methods of JsonDateTimeFormatter  only need one argument.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r468293390", "createdAt": "2020-08-11T02:40:38Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/FormatType.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Locale;\n+\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static java.util.Objects.requireNonNull;\n+\n+public enum FormatType\n+{\n+    CUSTOM_DATE_TIME(true, CustomDateTimeFormatter.class),\n+    ISO8601(true, ISO8601DateTimeFormatter.class),\n+    RFC2822(true, RFC2822DateTimeFormatter.class),\n+    MILLISECONDS_SINCE_EPOCH(false, MillisecondsSinceEpochFormatter.class),\n+    SECONDS_SINCE_EPOCH(false, SecondsSinceEpochFormatter.class);\n+\n+    private final boolean supportsDate;\n+    private final Class<? extends JsonDateTimeFormatter> formatter;\n+\n+    FormatType(boolean supportsDate, Class<? extends JsonDateTimeFormatter> formatter)\n+    {\n+        this.supportsDate = supportsDate;\n+        this.formatter = requireNonNull(formatter, \"formatter is null\");\n+    }\n+\n+    public boolean isSupportedType(Type type)\n+    {\n+        if (type == TIME ||\n+                type == TIME_WITH_TIME_ZONE ||\n+                type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType) {\n+            return true;\n+        }\n+        return supportsDate && type == DATE;\n+    }\n+\n+    public JsonDateTimeFormatter getFormatter()\n+    {\n+        try {\n+            return formatter.getConstructor().newInstance();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTkwMzA2OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/ISO8601DateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjo1OToxOFrOG-mqew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjo1OToxOFrOG-mqew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5ODM2Mw==", "bodyText": "I think this can all go on a single line.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r468298363", "createdAt": "2020-08-11T02:59:18Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/ISO8601DateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+\n+import java.time.LocalDate;\n+import java.time.LocalTime;\n+import java.time.ZonedDateTime;\n+import java.util.Optional;\n+\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class ISO8601DateTimeFormatter\n+        extends JsonDateTimeFormatter\n+{\n+    @Override\n+    public String formatDate(SqlDate value, Optional<String> pattern)\n+    {\n+        return LocalDate.ofEpochDay(value.getDays()).toString();\n+    }\n+\n+    @Override\n+    public String formatTime(SqlTime value, Optional<String> pattern)\n+    {\n+        return LocalTime.ofNanoOfDay(MILLISECONDS.toNanos(value.getMillis() % MILLIS_IN_DAY)).toString();\n+    }\n+\n+    @Override\n+    public String formatTimeWithZone(SqlTimeWithTimeZone value, Optional<String> pattern)\n+    {\n+        return ISO_OFFSET_TIME.format(\n+                ZonedDateTime.of(\n+                        localDateTimeOfEpochMillis(value.getMillisUtc()),\n+                        UTC));\n+    }\n+\n+    @Override\n+    public String formatTimestamp(SqlTimestamp value, Optional<String> pattern)\n+    {\n+        return localDateTimeOfEpochMillis(value.getMillis())\n+                .toString();\n+    }\n+\n+    @Override\n+    public String formatTimestampWithZone(SqlTimestampWithTimeZone value, Optional<String> pattern)\n+    {\n+        return ISO_OFFSET_DATE_TIME.format(\n+                ZonedDateTime.of(\n+                        localDateTimeOfEpochMillis(value.getMillisUtc()),\n+                        UTC));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTk2NTk4OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzozOTowNFrOG-nO2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTo1OToyOFrOG--oMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwNzY3Mw==", "bodyText": "You take licensing seriously...", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r468307673", "createdAt": "2020-08-11T03:39:04Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY5MDk5NA==", "bodyText": "intellij really likes to add lots of licensing headers...", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r468690994", "createdAt": "2020-08-11T15:59:28Z", "author": {"login": "charlesjmorgan"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwNzY3Mw=="}, "originalCommit": null, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDE4Mjg4OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/ISO8601DateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMjowNzozM1rOG_PQvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMjowNzozM1rOG_PQvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk2MzUxNw==", "bodyText": "Could you put parentheses around value.getPicos() / PICOSECONDS_PER_MILLISECOND so that readers don't have to think about operation precedence?\nAlso, when dropping precision, the guideline is to use rounding, instead of truncation (this applies to several methods in this PR).  Try running select format_datetime(timestamp '2020-08-09 10:11:12.123999999', 'yyyy-MM-dd HH:mm:ss.SSS');\nI think that would translate to:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return LocalTime.ofNanoOfDay(MILLISECONDS.toNanos(value.getPicos() / PICOSECONDS_PER_MILLISECOND % MILLIS_IN_DAY)).toString();\n          \n          \n            \n                    return LocalTime.ofNanoOfDay(MILLISECONDS.toNanos((value.getPicos().roundTo(3) / PICOSECONDS_PER_MILLISECOND) % MILLIS_IN_DAY)).toString();", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r468963517", "createdAt": "2020-08-12T02:07:33Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/ISO8601DateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+\n+import java.time.LocalDate;\n+import java.time.LocalTime;\n+import java.time.ZonedDateTime;\n+\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_MILLISECOND;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class ISO8601DateTimeFormatter\n+        extends JsonDateTimeFormatter\n+{\n+    @Override\n+    public String formatDate(SqlDate value)\n+    {\n+        return LocalDate.ofEpochDay(value.getDays()).toString();\n+    }\n+\n+    @Override\n+    public String formatTime(SqlTime value)\n+    {\n+        return LocalTime.ofNanoOfDay(MILLISECONDS.toNanos(value.getPicos() / PICOSECONDS_PER_MILLISECOND % MILLIS_IN_DAY)).toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDIxMTY1OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/TestKafkaIntegrationSmokeTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMjoyNDo0NVrOG_PhwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMjoyNDo0NVrOG_PhwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk2Nzg3Mw==", "bodyText": "You can use an assertion message to capture the field name:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            assertEquals(actual, expected);\n          \n          \n            \n                            assertEquals(actual, expected, \"Equality assertion failed for field: \" + field.getFieldName());", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r468967873", "createdAt": "2020-08-12T02:24:45Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/TestKafkaIntegrationSmokeTest.java", "diffHunk": "@@ -156,11 +178,227 @@ private KafkaTopicDescription createDescription(String name, String schema, Stri\n         return Optional.of(new KafkaTopicFieldGroup(dataFormat, Optional.empty(), fields));\n     }\n \n+    private KafkaTopicFieldDescription createOneFieldDescription(String name, Type type, String dataFormat, Optional<String> formatHint)\n+    {\n+        return formatHint.map(s -> new KafkaTopicFieldDescription(name, type, name, null, dataFormat, s, false))\n+                .orElseGet(() -> new KafkaTopicFieldDescription(name, type, name, null, dataFormat, null, false));\n+    }\n+\n     private KafkaTopicFieldDescription createOneFieldDescription(String name, Type type, String mapping, String dataFormat)\n     {\n         return new KafkaTopicFieldDescription(name, type, mapping, null, dataFormat, null, false);\n     }\n \n+    @Test(dataProvider = \"jsonDateTimeFormatsDataProvider\")\n+    public void testJsonDateTimeFormats(JsonDateTimeTestCase testCase)\n+    {\n+        assertUpdate(\"INSERT into write_test.\" + testCase.getTopicName() +\n+                \" (\" + testCase.getFieldNames() + \")\" +\n+                \" VALUES \" + testCase.getFieldValues(), 1);\n+        for (JsonDateTimeTestCase.Field field : testCase.getFields()) {\n+            Object actual = computeScalar(\"SELECT \" + field.getFieldName() + \" FROM write_test.\" + testCase.getTopicName());\n+            Object expected = computeScalar(\"VALUES (\" + field.getFieldValue() + \")\");\n+            try {\n+                assertEquals(actual, expected);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDI1MzMwOnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/JsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMjo0OToxNFrOG_P52A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMjo0OToxNFrOG_P52A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk3NDA0MA==", "bodyText": "Disclaimer: this is a subjective comment.  I have looked at this code several times and the name JsonDateTimeFormatter always trips me up, because it's not obvious it doesn't implement any of the operations.  WDYT about naming is UnimplementedJsonDateTimeFormatter (inspired by UnimplementedHiveMetastore)?", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r468974040", "createdAt": "2020-08-12T02:49:14Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/JsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class JsonDateTimeFormatter", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDI3NzM1OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMzowMzoxN1rOG_QH_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMzowMzoxN1rOG_QH_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk3NzY2Mg==", "bodyText": "This could all be on one line.  The pattern shows up in many places, though, so it may not worth making all those changes.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r468977662", "createdAt": "2020-08-12T03:03:17Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.FormatType;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.testng.annotations.Test;\n+\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.spi.type.TimeZoneKey.getTimeZoneKey;\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+\n+public class TestCustomJsonDateTimeFormatter\n+{\n+    private DateTimeFormatter getFormatterForPattern(String pattern)\n+    {\n+        return DateTimeFormat.forPattern(pattern).withLocale(Locale.ENGLISH);\n+    }\n+\n+    private void testDate(SqlDate value, FormatType formatType, String formatHint)\n+    {\n+        String formattedStr = formatType.getFormatter(Optional.of(formatHint))\n+                .formatDate(value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzY4NzQ2OnYy", "diffSide": "RIGHT", "path": "presto-record-decoder/src/main/java/io/prestosql/decoder/json/AbstractDateTimeJsonValueProvider.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDowODozNFrOG_wqgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMDoyNjoyMVrOHB5tFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUxMDc4NA==", "bodyText": "I don't think this is right.  If the precision is great than 3, you need a different encoding.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r469510784", "createdAt": "2020-08-12T20:08:34Z", "author": {"login": "dain"}, "path": "presto-record-decoder/src/main/java/io/prestosql/decoder/json/AbstractDateTimeJsonValueProvider.java", "diffHunk": "@@ -70,10 +70,10 @@ public final long getLong()\n         if (type.equals(TIME)) {\n             return millis * PICOSECONDS_PER_MILLISECOND;\n         }\n-        if (type.equals(TIMESTAMP)) {\n+        if (type instanceof TimestampType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY0OTI0OA==", "bodyText": "Kafka table definition files only allow specifying TIMESTAMP without precision for field mappings.  So at this point, Kafka table columns can only have millisecond precision for timestamps.  This is a valid concern though for the code that handles writes, though, since the source data could potentially have columns with higher precision.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r469649248", "createdAt": "2020-08-13T01:46:51Z", "author": {"login": "aalbu"}, "path": "presto-record-decoder/src/main/java/io/prestosql/decoder/json/AbstractDateTimeJsonValueProvider.java", "diffHunk": "@@ -70,10 +70,10 @@ public final long getLong()\n         if (type.equals(TIME)) {\n             return millis * PICOSECONDS_PER_MILLISECOND;\n         }\n-        if (type.equals(TIMESTAMP)) {\n+        if (type instanceof TimestampType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUxMDc4NA=="}, "originalCommit": null, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc2NTE3Nw==", "bodyText": "presto-record-decoder is a module that can be used by other connectors aside from Kafka. If this code declares that it supports any precision for timestamp, it should produce the correct value:\n\nfor p <= 3, a long representing milliseconds from the epoch\nfor 3 < p <= 6, a long representing microseconds from the epoch\nfor p > 6, an instance of LongTimestamp", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r470765177", "createdAt": "2020-08-14T17:42:17Z", "author": {"login": "martint"}, "path": "presto-record-decoder/src/main/java/io/prestosql/decoder/json/AbstractDateTimeJsonValueProvider.java", "diffHunk": "@@ -70,10 +70,10 @@ public final long getLong()\n         if (type.equals(TIME)) {\n             return millis * PICOSECONDS_PER_MILLISECOND;\n         }\n-        if (type.equals(TIMESTAMP)) {\n+        if (type instanceof TimestampType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUxMDc4NA=="}, "originalCommit": null, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc1NjA1NQ==", "bodyText": "I changed it back to an equality check with the timestamp singleton. Same goes for tswtz. Supporting variable precision timestamps in the record decoder is a change for a different pr.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r471756055", "createdAt": "2020-08-17T20:26:21Z", "author": {"login": "charlesjmorgan"}, "path": "presto-record-decoder/src/main/java/io/prestosql/decoder/json/AbstractDateTimeJsonValueProvider.java", "diffHunk": "@@ -70,10 +70,10 @@ public final long getLong()\n         if (type.equals(TIME)) {\n             return millis * PICOSECONDS_PER_MILLISECOND;\n         }\n-        if (type.equals(TIMESTAMP)) {\n+        if (type instanceof TimestampType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUxMDc4NA=="}, "originalCommit": null, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzY4NzY5OnYy", "diffSide": "RIGHT", "path": "presto-record-decoder/src/main/java/io/prestosql/decoder/json/AbstractDateTimeJsonValueProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDowODo0MVrOG_wqpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNzo0NToxMVrOHA9TrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUxMDgyMQ==", "bodyText": "same", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r469510821", "createdAt": "2020-08-12T20:08:41Z", "author": {"login": "dain"}, "path": "presto-record-decoder/src/main/java/io/prestosql/decoder/json/AbstractDateTimeJsonValueProvider.java", "diffHunk": "@@ -70,10 +70,10 @@ public final long getLong()\n         if (type.equals(TIME)) {\n             return millis * PICOSECONDS_PER_MILLISECOND;\n         }\n-        if (type.equals(TIMESTAMP)) {\n+        if (type instanceof TimestampType) {\n             return millis;\n         }\n-        if (type.equals(TIMESTAMP_WITH_TIME_ZONE) || type.equals(TIME_WITH_TIME_ZONE)) {\n+        if (type instanceof TimestampWithTimeZoneType || type.equals(TIME_WITH_TIME_ZONE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc2NjUwOQ==", "bodyText": "in this case, the encoding is:\n\np <= 3, a long containing the milliseconds since the epoch packed with the time zone id\np > 3, an instance of LongTimestampWithTimeZone", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r470766509", "createdAt": "2020-08-14T17:45:11Z", "author": {"login": "martint"}, "path": "presto-record-decoder/src/main/java/io/prestosql/decoder/json/AbstractDateTimeJsonValueProvider.java", "diffHunk": "@@ -70,10 +70,10 @@ public final long getLong()\n         if (type.equals(TIME)) {\n             return millis * PICOSECONDS_PER_MILLISECOND;\n         }\n-        if (type.equals(TIMESTAMP)) {\n+        if (type instanceof TimestampType) {\n             return millis;\n         }\n-        if (type.equals(TIMESTAMP_WITH_TIME_ZONE) || type.equals(TIME_WITH_TIME_ZONE)) {\n+        if (type instanceof TimestampWithTimeZoneType || type.equals(TIME_WITH_TIME_ZONE)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUxMDgyMQ=="}, "originalCommit": null, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MTg1ODAwOnYy", "diffSide": "RIGHT", "path": "presto-record-decoder/src/main/java/io/prestosql/decoder/json/ISO8601JsonFieldDecoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNzo0Mzo1OVrOHA9RZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNzo0Mzo1OVrOHA9RZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc2NTkyNQ==", "bodyText": "Same comment as above. This needs to produce the proper encoding and type for the precision of TimestampType", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r470765925", "createdAt": "2020-08-14T17:43:59Z", "author": {"login": "martint"}, "path": "presto-record-decoder/src/main/java/io/prestosql/decoder/json/ISO8601JsonFieldDecoder.java", "diffHunk": "@@ -104,12 +111,12 @@ public long getLong()\n \n             try {\n                 String textValue = value.asText();\n-                if (columnType.equals(TIMESTAMP)) {\n+                if (columnType instanceof TimestampType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzQyNTk4OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/FormatType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMTowOTo0OFrOHCmycA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMTowOTo0OFrOHCmycA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ5NDcwNA==", "bodyText": "You could extract an interface (say JsonDateTimeFormatter) and reference that instead of the implementation class.\nprivate final Function<Optional<String>, JsonDateTimeFormatter> formatterConstructor;", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r472494704", "createdAt": "2020-08-18T21:09:48Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/FormatType.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static java.util.Objects.requireNonNull;\n+\n+public enum FormatType\n+{\n+    CUSTOM_DATE_TIME(true, CustomDateTimeFormatter::new),\n+    ISO8601(true, pattern -> new ISO8601DateTimeFormatter()),\n+    RFC2822(true, pattern -> new RFC2822DateTimeFormatter()),\n+    MILLISECONDS_SINCE_EPOCH(false, pattern -> new MillisecondsSinceEpochFormatter()),\n+    SECONDS_SINCE_EPOCH(false, pattern -> new SecondsSinceEpochFormatter());\n+\n+    private final boolean supportsDate;\n+    private final Function<Optional<String>, ? extends UnimplementedJsonDateTimeFormatter> formatterConstructor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzYzMTY3OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/ISO8601DateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMjoyMTozOFrOHCotTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMjoyMTozOFrOHCotTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUyNjE1Ng==", "bodyText": "I think this approach will limit the range of values we can encode.  You could build the ZonedDateTime using ZonedDateTime#ofInstant() and you can construct the instant using Instant#ofEpochSecond(epochSecond, nanoAdjustment).  You can look at DateTimes#toZonedDateTime() for inspiration.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r472526156", "createdAt": "2020-08-18T22:21:38Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/ISO8601DateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+\n+import java.time.LocalDate;\n+import java.time.LocalTime;\n+import java.time.ZonedDateTime;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getNanosOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.localDateTimeOfEpochNanos;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scaleEpochMicrosToNanos;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scaleEpochMillisToNanos;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scaleEpochPicosToNanos;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+\n+public class ISO8601DateTimeFormatter\n+        extends UnimplementedJsonDateTimeFormatter\n+{\n+    @Override\n+    public String formatDate(SqlDate value)\n+    {\n+        return LocalDate.ofEpochDay(value.getDays()).toString();\n+    }\n+\n+    @Override\n+    public String formatTime(SqlTime value, int precision)\n+    {\n+        return LocalTime.ofNanoOfDay(getNanosOfDay(scaleEpochPicosToNanos(value.getPicos()))).toString();\n+    }\n+\n+    @Override\n+    public String formatTimeWithZone(SqlTimeWithTimeZone value)\n+    {\n+        return ISO_OFFSET_TIME.format(\n+                ZonedDateTime.of(localDateTimeOfEpochNanos(scaleEpochMillisToNanos(value.getMillisUtc())), UTC));\n+    }\n+\n+    @Override\n+    public String formatTimestamp(SqlTimestamp value)\n+    {\n+        long epochNanos = Math.addExact(\n+                scaleEpochMicrosToNanos(value.getEpochMicros()),\n+                scaleEpochPicosToNanos(value.getPicosOfMicros()));\n+\n+        return localDateTimeOfEpochNanos(epochNanos).toString();\n+    }\n+\n+    @Override\n+    public String formatTimestampWithZone(SqlTimestampWithTimeZone value)\n+    {\n+        long epochNanos = Math.addExact(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1Mzg3OTA3OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestRFC2822JsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMDoxODo0N1rOHCq-rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMDoxODo0N1rOHCq-rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU2MzM3NA==", "bodyText": "Using these long values to construct timestamps makes it difficult to reason about the tests.  DateTimeTestingUtils has some utilities for constructing SqlTimestamp in a more readable form.\nSome edge cases are better expressed with millis values, but you could use something like NANOSECONDS.toMillis(Long.MAX_VALUE) instead of 9223372036000L.\nAs an aside, SqlTimestamp can represent a much wider range, so that's not an edge case.  It would also make sense to have some dates before the epoch.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r472563374", "createdAt": "2020-08-19T00:18:47Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestRFC2822JsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.FormatType;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.TemporalAccessor;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getMillisOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getNanosOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scaleEpochPicosToNanos;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.spi.type.TimeZoneKey.getTimeZoneKey;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.temporal.ChronoField.EPOCH_DAY;\n+import static java.time.temporal.ChronoField.INSTANT_SECONDS;\n+import static java.time.temporal.ChronoField.MILLI_OF_DAY;\n+import static java.time.temporal.ChronoField.MILLI_OF_SECOND;\n+import static java.time.temporal.ChronoField.NANO_OF_DAY;\n+import static java.time.temporal.ChronoField.OFFSET_SECONDS;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+\n+public class TestRFC2822JsonDateTimeFormatter\n+{\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH).withZone(UTC);\n+\n+    private void testDate(SqlDate value, FormatType formatType)\n+    {\n+        String formattedStr = formatType.getFormatter(Optional.empty()).formatDate(value);\n+        assertEquals(RFC_FORMATTER.parse(formattedStr).getLong(EPOCH_DAY), value.getDays());\n+    }\n+\n+    private void testTime(SqlTime value, FormatType formatType, int precision)\n+    {\n+        String formattedStr = formatType.getFormatter(Optional.empty()).formatTime(value, precision);\n+        assertEquals(RFC_FORMATTER.parse(formattedStr).getLong(NANO_OF_DAY), getNanosOfDay(scaleEpochPicosToNanos(value.getPicos())));\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, FormatType formatType)\n+    {\n+        String formattedStr = formatType.getFormatter(Optional.empty()).formatTimeWithZone(value);\n+        TemporalAccessor parseResult = RFC_FORMATTER.parse(formattedStr);\n+        assertEquals(parseResult.get(MILLI_OF_DAY), getMillisOfDay(value.getMillisUtc()));\n+        assertEquals(getTimeZoneKey(ZoneId.from(parseResult).getId()), UTC_KEY);\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, FormatType formatType)\n+    {\n+        String formattedStr = formatType.getFormatter(Optional.empty()).formatTimestamp(value);\n+        TemporalAccessor parseResult = RFC_FORMATTER.withZone(ZoneId.of(\"UTC\")).parse(formattedStr);\n+        assertEquals(DAYS.toMillis(parseResult.getLong(EPOCH_DAY)) + parseResult.getLong(MILLI_OF_DAY), value.getMillis());\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, FormatType formatType)\n+    {\n+        String formattedStr = formatType.getFormatter(Optional.empty()).formatTimestampWithZone(value);\n+\n+        TemporalAccessor parseResult = RFC_FORMATTER.parse(formattedStr);\n+        long actualEpochMillis = (parseResult.getLong(INSTANT_SECONDS) + parseResult.getLong(OFFSET_SECONDS)) * 1000 + parseResult.getLong(MILLI_OF_SECOND);\n+\n+        assertEquals(actualEpochMillis, value.getEpochMillis());\n+        assertEquals(getTimeZoneKey(ZoneId.from(parseResult).getId()), UTC_KEY);\n+    }\n+\n+    @Test\n+    public void testRFC2822DateTimeFunctions()\n+    {\n+        FormatType formatType = FormatType.RFC2822;\n+\n+        testDate(new SqlDate(389356), formatType);\n+        testDate(new SqlDate(0), formatType);\n+        testDate(new SqlDate(Integer.MAX_VALUE), formatType);\n+\n+        testTime(SqlTime.newInstance(3, 75303000000000000L), formatType, 3);\n+        testTime(SqlTime.newInstance(3, 0), formatType, 3);\n+        testTime(SqlTime.newInstance(3, 86399000000000000L), formatType, 3);\n+\n+        testTimeWithTZ(new SqlTimeWithTimeZone(1594846503000L, TimeZoneKey.getTimeZoneKeyForOffset(-240)), formatType);\n+        testTimeWithTZ(new SqlTimeWithTimeZone(1594846503000L, UTC_KEY), formatType);\n+        testTimeWithTZ(new SqlTimeWithTimeZone(1594846503000L, TimeZoneKey.getTimeZoneKeyForOffset(-360)), formatType);\n+        testTimeWithTZ(new SqlTimeWithTimeZone(9223372036000L, TimeZoneKey.getTimeZoneKeyForOffset(720)), formatType);\n+        testTimeWithTZ(new SqlTimeWithTimeZone(0, UTC_KEY), formatType);\n+\n+        testTimestamp(SqlTimestamp.fromMillis(3, 1594846503000L), formatType);\n+        testTimestamp(SqlTimestamp.fromMillis(3, 0), formatType);\n+        testTimestamp(SqlTimestamp.fromMillis(3, 9223372036000L), formatType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1OTc1NjQwOnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/FormatType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwMTo0ODo0MVrOHDlmKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwMTo0ODo0MVrOHDlmKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUyMzc1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Function<Optional<String>, ? extends JsonDateTimeFormatter> formatterConstructor;\n          \n          \n            \n                private final Function<Optional<String>, JsonDateTimeFormatter> formatterConstructor;", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r473523755", "createdAt": "2020-08-20T01:48:41Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/FormatType.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static java.util.Objects.requireNonNull;\n+\n+public enum FormatType\n+{\n+    CUSTOM_DATE_TIME(true, CustomDateTimeFormatter::new),\n+    ISO8601(true, pattern -> new ISO8601DateTimeFormatter()),\n+    RFC2822(true, pattern -> new RFC2822DateTimeFormatter()),\n+    MILLISECONDS_SINCE_EPOCH(false, pattern -> new MillisecondsSinceEpochFormatter()),\n+    SECONDS_SINCE_EPOCH(false, pattern -> new SecondsSinceEpochFormatter());\n+\n+    private final boolean supportsDate;\n+    private final Function<Optional<String>, ? extends JsonDateTimeFormatter> formatterConstructor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1OTc1ODg5OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/FormatType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwMTo0OToyMVrOHDloAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwMTo0OToyMVrOHDloAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUyNDIyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                FormatType(boolean supportsDate, Function<Optional<String>, ? extends JsonDateTimeFormatter> formatter)\n          \n          \n            \n                FormatType(boolean supportsDate, Function<Optional<String>, JsonDateTimeFormatter> formatter)", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r473524226", "createdAt": "2020-08-20T01:49:21Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/FormatType.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static java.util.Objects.requireNonNull;\n+\n+public enum FormatType\n+{\n+    CUSTOM_DATE_TIME(true, CustomDateTimeFormatter::new),\n+    ISO8601(true, pattern -> new ISO8601DateTimeFormatter()),\n+    RFC2822(true, pattern -> new RFC2822DateTimeFormatter()),\n+    MILLISECONDS_SINCE_EPOCH(false, pattern -> new MillisecondsSinceEpochFormatter()),\n+    SECONDS_SINCE_EPOCH(false, pattern -> new SecondsSinceEpochFormatter());\n+\n+    private final boolean supportsDate;\n+    private final Function<Optional<String>, ? extends JsonDateTimeFormatter> formatterConstructor;\n+\n+    FormatType(boolean supportsDate, Function<Optional<String>, ? extends JsonDateTimeFormatter> formatter)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1OTgyOTE0OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/ISO8601DateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwMjowODozN1rOHDmYRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDoyOTo0M1rOHEEU4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUzNjU4Mg==", "bodyText": "roundToNearest(picosOfMicros, PICOSECONDS_PER_NANOSECOND) / PICOSECONDS_PER_NANOSECOND - this is the same as roundDiv(picosOfMicros, PICOSECONDS_PER_NANOSECOND), right?  Perhaps you can change its visibility.  I found myself needing it too.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r473536582", "createdAt": "2020-08-20T02:08:37Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/ISO8601DateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZonedDateTime;\n+\n+import static io.prestosql.plugin.base.type.DateTimes.NANOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.plugin.base.type.DateTimes.NANOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.plugin.base.type.DateTimes.PICOSECONDS_PER_NANOSECOND;\n+import static io.prestosql.plugin.base.type.DateTimes.getMicrosOfSecond;\n+import static io.prestosql.plugin.base.type.DateTimes.getMillisOfSecond;\n+import static io.prestosql.plugin.base.type.DateTimes.roundToNearest;\n+import static io.prestosql.plugin.base.type.DateTimes.scaleEpochMicrosToSeconds;\n+import static io.prestosql.plugin.base.type.DateTimes.scaleEpochMillisToSeconds;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getNanosOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.localDateTimeOfEpochNanos;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scaleEpochMillisToNanos;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scaleEpochPicosToNanos;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+\n+public class ISO8601DateTimeFormatter\n+        extends UnimplementedJsonDateTimeFormatter\n+{\n+    @Override\n+    public String formatDate(SqlDate value)\n+    {\n+        return LocalDate.ofEpochDay(value.getDays()).toString();\n+    }\n+\n+    @Override\n+    public String formatTime(SqlTime value, int precision)\n+    {\n+        return LocalTime.ofNanoOfDay(getNanosOfDay(scaleEpochPicosToNanos(value.getPicos()))).toString();\n+    }\n+\n+    @Override\n+    public String formatTimeWithZone(SqlTimeWithTimeZone value)\n+    {\n+        return ISO_OFFSET_TIME.format(\n+                ZonedDateTime.of(localDateTimeOfEpochNanos(scaleEpochMillisToNanos(value.getMillisUtc())), UTC));\n+    }\n+\n+    @Override\n+    public String formatTimestamp(SqlTimestamp value)\n+    {\n+        long epochMicros = value.getEpochMicros();\n+        long picosOfMicros = value.getPicosOfMicros();\n+\n+        long epochSecond = scaleEpochMicrosToSeconds(epochMicros);\n+        int nanoFraction = getMicrosOfSecond(epochMicros) * NANOSECONDS_PER_MICROSECOND + (int) (roundToNearest(picosOfMicros, PICOSECONDS_PER_NANOSECOND) / PICOSECONDS_PER_NANOSECOND);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAyNzIzMg==", "bodyText": "I think this is the same as scaling from picoseconds to nanoseconds precision", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r474027232", "createdAt": "2020-08-20T14:29:43Z", "author": {"login": "charlesjmorgan"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/ISO8601DateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZonedDateTime;\n+\n+import static io.prestosql.plugin.base.type.DateTimes.NANOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.plugin.base.type.DateTimes.NANOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.plugin.base.type.DateTimes.PICOSECONDS_PER_NANOSECOND;\n+import static io.prestosql.plugin.base.type.DateTimes.getMicrosOfSecond;\n+import static io.prestosql.plugin.base.type.DateTimes.getMillisOfSecond;\n+import static io.prestosql.plugin.base.type.DateTimes.roundToNearest;\n+import static io.prestosql.plugin.base.type.DateTimes.scaleEpochMicrosToSeconds;\n+import static io.prestosql.plugin.base.type.DateTimes.scaleEpochMillisToSeconds;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getNanosOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.localDateTimeOfEpochNanos;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scaleEpochMillisToNanos;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scaleEpochPicosToNanos;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+\n+public class ISO8601DateTimeFormatter\n+        extends UnimplementedJsonDateTimeFormatter\n+{\n+    @Override\n+    public String formatDate(SqlDate value)\n+    {\n+        return LocalDate.ofEpochDay(value.getDays()).toString();\n+    }\n+\n+    @Override\n+    public String formatTime(SqlTime value, int precision)\n+    {\n+        return LocalTime.ofNanoOfDay(getNanosOfDay(scaleEpochPicosToNanos(value.getPicos()))).toString();\n+    }\n+\n+    @Override\n+    public String formatTimeWithZone(SqlTimeWithTimeZone value)\n+    {\n+        return ISO_OFFSET_TIME.format(\n+                ZonedDateTime.of(localDateTimeOfEpochNanos(scaleEpochMillisToNanos(value.getMillisUtc())), UTC));\n+    }\n+\n+    @Override\n+    public String formatTimestamp(SqlTimestamp value)\n+    {\n+        long epochMicros = value.getEpochMicros();\n+        long picosOfMicros = value.getPicosOfMicros();\n+\n+        long epochSecond = scaleEpochMicrosToSeconds(epochMicros);\n+        int nanoFraction = getMicrosOfSecond(epochMicros) * NANOSECONDS_PER_MICROSECOND + (int) (roundToNearest(picosOfMicros, PICOSECONDS_PER_NANOSECOND) / PICOSECONDS_PER_NANOSECOND);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUzNjU4Mg=="}, "originalCommit": null, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1OTg1OTQ0OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/TestKafkaIntegrationSmokeTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwMjoxNzowMlrOHDmtMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwMjoxNzowMlrOHDmtMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU0MTkzNw==", "bodyText": "We tend to use ImmutableList.Builder.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r473541937", "createdAt": "2020-08-20T02:17:02Z", "author": {"login": "aalbu"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/TestKafkaIntegrationSmokeTest.java", "diffHunk": "@@ -262,11 +283,227 @@ private KafkaTopicDescription createDescription(String name, String schema, Stri\n         return Optional.of(new KafkaTopicFieldGroup(dataFormat, Optional.empty(), fields));\n     }\n \n+    private KafkaTopicFieldDescription createOneFieldDescription(String name, Type type, String dataFormat, Optional<String> formatHint)\n+    {\n+        return formatHint.map(s -> new KafkaTopicFieldDescription(name, type, name, null, dataFormat, s, false))\n+                .orElseGet(() -> new KafkaTopicFieldDescription(name, type, name, null, dataFormat, null, false));\n+    }\n+\n     private KafkaTopicFieldDescription createOneFieldDescription(String name, Type type, String mapping, String dataFormat)\n     {\n         return new KafkaTopicFieldDescription(name, type, mapping, null, dataFormat, null, false);\n     }\n \n+    @Test(dataProvider = \"jsonDateTimeFormatsDataProvider\")\n+    public void testJsonDateTimeFormats(JsonDateTimeTestCase testCase)\n+    {\n+        assertUpdate(\"INSERT into write_test.\" + testCase.getTopicName() +\n+                \" (\" + testCase.getFieldNames() + \")\" +\n+                \" VALUES \" + testCase.getFieldValues(), 1);\n+        for (JsonDateTimeTestCase.Field field : testCase.getFields()) {\n+            Object actual = computeScalar(\"SELECT \" + field.getFieldName() + \" FROM write_test.\" + testCase.getTopicName());\n+            Object expected = computeScalar(\"VALUES (\" + field.getFieldValue() + \")\");\n+            try {\n+                assertEquals(actual, expected, \"Equality assertion failed for field: \" + field.getFieldName());\n+            }\n+            catch (AssertionError e) {\n+                throw new AssertionError(format(\"Equality assertion failed for field '%s'\\n%s\", field.getFieldName(), e.getMessage()), e);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public final Object[][] jsonDateTimeFormatsDataProvider()\n+    {\n+        return jsonDateTimeFormatsData().stream()\n+                .collect(toDataProvider());\n+    }\n+\n+    private List<JsonDateTimeTestCase> jsonDateTimeFormatsData()\n+    {\n+        return ImmutableList.<JsonDateTimeTestCase>builder()\n+                .add(JsonDateTimeTestCase.builder()\n+                        .setTopicName(JSON_CUSTOM_DATE_TIME_TABLE_NAME)\n+                        .addField(DATE, \"custom-date-time\", \"yyyy-MM-dd\", \"DATE '2020-07-15'\")\n+                        .addField(TIME, \"custom-date-time\", \"HH:mm:ss.SSS\", \"TIME '01:02:03.456'\")\n+                        .addField(TIME_WITH_TIME_ZONE, \"custom-date-time\", \"HH:mm:ss.SSS Z\", \"TIME '01:02:03.456 UTC'\")\n+                        .addField(TIMESTAMP, \"custom-date-time\", \"yyyy-dd-MM HH:mm:ss.SSS\", \"TIMESTAMP '2020-07-15 01:02:03.456'\")\n+                        .addField(TIMESTAMP_WITH_TIME_ZONE, \"custom-date-time\", \"yyyy-dd-MM HH:mm:ss.SSS Z\", \"TIMESTAMP '2020-07-15 01:02:03.456 UTC'\")\n+                        .build())\n+                .add(JsonDateTimeTestCase.builder()\n+                        .setTopicName(JSON_ISO8601_TABLE_NAME)\n+                        .addField(DATE, \"iso8601\", \"DATE '2020-07-15'\")\n+                        .addField(TIME, \"iso8601\", \"TIME '01:02:03.456'\")\n+                        .addField(TIME_WITH_TIME_ZONE, \"iso8601\", \"TIME '01:02:03.456 UTC'\")\n+                        .addField(TIMESTAMP, \"iso8601\", \"TIMESTAMP '2020-07-15 01:02:03.456'\")\n+                        .addField(TIMESTAMP_WITH_TIME_ZONE, \"iso8601\", \"TIMESTAMP '2020-07-15 01:02:03.456 UTC'\")\n+                        .build())\n+                .add(JsonDateTimeTestCase.builder()\n+                        .setTopicName(JSON_RFC2822_TABLE_NAME)\n+                        .addField(DATE, \"rfc2822\", \"DATE '2020-07-15'\")\n+                        .addField(TIME, \"rfc2822\", \"TIME '01:02:03'\")\n+                        .addField(TIME_WITH_TIME_ZONE, \"rfc2822\", \"TIME '01:02:03 UTC'\")\n+                        .addField(TIMESTAMP, \"rfc2822\", \"TIMESTAMP '2020-07-15 01:02:03'\")\n+                        .addField(TIMESTAMP_WITH_TIME_ZONE, \"rfc2822\", \"TIMESTAMP '2020-07-15 01:02:03 UTC'\")\n+                        .build())\n+                .add(JsonDateTimeTestCase.builder()\n+                        .setTopicName(JSON_MILLISECONDS_TABLE_NAME)\n+                        .addField(TIME, \"milliseconds-since-epoch\", \"TIME '01:02:03.456'\")\n+                        .addField(TIME_WITH_TIME_ZONE, \"milliseconds-since-epoch\", \"TIME '01:02:03.456 UTC'\")\n+                        .addField(TIMESTAMP, \"milliseconds-since-epoch\", \"TIMESTAMP '2020-07-15 01:02:03.456'\")\n+                        .addField(TIMESTAMP_WITH_TIME_ZONE, \"milliseconds-since-epoch\", \"TIMESTAMP '2020-07-15 01:02:03.456 UTC'\")\n+                        .build())\n+                .add(JsonDateTimeTestCase.builder()\n+                        .setTopicName(JSON_SECONDS_TABLE_NAME)\n+                        .addField(TIME, \"seconds-since-epoch\", \"TIME '01:02:03'\")\n+                        .addField(TIME_WITH_TIME_ZONE, \"seconds-since-epoch\", \"TIME '01:02:03 UTC'\")\n+                        .addField(TIMESTAMP, \"seconds-since-epoch\", \"TIMESTAMP '2020-07-15 01:02:03'\")\n+                        .addField(TIMESTAMP_WITH_TIME_ZONE, \"seconds-since-epoch\", \"TIMESTAMP '2020-07-15 01:02:03 UTC'\")\n+                        .build())\n+                .build();\n+    }\n+\n+    private Map<SchemaTableName, KafkaTopicDescription> createJsonDateTimeTestTopic()\n+    {\n+        return jsonDateTimeFormatsData().stream().collect(toImmutableMap(\n+                testCase -> new SchemaTableName(\"write_test\", testCase.getTopicName()),\n+                testCase -> new KafkaTopicDescription(\n+                        testCase.getTopicName(),\n+                        Optional.of(\"write_test\"),\n+                        testCase.getTopicName(),\n+                        Optional.of(new KafkaTopicFieldGroup(\"json\", Optional.empty(), ImmutableList.of(createOneFieldDescription(\"key\", BIGINT, \"key\", (String) null)))),\n+                        Optional.of(new KafkaTopicFieldGroup(\"json\", Optional.empty(), testCase.getFields().stream()\n+                                .map(field -> createOneFieldDescription(\n+                                      field.getFieldName(),\n+                                      field.getType(),\n+                                      field.getDataFormat(),\n+                                      field.getFormatHint()))\n+                                .collect(toImmutableList()))))));\n+    }\n+\n+    private static final class JsonDateTimeTestCase\n+    {\n+        private final String topicName;\n+        private final List<Field> fields;\n+\n+        public JsonDateTimeTestCase(String topicName, List<Field> fields)\n+        {\n+            this.topicName = requireNonNull(topicName, \"topicName is null\");\n+            requireNonNull(fields, \"fields is null\");\n+            this.fields = ImmutableList.copyOf(fields);\n+        }\n+\n+        public static Builder builder()\n+        {\n+            return new Builder();\n+        }\n+\n+        public String getTopicName()\n+        {\n+            return topicName;\n+        }\n+\n+        public String getFieldNames()\n+        {\n+            return fields.stream().map(Field::getFieldName).collect(Collectors.joining(\", \"));\n+        }\n+\n+        public String getFieldValues()\n+        {\n+            return fields.stream().map(Field::getFieldValue).collect(Collectors.joining(\", \", \"(\", \")\"));\n+        }\n+\n+        public List<Field> getFields()\n+        {\n+            return fields;\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return topicName; // for test case label in IDE\n+        }\n+\n+        public static class Builder\n+        {\n+            private String topicName = \"\";\n+            private final ArrayList<Field> fields = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 209}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Mjc1MjQ0OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDowNDo0MFrOHEDNnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDo0MzozNlrOHEE9OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAwODk5MQ==", "bodyText": "Do we support only types with precision == 3 intentionally?\nTo support different precisions you need to check using type instanceof TimeType etc.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r474008991", "createdAt": "2020-08-20T14:04:40Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -40,32 +56,71 @@\n public class JsonRowEncoder\n         extends AbstractRowEncoder\n {\n-    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+    private static final Set<Type> SUPPORTED_PRIMITIVE_TYPES = ImmutableSet.of(\n             BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> SUPPORTED_TEMPORAL_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE, TIMESTAMP, TIMESTAMP_WITH_TIME_ZONE);\n \n     public static final String NAME = \"json\";\n \n     private final ObjectMapper objectMapper;\n     private final ObjectNode node;\n+    private final List<JsonDateTimeFormatter> dateTimeFormatters;\n \n     JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n     {\n         super(session, columnHandles);\n \n+        ImmutableList.Builder<JsonDateTimeFormatter> formatFunctions = ImmutableList.builder();\n         for (EncoderColumnHandle columnHandle : this.columnHandles) {\n             checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n-            checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n-            checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+\n+            if (isSupportedTemporalType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getDataFormat() != null, \"Unsupported or no dataFormat '%s' defined for temporal column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                FormatType dataFormat = parseDataFormat(columnHandle.getDataFormat(), columnHandle.getName());\n+                checkArgument(dataFormat.isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+\n+                if (dataFormat == FormatType.CUSTOM_DATE_TIME) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());\n+                }\n+                else {\n+                    checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                }\n+\n+                formatFunctions.add(dataFormat.getFormatter(Optional.ofNullable(columnHandle.getFormatHint())));\n+            }\n+            else {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                formatFunctions.add(new UnimplementedJsonDateTimeFormatter());\n+            }\n         }\n \n+        this.dateTimeFormatters = formatFunctions.build();\n         this.objectMapper = requireNonNull(objectMapper, \"objectMapper is null\");\n         this.node = objectMapper.createObjectNode();\n     }\n \n     private boolean isSupportedType(Type type)\n     {\n         return isVarcharType(type) ||\n-                PRIMITIVE_SUPPORTED_TYPES.contains(type);\n+                SUPPORTED_PRIMITIVE_TYPES.contains(type) ||\n+                isSupportedTemporalType(type);\n+    }\n+\n+    private boolean isSupportedTemporalType(Type type)\n+    {\n+        return SUPPORTED_TEMPORAL_TYPES.contains(type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAzNzU2MQ==", "bodyText": "Yes that is intentional to mirror the decoder for now. Updating the decoder to use variable precision time/timestamps is going to be a bigger change so I wanted to constrain the encoder to default precision 3 for now.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r474037561", "createdAt": "2020-08-20T14:43:36Z", "author": {"login": "charlesjmorgan"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -40,32 +56,71 @@\n public class JsonRowEncoder\n         extends AbstractRowEncoder\n {\n-    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+    private static final Set<Type> SUPPORTED_PRIMITIVE_TYPES = ImmutableSet.of(\n             BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> SUPPORTED_TEMPORAL_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE, TIMESTAMP, TIMESTAMP_WITH_TIME_ZONE);\n \n     public static final String NAME = \"json\";\n \n     private final ObjectMapper objectMapper;\n     private final ObjectNode node;\n+    private final List<JsonDateTimeFormatter> dateTimeFormatters;\n \n     JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n     {\n         super(session, columnHandles);\n \n+        ImmutableList.Builder<JsonDateTimeFormatter> formatFunctions = ImmutableList.builder();\n         for (EncoderColumnHandle columnHandle : this.columnHandles) {\n             checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n-            checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n-            checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+\n+            if (isSupportedTemporalType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getDataFormat() != null, \"Unsupported or no dataFormat '%s' defined for temporal column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                FormatType dataFormat = parseDataFormat(columnHandle.getDataFormat(), columnHandle.getName());\n+                checkArgument(dataFormat.isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+\n+                if (dataFormat == FormatType.CUSTOM_DATE_TIME) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());\n+                }\n+                else {\n+                    checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                }\n+\n+                formatFunctions.add(dataFormat.getFormatter(Optional.ofNullable(columnHandle.getFormatHint())));\n+            }\n+            else {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                formatFunctions.add(new UnimplementedJsonDateTimeFormatter());\n+            }\n         }\n \n+        this.dateTimeFormatters = formatFunctions.build();\n         this.objectMapper = requireNonNull(objectMapper, \"objectMapper is null\");\n         this.node = objectMapper.createObjectNode();\n     }\n \n     private boolean isSupportedType(Type type)\n     {\n         return isVarcharType(type) ||\n-                PRIMITIVE_SUPPORTED_TYPES.contains(type);\n+                SUPPORTED_PRIMITIVE_TYPES.contains(type) ||\n+                isSupportedTemporalType(type);\n+    }\n+\n+    private boolean isSupportedTemporalType(Type type)\n+    {\n+        return SUPPORTED_TEMPORAL_TYPES.contains(type);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAwODk5MQ=="}, "originalCommit": null, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Mjc2MzY2OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDowNzoxOFrOHEDUug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDowNzoxOFrOHEDUug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxMDgxMA==", "bodyText": "nit: name local variable as field (dateTimeFormatters)", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r474010810", "createdAt": "2020-08-20T14:07:18Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -40,32 +56,71 @@\n public class JsonRowEncoder\n         extends AbstractRowEncoder\n {\n-    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+    private static final Set<Type> SUPPORTED_PRIMITIVE_TYPES = ImmutableSet.of(\n             BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> SUPPORTED_TEMPORAL_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE, TIMESTAMP, TIMESTAMP_WITH_TIME_ZONE);\n \n     public static final String NAME = \"json\";\n \n     private final ObjectMapper objectMapper;\n     private final ObjectNode node;\n+    private final List<JsonDateTimeFormatter> dateTimeFormatters;\n \n     JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n     {\n         super(session, columnHandles);\n \n+        ImmutableList.Builder<JsonDateTimeFormatter> formatFunctions = ImmutableList.builder();\n         for (EncoderColumnHandle columnHandle : this.columnHandles) {\n             checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n-            checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n-            checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+\n+            if (isSupportedTemporalType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getDataFormat() != null, \"Unsupported or no dataFormat '%s' defined for temporal column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                FormatType dataFormat = parseDataFormat(columnHandle.getDataFormat(), columnHandle.getName());\n+                checkArgument(dataFormat.isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+\n+                if (dataFormat == FormatType.CUSTOM_DATE_TIME) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());\n+                }\n+                else {\n+                    checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                }\n+\n+                formatFunctions.add(dataFormat.getFormatter(Optional.ofNullable(columnHandle.getFormatHint())));\n+            }\n+            else {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                formatFunctions.add(new UnimplementedJsonDateTimeFormatter());\n+            }\n         }\n \n+        this.dateTimeFormatters = formatFunctions.build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Mjc3MDA1OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDowODo1MFrOHEDYuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDowODo1MFrOHEDYuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxMTgzNQ==", "bodyText": ".strip()?", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r474011835", "createdAt": "2020-08-20T14:08:50Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -40,32 +56,71 @@\n public class JsonRowEncoder\n         extends AbstractRowEncoder\n {\n-    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+    private static final Set<Type> SUPPORTED_PRIMITIVE_TYPES = ImmutableSet.of(\n             BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> SUPPORTED_TEMPORAL_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE, TIMESTAMP, TIMESTAMP_WITH_TIME_ZONE);\n \n     public static final String NAME = \"json\";\n \n     private final ObjectMapper objectMapper;\n     private final ObjectNode node;\n+    private final List<JsonDateTimeFormatter> dateTimeFormatters;\n \n     JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n     {\n         super(session, columnHandles);\n \n+        ImmutableList.Builder<JsonDateTimeFormatter> formatFunctions = ImmutableList.builder();\n         for (EncoderColumnHandle columnHandle : this.columnHandles) {\n             checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n-            checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n-            checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+\n+            if (isSupportedTemporalType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getDataFormat() != null, \"Unsupported or no dataFormat '%s' defined for temporal column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                FormatType dataFormat = parseDataFormat(columnHandle.getDataFormat(), columnHandle.getName());\n+                checkArgument(dataFormat.isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+\n+                if (dataFormat == FormatType.CUSTOM_DATE_TIME) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());\n+                }\n+                else {\n+                    checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                }\n+\n+                formatFunctions.add(dataFormat.getFormatter(Optional.ofNullable(columnHandle.getFormatHint())));\n+            }\n+            else {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                formatFunctions.add(new UnimplementedJsonDateTimeFormatter());\n+            }\n         }\n \n+        this.dateTimeFormatters = formatFunctions.build();\n         this.objectMapper = requireNonNull(objectMapper, \"objectMapper is null\");\n         this.node = objectMapper.createObjectNode();\n     }\n \n     private boolean isSupportedType(Type type)\n     {\n         return isVarcharType(type) ||\n-                PRIMITIVE_SUPPORTED_TYPES.contains(type);\n+                SUPPORTED_PRIMITIVE_TYPES.contains(type) ||\n+                isSupportedTemporalType(type);\n+    }\n+\n+    private boolean isSupportedTemporalType(Type type)\n+    {\n+        return SUPPORTED_TEMPORAL_TYPES.contains(type);\n+    }\n+\n+    private FormatType parseDataFormat(String dataFormat, String columnName)\n+    {\n+        try {\n+            return FormatType.valueOf(dataFormat.toUpperCase().replaceAll(\"-\", \"_\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Mjc4ODMxOnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/UnimplementedJsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDoxMjo1MlrOHEDj-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDoxMjo1MlrOHEDj-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNDcxNQ==", "bodyText": "you can make methods defined here default method implementations in JsonDateTimeFormatter interface.\nAnd then drop UnimplementedJsonDateTimeFormatter from inheritance hierarchy for concrete formatters.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r474014715", "createdAt": "2020-08-20T14:12:52Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/UnimplementedJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+\n+public class UnimplementedJsonDateTimeFormatter\n+        implements JsonDateTimeFormatter\n+{\n+    public String formatDate(SqlDate value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Mjc5NjMwOnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDoxNDo0NlrOHEDpFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDo0NDo1M1rOHEFBCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNjAyMQ==", "bodyText": "why no precision here?", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r474016021", "createdAt": "2020-08-20T14:14:46Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -133,6 +188,37 @@ protected void appendByteBuffer(ByteBuffer value)\n         node.put(currentColumnName(), value.array());\n     }\n \n+    @Override\n+    protected void appendSqlDate(SqlDate value)\n+    {\n+        node.put(currentColumnName(), dateTimeFormatters.get(currentColumnIndex).formatDate(value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTime(SqlTime value)\n+    {\n+        int precision = ((TimeType) columnHandles.get(currentColumnIndex).getType()).getPrecision();\n+        node.put(currentColumnName(), dateTimeFormatters.get(currentColumnIndex).formatTime(value, precision));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimeWithTimeZone(SqlTimeWithTimeZone value)\n+    {\n+        node.put(currentColumnName(), dateTimeFormatters.get(currentColumnIndex).formatTimeWithZone(value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestamp(SqlTimestamp value)\n+    {\n+        node.put(currentColumnName(), dateTimeFormatters.get(currentColumnIndex).formatTimestamp(value));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAzODUzOQ==", "bodyText": "SqlTimestamp has a getPrecision method", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r474038539", "createdAt": "2020-08-20T14:44:53Z", "author": {"login": "charlesjmorgan"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -133,6 +188,37 @@ protected void appendByteBuffer(ByteBuffer value)\n         node.put(currentColumnName(), value.array());\n     }\n \n+    @Override\n+    protected void appendSqlDate(SqlDate value)\n+    {\n+        node.put(currentColumnName(), dateTimeFormatters.get(currentColumnIndex).formatDate(value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTime(SqlTime value)\n+    {\n+        int precision = ((TimeType) columnHandles.get(currentColumnIndex).getType()).getPrecision();\n+        node.put(currentColumnName(), dateTimeFormatters.get(currentColumnIndex).formatTime(value, precision));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimeWithTimeZone(SqlTimeWithTimeZone value)\n+    {\n+        node.put(currentColumnName(), dateTimeFormatters.get(currentColumnIndex).formatTimeWithZone(value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestamp(SqlTimestamp value)\n+    {\n+        node.put(currentColumnName(), dateTimeFormatters.get(currentColumnIndex).formatTimestamp(value));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNjAyMQ=="}, "originalCommit": null, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Mjc5Njk3OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDoxNDo1M1rOHEDpew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDo0NToyOFrOHEFCwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNjEyMw==", "bodyText": "why no precision here?", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r474016123", "createdAt": "2020-08-20T14:14:53Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -133,6 +188,37 @@ protected void appendByteBuffer(ByteBuffer value)\n         node.put(currentColumnName(), value.array());\n     }\n \n+    @Override\n+    protected void appendSqlDate(SqlDate value)\n+    {\n+        node.put(currentColumnName(), dateTimeFormatters.get(currentColumnIndex).formatDate(value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTime(SqlTime value)\n+    {\n+        int precision = ((TimeType) columnHandles.get(currentColumnIndex).getType()).getPrecision();\n+        node.put(currentColumnName(), dateTimeFormatters.get(currentColumnIndex).formatTime(value, precision));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimeWithTimeZone(SqlTimeWithTimeZone value)\n+    {\n+        node.put(currentColumnName(), dateTimeFormatters.get(currentColumnIndex).formatTimeWithZone(value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestamp(SqlTimestamp value)\n+    {\n+        node.put(currentColumnName(), dateTimeFormatters.get(currentColumnIndex).formatTimestamp(value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestampWithTimeZone(SqlTimestampWithTimeZone value)\n+    {\n+        node.put(currentColumnName(), dateTimeFormatters.get(currentColumnIndex).formatTimestampWithZone(value));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAzODk3Nw==", "bodyText": "SqlTimestampWithTimeZone has a getPrecision method", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r474038977", "createdAt": "2020-08-20T14:45:28Z", "author": {"login": "charlesjmorgan"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -133,6 +188,37 @@ protected void appendByteBuffer(ByteBuffer value)\n         node.put(currentColumnName(), value.array());\n     }\n \n+    @Override\n+    protected void appendSqlDate(SqlDate value)\n+    {\n+        node.put(currentColumnName(), dateTimeFormatters.get(currentColumnIndex).formatDate(value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTime(SqlTime value)\n+    {\n+        int precision = ((TimeType) columnHandles.get(currentColumnIndex).getType()).getPrecision();\n+        node.put(currentColumnName(), dateTimeFormatters.get(currentColumnIndex).formatTime(value, precision));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimeWithTimeZone(SqlTimeWithTimeZone value)\n+    {\n+        node.put(currentColumnName(), dateTimeFormatters.get(currentColumnIndex).formatTimeWithZone(value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestamp(SqlTimestamp value)\n+    {\n+        node.put(currentColumnName(), dateTimeFormatters.get(currentColumnIndex).formatTimestamp(value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestampWithTimeZone(SqlTimestampWithTimeZone value)\n+    {\n+        node.put(currentColumnName(), dateTimeFormatters.get(currentColumnIndex).formatTimestampWithZone(value));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNjEyMw=="}, "originalCommit": null, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MjgwNjc5OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/FormatType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDoxNzowMlrOHEDvUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDoxNzowMlrOHEDvUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNzYxNg==", "bodyText": "rename to DateTimeFormat", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r474017616", "createdAt": "2020-08-20T14:17:02Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/FormatType.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static java.util.Objects.requireNonNull;\n+\n+public enum FormatType", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MjgxNzIzOnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/FormatType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDoxOTozMlrOHED2Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDoxOTozMlrOHED2Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxOTM2Mg==", "bodyText": "type instanceof TimeType?", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r474019362", "createdAt": "2020-08-20T14:19:32Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/FormatType.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static java.util.Objects.requireNonNull;\n+\n+public enum FormatType\n+{\n+    CUSTOM_DATE_TIME(true, CustomDateTimeFormatter::new),\n+    ISO8601(true, pattern -> new ISO8601DateTimeFormatter()),\n+    RFC2822(true, pattern -> new RFC2822DateTimeFormatter()),\n+    MILLISECONDS_SINCE_EPOCH(false, pattern -> new MillisecondsSinceEpochFormatter()),\n+    SECONDS_SINCE_EPOCH(false, pattern -> new SecondsSinceEpochFormatter());\n+\n+    private final boolean supportsDate;\n+    private final Function<Optional<String>, ? extends JsonDateTimeFormatter> formatterConstructor;\n+\n+    FormatType(boolean supportsDate, Function<Optional<String>, ? extends JsonDateTimeFormatter> formatter)\n+    {\n+        this.supportsDate = supportsDate;\n+        this.formatterConstructor = requireNonNull(formatter, \"formatter is null\");\n+    }\n+\n+    public boolean isSupportedType(Type type)\n+    {\n+        if (type == TIME ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Mjg4MzE1OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/RFC2822DateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDozMzowM1rOHEEezA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNTowNzo0OFrOHFpkvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAyOTc3Mg==", "bodyText": "I possibly can live with formatDate setting time part to zeros. But this one is imo a bit too far fetched. It feels to me that the file format which requires date part in it should not support TIME.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r474029772", "createdAt": "2020-08-20T14:33:03Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/RFC2822DateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Locale;\n+\n+import static io.prestosql.plugin.base.type.DateTimes.NANOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.plugin.base.type.DateTimes.NANOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.plugin.base.type.DateTimes.getMicrosOfSecond;\n+import static io.prestosql.plugin.base.type.DateTimes.getMillisOfSecond;\n+import static io.prestosql.plugin.base.type.DateTimes.round;\n+import static io.prestosql.plugin.base.type.DateTimes.scaleEpochMicrosToSeconds;\n+import static io.prestosql.plugin.base.type.DateTimes.scaleEpochMillisToSeconds;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.NANOSECONDS_PRECISION;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.SECONDS_PRECISION;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getNanosOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scaleMillisToNanos;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToMillis;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToNanos;\n+import static java.time.LocalDate.EPOCH;\n+import static java.time.LocalTime.MIDNIGHT;\n+import static java.time.ZoneOffset.UTC;\n+\n+public class RFC2822DateTimeFormatter\n+        extends UnimplementedJsonDateTimeFormatter\n+{\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH);\n+\n+    private static long roundNanosToSecondsPrecision(long nanos)\n+    {\n+        return round(nanos, NANOSECONDS_PRECISION - SECONDS_PRECISION);\n+    }\n+\n+    private static LocalTime epochNanosToLocalTime(long epochNanos)\n+    {\n+        return LocalTime.ofNanoOfDay(getNanosOfDay(roundNanosToSecondsPrecision(epochNanos)));\n+    }\n+\n+    @Override\n+    public String formatDate(SqlDate value)\n+    {\n+        return RFC_FORMATTER.format(\n+                ZonedDateTime.of(LocalDate.ofEpochDay(value.getDays()), MIDNIGHT, UTC));\n+    }\n+\n+    @Override\n+    public String formatTime(SqlTime value, int precision)\n+    {\n+        long epochNanos = roundNanosToSecondsPrecision(scalePicosToNanos(value.getPicos()));\n+\n+        return RFC_FORMATTER.format(\n+                ZonedDateTime.of(EPOCH, epochNanosToLocalTime(epochNanos), UTC));\n+    }\n+\n+    @Override\n+    public String formatTimeWithZone(SqlTimeWithTimeZone value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAzOTkzNw==", "bodyText": "I agree, supporting anything other than timestamps for RFC2822 seems ridiculous to me. The decoder supports them tho so I decided the encoder should too.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r474039937", "createdAt": "2020-08-20T14:46:51Z", "author": {"login": "charlesjmorgan"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/RFC2822DateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Locale;\n+\n+import static io.prestosql.plugin.base.type.DateTimes.NANOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.plugin.base.type.DateTimes.NANOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.plugin.base.type.DateTimes.getMicrosOfSecond;\n+import static io.prestosql.plugin.base.type.DateTimes.getMillisOfSecond;\n+import static io.prestosql.plugin.base.type.DateTimes.round;\n+import static io.prestosql.plugin.base.type.DateTimes.scaleEpochMicrosToSeconds;\n+import static io.prestosql.plugin.base.type.DateTimes.scaleEpochMillisToSeconds;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.NANOSECONDS_PRECISION;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.SECONDS_PRECISION;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getNanosOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scaleMillisToNanos;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToMillis;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToNanos;\n+import static java.time.LocalDate.EPOCH;\n+import static java.time.LocalTime.MIDNIGHT;\n+import static java.time.ZoneOffset.UTC;\n+\n+public class RFC2822DateTimeFormatter\n+        extends UnimplementedJsonDateTimeFormatter\n+{\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH);\n+\n+    private static long roundNanosToSecondsPrecision(long nanos)\n+    {\n+        return round(nanos, NANOSECONDS_PRECISION - SECONDS_PRECISION);\n+    }\n+\n+    private static LocalTime epochNanosToLocalTime(long epochNanos)\n+    {\n+        return LocalTime.ofNanoOfDay(getNanosOfDay(roundNanosToSecondsPrecision(epochNanos)));\n+    }\n+\n+    @Override\n+    public String formatDate(SqlDate value)\n+    {\n+        return RFC_FORMATTER.format(\n+                ZonedDateTime.of(LocalDate.ofEpochDay(value.getDays()), MIDNIGHT, UTC));\n+    }\n+\n+    @Override\n+    public String formatTime(SqlTime value, int precision)\n+    {\n+        long epochNanos = roundNanosToSecondsPrecision(scalePicosToNanos(value.getPicos()));\n+\n+        return RFC_FORMATTER.format(\n+                ZonedDateTime.of(EPOCH, epochNanosToLocalTime(epochNanos), UTC));\n+    }\n+\n+    @Override\n+    public String formatTimeWithZone(SqlTimeWithTimeZone value)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAyOTc3Mg=="}, "originalCommit": null, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3MjQyNQ==", "bodyText": "I would not add support here. Noone will use it anyway. Why to have extra code to maintain.\ncc: @findepi", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r475572425", "createdAt": "2020-08-24T12:46:32Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/RFC2822DateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Locale;\n+\n+import static io.prestosql.plugin.base.type.DateTimes.NANOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.plugin.base.type.DateTimes.NANOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.plugin.base.type.DateTimes.getMicrosOfSecond;\n+import static io.prestosql.plugin.base.type.DateTimes.getMillisOfSecond;\n+import static io.prestosql.plugin.base.type.DateTimes.round;\n+import static io.prestosql.plugin.base.type.DateTimes.scaleEpochMicrosToSeconds;\n+import static io.prestosql.plugin.base.type.DateTimes.scaleEpochMillisToSeconds;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.NANOSECONDS_PRECISION;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.SECONDS_PRECISION;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getNanosOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scaleMillisToNanos;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToMillis;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToNanos;\n+import static java.time.LocalDate.EPOCH;\n+import static java.time.LocalTime.MIDNIGHT;\n+import static java.time.ZoneOffset.UTC;\n+\n+public class RFC2822DateTimeFormatter\n+        extends UnimplementedJsonDateTimeFormatter\n+{\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH);\n+\n+    private static long roundNanosToSecondsPrecision(long nanos)\n+    {\n+        return round(nanos, NANOSECONDS_PRECISION - SECONDS_PRECISION);\n+    }\n+\n+    private static LocalTime epochNanosToLocalTime(long epochNanos)\n+    {\n+        return LocalTime.ofNanoOfDay(getNanosOfDay(roundNanosToSecondsPrecision(epochNanos)));\n+    }\n+\n+    @Override\n+    public String formatDate(SqlDate value)\n+    {\n+        return RFC_FORMATTER.format(\n+                ZonedDateTime.of(LocalDate.ofEpochDay(value.getDays()), MIDNIGHT, UTC));\n+    }\n+\n+    @Override\n+    public String formatTime(SqlTime value, int precision)\n+    {\n+        long epochNanos = roundNanosToSecondsPrecision(scalePicosToNanos(value.getPicos()));\n+\n+        return RFC_FORMATTER.format(\n+                ZonedDateTime.of(EPOCH, epochNanosToLocalTime(epochNanos), UTC));\n+    }\n+\n+    @Override\n+    public String formatTimeWithZone(SqlTimeWithTimeZone value)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAyOTc3Mg=="}, "originalCommit": null, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY4NjA3Nw==", "bodyText": "let's not", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r475686077", "createdAt": "2020-08-24T15:07:48Z", "author": {"login": "findepi"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/RFC2822DateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Locale;\n+\n+import static io.prestosql.plugin.base.type.DateTimes.NANOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.plugin.base.type.DateTimes.NANOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.plugin.base.type.DateTimes.getMicrosOfSecond;\n+import static io.prestosql.plugin.base.type.DateTimes.getMillisOfSecond;\n+import static io.prestosql.plugin.base.type.DateTimes.round;\n+import static io.prestosql.plugin.base.type.DateTimes.scaleEpochMicrosToSeconds;\n+import static io.prestosql.plugin.base.type.DateTimes.scaleEpochMillisToSeconds;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.NANOSECONDS_PRECISION;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.SECONDS_PRECISION;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getNanosOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scaleMillisToNanos;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToMillis;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToNanos;\n+import static java.time.LocalDate.EPOCH;\n+import static java.time.LocalTime.MIDNIGHT;\n+import static java.time.ZoneOffset.UTC;\n+\n+public class RFC2822DateTimeFormatter\n+        extends UnimplementedJsonDateTimeFormatter\n+{\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH);\n+\n+    private static long roundNanosToSecondsPrecision(long nanos)\n+    {\n+        return round(nanos, NANOSECONDS_PRECISION - SECONDS_PRECISION);\n+    }\n+\n+    private static LocalTime epochNanosToLocalTime(long epochNanos)\n+    {\n+        return LocalTime.ofNanoOfDay(getNanosOfDay(roundNanosToSecondsPrecision(epochNanos)));\n+    }\n+\n+    @Override\n+    public String formatDate(SqlDate value)\n+    {\n+        return RFC_FORMATTER.format(\n+                ZonedDateTime.of(LocalDate.ofEpochDay(value.getDays()), MIDNIGHT, UTC));\n+    }\n+\n+    @Override\n+    public String formatTime(SqlTime value, int precision)\n+    {\n+        long epochNanos = roundNanosToSecondsPrecision(scalePicosToNanos(value.getPicos()));\n+\n+        return RFC_FORMATTER.format(\n+                ZonedDateTime.of(EPOCH, epochNanosToLocalTime(epochNanos), UTC));\n+    }\n+\n+    @Override\n+    public String formatTimeWithZone(SqlTimeWithTimeZone value)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAyOTc3Mg=="}, "originalCommit": null, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MzIyMDg2OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/MillisecondsSinceEpochFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMjo0NToxM1rOHFil2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMjo0NToxM1rOHFil2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3MTY3NQ==", "bodyText": "change to implements JsonDateTimeFormatter (it has default methods already)", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r475571675", "createdAt": "2020-08-24T12:45:13Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/MillisecondsSinceEpochFormatter.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToMillis;\n+\n+public class MillisecondsSinceEpochFormatter\n+        extends UnimplementedJsonDateTimeFormatter", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MzIyMTY0OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/RFC2822DateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMjo0NToyMlrOHFimSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMjo0NToyMlrOHFimSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3MTc4Nw==", "bodyText": "change to implements JsonDateTimeFormatter (it has default methods already)", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r475571787", "createdAt": "2020-08-24T12:45:22Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/RFC2822DateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Locale;\n+\n+import static io.prestosql.plugin.base.type.DateTimes.NANOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.plugin.base.type.DateTimes.NANOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.plugin.base.type.DateTimes.getMicrosOfSecond;\n+import static io.prestosql.plugin.base.type.DateTimes.getMillisOfSecond;\n+import static io.prestosql.plugin.base.type.DateTimes.round;\n+import static io.prestosql.plugin.base.type.DateTimes.scaleEpochMicrosToSeconds;\n+import static io.prestosql.plugin.base.type.DateTimes.scaleEpochMillisToSeconds;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.NANOSECONDS_PRECISION;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.SECONDS_PRECISION;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getNanosOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scaleMillisToNanos;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToMillis;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToNanos;\n+import static java.time.LocalDate.EPOCH;\n+import static java.time.LocalTime.MIDNIGHT;\n+import static java.time.ZoneOffset.UTC;\n+\n+public class RFC2822DateTimeFormatter\n+        extends UnimplementedJsonDateTimeFormatter", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MzIyNjQ0OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/SecondsSinceEpochFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMjo0Njo0M1rOHFipJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMjo0Njo0M1rOHFipJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3MjUxOA==", "bodyText": "change to implements JsonDateTimeFormatter (it has default methods already)", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r475572518", "createdAt": "2020-08-24T12:46:43Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/SecondsSinceEpochFormatter.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+\n+import static io.prestosql.plugin.base.type.DateTimes.scaleEpochMillisToSeconds;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToSeconds;\n+\n+public class SecondsSinceEpochFormatter\n+        extends UnimplementedJsonDateTimeFormatter", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MzIzNzYxOnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/TestKafkaIntegrationSmokeTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMjo0OTo0OVrOHFiv9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMjo0OTo0OVrOHFiv9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3NDI2MQ==", "bodyText": "static import joining", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r475574261", "createdAt": "2020-08-24T12:49:49Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/TestKafkaIntegrationSmokeTest.java", "diffHunk": "@@ -262,11 +282,227 @@ private KafkaTopicDescription createDescription(String name, String schema, Stri\n         return Optional.of(new KafkaTopicFieldGroup(dataFormat, Optional.empty(), fields));\n     }\n \n+    private KafkaTopicFieldDescription createOneFieldDescription(String name, Type type, String dataFormat, Optional<String> formatHint)\n+    {\n+        return formatHint.map(s -> new KafkaTopicFieldDescription(name, type, name, null, dataFormat, s, false))\n+                .orElseGet(() -> new KafkaTopicFieldDescription(name, type, name, null, dataFormat, null, false));\n+    }\n+\n     private KafkaTopicFieldDescription createOneFieldDescription(String name, Type type, String mapping, String dataFormat)\n     {\n         return new KafkaTopicFieldDescription(name, type, mapping, null, dataFormat, null, false);\n     }\n \n+    @Test(dataProvider = \"jsonDateTimeFormatsDataProvider\")\n+    public void testJsonDateTimeFormats(JsonDateTimeTestCase testCase)\n+    {\n+        assertUpdate(\"INSERT into write_test.\" + testCase.getTopicName() +\n+                \" (\" + testCase.getFieldNames() + \")\" +\n+                \" VALUES \" + testCase.getFieldValues(), 1);\n+        for (JsonDateTimeTestCase.Field field : testCase.getFields()) {\n+            Object actual = computeScalar(\"SELECT \" + field.getFieldName() + \" FROM write_test.\" + testCase.getTopicName());\n+            Object expected = computeScalar(\"VALUES (\" + field.getFieldValue() + \")\");\n+            try {\n+                assertEquals(actual, expected, \"Equality assertion failed for field: \" + field.getFieldName());\n+            }\n+            catch (AssertionError e) {\n+                throw new AssertionError(format(\"Equality assertion failed for field '%s'\\n%s\", field.getFieldName(), e.getMessage()), e);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public final Object[][] jsonDateTimeFormatsDataProvider()\n+    {\n+        return jsonDateTimeFormatsData().stream()\n+                .collect(toDataProvider());\n+    }\n+\n+    private List<JsonDateTimeTestCase> jsonDateTimeFormatsData()\n+    {\n+        return ImmutableList.<JsonDateTimeTestCase>builder()\n+                .add(JsonDateTimeTestCase.builder()\n+                        .setTopicName(JSON_CUSTOM_DATE_TIME_TABLE_NAME)\n+                        .addField(DATE, \"custom-date-time\", \"yyyy-MM-dd\", \"DATE '2020-07-15'\")\n+                        .addField(TIME, \"custom-date-time\", \"HH:mm:ss.SSS\", \"TIME '01:02:03.456'\")\n+                        .addField(TIME_WITH_TIME_ZONE, \"custom-date-time\", \"HH:mm:ss.SSS Z\", \"TIME '01:02:03.456 UTC'\")\n+                        .addField(TIMESTAMP, \"custom-date-time\", \"yyyy-dd-MM HH:mm:ss.SSS\", \"TIMESTAMP '2020-07-15 01:02:03.456'\")\n+                        .addField(TIMESTAMP_WITH_TIME_ZONE, \"custom-date-time\", \"yyyy-dd-MM HH:mm:ss.SSS Z\", \"TIMESTAMP '2020-07-15 01:02:03.456 UTC'\")\n+                        .build())\n+                .add(JsonDateTimeTestCase.builder()\n+                        .setTopicName(JSON_ISO8601_TABLE_NAME)\n+                        .addField(DATE, \"iso8601\", \"DATE '2020-07-15'\")\n+                        .addField(TIME, \"iso8601\", \"TIME '01:02:03.456'\")\n+                        .addField(TIME_WITH_TIME_ZONE, \"iso8601\", \"TIME '01:02:03.456 UTC'\")\n+                        .addField(TIMESTAMP, \"iso8601\", \"TIMESTAMP '2020-07-15 01:02:03.456'\")\n+                        .addField(TIMESTAMP_WITH_TIME_ZONE, \"iso8601\", \"TIMESTAMP '2020-07-15 01:02:03.456 UTC'\")\n+                        .build())\n+                .add(JsonDateTimeTestCase.builder()\n+                        .setTopicName(JSON_RFC2822_TABLE_NAME)\n+                        .addField(DATE, \"rfc2822\", \"DATE '2020-07-15'\")\n+                        .addField(TIME, \"rfc2822\", \"TIME '01:02:03'\")\n+                        .addField(TIME_WITH_TIME_ZONE, \"rfc2822\", \"TIME '01:02:03 UTC'\")\n+                        .addField(TIMESTAMP, \"rfc2822\", \"TIMESTAMP '2020-07-15 01:02:03'\")\n+                        .addField(TIMESTAMP_WITH_TIME_ZONE, \"rfc2822\", \"TIMESTAMP '2020-07-15 01:02:03 UTC'\")\n+                        .build())\n+                .add(JsonDateTimeTestCase.builder()\n+                        .setTopicName(JSON_MILLISECONDS_TABLE_NAME)\n+                        .addField(TIME, \"milliseconds-since-epoch\", \"TIME '01:02:03.456'\")\n+                        .addField(TIME_WITH_TIME_ZONE, \"milliseconds-since-epoch\", \"TIME '01:02:03.456 UTC'\")\n+                        .addField(TIMESTAMP, \"milliseconds-since-epoch\", \"TIMESTAMP '2020-07-15 01:02:03.456'\")\n+                        .addField(TIMESTAMP_WITH_TIME_ZONE, \"milliseconds-since-epoch\", \"TIMESTAMP '2020-07-15 01:02:03.456 UTC'\")\n+                        .build())\n+                .add(JsonDateTimeTestCase.builder()\n+                        .setTopicName(JSON_SECONDS_TABLE_NAME)\n+                        .addField(TIME, \"seconds-since-epoch\", \"TIME '01:02:03'\")\n+                        .addField(TIME_WITH_TIME_ZONE, \"seconds-since-epoch\", \"TIME '01:02:03 UTC'\")\n+                        .addField(TIMESTAMP, \"seconds-since-epoch\", \"TIMESTAMP '2020-07-15 01:02:03'\")\n+                        .addField(TIMESTAMP_WITH_TIME_ZONE, \"seconds-since-epoch\", \"TIMESTAMP '2020-07-15 01:02:03 UTC'\")\n+                        .build())\n+                .build();\n+    }\n+\n+    private Map<SchemaTableName, KafkaTopicDescription> createJsonDateTimeTestTopic()\n+    {\n+        return jsonDateTimeFormatsData().stream().collect(toImmutableMap(\n+                testCase -> new SchemaTableName(\"write_test\", testCase.getTopicName()),\n+                testCase -> new KafkaTopicDescription(\n+                        testCase.getTopicName(),\n+                        Optional.of(\"write_test\"),\n+                        testCase.getTopicName(),\n+                        Optional.of(new KafkaTopicFieldGroup(\"json\", Optional.empty(), ImmutableList.of(createOneFieldDescription(\"key\", BIGINT, \"key\", (String) null)))),\n+                        Optional.of(new KafkaTopicFieldGroup(\"json\", Optional.empty(), testCase.getFields().stream()\n+                                .map(field -> createOneFieldDescription(\n+                                      field.getFieldName(),\n+                                      field.getType(),\n+                                      field.getDataFormat(),\n+                                      field.getFormatHint()))\n+                                .collect(toImmutableList()))))));\n+    }\n+\n+    private static final class JsonDateTimeTestCase\n+    {\n+        private final String topicName;\n+        private final List<Field> fields;\n+\n+        public JsonDateTimeTestCase(String topicName, List<Field> fields)\n+        {\n+            this.topicName = requireNonNull(topicName, \"topicName is null\");\n+            requireNonNull(fields, \"fields is null\");\n+            this.fields = ImmutableList.copyOf(fields);\n+        }\n+\n+        public static Builder builder()\n+        {\n+            return new Builder();\n+        }\n+\n+        public String getTopicName()\n+        {\n+            return topicName;\n+        }\n+\n+        public String getFieldNames()\n+        {\n+            return fields.stream().map(Field::getFieldName).collect(Collectors.joining(\", \"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MzI1OTE3OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/TestKafkaIntegrationSmokeTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMjo1Mzo0OVrOHFi9Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMjo1Mzo0OVrOHFi9Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3NzYzMA==", "bodyText": "If we support multiple precisions it may result with conflicts. Seems like something(3) and something(7) will generate same name. Maybe just replace parens with underscore and leave numbers?", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r475577630", "createdAt": "2020-08-24T12:53:49Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/TestKafkaIntegrationSmokeTest.java", "diffHunk": "@@ -262,11 +282,227 @@ private KafkaTopicDescription createDescription(String name, String schema, Stri\n         return Optional.of(new KafkaTopicFieldGroup(dataFormat, Optional.empty(), fields));\n     }\n \n+    private KafkaTopicFieldDescription createOneFieldDescription(String name, Type type, String dataFormat, Optional<String> formatHint)\n+    {\n+        return formatHint.map(s -> new KafkaTopicFieldDescription(name, type, name, null, dataFormat, s, false))\n+                .orElseGet(() -> new KafkaTopicFieldDescription(name, type, name, null, dataFormat, null, false));\n+    }\n+\n     private KafkaTopicFieldDescription createOneFieldDescription(String name, Type type, String mapping, String dataFormat)\n     {\n         return new KafkaTopicFieldDescription(name, type, mapping, null, dataFormat, null, false);\n     }\n \n+    @Test(dataProvider = \"jsonDateTimeFormatsDataProvider\")\n+    public void testJsonDateTimeFormats(JsonDateTimeTestCase testCase)\n+    {\n+        assertUpdate(\"INSERT into write_test.\" + testCase.getTopicName() +\n+                \" (\" + testCase.getFieldNames() + \")\" +\n+                \" VALUES \" + testCase.getFieldValues(), 1);\n+        for (JsonDateTimeTestCase.Field field : testCase.getFields()) {\n+            Object actual = computeScalar(\"SELECT \" + field.getFieldName() + \" FROM write_test.\" + testCase.getTopicName());\n+            Object expected = computeScalar(\"VALUES (\" + field.getFieldValue() + \")\");\n+            try {\n+                assertEquals(actual, expected, \"Equality assertion failed for field: \" + field.getFieldName());\n+            }\n+            catch (AssertionError e) {\n+                throw new AssertionError(format(\"Equality assertion failed for field '%s'\\n%s\", field.getFieldName(), e.getMessage()), e);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public final Object[][] jsonDateTimeFormatsDataProvider()\n+    {\n+        return jsonDateTimeFormatsData().stream()\n+                .collect(toDataProvider());\n+    }\n+\n+    private List<JsonDateTimeTestCase> jsonDateTimeFormatsData()\n+    {\n+        return ImmutableList.<JsonDateTimeTestCase>builder()\n+                .add(JsonDateTimeTestCase.builder()\n+                        .setTopicName(JSON_CUSTOM_DATE_TIME_TABLE_NAME)\n+                        .addField(DATE, \"custom-date-time\", \"yyyy-MM-dd\", \"DATE '2020-07-15'\")\n+                        .addField(TIME, \"custom-date-time\", \"HH:mm:ss.SSS\", \"TIME '01:02:03.456'\")\n+                        .addField(TIME_WITH_TIME_ZONE, \"custom-date-time\", \"HH:mm:ss.SSS Z\", \"TIME '01:02:03.456 UTC'\")\n+                        .addField(TIMESTAMP, \"custom-date-time\", \"yyyy-dd-MM HH:mm:ss.SSS\", \"TIMESTAMP '2020-07-15 01:02:03.456'\")\n+                        .addField(TIMESTAMP_WITH_TIME_ZONE, \"custom-date-time\", \"yyyy-dd-MM HH:mm:ss.SSS Z\", \"TIMESTAMP '2020-07-15 01:02:03.456 UTC'\")\n+                        .build())\n+                .add(JsonDateTimeTestCase.builder()\n+                        .setTopicName(JSON_ISO8601_TABLE_NAME)\n+                        .addField(DATE, \"iso8601\", \"DATE '2020-07-15'\")\n+                        .addField(TIME, \"iso8601\", \"TIME '01:02:03.456'\")\n+                        .addField(TIME_WITH_TIME_ZONE, \"iso8601\", \"TIME '01:02:03.456 UTC'\")\n+                        .addField(TIMESTAMP, \"iso8601\", \"TIMESTAMP '2020-07-15 01:02:03.456'\")\n+                        .addField(TIMESTAMP_WITH_TIME_ZONE, \"iso8601\", \"TIMESTAMP '2020-07-15 01:02:03.456 UTC'\")\n+                        .build())\n+                .add(JsonDateTimeTestCase.builder()\n+                        .setTopicName(JSON_RFC2822_TABLE_NAME)\n+                        .addField(DATE, \"rfc2822\", \"DATE '2020-07-15'\")\n+                        .addField(TIME, \"rfc2822\", \"TIME '01:02:03'\")\n+                        .addField(TIME_WITH_TIME_ZONE, \"rfc2822\", \"TIME '01:02:03 UTC'\")\n+                        .addField(TIMESTAMP, \"rfc2822\", \"TIMESTAMP '2020-07-15 01:02:03'\")\n+                        .addField(TIMESTAMP_WITH_TIME_ZONE, \"rfc2822\", \"TIMESTAMP '2020-07-15 01:02:03 UTC'\")\n+                        .build())\n+                .add(JsonDateTimeTestCase.builder()\n+                        .setTopicName(JSON_MILLISECONDS_TABLE_NAME)\n+                        .addField(TIME, \"milliseconds-since-epoch\", \"TIME '01:02:03.456'\")\n+                        .addField(TIME_WITH_TIME_ZONE, \"milliseconds-since-epoch\", \"TIME '01:02:03.456 UTC'\")\n+                        .addField(TIMESTAMP, \"milliseconds-since-epoch\", \"TIMESTAMP '2020-07-15 01:02:03.456'\")\n+                        .addField(TIMESTAMP_WITH_TIME_ZONE, \"milliseconds-since-epoch\", \"TIMESTAMP '2020-07-15 01:02:03.456 UTC'\")\n+                        .build())\n+                .add(JsonDateTimeTestCase.builder()\n+                        .setTopicName(JSON_SECONDS_TABLE_NAME)\n+                        .addField(TIME, \"seconds-since-epoch\", \"TIME '01:02:03'\")\n+                        .addField(TIME_WITH_TIME_ZONE, \"seconds-since-epoch\", \"TIME '01:02:03 UTC'\")\n+                        .addField(TIMESTAMP, \"seconds-since-epoch\", \"TIMESTAMP '2020-07-15 01:02:03'\")\n+                        .addField(TIMESTAMP_WITH_TIME_ZONE, \"seconds-since-epoch\", \"TIMESTAMP '2020-07-15 01:02:03 UTC'\")\n+                        .build())\n+                .build();\n+    }\n+\n+    private Map<SchemaTableName, KafkaTopicDescription> createJsonDateTimeTestTopic()\n+    {\n+        return jsonDateTimeFormatsData().stream().collect(toImmutableMap(\n+                testCase -> new SchemaTableName(\"write_test\", testCase.getTopicName()),\n+                testCase -> new KafkaTopicDescription(\n+                        testCase.getTopicName(),\n+                        Optional.of(\"write_test\"),\n+                        testCase.getTopicName(),\n+                        Optional.of(new KafkaTopicFieldGroup(\"json\", Optional.empty(), ImmutableList.of(createOneFieldDescription(\"key\", BIGINT, \"key\", (String) null)))),\n+                        Optional.of(new KafkaTopicFieldGroup(\"json\", Optional.empty(), testCase.getFields().stream()\n+                                .map(field -> createOneFieldDescription(\n+                                      field.getFieldName(),\n+                                      field.getType(),\n+                                      field.getDataFormat(),\n+                                      field.getFormatHint()))\n+                                .collect(toImmutableList()))))));\n+    }\n+\n+    private static final class JsonDateTimeTestCase\n+    {\n+        private final String topicName;\n+        private final List<Field> fields;\n+\n+        public JsonDateTimeTestCase(String topicName, List<Field> fields)\n+        {\n+            this.topicName = requireNonNull(topicName, \"topicName is null\");\n+            requireNonNull(fields, \"fields is null\");\n+            this.fields = ImmutableList.copyOf(fields);\n+        }\n+\n+        public static Builder builder()\n+        {\n+            return new Builder();\n+        }\n+\n+        public String getTopicName()\n+        {\n+            return topicName;\n+        }\n+\n+        public String getFieldNames()\n+        {\n+            return fields.stream().map(Field::getFieldName).collect(Collectors.joining(\", \"));\n+        }\n+\n+        public String getFieldValues()\n+        {\n+            return fields.stream().map(Field::getFieldValue).collect(Collectors.joining(\", \", \"(\", \")\"));\n+        }\n+\n+        public List<Field> getFields()\n+        {\n+            return fields;\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return topicName; // for test case label in IDE\n+        }\n+\n+        public static class Builder\n+        {\n+            private String topicName = \"\";\n+            private final ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+\n+            public Builder setTopicName(String topicName)\n+            {\n+                this.topicName = topicName;\n+                return this;\n+            }\n+\n+            public Builder addField(Type type, String dataFormat, String fieldValue)\n+            {\n+                String fieldName = getFieldName(type, dataFormat);\n+                this.fields.add(new Field(fieldName, type, dataFormat, Optional.empty(), fieldValue));\n+                return this;\n+            }\n+\n+            public Builder addField(Type type, String dataFormat, String formatHint, String fieldValue)\n+            {\n+                String fieldName = getFieldName(type, dataFormat);\n+                this.fields.add(new Field(fieldName, type, dataFormat, Optional.of(formatHint), fieldValue));\n+                return this;\n+            }\n+\n+            private static String getFieldName(Type type, String dataFormat)\n+            {\n+                return String.join(\"_\", dataFormat.replaceAll(\"-\", \"_\"), type.getDisplayName().replaceAll(\" \", \"_\").replaceAll(\"[(]\\\\d+[)]\", \"\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MzczMzI2OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDoyOTowNlrOHFnnMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDoyOTowNlrOHFnnMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY1MzkzOA==", "bodyText": "I would prefer to have an explicit hardcoded exepected value. So instead generating expected value in testDate programatically pass it to testDate as an argument. Sth like:\ntestDate(sqlDateOf(2020, 8, 14), dateTimeFormat, \"yyyy-MM-dd\", \"2020-08-14\");\n\nIt make sense to have some level of expected-value generation if it is hard to eyeball if it is correct. (e.g. if encoder encodes to number-of-seconds-since-epoch).\nBut for case like this one it is much more readable it just write it down. And by doing that you make it sure that the logic in test does not mask symmetric bug in tested code.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r475653938", "createdAt": "2020-08-24T14:29:06Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneOffset;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getMillisOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToMillis;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.spi.type.TimeZoneKey.getTimeZoneKey;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlDateOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+\n+public class TestCustomJsonDateTimeFormatter\n+{\n+    private DateTimeFormatter getFormatterForPattern(String pattern)\n+    {\n+        return org.joda.time.format.DateTimeFormat.forPattern(pattern).withLocale(Locale.ENGLISH);\n+    }\n+\n+    private void testDate(SqlDate value, DateTimeFormat dateTimeFormat, String formatHint)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.of(formatHint)).formatDate(value);\n+\n+        long epochMillis = getFormatterForPattern(formatHint).withZoneUTC().parseMillis(formattedStr);\n+        assertEquals(epochMillis, DAYS.toMillis(value.getDays()));\n+    }\n+\n+    private void testTime(SqlTime value, DateTimeFormat dateTimeFormat, String formatHint, int precision)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.of(formatHint)).formatTime(value, precision);\n+\n+        long epochMillis = getFormatterForPattern(formatHint).withZoneUTC().parseMillis(formattedStr);\n+        assertEquals(epochMillis, getMillisOfDay(scalePicosToMillis(value.getPicos())));\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, DateTimeFormat dateTimeFormat, String formatHint)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.of(formatHint)).formatTimeWithZone(value);\n+\n+        DateTimeFormatter formatter = getFormatterForPattern(formatHint).withOffsetParsed();\n+        assertEquals(formatter.parseMillis(formattedStr), getMillisOfDay(value.getMillisUtc()));\n+        assertEquals(getTimeZoneKey(formatter.parseDateTime(formattedStr).getZone().getID()), UTC_KEY);\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, DateTimeFormat dateTimeFormat, String formatHint)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.of(formatHint)).formatTimestamp(value);\n+\n+        long epochMillis = getFormatterForPattern(formatHint).withZoneUTC().parseMillis(formattedStr);\n+        assertEquals(epochMillis, value.getMillis());\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, DateTimeFormat dateTimeFormat, String formatHint)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.of(formatHint)).formatTimestampWithZone(value);\n+\n+        DateTimeFormatter formatter = getFormatterForPattern(formatHint).withOffsetParsed();\n+        assertEquals(formatter.parseMillis(formattedStr), value.getEpochMillis());\n+        assertEquals(getTimeZoneKey(formatter.parseDateTime(formattedStr).getZone().getID()), UTC_KEY);\n+    }\n+\n+    @Test\n+    public void testCustomDateTimeFunctions()\n+    {\n+        DateTimeFormat dateTimeFormat = DateTimeFormat.CUSTOM_DATE_TIME;\n+\n+        testDate(sqlDateOf(2020, 8, 14), dateTimeFormat, \"yyyy-MM-dd\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3Mzc0MTUwOnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestISO8601JsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDozMDo0NlrOHFnsKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDozMDo0NlrOHFnsKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY1NTIxMA==", "bodyText": "Add explicit test values here too.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r475655210", "createdAt": "2020-08-24T14:30:46Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestISO8601JsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.temporal.TemporalAccessor;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getMillisOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getNanosOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToNanos;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.spi.type.TimeZoneKey.getTimeZoneKey;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlDateOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+import static java.time.format.DateTimeFormatter.ISO_DATE;\n+import static java.time.format.DateTimeFormatter.ISO_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_ZONED_DATE_TIME;\n+import static java.time.temporal.ChronoField.EPOCH_DAY;\n+import static java.time.temporal.ChronoField.INSTANT_SECONDS;\n+import static java.time.temporal.ChronoField.MILLI_OF_DAY;\n+import static java.time.temporal.ChronoField.MILLI_OF_SECOND;\n+import static java.time.temporal.ChronoField.NANO_OF_DAY;\n+import static java.time.temporal.ChronoField.OFFSET_SECONDS;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+\n+public class TestISO8601JsonDateTimeFormatter\n+{\n+    private void testDate(SqlDate value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatDate(value);\n+\n+        LocalDate actualDate = ISO_DATE.parse(formattedStr, LocalDate::from);\n+        LocalDate expectedDate = LocalDate.ofEpochDay(value.getDays());\n+        assertEquals(actualDate, expectedDate);\n+    }\n+\n+    private void testTime(SqlTime value, DateTimeFormat dateTimeFormat, int precision)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTime(value, precision);\n+\n+        assertEquals(ISO_TIME.parse(formattedStr).getLong(NANO_OF_DAY), getNanosOfDay(scalePicosToNanos(value.getPicos())));\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimeWithZone(value);\n+\n+        TemporalAccessor parseResult = ISO_OFFSET_TIME.parse(formattedStr);\n+        assertEquals(parseResult.get(MILLI_OF_DAY), getMillisOfDay(value.getMillisUtc()));\n+        assertEquals(getTimeZoneKey(ZoneId.from(parseResult).getId()), UTC_KEY);\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimestamp(value);\n+\n+        TemporalAccessor parseResult = ISO_DATE_TIME.parse(formattedStr);\n+        long actualEpochMillis = DAYS.toMillis(parseResult.getLong(EPOCH_DAY)) + parseResult.getLong(MILLI_OF_DAY);\n+\n+        assertEquals(actualEpochMillis, value.getMillis());\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimestampWithZone(value);\n+\n+        TemporalAccessor parseResult = ISO_ZONED_DATE_TIME.parse(formattedStr);\n+        long actualEpochMillis = (parseResult.getLong(INSTANT_SECONDS) + parseResult.getLong(OFFSET_SECONDS)) * 1000 + parseResult.getLong(MILLI_OF_SECOND);\n+\n+        assertEquals(actualEpochMillis, value.getEpochMillis());\n+        assertEquals(getTimeZoneKey(ZoneId.from(parseResult).getId()), UTC_KEY);\n+    }\n+\n+    @Test\n+    public void testISO8601DateTimeFunctions()\n+    {\n+        DateTimeFormat dateTimeFormat = DateTimeFormat.ISO8601;\n+\n+        testDate(sqlDateOf(2020, 8, 14), dateTimeFormat);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3Mzc1MzY2OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestMillisecondsJsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDozMzo0MFrOHFnzww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDozMzo0MFrOHFnzww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY1NzE1NQ==", "bodyText": "you are passing same dateTimeFormat everywhere. Drop the parameter.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r475657155", "createdAt": "2020-08-24T14:33:40Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestMillisecondsJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneOffset;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToMillis;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestMillisecondsJsonDateTimeFormatter\n+{\n+    private void testTime(SqlTime value, DateTimeFormat dateTimeFormat, int precision)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTime(value, precision);\n+        assertEquals(Long.parseLong(formattedStr), scalePicosToMillis(value.getPicos()));\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimeWithZone(value);\n+        assertEquals(Long.parseLong(formattedStr), value.getMillisUtc());\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimestamp(value);\n+        assertEquals(Long.parseLong(formattedStr), value.getMillis());\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimestampWithZone(value);\n+        assertEquals(Long.parseLong(formattedStr), value.getEpochMillis());\n+    }\n+\n+    @Test\n+    public void testMillisecondsDateTimeFunctions()\n+    {\n+        DateTimeFormat dateTimeFormat = DateTimeFormat.MILLISECONDS_SINCE_EPOCH;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3Mzc3MTU1OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestMillisecondsJsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDozNzozMFrOHFn-Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDozNzozMFrOHFn-Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY1OTg1NA==", "bodyText": "explicitly pass expected values. To avoid hard to read seconds-since-epoch you can have some trivial generation logic, but I would suggest to do it in place. E.g sth like:\ntestTime(sqlTimeOf(3, 15, 36, 25, 123000000), dateTimeFormat, 3, LocalTime.of(15, 36, 25, 123000000).toNanoOfDay()/1000);", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r475659854", "createdAt": "2020-08-24T14:37:30Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestMillisecondsJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneOffset;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToMillis;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestMillisecondsJsonDateTimeFormatter\n+{\n+    private void testTime(SqlTime value, DateTimeFormat dateTimeFormat, int precision)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTime(value, precision);\n+        assertEquals(Long.parseLong(formattedStr), scalePicosToMillis(value.getPicos()));\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimeWithZone(value);\n+        assertEquals(Long.parseLong(formattedStr), value.getMillisUtc());\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimestamp(value);\n+        assertEquals(Long.parseLong(formattedStr), value.getMillis());\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimestampWithZone(value);\n+        assertEquals(Long.parseLong(formattedStr), value.getEpochMillis());\n+    }\n+\n+    @Test\n+    public void testMillisecondsDateTimeFunctions()\n+    {\n+        DateTimeFormat dateTimeFormat = DateTimeFormat.MILLISECONDS_SINCE_EPOCH;\n+\n+        testTime(sqlTimeOf(3, 15, 36, 25, 123000000), dateTimeFormat, 3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3Mzc3MjcwOnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestRFC2822JsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDozNzo1MVrOHFn_Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDozNzo1MVrOHFn_Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY2MDA2Mw==", "bodyText": "same dateTimeFormat everywhere drop.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r475660063", "createdAt": "2020-08-24T14:37:51Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestRFC2822JsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.TemporalAccessor;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getMillisOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getNanosOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToNanos;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.spi.type.TimeZoneKey.getTimeZoneKey;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlDateOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.temporal.ChronoField.EPOCH_DAY;\n+import static java.time.temporal.ChronoField.INSTANT_SECONDS;\n+import static java.time.temporal.ChronoField.MILLI_OF_DAY;\n+import static java.time.temporal.ChronoField.MILLI_OF_SECOND;\n+import static java.time.temporal.ChronoField.NANO_OF_DAY;\n+import static java.time.temporal.ChronoField.OFFSET_SECONDS;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+\n+public class TestRFC2822JsonDateTimeFormatter\n+{\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH).withZone(UTC);\n+\n+    private void testDate(SqlDate value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatDate(value);\n+        assertEquals(RFC_FORMATTER.parse(formattedStr).getLong(EPOCH_DAY), value.getDays());\n+    }\n+\n+    private void testTime(SqlTime value, DateTimeFormat dateTimeFormat, int precision)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTime(value, precision);\n+        assertEquals(RFC_FORMATTER.parse(formattedStr).getLong(NANO_OF_DAY), getNanosOfDay(scalePicosToNanos(value.getPicos())));\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimeWithZone(value);\n+        TemporalAccessor parseResult = RFC_FORMATTER.parse(formattedStr);\n+        assertEquals(parseResult.get(MILLI_OF_DAY), getMillisOfDay(value.getMillisUtc()));\n+        assertEquals(getTimeZoneKey(ZoneId.from(parseResult).getId()), UTC_KEY);\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimestamp(value);\n+        TemporalAccessor parseResult = RFC_FORMATTER.withZone(ZoneId.of(\"UTC\")).parse(formattedStr);\n+        assertEquals(DAYS.toMillis(parseResult.getLong(EPOCH_DAY)) + parseResult.getLong(MILLI_OF_DAY), value.getMillis());\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimestampWithZone(value);\n+\n+        TemporalAccessor parseResult = RFC_FORMATTER.parse(formattedStr);\n+        long actualEpochMillis = (parseResult.getLong(INSTANT_SECONDS) + parseResult.getLong(OFFSET_SECONDS)) * 1000 + parseResult.getLong(MILLI_OF_SECOND);\n+\n+        assertEquals(actualEpochMillis, value.getEpochMillis());\n+        assertEquals(getTimeZoneKey(ZoneId.from(parseResult).getId()), UTC_KEY);\n+    }\n+\n+    @Test\n+    public void testRFC2822DateTimeFunctions()\n+    {\n+        DateTimeFormat dateTimeFormat = DateTimeFormat.RFC2822;\n+\n+        testDate(sqlDateOf(2020, 8, 14), dateTimeFormat);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3Mzc3MzIzOnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestRFC2822JsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDozODowMFrOHFn_bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDozODowMFrOHFn_bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY2MDE0Mg==", "bodyText": "pass expected values explicitly.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r475660142", "createdAt": "2020-08-24T14:38:00Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestRFC2822JsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.TemporalAccessor;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getMillisOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getNanosOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToNanos;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.spi.type.TimeZoneKey.getTimeZoneKey;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlDateOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.temporal.ChronoField.EPOCH_DAY;\n+import static java.time.temporal.ChronoField.INSTANT_SECONDS;\n+import static java.time.temporal.ChronoField.MILLI_OF_DAY;\n+import static java.time.temporal.ChronoField.MILLI_OF_SECOND;\n+import static java.time.temporal.ChronoField.NANO_OF_DAY;\n+import static java.time.temporal.ChronoField.OFFSET_SECONDS;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+\n+public class TestRFC2822JsonDateTimeFormatter\n+{\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH).withZone(UTC);\n+\n+    private void testDate(SqlDate value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatDate(value);\n+        assertEquals(RFC_FORMATTER.parse(formattedStr).getLong(EPOCH_DAY), value.getDays());\n+    }\n+\n+    private void testTime(SqlTime value, DateTimeFormat dateTimeFormat, int precision)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTime(value, precision);\n+        assertEquals(RFC_FORMATTER.parse(formattedStr).getLong(NANO_OF_DAY), getNanosOfDay(scalePicosToNanos(value.getPicos())));\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimeWithZone(value);\n+        TemporalAccessor parseResult = RFC_FORMATTER.parse(formattedStr);\n+        assertEquals(parseResult.get(MILLI_OF_DAY), getMillisOfDay(value.getMillisUtc()));\n+        assertEquals(getTimeZoneKey(ZoneId.from(parseResult).getId()), UTC_KEY);\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimestamp(value);\n+        TemporalAccessor parseResult = RFC_FORMATTER.withZone(ZoneId.of(\"UTC\")).parse(formattedStr);\n+        assertEquals(DAYS.toMillis(parseResult.getLong(EPOCH_DAY)) + parseResult.getLong(MILLI_OF_DAY), value.getMillis());\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimestampWithZone(value);\n+\n+        TemporalAccessor parseResult = RFC_FORMATTER.parse(formattedStr);\n+        long actualEpochMillis = (parseResult.getLong(INSTANT_SECONDS) + parseResult.getLong(OFFSET_SECONDS)) * 1000 + parseResult.getLong(MILLI_OF_SECOND);\n+\n+        assertEquals(actualEpochMillis, value.getEpochMillis());\n+        assertEquals(getTimeZoneKey(ZoneId.from(parseResult).getId()), UTC_KEY);\n+    }\n+\n+    @Test\n+    public void testRFC2822DateTimeFunctions()\n+    {\n+        DateTimeFormat dateTimeFormat = DateTimeFormat.RFC2822;\n+\n+        testDate(sqlDateOf(2020, 8, 14), dateTimeFormat);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3Mzc3NDg3OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestSecondsJsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDozODoyMlrOHFoAZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDozODoyMlrOHFoAZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY2MDM5MQ==", "bodyText": "same dateTimeFormat everywhere. Drop arguemnt", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r475660391", "createdAt": "2020-08-24T14:38:22Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestSecondsJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneOffset;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.base.type.DateTimes.scaleEpochMillisToSeconds;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToSeconds;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestSecondsJsonDateTimeFormatter\n+{\n+    private void testTime(SqlTime value, DateTimeFormat dateTimeFormat, int precision)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTime(value, precision);\n+        assertEquals(Long.parseLong(formattedStr), scalePicosToSeconds(value.getPicos()));\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimeWithZone(value);\n+        assertEquals(Long.parseLong(formattedStr), scaleEpochMillisToSeconds(value.getMillisUtc()));\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimestamp(value);\n+        assertEquals(Long.parseLong(formattedStr), scaleEpochMillisToSeconds(value.getMillis()));\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimestampWithZone(value);\n+        assertEquals(Long.parseLong(formattedStr), scaleEpochMillisToSeconds(value.getEpochMillis()));\n+    }\n+\n+    @Test\n+    public void testSecondsDateTimeFunctions()\n+    {\n+        DateTimeFormat dateTimeFormat = DateTimeFormat.SECONDS_SINCE_EPOCH;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3Mzc3NTc0OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestSecondsJsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDozODozNFrOHFoA6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDozODozNFrOHFoA6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY2MDUyMQ==", "bodyText": "pass expected values explicitly.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r475660521", "createdAt": "2020-08-24T14:38:34Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestSecondsJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneOffset;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.base.type.DateTimes.scaleEpochMillisToSeconds;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToSeconds;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestSecondsJsonDateTimeFormatter\n+{\n+    private void testTime(SqlTime value, DateTimeFormat dateTimeFormat, int precision)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTime(value, precision);\n+        assertEquals(Long.parseLong(formattedStr), scalePicosToSeconds(value.getPicos()));\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimeWithZone(value);\n+        assertEquals(Long.parseLong(formattedStr), scaleEpochMillisToSeconds(value.getMillisUtc()));\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimestamp(value);\n+        assertEquals(Long.parseLong(formattedStr), scaleEpochMillisToSeconds(value.getMillis()));\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimestampWithZone(value);\n+        assertEquals(Long.parseLong(formattedStr), scaleEpochMillisToSeconds(value.getEpochMillis()));\n+    }\n+\n+    @Test\n+    public void testSecondsDateTimeFunctions()\n+    {\n+        DateTimeFormat dateTimeFormat = DateTimeFormat.SECONDS_SINCE_EPOCH;\n+\n+        testTime(sqlTimeOf(3, 15, 36, 25, 0), dateTimeFormat, 3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3Mzc3OTQ4OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestISO8601JsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDozOTozMlrOHFoDTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDozOTozMlrOHFoDTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY2MTEzNQ==", "bodyText": "do not pass dateTimeFormat as argument. Same one is passed everywhere.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r475661135", "createdAt": "2020-08-24T14:39:32Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestISO8601JsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.temporal.TemporalAccessor;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getMillisOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.getNanosOfDay;\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scalePicosToNanos;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.spi.type.TimeZoneKey.getTimeZoneKey;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlDateOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+import static java.time.format.DateTimeFormatter.ISO_DATE;\n+import static java.time.format.DateTimeFormatter.ISO_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_ZONED_DATE_TIME;\n+import static java.time.temporal.ChronoField.EPOCH_DAY;\n+import static java.time.temporal.ChronoField.INSTANT_SECONDS;\n+import static java.time.temporal.ChronoField.MILLI_OF_DAY;\n+import static java.time.temporal.ChronoField.MILLI_OF_SECOND;\n+import static java.time.temporal.ChronoField.NANO_OF_DAY;\n+import static java.time.temporal.ChronoField.OFFSET_SECONDS;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+\n+public class TestISO8601JsonDateTimeFormatter\n+{\n+    private void testDate(SqlDate value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatDate(value);\n+\n+        LocalDate actualDate = ISO_DATE.parse(formattedStr, LocalDate::from);\n+        LocalDate expectedDate = LocalDate.ofEpochDay(value.getDays());\n+        assertEquals(actualDate, expectedDate);\n+    }\n+\n+    private void testTime(SqlTime value, DateTimeFormat dateTimeFormat, int precision)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTime(value, precision);\n+\n+        assertEquals(ISO_TIME.parse(formattedStr).getLong(NANO_OF_DAY), getNanosOfDay(scalePicosToNanos(value.getPicos())));\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimeWithZone(value);\n+\n+        TemporalAccessor parseResult = ISO_OFFSET_TIME.parse(formattedStr);\n+        assertEquals(parseResult.get(MILLI_OF_DAY), getMillisOfDay(value.getMillisUtc()));\n+        assertEquals(getTimeZoneKey(ZoneId.from(parseResult).getId()), UTC_KEY);\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimestamp(value);\n+\n+        TemporalAccessor parseResult = ISO_DATE_TIME.parse(formattedStr);\n+        long actualEpochMillis = DAYS.toMillis(parseResult.getLong(EPOCH_DAY)) + parseResult.getLong(MILLI_OF_DAY);\n+\n+        assertEquals(actualEpochMillis, value.getMillis());\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, DateTimeFormat dateTimeFormat)\n+    {\n+        String formattedStr = dateTimeFormat.getFormatter(Optional.empty()).formatTimestampWithZone(value);\n+\n+        TemporalAccessor parseResult = ISO_ZONED_DATE_TIME.parse(formattedStr);\n+        long actualEpochMillis = (parseResult.getLong(INSTANT_SECONDS) + parseResult.getLong(OFFSET_SECONDS)) * 1000 + parseResult.getLong(MILLI_OF_SECOND);\n+\n+        assertEquals(actualEpochMillis, value.getEpochMillis());\n+        assertEquals(getTimeZoneKey(ZoneId.from(parseResult).getId()), UTC_KEY);\n+    }\n+\n+    @Test\n+    public void testISO8601DateTimeFunctions()\n+    {\n+        DateTimeFormat dateTimeFormat = DateTimeFormat.ISO8601;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDExNjgyOnYy", "diffSide": "RIGHT", "path": "presto-plugin-toolkit/src/main/java/io/prestosql/plugin/base/type/DateTimes.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNTo1MDoxMlrOHFrVZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzowOTozMVrOHGhpgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcxNDkxNg==", "bodyText": "Let's not move this class to the plugin toolkit. In fact, presto-main should not depend on plugin-toolkit at all. Once all the variable-precision datetime PRs go in, we need to do a round of cleanup of all the shared code and figure out what things should go where. For now, please copy the necessary code into the plugin or plugin toolkit and add a TODO indicating it's a duplicate of code in this class.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r475714916", "createdAt": "2020-08-24T15:50:12Z", "author": {"login": "martint"}, "path": "presto-plugin-toolkit/src/main/java/io/prestosql/plugin/base/type/DateTimes.java", "diffHunk": "@@ -11,7 +11,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package io.prestosql.type;\n+package io.prestosql.plugin.base.type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMyNzU1OQ==", "bodyText": "In fact, presto-main should not depend on plugin-toolkit at all.\n\nSounds reasonable. Then we need some other place for shared code between engine and (our) connectors.\nOtherwise we will probably be putting more things in SPI than we otherwise would like to.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r476327559", "createdAt": "2020-08-25T09:55:41Z", "author": {"login": "findepi"}, "path": "presto-plugin-toolkit/src/main/java/io/prestosql/plugin/base/type/DateTimes.java", "diffHunk": "@@ -11,7 +11,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package io.prestosql.type;\n+package io.prestosql.plugin.base.type;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcxNDkxNg=="}, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwNDgwMQ==", "bodyText": "I added duplicate functions to io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions with TODOs", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r476604801", "createdAt": "2020-08-25T17:09:31Z", "author": {"login": "charlesjmorgan"}, "path": "presto-plugin-toolkit/src/main/java/io/prestosql/plugin/base/type/DateTimes.java", "diffHunk": "@@ -11,7 +11,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package io.prestosql.type;\n+package io.prestosql.plugin.base.type;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcxNDkxNg=="}, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4Mjc0NzUyOnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNzo1NDo0MlrOHHAOGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNzo1NDo0MlrOHHAOGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEwNTY4OA==", "bodyText": "inline and static import\nThen you may also extract\n    private JsonDateTimeFormatter getFormatter(String formatHint)\n    {\n        return CUSTOM_DATE_TIME.getFormatter(Optional.of(formatHint));\n    }", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r477105688", "createdAt": "2020-08-26T07:54:42Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneOffset;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlDateOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestCustomJsonDateTimeFormatter\n+{\n+    private static final DateTimeFormat DATE_TIME_FORMAT = DateTimeFormat.CUSTOM_DATE_TIME;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4Mjc3MDQ5OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODowMDowM1rOHHAbhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxODo0NzoyMFrOHHZElg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEwOTEyNg==", "bodyText": "Why zone in expected value is \"+0000\"?\nLooks like .withZoneUTC(); in CustomDateTimeFormatter is the culprit.\nIs that a conscious decision that we do not want to expose the timezone information from the value in the encoded string?", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r477109126", "createdAt": "2020-08-26T08:00:03Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneOffset;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlDateOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestCustomJsonDateTimeFormatter\n+{\n+    private static final DateTimeFormat DATE_TIME_FORMAT = DateTimeFormat.CUSTOM_DATE_TIME;\n+\n+    private void testDate(SqlDate value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.of(formatHint)).formatDate(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTime(SqlTime value, String formatHint, int precision, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.of(formatHint)).formatTime(value, precision);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.of(formatHint)).formatTimeWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.of(formatHint)).formatTimestamp(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.of(formatHint)).formatTimestampWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    @Test\n+    public void testCustomDateTimeFunctions()\n+    {\n+        testDate(sqlDateOf(2020, 8, 14), \"yyyy-MM-dd\", \"2020-08-14\");\n+        testDate(sqlDateOf(1970, 1, 1), \"yyyy-MM-dd\", \"1970-01-01\");\n+        testDate(sqlDateOf(1900, 1, 1), \"yyyy-MM-dd\", \"1900-01-01\");\n+        testDate(sqlDateOf(3001, 1, 1), \"yyyy-MM-dd\", \"3001-01-01\");\n+\n+        testTime(sqlTimeOf(3, 15, 36, 25, 123000000), \"HH:mm:ss.SSS\", 3, \"15:36:25.123\");\n+        testTime(sqlTimeOf(3, 15, 36, 25, 0), \"HH:mm:ss\", 3, \"15:36:25\");\n+        testTime(sqlTimeOf(3, 8, 12, 45, 987000000), \"HH:mm:ss.SSS\", 3, \"08:12:45.987\");\n+        testTime(sqlTimeOf(3, 0, 0, 0, 0), \"HH:mm:ss.SSS\", 3, \"00:00:00.000\");\n+        testTime(sqlTimeOf(3, 23, 59, 59, 999000000), \"HH:mm:ss.SSS\", 3, \"23:59:59.999\");\n+\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.UTC), \"HH:mm:ss.SSS Z\", \"10:23:35.123 +0000\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(0, 0, 0, 0, ZoneOffset.UTC), \"HH:mm:ss.SSS Z\", \"00:00:00.000 +0000\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.ofHours(2)), \"HH:mm:ss.SSS Z\", \"10:23:35.123 +0000\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUxMjg1NA==", "bodyText": "The decoder assumes UTC time zone, so that's what I figured the encoder should do as well. Is this assumption incorrect?", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r477512854", "createdAt": "2020-08-26T18:47:20Z", "author": {"login": "charlesjmorgan"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneOffset;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlDateOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestCustomJsonDateTimeFormatter\n+{\n+    private static final DateTimeFormat DATE_TIME_FORMAT = DateTimeFormat.CUSTOM_DATE_TIME;\n+\n+    private void testDate(SqlDate value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.of(formatHint)).formatDate(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTime(SqlTime value, String formatHint, int precision, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.of(formatHint)).formatTime(value, precision);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.of(formatHint)).formatTimeWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.of(formatHint)).formatTimestamp(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.of(formatHint)).formatTimestampWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    @Test\n+    public void testCustomDateTimeFunctions()\n+    {\n+        testDate(sqlDateOf(2020, 8, 14), \"yyyy-MM-dd\", \"2020-08-14\");\n+        testDate(sqlDateOf(1970, 1, 1), \"yyyy-MM-dd\", \"1970-01-01\");\n+        testDate(sqlDateOf(1900, 1, 1), \"yyyy-MM-dd\", \"1900-01-01\");\n+        testDate(sqlDateOf(3001, 1, 1), \"yyyy-MM-dd\", \"3001-01-01\");\n+\n+        testTime(sqlTimeOf(3, 15, 36, 25, 123000000), \"HH:mm:ss.SSS\", 3, \"15:36:25.123\");\n+        testTime(sqlTimeOf(3, 15, 36, 25, 0), \"HH:mm:ss\", 3, \"15:36:25\");\n+        testTime(sqlTimeOf(3, 8, 12, 45, 987000000), \"HH:mm:ss.SSS\", 3, \"08:12:45.987\");\n+        testTime(sqlTimeOf(3, 0, 0, 0, 0), \"HH:mm:ss.SSS\", 3, \"00:00:00.000\");\n+        testTime(sqlTimeOf(3, 23, 59, 59, 999000000), \"HH:mm:ss.SSS\", 3, \"23:59:59.999\");\n+\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.UTC), \"HH:mm:ss.SSS Z\", \"10:23:35.123 +0000\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(0, 0, 0, 0, ZoneOffset.UTC), \"HH:mm:ss.SSS Z\", \"00:00:00.000 +0000\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.ofHours(2)), \"HH:mm:ss.SSS Z\", \"10:23:35.123 +0000\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEwOTEyNg=="}, "originalCommit": null, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4Mjc3MjUwOnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODowMDozM1rOHHAcuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODowMDozM1rOHHAcuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEwOTQzMw==", "bodyText": "Why zone in expected value is \"+0000\"?", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r477109433", "createdAt": "2020-08-26T08:00:33Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneOffset;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlDateOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestCustomJsonDateTimeFormatter\n+{\n+    private static final DateTimeFormat DATE_TIME_FORMAT = DateTimeFormat.CUSTOM_DATE_TIME;\n+\n+    private void testDate(SqlDate value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.of(formatHint)).formatDate(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTime(SqlTime value, String formatHint, int precision, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.of(formatHint)).formatTime(value, precision);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.of(formatHint)).formatTimeWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.of(formatHint)).formatTimestamp(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.of(formatHint)).formatTimestampWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    @Test\n+    public void testCustomDateTimeFunctions()\n+    {\n+        testDate(sqlDateOf(2020, 8, 14), \"yyyy-MM-dd\", \"2020-08-14\");\n+        testDate(sqlDateOf(1970, 1, 1), \"yyyy-MM-dd\", \"1970-01-01\");\n+        testDate(sqlDateOf(1900, 1, 1), \"yyyy-MM-dd\", \"1900-01-01\");\n+        testDate(sqlDateOf(3001, 1, 1), \"yyyy-MM-dd\", \"3001-01-01\");\n+\n+        testTime(sqlTimeOf(3, 15, 36, 25, 123000000), \"HH:mm:ss.SSS\", 3, \"15:36:25.123\");\n+        testTime(sqlTimeOf(3, 15, 36, 25, 0), \"HH:mm:ss\", 3, \"15:36:25\");\n+        testTime(sqlTimeOf(3, 8, 12, 45, 987000000), \"HH:mm:ss.SSS\", 3, \"08:12:45.987\");\n+        testTime(sqlTimeOf(3, 0, 0, 0, 0), \"HH:mm:ss.SSS\", 3, \"00:00:00.000\");\n+        testTime(sqlTimeOf(3, 23, 59, 59, 999000000), \"HH:mm:ss.SSS\", 3, \"23:59:59.999\");\n+\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.UTC), \"HH:mm:ss.SSS Z\", \"10:23:35.123 +0000\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(0, 0, 0, 0, ZoneOffset.UTC), \"HH:mm:ss.SSS Z\", \"00:00:00.000 +0000\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.ofHours(2)), \"HH:mm:ss.SSS Z\", \"10:23:35.123 +0000\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.ofHours(10)), \"HH:mm:ss.SSS Z\", \"10:23:35.123 +0000\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.ofHours(-10)), \"HH:mm:ss.SSS Z\", \"10:23:35.123 +0000\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(23, 59, 59, 999000000, ZoneOffset.UTC), \"HH:mm:ss.SSS Z\", \"23:59:59.999 +0000\");\n+\n+        testTimestamp(sqlTimestampOf(3, 2020, 8, 18, 12, 38, 29, 123), \"yyyy-dd-MM HH:mm:ss.SSS\", \"2020-18-08 12:38:29.123\");\n+        testTimestamp(sqlTimestampOf(3, 1970, 1, 1, 0, 0, 0, 0), \"yyyy-dd-MM HH:mm:ss.SSS\", \"1970-01-01 00:00:00.000\");\n+        testTimestamp(sqlTimestampOf(3, 1800, 8, 18, 12, 38, 29, 123), \"yyyy-dd-MM HH:mm:ss.SSS\", \"1800-18-08 12:38:29.123\");\n+\n+        testTimestampWithTZ(sqlTimestampWithTimeZoneOf(3, 2020, 8, 19, 12, 23, 41, 123000000, UTC_KEY), \"yyyy-dd-MM HH:mm:ss.SSS Z\", \"2020-19-08 12:23:41.124 +0000\");\n+        testTimestampWithTZ(sqlTimestampWithTimeZoneOf(3, 2020, 8, 19, 12, 23, 41, 123000000, TimeZoneKey.getTimeZoneKey(\"America/New_York\")), \"yyyy-dd-MM HH:mm:ss.SSS Z\", \"2020-19-08 12:23:41.124 +0000\");\n+        testTimestampWithTZ(sqlTimestampWithTimeZoneOf(3, 1800, 8, 19, 12, 23, 41, 123000000, UTC_KEY), \"yyyy-dd-MM HH:mm:ss.SSS Z\", \"1800-19-08 12:23:41.124 +0000\");\n+        testTimestampWithTZ(sqlTimestampWithTimeZoneOf(3, 2020, 8, 19, 12, 23, 41, 123000000, TimeZoneKey.getTimeZoneKey(\"Asia/Hong_Kong\")), \"yyyy-dd-MM HH:mm:ss.SSS Z\", \"2020-19-08 12:23:41.124 +0000\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4Mjc3OTA1OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestISO8601JsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODowMjoyM1rOHHAgwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODowMjoyM1rOHHAgwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExMDQ2NQ==", "bodyText": "static import and inline", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r477110465", "createdAt": "2020-08-26T08:02:23Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestISO8601JsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneOffset;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlDateOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestISO8601JsonDateTimeFormatter\n+{\n+    private static final DateTimeFormat DATE_TIME_FORMAT = DateTimeFormat.ISO8601;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4Mjc4NzAwOnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestISO8601JsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODowNDozNFrOHHAlew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODowNDozNFrOHHAlew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExMTY3NQ==", "bodyText": "why expected value uses UTC (Z)\nISO8601 allows for timezone encoding - don't we want to support it?", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r477111675", "createdAt": "2020-08-26T08:04:34Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestISO8601JsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneOffset;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlDateOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestISO8601JsonDateTimeFormatter\n+{\n+    private static final DateTimeFormat DATE_TIME_FORMAT = DateTimeFormat.ISO8601;\n+\n+    private void testDate(SqlDate value, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.empty()).formatDate(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTime(SqlTime value, int precision, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.empty()).formatTime(value, precision);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.empty()).formatTimeWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.empty()).formatTimestamp(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.empty()).formatTimestampWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    @Test\n+    public void testISO8601DateTimeFunctions()\n+    {\n+        testDate(sqlDateOf(2020, 8, 14), \"2020-08-14\");\n+        testDate(sqlDateOf(1970, 1, 1), \"1970-01-01\");\n+        testDate(sqlDateOf(1900, 1, 1), \"1900-01-01\");\n+        testDate(sqlDateOf(3001, 1, 1), \"3001-01-01\");\n+\n+        testTime(sqlTimeOf(3, 15, 36, 25, 123000000), 3, \"15:36:25.123\");\n+        testTime(sqlTimeOf(3, 15, 36, 25, 0), 3, \"15:36:25\");\n+        testTime(sqlTimeOf(3, 8, 12, 45, 987000000), 3, \"08:12:45.987\");\n+        testTime(sqlTimeOf(3, 0, 0, 0, 0), 3, \"00:00\");\n+        testTime(sqlTimeOf(3, 23, 59, 59, 999000000), 3, \"23:59:59.999\");\n+\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.UTC), \"10:23:35.123Z\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(0, 0, 0, 0, ZoneOffset.UTC), \"00:00:00Z\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.ofHours(2)), \"10:23:35.123Z\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4Mjc4NzMyOnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestISO8601JsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODowNDozN1rOHHAlqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODowNDozN1rOHHAlqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExMTcyMQ==", "bodyText": "why expected value uses UTC (Z)", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r477111721", "createdAt": "2020-08-26T08:04:37Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestISO8601JsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneOffset;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlDateOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestISO8601JsonDateTimeFormatter\n+{\n+    private static final DateTimeFormat DATE_TIME_FORMAT = DateTimeFormat.ISO8601;\n+\n+    private void testDate(SqlDate value, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.empty()).formatDate(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTime(SqlTime value, int precision, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.empty()).formatTime(value, precision);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.empty()).formatTimeWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.empty()).formatTimestamp(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.empty()).formatTimestampWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    @Test\n+    public void testISO8601DateTimeFunctions()\n+    {\n+        testDate(sqlDateOf(2020, 8, 14), \"2020-08-14\");\n+        testDate(sqlDateOf(1970, 1, 1), \"1970-01-01\");\n+        testDate(sqlDateOf(1900, 1, 1), \"1900-01-01\");\n+        testDate(sqlDateOf(3001, 1, 1), \"3001-01-01\");\n+\n+        testTime(sqlTimeOf(3, 15, 36, 25, 123000000), 3, \"15:36:25.123\");\n+        testTime(sqlTimeOf(3, 15, 36, 25, 0), 3, \"15:36:25\");\n+        testTime(sqlTimeOf(3, 8, 12, 45, 987000000), 3, \"08:12:45.987\");\n+        testTime(sqlTimeOf(3, 0, 0, 0, 0), 3, \"00:00\");\n+        testTime(sqlTimeOf(3, 23, 59, 59, 999000000), 3, \"23:59:59.999\");\n+\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.UTC), \"10:23:35.123Z\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(0, 0, 0, 0, ZoneOffset.UTC), \"00:00:00Z\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.ofHours(2)), \"10:23:35.123Z\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.ofHours(10)), \"10:23:35.123Z\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.ofHours(-10)), \"10:23:35.123Z\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(23, 59, 59, 999000000, ZoneOffset.UTC), \"23:59:59.999Z\");\n+\n+        testTimestamp(sqlTimestampOf(3, 2020, 8, 18, 12, 38, 29, 123), \"2020-08-18T12:38:29.123\");\n+        testTimestamp(sqlTimestampOf(3, 1970, 1, 1, 0, 0, 0, 0), \"1970-01-01T00:00\");\n+        testTimestamp(sqlTimestampOf(3, 1800, 8, 18, 12, 38, 29, 123), \"1800-08-18T12:38:29.123\");\n+\n+        testTimestampWithTZ(sqlTimestampWithTimeZoneOf(3, 2020, 8, 19, 12, 23, 41, 123000000, UTC_KEY), \"2020-08-19T12:23:41.124Z\");\n+        testTimestampWithTZ(sqlTimestampWithTimeZoneOf(3, 2020, 8, 19, 12, 23, 41, 123000000, TimeZoneKey.getTimeZoneKey(\"America/New_York\")), \"2020-08-19T12:23:41.124Z\");\n+        testTimestampWithTZ(sqlTimestampWithTimeZoneOf(3, 1800, 8, 19, 12, 23, 41, 123000000, UTC_KEY), \"1800-08-19T12:23:41.124Z\");\n+        testTimestampWithTZ(sqlTimestampWithTimeZoneOf(3, 2020, 8, 19, 12, 23, 41, 123000000, TimeZoneKey.getTimeZoneKey(\"Asia/Hong_Kong\")), \"2020-08-19T12:23:41.124Z\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4Mjk2MjM4OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestJsonEncoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODo0ODozN1rOHHCRKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODo0ODozN1rOHHCRKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEzOTI0Mg==", "bodyText": "why passing format string for iso8601?\nAnd more general question. What is purpose of this test at all? (I think I have missed it during previous reivews).\nIs it about compatibility of different encoders and data types?\nMaybe instead just calling out to singleColumnEncoder it would be more readable to wrap it into asserting method like you do for assertUnsupportedColumnTypeException. Even if assertion would be just \"does not throw exception\".\nsth like\nassertCanCreateEncoder(() -> singleColumnEncoder(BIGINT);", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r477139242", "createdAt": "2020-08-26T08:48:37Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestJsonEncoder.java", "diffHunk": "@@ -64,8 +88,36 @@ public void testColumnValidation()\n         singleColumnEncoder(createVarcharType(20));\n         singleColumnEncoder(createUnboundedVarcharType());\n \n+        singleColumnEncoder(TIMESTAMP, \"rfc2822\", \"\");\n+        singleColumnEncoder(TIMESTAMP_WITH_TIME_ZONE, \"rfc2822\", \"\");\n+\n+        for (String dataFormat : ImmutableList.of(\"custom-date-time\", \"iso8601\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4Mjk2MzY2OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestMillisecondsJsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODo0ODo1N1rOHHCR-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODo0ODo1N1rOHHCR-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEzOTQ1MQ==", "bodyText": "inline and static import", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r477139451", "createdAt": "2020-08-26T08:48:57Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestMillisecondsJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.util.TimeConversions.scaleNanosToMillis;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+import static java.time.temporal.ChronoField.EPOCH_DAY;\n+import static java.time.temporal.ChronoField.NANO_OF_DAY;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+\n+public class TestMillisecondsJsonDateTimeFormatter\n+{\n+    private static final DateTimeFormat DATE_TIME_FORMAT = DateTimeFormat.MILLISECONDS_SINCE_EPOCH;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4Mjk3MDE3OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestRFC2822JsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODo1MDoyN1rOHHCVvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODo1MDoyN1rOHHCVvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE0MDQxMg==", "bodyText": "same question about timezone. Why are we always going for UTC and do not use the TZ from value?", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r477140412", "createdAt": "2020-08-26T08:50:27Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestRFC2822JsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestRFC2822JsonDateTimeFormatter\n+{\n+    private static final DateTimeFormat DATE_TIME_FORMAT = DateTimeFormat.RFC2822;\n+\n+    private void testTimestamp(SqlTimestamp value, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.empty()).formatTimestamp(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, String expectedLiteral)\n+    {\n+        String actualLiteral = DATE_TIME_FORMAT.getFormatter(Optional.empty()).formatTimestampWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    @Test\n+    public void testRFC2822DateTimeFunctions()\n+    {\n+        testTimestamp(sqlTimestampOf(3, 2020, 8, 18, 12, 38, 29, 0), \"Tue Aug 18 12:38:29 +0000 2020\");\n+        testTimestamp(sqlTimestampOf(3, 1970, 1, 1, 0, 0, 0, 0), \"Thu Jan 01 00:00:00 +0000 1970\");\n+        testTimestamp(sqlTimestampOf(3, 1800, 8, 18, 12, 38, 29, 0), \"Mon Aug 18 12:38:29 +0000 1800\");\n+\n+        testTimestampWithTZ(sqlTimestampWithTimeZoneOf(3, 2020, 8, 19, 12, 23, 41, 0, UTC_KEY), \"Wed Aug 19 12:23:41 +0000 2020\");\n+        testTimestampWithTZ(sqlTimestampWithTimeZoneOf(3, 2020, 8, 19, 12, 23, 41, 0, TimeZoneKey.getTimeZoneKey(\"America/New_York\")), \"Wed Aug 19 12:23:41 +0000 2020\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4Mjk3MTUwOnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestRFC2822JsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODo1MDo0OFrOHHCWjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODo1MDo0OFrOHHCWjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE0MDYyMQ==", "bodyText": "inline and static import", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r477140621", "createdAt": "2020-08-26T08:50:48Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestRFC2822JsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestRFC2822JsonDateTimeFormatter\n+{\n+    private static final DateTimeFormat DATE_TIME_FORMAT = DateTimeFormat.RFC2822;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4Mjk3MjYxOnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestSecondsJsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODo1MTowN1rOHHCXPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODo1MTowN1rOHHCXPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE0MDc5OQ==", "bodyText": "inline and static import", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r477140799", "createdAt": "2020-08-26T08:51:07Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestSecondsJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneOffset;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestSecondsJsonDateTimeFormatter\n+{\n+    private static final DateTimeFormat DATE_TIME_FORMAT = DateTimeFormat.SECONDS_SINCE_EPOCH;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzU1NTk1OnYy", "diffSide": "RIGHT", "path": "presto-docs/src/main/sphinx/connector/kafka.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwOTozOTozOVrOHKuR7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwOTozOTozOVrOHKuR7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAwNjA2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * ``dataFormat`` - name of temporal formatter to use\n          \n          \n            \n            * ``dataFormat`` - name of formatter (required for temporal types)", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r481006060", "createdAt": "2020-09-01T09:39:39Z", "author": {"login": "losipiuk"}, "path": "presto-docs/src/main/sphinx/connector/kafka.rst", "diffHunk": "@@ -509,17 +509,71 @@ For fields, the following attributes are supported:\n * ``type`` - Presto type of column.\n * ``mapping`` - slash-separated list of field names to select a field from the\n   JSON object\n+* ``dataFormat`` - name of temporal formatter to use", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzU2MjM4OnYy", "diffSide": "RIGHT", "path": "presto-docs/src/main/sphinx/connector/kafka.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwOTo0MToyMFrOHKuVzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwOTo0MToyMFrOHKuVzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAwNzA1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * ``formatHint`` - pattern to format temporal data, only use for ``custom-date-time``\n          \n          \n            \n            * ``formatHint`` - pattern to format temporal data (only use with ``custom-date-time`` formatter)", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r481007054", "createdAt": "2020-09-01T09:41:20Z", "author": {"login": "losipiuk"}, "path": "presto-docs/src/main/sphinx/connector/kafka.rst", "diffHunk": "@@ -509,17 +509,71 @@ For fields, the following attributes are supported:\n * ``type`` - Presto type of column.\n * ``mapping`` - slash-separated list of field names to select a field from the\n   JSON object\n+* ``dataFormat`` - name of temporal formatter to use\n+* ``formatHint`` - pattern to format temporal data, only use for ``custom-date-time``", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzU3NDA4OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/TestKafkaIntegrationSmokeTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwOTo0NDoyNlrOHKuc2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwOTo0NDoyNlrOHKuc2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAwODg1OQ==", "bodyText": "nit: testJsonDateTimeFormatsRoundTrip?", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r481008859", "createdAt": "2020-09-01T09:44:26Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/TestKafkaIntegrationSmokeTest.java", "diffHunk": "@@ -262,11 +287,220 @@ private KafkaTopicDescription createDescription(String name, String schema, Stri\n         return Optional.of(new KafkaTopicFieldGroup(dataFormat, Optional.empty(), fields));\n     }\n \n+    private KafkaTopicFieldDescription createOneFieldDescription(String name, Type type, String dataFormat, Optional<String> formatHint)\n+    {\n+        return formatHint.map(s -> new KafkaTopicFieldDescription(name, type, name, null, dataFormat, s, false))\n+                .orElseGet(() -> new KafkaTopicFieldDescription(name, type, name, null, dataFormat, null, false));\n+    }\n+\n     private KafkaTopicFieldDescription createOneFieldDescription(String name, Type type, String mapping, String dataFormat)\n     {\n         return new KafkaTopicFieldDescription(name, type, mapping, null, dataFormat, null, false);\n     }\n \n+    @Test(dataProvider = \"jsonDateTimeFormatsDataProvider\")\n+    public void testJsonDateTimeFormats(JsonDateTimeTestCase testCase)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzk5MjQ5OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMTozOTo1NVrOHKyY4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwMDozMDo0OFrOHM7oQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA3MzM3OQ==", "bodyText": "Encoding for \"TIME WITH TIMEZONE\" and \"TIMESTAMP WITH TIMEZONE\" are incorrect. The time/timestamp part should be encoded exactly the same as specified in sqlTimeWithTimeZoneOf. If we are changing timezone, only timezone in output string should change.\nSo sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.ofHours(2)) should encode to 10:23:35.123 +0200.\nThis is implemented correctly for ISO8601. Edit: ISO8601 has it correct for TIME WITH TIMEZONE but not for TIMESTAMP WITH TIMEZONE", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r481073379", "createdAt": "2020-09-01T11:39:55Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonDateTimeFormatter;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneOffset;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat.CUSTOM_DATE_TIME;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlDateOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestCustomJsonDateTimeFormatter\n+{\n+    private JsonDateTimeFormatter getFormatter(String formatHint)\n+    {\n+        return CUSTOM_DATE_TIME.getFormatter(Optional.of(formatHint));\n+    }\n+\n+    private void testDate(SqlDate value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatDate(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTime(SqlTime value, String formatHint, int precision, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatTime(value, precision);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatTimeWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatTimestamp(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatTimestampWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    @Test\n+    public void testCustomDateTimeFunctions()\n+    {\n+        testDate(sqlDateOf(2020, 8, 14), \"yyyy-MM-dd\", \"2020-08-14\");\n+        testDate(sqlDateOf(1970, 1, 1), \"yyyy-MM-dd\", \"1970-01-01\");\n+        testDate(sqlDateOf(1900, 1, 1), \"yyyy-MM-dd\", \"1900-01-01\");\n+        testDate(sqlDateOf(3001, 1, 1), \"yyyy-MM-dd\", \"3001-01-01\");\n+\n+        testTime(sqlTimeOf(3, 15, 36, 25, 123000000), \"HH:mm:ss.SSS\", 3, \"15:36:25.123\");\n+        testTime(sqlTimeOf(3, 15, 36, 25, 0), \"HH:mm:ss\", 3, \"15:36:25\");\n+        testTime(sqlTimeOf(3, 8, 12, 45, 987000000), \"HH:mm:ss.SSS\", 3, \"08:12:45.987\");\n+        testTime(sqlTimeOf(3, 0, 0, 0, 0), \"HH:mm:ss.SSS\", 3, \"00:00:00.000\");\n+        testTime(sqlTimeOf(3, 23, 59, 59, 999000000), \"HH:mm:ss.SSS\", 3, \"23:59:59.999\");\n+\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.UTC), \"HH:mm:ss.SSS Z\", \"10:23:35.123 +0000\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(0, 0, 0, 0, ZoneOffset.UTC), \"HH:mm:ss.SSS Z\", \"00:00:00.000 +0000\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.ofHours(2)), \"HH:mm:ss.SSS Z\", \"12:23:35.123 +0200\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1MjU1OA==", "bodyText": "You're right, the problem was with sqlTimeWithTimeZoneOf and SqlTimestampWithTimeZone functions", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r481352558", "createdAt": "2020-09-01T18:39:50Z", "author": {"login": "charlesjmorgan"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonDateTimeFormatter;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneOffset;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat.CUSTOM_DATE_TIME;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlDateOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestCustomJsonDateTimeFormatter\n+{\n+    private JsonDateTimeFormatter getFormatter(String formatHint)\n+    {\n+        return CUSTOM_DATE_TIME.getFormatter(Optional.of(formatHint));\n+    }\n+\n+    private void testDate(SqlDate value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatDate(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTime(SqlTime value, String formatHint, int precision, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatTime(value, precision);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatTimeWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatTimestamp(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatTimestampWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    @Test\n+    public void testCustomDateTimeFunctions()\n+    {\n+        testDate(sqlDateOf(2020, 8, 14), \"yyyy-MM-dd\", \"2020-08-14\");\n+        testDate(sqlDateOf(1970, 1, 1), \"yyyy-MM-dd\", \"1970-01-01\");\n+        testDate(sqlDateOf(1900, 1, 1), \"yyyy-MM-dd\", \"1900-01-01\");\n+        testDate(sqlDateOf(3001, 1, 1), \"yyyy-MM-dd\", \"3001-01-01\");\n+\n+        testTime(sqlTimeOf(3, 15, 36, 25, 123000000), \"HH:mm:ss.SSS\", 3, \"15:36:25.123\");\n+        testTime(sqlTimeOf(3, 15, 36, 25, 0), \"HH:mm:ss\", 3, \"15:36:25\");\n+        testTime(sqlTimeOf(3, 8, 12, 45, 987000000), \"HH:mm:ss.SSS\", 3, \"08:12:45.987\");\n+        testTime(sqlTimeOf(3, 0, 0, 0, 0), \"HH:mm:ss.SSS\", 3, \"00:00:00.000\");\n+        testTime(sqlTimeOf(3, 23, 59, 59, 999000000), \"HH:mm:ss.SSS\", 3, \"23:59:59.999\");\n+\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.UTC), \"HH:mm:ss.SSS Z\", \"10:23:35.123 +0000\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(0, 0, 0, 0, ZoneOffset.UTC), \"HH:mm:ss.SSS Z\", \"00:00:00.000 +0000\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.ofHours(2)), \"HH:mm:ss.SSS Z\", \"12:23:35.123 +0200\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA3MzM3OQ=="}, "originalCommit": null, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2NTMzOA==", "bodyText": "and the formatting for TIME WITH TIME ZONE in the custom formatter", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r481365338", "createdAt": "2020-09-01T18:58:34Z", "author": {"login": "charlesjmorgan"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonDateTimeFormatter;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneOffset;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat.CUSTOM_DATE_TIME;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlDateOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestCustomJsonDateTimeFormatter\n+{\n+    private JsonDateTimeFormatter getFormatter(String formatHint)\n+    {\n+        return CUSTOM_DATE_TIME.getFormatter(Optional.of(formatHint));\n+    }\n+\n+    private void testDate(SqlDate value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatDate(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTime(SqlTime value, String formatHint, int precision, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatTime(value, precision);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatTimeWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatTimestamp(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatTimestampWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    @Test\n+    public void testCustomDateTimeFunctions()\n+    {\n+        testDate(sqlDateOf(2020, 8, 14), \"yyyy-MM-dd\", \"2020-08-14\");\n+        testDate(sqlDateOf(1970, 1, 1), \"yyyy-MM-dd\", \"1970-01-01\");\n+        testDate(sqlDateOf(1900, 1, 1), \"yyyy-MM-dd\", \"1900-01-01\");\n+        testDate(sqlDateOf(3001, 1, 1), \"yyyy-MM-dd\", \"3001-01-01\");\n+\n+        testTime(sqlTimeOf(3, 15, 36, 25, 123000000), \"HH:mm:ss.SSS\", 3, \"15:36:25.123\");\n+        testTime(sqlTimeOf(3, 15, 36, 25, 0), \"HH:mm:ss\", 3, \"15:36:25\");\n+        testTime(sqlTimeOf(3, 8, 12, 45, 987000000), \"HH:mm:ss.SSS\", 3, \"08:12:45.987\");\n+        testTime(sqlTimeOf(3, 0, 0, 0, 0), \"HH:mm:ss.SSS\", 3, \"00:00:00.000\");\n+        testTime(sqlTimeOf(3, 23, 59, 59, 999000000), \"HH:mm:ss.SSS\", 3, \"23:59:59.999\");\n+\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.UTC), \"HH:mm:ss.SSS Z\", \"10:23:35.123 +0000\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(0, 0, 0, 0, ZoneOffset.UTC), \"HH:mm:ss.SSS Z\", \"00:00:00.000 +0000\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.ofHours(2)), \"HH:mm:ss.SSS Z\", \"12:23:35.123 +0200\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA3MzM3OQ=="}, "originalCommit": null, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMyMTkyMQ==", "bodyText": "Good catch, I think there was a problem with the iso8601 decoder. I changed the return value for time with time zone type in io.prestosql.decoder.json.ISO8601JsonFieldDecoder.ISO8601JsonValueProvider#getLong to account for the offset.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r483321921", "createdAt": "2020-09-04T00:30:48Z", "author": {"login": "charlesjmorgan"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestCustomJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonDateTimeFormatter;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneOffset;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat.CUSTOM_DATE_TIME;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlDateOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestCustomJsonDateTimeFormatter\n+{\n+    private JsonDateTimeFormatter getFormatter(String formatHint)\n+    {\n+        return CUSTOM_DATE_TIME.getFormatter(Optional.of(formatHint));\n+    }\n+\n+    private void testDate(SqlDate value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatDate(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTime(SqlTime value, String formatHint, int precision, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatTime(value, precision);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatTimeWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatTimestamp(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, String formatHint, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter(formatHint).formatTimestampWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    @Test\n+    public void testCustomDateTimeFunctions()\n+    {\n+        testDate(sqlDateOf(2020, 8, 14), \"yyyy-MM-dd\", \"2020-08-14\");\n+        testDate(sqlDateOf(1970, 1, 1), \"yyyy-MM-dd\", \"1970-01-01\");\n+        testDate(sqlDateOf(1900, 1, 1), \"yyyy-MM-dd\", \"1900-01-01\");\n+        testDate(sqlDateOf(3001, 1, 1), \"yyyy-MM-dd\", \"3001-01-01\");\n+\n+        testTime(sqlTimeOf(3, 15, 36, 25, 123000000), \"HH:mm:ss.SSS\", 3, \"15:36:25.123\");\n+        testTime(sqlTimeOf(3, 15, 36, 25, 0), \"HH:mm:ss\", 3, \"15:36:25\");\n+        testTime(sqlTimeOf(3, 8, 12, 45, 987000000), \"HH:mm:ss.SSS\", 3, \"08:12:45.987\");\n+        testTime(sqlTimeOf(3, 0, 0, 0, 0), \"HH:mm:ss.SSS\", 3, \"00:00:00.000\");\n+        testTime(sqlTimeOf(3, 23, 59, 59, 999000000), \"HH:mm:ss.SSS\", 3, \"23:59:59.999\");\n+\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.UTC), \"HH:mm:ss.SSS Z\", \"10:23:35.123 +0000\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(0, 0, 0, 0, ZoneOffset.UTC), \"HH:mm:ss.SSS Z\", \"00:00:00.000 +0000\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.ofHours(2)), \"HH:mm:ss.SSS Z\", \"12:23:35.123 +0200\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA3MzM3OQ=="}, "originalCommit": null, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODA2ODM4OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestISO8601JsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMjowMjowNlrOHKzGVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMjowMjowNlrOHKzGVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA4NTAxMw==", "bodyText": "time in encoded value should match time in sqlTimestampWithTimeZoneOf", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r481085013", "createdAt": "2020-09-01T12:02:06Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestISO8601JsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonDateTimeFormatter;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.ZoneOffset;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat.ISO8601;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlDateOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestISO8601JsonDateTimeFormatter\n+{\n+    private JsonDateTimeFormatter getFormatter()\n+    {\n+        return ISO8601.getFormatter(Optional.empty());\n+    }\n+\n+    private void testDate(SqlDate value, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter().formatDate(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTime(SqlTime value, int precision, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter().formatTime(value, precision);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter().formatTimeWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter().formatTimestamp(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter().formatTimestampWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    @Test\n+    public void testISO8601DateTimeFunctions()\n+    {\n+        testDate(sqlDateOf(2020, 8, 14), \"2020-08-14\");\n+        testDate(sqlDateOf(1970, 1, 1), \"1970-01-01\");\n+        testDate(sqlDateOf(1900, 1, 1), \"1900-01-01\");\n+        testDate(sqlDateOf(3001, 1, 1), \"3001-01-01\");\n+\n+        testTime(sqlTimeOf(3, 15, 36, 25, 123000000), 3, \"15:36:25.123\");\n+        testTime(sqlTimeOf(3, 15, 36, 25, 0), 3, \"15:36:25\");\n+        testTime(sqlTimeOf(3, 8, 12, 45, 987000000), 3, \"08:12:45.987\");\n+        testTime(sqlTimeOf(3, 0, 0, 0, 0), 3, \"00:00\");\n+        testTime(sqlTimeOf(3, 23, 59, 59, 999000000), 3, \"23:59:59.999\");\n+\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.UTC), \"10:23:35.123Z\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(0, 0, 0, 0, ZoneOffset.UTC), \"00:00:00Z\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.ofHours(2)), \"10:23:35.123+02:00\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.ofHours(10)), \"10:23:35.123+10:00\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 123000000, ZoneOffset.ofHours(-10)), \"10:23:35.123-10:00\");\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(23, 59, 59, 999000000, ZoneOffset.UTC), \"23:59:59.999Z\");\n+\n+        testTimestamp(sqlTimestampOf(3, 2020, 8, 18, 12, 38, 29, 123), \"2020-08-18T12:38:29.123\");\n+        testTimestamp(sqlTimestampOf(3, 1970, 1, 1, 0, 0, 0, 0), \"1970-01-01T00:00\");\n+        testTimestamp(sqlTimestampOf(3, 1800, 8, 18, 12, 38, 29, 123), \"1800-08-18T12:38:29.123\");\n+\n+        testTimestampWithTZ(sqlTimestampWithTimeZoneOf(3, 2020, 8, 19, 12, 23, 41, 123000000, UTC_KEY), \"2020-08-19T12:23:41.124Z\");\n+        testTimestampWithTZ(sqlTimestampWithTimeZoneOf(3, 2020, 8, 19, 12, 23, 41, 123000000, TimeZoneKey.getTimeZoneKey(\"America/New_York\")), \"2020-08-19T08:23:41.124-04:00\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODA3MDUxOnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestRFC2822JsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMjowMjo0MlrOHKzHrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMjowMjo0MlrOHKzHrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA4NTM1Ng==", "bodyText": "same here", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r481085356", "createdAt": "2020-09-01T12:02:42Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestRFC2822JsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonDateTimeFormatter;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat.RFC2822;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestRFC2822JsonDateTimeFormatter\n+{\n+    private JsonDateTimeFormatter getFormatter()\n+    {\n+        return RFC2822.getFormatter(Optional.empty());\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter().formatTimestamp(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter().formatTimestampWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    @Test\n+    public void testRFC2822DateTimeFunctions()\n+    {\n+        testTimestamp(sqlTimestampOf(3, 2020, 8, 18, 12, 38, 29, 0), \"Tue Aug 18 12:38:29 +0000 2020\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODA3MDg5OnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestRFC2822JsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMjowMjo0OFrOHKzH5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMjowMjo0OFrOHKzH5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA4NTQxMw==", "bodyText": "same here", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r481085413", "createdAt": "2020-09-01T12:02:48Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestRFC2822JsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonDateTimeFormatter;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat.RFC2822;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestRFC2822JsonDateTimeFormatter\n+{\n+    private JsonDateTimeFormatter getFormatter()\n+    {\n+        return RFC2822.getFormatter(Optional.empty());\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter().formatTimestamp(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, String expectedLiteral)\n+    {\n+        String actualLiteral = getFormatter().formatTimestampWithZone(value);\n+        assertEquals(actualLiteral, expectedLiteral);\n+    }\n+\n+    @Test\n+    public void testRFC2822DateTimeFunctions()\n+    {\n+        testTimestamp(sqlTimestampOf(3, 2020, 8, 18, 12, 38, 29, 0), \"Tue Aug 18 12:38:29 +0000 2020\");\n+        testTimestamp(sqlTimestampOf(3, 1970, 1, 1, 0, 0, 0, 0), \"Thu Jan 01 00:00:00 +0000 1970\");\n+        testTimestamp(sqlTimestampOf(3, 1800, 8, 18, 12, 38, 29, 0), \"Mon Aug 18 12:38:29 +0000 1800\");\n+\n+        testTimestampWithTZ(sqlTimestampWithTimeZoneOf(3, 2020, 8, 19, 12, 23, 41, 0, UTC_KEY), \"Wed Aug 19 12:23:41 +0000 2020\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODA3ODEyOnYy", "diffSide": "RIGHT", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestSecondsJsonDateTimeFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMjowNDo1M1rOHKzMQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMjowNDo1M1rOHKzMQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA4NjUyOA==", "bodyText": "same here", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r481086528", "createdAt": "2020-09-01T12:04:53Z", "author": {"login": "losipiuk"}, "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestSecondsJsonDateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonDateTimeFormatter;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import org.testng.annotations.Test;\n+\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneOffset;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.DateTimeFormat.SECONDS_SINCE_EPOCH;\n+import static io.prestosql.spi.type.TimeZoneKey.UTC_KEY;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimeWithTimeZoneOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampOf;\n+import static io.prestosql.testing.DateTimeTestingUtils.sqlTimestampWithTimeZoneOf;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestSecondsJsonDateTimeFormatter\n+{\n+    private JsonDateTimeFormatter getFormatter()\n+    {\n+        return SECONDS_SINCE_EPOCH.getFormatter(Optional.empty());\n+    }\n+\n+    private void testTime(SqlTime value, int precision, long actualSeconds)\n+    {\n+        String formattedStr = getFormatter().formatTime(value, precision);\n+        assertEquals(Long.parseLong(formattedStr), actualSeconds);\n+    }\n+\n+    private void testTimeWithTZ(SqlTimeWithTimeZone value, long actualSeconds)\n+    {\n+        String formattedStr = getFormatter().formatTimeWithZone(value);\n+        assertEquals(Long.parseLong(formattedStr), actualSeconds);\n+    }\n+\n+    private void testTimestamp(SqlTimestamp value, long actualSeconds)\n+    {\n+        String formattedStr = getFormatter().formatTimestamp(value);\n+        assertEquals(Long.parseLong(formattedStr), actualSeconds);\n+    }\n+\n+    private void testTimestampWithTZ(SqlTimestampWithTimeZone value, long actualSeconds)\n+    {\n+        String formattedStr = getFormatter().formatTimestampWithZone(value);\n+        assertEquals(Long.parseLong(formattedStr), actualSeconds);\n+    }\n+\n+    @Test\n+    public void testSecondsDateTimeFunctions()\n+    {\n+        testTime(sqlTimeOf(3, 15, 36, 25, 0), 3, LocalTime.of(15, 36, 25, 0).toSecondOfDay());\n+        testTime(sqlTimeOf(3, 0, 0, 0, 0), 3, 0);\n+        testTime(sqlTimeOf(3, 23, 59, 59, 0), 3, LocalTime.of(23, 59, 59, 0).toSecondOfDay());\n+\n+        testTimeWithTZ(sqlTimeWithTimeZoneOf(10, 23, 35, 0, ZoneOffset.UTC), LocalTime.of(10, 23, 35, 0).toSecondOfDay());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyODk2MTI5OnYy", "diffSide": "RIGHT", "path": "presto-record-decoder/src/main/java/io/prestosql/decoder/json/AbstractDateTimeJsonValueProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwOTozOToxMlrOHN4UQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwOTozOToxMlrOHN4UQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxNjIyNw==", "bodyText": "I am concerned by the fact that no tests were broken by those change.\nIt looks like we are lacking decoding to TIME WTZ with input having timezone in input different than UTC.\nCan you add test coverage to:\n\nTestCustomDateTimeJsonFieldDecoder\nTestISO8601JsonFieldDecoder\nTestRFC2822JsonFieldDecoder (optionally - as we should drop support for TIME/TIME WTZ  here)", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r484316227", "createdAt": "2020-09-07T09:39:12Z", "author": {"login": "losipiuk"}, "path": "presto-record-decoder/src/main/java/io/prestosql/decoder/json/AbstractDateTimeJsonValueProvider.java", "diffHunk": "@@ -81,7 +83,8 @@ public final long getLong()\n             return packDateTimeWithZone(millis, getTimeZone());\n         }\n         if (type.equals(TIME_WITH_TIME_ZONE)) {\n-            return packTimeWithTimeZone(millis * NANOSECONDS_PER_MILLISECOND, 0);\n+            int offsetMinutes = getTimeZone().getZoneId().getRules().getOffset(Instant.ofEpochMilli(millis)).getTotalSeconds() / 60;\n+            return packTimeWithTimeZone((millis + (offsetMinutes * 60 * MILLISECONDS_PER_SECOND)) * NANOSECONDS_PER_MILLISECOND, offsetMinutes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTM4MjUxOnYy", "diffSide": "RIGHT", "path": "presto-docs/src/main/sphinx/connector/kafka.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMTo1OTo0NVrOHOz6JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMTo1OTo0NVrOHOz6JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI5MjU4MA==", "bodyText": "These changes don't seem on the right commit.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r485292580", "createdAt": "2020-09-09T01:59:45Z", "author": {"login": "aalbu"}, "path": "presto-docs/src/main/sphinx/connector/kafka.rst", "diffHunk": "@@ -820,12 +820,17 @@ which can be specified via ``dataFormat`` attribute.\n | | ``VARCHAR``                       |                                                                                |\n | | ``VARCHAR(x)``                    |                                                                                |\n +-------------------------------------+--------------------------------------------------------------------------------+\n+| | ``DATE``                          | ``custom-date-time``, ``iso8601``                                              |\n++-------------------------------------+--------------------------------------------------------------------------------+\n+| | ``TIME``                          | ``custom-date-time``, ``iso8601``, ``milliseconds-since-epoch``,               |\n+| |                                   | ``seconds-since-epoch``                                                        |\n++-------------------------------------+--------------------------------------------------------------------------------+\n+| | ``TIME WITH TIME ZONE``           | ``custom-date-time``, ``iso8601``                                              |\n++-------------------------------------+--------------------------------------------------------------------------------+\n | | ``TIMESTAMP``                     | ``custom-date-time``, ``iso8601``, ``rfc2822``,                                |\n-| | ``TIMESTAMP WITH TIME ZONE``      | ``milliseconds-since-epoch``, ``seconds-since-epoch``                          |\n-| | ``TIME``                          |                                                                                |\n-| | ``TIME WITH TIME ZONE``           |                                                                                |\n+| |                                   | ``milliseconds-since-epoch``, ``seconds-since-epoch``                          |\n +-------------------------------------+--------------------------------------------------------------------------------+\n-| ``DATE``                            | ``custom-date-time``, ``iso8601``, ``rfc2822``,                                |\n+| | ``TIMESTAMP WITH TIME ZONE``      | ``custom-date-time``, ``iso8601``, ``rfc2822``                                 |", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTM5NDUxOnYy", "diffSide": "LEFT", "path": "presto-record-decoder/src/main/java/io/prestosql/decoder/json/RFC2822JsonFieldDecoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMjowNTo1MVrOHO0BFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMjowNTo1MVrOHO0BFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI5NDM1Ng==", "bodyText": "It looks like tests still reference these types.", "url": "https://github.com/trinodb/trino/pull/4743#discussion_r485294356", "createdAt": "2020-09-09T02:05:51Z", "author": {"login": "aalbu"}, "path": "presto-record-decoder/src/main/java/io/prestosql/decoder/json/RFC2822JsonFieldDecoder.java", "diffHunk": "@@ -46,7 +43,7 @@\n public class RFC2822JsonFieldDecoder\n         implements JsonFieldDecoder\n {\n-    private static final Set<Type> SUPPORTED_TYPES = ImmutableSet.of(DATE, TIME, TIME_WITH_TIME_ZONE, TIMESTAMP_MILLIS, TIMESTAMP_WITH_TIME_ZONE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3406, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}