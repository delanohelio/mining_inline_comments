{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2MjI4MTQw", "number": 3697, "title": "SPI and engine changes for aggregation pushdown", "bodyText": "\u2026connectors.\nThe commit also includes the top level optimizer rule and feature config to control\nthe experimental behavior.", "createdAt": "2020-05-11T17:03:02Z", "url": "https://github.com/trinodb/trino/pull/3697", "merged": true, "mergeCommit": {"oid": "4052f33284a6cdf9f7a5267b32d1afd80761008a"}, "closed": true, "closedAt": "2020-06-11T21:54:24Z", "author": {"login": "Parth-Brahmbhatt"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcgs6oDgFqTQxMDM3NTMzMg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcqSPlggBqjM0MzUzNDIxODk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwMzc1MzMy", "url": "https://github.com/trinodb/trino/pull/3697#pullrequestreview-410375332", "createdAt": "2020-05-12T19:56:16Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxOTo1NjoxN1rOGUWpjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMzoyOTo1NFrOGUcdUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5NTc4OA==", "bodyText": "I don't think we need a global toggle for this. Connectors can choose whether to support aggregation pushdown by not implementing the new API (or doing it selectively, possibly based on a connector-specific setting)", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r423995788", "createdAt": "2020-05-12T19:56:17Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/SystemSessionProperties.java", "diffHunk": "@@ -564,7 +565,12 @@ public SystemSessionProperties(\n                         COST_ESTIMATION_WORKER_COUNT,\n                         \"Set the estimate count of workers while planning\",\n                         null,\n-                        true));\n+                        true),\n+                booleanProperty(\n+                        ENABLE_AGG_PUSHDOWN,\n+                        \"Enable aggregate pushdown\",\n+                        featuresConfig.isEnableAggPushdown(),\n+                        false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5NzY5OQ==", "bodyText": "Remove these since there are no details.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r423997699", "createdAt": "2020-05-12T19:59:45Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate\n+     *          v0 = agg_fn1(a)\n+     *          v1 = agg_fn2(b, 2)\n+     *          v2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call {@link #applyAggregation} with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [v0 = agg_fn1 (input=[a]), v1= agg_fn2(input=[b,2])]\n+     * group_by=[c]\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle agg_fn1(...) and agg_fn2(...), it would return:\n+     *\n+     * <pre>\n+     * handle = TH1\n+     * assignments = [\n+     *     v0 = CH0 (synthetic column for agg_fn1(a))\n+     *     v1 = CH1 (synthetic column for agg_fn2(b,2))\n+     *     v2 = CH3 (for column c)\n+     * ]\n+     * </pre>\n+     * @param session\n+     * @param handle\n+     * @param aggregates\n+     * @param assignments\n+     * @param groupBy\n+     * @return", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5ODQwOA==", "bodyText": "Why is groupBy a list of lists? For grouping sets?", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r423998408", "createdAt": "2020-05-12T20:00:57Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate\n+     *          v0 = agg_fn1(a)\n+     *          v1 = agg_fn2(b, 2)\n+     *          v2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call {@link #applyAggregation} with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [v0 = agg_fn1 (input=[a]), v1= agg_fn2(input=[b,2])]\n+     * group_by=[c]\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle agg_fn1(...) and agg_fn2(...), it would return:\n+     *\n+     * <pre>\n+     * handle = TH1\n+     * assignments = [\n+     *     v0 = CH0 (synthetic column for agg_fn1(a))\n+     *     v1 = CH1 (synthetic column for agg_fn2(b,2))\n+     *     v2 = CH3 (for column c)\n+     * ]\n+     * </pre>\n+     * @param session\n+     * @param handle\n+     * @param aggregates\n+     * @param assignments\n+     * @param groupBy\n+     * @return\n+     */\n+    default Optional<AggregatePushdownResult<ConnectorTableHandle>> applyAggregation(ConnectorSession session, ConnectorTableHandle handle, List<AggregateFunction> aggregates,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3MzkzMw==", "bodyText": "Ordering of the sorting clauses matters, so this should be a list of tuples containing an expression and a sort order.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424073933", "createdAt": "2020-05-12T22:39:31Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here\n+    private final String aggregateFunctionName;\n+    private final List<ConnectorExpression> inputs;\n+    private final Type outputType;\n+    private final Optional<List<ConnectorExpression>> sortBy;\n+    private final Optional<Map<ConnectorExpression, SortOrder>> sortOrder;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3NDEyMg==", "bodyText": "Rename to functionName", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424074122", "createdAt": "2020-05-12T22:39:56Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here\n+    private final String aggregateFunctionName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3OTkyOA==", "bodyText": "This shouldn't be here. The applyAggregation call should return a list of ConnectorExpression in the same order as the provided list of aggregations. With that, it can know which aggregation corresponds to which output. It should also return a list of Assignments similar to applyProjection. The idea is that given the following:\nAggregation\n        f1 := count(x)\n        f2 := count(x)\n    TableScan(TH0)\n            x = CH0\n\napplyAggregation would be called with:\ntable = TH0\naggregates = [count(x), count(x)]\nassignments = { x = CH0 }\ngroupBy = {}\n\nand would return:\ntable = TH0'\nprojections = [y, y]\nassignments = { y = CH0' }\n\nIt also allows for more sophisticated scenarios. For instance, given the following plan and a connector that can only compute sum(column):\nAggregation\n        f1 := sum(x)\n        f2 := sum(x+y)\n    TableScan(TH0)\n            x = CH0\n            y = CH1\n\nit could return:\ntable = TH1\nprojections = [a, a + b]\nassignments = { a = CH0', b = CH1' }\n\nwhere CH0' would be mapped internally to sum(CH0) and CH1' to sum(CH1) by decomposing sum(CH0 + CH1) into sum(CH0) + sum(CH1)", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424079928", "createdAt": "2020-05-12T22:56:14Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MDE5Ng==", "bodyText": "Rename to AggregationPushdownResult", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424080196", "createdAt": "2020-05-12T22:57:02Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregatePushdownResult.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import java.util.List;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregatePushdownResult<T>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MTI5NQ==", "bodyText": "Let's move Assignment to the top-level and use it here.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424081295", "createdAt": "2020-05-12T22:59:52Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregatePushdownResult.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import java.util.List;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregatePushdownResult<T>\n+{\n+    private final T handle;\n+    private final List<ProjectionApplicationResult.Assignment> assignments;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MjMzMw==", "bodyText": "Masks are not needed -- they are used as a way to \"implement\" filters and distinct. However, we should have a field for the filter, even if we don't initially support them. That way, connectors will have to explicitly opt out from handling them and it will be easier to introduce support later without changing semantics.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424082333", "createdAt": "2020-05-12T23:03:02Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here\n+    private final String aggregateFunctionName;\n+    private final List<ConnectorExpression> inputs;\n+    private final Type outputType;\n+    private final Optional<List<ConnectorExpression>> sortBy;\n+    private final Optional<Map<ConnectorExpression, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    // TODO It is unclear if filtering and mask from the aggregate needs to be forwarded to connectors so skipping them for now.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MzgyNg==", "bodyText": "Let's add another class to represent this. We should eventually retrofit the one in spi.block to use the new one.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424083826", "createdAt": "2020-05-12T23:07:31Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NDIzMQ==", "bodyText": "This package is about function implementations. Move this class to the package containing the other pushdown-related classes (ApplyProjectionResult, ApplyAggregationResult, etc).", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424084231", "createdAt": "2020-05-12T23:08:29Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NDQ2MQ==", "bodyText": "No need to a \"rule set\". This is just a single rule, so remove the wrapper layer.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424084461", "createdAt": "2020-05-12T23:09:16Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NDU3Nw==", "bodyText": "Rename to PATTERN", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424084577", "createdAt": "2020-05-12T23:09:36Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NDk4Nw==", "bodyText": "Also, format as:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n          \n          \n            \n                private static final Pattern<AggregationNode> PATTERN = aggregation()\n          \n          \n            \n                        .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424084987", "createdAt": "2020-05-12T23:10:36Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NDU3Nw=="}, "originalCommit": null, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NTU3Mg==", "bodyText": "This class hierarchy is unnecessary. There's only one implementation. Also, in general, it's better to use composition than inheritance to reuse behavior.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424085572", "createdAt": "2020-05-12T23:12:30Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NTc2OQ==", "bodyText": "This comment seems out of date.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424085769", "createdAt": "2020-05-12T23:13:04Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NjEyNg==", "bodyText": "Don't abbreviate variable names. In this case, I'd just call it result for brevity.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424086126", "createdAt": "2020-05-12T23:14:23Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.\n+                return Result.empty();\n+            }\n+\n+            List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                    .map(assignments::get)\n+                    .collect(toList());\n+\n+            Optional<AggregatePushdownResult<TableHandle>> connectorTableHandleAggregatePushdownResult = metadata.applyAggregation(context.getSession(),\n+                    tableScan.getTable(),\n+                    aggregateFunctions,\n+                    assignments,\n+                    Optional.of(ImmutableList.of(groupByColumns)));\n+\n+            if (!connectorTableHandleAggregatePushdownResult.isPresent()) {\n+                return Result.empty();\n+            }\n+\n+            AggregatePushdownResult<TableHandle> aggPushdownResult = connectorTableHandleAggregatePushdownResult.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NjMxMA==", "bodyText": "Use interface type for collection: List<AggregateFunction>. Also, don't abbreviate names: toAggregateFunction would be better.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424086310", "createdAt": "2020-05-12T23:14:56Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.\n+                return Result.empty();\n+            }\n+\n+            List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                    .map(assignments::get)\n+                    .collect(toList());\n+\n+            Optional<AggregatePushdownResult<TableHandle>> connectorTableHandleAggregatePushdownResult = metadata.applyAggregation(context.getSession(),\n+                    tableScan.getTable(),\n+                    aggregateFunctions,\n+                    assignments,\n+                    Optional.of(ImmutableList.of(groupByColumns)));\n+\n+            if (!connectorTableHandleAggregatePushdownResult.isPresent()) {\n+                return Result.empty();\n+            }\n+\n+            AggregatePushdownResult<TableHandle> aggPushdownResult = connectorTableHandleAggregatePushdownResult.get();\n+\n+            TableHandle handle = aggPushdownResult.getHandle();\n+            ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+            ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+            Map<String, ProjectionApplicationResult.Assignment> nameToAssignment = aggPushdownResult.getAssignments().stream()\n+                    .collect(Collectors.toMap(ProjectionApplicationResult.Assignment::getVariable, Function.identity()));\n+            for (Symbol aggOutputSymbol : node.getOutputSymbols()) {\n+                ProjectionApplicationResult.Assignment assignment = nameToAssignment.get(aggOutputSymbol.getName());\n+\n+                if (assignment == null) {\n+                    //TODO We pushdown all or nothing for V1 but we need to extend this in future.\n+                    return Result.empty();\n+                }\n+                newScanOutputs.add(aggOutputSymbol);\n+                newScanAssignments.put(aggOutputSymbol, assignment.getColumn());\n+            }\n+\n+            return Result.ofPlanNode(\n+                    TableScanNode.newInstance(\n+                            tableScan.getId(),\n+                            handle,\n+                            newScanOutputs.build(),\n+                            newScanAssignments.build()));\n+        }\n+    }\n+\n+    private ImmutableList<AggregateFunction> toAggFunction(Map<Symbol, AggregationNode.Aggregation> aggregations)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NjYwMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String aggFunctionName = signature.getName();\n          \n          \n            \n                        String name = signature.getName();", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424086602", "createdAt": "2020-05-12T23:15:54Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.\n+                return Result.empty();\n+            }\n+\n+            List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                    .map(assignments::get)\n+                    .collect(toList());\n+\n+            Optional<AggregatePushdownResult<TableHandle>> connectorTableHandleAggregatePushdownResult = metadata.applyAggregation(context.getSession(),\n+                    tableScan.getTable(),\n+                    aggregateFunctions,\n+                    assignments,\n+                    Optional.of(ImmutableList.of(groupByColumns)));\n+\n+            if (!connectorTableHandleAggregatePushdownResult.isPresent()) {\n+                return Result.empty();\n+            }\n+\n+            AggregatePushdownResult<TableHandle> aggPushdownResult = connectorTableHandleAggregatePushdownResult.get();\n+\n+            TableHandle handle = aggPushdownResult.getHandle();\n+            ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+            ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+            Map<String, ProjectionApplicationResult.Assignment> nameToAssignment = aggPushdownResult.getAssignments().stream()\n+                    .collect(Collectors.toMap(ProjectionApplicationResult.Assignment::getVariable, Function.identity()));\n+            for (Symbol aggOutputSymbol : node.getOutputSymbols()) {\n+                ProjectionApplicationResult.Assignment assignment = nameToAssignment.get(aggOutputSymbol.getName());\n+\n+                if (assignment == null) {\n+                    //TODO We pushdown all or nothing for V1 but we need to extend this in future.\n+                    return Result.empty();\n+                }\n+                newScanOutputs.add(aggOutputSymbol);\n+                newScanAssignments.put(aggOutputSymbol, assignment.getColumn());\n+            }\n+\n+            return Result.ofPlanNode(\n+                    TableScanNode.newInstance(\n+                            tableScan.getId(),\n+                            handle,\n+                            newScanOutputs.build(),\n+                            newScanAssignments.build()));\n+        }\n+    }\n+\n+    private ImmutableList<AggregateFunction> toAggFunction(Map<Symbol, AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (Map.Entry<Symbol, AggregationNode.Aggregation> entry : aggregations.entrySet()) {\n+            AggregationNode.Aggregation aggregation = entry.getValue();\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = typeManager.getType(signature.getReturnType());\n+            String aggFunctionName = signature.getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4ODY0OQ==", "bodyText": "This constructor is unnecessary at this point. Let's rely one the one below until it becomes clear that we need it.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424088649", "createdAt": "2020-05-12T23:22:33Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here\n+    private final String aggregateFunctionName;\n+    private final List<ConnectorExpression> inputs;\n+    private final Type outputType;\n+    private final Optional<List<ConnectorExpression>> sortBy;\n+    private final Optional<Map<ConnectorExpression, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    // TODO It is unclear if filtering and mask from the aggregate needs to be forwarded to connectors so skipping them for now.\n+\n+    public AggregateFunction(String projectionName, String name, List<ConnectorExpression> inputs, Type outputType)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4ODk5NA==", "bodyText": "Move outputType before inputs. That way, if we ever have to add other constructors, it's easier to support varargs for the inputs if needed and keep things consistent.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424088994", "createdAt": "2020-05-12T23:23:41Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here\n+    private final String aggregateFunctionName;\n+    private final List<ConnectorExpression> inputs;\n+    private final Type outputType;\n+    private final Optional<List<ConnectorExpression>> sortBy;\n+    private final Optional<Map<ConnectorExpression, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    // TODO It is unclear if filtering and mask from the aggregate needs to be forwarded to connectors so skipping them for now.\n+\n+    public AggregateFunction(String projectionName, String name, List<ConnectorExpression> inputs, Type outputType)\n+    {\n+        this(projectionName, name, inputs, outputType, Optional.empty(), Optional.empty(), false);\n+    }\n+\n+    public AggregateFunction(String projectionName, String aggregateFunctionName, List<ConnectorExpression> inputs, Type outputType, Optional<List<ConnectorExpression>> sortBy, Optional<Map<ConnectorExpression, SortOrder>> sortOrder, boolean isDistinct)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MDk2MA==", "bodyText": "InternalTypeManager is not meant to be used by anything other that the metadata APIs. use Metadata.getType() in the calls below, instead.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424090960", "createdAt": "2020-05-12T23:29:54Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 72}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwOTAwMjY2", "url": "https://github.com/trinodb/trino/pull/3697#pullrequestreview-410900266", "createdAt": "2020-05-13T13:03:02Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMzowMzowMlrOGUwerw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMzoyNzo0NFrOGUxi_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxODk5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n          \n          \n            \n                 * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times\n          \n      \n    \n    \n  \n\n-- connector cannot assume a method will be called multiple times (it may or may not)", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424418991", "createdAt": "2020-05-13T13:03:02Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxOTMwMQ==", "bodyText": "Optional.empty() -> {@code or {@link it", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424419301", "createdAt": "2020-05-13T13:03:30Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxOTY0Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n          \n          \n            \n                 * If the method returns a result, the list of assignments in the result will replace the existing assignments given", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424419643", "createdAt": "2020-05-13T13:04:02Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyMDgxMw==", "bodyText": "I understand the \"given\" part. It seems it's OK to return partial assignemnts (they will just be ignored).\n(I think it's ok to drop this part of the sentence)", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424420813", "createdAt": "2020-05-13T13:05:52Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyMjIwMQ==", "bodyText": "what does v2 mean here?", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424422201", "createdAt": "2020-05-13T13:07:50Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate\n+     *          v0 = agg_fn1(a)\n+     *          v1 = agg_fn2(b, 2)\n+     *          v2 = group_by c", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyMjc3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *\n          \n          \n            \n                 *  - aggregate\n          \n          \n            \n                 *  - aggregation", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424422777", "createdAt": "2020-05-13T13:08:43Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyMzMwMw==", "bodyText": "i have a warning on this line in IDE, so:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The optimizer would call {@link #applyAggregation} with the following arguments:\n          \n          \n            \n                 * The optimizer would call this method with the following arguments:", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424423303", "createdAt": "2020-05-13T13:09:31Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate\n+     *          v0 = agg_fn1(a)\n+     *          v1 = agg_fn2(b, 2)\n+     *          v2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call {@link #applyAggregation} with the following arguments:", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyNTM0NQ==", "bodyText": "aggregates is list, so not sure how this example translates to actual objects\nHowever, I think actually aggregates could be a Map, with io.prestosql.spi.function.AggregateFunction#projectionName removed, replaced with a Map key.\n(same would apply to pre-existing io.prestosql.spi.connector.ProjectionApplicationResult.Assignment.. @martint ?)", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424425345", "createdAt": "2020-05-13T13:12:34Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate\n+     *          v0 = agg_fn1(a)\n+     *          v1 = agg_fn2(b, 2)\n+     *          v2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call {@link #applyAggregation} with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [v0 = agg_fn1 (input=[a]), v1= agg_fn2(input=[b,2])]", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyNTczMQ==", "bodyText": "The example should also mention assignments", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424425731", "createdAt": "2020-05-13T13:13:06Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate\n+     *          v0 = agg_fn1(a)\n+     *          v1 = agg_fn2(b, 2)\n+     *          v2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call {@link #applyAggregation} with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [v0 = agg_fn1 (input=[a]), v1= agg_fn2(input=[b,2])]\n+     * group_by=[c]", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyNjAwOA==", "bodyText": "wrap agg_fn1(...) in {@code", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424426008", "createdAt": "2020-05-13T13:13:28Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate\n+     *          v0 = agg_fn1(a)\n+     *          v1 = agg_fn2(b, 2)\n+     *          v2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call {@link #applyAggregation} with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [v0 = agg_fn1 (input=[a]), v1= agg_fn2(input=[b,2])]\n+     * group_by=[c]\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle agg_fn1(...) and agg_fn2(...), it would return:", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyODI5Nw==", "bodyText": "Does the list ordering matter?\nwhere does v2 come from? (groupBy contains column handles only, so we didn't pass \"v2\" in)", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424428297", "createdAt": "2020-05-13T13:16:38Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate\n+     *          v0 = agg_fn1(a)\n+     *          v1 = agg_fn2(b, 2)\n+     *          v2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call {@link #applyAggregation} with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [v0 = agg_fn1 (input=[a]), v1= agg_fn2(input=[b,2])]\n+     * group_by=[c]\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle agg_fn1(...) and agg_fn2(...), it would return:\n+     *\n+     * <pre>\n+     * handle = TH1\n+     * assignments = [\n+     *     v0 = CH0 (synthetic column for agg_fn1(a))\n+     *     v1 = CH1 (synthetic column for agg_fn2(b,2))\n+     *     v2 = CH3 (for column c)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyODYyMQ==", "bodyText": "nit: put each arg on separate line", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424428621", "createdAt": "2020-05-13T13:17:07Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate\n+     *          v0 = agg_fn1(a)\n+     *          v1 = agg_fn2(b, 2)\n+     *          v2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call {@link #applyAggregation} with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [v0 = agg_fn1 (input=[a]), v1= agg_fn2(input=[b,2])]\n+     * group_by=[c]\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle agg_fn1(...) and agg_fn2(...), it would return:\n+     *\n+     * <pre>\n+     * handle = TH1\n+     * assignments = [\n+     *     v0 = CH0 (synthetic column for agg_fn1(a))\n+     *     v1 = CH1 (synthetic column for agg_fn2(b,2))\n+     *     v2 = CH3 (for column c)\n+     * ]\n+     * </pre>\n+     * @param session\n+     * @param handle\n+     * @param aggregates\n+     * @param assignments\n+     * @param groupBy\n+     * @return\n+     */\n+    default Optional<AggregatePushdownResult<ConnectorTableHandle>> applyAggregation(ConnectorSession session, ConnectorTableHandle handle, List<AggregateFunction> aggregates,\n+            Map<String, ColumnHandle> assignments, Optional<List<List<ColumnHandle>>> groupBy)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzMDY1OQ==", "bodyText": "The applyAggregation call should return a list of ConnectorExpression in the same order as the provided list of aggregations.\n\nAnd would group-bys go? At the end?\n(BTW My preference is with key-ing things in a Map, as it tends to be easier to troubleshoot and harder to get wrong, but i know we already do ordinals in applyProject)", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424430659", "createdAt": "2020-05-13T13:19:53Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3OTkyOA=="}, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzMjIzMQ==", "bodyText": "Do we need Optional here? Empty sortBy list seems to express no sorting (= sorting on a constant) equally well.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424432231", "createdAt": "2020-05-13T13:22:00Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here\n+    private final String aggregateFunctionName;\n+    private final List<ConnectorExpression> inputs;\n+    private final Type outputType;\n+    private final Optional<List<ConnectorExpression>> sortBy;\n+    private final Optional<Map<ConnectorExpression, SortOrder>> sortOrder;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzMzE2Ng==", "bodyText": "Make sure to reword (or remove) before the PR is merged.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424433166", "createdAt": "2020-05-13T13:23:17Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzNDMxMw==", "bodyText": "nit: put each arg on separate line", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424434313", "createdAt": "2020-05-13T13:24:47Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here\n+    private final String aggregateFunctionName;\n+    private final List<ConnectorExpression> inputs;\n+    private final Type outputType;\n+    private final Optional<List<ConnectorExpression>> sortBy;\n+    private final Optional<Map<ConnectorExpression, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    // TODO It is unclear if filtering and mask from the aggregate needs to be forwarded to connectors so skipping them for now.\n+\n+    public AggregateFunction(String projectionName, String name, List<ConnectorExpression> inputs, Type outputType)\n+    {\n+        this(projectionName, name, inputs, outputType, Optional.empty(), Optional.empty(), false);\n+    }\n+\n+    public AggregateFunction(String projectionName, String aggregateFunctionName, List<ConnectorExpression> inputs, Type outputType, Optional<List<ConnectorExpression>> sortBy, Optional<Map<ConnectorExpression, SortOrder>> sortOrder, boolean isDistinct)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzNTA0MA==", "bodyText": "Make defensive copies fo Lists and Maps (eg unmodifiableList(new ArrayList<>(...)))", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424435040", "createdAt": "2020-05-13T13:25:47Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here\n+    private final String aggregateFunctionName;\n+    private final List<ConnectorExpression> inputs;\n+    private final Type outputType;\n+    private final Optional<List<ConnectorExpression>> sortBy;\n+    private final Optional<Map<ConnectorExpression, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    // TODO It is unclear if filtering and mask from the aggregate needs to be forwarded to connectors so skipping them for now.\n+\n+    public AggregateFunction(String projectionName, String name, List<ConnectorExpression> inputs, Type outputType)\n+    {\n+        this(projectionName, name, inputs, outputType, Optional.empty(), Optional.empty(), false);\n+    }\n+\n+    public AggregateFunction(String projectionName, String aggregateFunctionName, List<ConnectorExpression> inputs, Type outputType, Optional<List<ConnectorExpression>> sortBy, Optional<Map<ConnectorExpression, SortOrder>> sortOrder, boolean isDistinct)\n+    {\n+        this.projectionName = requireNonNull(projectionName, \"projectionName is null\");\n+        this.aggregateFunctionName = requireNonNull(aggregateFunctionName, \"name is null\");\n+        this.inputs = requireNonNull(inputs, \"inputs is null\");\n+        this.outputType = requireNonNull(outputType, \"outputType is null\");\n+        this.sortBy = requireNonNull(sortBy, \"sortBy is null\");\n+        this.sortOrder = requireNonNull(sortOrder, \"sortOrder is null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzNTgyMg==", "bodyText": "Here we need to verify the return data is sane & safe.\nSee #3324", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424435822", "createdAt": "2020-05-13T13:26:51Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java", "diffHunk": "@@ -1100,6 +1102,26 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n                         Optional.empty()));\n     }\n \n+    @Override\n+    public Optional<AggregatePushdownResult<TableHandle>> applyAggregation(Session session, TableHandle table, List<AggregateFunction> aggregates, Map<String, ColumnHandle> assignments, Optional<List<List<ColumnHandle>>> groupBy)\n+    {\n+        CatalogName catalogName = table.getCatalogName();\n+        ConnectorMetadata metadata = getMetadata(session, catalogName);\n+\n+        if (metadata.usesLegacyTableLayouts()) {\n+            return Optional.empty();\n+        }\n+\n+        ConnectorSession connectorSession = session.toConnectorSession(catalogName);\n+        return metadata.applyAggregation(connectorSession, table.getConnectorHandle(), aggregates, assignments, groupBy)\n+                .map(result -> new AggregatePushdownResult<>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzNjQ3OQ==", "bodyText": "put each arg on separate line", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424436479", "createdAt": "2020-05-13T13:27:44Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java", "diffHunk": "@@ -1100,6 +1102,26 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n                         Optional.empty()));\n     }\n \n+    @Override\n+    public Optional<AggregatePushdownResult<TableHandle>> applyAggregation(Session session, TableHandle table, List<AggregateFunction> aggregates, Map<String, ColumnHandle> assignments, Optional<List<List<ColumnHandle>>> groupBy)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwOTUzODAw", "url": "https://github.com/trinodb/trino/pull/3697#pullrequestreview-410953800", "createdAt": "2020-05-13T13:59:42Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMzo1OTo0MlrOGUzBHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNDowNTo1MFrOGUzTSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2MDU3Mg==", "bodyText": "connectorTableHandleAggregatePushdownResult -> aggregationPushdownResult", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424460572", "createdAt": "2020-05-13T13:59:42Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.\n+                return Result.empty();\n+            }\n+\n+            List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                    .map(assignments::get)\n+                    .collect(toList());\n+\n+            Optional<AggregatePushdownResult<TableHandle>> connectorTableHandleAggregatePushdownResult = metadata.applyAggregation(context.getSession(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2MTE1MA==", "bodyText": "If this is always present, do we need Optional?", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424461150", "createdAt": "2020-05-13T14:00:26Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.\n+                return Result.empty();\n+            }\n+\n+            List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                    .map(assignments::get)\n+                    .collect(toList());\n+\n+            Optional<AggregatePushdownResult<TableHandle>> connectorTableHandleAggregatePushdownResult = metadata.applyAggregation(context.getSession(),\n+                    tableScan.getTable(),\n+                    aggregateFunctions,\n+                    assignments,\n+                    Optional.of(ImmutableList.of(groupByColumns)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2MjIwMA==", "bodyText": "I don't see how we could do partial pushdown. Replace TODO comment with something objective, but implying a change in the future (a change may or may not happen)\nAlso, isn't it an error condition (throw)?", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424462200", "createdAt": "2020-05-13T14:01:51Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.\n+                return Result.empty();\n+            }\n+\n+            List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                    .map(assignments::get)\n+                    .collect(toList());\n+\n+            Optional<AggregatePushdownResult<TableHandle>> connectorTableHandleAggregatePushdownResult = metadata.applyAggregation(context.getSession(),\n+                    tableScan.getTable(),\n+                    aggregateFunctions,\n+                    assignments,\n+                    Optional.of(ImmutableList.of(groupByColumns)));\n+\n+            if (!connectorTableHandleAggregatePushdownResult.isPresent()) {\n+                return Result.empty();\n+            }\n+\n+            AggregatePushdownResult<TableHandle> aggPushdownResult = connectorTableHandleAggregatePushdownResult.get();\n+\n+            TableHandle handle = aggPushdownResult.getHandle();\n+            ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+            ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+            Map<String, ProjectionApplicationResult.Assignment> nameToAssignment = aggPushdownResult.getAssignments().stream()\n+                    .collect(Collectors.toMap(ProjectionApplicationResult.Assignment::getVariable, Function.identity()));\n+            for (Symbol aggOutputSymbol : node.getOutputSymbols()) {\n+                ProjectionApplicationResult.Assignment assignment = nameToAssignment.get(aggOutputSymbol.getName());\n+\n+                if (assignment == null) {\n+                    //TODO We pushdown all or nothing for V1 but we need to extend this in future.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2MjgxMg==", "bodyText": "nit: collect(toList()) -> collect(toImmutableList())\n(here & in other places)\n-- we prefer Guava immutable collections", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424462812", "createdAt": "2020-05-13T14:02:37Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.\n+                return Result.empty();\n+            }\n+\n+            List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                    .map(assignments::get)\n+                    .collect(toList());\n+\n+            Optional<AggregatePushdownResult<TableHandle>> connectorTableHandleAggregatePushdownResult = metadata.applyAggregation(context.getSession(),\n+                    tableScan.getTable(),\n+                    aggregateFunctions,\n+                    assignments,\n+                    Optional.of(ImmutableList.of(groupByColumns)));\n+\n+            if (!connectorTableHandleAggregatePushdownResult.isPresent()) {\n+                return Result.empty();\n+            }\n+\n+            AggregatePushdownResult<TableHandle> aggPushdownResult = connectorTableHandleAggregatePushdownResult.get();\n+\n+            TableHandle handle = aggPushdownResult.getHandle();\n+            ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+            ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+            Map<String, ProjectionApplicationResult.Assignment> nameToAssignment = aggPushdownResult.getAssignments().stream()\n+                    .collect(Collectors.toMap(ProjectionApplicationResult.Assignment::getVariable, Function.identity()));\n+            for (Symbol aggOutputSymbol : node.getOutputSymbols()) {\n+                ProjectionApplicationResult.Assignment assignment = nameToAssignment.get(aggOutputSymbol.getName());\n+\n+                if (assignment == null) {\n+                    //TODO We pushdown all or nothing for V1 but we need to extend this in future.\n+                    return Result.empty();\n+                }\n+                newScanOutputs.add(aggOutputSymbol);\n+                newScanAssignments.put(aggOutputSymbol, assignment.getColumn());\n+            }\n+\n+            return Result.ofPlanNode(\n+                    TableScanNode.newInstance(\n+                            tableScan.getId(),\n+                            handle,\n+                            newScanOutputs.build(),\n+                            newScanAssignments.build()));\n+        }\n+    }\n+\n+    private ImmutableList<AggregateFunction> toAggFunction(Map<Symbol, AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (Map.Entry<Symbol, AggregationNode.Aggregation> entry : aggregations.entrySet()) {\n+            AggregationNode.Aggregation aggregation = entry.getValue();\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = typeManager.getType(signature.getReturnType());\n+            String aggFunctionName = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)\n+                    .map(SymbolsExtractor::extractUnique)\n+                    .flatMap(Collection::stream)\n+                    .collect(toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2MzA2OQ==", "bodyText": "I don't understand this comment.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424463069", "createdAt": "2020-05-13T14:03:01Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.\n+                return Result.empty();\n+            }\n+\n+            List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                    .map(assignments::get)\n+                    .collect(toList());\n+\n+            Optional<AggregatePushdownResult<TableHandle>> connectorTableHandleAggregatePushdownResult = metadata.applyAggregation(context.getSession(),\n+                    tableScan.getTable(),\n+                    aggregateFunctions,\n+                    assignments,\n+                    Optional.of(ImmutableList.of(groupByColumns)));\n+\n+            if (!connectorTableHandleAggregatePushdownResult.isPresent()) {\n+                return Result.empty();\n+            }\n+\n+            AggregatePushdownResult<TableHandle> aggPushdownResult = connectorTableHandleAggregatePushdownResult.get();\n+\n+            TableHandle handle = aggPushdownResult.getHandle();\n+            ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+            ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+            Map<String, ProjectionApplicationResult.Assignment> nameToAssignment = aggPushdownResult.getAssignments().stream()\n+                    .collect(Collectors.toMap(ProjectionApplicationResult.Assignment::getVariable, Function.identity()));\n+            for (Symbol aggOutputSymbol : node.getOutputSymbols()) {\n+                ProjectionApplicationResult.Assignment assignment = nameToAssignment.get(aggOutputSymbol.getName());\n+\n+                if (assignment == null) {\n+                    //TODO We pushdown all or nothing for V1 but we need to extend this in future.\n+                    return Result.empty();\n+                }\n+                newScanOutputs.add(aggOutputSymbol);\n+                newScanAssignments.put(aggOutputSymbol, assignment.getColumn());\n+            }\n+\n+            return Result.ofPlanNode(\n+                    TableScanNode.newInstance(\n+                            tableScan.getId(),\n+                            handle,\n+                            newScanOutputs.build(),\n+                            newScanAssignments.build()));\n+        }\n+    }\n+\n+    private ImmutableList<AggregateFunction> toAggFunction(Map<Symbol, AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (Map.Entry<Symbol, AggregationNode.Aggregation> entry : aggregations.entrySet()) {\n+            AggregationNode.Aggregation aggregation = entry.getValue();\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = typeManager.getType(signature.getReturnType());\n+            String aggFunctionName = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)\n+                    .map(SymbolsExtractor::extractUnique)\n+                    .flatMap(Collection::stream)\n+                    .collect(toList());\n+            // We could just reject calling down to connector's pushdown if the argument symbol is not already present in table scan's assignment.\n+            if (arguments.size() != symbols.size()) {\n+                return ImmutableList.of();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2NTIyNQ==", "bodyText": "@sopel39 if we reuse original TS id, will the EXPLAIN ANALYZE report (potentially incorrect) pre-CBO stats for this new TS?", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424465225", "createdAt": "2020-05-13T14:05:50Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.\n+                return Result.empty();\n+            }\n+\n+            List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                    .map(assignments::get)\n+                    .collect(toList());\n+\n+            Optional<AggregatePushdownResult<TableHandle>> connectorTableHandleAggregatePushdownResult = metadata.applyAggregation(context.getSession(),\n+                    tableScan.getTable(),\n+                    aggregateFunctions,\n+                    assignments,\n+                    Optional.of(ImmutableList.of(groupByColumns)));\n+\n+            if (!connectorTableHandleAggregatePushdownResult.isPresent()) {\n+                return Result.empty();\n+            }\n+\n+            AggregatePushdownResult<TableHandle> aggPushdownResult = connectorTableHandleAggregatePushdownResult.get();\n+\n+            TableHandle handle = aggPushdownResult.getHandle();\n+            ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+            ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+            Map<String, ProjectionApplicationResult.Assignment> nameToAssignment = aggPushdownResult.getAssignments().stream()\n+                    .collect(Collectors.toMap(ProjectionApplicationResult.Assignment::getVariable, Function.identity()));\n+            for (Symbol aggOutputSymbol : node.getOutputSymbols()) {\n+                ProjectionApplicationResult.Assignment assignment = nameToAssignment.get(aggOutputSymbol.getName());\n+\n+                if (assignment == null) {\n+                    //TODO We pushdown all or nothing for V1 but we need to extend this in future.\n+                    return Result.empty();\n+                }\n+                newScanOutputs.add(aggOutputSymbol);\n+                newScanAssignments.put(aggOutputSymbol, assignment.getColumn());\n+            }\n+\n+            return Result.ofPlanNode(\n+                    TableScanNode.newInstance(\n+                            tableScan.getId(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 155}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "author": {"user": {"login": "Parth-Brahmbhatt", "name": "Parth Brahmbhatt"}}, "url": "https://github.com/trinodb/trino/commit/5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "committedDate": "2020-05-18T21:37:45Z", "message": "SPI changes to support nonpartial and complete aggregate pushdown to connectors.\nThe commit also includes the top level optimizer rule"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1ODk1OTEy", "url": "https://github.com/trinodb/trino/pull/3697#pullrequestreview-415895912", "createdAt": "2020-05-21T05:54:55Z", "commit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "state": "COMMENTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwNTo1NDo1NVrOGYnFYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMToyNjo1MFrOGZDdgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1OTM2MA==", "bodyText": "Place the first argument on the next line", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428459360", "createdAt": "2020-05-21T05:54:55Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/Metadata.java", "diffHunk": "@@ -352,6 +354,12 @@\n \n     Optional<TableHandle> applySample(Session session, TableHandle table, SampleType sampleType, double sampleRatio);\n \n+    Optional<AggregationPushdownResult<TableHandle>> applyAggregation(Session session,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTI5OQ==", "bodyText": "Rename to AggregationApplicationResult for consistency with ProjectionApplicationResult", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428461299", "createdAt": "2020-05-21T06:01:32Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregationPushdownResult<T>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MzA4MQ==", "bodyText": "Format as:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .map(\n          \n          \n            \n                                    result -> {\n          \n          \n            \n                            .map(result -> {", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428463081", "createdAt": "2020-05-21T06:07:51Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java", "diffHunk": "@@ -1100,6 +1103,56 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n                         Optional.empty()));\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(\n+            Session session,\n+            TableHandle table,\n+            List<AggregateFunction> aggregations,\n+            Map<String, ColumnHandle> assignments,\n+            List<List<ColumnHandle>> groupBy)\n+    {\n+        CatalogName catalogName = table.getCatalogName();\n+        ConnectorMetadata metadata = getMetadata(session, catalogName);\n+\n+        if (metadata.usesLegacyTableLayouts()) {\n+            return Optional.empty();\n+        }\n+\n+        ConnectorSession connectorSession = session.toConnectorSession(catalogName);\n+        return metadata.applyAggregation(connectorSession, table.getConnectorHandle(), aggregations, assignments, groupBy)\n+                .map(\n+                        result -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MzU2MA==", "bodyText": "Format as:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .findAny().ifPresent(variableName -> { throw new IllegalStateException(\"Unbound variable: \" + variableName); });\n          \n          \n            \n                            .findAny()\n          \n          \n            \n                            .ifPresent(variableName -> { throw new IllegalStateException(\"Unbound variable: \" + variableName); });", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428463560", "createdAt": "2020-05-21T06:09:39Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java", "diffHunk": "@@ -1100,6 +1103,56 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n                         Optional.empty()));\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(\n+            Session session,\n+            TableHandle table,\n+            List<AggregateFunction> aggregations,\n+            Map<String, ColumnHandle> assignments,\n+            List<List<ColumnHandle>> groupBy)\n+    {\n+        CatalogName catalogName = table.getCatalogName();\n+        ConnectorMetadata metadata = getMetadata(session, catalogName);\n+\n+        if (metadata.usesLegacyTableLayouts()) {\n+            return Optional.empty();\n+        }\n+\n+        ConnectorSession connectorSession = session.toConnectorSession(catalogName);\n+        return metadata.applyAggregation(connectorSession, table.getConnectorHandle(), aggregations, assignments, groupBy)\n+                .map(\n+                        result -> {\n+                            verifyProjection(table, result.getProjections(), result.getAssignments(), aggregations.size());\n+\n+                            return new AggregationPushdownResult<>(\n+                                    new TableHandle(catalogName, result.getHandle(), table.getTransaction(), Optional.empty()),\n+                                    result.getProjections(),\n+                                    result.getAssignments());\n+                        });\n+    }\n+\n+    private void verifyProjection(TableHandle table, List<ConnectorExpression> projections, List<Assignment> assignments, int expectedProjectionSize)\n+    {\n+        projections.forEach(projection -> requireNonNull(projection, \"one of the projections is null\"));\n+        assignments.forEach(assignment -> requireNonNull(assignment, \"one of the assignments is null\"));\n+\n+        verify(\n+                expectedProjectionSize == projections.size(),\n+                \"ConnectorMetadata returned invalid number of projections: %s instead of %s for %s\",\n+                projections.size(),\n+                expectedProjectionSize,\n+                table);\n+\n+        Set<String> assignedVariables = assignments.stream()\n+                .map(Assignment::getVariable)\n+                .collect(toImmutableSet());\n+        projections.stream()\n+                .flatMap(connectorExpression -> ConnectorExpressions.extractVariables(connectorExpression).stream())\n+                .map(Variable::getName)\n+                .filter(variableName -> !assignedVariables.contains(variableName))\n+                .findAny().ifPresent(variableName -> { throw new IllegalStateException(\"Unbound variable: \" + variableName); });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NDI5NA==", "bodyText": "Put the first argument on the next line", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428464294", "createdAt": "2020-05-21T06:12:12Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/metadata/AbstractMockMetadata.java", "diffHunk": "@@ -447,6 +449,16 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n         return Optional.empty();\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(Session session,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NDM4Nw==", "bodyText": "First argument on the next line", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428464387", "createdAt": "2020-05-21T06:12:30Z", "author": {"login": "martint"}, "path": "presto-plugin-toolkit/src/main/java/io/prestosql/plugin/base/classloader/ClassLoaderSafeConnectorMetadata.java", "diffHunk": "@@ -687,6 +689,18 @@ public ConnectorTableProperties getTableProperties(ConnectorSession session, Con\n         }\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(ConnectorSession session,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NTQ0Mw==", "bodyText": "It's not a great idea to piggyback on Map.Entry to represent a sort item. For one, it doesn't clearly convey what the key and value represent. Let's create a dedicated class named SortItem.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428465443", "createdAt": "2020-05-21T06:15:51Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NjIwNw==", "bodyText": "requireNonNull", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428466207", "createdAt": "2020-05-21T06:18:16Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,\n+            boolean isDistinct,\n+            Optional<String> filter)\n+    {\n+        this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n+        this.outputType = requireNonNull(outputType, \"outputType is null\");\n+        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n+        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n+        this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");\n+        this.filter = filter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NzA1MQ==", "bodyText": "Move the requireNonNull for the arguments outside of the call. Having them inline muddles the code and makes it harder to read. Also, use List.copyOf():\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n          \n          \n            \n                    this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n          \n          \n            \n                    requireNonNull(inputs, \"inputs is null\");\n          \n          \n            \n                    requireNonNull(sortOrder, \"sortOrder is null\")\n          \n          \n            \n                    \n          \n          \n            \n                    this.inputs = List.copyOf(inputs);\n          \n          \n            \n                    this.sortOrder = List.copyOf(inputs);", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428467051", "createdAt": "2020-05-21T06:20:53Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,\n+            boolean isDistinct,\n+            Optional<String> filter)\n+    {\n+        this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n+        this.outputType = requireNonNull(outputType, \"outputType is null\");\n+        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n+        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2ODA5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.projections = unmodifiableList(new ArrayList<>(requireNonNull(projections, \"projections is null\")));\n          \n          \n            \n                    this.assignments = unmodifiableList(new ArrayList<>(requireNonNull(assignments, \"assignment is null\")));\n          \n          \n            \n                    requireNonNull(projections, \"projections is null\");\n          \n          \n            \n                    requireNonNull(assignments, \"assignment is null\");\n          \n          \n            \n                    this.projections = List.copyOf(projections);\n          \n          \n            \n                    this.assignments = List.copyOf(assignments);", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428468099", "createdAt": "2020-05-21T06:24:07Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregationPushdownResult<T>\n+{\n+    private final T handle;\n+    private final List<ConnectorExpression> projections;\n+    private final List<Assignment> assignments;\n+\n+    public AggregationPushdownResult(T handle, List<ConnectorExpression> projections, List<Assignment> assignments)\n+    {\n+        this.handle = requireNonNull(handle, \"handle is null\");\n+        this.projections = unmodifiableList(new ArrayList<>(requireNonNull(projections, \"projections is null\")));\n+        this.assignments = unmodifiableList(new ArrayList<>(requireNonNull(assignments, \"assignment is null\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjMzOA==", "bodyText": "We generally place the .stream() call next to the previous one as it's immaterial to understanding what the transformation does:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .entrySet()\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .entrySet().stream()", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428906338", "createdAt": "2020-05-21T20:49:22Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjUyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n          \n          \n            \n                            .stream()\n          \n          \n            \n                    List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations.stream()", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428906526", "createdAt": "2020-05-21T20:49:43Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwODUwOA==", "bodyText": "If you change toAggregateFunction to process a single aggregation, you can rewrite this as:\nList<AggregateFunction> aggregateFunctions = aggregations.stream()\n        .map(Entry::getValue)\n        .map(this::toAggregateFunction)\n        .collect(toImmutableList());\nAlso, since some aggregations are not candidates to be pushed down (e.g., if they contain lambda expressions), add a check before that bails out early if the condition doesn't hold, although it'd be it'd be better to add this condition to the pattern:\n    private static final Pattern<AggregationNode> PATTERN = aggregation()\n            .matching(PushAggregationIntoTableScan::allArgumentsAreSimpleReferences) // skip arguments that are, for instance, lambda expressions\n            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n\n    private static boolean allArgumentsAreSimpleReferences(AggregationNode node)\n    {\n        return node.getAggregations()\n                .values().stream()\n                .flatMap(aggregation -> aggregation.getArguments().stream())\n                .allMatch(SymbolReference.class::isInstance)\n    }", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428908508", "createdAt": "2020-05-21T20:53:36Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjUyNg=="}, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMjg4MA==", "bodyText": "Add this to the pattern:\nprivate static final Pattern<AggregationNode> PATTERN = aggregation()\n        .matching(node -> node.getGroupingSets().getGroupingSetCount() == 1)\n        .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428912880", "createdAt": "2020-05-21T21:02:29Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxODczNA==", "bodyText": "These variables are used only once. Inline them where they are referenced.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428918734", "createdAt": "2020-05-21T21:15:35Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTEzMA==", "bodyText": "This should unnecessary once you add the filter to the pattern as described above.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428919130", "createdAt": "2020-05-21T21:16:24Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTcxMA==", "bodyText": "This can only be a SymbolReference, so it'd be more appropriate to do:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .map(SymbolsExtractor::extractUnique)\n          \n          \n            \n                                .flatMap(Collection::stream)\n          \n          \n            \n                                .map(Symbol::from)", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428919710", "createdAt": "2020-05-21T21:17:49Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)\n+                    .map(SymbolsExtractor::extractUnique)\n+                    .flatMap(Collection::stream)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTg0Mg==", "bodyText": "This should unnecessary once you add the filter to the pattern as described above.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428919842", "createdAt": "2020-05-21T21:18:06Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)\n+                    .map(SymbolsExtractor::extractUnique)\n+                    .flatMap(Collection::stream)\n+                    .collect(toImmutableList());\n+\n+            if (arguments.size() != symbols.size()) {\n+                return ImmutableList.of();\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyMjg0OQ==", "bodyText": "Once you apply all the suggestions above and below, this method can simplify to:\nprivate AggregateFunction toAggregateFunction(AggregationNode.Aggregation aggregation)\n{\n    Signature signature = aggregation.getResolvedFunction().getSignature();\n\n    ImmutableList.Builder<ConnectorExpression> arguments = new ImmutableList.Builder<>();\n    for (int i = 0; i < aggregation.getArguments().size(); i++) {\n        SymbolReference argument = (SymbolReference) aggregation.getArguments().get(i);\n        arguments.add(new Variable(argument.getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n    }\n\n    Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n    Optional<List<Map.Entry<String, SortOrder>>> sortBy = orderingScheme.map(orderings ->\n            orderings.getOrderBy().stream()\n                    .map(orderBy -> new AbstractMap.SimpleEntry<>(\n                            orderBy.getName(),\n                            SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n                    .collect(toImmutableList()));\n\n    return new AggregateFunction(\n            signature.getName(),\n            metadata.getType(signature.getReturnType()),\n            arguments.build(),\n            sortBy.orElse(ImmutableList.of()),\n            aggregation.isDistinct(),\n            aggregation.getFilter().map(Symbol::getName));\n}", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428922849", "createdAt": "2020-05-21T21:24:03Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyNDI5MA==", "bodyText": "This is incorrect. The new scan outputs should be the symbols associated with grouping columns plus the symbols associated with aggregations.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428924290", "createdAt": "2020-05-21T21:26:50Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 135}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3NjIyNzMz", "url": "https://github.com/trinodb/trino/pull/3697#pullrequestreview-417622733", "createdAt": "2020-05-25T10:37:22Z", "commit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "state": "COMMENTED", "comments": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMDozNzoyM1rOGZ84Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjowNToxNFrOGZ--fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NDk5MA==", "bodyText": "6d9d47e", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429864990", "createdAt": "2020-05-25T10:37:23Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NjMzNQ==", "bodyText": "Why not ImmutableList.of(groupByColumns) always?\n[ [] ] would correctly describe the fact that there is 1 grouping set and that it is a global aggregation.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429866335", "createdAt": "2020-05-25T10:41:05Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MDUxNA==", "bodyText": "i think #3697 (comment) is still waiting for final resolution. @martint ?\n(nit: if this stays, would be good to avoid \"unioned\" as intellij spellchecker highlights this)", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429870514", "createdAt": "2020-05-25T10:51:58Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTA5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429871095", "createdAt": "2020-05-25T10:53:23Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTQ5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n          \n          \n            \n                 *              { functionName=agg_fn1, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} a]} ,\n          \n      \n    \n    \n  \n\notherwise you would need to use &lt; &gt;", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429871499", "createdAt": "2020-05-25T10:54:24Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTkwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * group_by=[{@link ColumnHandle} CH2]\n          \n          \n            \n                 * group_by=[[{@link ColumnHandle} CH2]]\n          \n      \n    \n    \n  \n\n(it's list of lists)", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429871908", "createdAt": "2020-05-25T10:55:33Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MjA5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * assignments = {a = CH0, b=CH1, c=CH2}\n          \n          \n            \n                 * assignments = {a = CH0, b = CH1, c = CH2}", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429872099", "createdAt": "2020-05-25T10:56:00Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MjgzNA==", "bodyText": "c assignments seems redundant, as there is no c variable", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429872834", "createdAt": "2020-05-25T10:57:50Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3Mjk5Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *  - aggregation\n          \n          \n            \n                 *          variable0 = agg_fn1(a)\n          \n          \n            \n                 *          variable1 = agg_fn2(b, 2)\n          \n          \n            \n                 *          variable2 = group_by c\n          \n          \n            \n                 *  - aggregation (GROUP BY c)\n          \n          \n            \n                 *          variable0 = agg_fn1(a)\n          \n          \n            \n                 *          variable1 = agg_fn2(b, 2)\n          \n          \n            \n                 *          variable2 = c", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429872996", "createdAt": "2020-05-25T10:58:15Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MzM3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429873373", "createdAt": "2020-05-25T10:59:19Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MzY1Mw==", "bodyText": "i like the way you wrote this!\njust consider adding an indent (here and following).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * {@link AggregationPushdownResult} {\n          \n          \n            \n                 * handle = TH1\n          \n          \n            \n                 * {@link AggregationPushdownResult} {\n          \n          \n            \n                 *     handle = TH1", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429873653", "createdAt": "2020-05-25T11:00:01Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3Mzk3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n          \n          \n            \n                 * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429873970", "createdAt": "2020-05-25T11:00:51Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NDIxNw==", "bodyText": "CH0, CH1, and CH2 are already used above", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429874217", "createdAt": "2020-05-25T11:01:31Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n+     * assignments = {\n+     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n+     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NDQxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n          \n          \n            \n                 * if the connector only knows how to handle {@code agg_fn1}, but not {@code agg_fn2}, it should return {@link Optional#empty()}.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429874415", "createdAt": "2020-05-25T11:02:03Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n+     * assignments = {\n+     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n+     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NDc2OQ==", "bodyText": "Should we call this groupingSets? @martint ?", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429874769", "createdAt": "2020-05-25T11:03:00Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n+     * assignments = {\n+     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n+     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n+     */\n+    default Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(\n+            ConnectorSession session,\n+            ConnectorTableHandle handle,\n+            List<AggregateFunction> aggregates,\n+            Map<String, ColumnHandle> assignments,\n+            List<List<ColumnHandle>> groupBy)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NTY5NQ==", "bodyText": "isDistinct is primitive, so\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");\n          \n          \n            \n                    this.isDistinct = isDistinct;", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429875695", "createdAt": "2020-05-25T11:05:33Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,\n+            boolean isDistinct,\n+            Optional<String> filter)\n+    {\n+        this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n+        this.outputType = requireNonNull(outputType, \"outputType is null\");\n+        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n+        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n+        this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4NTY5Mw==", "bodyText": "Moving out Assignment as a top level class touches a lot of files, that are otherwise unrelated to the change.\nCan you please extract this to a preparatory commit?", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429885693", "createdAt": "2020-05-25T11:31:37Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -91,7 +92,7 @@ public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n             handle = result.get().getHandle();\n \n             Map<String, ColumnHandle> assignments = result.get().getAssignments().stream()\n-                    .collect(toImmutableMap(ProjectionApplicationResult.Assignment::getVariable, ProjectionApplicationResult.Assignment::getColumn));\n+                    .collect(toImmutableMap(Assignment::getVariable, Assignment::getColumn));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4Nzg2NQ==", "bodyText": "Why?\nIf you remove this, the rule would be applicable also for queries like\nSELECT DISTINCT regionkey FROM tpch.tiny.nation;", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429887865", "createdAt": "2020-05-25T11:36:51Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MTA0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Pattern<AggregationNode> PATTERN = aggregation()\n          \n          \n            \n                        .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n          \n          \n            \n                    private static final Pattern<AggregationNode> PATTERN =\n          \n          \n            \n                        aggregation()\n          \n          \n            \n                                .with(step().equalTo(SINGLE))\n          \n          \n            \n                                .matching(node -> node.getGroupingSetCount() == 1)\n          \n          \n            \n                                .matching(node -> node.getGroupIdSymbol().isEmpty())\n          \n          \n            \n                                .matching(node -> node.getHashSymbol().isEmpty())\n          \n          \n            \n                                .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n          \n      \n    \n    \n  \n\n\na few additional checks\nif you move aggregation() to new line, this fill be formatted better", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429891044", "createdAt": "2020-05-25T11:44:49Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MjcxMw==", "bodyText": "what does \"partial project\" mean here? (can this be  newProjections?)", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429892713", "createdAt": "2020-05-25T11:49:02Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MzEzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    groupingSets.getGroupingKeys().stream()\n          \n          \n            \n                            .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n          \n          \n            \n                    groupingSets.getGroupingKeys()\n          \n          \n            \n                            .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n          \n      \n    \n    \n  \n\n-- use Collection#forEach without going thru Stream", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429893130", "createdAt": "2020-05-25T11:50:01Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NDk0Ng==", "bodyText": "add verify(aggregationOutputSymbols.size() == newPartialProjections.size()); just before this line as this is where you depend on this\nno need for good exc msg, since it's in fact already validated in MetadataManager, so it's more for documenting assumptions/dependencies of the code here", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429894946", "createdAt": "2020-05-25T11:54:37Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng==", "bodyText": "Optional<Variable>", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429896486", "createdAt": "2020-05-25T11:58:16Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5OTAwNQ==", "bodyText": "what about aggregation.getMask()? we should verify aggregation.getMask() is not present (yet).", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429899005", "createdAt": "2020-05-25T12:04:27Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyMjg0OQ=="}, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5OTM5MA==", "bodyText": "plus additional conditions\n\n@martint 's all agg args are symbols condition\nagg mask is not present\nanything else?", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429899390", "createdAt": "2020-05-25T12:05:14Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MTA0NA=="}, "originalCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1"}, "originalPosition": 68}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "author": {"user": {"login": "Parth-Brahmbhatt", "name": "Parth Brahmbhatt"}}, "url": "https://github.com/trinodb/trino/commit/5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "committedDate": "2020-05-18T21:37:45Z", "message": "SPI changes to support nonpartial and complete aggregate pushdown to connectors.\nThe commit also includes the top level optimizer rule"}, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MDA1OTYz", "url": "https://github.com/trinodb/trino/pull/3697#pullrequestreview-427005963", "createdAt": "2020-06-09T10:29:53Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMDoyOTo1M1rOGhDH-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMDozMDozM1rOGhDJUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMwNzM4NQ==", "bodyText": "Apparently  aggregateFunctions.size() == aggregations.size(), so you don't need the && part.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r437307385", "createdAt": "2020-06-09T10:29:53Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -119,7 +120,7 @@ public Result apply(AggregationNode node, Captures captures, Context context)\n                 .map(Entry::getKey)\n                 .collect(toImmutableList());\n \n-        if (aggregateFunctions.isEmpty()) {\n+        if (aggregateFunctions.isEmpty() && !aggregations.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMwNzcyOQ==", "bodyText": "update indent of the following lines", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r437307729", "createdAt": "2020-06-09T10:30:33Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -62,7 +62,8 @@\n {\n     private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n \n-    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+    private static final Pattern<AggregationNode> PATTERN =\n+            aggregation()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MDIyMjA2", "url": "https://github.com/trinodb/trino/pull/3697#pullrequestreview-427022206", "createdAt": "2020-06-09T10:54:21Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMDo1NDoyMVrOGhD4mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMDo1NDoyMVrOGhD4mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMxOTgzMg==", "bodyText": "Intellij warns me\n\n'Map<String, ColumnHandle>' may not contain keys of type 'Symbol'\n\nand indeed i get NPE in the next line, as originalColumnHandle comes out as null", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r437319832", "createdAt": "2020-06-09T10:54:21Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationApplicationResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortItem;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN =\n+            aggregation()\n+            // skip arguments that are, for instance, lambda expressions\n+            .matching(PushAggregationIntoTableScan::allArgumentsAreSimpleReferences)\n+            .matching(node -> node.getGroupingSets().getGroupingSetCount() <= 1)\n+            .matching(PushAggregationIntoTableScan::hasNoMasks)\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    private static boolean allArgumentsAreSimpleReferences(AggregationNode node)\n+    {\n+        return node.getAggregations()\n+                .values().stream()\n+                .flatMap(aggregation -> aggregation.getArguments().stream())\n+                .allMatch(SymbolReference.class::isInstance);\n+    }\n+\n+    private static boolean hasNoMasks(AggregationNode node)\n+    {\n+        return !node.getAggregations()\n+                .values().stream()\n+                .map(aggregation -> aggregation.getMask().isPresent())\n+                .anyMatch(isMaskPresent -> isMaskPresent);\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet().stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = aggregations.stream()\n+                .map(Entry::getValue)\n+                .map(aggregation -> toAggregateFunction(context, aggregation))\n+                .collect(toImmutableList());\n+\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty() && !aggregations.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationApplicationResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                ImmutableList.of(groupByColumns));\n+\n+        if (aggregationPushdownResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationApplicationResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        // The new scan outputs should be the symbols associated with grouping columns plus the symbols associated with aggregations.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableBiMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableBiMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        verify(aggregationOutputSymbols.size() == newProjections.size());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newProjections.get(index)));\n+\n+        ImmutableBiMap<Symbol, ColumnHandle> scanAssignments = newScanAssignments.build();\n+        ImmutableBiMap<ColumnHandle, Symbol> columnHandleToSymbol = scanAssignments.inverse();\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys()\n+                .forEach(groupBySymbol -> {\n+                    // if the connector returned a new mapping from oldColumnHandle to newColumnHandle, groupBy needs to point to\n+                    // new columnHandle's symbol reference, otherwise it will continue pointing at oldColumnHandle.\n+                    ColumnHandle originalColumnHandle = assignments.get(groupBySymbol);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 180}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NzQ5MTY3", "url": "https://github.com/trinodb/trino/pull/3697#pullrequestreview-427749167", "createdAt": "2020-06-10T06:37:54Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MTU0Njc2", "url": "https://github.com/trinodb/trino/pull/3697#pullrequestreview-429154676", "createdAt": "2020-06-11T17:51:59Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzo1MTo1OVrOGiob4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzo1MTo1OVrOGiob4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk2NzI2Nw==", "bodyText": "Let's call this groupingColumnMapping. Grouping sets are made of sets of columns, but this method is not specifically about the grouping sets themselves.", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r438967267", "createdAt": "2020-06-11T17:51:59Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregationApplicationResult.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregationApplicationResult<T>\n+{\n+    private final T handle;\n+    private final List<ConnectorExpression> projections;\n+    private final List<Assignment> assignments;\n+    private final Map<ColumnHandle, ColumnHandle> groupingSetMapping;\n+\n+    public AggregationApplicationResult(\n+            T handle,\n+            List<ConnectorExpression> projections,\n+            List<Assignment> assignments,\n+            Map<ColumnHandle, ColumnHandle> groupingSetMapping)\n+    {\n+        this.handle = requireNonNull(handle, \"handle is null\");\n+        requireNonNull(groupingSetMapping, \"goupingSetMapping is null\");\n+        requireNonNull(projections, \"projections is null\");\n+        requireNonNull(assignments, \"assignment is null\");\n+        this.groupingSetMapping = Map.copyOf(groupingSetMapping);\n+        this.projections = List.copyOf(projections);\n+        this.assignments = List.copyOf(assignments);\n+    }\n+\n+    public T getHandle()\n+    {\n+        return handle;\n+    }\n+\n+    public List<ConnectorExpression> getProjections()\n+    {\n+        return projections;\n+    }\n+\n+    public List<Assignment> getAssignments()\n+    {\n+        return assignments;\n+    }\n+\n+    public Map<ColumnHandle, ColumnHandle> getGroupingSetMapping()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 60}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a598fdfffa13d60136ab89df3370bf637b362a1", "author": {"user": {"login": "Parth-Brahmbhatt", "name": "Parth Brahmbhatt"}}, "url": "https://github.com/trinodb/trino/commit/0a598fdfffa13d60136ab89df3370bf637b362a1", "committedDate": "2020-06-11T18:05:43Z", "message": "Add support for aggregation pushdow"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "0a598fdfffa13d60136ab89df3370bf637b362a1", "author": {"user": {"login": "Parth-Brahmbhatt", "name": "Parth Brahmbhatt"}}, "url": "https://github.com/trinodb/trino/commit/0a598fdfffa13d60136ab89df3370bf637b362a1", "committedDate": "2020-06-11T18:05:43Z", "message": "Add support for aggregation pushdow"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1471, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}