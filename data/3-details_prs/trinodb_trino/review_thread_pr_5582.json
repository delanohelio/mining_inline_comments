{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA1MzE0MDg2", "number": 5582, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMToxMDozM1rOEzvq_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMjo1OTozOVrOE1pTvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjkzODg2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/IterativeOptimizer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMToxMDozM1rOHrKcSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMToxMDozM1rOHrKcSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyMTg5OA==", "bodyText": "Maybe more elegant way would be to add boolean forDelete to TableScanNode. Then we could simply use PlanNodeSearcher within a rule to search for TableScans with such flag.\nIn current approach delete logic (context goes to left) becomes part of IterativeOptimizers itself", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r515021898", "createdAt": "2020-10-30T11:10:33Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/IterativeOptimizer.java", "diffHunk": "@@ -182,15 +188,25 @@ private boolean exploreNode(int group, Context context)\n         return Rule.Result.empty();\n     }\n \n-    private boolean exploreChildren(int group, Context context)\n+    private boolean exploreChildren(int group, Context context, Context deleteContext)\n     {\n         boolean progress = false;\n \n         PlanNode expression = context.memo.getNode(group);\n-        for (PlanNode child : expression.getSources()) {\n+        for (int i = 0; i < expression.getSources().size(); i++) {\n+            PlanNode child = expression.getSources().get(i);\n             checkState(child instanceof GroupReference, \"Expected child to be a group reference. Found: \" + child.getClass().getName());\n \n-            if (exploreGroup(((GroupReference) child).getGroupId(), context)) {\n+            Context childContext;\n+            if (i == 0) {\n+                // pass the context of Delete to the left branch of plan", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjk2MjIwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDereferencePushDown.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMToxNzowOVrOHrKqFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMToxNzowOVrOHrKqFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyNTQyOA==", "bodyText": "remove?", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r515025428", "createdAt": "2020-10-30T11:17:09Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDereferencePushDown.java", "diffHunk": "@@ -38,6 +40,11 @@\n public class TestDereferencePushDown\n         extends BasePlanTest\n {\n+   /* public TestDereferencePushDown()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjk2NzM4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestQuantifiedComparison.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMToxODozMVrOHrKtAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMToxODozMVrOHrKtAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyNjE3OQ==", "bodyText": "Do we care that it's not rewritten? In other tests it seem to make sense, but in this one not neccecerly.", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r515026179", "createdAt": "2020-10-30T11:18:31Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestQuantifiedComparison.java", "diffHunk": "@@ -35,7 +37,12 @@\n     public void testQuantifiedComparisonEqualsAny()\n     {\n         String query = \"SELECT orderkey, custkey FROM orders WHERE orderkey = ANY (VALUES ROW(CAST(5 as BIGINT)), ROW(CAST(3 as BIGINT)))\";\n-        assertPlan(query, anyTree(\n+        assertPlan(\n+                query,\n+                Session.builder(getQueryRunner().getDefaultSession())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjk2OTc4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMToxOTowMlrOHrKuUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMToxOTowMlrOHrKuUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyNjUxNA==", "bodyText": "add a test case for semi join rewrite here.", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r515026514", "createdAt": "2020-10-30T11:19:02Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -1555,4 +1557,11 @@ private Session automaticJoinDistribution()\n                 .setSystemProperty(JOIN_DISTRIBUTION_TYPE, JoinDistributionType.AUTOMATIC.name())\n                 .build();\n     }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzMzMzI1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/RelationPlanner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMjoxOTo1OFrOHsCG5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMToyMTo1MVrOHtA5bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzMzkyNQ==", "bodyText": "is there any way to test it?", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r515933925", "createdAt": "2020-11-02T12:19:58Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/RelationPlanner.java", "diffHunk": "@@ -201,7 +202,8 @@ protected RelationPlan visitTable(Table node, Void context)\n             }\n \n             List<Symbol> outputSymbols = outputSymbolsBuilder.build();\n-            PlanNode root = TableScanNode.newInstance(idAllocator.getNextId(), handle, outputSymbols, columns.build());\n+            boolean isDeleteTarget = analysis.isDeleteTarget(createQualifiedObjectName(session, node, node.getName()));\n+            PlanNode root = TableScanNode.newInstance(idAllocator.getNextId(), handle, outputSymbols, columns.build(), isDeleteTarget);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk2MjY3MA==", "bodyText": "I didn't find a way. DELETE queries are rejected in TestLogicalPlanner", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r516962670", "createdAt": "2020-11-03T21:21:51Z", "author": {"login": "kasiafi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/RelationPlanner.java", "diffHunk": "@@ -201,7 +202,8 @@ protected RelationPlan visitTable(Table node, Void context)\n             }\n \n             List<Symbol> outputSymbols = outputSymbolsBuilder.build();\n-            PlanNode root = TableScanNode.newInstance(idAllocator.getNextId(), handle, outputSymbols, columns.build());\n+            boolean isDeleteTarget = analysis.isDeleteTarget(createQualifiedObjectName(session, node, node.getName()));\n+            PlanNode root = TableScanNode.newInstance(idAllocator.getNextId(), handle, outputSymbols, columns.build(), isDeleteTarget);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzMzkyNQ=="}, "originalCommit": null, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzM1MzM4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformFilteringSemiJoinToInnerJoin.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMjoyNzowNlrOHsCTEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMjoyNzowNlrOHsCTEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzNzA0Mg==", "bodyText": "nit: why not to create equi condition immediatelly?", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r515937042", "createdAt": "2020-11-02T12:27:06Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformFilteringSemiJoinToInnerJoin.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.optimizations.PlanNodeSearcher;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.SemiJoinNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.ComparisonExpression;\n+import io.prestosql.sql.tree.Expression;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.SystemSessionProperties.isRewriteFilteringSemiJoinToInnerJoin;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.ExpressionUtils.and;\n+import static io.prestosql.sql.ExpressionUtils.extractConjuncts;\n+import static io.prestosql.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.prestosql.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.semiJoin;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.EQUAL;\n+import static java.util.function.Predicate.not;\n+\n+/**\n+ * Rewrite filtering semi-join to inner join.\n+ * <p/>\n+ * Transforms:\n+ * <pre>\n+ * - Filter (semiJoinSymbol AND predicate)\n+ *    - SemiJoin (semiJoinSymbol <- (a IN b))\n+ *        source: plan A producing symbol a\n+ *        filtering source: plan B producing symbol b\n+ * </pre>\n+ * <p/>\n+ * Into:\n+ * <pre>\n+ * - Filter (predicate)\n+ *    - Project (semiJoinSymbol <- TRUE)\n+ *       - Join INNER on (a = b)\n+ *          - source\n+ *          - Aggregation distinct(b)\n+ *             - filtering source\n+ * </pre>\n+ */\n+public class TransformFilteringSemiJoinToInnerJoin\n+        implements Rule<FilterNode>\n+{\n+    private static final Capture<SemiJoinNode> SEMI_JOIN = newCapture();\n+\n+    private static final Pattern<FilterNode> PATTERN = filter()\n+            .with(source().matching(semiJoin().capturedAs(SEMI_JOIN)));\n+\n+    @Override\n+    public Pattern<FilterNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isRewriteFilteringSemiJoinToInnerJoin(session);\n+    }\n+\n+    @Override\n+    public Result apply(FilterNode filterNode, Captures captures, Context context)\n+    {\n+        SemiJoinNode semiJoin = captures.get(SEMI_JOIN);\n+\n+        // Do not transform semi-join in context of DELETE\n+        if (PlanNodeSearcher.searchFrom(semiJoin.getSource(), context.getLookup())\n+                .where(node -> node instanceof TableScanNode && ((TableScanNode) node).isForDelete())\n+                .matches()) {\n+            return Result.empty();\n+        }\n+\n+        Symbol semiJoinSymbol = semiJoin.getSemiJoinOutput();\n+        Predicate<Expression> isSemiJoinSymbol = expression -> expression.equals(semiJoinSymbol.toSymbolReference());\n+\n+        List<Expression> conjuncts = extractConjuncts(filterNode.getPredicate());\n+        if (conjuncts.stream().noneMatch(isSemiJoinSymbol)) {\n+            return Result.empty();\n+        }\n+        Expression filteredPredicate = and(conjuncts.stream()\n+                .filter(not(isSemiJoinSymbol))\n+                .collect(toImmutableList()));\n+\n+        PlanNode filteringSourceDistinct = new AggregationNode(\n+                context.getIdAllocator().getNextId(),\n+                semiJoin.getFilteringSource(),\n+                ImmutableMap.of(),\n+                singleGroupingSet(ImmutableList.of(semiJoin.getFilteringSourceJoinSymbol())),\n+                ImmutableList.of(),\n+                SINGLE,\n+                Optional.empty(),\n+                Optional.empty());\n+\n+        Expression joinFilter = new ComparisonExpression(EQUAL, semiJoin.getSourceJoinSymbol().toSymbolReference(), semiJoin.getFilteringSourceJoinSymbol().toSymbolReference());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzM1ODIyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformFilteringSemiJoinToInnerJoin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMjoyODo0OFrOHsCV6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMToyMjo1MFrOHtA7WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzNzc3MA==", "bodyText": "why not to put filteredPredicate immediatelly?", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r515937770", "createdAt": "2020-11-02T12:28:48Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformFilteringSemiJoinToInnerJoin.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.optimizations.PlanNodeSearcher;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.SemiJoinNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.ComparisonExpression;\n+import io.prestosql.sql.tree.Expression;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.SystemSessionProperties.isRewriteFilteringSemiJoinToInnerJoin;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.ExpressionUtils.and;\n+import static io.prestosql.sql.ExpressionUtils.extractConjuncts;\n+import static io.prestosql.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.prestosql.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.semiJoin;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.EQUAL;\n+import static java.util.function.Predicate.not;\n+\n+/**\n+ * Rewrite filtering semi-join to inner join.\n+ * <p/>\n+ * Transforms:\n+ * <pre>\n+ * - Filter (semiJoinSymbol AND predicate)\n+ *    - SemiJoin (semiJoinSymbol <- (a IN b))\n+ *        source: plan A producing symbol a\n+ *        filtering source: plan B producing symbol b\n+ * </pre>\n+ * <p/>\n+ * Into:\n+ * <pre>\n+ * - Filter (predicate)\n+ *    - Project (semiJoinSymbol <- TRUE)\n+ *       - Join INNER on (a = b)\n+ *          - source\n+ *          - Aggregation distinct(b)\n+ *             - filtering source\n+ * </pre>\n+ */\n+public class TransformFilteringSemiJoinToInnerJoin\n+        implements Rule<FilterNode>\n+{\n+    private static final Capture<SemiJoinNode> SEMI_JOIN = newCapture();\n+\n+    private static final Pattern<FilterNode> PATTERN = filter()\n+            .with(source().matching(semiJoin().capturedAs(SEMI_JOIN)));\n+\n+    @Override\n+    public Pattern<FilterNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isRewriteFilteringSemiJoinToInnerJoin(session);\n+    }\n+\n+    @Override\n+    public Result apply(FilterNode filterNode, Captures captures, Context context)\n+    {\n+        SemiJoinNode semiJoin = captures.get(SEMI_JOIN);\n+\n+        // Do not transform semi-join in context of DELETE\n+        if (PlanNodeSearcher.searchFrom(semiJoin.getSource(), context.getLookup())\n+                .where(node -> node instanceof TableScanNode && ((TableScanNode) node).isForDelete())\n+                .matches()) {\n+            return Result.empty();\n+        }\n+\n+        Symbol semiJoinSymbol = semiJoin.getSemiJoinOutput();\n+        Predicate<Expression> isSemiJoinSymbol = expression -> expression.equals(semiJoinSymbol.toSymbolReference());\n+\n+        List<Expression> conjuncts = extractConjuncts(filterNode.getPredicate());\n+        if (conjuncts.stream().noneMatch(isSemiJoinSymbol)) {\n+            return Result.empty();\n+        }\n+        Expression filteredPredicate = and(conjuncts.stream()\n+                .filter(not(isSemiJoinSymbol))\n+                .collect(toImmutableList()));\n+\n+        PlanNode filteringSourceDistinct = new AggregationNode(\n+                context.getIdAllocator().getNextId(),\n+                semiJoin.getFilteringSource(),\n+                ImmutableMap.of(),\n+                singleGroupingSet(ImmutableList.of(semiJoin.getFilteringSourceJoinSymbol())),\n+                ImmutableList.of(),\n+                SINGLE,\n+                Optional.empty(),\n+                Optional.empty());\n+\n+        Expression joinFilter = new ComparisonExpression(EQUAL, semiJoin.getSourceJoinSymbol().toSymbolReference(), semiJoin.getFilteringSourceJoinSymbol().toSymbolReference());\n+\n+        JoinNode innerJoin = new JoinNode(\n+                semiJoin.getId(),\n+                INNER,\n+                semiJoin.getSource(),\n+                filteringSourceDistinct,\n+                ImmutableList.of(),\n+                semiJoin.getSource().getOutputSymbols(),\n+                ImmutableList.of(),\n+                Optional.of(joinFilter),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk2MzE2MA==", "bodyText": "filteredPredicate might depend on the semi join symbol.", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r516963160", "createdAt": "2020-11-03T21:22:50Z", "author": {"login": "kasiafi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformFilteringSemiJoinToInnerJoin.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.optimizations.PlanNodeSearcher;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.SemiJoinNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.ComparisonExpression;\n+import io.prestosql.sql.tree.Expression;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.SystemSessionProperties.isRewriteFilteringSemiJoinToInnerJoin;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.ExpressionUtils.and;\n+import static io.prestosql.sql.ExpressionUtils.extractConjuncts;\n+import static io.prestosql.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.prestosql.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.semiJoin;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.EQUAL;\n+import static java.util.function.Predicate.not;\n+\n+/**\n+ * Rewrite filtering semi-join to inner join.\n+ * <p/>\n+ * Transforms:\n+ * <pre>\n+ * - Filter (semiJoinSymbol AND predicate)\n+ *    - SemiJoin (semiJoinSymbol <- (a IN b))\n+ *        source: plan A producing symbol a\n+ *        filtering source: plan B producing symbol b\n+ * </pre>\n+ * <p/>\n+ * Into:\n+ * <pre>\n+ * - Filter (predicate)\n+ *    - Project (semiJoinSymbol <- TRUE)\n+ *       - Join INNER on (a = b)\n+ *          - source\n+ *          - Aggregation distinct(b)\n+ *             - filtering source\n+ * </pre>\n+ */\n+public class TransformFilteringSemiJoinToInnerJoin\n+        implements Rule<FilterNode>\n+{\n+    private static final Capture<SemiJoinNode> SEMI_JOIN = newCapture();\n+\n+    private static final Pattern<FilterNode> PATTERN = filter()\n+            .with(source().matching(semiJoin().capturedAs(SEMI_JOIN)));\n+\n+    @Override\n+    public Pattern<FilterNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isRewriteFilteringSemiJoinToInnerJoin(session);\n+    }\n+\n+    @Override\n+    public Result apply(FilterNode filterNode, Captures captures, Context context)\n+    {\n+        SemiJoinNode semiJoin = captures.get(SEMI_JOIN);\n+\n+        // Do not transform semi-join in context of DELETE\n+        if (PlanNodeSearcher.searchFrom(semiJoin.getSource(), context.getLookup())\n+                .where(node -> node instanceof TableScanNode && ((TableScanNode) node).isForDelete())\n+                .matches()) {\n+            return Result.empty();\n+        }\n+\n+        Symbol semiJoinSymbol = semiJoin.getSemiJoinOutput();\n+        Predicate<Expression> isSemiJoinSymbol = expression -> expression.equals(semiJoinSymbol.toSymbolReference());\n+\n+        List<Expression> conjuncts = extractConjuncts(filterNode.getPredicate());\n+        if (conjuncts.stream().noneMatch(isSemiJoinSymbol)) {\n+            return Result.empty();\n+        }\n+        Expression filteredPredicate = and(conjuncts.stream()\n+                .filter(not(isSemiJoinSymbol))\n+                .collect(toImmutableList()));\n+\n+        PlanNode filteringSourceDistinct = new AggregationNode(\n+                context.getIdAllocator().getNextId(),\n+                semiJoin.getFilteringSource(),\n+                ImmutableMap.of(),\n+                singleGroupingSet(ImmutableList.of(semiJoin.getFilteringSourceJoinSymbol())),\n+                ImmutableList.of(),\n+                SINGLE,\n+                Optional.empty(),\n+                Optional.empty());\n+\n+        Expression joinFilter = new ComparisonExpression(EQUAL, semiJoin.getSourceJoinSymbol().toSymbolReference(), semiJoin.getFilteringSourceJoinSymbol().toSymbolReference());\n+\n+        JoinNode innerJoin = new JoinNode(\n+                semiJoin.getId(),\n+                INNER,\n+                semiJoin.getSource(),\n+                filteringSourceDistinct,\n+                ImmutableList.of(),\n+                semiJoin.getSource().getOutputSymbols(),\n+                ImmutableList.of(),\n+                Optional.of(joinFilter),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzNzc3MA=="}, "originalCommit": null, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzM2Nzc0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformFilteringSemiJoinToInnerJoin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMjozMTo0MFrOHsCbdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMjowNToyMVrOHtCH5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzOTE5MQ==", "bodyText": "You probably could skip generating of filteredPredicate and just put entire predicate in io.prestosql.sql.planner.plan.JoinNode#filter (assuming true for isSemiJoinSymbol). That would simplify rule.", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r515939191", "createdAt": "2020-11-02T12:31:40Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformFilteringSemiJoinToInnerJoin.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.optimizations.PlanNodeSearcher;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.SemiJoinNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.ComparisonExpression;\n+import io.prestosql.sql.tree.Expression;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.SystemSessionProperties.isRewriteFilteringSemiJoinToInnerJoin;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.ExpressionUtils.and;\n+import static io.prestosql.sql.ExpressionUtils.extractConjuncts;\n+import static io.prestosql.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.prestosql.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.semiJoin;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.EQUAL;\n+import static java.util.function.Predicate.not;\n+\n+/**\n+ * Rewrite filtering semi-join to inner join.\n+ * <p/>\n+ * Transforms:\n+ * <pre>\n+ * - Filter (semiJoinSymbol AND predicate)\n+ *    - SemiJoin (semiJoinSymbol <- (a IN b))\n+ *        source: plan A producing symbol a\n+ *        filtering source: plan B producing symbol b\n+ * </pre>\n+ * <p/>\n+ * Into:\n+ * <pre>\n+ * - Filter (predicate)\n+ *    - Project (semiJoinSymbol <- TRUE)\n+ *       - Join INNER on (a = b)\n+ *          - source\n+ *          - Aggregation distinct(b)\n+ *             - filtering source\n+ * </pre>\n+ */\n+public class TransformFilteringSemiJoinToInnerJoin\n+        implements Rule<FilterNode>\n+{\n+    private static final Capture<SemiJoinNode> SEMI_JOIN = newCapture();\n+\n+    private static final Pattern<FilterNode> PATTERN = filter()\n+            .with(source().matching(semiJoin().capturedAs(SEMI_JOIN)));\n+\n+    @Override\n+    public Pattern<FilterNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isRewriteFilteringSemiJoinToInnerJoin(session);\n+    }\n+\n+    @Override\n+    public Result apply(FilterNode filterNode, Captures captures, Context context)\n+    {\n+        SemiJoinNode semiJoin = captures.get(SEMI_JOIN);\n+\n+        // Do not transform semi-join in context of DELETE\n+        if (PlanNodeSearcher.searchFrom(semiJoin.getSource(), context.getLookup())\n+                .where(node -> node instanceof TableScanNode && ((TableScanNode) node).isForDelete())\n+                .matches()) {\n+            return Result.empty();\n+        }\n+\n+        Symbol semiJoinSymbol = semiJoin.getSemiJoinOutput();\n+        Predicate<Expression> isSemiJoinSymbol = expression -> expression.equals(semiJoinSymbol.toSymbolReference());\n+\n+        List<Expression> conjuncts = extractConjuncts(filterNode.getPredicate());\n+        if (conjuncts.stream().noneMatch(isSemiJoinSymbol)) {\n+            return Result.empty();\n+        }\n+        Expression filteredPredicate = and(conjuncts.stream()\n+                .filter(not(isSemiJoinSymbol))\n+                .collect(toImmutableList()));\n+\n+        PlanNode filteringSourceDistinct = new AggregationNode(\n+                context.getIdAllocator().getNextId(),\n+                semiJoin.getFilteringSource(),\n+                ImmutableMap.of(),\n+                singleGroupingSet(ImmutableList.of(semiJoin.getFilteringSourceJoinSymbol())),\n+                ImmutableList.of(),\n+                SINGLE,\n+                Optional.empty(),\n+                Optional.empty());\n+\n+        Expression joinFilter = new ComparisonExpression(EQUAL, semiJoin.getSourceJoinSymbol().toSymbolReference(), semiJoin.getFilteringSourceJoinSymbol().toSymbolReference());\n+\n+        JoinNode innerJoin = new JoinNode(\n+                semiJoin.getId(),\n+                INNER,\n+                semiJoin.getSource(),\n+                filteringSourceDistinct,\n+                ImmutableList.of(),\n+                semiJoin.getSource().getOutputSymbols(),\n+                ImmutableList.of(),\n+                Optional.of(joinFilter),\n+                Optional.empty(),\n+                Optional.empty(),\n+                Optional.empty(),\n+                Optional.empty(),\n+                semiJoin.getDynamicFilterId()\n+                        .map(id -> ImmutableMap.of(id, semiJoin.getFilteringSourceJoinSymbol()))\n+                        .orElse(ImmutableMap.of()),\n+                Optional.empty());\n+\n+        ProjectNode project = new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                innerJoin,\n+                Assignments.builder()\n+                        .putIdentities(innerJoin.getOutputSymbols())\n+                        .put(semiJoinSymbol, TRUE_LITERAL)\n+                        .build());\n+\n+        if (filteredPredicate.equals(TRUE_LITERAL)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4Mjc1OQ==", "bodyText": "done", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r516982759", "createdAt": "2020-11-03T22:05:21Z", "author": {"login": "kasiafi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformFilteringSemiJoinToInnerJoin.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.optimizations.PlanNodeSearcher;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.SemiJoinNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.ComparisonExpression;\n+import io.prestosql.sql.tree.Expression;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.SystemSessionProperties.isRewriteFilteringSemiJoinToInnerJoin;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.ExpressionUtils.and;\n+import static io.prestosql.sql.ExpressionUtils.extractConjuncts;\n+import static io.prestosql.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.prestosql.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.semiJoin;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.EQUAL;\n+import static java.util.function.Predicate.not;\n+\n+/**\n+ * Rewrite filtering semi-join to inner join.\n+ * <p/>\n+ * Transforms:\n+ * <pre>\n+ * - Filter (semiJoinSymbol AND predicate)\n+ *    - SemiJoin (semiJoinSymbol <- (a IN b))\n+ *        source: plan A producing symbol a\n+ *        filtering source: plan B producing symbol b\n+ * </pre>\n+ * <p/>\n+ * Into:\n+ * <pre>\n+ * - Filter (predicate)\n+ *    - Project (semiJoinSymbol <- TRUE)\n+ *       - Join INNER on (a = b)\n+ *          - source\n+ *          - Aggregation distinct(b)\n+ *             - filtering source\n+ * </pre>\n+ */\n+public class TransformFilteringSemiJoinToInnerJoin\n+        implements Rule<FilterNode>\n+{\n+    private static final Capture<SemiJoinNode> SEMI_JOIN = newCapture();\n+\n+    private static final Pattern<FilterNode> PATTERN = filter()\n+            .with(source().matching(semiJoin().capturedAs(SEMI_JOIN)));\n+\n+    @Override\n+    public Pattern<FilterNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isRewriteFilteringSemiJoinToInnerJoin(session);\n+    }\n+\n+    @Override\n+    public Result apply(FilterNode filterNode, Captures captures, Context context)\n+    {\n+        SemiJoinNode semiJoin = captures.get(SEMI_JOIN);\n+\n+        // Do not transform semi-join in context of DELETE\n+        if (PlanNodeSearcher.searchFrom(semiJoin.getSource(), context.getLookup())\n+                .where(node -> node instanceof TableScanNode && ((TableScanNode) node).isForDelete())\n+                .matches()) {\n+            return Result.empty();\n+        }\n+\n+        Symbol semiJoinSymbol = semiJoin.getSemiJoinOutput();\n+        Predicate<Expression> isSemiJoinSymbol = expression -> expression.equals(semiJoinSymbol.toSymbolReference());\n+\n+        List<Expression> conjuncts = extractConjuncts(filterNode.getPredicate());\n+        if (conjuncts.stream().noneMatch(isSemiJoinSymbol)) {\n+            return Result.empty();\n+        }\n+        Expression filteredPredicate = and(conjuncts.stream()\n+                .filter(not(isSemiJoinSymbol))\n+                .collect(toImmutableList()));\n+\n+        PlanNode filteringSourceDistinct = new AggregationNode(\n+                context.getIdAllocator().getNextId(),\n+                semiJoin.getFilteringSource(),\n+                ImmutableMap.of(),\n+                singleGroupingSet(ImmutableList.of(semiJoin.getFilteringSourceJoinSymbol())),\n+                ImmutableList.of(),\n+                SINGLE,\n+                Optional.empty(),\n+                Optional.empty());\n+\n+        Expression joinFilter = new ComparisonExpression(EQUAL, semiJoin.getSourceJoinSymbol().toSymbolReference(), semiJoin.getFilteringSourceJoinSymbol().toSymbolReference());\n+\n+        JoinNode innerJoin = new JoinNode(\n+                semiJoin.getId(),\n+                INNER,\n+                semiJoin.getSource(),\n+                filteringSourceDistinct,\n+                ImmutableList.of(),\n+                semiJoin.getSource().getOutputSymbols(),\n+                ImmutableList.of(),\n+                Optional.of(joinFilter),\n+                Optional.empty(),\n+                Optional.empty(),\n+                Optional.empty(),\n+                Optional.empty(),\n+                semiJoin.getDynamicFilterId()\n+                        .map(id -> ImmutableMap.of(id, semiJoin.getFilteringSourceJoinSymbol()))\n+                        .orElse(ImmutableMap.of()),\n+                Optional.empty());\n+\n+        ProjectNode project = new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                innerJoin,\n+                Assignments.builder()\n+                        .putIdentities(innerJoin.getOutputSymbols())\n+                        .put(semiJoinSymbol, TRUE_LITERAL)\n+                        .build());\n+\n+        if (filteredPredicate.equals(TRUE_LITERAL)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzOTE5MQ=="}, "originalCommit": null, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzM3NzU4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestQuantifiedComparison.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMjozNDoyNlrOHsCg_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMjozNDoyNlrOHsCg_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0MDYwNA==", "bodyText": "static import INNER", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r515940604", "createdAt": "2020-11-02T12:34:26Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestQuantifiedComparison.java", "diffHunk": "@@ -36,11 +39,11 @@ public void testQuantifiedComparisonEqualsAny()\n     {\n         String query = \"SELECT orderkey, custkey FROM orders WHERE orderkey = ANY (VALUES ROW(CAST(5 as BIGINT)), ROW(CAST(3 as BIGINT)))\";\n         assertPlan(query, anyTree(\n-                    filter(\"S\",\n-                            project(\n-                                    semiJoin(\"X\", \"Y\", \"S\",\n-                                            anyTree(tableScan(\"orders\", ImmutableMap.of(\"X\", \"orderkey\"))),\n-                                            anyTree(values(ImmutableMap.of(\"Y\", 0))))))));\n+                join(\n+                        JoinNode.Type.INNER,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTk2ODAxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestTransformFilteringSemiJoinToInnerJoin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMToxMTozOFrOHtTkTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMTo0NjowMFrOHtUqpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI2ODU1OA==", "bodyText": "static import expression", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r517268558", "createdAt": "2020-11-04T11:11:38Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestTransformFilteringSemiJoinToInnerJoin.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.iterative.rule.test.BaseRuleTest;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.aggregation;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.equiJoinClause;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.join;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.singleGroupingSet;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.values;\n+import static io.prestosql.sql.planner.iterative.rule.test.PlanBuilder.expression;\n+import static io.prestosql.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+\n+public class TestTransformFilteringSemiJoinToInnerJoin\n+        extends BaseRuleTest\n+{\n+    @Test\n+    public void testTransformSemiJoinToInnerJoin()\n+    {\n+        tester().assertThat(new TransformFilteringSemiJoinToInnerJoin())\n+                .on(p -> {\n+                    Symbol a = p.symbol(\"a\");\n+                    Symbol b = p.symbol(\"b\");\n+                    Symbol aInB = p.symbol(\"a_in_b\");\n+                    return p.filter(\n+                            expression(\"a_in_b AND a > 5\"),\n+                            p.semiJoin(\n+                                    p.values(a),\n+                                    p.values(b),\n+                                    a,\n+                                    b,\n+                                    aInB,\n+                                    Optional.empty(),\n+                                    Optional.empty(),\n+                                    Optional.empty()));\n+                })\n+                .matches(project(\n+                        ImmutableMap.of(\"a\", PlanMatchPattern.expression(\"a\"), \"a_in_b\", PlanMatchPattern.expression(\"true\")),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI4NjU2Ng==", "bodyText": "Can't import it due to collision with PlanBuilder.expression()", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r517286566", "createdAt": "2020-11-04T11:46:00Z", "author": {"login": "kasiafi"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestTransformFilteringSemiJoinToInnerJoin.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.iterative.rule.test.BaseRuleTest;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.aggregation;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.equiJoinClause;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.join;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.singleGroupingSet;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.values;\n+import static io.prestosql.sql.planner.iterative.rule.test.PlanBuilder.expression;\n+import static io.prestosql.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+\n+public class TestTransformFilteringSemiJoinToInnerJoin\n+        extends BaseRuleTest\n+{\n+    @Test\n+    public void testTransformSemiJoinToInnerJoin()\n+    {\n+        tester().assertThat(new TransformFilteringSemiJoinToInnerJoin())\n+                .on(p -> {\n+                    Symbol a = p.symbol(\"a\");\n+                    Symbol b = p.symbol(\"b\");\n+                    Symbol aInB = p.symbol(\"a_in_b\");\n+                    return p.filter(\n+                            expression(\"a_in_b AND a > 5\"),\n+                            p.semiJoin(\n+                                    p.values(a),\n+                                    p.values(b),\n+                                    a,\n+                                    b,\n+                                    aInB,\n+                                    Optional.empty(),\n+                                    Optional.empty(),\n+                                    Optional.empty()));\n+                })\n+                .matches(project(\n+                        ImmutableMap.of(\"a\", PlanMatchPattern.expression(\"a\"), \"a_in_b\", PlanMatchPattern.expression(\"true\")),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI2ODU1OA=="}, "originalCommit": null, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NjY0OTI2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestTransformFilteringSemiJoinToInnerJoin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMTo1OTowMlrOHuAEqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMjoxNzowM1rOHuArcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5NzczNw==", "bodyText": "Could we have a test that the rule does not fire with forDelete TS?\nAre there tests for DELETE query with IN (semi-join)?", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r517997737", "createdAt": "2020-11-05T11:59:02Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestTransformFilteringSemiJoinToInnerJoin.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.iterative.rule.test.BaseRuleTest;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.aggregation;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.equiJoinClause;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.join;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.singleGroupingSet;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.values;\n+import static io.prestosql.sql.planner.iterative.rule.test.PlanBuilder.expression;\n+import static io.prestosql.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+\n+public class TestTransformFilteringSemiJoinToInnerJoin\n+        extends BaseRuleTest\n+{\n+    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAwNzY2Ng==", "bodyText": "There's testDelete() in AbstractTestDistributedQueries. It covers the case of SemiJoin under DeleteNode. It runs for Raptor.", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r518007666", "createdAt": "2020-11-05T12:17:03Z", "author": {"login": "kasiafi"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestTransformFilteringSemiJoinToInnerJoin.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.iterative.rule.test.BaseRuleTest;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.aggregation;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.equiJoinClause;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.join;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.singleGroupingSet;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.values;\n+import static io.prestosql.sql.planner.iterative.rule.test.PlanBuilder.expression;\n+import static io.prestosql.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+\n+public class TestTransformFilteringSemiJoinToInnerJoin\n+        extends BaseRuleTest\n+{\n+    @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5NzczNw=="}, "originalCommit": null, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0Njg2NzgxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/test/PlanBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMjo1OTozOVrOHuCJSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMzowNzozOVrOHuCb-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzMTY4OA==", "bodyText": "nit: you could probably extend some exiting method and add an override, but it's also fine", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r518031688", "createdAt": "2020-11-05T12:59:39Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/test/PlanBuilder.java", "diffHunk": "@@ -482,6 +483,17 @@ public CorrelatedJoinNode correlatedJoin(List<Symbol> correlation, PlanNode inpu\n         return new CorrelatedJoinNode(idAllocator.getNextId(), input, subquery, correlation, type, filter, originSubquery);\n     }\n \n+    public TableScanNode tableScan(List<Symbol> symbols, boolean forDelete)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61330e14cfbf888c7a1c524d3128df85669c89d5"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzNjQ3Mw==", "bodyText": "I decided to add a separate method for now. I think we could reorganize the tableScan() methods later when forDelete property is more used and tested.", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r518036473", "createdAt": "2020-11-05T13:07:39Z", "author": {"login": "kasiafi"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/test/PlanBuilder.java", "diffHunk": "@@ -482,6 +483,17 @@ public CorrelatedJoinNode correlatedJoin(List<Symbol> correlation, PlanNode inpu\n         return new CorrelatedJoinNode(idAllocator.getNextId(), input, subquery, correlation, type, filter, originSubquery);\n     }\n \n+    public TableScanNode tableScan(List<Symbol> symbols, boolean forDelete)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzMTY4OA=="}, "originalCommit": {"oid": "61330e14cfbf888c7a1c524d3128df85669c89d5"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4452, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}