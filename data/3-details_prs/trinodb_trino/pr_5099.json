{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgxODkyMTE4", "number": 5099, "title": "Make DynamicFilter future resilient to cancel", "bodyText": "Cancelling CompletableFuture returned by DynamicFilter#isBlocked\nshould not affect dynamic filter collection. If cancellation of\na future from a consumer of DynamicFilter is allowed to propgate\ninto DynamicFilterService or LocalDynamicFiltersCollector,\nthen it will prevent the completion of collection of that\ndynamic filter and it's usage by other consumers.", "createdAt": "2020-09-08T08:56:24Z", "url": "https://github.com/trinodb/trino/pull/5099", "merged": true, "mergeCommit": {"oid": "ef5d7ae099c47037d32945f971165e0a3b72071f"}, "closed": true, "closedAt": "2020-09-10T11:27:16Z", "author": {"login": "raunaqmorarka"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdG0RL8gFqTQ4Mzk1ODAxMw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdG4FyPgFqTQ4NDE3MTc5NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzOTU4MDEz", "url": "https://github.com/trinodb/trino/pull/5099#pullrequestreview-483958013", "createdAt": "2020-09-08T09:29:37Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwOToyOTozOFrOHOUrcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwOTozNDoxMlrOHOU2oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4MDkxNA==", "bodyText": "remove, we don't need to assert these in every test", "url": "https://github.com/trinodb/trino/pull/5099#discussion_r484780914", "createdAt": "2020-09-08T09:29:38Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/server/TestDynamicFilterService.java", "diffHunk": "@@ -434,6 +435,75 @@ public void testReplicatedDynamicFilter()\n         assertEquals(dynamicFiltersStageSupplier.getRequestCount(), 1);\n     }\n \n+    @Test\n+    public void testDynamicFilterCancellation()\n+    {\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(new FeaturesConfig());\n+        DynamicFilterId filterId = new DynamicFilterId(\"df\");\n+        Expression df1 = expression(\"DF_SYMBOL1\");\n+        QueryId queryId = new QueryId(\"query\");\n+        StageId stageId = new StageId(queryId, 0);\n+        List<TaskId> taskIds = ImmutableList.of(new TaskId(stageId, 0), new TaskId(stageId, 1));\n+\n+        TestDynamicFiltersStageSupplier dynamicFiltersStageSupplier = new TestDynamicFiltersStageSupplier(RUNNING);\n+        dynamicFiltersStageSupplier.addTasks(taskIds);\n+        dynamicFilterService.registerQuery(queryId, dynamicFiltersStageSupplier, ImmutableSet.of(filterId), ImmutableSet.of(filterId), ImmutableSet.of());\n+        ColumnHandle column = new TestingColumnHandle(\"probeColumnA\");\n+        DynamicFilter dynamicFilter = dynamicFilterService.createDynamicFilter(\n+                queryId,\n+                ImmutableList.of(new DynamicFilters.Descriptor(filterId, df1)),\n+                ImmutableMap.of(\n+                        Symbol.from(df1), column));\n+        assertFalse(dynamicFilter.isBlocked().isDone());\n+        assertFalse(dynamicFilter.isComplete());\n+        assertEquals(dynamicFilter.getCurrentPredicate(), TupleDomain.all());\n+\n+        // assert initial dynamic filtering stats", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4MTQ5NQ==", "bodyText": "remove, we don't need to test these in every test case", "url": "https://github.com/trinodb/trino/pull/5099#discussion_r484781495", "createdAt": "2020-09-08T09:30:33Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/server/TestDynamicFilterService.java", "diffHunk": "@@ -434,6 +435,75 @@ public void testReplicatedDynamicFilter()\n         assertEquals(dynamicFiltersStageSupplier.getRequestCount(), 1);\n     }\n \n+    @Test\n+    public void testDynamicFilterCancellation()\n+    {\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(new FeaturesConfig());\n+        DynamicFilterId filterId = new DynamicFilterId(\"df\");\n+        Expression df1 = expression(\"DF_SYMBOL1\");\n+        QueryId queryId = new QueryId(\"query\");\n+        StageId stageId = new StageId(queryId, 0);\n+        List<TaskId> taskIds = ImmutableList.of(new TaskId(stageId, 0), new TaskId(stageId, 1));\n+\n+        TestDynamicFiltersStageSupplier dynamicFiltersStageSupplier = new TestDynamicFiltersStageSupplier(RUNNING);\n+        dynamicFiltersStageSupplier.addTasks(taskIds);\n+        dynamicFilterService.registerQuery(queryId, dynamicFiltersStageSupplier, ImmutableSet.of(filterId), ImmutableSet.of(filterId), ImmutableSet.of());\n+        ColumnHandle column = new TestingColumnHandle(\"probeColumnA\");\n+        DynamicFilter dynamicFilter = dynamicFilterService.createDynamicFilter(\n+                queryId,\n+                ImmutableList.of(new DynamicFilters.Descriptor(filterId, df1)),\n+                ImmutableMap.of(\n+                        Symbol.from(df1), column));\n+        assertFalse(dynamicFilter.isBlocked().isDone());\n+        assertFalse(dynamicFilter.isComplete());\n+        assertEquals(dynamicFilter.getCurrentPredicate(), TupleDomain.all());\n+\n+        // assert initial dynamic filtering stats\n+        DynamicFiltersStats stats = dynamicFilterService.getDynamicFilteringStats(queryId, session);\n+        assertEquals(stats.getTotalDynamicFilters(), 1);\n+        assertEquals(stats.getDynamicFiltersCompleted(), 0);\n+        assertEquals(stats.getLazyDynamicFilters(), 1);\n+        assertEquals(stats.getReplicatedDynamicFilters(), 0);\n+\n+        dynamicFiltersStageSupplier.storeSummary(\n+                filterId,\n+                new TaskId(stageId, 0),\n+                singleValue(INTEGER, 1L));\n+        dynamicFilterService.collectDynamicFilters();\n+        assertEquals(dynamicFilter.getCurrentPredicate(), TupleDomain.all());\n+\n+        stats = dynamicFilterService.getDynamicFilteringStats(queryId, session);\n+        assertEquals(stats.getDynamicFiltersCompleted(), 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4MTgwNQ==", "bodyText": "remove, we don't need to test these in every test case", "url": "https://github.com/trinodb/trino/pull/5099#discussion_r484781805", "createdAt": "2020-09-08T09:31:00Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/server/TestDynamicFilterService.java", "diffHunk": "@@ -434,6 +435,75 @@ public void testReplicatedDynamicFilter()\n         assertEquals(dynamicFiltersStageSupplier.getRequestCount(), 1);\n     }\n \n+    @Test\n+    public void testDynamicFilterCancellation()\n+    {\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(new FeaturesConfig());\n+        DynamicFilterId filterId = new DynamicFilterId(\"df\");\n+        Expression df1 = expression(\"DF_SYMBOL1\");\n+        QueryId queryId = new QueryId(\"query\");\n+        StageId stageId = new StageId(queryId, 0);\n+        List<TaskId> taskIds = ImmutableList.of(new TaskId(stageId, 0), new TaskId(stageId, 1));\n+\n+        TestDynamicFiltersStageSupplier dynamicFiltersStageSupplier = new TestDynamicFiltersStageSupplier(RUNNING);\n+        dynamicFiltersStageSupplier.addTasks(taskIds);\n+        dynamicFilterService.registerQuery(queryId, dynamicFiltersStageSupplier, ImmutableSet.of(filterId), ImmutableSet.of(filterId), ImmutableSet.of());\n+        ColumnHandle column = new TestingColumnHandle(\"probeColumnA\");\n+        DynamicFilter dynamicFilter = dynamicFilterService.createDynamicFilter(\n+                queryId,\n+                ImmutableList.of(new DynamicFilters.Descriptor(filterId, df1)),\n+                ImmutableMap.of(\n+                        Symbol.from(df1), column));\n+        assertFalse(dynamicFilter.isBlocked().isDone());\n+        assertFalse(dynamicFilter.isComplete());\n+        assertEquals(dynamicFilter.getCurrentPredicate(), TupleDomain.all());\n+\n+        // assert initial dynamic filtering stats\n+        DynamicFiltersStats stats = dynamicFilterService.getDynamicFilteringStats(queryId, session);\n+        assertEquals(stats.getTotalDynamicFilters(), 1);\n+        assertEquals(stats.getDynamicFiltersCompleted(), 0);\n+        assertEquals(stats.getLazyDynamicFilters(), 1);\n+        assertEquals(stats.getReplicatedDynamicFilters(), 0);\n+\n+        dynamicFiltersStageSupplier.storeSummary(\n+                filterId,\n+                new TaskId(stageId, 0),\n+                singleValue(INTEGER, 1L));\n+        dynamicFilterService.collectDynamicFilters();\n+        assertEquals(dynamicFilter.getCurrentPredicate(), TupleDomain.all());\n+\n+        stats = dynamicFilterService.getDynamicFilteringStats(queryId, session);\n+        assertEquals(stats.getDynamicFiltersCompleted(), 0);\n+\n+        // DynamicFilter future cancellation should not affect DynamicFilterService\n+        CompletableFuture<?> isBlocked = dynamicFilter.isBlocked();\n+        assertFalse(isBlocked.isDone());\n+        assertFalse(isBlocked.cancel(false));\n+        assertFalse(dynamicFilter.isBlocked().isDone());\n+        assertFalse(dynamicFilter.isComplete());\n+        stats = dynamicFilterService.getDynamicFilteringStats(queryId, session);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4MjYzMQ==", "bodyText": "use cancelled isBlocked instead of new future", "url": "https://github.com/trinodb/trino/pull/5099#discussion_r484782631", "createdAt": "2020-09-08T09:32:25Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/server/TestDynamicFilterService.java", "diffHunk": "@@ -434,6 +435,75 @@ public void testReplicatedDynamicFilter()\n         assertEquals(dynamicFiltersStageSupplier.getRequestCount(), 1);\n     }\n \n+    @Test\n+    public void testDynamicFilterCancellation()\n+    {\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(new FeaturesConfig());\n+        DynamicFilterId filterId = new DynamicFilterId(\"df\");\n+        Expression df1 = expression(\"DF_SYMBOL1\");\n+        QueryId queryId = new QueryId(\"query\");\n+        StageId stageId = new StageId(queryId, 0);\n+        List<TaskId> taskIds = ImmutableList.of(new TaskId(stageId, 0), new TaskId(stageId, 1));\n+\n+        TestDynamicFiltersStageSupplier dynamicFiltersStageSupplier = new TestDynamicFiltersStageSupplier(RUNNING);\n+        dynamicFiltersStageSupplier.addTasks(taskIds);\n+        dynamicFilterService.registerQuery(queryId, dynamicFiltersStageSupplier, ImmutableSet.of(filterId), ImmutableSet.of(filterId), ImmutableSet.of());\n+        ColumnHandle column = new TestingColumnHandle(\"probeColumnA\");\n+        DynamicFilter dynamicFilter = dynamicFilterService.createDynamicFilter(\n+                queryId,\n+                ImmutableList.of(new DynamicFilters.Descriptor(filterId, df1)),\n+                ImmutableMap.of(\n+                        Symbol.from(df1), column));\n+        assertFalse(dynamicFilter.isBlocked().isDone());\n+        assertFalse(dynamicFilter.isComplete());\n+        assertEquals(dynamicFilter.getCurrentPredicate(), TupleDomain.all());\n+\n+        // assert initial dynamic filtering stats\n+        DynamicFiltersStats stats = dynamicFilterService.getDynamicFilteringStats(queryId, session);\n+        assertEquals(stats.getTotalDynamicFilters(), 1);\n+        assertEquals(stats.getDynamicFiltersCompleted(), 0);\n+        assertEquals(stats.getLazyDynamicFilters(), 1);\n+        assertEquals(stats.getReplicatedDynamicFilters(), 0);\n+\n+        dynamicFiltersStageSupplier.storeSummary(\n+                filterId,\n+                new TaskId(stageId, 0),\n+                singleValue(INTEGER, 1L));\n+        dynamicFilterService.collectDynamicFilters();\n+        assertEquals(dynamicFilter.getCurrentPredicate(), TupleDomain.all());\n+\n+        stats = dynamicFilterService.getDynamicFilteringStats(queryId, session);\n+        assertEquals(stats.getDynamicFiltersCompleted(), 0);\n+\n+        // DynamicFilter future cancellation should not affect DynamicFilterService\n+        CompletableFuture<?> isBlocked = dynamicFilter.isBlocked();\n+        assertFalse(isBlocked.isDone());\n+        assertFalse(isBlocked.cancel(false));\n+        assertFalse(dynamicFilter.isBlocked().isDone());\n+        assertFalse(dynamicFilter.isComplete());\n+        stats = dynamicFilterService.getDynamicFilteringStats(queryId, session);\n+        assertEquals(stats.getDynamicFiltersCompleted(), 0);\n+\n+        dynamicFiltersStageSupplier.storeSummary(\n+                filterId,\n+                new TaskId(stageId, 1),\n+                singleValue(INTEGER, 2L));\n+        dynamicFilterService.collectDynamicFilters();\n+        assertTrue(dynamicFilter.isBlocked().isDone());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4MjkxMg==", "bodyText": "remove, we don't need to test these in every test case", "url": "https://github.com/trinodb/trino/pull/5099#discussion_r484782912", "createdAt": "2020-09-08T09:32:52Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/server/TestDynamicFilterService.java", "diffHunk": "@@ -434,6 +435,75 @@ public void testReplicatedDynamicFilter()\n         assertEquals(dynamicFiltersStageSupplier.getRequestCount(), 1);\n     }\n \n+    @Test\n+    public void testDynamicFilterCancellation()\n+    {\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(new FeaturesConfig());\n+        DynamicFilterId filterId = new DynamicFilterId(\"df\");\n+        Expression df1 = expression(\"DF_SYMBOL1\");\n+        QueryId queryId = new QueryId(\"query\");\n+        StageId stageId = new StageId(queryId, 0);\n+        List<TaskId> taskIds = ImmutableList.of(new TaskId(stageId, 0), new TaskId(stageId, 1));\n+\n+        TestDynamicFiltersStageSupplier dynamicFiltersStageSupplier = new TestDynamicFiltersStageSupplier(RUNNING);\n+        dynamicFiltersStageSupplier.addTasks(taskIds);\n+        dynamicFilterService.registerQuery(queryId, dynamicFiltersStageSupplier, ImmutableSet.of(filterId), ImmutableSet.of(filterId), ImmutableSet.of());\n+        ColumnHandle column = new TestingColumnHandle(\"probeColumnA\");\n+        DynamicFilter dynamicFilter = dynamicFilterService.createDynamicFilter(\n+                queryId,\n+                ImmutableList.of(new DynamicFilters.Descriptor(filterId, df1)),\n+                ImmutableMap.of(\n+                        Symbol.from(df1), column));\n+        assertFalse(dynamicFilter.isBlocked().isDone());\n+        assertFalse(dynamicFilter.isComplete());\n+        assertEquals(dynamicFilter.getCurrentPredicate(), TupleDomain.all());\n+\n+        // assert initial dynamic filtering stats\n+        DynamicFiltersStats stats = dynamicFilterService.getDynamicFilteringStats(queryId, session);\n+        assertEquals(stats.getTotalDynamicFilters(), 1);\n+        assertEquals(stats.getDynamicFiltersCompleted(), 0);\n+        assertEquals(stats.getLazyDynamicFilters(), 1);\n+        assertEquals(stats.getReplicatedDynamicFilters(), 0);\n+\n+        dynamicFiltersStageSupplier.storeSummary(\n+                filterId,\n+                new TaskId(stageId, 0),\n+                singleValue(INTEGER, 1L));\n+        dynamicFilterService.collectDynamicFilters();\n+        assertEquals(dynamicFilter.getCurrentPredicate(), TupleDomain.all());\n+\n+        stats = dynamicFilterService.getDynamicFilteringStats(queryId, session);\n+        assertEquals(stats.getDynamicFiltersCompleted(), 0);\n+\n+        // DynamicFilter future cancellation should not affect DynamicFilterService\n+        CompletableFuture<?> isBlocked = dynamicFilter.isBlocked();\n+        assertFalse(isBlocked.isDone());\n+        assertFalse(isBlocked.cancel(false));\n+        assertFalse(dynamicFilter.isBlocked().isDone());\n+        assertFalse(dynamicFilter.isComplete());\n+        stats = dynamicFilterService.getDynamicFilteringStats(queryId, session);\n+        assertEquals(stats.getDynamicFiltersCompleted(), 0);\n+\n+        dynamicFiltersStageSupplier.storeSummary(\n+                filterId,\n+                new TaskId(stageId, 1),\n+                singleValue(INTEGER, 2L));\n+        dynamicFilterService.collectDynamicFilters();\n+        assertTrue(dynamicFilter.isBlocked().isDone());\n+        assertTrue(dynamicFilter.isComplete());\n+        assertEquals(dynamicFilter.getCurrentPredicate(), TupleDomain.withColumnDomains(\n+                ImmutableMap.of(column, multipleValues(INTEGER, ImmutableList.of(1L, 2L)))));\n+\n+        stats = dynamicFilterService.getDynamicFilteringStats(queryId, session);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4Mzc3Ng==", "bodyText": "use cancelled isBlocked future for assertion instead of new future", "url": "https://github.com/trinodb/trino/pull/5099#discussion_r484783776", "createdAt": "2020-09-08T09:34:12Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "diffHunk": "@@ -63,6 +63,38 @@ public void testSingle()\n         assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(column, domain)));\n     }\n \n+    @Test\n+    public void testDynamicFilterCancellation()\n+    {\n+        LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n+        DynamicFilterId filterId = new DynamicFilterId(\"filter\");\n+        collector.register(ImmutableSet.of(filterId));\n+\n+        Symbol symbol = new Symbol(\"symbol\");\n+        ColumnHandle column = new TestingColumnHandle(\"column\");\n+        DynamicFilter filter = collector.createDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(filterId, symbol.toSymbolReference())),\n+                ImmutableMap.of(symbol, column));\n+\n+        // Filter is blocked and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertFalse(filter.isComplete());\n+        assertFalse(isBlocked.isDone());\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+        // DynamicFilter future cancellation should not affect LocalDynamicFiltersCollector\n+        assertFalse(isBlocked.cancel(false));\n+        assertFalse(filter.isBlocked().isDone());\n+        assertFalse(filter.isComplete());\n+\n+        Domain domain = Domain.singleValue(BIGINT, 7L);\n+        collector.collectDynamicFilterDomains(ImmutableMap.of(filterId, domain));\n+\n+        // Unblocked and completed.\n+        assertTrue(filter.isComplete());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "adf09886585285b113971e8dfaf075b3ff1335bf", "author": {"user": {"login": "raunaqmorarka", "name": "Raunaq Morarka"}}, "url": "https://github.com/trinodb/trino/commit/adf09886585285b113971e8dfaf075b3ff1335bf", "committedDate": "2020-09-08T13:35:56Z", "message": "Make DynamicFilter future resilient to cancel\n\nCancelling CompletableFuture returned by DynamicFilter#isBlocked\nshould not affect dynamic filter collection. If cancellation of\na future from a consumer of DynamicFilter is allowed to propgate\ninto DynamicFilterService or LocalDynamicFiltersCollector,\nthen it will prevent the completion of collection of that\ndynamic filter and it's usage by other consumers."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "adf09886585285b113971e8dfaf075b3ff1335bf", "author": {"user": {"login": "raunaqmorarka", "name": "Raunaq Morarka"}}, "url": "https://github.com/trinodb/trino/commit/adf09886585285b113971e8dfaf075b3ff1335bf", "committedDate": "2020-09-08T13:35:56Z", "message": "Make DynamicFilter future resilient to cancel\n\nCancelling CompletableFuture returned by DynamicFilter#isBlocked\nshould not affect dynamic filter collection. If cancellation of\na future from a consumer of DynamicFilter is allowed to propgate\ninto DynamicFilterService or LocalDynamicFiltersCollector,\nthen it will prevent the completion of collection of that\ndynamic filter and it's usage by other consumers."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MTcxNzk1", "url": "https://github.com/trinodb/trino/pull/5099#pullrequestreview-484171795", "createdAt": "2020-09-08T14:01:47Z", "commit": {"oid": "adf09886585285b113971e8dfaf075b3ff1335bf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3910, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}