{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYwNjU4NzMz", "number": 4661, "title": "Integrate Coral with Presto to enable querying hive views", "bodyText": "", "createdAt": "2020-08-01T00:53:53Z", "url": "https://github.com/trinodb/trino/pull/4661", "merged": true, "mergeCommit": {"oid": "47dbba4140f474b3179e54176bfb12523f76ca57"}, "closed": true, "closedAt": "2020-10-13T18:44:24Z", "author": {"login": "laurachenyu"}, "timelineItems": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc7YqpXgBqjM2MTc2MDg0MTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdTr_LHgFqTUxMTEyNDcxNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNDQ1Mzk3", "url": "https://github.com/trinodb/trino/pull/4661#pullrequestreview-460445397", "createdAt": "2020-08-04T01:57:16Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwMTo1NzoxNlrOG7OViw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwMjoxNDowN1rOG7Omtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1NDA1OQ==", "bodyText": "It looks like there was a rebase conflict which duplicated these dependencies. We recently re-ordered all the dependencies in the POMs.", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r464754059", "createdAt": "2020-08-04T01:57:16Z", "author": {"login": "electrum"}, "path": "pom.xml", "diffHunk": "@@ -573,6 +583,87 @@\n                 <version>1.0</version>\n             </dependency>\n \n+            <!-- Airlift -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1NDk5MA==", "bodyText": "I assume this is temporary and these artifacts will soon be published to Maven Central? We don't want to depend on a third party repository.", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r464754990", "createdAt": "2020-08-04T02:01:01Z", "author": {"login": "electrum"}, "path": "pom.xml", "diffHunk": "@@ -33,6 +33,13 @@\n         <tag>HEAD</tag>\n     </scm>\n \n+    <repositories>\n+        <repository>\n+            <id>dl.bintray</id>\n+            <url>http://dl.bintray.com/funcheetah8/maven/</url>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1NTE3NA==", "bodyText": "Let's remove this comment. We don't have it for other dependencies.", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r464755174", "createdAt": "2020-08-04T02:01:36Z", "author": {"login": "electrum"}, "path": "pom.xml", "diffHunk": "@@ -54,6 +61,9 @@\n         <dep.oracle.version>19.3.0.0</dep.oracle.version>\n         <dep.drift.version>1.14</dep.drift.version>\n         <dep.tempto.version>180</dep.tempto.version>\n+        <!-- coral version for reading hive views -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1NTI4MA==", "bodyText": "No need for a property here since it's only used for one dependency. We only add properties for versions that need to be the same across multiple dependencies.", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r464755280", "createdAt": "2020-08-04T02:02:02Z", "author": {"login": "electrum"}, "path": "pom.xml", "diffHunk": "@@ -54,6 +61,9 @@\n         <dep.oracle.version>19.3.0.0</dep.oracle.version>\n         <dep.drift.version>1.14</dep.drift.version>\n         <dep.tempto.version>180</dep.tempto.version>\n+        <!-- coral version for reading hive views -->\n+        <dep.coral.version>1.0.5</dep.coral.version>\n+        <dep.calcite.version>1.21.1.1</dep.calcite.version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1NTUzMw==", "bodyText": "Remove version since it's specified in the room POM", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r464755533", "createdAt": "2020-08-04T02:02:57Z", "author": {"login": "electrum"}, "path": "presto-hive/pom.xml", "diffHunk": "@@ -351,7 +351,36 @@\n             <artifactId>testng</artifactId>\n             <scope>test</scope>\n         </dependency>\n-    </dependencies>\n+        \n+        <!-- for coral -->\n+        <dependency>\n+            <groupId>com.linkedin.coral</groupId>\n+            <artifactId>coral-presto</artifactId>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>com.linkedin.calcite</groupId>\n+            <artifactId>calcite-core</artifactId>\n+            <version>1.21.1.1</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1NTYxOA==", "bodyText": "Remove exclusions since they are in the root POM", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r464755618", "createdAt": "2020-08-04T02:03:15Z", "author": {"login": "electrum"}, "path": "presto-hive/pom.xml", "diffHunk": "@@ -351,7 +351,36 @@\n             <artifactId>testng</artifactId>\n             <scope>test</scope>\n         </dependency>\n-    </dependencies>\n+        \n+        <!-- for coral -->\n+        <dependency>\n+            <groupId>com.linkedin.coral</groupId>\n+            <artifactId>coral-presto</artifactId>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>com.linkedin.calcite</groupId>\n+            <artifactId>calcite-core</artifactId>\n+            <version>1.21.1.1</version>\n+            <classifier>shaded</classifier>\n+            <scope>compile</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>com.linkedin.coral</groupId>\n+            <artifactId>coral-hive</artifactId>\n+            <exclusions>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1Njg5NQ==", "bodyText": "Since this abstract class only defines one method and doesn't have any state or other helpers, it might be cleaner to structure it as a utility class with a nested interface:\npublic final class ViewReaderUtil\n{\n    public interface ViewReader\n    {\n        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n    }\n\n    public static ViewReader createViewReader(...) ...\n}", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r464756895", "createdAt": "2020-08-04T02:08:09Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReader.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.base.Preconditions;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_UNKNOWN_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+/**\n+ * Decode view definitions stored in Hive metastore. This class instantiates\n+ * correct decoder based on the type of view (hive or presto view).\n+ */\n+public abstract class ViewReader", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1ODQ1NQ==", "bodyText": "We should move this to io.prestosql.tests.hive.TestHiveViews which already tests Hive view translation. Many of those tests will need to be updated anyway, as the translation will work with Coral.", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r464758455", "createdAt": "2020-08-04T02:14:07Z", "author": {"login": "electrum"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestCoralIntegration.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.Files;\n+import io.prestosql.Session;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.Database;\n+import io.prestosql.plugin.hive.metastore.MetastoreUtil;\n+import io.prestosql.plugin.hive.metastore.Storage;\n+import io.prestosql.plugin.hive.metastore.StorageFormat;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.plugin.hive.metastore.file.FileHiveMetastore;\n+import io.prestosql.plugin.hive.testing.TestingHivePlugin;\n+import io.prestosql.plugin.tpch.TpchPlugin;\n+import io.prestosql.spi.security.PrincipalType;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.TestingSession;\n+import io.prestosql.tpch.TpchTable;\n+import org.apache.hadoop.hive.metastore.TableType;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+import static com.google.common.io.MoreFiles.deleteRecursively;\n+import static com.google.common.io.RecursiveDeleteOption.ALLOW_INSECURE;\n+import static io.prestosql.plugin.hive.HiveQueryRunner.TPCH_SCHEMA;\n+import static io.prestosql.plugin.tpch.TpchMetadata.TINY_SCHEMA_NAME;\n+import static io.prestosql.testing.QueryAssertions.copyTpchTables;\n+\n+public class TestCoralIntegration\n+        extends AbstractTestQueryFramework\n+{\n+    private static final String HIVE_CATALOG = \"hive\";\n+    private File catalogDirectory = Files.createTempDir();\n+\n+    @AfterClass(alwaysRun = true)\n+    public void close()\n+    {\n+        try {\n+            deleteRecursively(catalogDirectory.toPath(), ALLOW_INSECURE);\n+        }\n+        catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        Session session = TestingSession.testSessionBuilder().setCatalog(HIVE_CATALOG).build();\n+        DistributedQueryRunner queryRunner = DistributedQueryRunner.builder(session).build();\n+\n+        // Create tpch catalog\n+        queryRunner.installPlugin(new TpchPlugin());\n+        queryRunner.createCatalog(\"tpch\", \"tpch\", ImmutableMap.of());\n+\n+        // Create hive catalog\n+        FileHiveMetastore metastore = FileHiveMetastore.createTestingFileHiveMetastore(catalogDirectory);\n+        queryRunner.installPlugin(new TestingHivePlugin(metastore));\n+        queryRunner.createCatalog(HIVE_CATALOG, \"hive\", ImmutableMap.of());\n+\n+        // Populate TPC-H tables to Hive\n+        metastore.createDatabase(new HiveIdentity(session.toConnectorSession()), new Database(TPCH_SCHEMA, Optional.empty(), \"ignored\", PrincipalType.USER, Optional.empty(), ImmutableMap.of()));\n+        Session tpchSession = Session.builder(queryRunner.getDefaultSession()).setSchema(\"tpch\").build();\n+        copyTpchTables(queryRunner, \"tpch\", TINY_SCHEMA_NAME, tpchSession, ImmutableList.of(TpchTable.ORDERS));\n+\n+        // And create the Hive-defined views we'll use for testing\n+        createHiveView(\n+                metastore,\n+                new HiveIdentity(session.toConnectorSession()),\n+                \"tpch\",\n+                \"counting_view\",\n+                \"select count(1) as count from tpch.orders\",\n+                \"select count(1) as `count` from `tpch`.`orders`\");\n+        createHiveView(\n+                metastore,\n+                new HiveIdentity(session.toConnectorSession()),\n+                \"tpch\",\n+                \"zero_index_view\",\n+                // Arrays in Hive are zero-indexed. This query will return 'hive' only if it's being parsed as a Hive query\n+                \"select array('presto','hive')[1] as sql_dialect\",\n+                \"select array('presto','hive')[1] as `sql_dialect`\");\n+\n+        return queryRunner;\n+    }\n+\n+    private static void createHiveView(FileHiveMetastore metastore, HiveIdentity identity, String databaseName, String tableName, String originalViewText, String expandedViewText)\n+    {\n+        Storage storage = Storage.builder()\n+                .setLocation(\"\")\n+                .setStorageFormat(StorageFormat.VIEW_STORAGE_FORMAT)\n+                .setBucketProperty(Optional.empty())\n+                .setSerdeParameters(ImmutableMap.of())\n+                .build();\n+        metastore.createTable(identity, new Table(\n+                        databaseName,\n+                        tableName,\n+                        \"admin\",\n+                        TableType.VIRTUAL_VIEW.toString(),\n+                        storage,\n+                        ImmutableList.of(),\n+                        ImmutableList.of(),\n+                        ImmutableMap.of(),\n+                        Optional.of(originalViewText),\n+                        Optional.of(expandedViewText)),\n+                MetastoreUtil.buildInitialPrivilegeSet(\"admin\"));\n+    }\n+\n+    // The intent here is not to exhaustively test Coral itself, only that we have properly integrated with it. Queries of all different shapes are tested within Coral.\n+    @Test\n+    public void testSimpleCoralIntegration()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 131}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyMzgyMzE1", "url": "https://github.com/trinodb/trino/pull/4661#pullrequestreview-462382315", "createdAt": "2020-08-06T10:05:06Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxMDowNTowNlrOG8tEbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxMDoxNToxNlrOG8tYuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMwNjE1OA==", "bodyText": "Does this work for field names with special characters that need quoting? Or does the field already return the quoted name?", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r466306158", "createdAt": "2020-08-06T10:05:06Z", "author": {"login": "hashhar"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReader.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.base.Preconditions;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_UNKNOWN_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+/**\n+ * Decode view definitions stored in Hive metastore. This class instantiates\n+ * correct decoder based on the type of view (hive or presto view).\n+ */\n+public abstract class ViewReader\n+{\n+    public static final String PRESTO_VIEW_FLAG = \"presto_view\";\n+\n+    static final String VIEW_PREFIX = \"/* Presto View: \";\n+    static final String VIEW_SUFFIX = \" */\";\n+\n+    private static final JsonCodec<ConnectorViewDefinition> VIEW_CODEC =\n+            new JsonCodecFactory(new ObjectMapperProvider()).jsonCodec(ConnectorViewDefinition.class);\n+\n+    private static Logger log = Logger.get(ViewReader.class);\n+\n+    public static boolean isPrestoView(Table table)\n+    {\n+        return \"true\".equals(table.getParameters().get(PRESTO_VIEW_FLAG));\n+    }\n+\n+    public static boolean isHiveOrPrestoView(Table table)\n+    {\n+        return table.getTableType().equals(TableType.VIRTUAL_VIEW.name());\n+    }\n+\n+    public static boolean canDecodeView(Table table)\n+    {\n+        // we can decode Hive or Presto view\n+        return table.getTableType().equals(VIRTUAL_VIEW.name());\n+    }\n+\n+    public static String encodeViewData(ConnectorViewDefinition definition)\n+    {\n+        byte[] bytes = VIEW_CODEC.toJsonBytes(definition);\n+        String data = Base64.getEncoder().encodeToString(bytes);\n+        return VIEW_PREFIX + data + VIEW_SUFFIX;\n+    }\n+\n+    /**\n+     * Decodes view definition stored in hive metastore. Currently, it supports decoding\n+     * hive or presto view definitions.\n+     *\n+     * @param metastore hive metastore to read view definitions from. This is required\n+     * to decode Hive view definitions.\n+     * @param table virtual table (view) instance\n+     * @return json representation of view definition\n+     */\n+    public static ConnectorViewDefinition decodeView(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, CatalogName catalogName, TypeManager typemanager)\n+    {\n+        ViewReader viewReader = create(metastore, identity, table, typemanager);\n+        return viewReader.decodeViewData(table.getViewOriginalText().get(), table, catalogName);\n+    }\n+\n+    public static ViewReader create(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new PrestoViewDecoder();\n+        }\n+        else {\n+            return new HiveViewDecoder(new CoralSemiTransactionalHiveMSCAdapter(metastore, identity), typemanager);\n+        }\n+    }\n+\n+    /**\n+     * Decode view definition\n+     *\n+     * @param viewData view definition stored as \"View Original Text\" in Hive metastore\n+     * @param table table representing virtual view to decode\n+     * @return json representation of view definition\n+     */\n+    public abstract ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+\n+    /**\n+     * Supports decoding of Presto views\n+     */\n+    public static class PrestoViewDecoder\n+            extends ViewReader\n+    {\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName)\n+        {\n+            checkCondition(viewData.startsWith(VIEW_PREFIX), HIVE_INVALID_VIEW_DATA, \"View data missing prefix: %s\", viewData);\n+            checkCondition(viewData.endsWith(VIEW_SUFFIX), HIVE_INVALID_VIEW_DATA, \"View data missing suffix: %s\", viewData);\n+            viewData = viewData.substring(VIEW_PREFIX.length());\n+            viewData = viewData.substring(0, viewData.length() - VIEW_SUFFIX.length());\n+            byte[] bytes = Base64.getDecoder().decode(viewData);\n+            return VIEW_CODEC.fromJson(bytes);\n+        }\n+    }\n+\n+    /**\n+     * Class to decode Hive view definitions\n+     */\n+    public static class HiveViewDecoder\n+            extends ViewReader\n+    {\n+        private final HiveMetastoreClient mscClient;\n+        private final TypeManager typeManager;\n+\n+        public HiveViewDecoder(HiveMetastoreClient mscClient, TypeManager typemanager)\n+        {\n+            this.mscClient = mscClient;\n+            this.typeManager = requireNonNull(typemanager, \"metadata is null\");\n+        }\n+\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewSql, Table table, CatalogName catalogName)\n+        {\n+            try {\n+                HiveToRelConverter hiveToRelConverter = HiveToRelConverter.create(mscClient);\n+                RelNode rel = hiveToRelConverter.convertView(table.getDatabaseName(), table.getTableName());\n+                RelToPrestoConverter rel2Presto = new RelToPrestoConverter();\n+                String prestoSql = rel2Presto.convert(rel);\n+                RelDataType rowType = rel.getRowType();\n+                List<ConnectorViewDefinition.ViewColumn> columns = new ArrayList<>(rowType.getFieldCount());\n+                for (RelDataTypeField field : rowType.getFieldList()) {\n+                    log.debug(\"Adding column %s, %s, %s, %s\", field.getName(),\n+                            field.getType().getFullTypeString(),\n+                            field.getType().getSqlTypeName(),\n+                            field);\n+\n+                    Type type = typeManager.fromSqlType(getTypeString(field.getType()));\n+                    ConnectorViewDefinition.ViewColumn column = new ConnectorViewDefinition.ViewColumn(field.getName(), type.getTypeId());\n+                    columns.add(column);\n+                }\n+                return new ConnectorViewDefinition(prestoSql,\n+                        Optional.of(catalogName.toString()),\n+                        Optional.of(table.getDatabaseName()),\n+                        columns,\n+                        Optional.ofNullable(table.getParameters().get(TABLE_COMMENT)),\n+                        Optional.empty(),\n+                        true);\n+            }\n+            catch (RuntimeException e) {\n+                throw new PrestoException(HIVE_UNKNOWN_ERROR,\n+                        format(\"Error decoding view definition for %s.%s: %s. Please report this to ask_dali@linkedin.com\",\n+                                table.getDatabaseName(),\n+                                table.getTableName(),\n+                                e.getMessage()),\n+                        e);\n+            }\n+        }\n+\n+        // Calcite does not provide correct type strings for non-primitive types.\n+        // We add custom code here to make it work. Goal is for calcite/coral to handle this\n+        private String getTypeString(RelDataType type)\n+        {\n+            switch (type.getSqlTypeName()) {\n+                case ROW: {\n+                    Preconditions.checkState(type.isStruct());\n+                    StringBuilder sb = new StringBuilder(\"row(\");\n+                    List<RelDataTypeField> fieldList = type.getFieldList();\n+                    for (int i = 0; i < fieldList.size(); i++) {\n+                        if (i != 0) {\n+                            // There should not be space after comma. Presto deserializer doesn't like it\n+                            sb.append(\",\");\n+                        }\n+                        RelDataTypeField field = fieldList.get(i);\n+                        sb.append(field.getName().toLowerCase(Locale.ENGLISH)).append(\" \").append(getTypeString(field.getType()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMxMTM1Mw==", "bodyText": "Nice.", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r466311353", "createdAt": "2020-08-06T10:15:16Z", "author": {"login": "hashhar"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestCoralIntegration.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.Files;\n+import io.prestosql.Session;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.Database;\n+import io.prestosql.plugin.hive.metastore.MetastoreUtil;\n+import io.prestosql.plugin.hive.metastore.Storage;\n+import io.prestosql.plugin.hive.metastore.StorageFormat;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.plugin.hive.metastore.file.FileHiveMetastore;\n+import io.prestosql.plugin.hive.testing.TestingHivePlugin;\n+import io.prestosql.plugin.tpch.TpchPlugin;\n+import io.prestosql.spi.security.PrincipalType;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.TestingSession;\n+import io.prestosql.tpch.TpchTable;\n+import org.apache.hadoop.hive.metastore.TableType;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+import static com.google.common.io.MoreFiles.deleteRecursively;\n+import static com.google.common.io.RecursiveDeleteOption.ALLOW_INSECURE;\n+import static io.prestosql.plugin.hive.HiveQueryRunner.TPCH_SCHEMA;\n+import static io.prestosql.plugin.tpch.TpchMetadata.TINY_SCHEMA_NAME;\n+import static io.prestosql.testing.QueryAssertions.copyTpchTables;\n+\n+public class TestCoralIntegration\n+        extends AbstractTestQueryFramework\n+{\n+    private static final String HIVE_CATALOG = \"hive\";\n+    private File catalogDirectory = Files.createTempDir();\n+\n+    @AfterClass(alwaysRun = true)\n+    public void close()\n+    {\n+        try {\n+            deleteRecursively(catalogDirectory.toPath(), ALLOW_INSECURE);\n+        }\n+        catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        Session session = TestingSession.testSessionBuilder().setCatalog(HIVE_CATALOG).build();\n+        DistributedQueryRunner queryRunner = DistributedQueryRunner.builder(session).build();\n+\n+        // Create tpch catalog\n+        queryRunner.installPlugin(new TpchPlugin());\n+        queryRunner.createCatalog(\"tpch\", \"tpch\", ImmutableMap.of());\n+\n+        // Create hive catalog\n+        FileHiveMetastore metastore = FileHiveMetastore.createTestingFileHiveMetastore(catalogDirectory);\n+        queryRunner.installPlugin(new TestingHivePlugin(metastore));\n+        queryRunner.createCatalog(HIVE_CATALOG, \"hive\", ImmutableMap.of());\n+\n+        // Populate TPC-H tables to Hive\n+        metastore.createDatabase(new HiveIdentity(session.toConnectorSession()), new Database(TPCH_SCHEMA, Optional.empty(), \"ignored\", PrincipalType.USER, Optional.empty(), ImmutableMap.of()));\n+        Session tpchSession = Session.builder(queryRunner.getDefaultSession()).setSchema(\"tpch\").build();\n+        copyTpchTables(queryRunner, \"tpch\", TINY_SCHEMA_NAME, tpchSession, ImmutableList.of(TpchTable.ORDERS));\n+\n+        // And create the Hive-defined views we'll use for testing\n+        createHiveView(\n+                metastore,\n+                new HiveIdentity(session.toConnectorSession()),\n+                \"tpch\",\n+                \"counting_view\",\n+                \"select count(1) as count from tpch.orders\",\n+                \"select count(1) as `count` from `tpch`.`orders`\");\n+        createHiveView(\n+                metastore,\n+                new HiveIdentity(session.toConnectorSession()),\n+                \"tpch\",\n+                \"zero_index_view\",\n+                // Arrays in Hive are zero-indexed. This query will return 'hive' only if it's being parsed as a Hive query", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 100}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzOTg0ODky", "url": "https://github.com/trinodb/trino/pull/4661#pullrequestreview-493984892", "createdAt": "2020-09-23T02:24:28Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMjoyNDoyOFrOHWUCZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMDozNDoxN1rOHYZXgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1OTAxNA==", "bodyText": "I don't think we this these comment since all the dependencies have \"coral\" in the name", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r493159014", "createdAt": "2020-09-23T02:24:28Z", "author": {"login": "electrum"}, "path": "pom.xml", "diffHunk": "@@ -981,6 +981,43 @@\n                 <version>1.4.200</version>\n             </dependency>\n \n+            <!-- for coral -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMyODMzMA==", "bodyText": "Same", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495328330", "createdAt": "2020-09-25T23:56:25Z", "author": {"login": "electrum"}, "path": "presto-hive/pom.xml", "diffHunk": "@@ -173,6 +173,24 @@\n             <artifactId>guice</artifactId>\n         </dependency>\n \n+        <!-- for coral -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMyODQzOQ==", "bodyText": "Remove since compile is the default scope", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495328439", "createdAt": "2020-09-25T23:56:44Z", "author": {"login": "electrum"}, "path": "pom.xml", "diffHunk": "@@ -981,6 +981,43 @@\n                 <version>1.4.200</version>\n             </dependency>\n \n+            <!-- for coral -->\n+            <dependency>\n+                <groupId>com.linkedin.calcite</groupId>\n+                <artifactId>calcite-core</artifactId>\n+                <version>1.21.0.140</version>\n+                <classifier>shaded</classifier>\n+                <scope>compile</scope>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMyODcwNw==", "bodyText": "Remove since compile is the default scope", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495328707", "createdAt": "2020-09-25T23:57:25Z", "author": {"login": "electrum"}, "path": "presto-hive/pom.xml", "diffHunk": "@@ -173,6 +173,24 @@\n             <artifactId>guice</artifactId>\n         </dependency>\n \n+        <!-- for coral -->\n+        <dependency>\n+            <groupId>com.linkedin.calcite</groupId>\n+            <artifactId>calcite-core</artifactId>\n+            <classifier>shaded</classifier>\n+            <scope>compile</scope>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMyOTIwOQ==", "bodyText": "Add a property dep.coral.version so that the versions stay in sync between coral-hive and coral-presto", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495329209", "createdAt": "2020-09-25T23:58:49Z", "author": {"login": "electrum"}, "path": "pom.xml", "diffHunk": "@@ -981,6 +981,43 @@\n                 <version>1.4.200</version>\n             </dependency>\n \n+            <!-- for coral -->\n+            <dependency>\n+                <groupId>com.linkedin.calcite</groupId>\n+                <artifactId>calcite-core</artifactId>\n+                <version>1.21.0.140</version>\n+                <classifier>shaded</classifier>\n+                <scope>compile</scope>\n+                <exclusions>\n+                    <exclusion>\n+                        <groupId>*</groupId>\n+                        <artifactId>*</artifactId>\n+                    </exclusion>\n+                </exclusions>\n+            </dependency>\n+\n+            <dependency>\n+                <groupId>com.linkedin.coral</groupId>\n+                <artifactId>coral-hive</artifactId>\n+                <version>1.0.8</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMyOTQzNQ==", "bodyText": "Nit: wrap .decodeViewData() onto the next line since the line is very long", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495329435", "createdAt": "2020-09-25T23:59:29Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveMetadata.java", "diffHunk": "@@ -1843,35 +1843,24 @@ public void dropView(ConnectorSession session, SchemaTableName viewName)\n             return Optional.empty();\n         }\n         return metastore.getTable(new HiveIdentity(session), viewName.getSchemaName(), viewName.getTableName())\n-                .flatMap(view -> {\n-                    if (isPrestoView(view)) {\n-                        ConnectorViewDefinition definition = decodeViewData(view.getViewOriginalText()\n-                                .orElseThrow(() -> new PrestoException(HIVE_INVALID_METADATA, \"No view original text: \" + viewName)));\n-                        // use owner from table metadata if it exists\n-                        if (view.getOwner() != null && !definition.isRunAsInvoker()) {\n-                            definition = new ConnectorViewDefinition(\n-                                    definition.getOriginalSql(),\n-                                    definition.getCatalog(),\n-                                    definition.getSchema(),\n-                                    definition.getColumns(),\n-                                    definition.getComment(),\n-                                    Optional.of(view.getOwner()),\n-                                    false);\n-                        }\n-                        return Optional.of(definition);\n+                .filter(ViewReaderUtil::canDecodeView)\n+                .map(view -> {\n+                    ConnectorViewDefinition definition = createViewReader(metastore, new HiveIdentity(session), view, typeManager).decodeViewData(view.getViewOriginalText().get(), view, catalogName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMzMDExMg==", "bodyText": "We avoid abbreviations. How about metastoreClient", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495330112", "createdAt": "2020-09-26T00:01:07Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReaderUtil.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.base.Preconditions;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_UNKNOWN_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+public final class ViewReaderUtil\n+{\n+    private ViewReaderUtil()\n+    {}\n+\n+    public interface ViewReader\n+    {\n+        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+    }\n+\n+    public static ViewReader createViewReader(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.PrestoViewDecoder();\n+        }\n+        else {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.HiveViewDecoder(new CoralSemiTransactionalHiveMSCAdapter(metastore, identity), typemanager);\n+        }\n+    }\n+\n+    public static final String PRESTO_VIEW_FLAG = \"presto_view\";\n+    static final String VIEW_PREFIX = \"/* Presto View: \";\n+    static final String VIEW_SUFFIX = \" */\";\n+    private static final JsonCodec<ConnectorViewDefinition> VIEW_CODEC =\n+            new JsonCodecFactory(new ObjectMapperProvider()).jsonCodec(ConnectorViewDefinition.class);\n+    private static Logger log = Logger.get(io.prestosql.plugin.hive.ViewReaderUtil.class);\n+\n+    public static boolean isPrestoView(Table table)\n+    {\n+        return \"true\".equals(table.getParameters().get(PRESTO_VIEW_FLAG));\n+    }\n+\n+    public static boolean isHiveOrPrestoView(Table table)\n+    {\n+        return table.getTableType().equals(TableType.VIRTUAL_VIEW.name());\n+    }\n+\n+    public static boolean canDecodeView(Table table)\n+    {\n+        // we can decode Hive or Presto view\n+        return table.getTableType().equals(VIRTUAL_VIEW.name());\n+    }\n+\n+    public static String encodeViewData(ConnectorViewDefinition definition)\n+    {\n+        byte[] bytes = VIEW_CODEC.toJsonBytes(definition);\n+        String data = Base64.getEncoder().encodeToString(bytes);\n+        return VIEW_PREFIX + data + VIEW_SUFFIX;\n+    }\n+\n+    /**\n+     * Supports decoding of Presto views\n+     */\n+    public static class PrestoViewDecoder\n+            implements ViewReader\n+    {\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName)\n+        {\n+            checkCondition(viewData.startsWith(VIEW_PREFIX), HIVE_INVALID_VIEW_DATA, \"View data missing prefix: %s\", viewData);\n+            checkCondition(viewData.endsWith(VIEW_SUFFIX), HIVE_INVALID_VIEW_DATA, \"View data missing suffix: %s\", viewData);\n+            viewData = viewData.substring(VIEW_PREFIX.length());\n+            viewData = viewData.substring(0, viewData.length() - VIEW_SUFFIX.length());\n+            byte[] bytes = Base64.getDecoder().decode(viewData);\n+            return VIEW_CODEC.fromJson(bytes);\n+        }\n+    }\n+\n+    /**\n+     * Class to decode Hive view definitions\n+     */\n+    public static class HiveViewDecoder\n+            implements ViewReader\n+    {\n+        private final HiveMetastoreClient mscClient;\n+        private final TypeManager typeManager;\n+\n+        public HiveViewDecoder(HiveMetastoreClient mscClient, TypeManager typemanager)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMzMDEzNQ==", "bodyText": "Check for null", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495330135", "createdAt": "2020-09-26T00:01:12Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReaderUtil.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.base.Preconditions;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_UNKNOWN_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+public final class ViewReaderUtil\n+{\n+    private ViewReaderUtil()\n+    {}\n+\n+    public interface ViewReader\n+    {\n+        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+    }\n+\n+    public static ViewReader createViewReader(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.PrestoViewDecoder();\n+        }\n+        else {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.HiveViewDecoder(new CoralSemiTransactionalHiveMSCAdapter(metastore, identity), typemanager);\n+        }\n+    }\n+\n+    public static final String PRESTO_VIEW_FLAG = \"presto_view\";\n+    static final String VIEW_PREFIX = \"/* Presto View: \";\n+    static final String VIEW_SUFFIX = \" */\";\n+    private static final JsonCodec<ConnectorViewDefinition> VIEW_CODEC =\n+            new JsonCodecFactory(new ObjectMapperProvider()).jsonCodec(ConnectorViewDefinition.class);\n+    private static Logger log = Logger.get(io.prestosql.plugin.hive.ViewReaderUtil.class);\n+\n+    public static boolean isPrestoView(Table table)\n+    {\n+        return \"true\".equals(table.getParameters().get(PRESTO_VIEW_FLAG));\n+    }\n+\n+    public static boolean isHiveOrPrestoView(Table table)\n+    {\n+        return table.getTableType().equals(TableType.VIRTUAL_VIEW.name());\n+    }\n+\n+    public static boolean canDecodeView(Table table)\n+    {\n+        // we can decode Hive or Presto view\n+        return table.getTableType().equals(VIRTUAL_VIEW.name());\n+    }\n+\n+    public static String encodeViewData(ConnectorViewDefinition definition)\n+    {\n+        byte[] bytes = VIEW_CODEC.toJsonBytes(definition);\n+        String data = Base64.getEncoder().encodeToString(bytes);\n+        return VIEW_PREFIX + data + VIEW_SUFFIX;\n+    }\n+\n+    /**\n+     * Supports decoding of Presto views\n+     */\n+    public static class PrestoViewDecoder\n+            implements ViewReader\n+    {\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName)\n+        {\n+            checkCondition(viewData.startsWith(VIEW_PREFIX), HIVE_INVALID_VIEW_DATA, \"View data missing prefix: %s\", viewData);\n+            checkCondition(viewData.endsWith(VIEW_SUFFIX), HIVE_INVALID_VIEW_DATA, \"View data missing suffix: %s\", viewData);\n+            viewData = viewData.substring(VIEW_PREFIX.length());\n+            viewData = viewData.substring(0, viewData.length() - VIEW_SUFFIX.length());\n+            byte[] bytes = Base64.getDecoder().decode(viewData);\n+            return VIEW_CODEC.fromJson(bytes);\n+        }\n+    }\n+\n+    /**\n+     * Class to decode Hive view definitions\n+     */\n+    public static class HiveViewDecoder\n+            implements ViewReader\n+    {\n+        private final HiveMetastoreClient mscClient;\n+        private final TypeManager typeManager;\n+\n+        public HiveViewDecoder(HiveMetastoreClient mscClient, TypeManager typemanager)\n+        {\n+            this.mscClient = mscClient;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMzMDY5MA==", "bodyText": "You can simply reference PrestoViewDecoder and HiveViewDecoder since they are visible within this class", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495330690", "createdAt": "2020-09-26T00:02:35Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReaderUtil.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.base.Preconditions;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_UNKNOWN_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+public final class ViewReaderUtil\n+{\n+    private ViewReaderUtil()\n+    {}\n+\n+    public interface ViewReader\n+    {\n+        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+    }\n+\n+    public static ViewReader createViewReader(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.PrestoViewDecoder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMzMDg3Mw==", "bodyText": "Nit: the \"else\" is redundant since the \"if\" returns. Write this as\nif (xxx) { \n    return ...;\n}\nreturn ...;", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495330873", "createdAt": "2020-09-26T00:03:05Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReaderUtil.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.base.Preconditions;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_UNKNOWN_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+public final class ViewReaderUtil\n+{\n+    private ViewReaderUtil()\n+    {}\n+\n+    public interface ViewReader\n+    {\n+        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+    }\n+\n+    public static ViewReader createViewReader(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.PrestoViewDecoder();\n+        }\n+        else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMzMTUxNA==", "bodyText": "We avoid acronyms or abbreviations. How about CoralHiveMetastoreClient", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495331514", "createdAt": "2020-09-26T00:04:46Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/CoralSemiTransactionalHiveMSCAdapter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore;\n+\n+import com.google.common.collect.ImmutableMultimap;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import org.apache.hadoop.hive.metastore.api.Database;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Class to adapt Presto's {@link SemiTransactionalHiveMetastore} to Coral's\n+ * {@link HiveMetastoreClient}. This allows reuse of the hive metastore instantiated by\n+ * Presto, based on configuration, inside Coral.\n+ */\n+public class CoralSemiTransactionalHiveMSCAdapter", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMzMTY4OA==", "bodyText": "Check for null", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495331688", "createdAt": "2020-09-26T00:05:05Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/CoralSemiTransactionalHiveMSCAdapter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore;\n+\n+import com.google.common.collect.ImmutableMultimap;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import org.apache.hadoop.hive.metastore.api.Database;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Class to adapt Presto's {@link SemiTransactionalHiveMetastore} to Coral's\n+ * {@link HiveMetastoreClient}. This allows reuse of the hive metastore instantiated by\n+ * Presto, based on configuration, inside Coral.\n+ */\n+public class CoralSemiTransactionalHiveMSCAdapter\n+        implements HiveMetastoreClient\n+{\n+    private final SemiTransactionalHiveMetastore delegate;\n+    private final HiveIdentity identity;\n+\n+    public CoralSemiTransactionalHiveMSCAdapter(SemiTransactionalHiveMetastore msc, HiveIdentity identity)\n+    {\n+        this.delegate = msc;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMzMjM0Nw==", "bodyText": "We can write this as\nreturn delegate.getTable(identity, dbName, tableName)\n        .map(value -> ThriftMetastoreUtil.toMetastoreApiTable(value, new PrincipalPrivileges(ImmutableMultimap.of(), ImmutableMultimap.of())))\n        .orElse(null);", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495332347", "createdAt": "2020-09-26T00:06:45Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/CoralSemiTransactionalHiveMSCAdapter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore;\n+\n+import com.google.common.collect.ImmutableMultimap;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import org.apache.hadoop.hive.metastore.api.Database;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Class to adapt Presto's {@link SemiTransactionalHiveMetastore} to Coral's\n+ * {@link HiveMetastoreClient}. This allows reuse of the hive metastore instantiated by\n+ * Presto, based on configuration, inside Coral.\n+ */\n+public class CoralSemiTransactionalHiveMSCAdapter\n+        implements HiveMetastoreClient\n+{\n+    private final SemiTransactionalHiveMetastore delegate;\n+    private final HiveIdentity identity;\n+\n+    public CoralSemiTransactionalHiveMSCAdapter(SemiTransactionalHiveMetastore msc, HiveIdentity identity)\n+    {\n+        this.delegate = msc;\n+        this.identity = identity;\n+    }\n+\n+    @Override\n+    public List<String> getAllDatabases()\n+    {\n+        return delegate.getAllDatabases();\n+    }\n+\n+    // returning null for missing entry is as per Coral's requirements\n+    @Override\n+    public Database getDatabase(String dbName)\n+    {\n+        return delegate.getDatabase(dbName).map(ThriftMetastoreUtil::toMetastoreApiDatabase).orElse(null);\n+    }\n+\n+    @Override\n+    public List<String> getAllTables(String dbName)\n+    {\n+        return delegate.getAllTables(dbName);\n+    }\n+\n+    @Override\n+    public org.apache.hadoop.hive.metastore.api.Table getTable(String dbName, String tableName)\n+    {\n+        Optional<io.prestosql.plugin.hive.metastore.Table> table = delegate.getTable(identity, dbName, tableName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMzMjY3Ng==", "bodyText": "Do we need a TODO here? If Coral needs the permissions, then we should implement it. If not, then it doesn't matter.", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495332676", "createdAt": "2020-09-26T00:07:38Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/CoralSemiTransactionalHiveMSCAdapter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore;\n+\n+import com.google.common.collect.ImmutableMultimap;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import org.apache.hadoop.hive.metastore.api.Database;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Class to adapt Presto's {@link SemiTransactionalHiveMetastore} to Coral's\n+ * {@link HiveMetastoreClient}. This allows reuse of the hive metastore instantiated by\n+ * Presto, based on configuration, inside Coral.\n+ */\n+public class CoralSemiTransactionalHiveMSCAdapter\n+        implements HiveMetastoreClient\n+{\n+    private final SemiTransactionalHiveMetastore delegate;\n+    private final HiveIdentity identity;\n+\n+    public CoralSemiTransactionalHiveMSCAdapter(SemiTransactionalHiveMetastore msc, HiveIdentity identity)\n+    {\n+        this.delegate = msc;\n+        this.identity = identity;\n+    }\n+\n+    @Override\n+    public List<String> getAllDatabases()\n+    {\n+        return delegate.getAllDatabases();\n+    }\n+\n+    // returning null for missing entry is as per Coral's requirements\n+    @Override\n+    public Database getDatabase(String dbName)\n+    {\n+        return delegate.getDatabase(dbName).map(ThriftMetastoreUtil::toMetastoreApiDatabase).orElse(null);\n+    }\n+\n+    @Override\n+    public List<String> getAllTables(String dbName)\n+    {\n+        return delegate.getAllTables(dbName);\n+    }\n+\n+    @Override\n+    public org.apache.hadoop.hive.metastore.api.Table getTable(String dbName, String tableName)\n+    {\n+        Optional<io.prestosql.plugin.hive.metastore.Table> table = delegate.getTable(identity, dbName, tableName);\n+        // TODO: Get the right privileges here. This could be problematic if Coral needs permissions of the table.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMzMjk0OQ==", "bodyText": "You can inline this variable", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495332949", "createdAt": "2020-09-26T00:08:25Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/file/FileHiveMetastore.java", "diffHunk": "@@ -443,7 +442,15 @@ public synchronized void updatePartitionStatistics(HiveIdentity identity, Table\n     @Override\n     public synchronized List<String> getAllViews(String databaseName)\n     {\n-        return getTablesWithParameter(databaseName, PRESTO_VIEW_FLAG, \"true\");\n+        List<String> tables = getAllTables(databaseName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMzMzA3Mw==", "bodyText": "Nit: No need to wrap here", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495333073", "createdAt": "2020-09-26T00:08:43Z", "author": {"login": "electrum"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveViews.java", "diffHunk": "@@ -174,6 +173,20 @@ public void testHiveViewWithParametrizedTypes()\n         assertThat(query(\"SELECT data_type FROM information_schema.columns WHERE table_name = 'hive_view_parametrized'\")).containsOnly(\n                 row(\"decimal(20,4)\"),\n                 row(\"bigint\"),\n-                row(\"varchar(20)\"));\n+                row(\"varchar\"));\n+    }\n+\n+    @Test(groups = HIVE_VIEWS)\n+    public void testSimpleCoral()\n+    {\n+        onHive().executeQuery(\"DROP VIEW IF EXISTS hive_zero_index_view\");\n+        onHive().executeQuery(\"DROP TABLE IF EXISTS hive_table_dummy\");\n+\n+        onHive().executeQuery(\"CREATE TABLE hive_table_dummy(a int)\");\n+        onHive().executeQuery(\"CREATE VIEW hive_zero_index_view AS SELECT array('presto','hive')[1] AS sql_dialect from hive_table_dummy\");\n+        onHive().executeQuery(\"INSERT INTO TABLE hive_table_dummy VALUES (1)\");\n+\n+        assertThat(query(\"SELECT * FROM hive_zero_index_view\")).containsOnly(\n+                row(\"hive\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMzMzM5NA==", "bodyText": "Nit: uppercase FROM keyword", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495333394", "createdAt": "2020-09-26T00:09:38Z", "author": {"login": "electrum"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveViews.java", "diffHunk": "@@ -174,6 +173,20 @@ public void testHiveViewWithParametrizedTypes()\n         assertThat(query(\"SELECT data_type FROM information_schema.columns WHERE table_name = 'hive_view_parametrized'\")).containsOnly(\n                 row(\"decimal(20,4)\"),\n                 row(\"bigint\"),\n-                row(\"varchar(20)\"));\n+                row(\"varchar\"));\n+    }\n+\n+    @Test(groups = HIVE_VIEWS)\n+    public void testSimpleCoral()\n+    {\n+        onHive().executeQuery(\"DROP VIEW IF EXISTS hive_zero_index_view\");\n+        onHive().executeQuery(\"DROP TABLE IF EXISTS hive_table_dummy\");\n+\n+        onHive().executeQuery(\"CREATE TABLE hive_table_dummy(a int)\");\n+        onHive().executeQuery(\"CREATE VIEW hive_zero_index_view AS SELECT array('presto','hive')[1] AS sql_dialect from hive_table_dummy\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMzNDY1OA==", "bodyText": "Do we expect this class to get substantially bigger as the transactional support is expanded? If so, it would be better to make it a top level class.", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495334658", "createdAt": "2020-09-26T00:13:12Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReaderUtil.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.base.Preconditions;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_UNKNOWN_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+public final class ViewReaderUtil\n+{\n+    private ViewReaderUtil()\n+    {}\n+\n+    public interface ViewReader\n+    {\n+        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+    }\n+\n+    public static ViewReader createViewReader(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.PrestoViewDecoder();\n+        }\n+        else {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.HiveViewDecoder(new CoralSemiTransactionalHiveMSCAdapter(metastore, identity), typemanager);\n+        }\n+    }\n+\n+    public static final String PRESTO_VIEW_FLAG = \"presto_view\";\n+    static final String VIEW_PREFIX = \"/* Presto View: \";\n+    static final String VIEW_SUFFIX = \" */\";\n+    private static final JsonCodec<ConnectorViewDefinition> VIEW_CODEC =\n+            new JsonCodecFactory(new ObjectMapperProvider()).jsonCodec(ConnectorViewDefinition.class);\n+    private static Logger log = Logger.get(io.prestosql.plugin.hive.ViewReaderUtil.class);\n+\n+    public static boolean isPrestoView(Table table)\n+    {\n+        return \"true\".equals(table.getParameters().get(PRESTO_VIEW_FLAG));\n+    }\n+\n+    public static boolean isHiveOrPrestoView(Table table)\n+    {\n+        return table.getTableType().equals(TableType.VIRTUAL_VIEW.name());\n+    }\n+\n+    public static boolean canDecodeView(Table table)\n+    {\n+        // we can decode Hive or Presto view\n+        return table.getTableType().equals(VIRTUAL_VIEW.name());\n+    }\n+\n+    public static String encodeViewData(ConnectorViewDefinition definition)\n+    {\n+        byte[] bytes = VIEW_CODEC.toJsonBytes(definition);\n+        String data = Base64.getEncoder().encodeToString(bytes);\n+        return VIEW_PREFIX + data + VIEW_SUFFIX;\n+    }\n+\n+    /**\n+     * Supports decoding of Presto views\n+     */\n+    public static class PrestoViewDecoder\n+            implements ViewReader\n+    {\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName)\n+        {\n+            checkCondition(viewData.startsWith(VIEW_PREFIX), HIVE_INVALID_VIEW_DATA, \"View data missing prefix: %s\", viewData);\n+            checkCondition(viewData.endsWith(VIEW_SUFFIX), HIVE_INVALID_VIEW_DATA, \"View data missing suffix: %s\", viewData);\n+            viewData = viewData.substring(VIEW_PREFIX.length());\n+            viewData = viewData.substring(0, viewData.length() - VIEW_SUFFIX.length());\n+            byte[] bytes = Base64.getDecoder().decode(viewData);\n+            return VIEW_CODEC.fromJson(bytes);\n+        }\n+    }\n+\n+    /**\n+     * Class to decode Hive view definitions\n+     */\n+    public static class HiveViewDecoder", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMzNTA3NA==", "bodyText": "Let's call these PrestoViewReader and HiveViewReader so that the names match the interface (that's the typical convention).", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495335074", "createdAt": "2020-09-26T00:14:22Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReaderUtil.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.base.Preconditions;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_UNKNOWN_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+public final class ViewReaderUtil\n+{\n+    private ViewReaderUtil()\n+    {}\n+\n+    public interface ViewReader\n+    {\n+        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+    }\n+\n+    public static ViewReader createViewReader(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.PrestoViewDecoder();\n+        }\n+        else {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.HiveViewDecoder(new CoralSemiTransactionalHiveMSCAdapter(metastore, identity), typemanager);\n+        }\n+    }\n+\n+    public static final String PRESTO_VIEW_FLAG = \"presto_view\";\n+    static final String VIEW_PREFIX = \"/* Presto View: \";\n+    static final String VIEW_SUFFIX = \" */\";\n+    private static final JsonCodec<ConnectorViewDefinition> VIEW_CODEC =\n+            new JsonCodecFactory(new ObjectMapperProvider()).jsonCodec(ConnectorViewDefinition.class);\n+    private static Logger log = Logger.get(io.prestosql.plugin.hive.ViewReaderUtil.class);\n+\n+    public static boolean isPrestoView(Table table)\n+    {\n+        return \"true\".equals(table.getParameters().get(PRESTO_VIEW_FLAG));\n+    }\n+\n+    public static boolean isHiveOrPrestoView(Table table)\n+    {\n+        return table.getTableType().equals(TableType.VIRTUAL_VIEW.name());\n+    }\n+\n+    public static boolean canDecodeView(Table table)\n+    {\n+        // we can decode Hive or Presto view\n+        return table.getTableType().equals(VIRTUAL_VIEW.name());\n+    }\n+\n+    public static String encodeViewData(ConnectorViewDefinition definition)\n+    {\n+        byte[] bytes = VIEW_CODEC.toJsonBytes(definition);\n+        String data = Base64.getEncoder().encodeToString(bytes);\n+        return VIEW_PREFIX + data + VIEW_SUFFIX;\n+    }\n+\n+    /**\n+     * Supports decoding of Presto views\n+     */\n+    public static class PrestoViewDecoder", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMzNTc3Mg==", "bodyText": "Is this useful to leave in the code? If so, we should expand it to include the view name. Otherwise, if it's just for development, please remove it.", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495335772", "createdAt": "2020-09-26T00:15:59Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReaderUtil.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.base.Preconditions;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_UNKNOWN_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+public final class ViewReaderUtil\n+{\n+    private ViewReaderUtil()\n+    {}\n+\n+    public interface ViewReader\n+    {\n+        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+    }\n+\n+    public static ViewReader createViewReader(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.PrestoViewDecoder();\n+        }\n+        else {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.HiveViewDecoder(new CoralSemiTransactionalHiveMSCAdapter(metastore, identity), typemanager);\n+        }\n+    }\n+\n+    public static final String PRESTO_VIEW_FLAG = \"presto_view\";\n+    static final String VIEW_PREFIX = \"/* Presto View: \";\n+    static final String VIEW_SUFFIX = \" */\";\n+    private static final JsonCodec<ConnectorViewDefinition> VIEW_CODEC =\n+            new JsonCodecFactory(new ObjectMapperProvider()).jsonCodec(ConnectorViewDefinition.class);\n+    private static Logger log = Logger.get(io.prestosql.plugin.hive.ViewReaderUtil.class);\n+\n+    public static boolean isPrestoView(Table table)\n+    {\n+        return \"true\".equals(table.getParameters().get(PRESTO_VIEW_FLAG));\n+    }\n+\n+    public static boolean isHiveOrPrestoView(Table table)\n+    {\n+        return table.getTableType().equals(TableType.VIRTUAL_VIEW.name());\n+    }\n+\n+    public static boolean canDecodeView(Table table)\n+    {\n+        // we can decode Hive or Presto view\n+        return table.getTableType().equals(VIRTUAL_VIEW.name());\n+    }\n+\n+    public static String encodeViewData(ConnectorViewDefinition definition)\n+    {\n+        byte[] bytes = VIEW_CODEC.toJsonBytes(definition);\n+        String data = Base64.getEncoder().encodeToString(bytes);\n+        return VIEW_PREFIX + data + VIEW_SUFFIX;\n+    }\n+\n+    /**\n+     * Supports decoding of Presto views\n+     */\n+    public static class PrestoViewDecoder\n+            implements ViewReader\n+    {\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName)\n+        {\n+            checkCondition(viewData.startsWith(VIEW_PREFIX), HIVE_INVALID_VIEW_DATA, \"View data missing prefix: %s\", viewData);\n+            checkCondition(viewData.endsWith(VIEW_SUFFIX), HIVE_INVALID_VIEW_DATA, \"View data missing suffix: %s\", viewData);\n+            viewData = viewData.substring(VIEW_PREFIX.length());\n+            viewData = viewData.substring(0, viewData.length() - VIEW_SUFFIX.length());\n+            byte[] bytes = Base64.getDecoder().decode(viewData);\n+            return VIEW_CODEC.fromJson(bytes);\n+        }\n+    }\n+\n+    /**\n+     * Class to decode Hive view definitions\n+     */\n+    public static class HiveViewDecoder\n+            implements ViewReader\n+    {\n+        private final HiveMetastoreClient mscClient;\n+        private final TypeManager typeManager;\n+\n+        public HiveViewDecoder(HiveMetastoreClient mscClient, TypeManager typemanager)\n+        {\n+            this.mscClient = mscClient;\n+            this.typeManager = requireNonNull(typemanager, \"metadata is null\");\n+        }\n+\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewSql, Table table, CatalogName catalogName)\n+        {\n+            try {\n+                HiveToRelConverter hiveToRelConverter = HiveToRelConverter.create(mscClient);\n+                RelNode rel = hiveToRelConverter.convertView(table.getDatabaseName(), table.getTableName());\n+                RelToPrestoConverter rel2Presto = new RelToPrestoConverter();\n+                String prestoSql = rel2Presto.convert(rel);\n+                RelDataType rowType = rel.getRowType();\n+                List<ConnectorViewDefinition.ViewColumn> columns = new ArrayList<>(rowType.getFieldCount());\n+                for (RelDataTypeField field : rowType.getFieldList()) {\n+                    log.debug(\"Adding column %s, %s, %s, %s\", field.getName(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMzNTg3OA==", "bodyText": "Nit: wrap all the arguments if wrapping any", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495335878", "createdAt": "2020-09-26T00:16:16Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReaderUtil.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.base.Preconditions;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_UNKNOWN_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+public final class ViewReaderUtil\n+{\n+    private ViewReaderUtil()\n+    {}\n+\n+    public interface ViewReader\n+    {\n+        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+    }\n+\n+    public static ViewReader createViewReader(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.PrestoViewDecoder();\n+        }\n+        else {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.HiveViewDecoder(new CoralSemiTransactionalHiveMSCAdapter(metastore, identity), typemanager);\n+        }\n+    }\n+\n+    public static final String PRESTO_VIEW_FLAG = \"presto_view\";\n+    static final String VIEW_PREFIX = \"/* Presto View: \";\n+    static final String VIEW_SUFFIX = \" */\";\n+    private static final JsonCodec<ConnectorViewDefinition> VIEW_CODEC =\n+            new JsonCodecFactory(new ObjectMapperProvider()).jsonCodec(ConnectorViewDefinition.class);\n+    private static Logger log = Logger.get(io.prestosql.plugin.hive.ViewReaderUtil.class);\n+\n+    public static boolean isPrestoView(Table table)\n+    {\n+        return \"true\".equals(table.getParameters().get(PRESTO_VIEW_FLAG));\n+    }\n+\n+    public static boolean isHiveOrPrestoView(Table table)\n+    {\n+        return table.getTableType().equals(TableType.VIRTUAL_VIEW.name());\n+    }\n+\n+    public static boolean canDecodeView(Table table)\n+    {\n+        // we can decode Hive or Presto view\n+        return table.getTableType().equals(VIRTUAL_VIEW.name());\n+    }\n+\n+    public static String encodeViewData(ConnectorViewDefinition definition)\n+    {\n+        byte[] bytes = VIEW_CODEC.toJsonBytes(definition);\n+        String data = Base64.getEncoder().encodeToString(bytes);\n+        return VIEW_PREFIX + data + VIEW_SUFFIX;\n+    }\n+\n+    /**\n+     * Supports decoding of Presto views\n+     */\n+    public static class PrestoViewDecoder\n+            implements ViewReader\n+    {\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName)\n+        {\n+            checkCondition(viewData.startsWith(VIEW_PREFIX), HIVE_INVALID_VIEW_DATA, \"View data missing prefix: %s\", viewData);\n+            checkCondition(viewData.endsWith(VIEW_SUFFIX), HIVE_INVALID_VIEW_DATA, \"View data missing suffix: %s\", viewData);\n+            viewData = viewData.substring(VIEW_PREFIX.length());\n+            viewData = viewData.substring(0, viewData.length() - VIEW_SUFFIX.length());\n+            byte[] bytes = Base64.getDecoder().decode(viewData);\n+            return VIEW_CODEC.fromJson(bytes);\n+        }\n+    }\n+\n+    /**\n+     * Class to decode Hive view definitions\n+     */\n+    public static class HiveViewDecoder\n+            implements ViewReader\n+    {\n+        private final HiveMetastoreClient mscClient;\n+        private final TypeManager typeManager;\n+\n+        public HiveViewDecoder(HiveMetastoreClient mscClient, TypeManager typemanager)\n+        {\n+            this.mscClient = mscClient;\n+            this.typeManager = requireNonNull(typemanager, \"metadata is null\");\n+        }\n+\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewSql, Table table, CatalogName catalogName)\n+        {\n+            try {\n+                HiveToRelConverter hiveToRelConverter = HiveToRelConverter.create(mscClient);\n+                RelNode rel = hiveToRelConverter.convertView(table.getDatabaseName(), table.getTableName());\n+                RelToPrestoConverter rel2Presto = new RelToPrestoConverter();\n+                String prestoSql = rel2Presto.convert(rel);\n+                RelDataType rowType = rel.getRowType();\n+                List<ConnectorViewDefinition.ViewColumn> columns = new ArrayList<>(rowType.getFieldCount());\n+                for (RelDataTypeField field : rowType.getFieldList()) {\n+                    log.debug(\"Adding column %s, %s, %s, %s\", field.getName(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMzNzQxMw==", "bodyText": "I think you want to remove this second part :)\nIs it useful to duplicate the error message here? It's available in the stack trace. Let's also add quotes around the table name, and use the right error code.\nthrow new PrestoException(HIVE_VIEW_TRANSLATION_ERROR, format(\"Failed to translate Hive view '%s': %s', table.getSchemaTableName(), e.getMessage()), e);", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495337413", "createdAt": "2020-09-26T00:20:15Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReaderUtil.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.base.Preconditions;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_UNKNOWN_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+public final class ViewReaderUtil\n+{\n+    private ViewReaderUtil()\n+    {}\n+\n+    public interface ViewReader\n+    {\n+        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+    }\n+\n+    public static ViewReader createViewReader(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.PrestoViewDecoder();\n+        }\n+        else {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.HiveViewDecoder(new CoralSemiTransactionalHiveMSCAdapter(metastore, identity), typemanager);\n+        }\n+    }\n+\n+    public static final String PRESTO_VIEW_FLAG = \"presto_view\";\n+    static final String VIEW_PREFIX = \"/* Presto View: \";\n+    static final String VIEW_SUFFIX = \" */\";\n+    private static final JsonCodec<ConnectorViewDefinition> VIEW_CODEC =\n+            new JsonCodecFactory(new ObjectMapperProvider()).jsonCodec(ConnectorViewDefinition.class);\n+    private static Logger log = Logger.get(io.prestosql.plugin.hive.ViewReaderUtil.class);\n+\n+    public static boolean isPrestoView(Table table)\n+    {\n+        return \"true\".equals(table.getParameters().get(PRESTO_VIEW_FLAG));\n+    }\n+\n+    public static boolean isHiveOrPrestoView(Table table)\n+    {\n+        return table.getTableType().equals(TableType.VIRTUAL_VIEW.name());\n+    }\n+\n+    public static boolean canDecodeView(Table table)\n+    {\n+        // we can decode Hive or Presto view\n+        return table.getTableType().equals(VIRTUAL_VIEW.name());\n+    }\n+\n+    public static String encodeViewData(ConnectorViewDefinition definition)\n+    {\n+        byte[] bytes = VIEW_CODEC.toJsonBytes(definition);\n+        String data = Base64.getEncoder().encodeToString(bytes);\n+        return VIEW_PREFIX + data + VIEW_SUFFIX;\n+    }\n+\n+    /**\n+     * Supports decoding of Presto views\n+     */\n+    public static class PrestoViewDecoder\n+            implements ViewReader\n+    {\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName)\n+        {\n+            checkCondition(viewData.startsWith(VIEW_PREFIX), HIVE_INVALID_VIEW_DATA, \"View data missing prefix: %s\", viewData);\n+            checkCondition(viewData.endsWith(VIEW_SUFFIX), HIVE_INVALID_VIEW_DATA, \"View data missing suffix: %s\", viewData);\n+            viewData = viewData.substring(VIEW_PREFIX.length());\n+            viewData = viewData.substring(0, viewData.length() - VIEW_SUFFIX.length());\n+            byte[] bytes = Base64.getDecoder().decode(viewData);\n+            return VIEW_CODEC.fromJson(bytes);\n+        }\n+    }\n+\n+    /**\n+     * Class to decode Hive view definitions\n+     */\n+    public static class HiveViewDecoder\n+            implements ViewReader\n+    {\n+        private final HiveMetastoreClient mscClient;\n+        private final TypeManager typeManager;\n+\n+        public HiveViewDecoder(HiveMetastoreClient mscClient, TypeManager typemanager)\n+        {\n+            this.mscClient = mscClient;\n+            this.typeManager = requireNonNull(typemanager, \"metadata is null\");\n+        }\n+\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewSql, Table table, CatalogName catalogName)\n+        {\n+            try {\n+                HiveToRelConverter hiveToRelConverter = HiveToRelConverter.create(mscClient);\n+                RelNode rel = hiveToRelConverter.convertView(table.getDatabaseName(), table.getTableName());\n+                RelToPrestoConverter rel2Presto = new RelToPrestoConverter();\n+                String prestoSql = rel2Presto.convert(rel);\n+                RelDataType rowType = rel.getRowType();\n+                List<ConnectorViewDefinition.ViewColumn> columns = new ArrayList<>(rowType.getFieldCount());\n+                for (RelDataTypeField field : rowType.getFieldList()) {\n+                    log.debug(\"Adding column %s, %s, %s, %s\", field.getName(),\n+                            field.getType().getFullTypeString(),\n+                            field.getType().getSqlTypeName(),\n+                            field);\n+\n+                    Type type = typeManager.fromSqlType(getTypeString(field.getType()));\n+                    ConnectorViewDefinition.ViewColumn column = new ConnectorViewDefinition.ViewColumn(field.getName(), type.getTypeId());\n+                    columns.add(column);\n+                }\n+                return new ConnectorViewDefinition(prestoSql,\n+                        Optional.of(catalogName.toString()),\n+                        Optional.of(table.getDatabaseName()),\n+                        columns,\n+                        Optional.ofNullable(table.getParameters().get(TABLE_COMMENT)),\n+                        Optional.empty(),\n+                        true);\n+            }\n+            catch (RuntimeException e) {\n+                throw new PrestoException(HIVE_UNKNOWN_ERROR,\n+                        format(\"Error decoding view definition for %s.%s: %s. Please report this to ask_dali@linkedin.com\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMzOTIzOQ==", "bodyText": "Use verify() as IllegalStateException means something different. This is a general problem of the RelDataType invariants being violated.\nverify(type.isStrict(), \"expected ROW type to be a struct: %s\", type);", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495339239", "createdAt": "2020-09-26T00:24:27Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReaderUtil.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.base.Preconditions;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_UNKNOWN_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+public final class ViewReaderUtil\n+{\n+    private ViewReaderUtil()\n+    {}\n+\n+    public interface ViewReader\n+    {\n+        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+    }\n+\n+    public static ViewReader createViewReader(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.PrestoViewDecoder();\n+        }\n+        else {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.HiveViewDecoder(new CoralSemiTransactionalHiveMSCAdapter(metastore, identity), typemanager);\n+        }\n+    }\n+\n+    public static final String PRESTO_VIEW_FLAG = \"presto_view\";\n+    static final String VIEW_PREFIX = \"/* Presto View: \";\n+    static final String VIEW_SUFFIX = \" */\";\n+    private static final JsonCodec<ConnectorViewDefinition> VIEW_CODEC =\n+            new JsonCodecFactory(new ObjectMapperProvider()).jsonCodec(ConnectorViewDefinition.class);\n+    private static Logger log = Logger.get(io.prestosql.plugin.hive.ViewReaderUtil.class);\n+\n+    public static boolean isPrestoView(Table table)\n+    {\n+        return \"true\".equals(table.getParameters().get(PRESTO_VIEW_FLAG));\n+    }\n+\n+    public static boolean isHiveOrPrestoView(Table table)\n+    {\n+        return table.getTableType().equals(TableType.VIRTUAL_VIEW.name());\n+    }\n+\n+    public static boolean canDecodeView(Table table)\n+    {\n+        // we can decode Hive or Presto view\n+        return table.getTableType().equals(VIRTUAL_VIEW.name());\n+    }\n+\n+    public static String encodeViewData(ConnectorViewDefinition definition)\n+    {\n+        byte[] bytes = VIEW_CODEC.toJsonBytes(definition);\n+        String data = Base64.getEncoder().encodeToString(bytes);\n+        return VIEW_PREFIX + data + VIEW_SUFFIX;\n+    }\n+\n+    /**\n+     * Supports decoding of Presto views\n+     */\n+    public static class PrestoViewDecoder\n+            implements ViewReader\n+    {\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName)\n+        {\n+            checkCondition(viewData.startsWith(VIEW_PREFIX), HIVE_INVALID_VIEW_DATA, \"View data missing prefix: %s\", viewData);\n+            checkCondition(viewData.endsWith(VIEW_SUFFIX), HIVE_INVALID_VIEW_DATA, \"View data missing suffix: %s\", viewData);\n+            viewData = viewData.substring(VIEW_PREFIX.length());\n+            viewData = viewData.substring(0, viewData.length() - VIEW_SUFFIX.length());\n+            byte[] bytes = Base64.getDecoder().decode(viewData);\n+            return VIEW_CODEC.fromJson(bytes);\n+        }\n+    }\n+\n+    /**\n+     * Class to decode Hive view definitions\n+     */\n+    public static class HiveViewDecoder\n+            implements ViewReader\n+    {\n+        private final HiveMetastoreClient mscClient;\n+        private final TypeManager typeManager;\n+\n+        public HiveViewDecoder(HiveMetastoreClient mscClient, TypeManager typemanager)\n+        {\n+            this.mscClient = mscClient;\n+            this.typeManager = requireNonNull(typemanager, \"metadata is null\");\n+        }\n+\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewSql, Table table, CatalogName catalogName)\n+        {\n+            try {\n+                HiveToRelConverter hiveToRelConverter = HiveToRelConverter.create(mscClient);\n+                RelNode rel = hiveToRelConverter.convertView(table.getDatabaseName(), table.getTableName());\n+                RelToPrestoConverter rel2Presto = new RelToPrestoConverter();\n+                String prestoSql = rel2Presto.convert(rel);\n+                RelDataType rowType = rel.getRowType();\n+                List<ConnectorViewDefinition.ViewColumn> columns = new ArrayList<>(rowType.getFieldCount());\n+                for (RelDataTypeField field : rowType.getFieldList()) {\n+                    log.debug(\"Adding column %s, %s, %s, %s\", field.getName(),\n+                            field.getType().getFullTypeString(),\n+                            field.getType().getSqlTypeName(),\n+                            field);\n+\n+                    Type type = typeManager.fromSqlType(getTypeString(field.getType()));\n+                    ConnectorViewDefinition.ViewColumn column = new ConnectorViewDefinition.ViewColumn(field.getName(), type.getTypeId());\n+                    columns.add(column);\n+                }\n+                return new ConnectorViewDefinition(prestoSql,\n+                        Optional.of(catalogName.toString()),\n+                        Optional.of(table.getDatabaseName()),\n+                        columns,\n+                        Optional.ofNullable(table.getParameters().get(TABLE_COMMENT)),\n+                        Optional.empty(),\n+                        true);\n+            }\n+            catch (RuntimeException e) {\n+                throw new PrestoException(HIVE_UNKNOWN_ERROR,\n+                        format(\"Error decoding view definition for %s.%s: %s. Please report this to ask_dali@linkedin.com\",\n+                                table.getDatabaseName(),\n+                                table.getTableName(),\n+                                e.getMessage()),\n+                        e);\n+            }\n+        }\n+\n+        // Calcite does not provide correct type strings for non-primitive types.\n+        // We add custom code here to make it work. Goal is for calcite/coral to handle this\n+        private String getTypeString(RelDataType type)\n+        {\n+            switch (type.getSqlTypeName()) {\n+                case ROW: {\n+                    Preconditions.checkState(type.isStruct());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM0MDA3MQ==", "bodyText": "This can be done with a stream\nreturn type.getFieldList().stream()\n        .map(field -> field.getName().toLowerCase(ENGLISH) + \" \" + getTypeString(field.getType()))\n        .collect(joining(\",\", \"row(\", \")\"));", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495340071", "createdAt": "2020-09-26T00:26:32Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReaderUtil.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.base.Preconditions;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_UNKNOWN_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+public final class ViewReaderUtil\n+{\n+    private ViewReaderUtil()\n+    {}\n+\n+    public interface ViewReader\n+    {\n+        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+    }\n+\n+    public static ViewReader createViewReader(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.PrestoViewDecoder();\n+        }\n+        else {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.HiveViewDecoder(new CoralSemiTransactionalHiveMSCAdapter(metastore, identity), typemanager);\n+        }\n+    }\n+\n+    public static final String PRESTO_VIEW_FLAG = \"presto_view\";\n+    static final String VIEW_PREFIX = \"/* Presto View: \";\n+    static final String VIEW_SUFFIX = \" */\";\n+    private static final JsonCodec<ConnectorViewDefinition> VIEW_CODEC =\n+            new JsonCodecFactory(new ObjectMapperProvider()).jsonCodec(ConnectorViewDefinition.class);\n+    private static Logger log = Logger.get(io.prestosql.plugin.hive.ViewReaderUtil.class);\n+\n+    public static boolean isPrestoView(Table table)\n+    {\n+        return \"true\".equals(table.getParameters().get(PRESTO_VIEW_FLAG));\n+    }\n+\n+    public static boolean isHiveOrPrestoView(Table table)\n+    {\n+        return table.getTableType().equals(TableType.VIRTUAL_VIEW.name());\n+    }\n+\n+    public static boolean canDecodeView(Table table)\n+    {\n+        // we can decode Hive or Presto view\n+        return table.getTableType().equals(VIRTUAL_VIEW.name());\n+    }\n+\n+    public static String encodeViewData(ConnectorViewDefinition definition)\n+    {\n+        byte[] bytes = VIEW_CODEC.toJsonBytes(definition);\n+        String data = Base64.getEncoder().encodeToString(bytes);\n+        return VIEW_PREFIX + data + VIEW_SUFFIX;\n+    }\n+\n+    /**\n+     * Supports decoding of Presto views\n+     */\n+    public static class PrestoViewDecoder\n+            implements ViewReader\n+    {\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName)\n+        {\n+            checkCondition(viewData.startsWith(VIEW_PREFIX), HIVE_INVALID_VIEW_DATA, \"View data missing prefix: %s\", viewData);\n+            checkCondition(viewData.endsWith(VIEW_SUFFIX), HIVE_INVALID_VIEW_DATA, \"View data missing suffix: %s\", viewData);\n+            viewData = viewData.substring(VIEW_PREFIX.length());\n+            viewData = viewData.substring(0, viewData.length() - VIEW_SUFFIX.length());\n+            byte[] bytes = Base64.getDecoder().decode(viewData);\n+            return VIEW_CODEC.fromJson(bytes);\n+        }\n+    }\n+\n+    /**\n+     * Class to decode Hive view definitions\n+     */\n+    public static class HiveViewDecoder\n+            implements ViewReader\n+    {\n+        private final HiveMetastoreClient mscClient;\n+        private final TypeManager typeManager;\n+\n+        public HiveViewDecoder(HiveMetastoreClient mscClient, TypeManager typemanager)\n+        {\n+            this.mscClient = mscClient;\n+            this.typeManager = requireNonNull(typemanager, \"metadata is null\");\n+        }\n+\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewSql, Table table, CatalogName catalogName)\n+        {\n+            try {\n+                HiveToRelConverter hiveToRelConverter = HiveToRelConverter.create(mscClient);\n+                RelNode rel = hiveToRelConverter.convertView(table.getDatabaseName(), table.getTableName());\n+                RelToPrestoConverter rel2Presto = new RelToPrestoConverter();\n+                String prestoSql = rel2Presto.convert(rel);\n+                RelDataType rowType = rel.getRowType();\n+                List<ConnectorViewDefinition.ViewColumn> columns = new ArrayList<>(rowType.getFieldCount());\n+                for (RelDataTypeField field : rowType.getFieldList()) {\n+                    log.debug(\"Adding column %s, %s, %s, %s\", field.getName(),\n+                            field.getType().getFullTypeString(),\n+                            field.getType().getSqlTypeName(),\n+                            field);\n+\n+                    Type type = typeManager.fromSqlType(getTypeString(field.getType()));\n+                    ConnectorViewDefinition.ViewColumn column = new ConnectorViewDefinition.ViewColumn(field.getName(), type.getTypeId());\n+                    columns.add(column);\n+                }\n+                return new ConnectorViewDefinition(prestoSql,\n+                        Optional.of(catalogName.toString()),\n+                        Optional.of(table.getDatabaseName()),\n+                        columns,\n+                        Optional.ofNullable(table.getParameters().get(TABLE_COMMENT)),\n+                        Optional.empty(),\n+                        true);\n+            }\n+            catch (RuntimeException e) {\n+                throw new PrestoException(HIVE_UNKNOWN_ERROR,\n+                        format(\"Error decoding view definition for %s.%s: %s. Please report this to ask_dali@linkedin.com\",\n+                                table.getDatabaseName(),\n+                                table.getTableName(),\n+                                e.getMessage()),\n+                        e);\n+            }\n+        }\n+\n+        // Calcite does not provide correct type strings for non-primitive types.\n+        // We add custom code here to make it work. Goal is for calcite/coral to handle this\n+        private String getTypeString(RelDataType type)\n+        {\n+            switch (type.getSqlTypeName()) {\n+                case ROW: {\n+                    Preconditions.checkState(type.isStruct());\n+                    StringBuilder sb = new StringBuilder(\"row(\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM0MTEzOA==", "bodyText": "This can chain (no need for a variable). Though I think it's easier to read with string formatting\nreturn format(\"map(%s,%s)\", getTypeString(keyType), getTypeString(valueType));", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495341138", "createdAt": "2020-09-26T00:29:15Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReaderUtil.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.base.Preconditions;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_UNKNOWN_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+public final class ViewReaderUtil\n+{\n+    private ViewReaderUtil()\n+    {}\n+\n+    public interface ViewReader\n+    {\n+        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+    }\n+\n+    public static ViewReader createViewReader(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.PrestoViewDecoder();\n+        }\n+        else {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.HiveViewDecoder(new CoralSemiTransactionalHiveMSCAdapter(metastore, identity), typemanager);\n+        }\n+    }\n+\n+    public static final String PRESTO_VIEW_FLAG = \"presto_view\";\n+    static final String VIEW_PREFIX = \"/* Presto View: \";\n+    static final String VIEW_SUFFIX = \" */\";\n+    private static final JsonCodec<ConnectorViewDefinition> VIEW_CODEC =\n+            new JsonCodecFactory(new ObjectMapperProvider()).jsonCodec(ConnectorViewDefinition.class);\n+    private static Logger log = Logger.get(io.prestosql.plugin.hive.ViewReaderUtil.class);\n+\n+    public static boolean isPrestoView(Table table)\n+    {\n+        return \"true\".equals(table.getParameters().get(PRESTO_VIEW_FLAG));\n+    }\n+\n+    public static boolean isHiveOrPrestoView(Table table)\n+    {\n+        return table.getTableType().equals(TableType.VIRTUAL_VIEW.name());\n+    }\n+\n+    public static boolean canDecodeView(Table table)\n+    {\n+        // we can decode Hive or Presto view\n+        return table.getTableType().equals(VIRTUAL_VIEW.name());\n+    }\n+\n+    public static String encodeViewData(ConnectorViewDefinition definition)\n+    {\n+        byte[] bytes = VIEW_CODEC.toJsonBytes(definition);\n+        String data = Base64.getEncoder().encodeToString(bytes);\n+        return VIEW_PREFIX + data + VIEW_SUFFIX;\n+    }\n+\n+    /**\n+     * Supports decoding of Presto views\n+     */\n+    public static class PrestoViewDecoder\n+            implements ViewReader\n+    {\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName)\n+        {\n+            checkCondition(viewData.startsWith(VIEW_PREFIX), HIVE_INVALID_VIEW_DATA, \"View data missing prefix: %s\", viewData);\n+            checkCondition(viewData.endsWith(VIEW_SUFFIX), HIVE_INVALID_VIEW_DATA, \"View data missing suffix: %s\", viewData);\n+            viewData = viewData.substring(VIEW_PREFIX.length());\n+            viewData = viewData.substring(0, viewData.length() - VIEW_SUFFIX.length());\n+            byte[] bytes = Base64.getDecoder().decode(viewData);\n+            return VIEW_CODEC.fromJson(bytes);\n+        }\n+    }\n+\n+    /**\n+     * Class to decode Hive view definitions\n+     */\n+    public static class HiveViewDecoder\n+            implements ViewReader\n+    {\n+        private final HiveMetastoreClient mscClient;\n+        private final TypeManager typeManager;\n+\n+        public HiveViewDecoder(HiveMetastoreClient mscClient, TypeManager typemanager)\n+        {\n+            this.mscClient = mscClient;\n+            this.typeManager = requireNonNull(typemanager, \"metadata is null\");\n+        }\n+\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewSql, Table table, CatalogName catalogName)\n+        {\n+            try {\n+                HiveToRelConverter hiveToRelConverter = HiveToRelConverter.create(mscClient);\n+                RelNode rel = hiveToRelConverter.convertView(table.getDatabaseName(), table.getTableName());\n+                RelToPrestoConverter rel2Presto = new RelToPrestoConverter();\n+                String prestoSql = rel2Presto.convert(rel);\n+                RelDataType rowType = rel.getRowType();\n+                List<ConnectorViewDefinition.ViewColumn> columns = new ArrayList<>(rowType.getFieldCount());\n+                for (RelDataTypeField field : rowType.getFieldList()) {\n+                    log.debug(\"Adding column %s, %s, %s, %s\", field.getName(),\n+                            field.getType().getFullTypeString(),\n+                            field.getType().getSqlTypeName(),\n+                            field);\n+\n+                    Type type = typeManager.fromSqlType(getTypeString(field.getType()));\n+                    ConnectorViewDefinition.ViewColumn column = new ConnectorViewDefinition.ViewColumn(field.getName(), type.getTypeId());\n+                    columns.add(column);\n+                }\n+                return new ConnectorViewDefinition(prestoSql,\n+                        Optional.of(catalogName.toString()),\n+                        Optional.of(table.getDatabaseName()),\n+                        columns,\n+                        Optional.ofNullable(table.getParameters().get(TABLE_COMMENT)),\n+                        Optional.empty(),\n+                        true);\n+            }\n+            catch (RuntimeException e) {\n+                throw new PrestoException(HIVE_UNKNOWN_ERROR,\n+                        format(\"Error decoding view definition for %s.%s: %s. Please report this to ask_dali@linkedin.com\",\n+                                table.getDatabaseName(),\n+                                table.getTableName(),\n+                                e.getMessage()),\n+                        e);\n+            }\n+        }\n+\n+        // Calcite does not provide correct type strings for non-primitive types.\n+        // We add custom code here to make it work. Goal is for calcite/coral to handle this\n+        private String getTypeString(RelDataType type)\n+        {\n+            switch (type.getSqlTypeName()) {\n+                case ROW: {\n+                    Preconditions.checkState(type.isStruct());\n+                    StringBuilder sb = new StringBuilder(\"row(\");\n+                    List<RelDataTypeField> fieldList = type.getFieldList();\n+                    for (int i = 0; i < fieldList.size(); i++) {\n+                        if (i != 0) {\n+                            // There should not be space after comma. Presto deserializer doesn't like it\n+                            sb.append(\",\");\n+                        }\n+                        RelDataTypeField field = fieldList.get(i);\n+                        sb.append(field.getName().toLowerCase(Locale.ENGLISH)).append(\" \").append(getTypeString(field.getType()));\n+                    }\n+                    sb.append(\")\");\n+                    return sb.toString();\n+                }\n+                case CHAR:\n+                    return \"varchar\";\n+                case FLOAT:\n+                    return \"real\";\n+                case BINARY:\n+                case VARBINARY:\n+                    return \"varbinary\";\n+                case MAP: {\n+                    RelDataType keyType = type.getKeyType();\n+                    RelDataType valueType = type.getValueType();\n+                    StringBuilder sb = new StringBuilder(\"map(\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM0MTI3NA==", "bodyText": "return format(\"array(%s)\", type.getComponentType());", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495341274", "createdAt": "2020-09-26T00:29:30Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReaderUtil.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.base.Preconditions;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_UNKNOWN_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+public final class ViewReaderUtil\n+{\n+    private ViewReaderUtil()\n+    {}\n+\n+    public interface ViewReader\n+    {\n+        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+    }\n+\n+    public static ViewReader createViewReader(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.PrestoViewDecoder();\n+        }\n+        else {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.HiveViewDecoder(new CoralSemiTransactionalHiveMSCAdapter(metastore, identity), typemanager);\n+        }\n+    }\n+\n+    public static final String PRESTO_VIEW_FLAG = \"presto_view\";\n+    static final String VIEW_PREFIX = \"/* Presto View: \";\n+    static final String VIEW_SUFFIX = \" */\";\n+    private static final JsonCodec<ConnectorViewDefinition> VIEW_CODEC =\n+            new JsonCodecFactory(new ObjectMapperProvider()).jsonCodec(ConnectorViewDefinition.class);\n+    private static Logger log = Logger.get(io.prestosql.plugin.hive.ViewReaderUtil.class);\n+\n+    public static boolean isPrestoView(Table table)\n+    {\n+        return \"true\".equals(table.getParameters().get(PRESTO_VIEW_FLAG));\n+    }\n+\n+    public static boolean isHiveOrPrestoView(Table table)\n+    {\n+        return table.getTableType().equals(TableType.VIRTUAL_VIEW.name());\n+    }\n+\n+    public static boolean canDecodeView(Table table)\n+    {\n+        // we can decode Hive or Presto view\n+        return table.getTableType().equals(VIRTUAL_VIEW.name());\n+    }\n+\n+    public static String encodeViewData(ConnectorViewDefinition definition)\n+    {\n+        byte[] bytes = VIEW_CODEC.toJsonBytes(definition);\n+        String data = Base64.getEncoder().encodeToString(bytes);\n+        return VIEW_PREFIX + data + VIEW_SUFFIX;\n+    }\n+\n+    /**\n+     * Supports decoding of Presto views\n+     */\n+    public static class PrestoViewDecoder\n+            implements ViewReader\n+    {\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName)\n+        {\n+            checkCondition(viewData.startsWith(VIEW_PREFIX), HIVE_INVALID_VIEW_DATA, \"View data missing prefix: %s\", viewData);\n+            checkCondition(viewData.endsWith(VIEW_SUFFIX), HIVE_INVALID_VIEW_DATA, \"View data missing suffix: %s\", viewData);\n+            viewData = viewData.substring(VIEW_PREFIX.length());\n+            viewData = viewData.substring(0, viewData.length() - VIEW_SUFFIX.length());\n+            byte[] bytes = Base64.getDecoder().decode(viewData);\n+            return VIEW_CODEC.fromJson(bytes);\n+        }\n+    }\n+\n+    /**\n+     * Class to decode Hive view definitions\n+     */\n+    public static class HiveViewDecoder\n+            implements ViewReader\n+    {\n+        private final HiveMetastoreClient mscClient;\n+        private final TypeManager typeManager;\n+\n+        public HiveViewDecoder(HiveMetastoreClient mscClient, TypeManager typemanager)\n+        {\n+            this.mscClient = mscClient;\n+            this.typeManager = requireNonNull(typemanager, \"metadata is null\");\n+        }\n+\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewSql, Table table, CatalogName catalogName)\n+        {\n+            try {\n+                HiveToRelConverter hiveToRelConverter = HiveToRelConverter.create(mscClient);\n+                RelNode rel = hiveToRelConverter.convertView(table.getDatabaseName(), table.getTableName());\n+                RelToPrestoConverter rel2Presto = new RelToPrestoConverter();\n+                String prestoSql = rel2Presto.convert(rel);\n+                RelDataType rowType = rel.getRowType();\n+                List<ConnectorViewDefinition.ViewColumn> columns = new ArrayList<>(rowType.getFieldCount());\n+                for (RelDataTypeField field : rowType.getFieldList()) {\n+                    log.debug(\"Adding column %s, %s, %s, %s\", field.getName(),\n+                            field.getType().getFullTypeString(),\n+                            field.getType().getSqlTypeName(),\n+                            field);\n+\n+                    Type type = typeManager.fromSqlType(getTypeString(field.getType()));\n+                    ConnectorViewDefinition.ViewColumn column = new ConnectorViewDefinition.ViewColumn(field.getName(), type.getTypeId());\n+                    columns.add(column);\n+                }\n+                return new ConnectorViewDefinition(prestoSql,\n+                        Optional.of(catalogName.toString()),\n+                        Optional.of(table.getDatabaseName()),\n+                        columns,\n+                        Optional.ofNullable(table.getParameters().get(TABLE_COMMENT)),\n+                        Optional.empty(),\n+                        true);\n+            }\n+            catch (RuntimeException e) {\n+                throw new PrestoException(HIVE_UNKNOWN_ERROR,\n+                        format(\"Error decoding view definition for %s.%s: %s. Please report this to ask_dali@linkedin.com\",\n+                                table.getDatabaseName(),\n+                                table.getTableName(),\n+                                e.getMessage()),\n+                        e);\n+            }\n+        }\n+\n+        // Calcite does not provide correct type strings for non-primitive types.\n+        // We add custom code here to make it work. Goal is for calcite/coral to handle this\n+        private String getTypeString(RelDataType type)\n+        {\n+            switch (type.getSqlTypeName()) {\n+                case ROW: {\n+                    Preconditions.checkState(type.isStruct());\n+                    StringBuilder sb = new StringBuilder(\"row(\");\n+                    List<RelDataTypeField> fieldList = type.getFieldList();\n+                    for (int i = 0; i < fieldList.size(); i++) {\n+                        if (i != 0) {\n+                            // There should not be space after comma. Presto deserializer doesn't like it\n+                            sb.append(\",\");\n+                        }\n+                        RelDataTypeField field = fieldList.get(i);\n+                        sb.append(field.getName().toLowerCase(Locale.ENGLISH)).append(\" \").append(getTypeString(field.getType()));\n+                    }\n+                    sb.append(\")\");\n+                    return sb.toString();\n+                }\n+                case CHAR:\n+                    return \"varchar\";\n+                case FLOAT:\n+                    return \"real\";\n+                case BINARY:\n+                case VARBINARY:\n+                    return \"varbinary\";\n+                case MAP: {\n+                    RelDataType keyType = type.getKeyType();\n+                    RelDataType valueType = type.getValueType();\n+                    StringBuilder sb = new StringBuilder(\"map(\");\n+                    sb.append(getTypeString(keyType))\n+                            .append(\",\")\n+                            .append(getTypeString(valueType));\n+                    sb.append(\")\");\n+                    return sb.toString();\n+                }\n+                case ARRAY: {\n+                    StringBuilder sb = new StringBuilder(\"array(\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM0MTQxNg==", "bodyText": "return format(\"decimal(%s,%s)\", type.getPrecision(), type.getScale());", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495341416", "createdAt": "2020-09-26T00:29:50Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReaderUtil.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.base.Preconditions;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_UNKNOWN_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+public final class ViewReaderUtil\n+{\n+    private ViewReaderUtil()\n+    {}\n+\n+    public interface ViewReader\n+    {\n+        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+    }\n+\n+    public static ViewReader createViewReader(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.PrestoViewDecoder();\n+        }\n+        else {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.HiveViewDecoder(new CoralSemiTransactionalHiveMSCAdapter(metastore, identity), typemanager);\n+        }\n+    }\n+\n+    public static final String PRESTO_VIEW_FLAG = \"presto_view\";\n+    static final String VIEW_PREFIX = \"/* Presto View: \";\n+    static final String VIEW_SUFFIX = \" */\";\n+    private static final JsonCodec<ConnectorViewDefinition> VIEW_CODEC =\n+            new JsonCodecFactory(new ObjectMapperProvider()).jsonCodec(ConnectorViewDefinition.class);\n+    private static Logger log = Logger.get(io.prestosql.plugin.hive.ViewReaderUtil.class);\n+\n+    public static boolean isPrestoView(Table table)\n+    {\n+        return \"true\".equals(table.getParameters().get(PRESTO_VIEW_FLAG));\n+    }\n+\n+    public static boolean isHiveOrPrestoView(Table table)\n+    {\n+        return table.getTableType().equals(TableType.VIRTUAL_VIEW.name());\n+    }\n+\n+    public static boolean canDecodeView(Table table)\n+    {\n+        // we can decode Hive or Presto view\n+        return table.getTableType().equals(VIRTUAL_VIEW.name());\n+    }\n+\n+    public static String encodeViewData(ConnectorViewDefinition definition)\n+    {\n+        byte[] bytes = VIEW_CODEC.toJsonBytes(definition);\n+        String data = Base64.getEncoder().encodeToString(bytes);\n+        return VIEW_PREFIX + data + VIEW_SUFFIX;\n+    }\n+\n+    /**\n+     * Supports decoding of Presto views\n+     */\n+    public static class PrestoViewDecoder\n+            implements ViewReader\n+    {\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName)\n+        {\n+            checkCondition(viewData.startsWith(VIEW_PREFIX), HIVE_INVALID_VIEW_DATA, \"View data missing prefix: %s\", viewData);\n+            checkCondition(viewData.endsWith(VIEW_SUFFIX), HIVE_INVALID_VIEW_DATA, \"View data missing suffix: %s\", viewData);\n+            viewData = viewData.substring(VIEW_PREFIX.length());\n+            viewData = viewData.substring(0, viewData.length() - VIEW_SUFFIX.length());\n+            byte[] bytes = Base64.getDecoder().decode(viewData);\n+            return VIEW_CODEC.fromJson(bytes);\n+        }\n+    }\n+\n+    /**\n+     * Class to decode Hive view definitions\n+     */\n+    public static class HiveViewDecoder\n+            implements ViewReader\n+    {\n+        private final HiveMetastoreClient mscClient;\n+        private final TypeManager typeManager;\n+\n+        public HiveViewDecoder(HiveMetastoreClient mscClient, TypeManager typemanager)\n+        {\n+            this.mscClient = mscClient;\n+            this.typeManager = requireNonNull(typemanager, \"metadata is null\");\n+        }\n+\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewSql, Table table, CatalogName catalogName)\n+        {\n+            try {\n+                HiveToRelConverter hiveToRelConverter = HiveToRelConverter.create(mscClient);\n+                RelNode rel = hiveToRelConverter.convertView(table.getDatabaseName(), table.getTableName());\n+                RelToPrestoConverter rel2Presto = new RelToPrestoConverter();\n+                String prestoSql = rel2Presto.convert(rel);\n+                RelDataType rowType = rel.getRowType();\n+                List<ConnectorViewDefinition.ViewColumn> columns = new ArrayList<>(rowType.getFieldCount());\n+                for (RelDataTypeField field : rowType.getFieldList()) {\n+                    log.debug(\"Adding column %s, %s, %s, %s\", field.getName(),\n+                            field.getType().getFullTypeString(),\n+                            field.getType().getSqlTypeName(),\n+                            field);\n+\n+                    Type type = typeManager.fromSqlType(getTypeString(field.getType()));\n+                    ConnectorViewDefinition.ViewColumn column = new ConnectorViewDefinition.ViewColumn(field.getName(), type.getTypeId());\n+                    columns.add(column);\n+                }\n+                return new ConnectorViewDefinition(prestoSql,\n+                        Optional.of(catalogName.toString()),\n+                        Optional.of(table.getDatabaseName()),\n+                        columns,\n+                        Optional.ofNullable(table.getParameters().get(TABLE_COMMENT)),\n+                        Optional.empty(),\n+                        true);\n+            }\n+            catch (RuntimeException e) {\n+                throw new PrestoException(HIVE_UNKNOWN_ERROR,\n+                        format(\"Error decoding view definition for %s.%s: %s. Please report this to ask_dali@linkedin.com\",\n+                                table.getDatabaseName(),\n+                                table.getTableName(),\n+                                e.getMessage()),\n+                        e);\n+            }\n+        }\n+\n+        // Calcite does not provide correct type strings for non-primitive types.\n+        // We add custom code here to make it work. Goal is for calcite/coral to handle this\n+        private String getTypeString(RelDataType type)\n+        {\n+            switch (type.getSqlTypeName()) {\n+                case ROW: {\n+                    Preconditions.checkState(type.isStruct());\n+                    StringBuilder sb = new StringBuilder(\"row(\");\n+                    List<RelDataTypeField> fieldList = type.getFieldList();\n+                    for (int i = 0; i < fieldList.size(); i++) {\n+                        if (i != 0) {\n+                            // There should not be space after comma. Presto deserializer doesn't like it\n+                            sb.append(\",\");\n+                        }\n+                        RelDataTypeField field = fieldList.get(i);\n+                        sb.append(field.getName().toLowerCase(Locale.ENGLISH)).append(\" \").append(getTypeString(field.getType()));\n+                    }\n+                    sb.append(\")\");\n+                    return sb.toString();\n+                }\n+                case CHAR:\n+                    return \"varchar\";\n+                case FLOAT:\n+                    return \"real\";\n+                case BINARY:\n+                case VARBINARY:\n+                    return \"varbinary\";\n+                case MAP: {\n+                    RelDataType keyType = type.getKeyType();\n+                    RelDataType valueType = type.getValueType();\n+                    StringBuilder sb = new StringBuilder(\"map(\");\n+                    sb.append(getTypeString(keyType))\n+                            .append(\",\")\n+                            .append(getTypeString(valueType));\n+                    sb.append(\")\");\n+                    return sb.toString();\n+                }\n+                case ARRAY: {\n+                    StringBuilder sb = new StringBuilder(\"array(\");\n+                    sb.append(getTypeString(type.getComponentType()));\n+                    sb.append(\")\");\n+                    return sb.toString();\n+                }\n+                case DECIMAL: {\n+                    StringBuilder sb = new StringBuilder(\"decimal(\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM0MjIwMA==", "bodyText": "We might consider explicitly listing all of the other supported types here, allowing us to throw an error if we get an unexpected type, rather than failing later when Presto parses the view.", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495342200", "createdAt": "2020-09-26T00:31:34Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReaderUtil.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.base.Preconditions;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_UNKNOWN_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+public final class ViewReaderUtil\n+{\n+    private ViewReaderUtil()\n+    {}\n+\n+    public interface ViewReader\n+    {\n+        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+    }\n+\n+    public static ViewReader createViewReader(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.PrestoViewDecoder();\n+        }\n+        else {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.HiveViewDecoder(new CoralSemiTransactionalHiveMSCAdapter(metastore, identity), typemanager);\n+        }\n+    }\n+\n+    public static final String PRESTO_VIEW_FLAG = \"presto_view\";\n+    static final String VIEW_PREFIX = \"/* Presto View: \";\n+    static final String VIEW_SUFFIX = \" */\";\n+    private static final JsonCodec<ConnectorViewDefinition> VIEW_CODEC =\n+            new JsonCodecFactory(new ObjectMapperProvider()).jsonCodec(ConnectorViewDefinition.class);\n+    private static Logger log = Logger.get(io.prestosql.plugin.hive.ViewReaderUtil.class);\n+\n+    public static boolean isPrestoView(Table table)\n+    {\n+        return \"true\".equals(table.getParameters().get(PRESTO_VIEW_FLAG));\n+    }\n+\n+    public static boolean isHiveOrPrestoView(Table table)\n+    {\n+        return table.getTableType().equals(TableType.VIRTUAL_VIEW.name());\n+    }\n+\n+    public static boolean canDecodeView(Table table)\n+    {\n+        // we can decode Hive or Presto view\n+        return table.getTableType().equals(VIRTUAL_VIEW.name());\n+    }\n+\n+    public static String encodeViewData(ConnectorViewDefinition definition)\n+    {\n+        byte[] bytes = VIEW_CODEC.toJsonBytes(definition);\n+        String data = Base64.getEncoder().encodeToString(bytes);\n+        return VIEW_PREFIX + data + VIEW_SUFFIX;\n+    }\n+\n+    /**\n+     * Supports decoding of Presto views\n+     */\n+    public static class PrestoViewDecoder\n+            implements ViewReader\n+    {\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName)\n+        {\n+            checkCondition(viewData.startsWith(VIEW_PREFIX), HIVE_INVALID_VIEW_DATA, \"View data missing prefix: %s\", viewData);\n+            checkCondition(viewData.endsWith(VIEW_SUFFIX), HIVE_INVALID_VIEW_DATA, \"View data missing suffix: %s\", viewData);\n+            viewData = viewData.substring(VIEW_PREFIX.length());\n+            viewData = viewData.substring(0, viewData.length() - VIEW_SUFFIX.length());\n+            byte[] bytes = Base64.getDecoder().decode(viewData);\n+            return VIEW_CODEC.fromJson(bytes);\n+        }\n+    }\n+\n+    /**\n+     * Class to decode Hive view definitions\n+     */\n+    public static class HiveViewDecoder\n+            implements ViewReader\n+    {\n+        private final HiveMetastoreClient mscClient;\n+        private final TypeManager typeManager;\n+\n+        public HiveViewDecoder(HiveMetastoreClient mscClient, TypeManager typemanager)\n+        {\n+            this.mscClient = mscClient;\n+            this.typeManager = requireNonNull(typemanager, \"metadata is null\");\n+        }\n+\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewSql, Table table, CatalogName catalogName)\n+        {\n+            try {\n+                HiveToRelConverter hiveToRelConverter = HiveToRelConverter.create(mscClient);\n+                RelNode rel = hiveToRelConverter.convertView(table.getDatabaseName(), table.getTableName());\n+                RelToPrestoConverter rel2Presto = new RelToPrestoConverter();\n+                String prestoSql = rel2Presto.convert(rel);\n+                RelDataType rowType = rel.getRowType();\n+                List<ConnectorViewDefinition.ViewColumn> columns = new ArrayList<>(rowType.getFieldCount());\n+                for (RelDataTypeField field : rowType.getFieldList()) {\n+                    log.debug(\"Adding column %s, %s, %s, %s\", field.getName(),\n+                            field.getType().getFullTypeString(),\n+                            field.getType().getSqlTypeName(),\n+                            field);\n+\n+                    Type type = typeManager.fromSqlType(getTypeString(field.getType()));\n+                    ConnectorViewDefinition.ViewColumn column = new ConnectorViewDefinition.ViewColumn(field.getName(), type.getTypeId());\n+                    columns.add(column);\n+                }\n+                return new ConnectorViewDefinition(prestoSql,\n+                        Optional.of(catalogName.toString()),\n+                        Optional.of(table.getDatabaseName()),\n+                        columns,\n+                        Optional.ofNullable(table.getParameters().get(TABLE_COMMENT)),\n+                        Optional.empty(),\n+                        true);\n+            }\n+            catch (RuntimeException e) {\n+                throw new PrestoException(HIVE_UNKNOWN_ERROR,\n+                        format(\"Error decoding view definition for %s.%s: %s. Please report this to ask_dali@linkedin.com\",\n+                                table.getDatabaseName(),\n+                                table.getTableName(),\n+                                e.getMessage()),\n+                        e);\n+            }\n+        }\n+\n+        // Calcite does not provide correct type strings for non-primitive types.\n+        // We add custom code here to make it work. Goal is for calcite/coral to handle this\n+        private String getTypeString(RelDataType type)\n+        {\n+            switch (type.getSqlTypeName()) {\n+                case ROW: {\n+                    Preconditions.checkState(type.isStruct());\n+                    StringBuilder sb = new StringBuilder(\"row(\");\n+                    List<RelDataTypeField> fieldList = type.getFieldList();\n+                    for (int i = 0; i < fieldList.size(); i++) {\n+                        if (i != 0) {\n+                            // There should not be space after comma. Presto deserializer doesn't like it\n+                            sb.append(\",\");\n+                        }\n+                        RelDataTypeField field = fieldList.get(i);\n+                        sb.append(field.getName().toLowerCase(Locale.ENGLISH)).append(\" \").append(getTypeString(field.getType()));\n+                    }\n+                    sb.append(\")\");\n+                    return sb.toString();\n+                }\n+                case CHAR:\n+                    return \"varchar\";\n+                case FLOAT:\n+                    return \"real\";\n+                case BINARY:\n+                case VARBINARY:\n+                    return \"varbinary\";\n+                case MAP: {\n+                    RelDataType keyType = type.getKeyType();\n+                    RelDataType valueType = type.getValueType();\n+                    StringBuilder sb = new StringBuilder(\"map(\");\n+                    sb.append(getTypeString(keyType))\n+                            .append(\",\")\n+                            .append(getTypeString(valueType));\n+                    sb.append(\")\");\n+                    return sb.toString();\n+                }\n+                case ARRAY: {\n+                    StringBuilder sb = new StringBuilder(\"array(\");\n+                    sb.append(getTypeString(type.getComponentType()));\n+                    sb.append(\")\");\n+                    return sb.toString();\n+                }\n+                case DECIMAL: {\n+                    StringBuilder sb = new StringBuilder(\"decimal(\");\n+                    sb.append(type.getPrecision())\n+                            .append(\",\")\n+                            .append(type.getScale())\n+                            .append(\")\");\n+                    return sb.toString();\n+                }\n+                default:", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM0MzQ4OQ==", "bodyText": "Import ViewColumn directly for readability.\nMaybe use a stream for this\nList<ViewColumn> columns = rowType.getFieldList().stream()\n        .map(field -> new ViewColumn(\n                field.getName(),\n                typeManager.fromSqlType(getTypeString(field.getType())).getTypeId()))\n        .collect(toImmutableList());", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r495343489", "createdAt": "2020-09-26T00:34:17Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReaderUtil.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.base.Preconditions;\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_UNKNOWN_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+public final class ViewReaderUtil\n+{\n+    private ViewReaderUtil()\n+    {}\n+\n+    public interface ViewReader\n+    {\n+        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+    }\n+\n+    public static ViewReader createViewReader(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.PrestoViewDecoder();\n+        }\n+        else {\n+            return new io.prestosql.plugin.hive.ViewReaderUtil.HiveViewDecoder(new CoralSemiTransactionalHiveMSCAdapter(metastore, identity), typemanager);\n+        }\n+    }\n+\n+    public static final String PRESTO_VIEW_FLAG = \"presto_view\";\n+    static final String VIEW_PREFIX = \"/* Presto View: \";\n+    static final String VIEW_SUFFIX = \" */\";\n+    private static final JsonCodec<ConnectorViewDefinition> VIEW_CODEC =\n+            new JsonCodecFactory(new ObjectMapperProvider()).jsonCodec(ConnectorViewDefinition.class);\n+    private static Logger log = Logger.get(io.prestosql.plugin.hive.ViewReaderUtil.class);\n+\n+    public static boolean isPrestoView(Table table)\n+    {\n+        return \"true\".equals(table.getParameters().get(PRESTO_VIEW_FLAG));\n+    }\n+\n+    public static boolean isHiveOrPrestoView(Table table)\n+    {\n+        return table.getTableType().equals(TableType.VIRTUAL_VIEW.name());\n+    }\n+\n+    public static boolean canDecodeView(Table table)\n+    {\n+        // we can decode Hive or Presto view\n+        return table.getTableType().equals(VIRTUAL_VIEW.name());\n+    }\n+\n+    public static String encodeViewData(ConnectorViewDefinition definition)\n+    {\n+        byte[] bytes = VIEW_CODEC.toJsonBytes(definition);\n+        String data = Base64.getEncoder().encodeToString(bytes);\n+        return VIEW_PREFIX + data + VIEW_SUFFIX;\n+    }\n+\n+    /**\n+     * Supports decoding of Presto views\n+     */\n+    public static class PrestoViewDecoder\n+            implements ViewReader\n+    {\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName)\n+        {\n+            checkCondition(viewData.startsWith(VIEW_PREFIX), HIVE_INVALID_VIEW_DATA, \"View data missing prefix: %s\", viewData);\n+            checkCondition(viewData.endsWith(VIEW_SUFFIX), HIVE_INVALID_VIEW_DATA, \"View data missing suffix: %s\", viewData);\n+            viewData = viewData.substring(VIEW_PREFIX.length());\n+            viewData = viewData.substring(0, viewData.length() - VIEW_SUFFIX.length());\n+            byte[] bytes = Base64.getDecoder().decode(viewData);\n+            return VIEW_CODEC.fromJson(bytes);\n+        }\n+    }\n+\n+    /**\n+     * Class to decode Hive view definitions\n+     */\n+    public static class HiveViewDecoder\n+            implements ViewReader\n+    {\n+        private final HiveMetastoreClient mscClient;\n+        private final TypeManager typeManager;\n+\n+        public HiveViewDecoder(HiveMetastoreClient mscClient, TypeManager typemanager)\n+        {\n+            this.mscClient = mscClient;\n+            this.typeManager = requireNonNull(typemanager, \"metadata is null\");\n+        }\n+\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewSql, Table table, CatalogName catalogName)\n+        {\n+            try {\n+                HiveToRelConverter hiveToRelConverter = HiveToRelConverter.create(mscClient);\n+                RelNode rel = hiveToRelConverter.convertView(table.getDatabaseName(), table.getTableName());\n+                RelToPrestoConverter rel2Presto = new RelToPrestoConverter();\n+                String prestoSql = rel2Presto.convert(rel);\n+                RelDataType rowType = rel.getRowType();\n+                List<ConnectorViewDefinition.ViewColumn> columns = new ArrayList<>(rowType.getFieldCount());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 144}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzQ1MDk0", "url": "https://github.com/trinodb/trino/pull/4661#pullrequestreview-497745094", "createdAt": "2020-09-28T17:24:02Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "f93122c17424bed9e39b6a4a29b6fede102dc8d2", "author": {"user": {"login": "laurachenyu", "name": null}}, "url": "https://github.com/trinodb/trino/commit/f93122c17424bed9e39b6a4a29b6fede102dc8d2", "committedDate": "2020-10-09T19:24:24Z", "message": "Integrate Coral with Presto to enable querying hive views"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "f93122c17424bed9e39b6a4a29b6fede102dc8d2", "author": {"user": {"login": "laurachenyu", "name": null}}, "url": "https://github.com/trinodb/trino/commit/f93122c17424bed9e39b6a4a29b6fede102dc8d2", "committedDate": "2020-10-09T19:24:24Z", "message": "Integrate Coral with Presto to enable querying hive views"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3NzI5OTgx", "url": "https://github.com/trinodb/trino/pull/4661#pullrequestreview-507729981", "createdAt": "2020-10-13T18:43:14Z", "commit": {"oid": "f93122c17424bed9e39b6a4a29b6fede102dc8d2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMTI0NzE0", "url": "https://github.com/trinodb/trino/pull/4661#pullrequestreview-511124714", "createdAt": "2020-10-18T09:16:37Z", "commit": {"oid": "f93122c17424bed9e39b6a4a29b6fede102dc8d2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOToxNjozN1rOHjkQVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOToxNjozN1rOHjkQVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA1NjIxNQ==", "bodyText": "Just double checking. Is this deliberate choice to execute Hive views by INVOKER? Previously they were executed by INVOKER. It sounds like a backward incompatible change (just noting for release notes if it is deliberate choice).", "url": "https://github.com/trinodb/trino/pull/4661#discussion_r507056215", "createdAt": "2020-10-18T09:16:37Z", "author": {"login": "kokosing"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/ViewReaderUtil.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.linkedin.coral.hive.hive2rel.HiveMetastoreClient;\n+import com.linkedin.coral.hive.hive2rel.HiveToRelConverter;\n+import com.linkedin.coral.presto.rel2presto.RelToPrestoConverter;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.json.JsonCodecFactory;\n+import io.airlift.json.ObjectMapperProvider;\n+import io.airlift.log.Logger;\n+import io.prestosql.plugin.base.CatalogName;\n+import io.prestosql.plugin.hive.authentication.HiveIdentity;\n+import io.prestosql.plugin.hive.metastore.CoralSemiTransactionalHiveMSCAdapter;\n+import io.prestosql.plugin.hive.metastore.SemiTransactionalHiveMetastore;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorViewDefinition;\n+import io.prestosql.spi.connector.ConnectorViewDefinition.ViewColumn;\n+import io.prestosql.spi.type.TypeManager;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.hadoop.hive.metastore.TableType;\n+\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_VIEW_DATA;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_VIEW_TRANSLATION_ERROR;\n+import static io.prestosql.plugin.hive.HiveMetadata.TABLE_COMMENT;\n+import static io.prestosql.plugin.hive.util.HiveUtil.checkCondition;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.joining;\n+import static org.apache.hadoop.hive.metastore.TableType.VIRTUAL_VIEW;\n+\n+public final class ViewReaderUtil\n+{\n+    private ViewReaderUtil()\n+    {}\n+\n+    public interface ViewReader\n+    {\n+        ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName);\n+    }\n+\n+    public static ViewReader createViewReader(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, Table table, TypeManager typemanager)\n+    {\n+        if (isPrestoView(table)) {\n+            return new PrestoViewReader();\n+        }\n+        return new HiveViewReader(new CoralSemiTransactionalHiveMSCAdapter(metastore, identity), typemanager);\n+    }\n+\n+    public static final String PRESTO_VIEW_FLAG = \"presto_view\";\n+    static final String VIEW_PREFIX = \"/* Presto View: \";\n+    static final String VIEW_SUFFIX = \" */\";\n+    private static final JsonCodec<ConnectorViewDefinition> VIEW_CODEC =\n+            new JsonCodecFactory(new ObjectMapperProvider()).jsonCodec(ConnectorViewDefinition.class);\n+    private static Logger log = Logger.get(io.prestosql.plugin.hive.ViewReaderUtil.class);\n+\n+    public static boolean isPrestoView(Table table)\n+    {\n+        return \"true\".equals(table.getParameters().get(PRESTO_VIEW_FLAG));\n+    }\n+\n+    public static boolean isHiveOrPrestoView(Table table)\n+    {\n+        return table.getTableType().equals(TableType.VIRTUAL_VIEW.name());\n+    }\n+\n+    public static boolean canDecodeView(Table table)\n+    {\n+        // we can decode Hive or Presto view\n+        return table.getTableType().equals(VIRTUAL_VIEW.name());\n+    }\n+\n+    public static String encodeViewData(ConnectorViewDefinition definition)\n+    {\n+        byte[] bytes = VIEW_CODEC.toJsonBytes(definition);\n+        String data = Base64.getEncoder().encodeToString(bytes);\n+        return VIEW_PREFIX + data + VIEW_SUFFIX;\n+    }\n+\n+    /**\n+     * Supports decoding of Presto views\n+     */\n+    public static class PrestoViewReader\n+            implements ViewReader\n+    {\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewData, Table table, CatalogName catalogName)\n+        {\n+            checkCondition(viewData.startsWith(VIEW_PREFIX), HIVE_INVALID_VIEW_DATA, \"View data missing prefix: %s\", viewData);\n+            checkCondition(viewData.endsWith(VIEW_SUFFIX), HIVE_INVALID_VIEW_DATA, \"View data missing suffix: %s\", viewData);\n+            viewData = viewData.substring(VIEW_PREFIX.length());\n+            viewData = viewData.substring(0, viewData.length() - VIEW_SUFFIX.length());\n+            byte[] bytes = Base64.getDecoder().decode(viewData);\n+            return VIEW_CODEC.fromJson(bytes);\n+        }\n+    }\n+\n+    /**\n+     * Class to decode Hive view definitions\n+     */\n+    public static class HiveViewReader\n+            implements ViewReader\n+    {\n+        private final HiveMetastoreClient metastoreClient;\n+        private final TypeManager typeManager;\n+\n+        public HiveViewReader(HiveMetastoreClient hiveMetastoreClient, TypeManager typemanager)\n+        {\n+            this.metastoreClient = requireNonNull(hiveMetastoreClient, \"metastoreClient is null\");\n+            this.typeManager = requireNonNull(typemanager, \"typeManager is null\");\n+        }\n+\n+        @Override\n+        public ConnectorViewDefinition decodeViewData(String viewSql, Table table, CatalogName catalogName)\n+        {\n+            try {\n+                HiveToRelConverter hiveToRelConverter = HiveToRelConverter.create(metastoreClient);\n+                RelNode rel = hiveToRelConverter.convertView(table.getDatabaseName(), table.getTableName());\n+                RelToPrestoConverter rel2Presto = new RelToPrestoConverter();\n+                String prestoSql = rel2Presto.convert(rel);\n+                RelDataType rowType = rel.getRowType();\n+                List<ViewColumn> columns = rowType.getFieldList().stream()\n+                        .map(field -> new ViewColumn(\n+                                field.getName(),\n+                                typeManager.fromSqlType(getTypeString(field.getType())).getTypeId()))\n+                        .collect(toImmutableList());\n+                return new ConnectorViewDefinition(prestoSql,\n+                        Optional.of(catalogName.toString()),\n+                        Optional.of(table.getDatabaseName()),\n+                        columns,\n+                        Optional.ofNullable(table.getParameters().get(TABLE_COMMENT)),\n+                        Optional.empty(),\n+                        true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f93122c17424bed9e39b6a4a29b6fede102dc8d2"}, "originalPosition": 153}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4586, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}