{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3OTY5Njcw", "number": 4144, "title": "Support enforcement of NOT NULL column declarations", "bodyText": "This commit enforces NOT NULL column declarations on write\nin the Presto engine, so it applies to all connectors.  The\nexisting Postgres and Mysql tests named testInsertIntoNotNullColumn\nwere changed to check for the new error message, and a new test\nwith the same name was added to TestIcebergSmoke.\nOne possible concern with this commit is that the error message\nissued by the Presto engine when writing a null to a NOT NULL\ncolumn is a different message than the Connector might issue\nif no value was supplied for the NOT NULL column.  I think this\nis ok, because the error messages supplied by the Connectors are\ncompletely specific to the Connector.", "createdAt": "2020-06-22T14:10:02Z", "url": "https://github.com/trinodb/trino/pull/4144", "merged": true, "mergeCommit": {"oid": "078b68023ee83e7c79fd31fbfb41dd454a4e4c5a"}, "closed": true, "closedAt": "2020-06-29T15:28:42Z", "author": {"login": "djsstarburst"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABct39I7AFqTQzNTI5NTM5NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcvYj4PABqjM0ODkwMTE2ODk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1Mjk1Mzk0", "url": "https://github.com/trinodb/trino/pull/4144#pullrequestreview-435295394", "createdAt": "2020-06-22T21:44:05Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMTo0NDowNVrOGnSDNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMTo0NDowNVrOGnSDNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg0MzM4MQ==", "bodyText": "plan.getFieldMappings() is guaranteed to match the order of columns in plan.getScope().getRelationType() (i.e., the output \"shape\" of the query).\nThe planner is not the right place to match ColumnMetadata to fields, as there is no correspondence between those fields and the order in which the fields appear in the plan.\nFor instance, given a table t (a BIGINT, b BIGINT), the following query will see the fields in a different order: INSERT INTO t(b, a) VALUES (1, 10)\nThis should be handled during analysis. The analyzer should record which fields ordinals are supposed to be not null. Take a look at Analysis.JoinUsingAnalysis and callers for an example of how you might record that.", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r443843381", "createdAt": "2020-06-22T21:44:05Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LogicalPlanner.java", "diffHunk": "@@ -448,6 +453,18 @@ else if (isUsePreferredWritePartitioning(session)) {\n             }\n         }\n \n+        // TODO: Is this too fragile?  Other places we depend on the correspondence between order\n+        //  of non-hidden columns and order of symbols, but it feels a little grotty.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1NDI0OTQ2", "url": "https://github.com/trinodb/trino/pull/4144#pullrequestreview-435424946", "createdAt": "2020-06-23T04:07:18Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwNDowNzoxOFrOGnYhgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwNDozMjoyNlrOGnY4FQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk0OTQ0Mw==", "bodyText": "For SQL formatting, add spaces before opening parenthesis: VALUES (2)", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r443949443", "createdAt": "2020-06-23T04:07:18Z", "author": {"login": "electrum"}, "path": "presto-iceberg/src/test/java/io/prestosql/plugin/iceberg/TestIcebergSmoke.java", "diffHunk": "@@ -324,6 +324,16 @@ public void testSchemaEvolution()\n         testWithAllFileFormats(this::testSchemaEvolution);\n     }\n \n+    @Test\n+    public void testInsertIntoNotNullColumn()\n+    {\n+        assertUpdate(\"CREATE TABLE test_not_null_table (c1 INTEGER, c2 INTEGER NOT NULL)\");\n+        assertUpdate(\"INSERT INTO test_not_null_table (c2) VALUES(2)\", 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1MDg1NA==", "bodyText": "We should do this inside the check for not-null channels, since this is logically an optimization of checking the block for nulls. For nullable channels, we don't need to look at this.", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r443950854", "createdAt": "2020-06-23T04:13:23Z", "author": {"login": "electrum"}, "path": "presto-main/src/main/java/io/prestosql/operator/TableWriterOperator.java", "diffHunk": "@@ -227,7 +236,14 @@ public void addInput(Page page)\n \n         Block[] blocks = new Block[columnChannels.size()];\n         for (int outputChannel = 0; outputChannel < columnChannels.size(); outputChannel++) {\n-            blocks[outputChannel] = page.getBlock(columnChannels.get(outputChannel));\n+            Block block = page.getBlock(columnChannels.get(outputChannel));\n+            if (block.mayHaveNull()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1MDg2Nw==", "bodyText": "Doing a map lookup for every channel could have a non-trivial cost, especially since we have to box the channel integer key. I think it would be better to use a List<String> with null values for the nullable columns, making the lookup basically free.", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r443950867", "createdAt": "2020-06-23T04:13:28Z", "author": {"login": "electrum"}, "path": "presto-main/src/main/java/io/prestosql/operator/TableWriterOperator.java", "diffHunk": "@@ -227,7 +236,14 @@ public void addInput(Page page)\n \n         Block[] blocks = new Block[columnChannels.size()];\n         for (int outputChannel = 0; outputChannel < columnChannels.size(); outputChannel++) {\n-            blocks[outputChannel] = page.getBlock(columnChannels.get(outputChannel));\n+            Block block = page.getBlock(columnChannels.get(outputChannel));\n+            if (block.mayHaveNull()) {\n+                String columnName = notNullChannelColumnNames.get(outputChannel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1MTY4Mw==", "bodyText": "The block check logically fits better here\nif (!block.mayHaveNull()) {\n    return;\n}", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r443951683", "createdAt": "2020-06-23T04:16:50Z", "author": {"login": "electrum"}, "path": "presto-main/src/main/java/io/prestosql/operator/TableWriterOperator.java", "diffHunk": "@@ -243,6 +259,15 @@ public void addInput(Page page)\n         updateWrittenBytes();\n     }\n \n+    private void verifyBlockHasNoNulls(Block block, String columnName)\n+    {\n+        for (int position = 0; position < block.getPositionCount(); position++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1MzU0Mg==", "bodyText": "You can use toImmutableMap() from ImmutableMap. Also, I think this could simplify with a map call:\nMap<Integer, String> notNullChannelColumnNames = node.getColumns().stream()\n        .filter(symbol -> node.getNotNullColumnSymbols().contains(symbol))\n        .map(source::symbolToChannel)\n        .collect(toImmutableMap(identity(), node.getColumnNames()::get));", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r443953542", "createdAt": "2020-06-23T04:25:10Z", "author": {"login": "electrum"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -2334,12 +2334,17 @@ public PhysicalOperation visitTableWriter(TableWriterNode node, LocalExecutionPl\n                     .map(source::symbolToChannel)\n                     .collect(toImmutableList());\n \n+            Map<Integer, String> notNullChannelColumnNames = node.getColumns().stream()\n+                    .filter(symbol -> node.getNotNullColumnSymbols().contains(symbol))\n+                    .collect(Collectors.toMap(source::symbolToChannel, s -> node.getColumnNames().get(source.symbolToChannel(s))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1NTIyMQ==", "bodyText": "@martint The two callers of this method in this class fetch the columns names from table metadata. Are they wrong as well?", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r443955221", "createdAt": "2020-06-23T04:32:26Z", "author": {"login": "electrum"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LogicalPlanner.java", "diffHunk": "@@ -448,6 +453,18 @@ else if (isUsePreferredWritePartitioning(session)) {\n             }\n         }\n \n+        // TODO: Is this too fragile?  Other places we depend on the correspondence between order\n+        //  of non-hidden columns and order of symbols, but it feels a little grotty.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg0MzM4MQ=="}, "originalCommit": null, "originalPosition": 45}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NzEwNjc3", "url": "https://github.com/trinodb/trino/pull/4144#pullrequestreview-437710677", "createdAt": "2020-06-25T17:31:08Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNzozMTowOFrOGpExNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNzozMTowOFrOGpExNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyMjkzNA==", "bodyText": "Why use symbols here? Seems like it would be easier to have this be the column names", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r445722934", "createdAt": "2020-06-25T17:31:08Z", "author": {"login": "electrum"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/plan/TableWriterNode.java", "diffHunk": "@@ -61,6 +64,7 @@ public TableWriterNode(\n             @JsonProperty(\"fragmentSymbol\") Symbol fragmentSymbol,\n             @JsonProperty(\"columns\") List<Symbol> columns,\n             @JsonProperty(\"columnNames\") List<String> columnNames,\n+            @JsonProperty(\"notNullColumnSymbols\") Set<Symbol> notNullColumnSymbols,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4Mzk2NDM1", "url": "https://github.com/trinodb/trino/pull/4144#pullrequestreview-438396435", "createdAt": "2020-06-26T15:36:17Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NjcxMTU4", "url": "https://github.com/trinodb/trino/pull/4144#pullrequestreview-438671158", "createdAt": "2020-06-27T04:20:29Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwNDoyMDozMFrOGpzIRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwNDoyMDozMFrOGpzIRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ4MjUwMg==", "bodyText": "I'd just do this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .map(column -> requireNonNull(columnToSymbolMap.get(column.getName()), \"columnToSymbolMap is missing column \" + column.getName()))\n          \n          \n            \n                            .collect(Collectors.toSet());\n          \n          \n            \n                            .map(columnToSymbolMap::get)\n          \n          \n            \n                            .collect(toImmutableSet());\n          \n      \n    \n    \n  \n\nIt's more concise, and the immutable set will catch any nulls that might result from the lookup (which is a bug somewhere in the implementation, anyway)", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r446482502", "createdAt": "2020-06-27T04:20:30Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LogicalPlanner.java", "diffHunk": "@@ -448,11 +453,16 @@ else if (isUsePreferredWritePartitioning(session)) {\n             }\n         }\n \n-        if (!statisticsMetadata.isEmpty()) {\n-            verify(columnNames.size() == symbols.size(), \"columnNames.size() != symbols.size(): %s and %s\", columnNames, symbols);\n-            Map<String, Symbol> columnToSymbolMap = zip(columnNames.stream(), symbols.stream(), SimpleImmutableEntry::new)\n-                    .collect(toImmutableMap(Entry::getKey, Entry::getValue));\n+        verify(columnNames.size() == symbols.size(), \"columnNames.size() != symbols.size(): %s and %s\", columnNames, symbols);\n+        Map<String, Symbol> columnToSymbolMap = zip(columnNames.stream(), symbols.stream(), SimpleImmutableEntry::new)\n+                .collect(toImmutableMap(Entry::getKey, Entry::getValue));\n+\n+        Set<Symbol> notNullColumnSymbols = columnMetadataList.stream()\n+                .filter(column -> !column.isNullable())\n+                .map(column -> requireNonNull(columnToSymbolMap.get(column.getName()), \"columnToSymbolMap is missing column \" + column.getName()))\n+                .collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NjcyMTU1", "url": "https://github.com/trinodb/trino/pull/4144#pullrequestreview-438672155", "createdAt": "2020-06-27T04:40:44Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0674742fcfa59e9a21ab4aeadd7131a76dd6a735", "author": {"user": {"login": "djsstarburst", "name": "David Stryker"}}, "url": "https://github.com/trinodb/trino/commit/0674742fcfa59e9a21ab4aeadd7131a76dd6a735", "committedDate": "2020-06-27T14:17:03Z", "message": "Support enforcement of NOT NULL column declarations\n\nThis commit enforces NOT NULL column declarations on write\nin the Presto engine, so it applies to all connectors.  The\nexisting Postgres and Mysql tests named testInsertIntoNotNullColumn\nwere changed to check for the new error message, and a new test\nwith the same name was added to TestIcebergSmoke.\n\nOne possible concern with this commit is that the error message\nissued by the Presto engine when writing a null to a NOT NULL\ncolumn is a different message than the Connector might issue\nif no value was supplied for the NOT NULL column.  I think this\nis ok, because the error messages supplied by the Connectors are\ncompletely specific to the Connector."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "0674742fcfa59e9a21ab4aeadd7131a76dd6a735", "author": {"user": {"login": "djsstarburst", "name": "David Stryker"}}, "url": "https://github.com/trinodb/trino/commit/0674742fcfa59e9a21ab4aeadd7131a76dd6a735", "committedDate": "2020-06-27T14:17:03Z", "message": "Support enforcement of NOT NULL column declarations\n\nThis commit enforces NOT NULL column declarations on write\nin the Presto engine, so it applies to all connectors.  The\nexisting Postgres and Mysql tests named testInsertIntoNotNullColumn\nwere changed to check for the new error message, and a new test\nwith the same name was added to TestIcebergSmoke.\n\nOne possible concern with this commit is that the error message\nissued by the Presto engine when writing a null to a NOT NULL\ncolumn is a different message than the Connector might issue\nif no value was supplied for the NOT NULL column.  I think this\nis ok, because the error messages supplied by the Connectors are\ncompletely specific to the Connector."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 491, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}