{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyNTI2NDI0", "number": 2759, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwNzowODozNlrODeNNpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMToxMjoxOFrODjTNjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMDAwMzU2OnYy", "diffSide": "RIGHT", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwNzowODozNlrOFnPiJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTo0NTozNlrOFu5rww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY5MzI4NA==", "bodyText": "nit: use stream", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r376693284", "createdAt": "2020-02-08T07:08:36Z", "author": {"login": "vrozov"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "diffHunk": "@@ -49,16 +49,14 @@ private DomainConverter() {}\n         if (tupleDomain.isAll() || tupleDomain.isNone()) {\n             return tupleDomain;\n         }\n-        if (!tupleDomain.getDomains().isPresent()) {\n-            return tupleDomain;\n-        }\n \n         Map<IcebergColumnHandle, Domain> transformedMap = new HashMap<>();\n         tupleDomain.getDomains().get().forEach((column, domain) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc1NzQ4MQ==", "bodyText": "or use Maps.transformValues().", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r376757481", "createdAt": "2020-02-09T05:55:07Z", "author": {"login": "vrozov"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "diffHunk": "@@ -49,16 +49,14 @@ private DomainConverter() {}\n         if (tupleDomain.isAll() || tupleDomain.isNone()) {\n             return tupleDomain;\n         }\n-        if (!tupleDomain.getDomains().isPresent()) {\n-            return tupleDomain;\n-        }\n \n         Map<IcebergColumnHandle, Domain> transformedMap = new HashMap<>();\n         tupleDomain.getDomains().get().forEach((column, domain) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY5MzI4NA=="}, "originalCommit": null, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyMzkwNw==", "bodyText": "Agreed, using Maps.transformValues() here would avoid this error. But I'd do that refactoring separately, as a different commit.", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384723907", "createdAt": "2020-02-26T19:45:36Z", "author": {"login": "electrum"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "diffHunk": "@@ -49,16 +49,14 @@ private DomainConverter() {}\n         if (tupleDomain.isAll() || tupleDomain.isNone()) {\n             return tupleDomain;\n         }\n-        if (!tupleDomain.getDomains().isPresent()) {\n-            return tupleDomain;\n-        }\n \n         Map<IcebergColumnHandle, Domain> transformedMap = new HashMap<>();\n         tupleDomain.getDomains().get().forEach((column, domain) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY5MzI4NA=="}, "originalCommit": null, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMDAwMzc5OnYy", "diffSide": "RIGHT", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwNzowOTowM1rOFnPiQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTo0NDozMFrOFu5pHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY5MzMxMg==", "bodyText": "avoid System.out.", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r376693312", "createdAt": "2020-02-08T07:09:03Z", "author": {"login": "vrozov"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "diffHunk": "@@ -49,16 +49,14 @@ private DomainConverter() {}\n         if (tupleDomain.isAll() || tupleDomain.isNone()) {\n             return tupleDomain;\n         }\n-        if (!tupleDomain.getDomains().isPresent()) {\n-            return tupleDomain;\n-        }\n \n         Map<IcebergColumnHandle, Domain> transformedMap = new HashMap<>();\n         tupleDomain.getDomains().get().forEach((column, domain) -> {\n             ValueSet valueSet = domain.getValues();\n             ValueSet transformedValueSet = valueSet;\n             Type type = domain.getType();\n             if (type instanceof TimestampType || type instanceof TimestampWithTimeZoneType || type instanceof TimeType || type instanceof TimeWithTimeZoneType) {\n+                System.out.println(valueSet);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyMzIzMA==", "bodyText": "Yes, please remove", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384723230", "createdAt": "2020-02-26T19:44:30Z", "author": {"login": "electrum"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "diffHunk": "@@ -49,16 +49,14 @@ private DomainConverter() {}\n         if (tupleDomain.isAll() || tupleDomain.isNone()) {\n             return tupleDomain;\n         }\n-        if (!tupleDomain.getDomains().isPresent()) {\n-            return tupleDomain;\n-        }\n \n         Map<IcebergColumnHandle, Domain> transformedMap = new HashMap<>();\n         tupleDomain.getDomains().get().forEach((column, domain) -> {\n             ValueSet valueSet = domain.getValues();\n             ValueSet transformedValueSet = valueSet;\n             Type type = domain.getType();\n             if (type instanceof TimestampType || type instanceof TimestampWithTimeZoneType || type instanceof TimeType || type instanceof TimeWithTimeZoneType) {\n+                System.out.println(valueSet);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY5MzMxMg=="}, "originalCommit": null, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMDAwNjA4OnYy", "diffSide": "RIGHT", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergSplitSource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwNzoxNjoyMFrOFnPjdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo1MDoxNlrOFpffkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY5MzYyMA==", "bodyText": "There is no need to introduce a local variable, use predicate member variable.", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r376693620", "createdAt": "2020-02-08T07:16:20Z", "author": {"login": "vrozov"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergSplitSource.java", "diffHunk": "@@ -75,7 +74,7 @@ public IcebergSplitSource(\n     {\n         // TODO: move this to a background thread\n         List<ConnectorSplit> splits = new ArrayList<>();\n-        TupleDomain<IcebergColumnHandle> predicate = convertTupleDomainTypes(this.predicate);\n+        TupleDomain<IcebergColumnHandle> predicate = this.predicate;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA1MTkyMg==", "bodyText": "Please remove local variable.", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r379051922", "createdAt": "2020-02-13T18:50:16Z", "author": {"login": "vrozov"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergSplitSource.java", "diffHunk": "@@ -75,7 +74,7 @@ public IcebergSplitSource(\n     {\n         // TODO: move this to a background thread\n         List<ConnectorSplit> splits = new ArrayList<>();\n-        TupleDomain<IcebergColumnHandle> predicate = convertTupleDomainTypes(this.predicate);\n+        TupleDomain<IcebergColumnHandle> predicate = this.predicate;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY5MzYyMA=="}, "originalCommit": null, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTIxOTMyOnYy", "diffSide": "RIGHT", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo0NToxM1rOFpfVGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo0NToxM1rOFpfVGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA0OTI0Mg==", "bodyText": "nit: consider converting this to a static method for code readability.", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r379049242", "createdAt": "2020-02-13T18:45:13Z", "author": {"login": "vrozov"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "diffHunk": "@@ -49,46 +50,45 @@ private DomainConverter() {}\n         if (tupleDomain.isAll() || tupleDomain.isNone()) {\n             return tupleDomain;\n         }\n-        if (!tupleDomain.getDomains().isPresent()) {\n-            return tupleDomain;\n-        }\n \n         Map<IcebergColumnHandle, Domain> transformedMap = new HashMap<>();\n-        tupleDomain.getDomains().get().forEach((column, domain) -> {\n-            ValueSet valueSet = domain.getValues();\n-            ValueSet transformedValueSet = valueSet;\n-            Type type = domain.getType();\n-            if (type instanceof TimestampType || type instanceof TimestampWithTimeZoneType || type instanceof TimeType || type instanceof TimeWithTimeZoneType) {\n-                if (valueSet instanceof EquatableValueSet) {\n-                    EquatableValueSet equatableValueSet = (EquatableValueSet) valueSet;\n-                    Set<ValueEntry> values = equatableValueSet.getEntries().stream()\n-                            .map(value -> ValueEntry.create(value.getType(), convertToMicros(type, (long) value.getValue())))\n-                            .collect(toImmutableSet());\n-                    transformedValueSet = new EquatableValueSet(equatableValueSet.getType(), equatableValueSet.isWhiteList(), values);\n-                }\n-                else if (valueSet instanceof SortedRangeSet) {\n-                    List<Range> ranges = new ArrayList<>();\n-                    for (Range range : valueSet.getRanges().getOrderedRanges()) {\n-                        Marker low = range.getLow();\n-                        if (low.getValueBlock().isPresent()) {\n-                            Block value = nativeValueToBlock(type, convertToMicros(type, (long) range.getLow().getValue()));\n-                            low = new Marker(range.getType(), Optional.of(value), range.getLow().getBound());\n+        return TupleDomain.withColumnDomains(Maps.transformValues(\n+                tupleDomain.getDomains().get(),\n+                (domain) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTIyMzY0OnYy", "diffSide": "RIGHT", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo0NjozNlrOFpfX9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo0NjozNlrOFpfX9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA0OTk3NA==", "bodyText": "nit: introduction of transformedValueSet is not required, valueSet can be used instead.", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r379049974", "createdAt": "2020-02-13T18:46:36Z", "author": {"login": "vrozov"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "diffHunk": "@@ -49,46 +50,45 @@ private DomainConverter() {}\n         if (tupleDomain.isAll() || tupleDomain.isNone()) {\n             return tupleDomain;\n         }\n-        if (!tupleDomain.getDomains().isPresent()) {\n-            return tupleDomain;\n-        }\n \n         Map<IcebergColumnHandle, Domain> transformedMap = new HashMap<>();\n-        tupleDomain.getDomains().get().forEach((column, domain) -> {\n-            ValueSet valueSet = domain.getValues();\n-            ValueSet transformedValueSet = valueSet;\n-            Type type = domain.getType();\n-            if (type instanceof TimestampType || type instanceof TimestampWithTimeZoneType || type instanceof TimeType || type instanceof TimeWithTimeZoneType) {\n-                if (valueSet instanceof EquatableValueSet) {\n-                    EquatableValueSet equatableValueSet = (EquatableValueSet) valueSet;\n-                    Set<ValueEntry> values = equatableValueSet.getEntries().stream()\n-                            .map(value -> ValueEntry.create(value.getType(), convertToMicros(type, (long) value.getValue())))\n-                            .collect(toImmutableSet());\n-                    transformedValueSet = new EquatableValueSet(equatableValueSet.getType(), equatableValueSet.isWhiteList(), values);\n-                }\n-                else if (valueSet instanceof SortedRangeSet) {\n-                    List<Range> ranges = new ArrayList<>();\n-                    for (Range range : valueSet.getRanges().getOrderedRanges()) {\n-                        Marker low = range.getLow();\n-                        if (low.getValueBlock().isPresent()) {\n-                            Block value = nativeValueToBlock(type, convertToMicros(type, (long) range.getLow().getValue()));\n-                            low = new Marker(range.getType(), Optional.of(value), range.getLow().getBound());\n+        return TupleDomain.withColumnDomains(Maps.transformValues(\n+                tupleDomain.getDomains().get(),\n+                (domain) -> {\n+                    ValueSet valueSet = domain.getValues();\n+                    ValueSet transformedValueSet = valueSet;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTI0OTI1OnYy", "diffSide": "RIGHT", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergMetadata.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo1Mzo1NFrOFpfnrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo1Mzo1NFrOFpfnrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA1Mzk5OQ==", "bodyText": "Once iceberg supports IN predicate, it is not necessary to simplify(). Can you add TODO comment and explain why simplify() is necessary.", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r379053999", "createdAt": "2020-02-13T18:53:54Z", "author": {"login": "vrozov"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergMetadata.java", "diffHunk": "@@ -550,7 +550,11 @@ public void rollback()\n     public Optional<ConstraintApplicationResult<ConnectorTableHandle>> applyFilter(ConnectorSession session, ConnectorTableHandle handle, Constraint constraint)\n     {\n         IcebergTableHandle table = (IcebergTableHandle) handle;\n-        TupleDomain<IcebergColumnHandle> newDomain = convertTupleDomainTypes(constraint.getSummary().transform(IcebergColumnHandle.class::cast));\n+        TupleDomain<IcebergColumnHandle> newDomain = convertTupleDomainTypes(\n+                constraint.getSummary()\n+                        .transform(IcebergColumnHandle.class::cast)\n+                        .simplify())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODExNDg0OnYy", "diffSide": "RIGHT", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNTo0ODowMFrOFp7B1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNTo0ODowMFrOFp7B1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwMzA2Mw==", "bodyText": "It is better to avoid creating a new Domain object and return the original domain here.  It will also be more clear that  domain is not changed for the majority of Types.", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r379503063", "createdAt": "2020-02-14T15:48:00Z", "author": {"login": "vrozov"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "diffHunk": "@@ -49,46 +50,46 @@ private DomainConverter() {}\n         if (tupleDomain.isAll() || tupleDomain.isNone()) {\n             return tupleDomain;\n         }\n-        if (!tupleDomain.getDomains().isPresent()) {\n-            return tupleDomain;\n-        }\n \n         Map<IcebergColumnHandle, Domain> transformedMap = new HashMap<>();\n-        tupleDomain.getDomains().get().forEach((column, domain) -> {\n-            ValueSet valueSet = domain.getValues();\n-            ValueSet transformedValueSet = valueSet;\n-            Type type = domain.getType();\n-            if (type instanceof TimestampType || type instanceof TimestampWithTimeZoneType || type instanceof TimeType || type instanceof TimeWithTimeZoneType) {\n-                if (valueSet instanceof EquatableValueSet) {\n-                    EquatableValueSet equatableValueSet = (EquatableValueSet) valueSet;\n-                    Set<ValueEntry> values = equatableValueSet.getEntries().stream()\n-                            .map(value -> ValueEntry.create(value.getType(), convertToMicros(type, (long) value.getValue())))\n-                            .collect(toImmutableSet());\n-                    transformedValueSet = new EquatableValueSet(equatableValueSet.getType(), equatableValueSet.isWhiteList(), values);\n-                }\n-                else if (valueSet instanceof SortedRangeSet) {\n-                    List<Range> ranges = new ArrayList<>();\n-                    for (Range range : valueSet.getRanges().getOrderedRanges()) {\n-                        Marker low = range.getLow();\n-                        if (low.getValueBlock().isPresent()) {\n-                            Block value = nativeValueToBlock(type, convertToMicros(type, (long) range.getLow().getValue()));\n-                            low = new Marker(range.getType(), Optional.of(value), range.getLow().getBound());\n-                        }\n+        return TupleDomain.withColumnDomains(Maps.transformValues(\n+                tupleDomain.getDomains().get(),\n+                DomainConverter::translateDomain));\n+    }\n \n-                        Marker high = range.getHigh();\n-                        if (high.getValueBlock().isPresent()) {\n-                            Block value = nativeValueToBlock(type, convertToMicros(type, (long) range.getHigh().getValue()));\n-                            high = new Marker(range.getType(), Optional.of(value), range.getHigh().getBound());\n-                        }\n+    private static Domain translateDomain(Domain domain)\n+    {\n+        ValueSet valueSet = domain.getValues();\n+        Type type = domain.getType();\n+        if (type instanceof TimestampType || type instanceof TimestampWithTimeZoneType || type instanceof TimeType || type instanceof TimeWithTimeZoneType) {\n+            if (valueSet instanceof EquatableValueSet) {\n+                EquatableValueSet equatableValueSet = (EquatableValueSet) valueSet;\n+                Set<ValueEntry> values = equatableValueSet.getEntries().stream()\n+                        .map(value -> ValueEntry.create(value.getType(), convertToMicros(type, (long) value.getValue())))\n+                        .collect(toImmutableSet());\n+                valueSet = new EquatableValueSet(equatableValueSet.getType(), equatableValueSet.isWhiteList(), values);\n+            }\n+            else if (valueSet instanceof SortedRangeSet) {\n+                List<Range> ranges = new ArrayList<>();\n+                for (Range range : valueSet.getRanges().getOrderedRanges()) {\n+                    Marker low = range.getLow();\n+                    if (low.getValueBlock().isPresent()) {\n+                        Block value = nativeValueToBlock(type, convertToMicros(type, (long) range.getLow().getValue()));\n+                        low = new Marker(range.getType(), Optional.of(value), range.getLow().getBound());\n+                    }\n \n-                        ranges.add(new Range(low, high));\n+                    Marker high = range.getHigh();\n+                    if (high.getValueBlock().isPresent()) {\n+                        Block value = nativeValueToBlock(type, convertToMicros(type, (long) range.getHigh().getValue()));\n+                        high = new Marker(range.getType(), Optional.of(value), range.getHigh().getBound());\n                     }\n-                    transformedValueSet = SortedRangeSet.copyOf(valueSet.getType(), ranges);\n+\n+                    ranges.add(new Range(low, high));\n                 }\n-                transformedMap.put(column, Domain.create(transformedValueSet, domain.isNullAllowed()));\n+                valueSet = SortedRangeSet.copyOf(valueSet.getType(), ranges);\n             }\n-        });\n-        return TupleDomain.withColumnDomains(transformedMap);\n+        }\n+        return Domain.create(valueSet, domain.isNullAllowed());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjU0MjI1OnYy", "diffSide": "RIGHT", "path": "presto-iceberg/src/test/java/io/prestosql/plugin/iceberg/TestDomainConverter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTo0OTozOVrOFu50hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTo0OTozOVrOFu50hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyNjE0OA==", "bodyText": "For all of these where the expected and actual are identical, let's add a new method like assertTupleDomainUnchanged so we don't need to repeat the value.\nprivate void assertTupleDomainUnchanged(TupleDomain<IcebergColumnHandle> domain)\n{\n    assertTupleDomain(domain, domain);\n}\nThat will make it easier to spot the ones that are different.", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384726148", "createdAt": "2020-02-26T19:49:39Z", "author": {"login": "electrum"}, "path": "presto-iceberg/src/test/java/io/prestosql/plugin/iceberg/TestDomainConverter.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.iceberg;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slices;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.plugin.iceberg.DomainConverter.convertTupleDomainTypes;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.RealType.REAL;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimestampType.TIMESTAMP;\n+import static io.prestosql.spi.type.TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.VarbinaryType.VARBINARY;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestDomainConverter\n+{\n+    private static final Function<Type, IcebergColumnHandle> ICEBERG_COLUMN_PROVIDER = type -> new IcebergColumnHandle(0, \"column\", type, Optional.empty());\n+\n+    @Test\n+    public void testSimple()\n+    {\n+        assertTupleDomain(TupleDomain.all(), TupleDomain.all());\n+        assertTupleDomain(TupleDomain.all(), TupleDomain.all());\n+    }\n+\n+    @Test\n+    public void testBoolean()\n+    {\n+        assertTupleDomain(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjU1MTg1OnYy", "diffSide": "RIGHT", "path": "presto-iceberg/src/test/java/io/prestosql/plugin/iceberg/TestDomainConverter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTo1MjoxOFrOFu56NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTo1MjoxOFrOFu56NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyNzYwNA==", "bodyText": "It's cleaner to write these tests with a fixed timestamp like 1_234_567_890_123L", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384727604", "createdAt": "2020-02-26T19:52:18Z", "author": {"login": "electrum"}, "path": "presto-iceberg/src/test/java/io/prestosql/plugin/iceberg/TestDomainConverter.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.iceberg;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slices;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.plugin.iceberg.DomainConverter.convertTupleDomainTypes;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.RealType.REAL;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimestampType.TIMESTAMP;\n+import static io.prestosql.spi.type.TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.VarbinaryType.VARBINARY;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestDomainConverter\n+{\n+    private static final Function<Type, IcebergColumnHandle> ICEBERG_COLUMN_PROVIDER = type -> new IcebergColumnHandle(0, \"column\", type, Optional.empty());\n+\n+    @Test\n+    public void testSimple()\n+    {\n+        assertTupleDomain(TupleDomain.all(), TupleDomain.all());\n+        assertTupleDomain(TupleDomain.all(), TupleDomain.all());\n+    }\n+\n+    @Test\n+    public void testBoolean()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BOOLEAN), Domain.singleValue(BOOLEAN, true))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BOOLEAN), Domain.singleValue(BOOLEAN, true))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BOOLEAN), Domain.singleValue(BOOLEAN, false))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BOOLEAN), Domain.singleValue(BOOLEAN, false))));\n+    }\n+\n+    @Test\n+    public void testDate()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DATE), Domain.singleValue(DATE, 1L))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DATE), Domain.singleValue(DATE, 1L))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DATE), Domain.multipleValues(DATE, ImmutableList.of(1L, 2L, 3L)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DATE), Domain.multipleValues(DATE, ImmutableList.of(1L, 2L, 3L)))));\n+    }\n+\n+    @Test\n+    public void testVarbinary()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARBINARY), Domain.singleValue(VARBINARY, Slices.utf8Slice(\"apple\")))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARBINARY), Domain.singleValue(VARBINARY, Slices.utf8Slice(\"apple\")))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARBINARY), Domain.multipleValues(VARBINARY, ImmutableList.of(Slices.utf8Slice(\"apple\"), Slices.utf8Slice(\"banana\"))))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARBINARY), Domain.multipleValues(VARBINARY, ImmutableList.of(Slices.utf8Slice(\"apple\"), Slices.utf8Slice(\"banana\"))))));\n+    }\n+\n+    @Test\n+    public void testDouble()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DOUBLE), Domain.singleValue(DOUBLE, 1.0d))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DOUBLE), Domain.singleValue(DOUBLE, 1.0d))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DOUBLE), Domain.multipleValues(DOUBLE, ImmutableList.of(1.0d, 2.0d, 3.0d)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DOUBLE), Domain.multipleValues(DOUBLE, ImmutableList.of(1.0d, 2.0d, 3.0d)))));\n+    }\n+\n+    @Test\n+    public void testBigint()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.singleValue(BIGINT, 1L))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.singleValue(BIGINT, 1L))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L)))));\n+    }\n+\n+    @Test\n+    public void testReal()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(REAL), Domain.singleValue(REAL, 1L))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(REAL), Domain.singleValue(REAL, 1L))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(REAL), Domain.multipleValues(REAL, ImmutableList.of(1L, 2L, 3L)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(REAL), Domain.multipleValues(REAL, ImmutableList.of(1L, 2L, 3L)))));\n+    }\n+\n+    @Test\n+    public void testInteger()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.singleValue(INTEGER, 1L))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.singleValue(INTEGER, 1L))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.multipleValues(INTEGER, ImmutableList.of(1L, 2L, 3L)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.multipleValues(INTEGER, ImmutableList.of(1L, 2L, 3L)))));\n+    }\n+\n+    @Test\n+    public void testVarchar()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARCHAR), Domain.singleValue(VARCHAR, Slices.utf8Slice(\"apple\")))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARCHAR), Domain.singleValue(VARCHAR, Slices.utf8Slice(\"apple\")))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARCHAR), Domain.multipleValues(VARCHAR, ImmutableList.of(Slices.utf8Slice(\"apple\"), Slices.utf8Slice(\"banana\"))))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARCHAR), Domain.multipleValues(VARCHAR, ImmutableList.of(Slices.utf8Slice(\"apple\"), Slices.utf8Slice(\"banana\"))))));\n+    }\n+\n+    @Test\n+    public void testTimestamp()\n+    {\n+        long time = System.currentTimeMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjU1NTY3OnYy", "diffSide": "RIGHT", "path": "presto-iceberg/src/test/java/io/prestosql/plugin/iceberg/TestDomainConverter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTo1MzoxM1rOFu58cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTo1MzoxM1rOFu58cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyODE3Nw==", "bodyText": "After changing to a fixed timestamp, write the expected literals here, so the expected behavior is more obvious (and easier to tell there isn't a bug in the test code) 1_234_567_890_123_000L", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384728177", "createdAt": "2020-02-26T19:53:13Z", "author": {"login": "electrum"}, "path": "presto-iceberg/src/test/java/io/prestosql/plugin/iceberg/TestDomainConverter.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.iceberg;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slices;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.plugin.iceberg.DomainConverter.convertTupleDomainTypes;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.RealType.REAL;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimestampType.TIMESTAMP;\n+import static io.prestosql.spi.type.TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.VarbinaryType.VARBINARY;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestDomainConverter\n+{\n+    private static final Function<Type, IcebergColumnHandle> ICEBERG_COLUMN_PROVIDER = type -> new IcebergColumnHandle(0, \"column\", type, Optional.empty());\n+\n+    @Test\n+    public void testSimple()\n+    {\n+        assertTupleDomain(TupleDomain.all(), TupleDomain.all());\n+        assertTupleDomain(TupleDomain.all(), TupleDomain.all());\n+    }\n+\n+    @Test\n+    public void testBoolean()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BOOLEAN), Domain.singleValue(BOOLEAN, true))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BOOLEAN), Domain.singleValue(BOOLEAN, true))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BOOLEAN), Domain.singleValue(BOOLEAN, false))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BOOLEAN), Domain.singleValue(BOOLEAN, false))));\n+    }\n+\n+    @Test\n+    public void testDate()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DATE), Domain.singleValue(DATE, 1L))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DATE), Domain.singleValue(DATE, 1L))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DATE), Domain.multipleValues(DATE, ImmutableList.of(1L, 2L, 3L)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DATE), Domain.multipleValues(DATE, ImmutableList.of(1L, 2L, 3L)))));\n+    }\n+\n+    @Test\n+    public void testVarbinary()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARBINARY), Domain.singleValue(VARBINARY, Slices.utf8Slice(\"apple\")))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARBINARY), Domain.singleValue(VARBINARY, Slices.utf8Slice(\"apple\")))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARBINARY), Domain.multipleValues(VARBINARY, ImmutableList.of(Slices.utf8Slice(\"apple\"), Slices.utf8Slice(\"banana\"))))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARBINARY), Domain.multipleValues(VARBINARY, ImmutableList.of(Slices.utf8Slice(\"apple\"), Slices.utf8Slice(\"banana\"))))));\n+    }\n+\n+    @Test\n+    public void testDouble()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DOUBLE), Domain.singleValue(DOUBLE, 1.0d))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DOUBLE), Domain.singleValue(DOUBLE, 1.0d))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DOUBLE), Domain.multipleValues(DOUBLE, ImmutableList.of(1.0d, 2.0d, 3.0d)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DOUBLE), Domain.multipleValues(DOUBLE, ImmutableList.of(1.0d, 2.0d, 3.0d)))));\n+    }\n+\n+    @Test\n+    public void testBigint()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.singleValue(BIGINT, 1L))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.singleValue(BIGINT, 1L))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L)))));\n+    }\n+\n+    @Test\n+    public void testReal()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(REAL), Domain.singleValue(REAL, 1L))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(REAL), Domain.singleValue(REAL, 1L))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(REAL), Domain.multipleValues(REAL, ImmutableList.of(1L, 2L, 3L)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(REAL), Domain.multipleValues(REAL, ImmutableList.of(1L, 2L, 3L)))));\n+    }\n+\n+    @Test\n+    public void testInteger()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.singleValue(INTEGER, 1L))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.singleValue(INTEGER, 1L))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.multipleValues(INTEGER, ImmutableList.of(1L, 2L, 3L)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.multipleValues(INTEGER, ImmutableList.of(1L, 2L, 3L)))));\n+    }\n+\n+    @Test\n+    public void testVarchar()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARCHAR), Domain.singleValue(VARCHAR, Slices.utf8Slice(\"apple\")))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARCHAR), Domain.singleValue(VARCHAR, Slices.utf8Slice(\"apple\")))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARCHAR), Domain.multipleValues(VARCHAR, ImmutableList.of(Slices.utf8Slice(\"apple\"), Slices.utf8Slice(\"banana\"))))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARCHAR), Domain.multipleValues(VARCHAR, ImmutableList.of(Slices.utf8Slice(\"apple\"), Slices.utf8Slice(\"banana\"))))));\n+    }\n+\n+    @Test\n+    public void testTimestamp()\n+    {\n+        long time = System.currentTimeMillis();\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(TIMESTAMP), Domain.singleValue(TIMESTAMP, time))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(TIMESTAMP), Domain.singleValue(TIMESTAMP, MILLISECONDS.toMicros(time)))));\n+\n+        List<Long> list = ImmutableList.of(System.currentTimeMillis(), System.currentTimeMillis() - 1000);\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(TIMESTAMP), Domain.multipleValues(TIMESTAMP, list))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(TIMESTAMP), Domain.multipleValues(TIMESTAMP, list.stream().map(MILLISECONDS::toMicros).collect(toImmutableList())))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjU2NDI1OnYy", "diffSide": "RIGHT", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTo1NToxMlrOFu6BSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTo1NToxMlrOFu6BSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyOTQxNw==", "bodyText": "Can you move this refactoring to a separate commit? It's hard to tell if this is simply a refactor or is introducing changes to the logic", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384729417", "createdAt": "2020-02-26T19:55:12Z", "author": {"login": "electrum"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "diffHunk": "@@ -51,45 +52,45 @@ private DomainConverter() {}\n         }\n \n         Map<IcebergColumnHandle, Domain> transformedMap = new HashMap<>();\n-        tupleDomain.getDomains().get().forEach((column, domain) -> {\n-            ValueSet valueSet = domain.getValues();\n-            ValueSet transformedValueSet = valueSet;\n-            Type type = domain.getType();\n-            if (type instanceof TimestampType || type instanceof TimestampWithTimeZoneType || type instanceof TimeType || type instanceof TimeWithTimeZoneType) {\n-                System.out.println(valueSet);\n-                if (valueSet instanceof EquatableValueSet) {\n-                    EquatableValueSet equatableValueSet = (EquatableValueSet) valueSet;\n-                    Set<ValueEntry> values = equatableValueSet.getEntries().stream()\n-                            .map(value -> ValueEntry.create(value.getType(), convertToMicros(type, (long) value.getValue())))\n-                            .collect(toImmutableSet());\n-                    transformedValueSet = new EquatableValueSet(equatableValueSet.getType(), equatableValueSet.isWhiteList(), values);\n-                }\n-                else if (valueSet instanceof SortedRangeSet) {\n-                    List<Range> ranges = new ArrayList<>();\n-                    for (Range range : valueSet.getRanges().getOrderedRanges()) {\n-                        Marker low = range.getLow();\n-                        if (low.getValueBlock().isPresent()) {\n-                            Block value = nativeValueToBlock(type, convertToMicros(type, (long) range.getLow().getValue()));\n-                            low = new Marker(range.getType(), Optional.of(value), range.getLow().getBound());\n-                        }\n+        return TupleDomain.withColumnDomains(Maps.transformValues(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjU4MDIxOnYy", "diffSide": "RIGHT", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergMetadata.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTo1OTo0MFrOFu6LAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMVQxNDoyNDozOVrOFwObMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMTkwNg==", "bodyText": "I don't understand this. simplify() reduces the number of ranges, but can still have multiple ranges. If Iceberg doesn't support IN expressions at all, how does this work?", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384731906", "createdAt": "2020-02-26T19:59:40Z", "author": {"login": "electrum"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergMetadata.java", "diffHunk": "@@ -550,7 +550,12 @@ public void rollback()\n     public Optional<ConstraintApplicationResult<ConnectorTableHandle>> applyFilter(ConnectorSession session, ConnectorTableHandle handle, Constraint constraint)\n     {\n         IcebergTableHandle table = (IcebergTableHandle) handle;\n-        TupleDomain<IcebergColumnHandle> newDomain = convertTupleDomainTypes(constraint.getSummary().transform(IcebergColumnHandle.class::cast));\n+        // TODO: Remove TupleDomain#simplify once Iceberg supports IN expression", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMjc2MQ==", "bodyText": "Also, is this related to removing the extra convert call in IcebergSplitSource?", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384732761", "createdAt": "2020-02-26T20:01:16Z", "author": {"login": "electrum"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergMetadata.java", "diffHunk": "@@ -550,7 +550,12 @@ public void rollback()\n     public Optional<ConstraintApplicationResult<ConnectorTableHandle>> applyFilter(ConnectorSession session, ConnectorTableHandle handle, Constraint constraint)\n     {\n         IcebergTableHandle table = (IcebergTableHandle) handle;\n-        TupleDomain<IcebergColumnHandle> newDomain = convertTupleDomainTypes(constraint.getSummary().transform(IcebergColumnHandle.class::cast));\n+        // TODO: Remove TupleDomain#simplify once Iceberg supports IN expression", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMTkwNg=="}, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2MzkyMA==", "bodyText": "As Iceberg does not support IN, it is converted to multiple OR in ExpressionConverter and with a large number of values in the IN set, it causes stack overflow when Iceberg tries to evaluate deeply nested OR.", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384863920", "createdAt": "2020-02-27T01:21:14Z", "author": {"login": "vrozov"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergMetadata.java", "diffHunk": "@@ -550,7 +550,12 @@ public void rollback()\n     public Optional<ConstraintApplicationResult<ConnectorTableHandle>> applyFilter(ConnectorSession session, ConnectorTableHandle handle, Constraint constraint)\n     {\n         IcebergTableHandle table = (IcebergTableHandle) handle;\n-        TupleDomain<IcebergColumnHandle> newDomain = convertTupleDomainTypes(constraint.getSummary().transform(IcebergColumnHandle.class::cast));\n+        // TODO: Remove TupleDomain#simplify once Iceberg supports IN expression", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMTkwNg=="}, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjExMjMwNQ==", "bodyText": "Actually Iceberg converts it to OR expression but when iceberg logs that translated expression then it throws stack overflow expression.", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r386112305", "createdAt": "2020-03-01T14:24:39Z", "author": {"login": "Praveen2112"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergMetadata.java", "diffHunk": "@@ -550,7 +550,12 @@ public void rollback()\n     public Optional<ConstraintApplicationResult<ConnectorTableHandle>> applyFilter(ConnectorSession session, ConnectorTableHandle handle, Constraint constraint)\n     {\n         IcebergTableHandle table = (IcebergTableHandle) handle;\n-        TupleDomain<IcebergColumnHandle> newDomain = convertTupleDomainTypes(constraint.getSummary().transform(IcebergColumnHandle.class::cast));\n+        // TODO: Remove TupleDomain#simplify once Iceberg supports IN expression", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMTkwNg=="}, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MzQxNTE5OnYy", "diffSide": "RIGHT", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/ExpressionConverter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMToxMjoxOFrOFvCFZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMToxMjoxOFrOFvCFZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2MTU0Mg==", "bodyText": "The newer version of Iceberg will allow Long->Date conversion, so conversion to int won't be necessary. Please see apache/iceberg@eb9c75e.", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384861542", "createdAt": "2020-02-27T01:12:18Z", "author": {"login": "vrozov"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/ExpressionConverter.java", "diffHunk": "@@ -174,6 +176,10 @@ private static Object getValue(Type type, Marker marker, ConnectorSession sessio\n             return MILLISECONDS.toMicros((Long) marker.getValue());\n         }\n \n+        if (type instanceof DateType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 883, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}