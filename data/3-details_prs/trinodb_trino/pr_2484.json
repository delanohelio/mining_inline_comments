{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyMDA4NTI0", "number": 2484, "title": "Allow overriding required workers and required workers max wait time through system session properties", "bodyText": "Added required_workers and required_workers_max_wait session properties.\nModified waitForMinimumWorkers to avoid waiting for more than 1 node for set session statements and queries on system and information schema connectors.\nModified ClusterSizeMonitor to support waiting on different number of nodes for each query.\nModified DistributedQueryRunner to support adding nodes in tests.", "createdAt": "2020-01-13T09:13:55Z", "url": "https://github.com/trinodb/trino/pull/2484", "merged": true, "mergeCommit": {"oid": "f8a14e1e42e050be1147f6f983661277d7155358"}, "closed": true, "closedAt": "2020-01-27T10:50:26Z", "author": {"login": "raunaqmorarka"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb55DbqgBqjI5NDI0Mzc2MDI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb-ZaetgFqTM0ODUyODk0NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MDUyNzI1", "url": "https://github.com/trinodb/trino/pull/2484#pullrequestreview-347052725", "createdAt": "2020-01-23T04:29:50Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwNDoyOTo1MFrOFgyjjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwNToyNDoyNVrOFgzL0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkyNzA1NQ==", "bodyText": "My understanding of this method is used to determine if the execution needs workers.  For example, DDL commands do not need any workers.  In that case, I would expect if we don't need to wait for workers, we simply call startExecution(queryExecution).  So this code would become something like:\naddSuccessCallback(queryExecutionFuture, queryExecution -> {\n    if (queryExecution.shouldWaitForMinWorkers()) {\n        startExecution(queryExecution);\n    }\n    ListenableFuture<?> minimumWorkerFuture = clusterSizeMonitor.waitForMinimumWorkers(getRequiredWorkers(session), getRequiredWorkersMaxWait(session));\n    // when worker requirement is met, start the execution\n    addSuccessCallback(minimumWorkerFuture, () -> startExecution(queryExecution));\n    addExceptionCallback(minimumWorkerFuture, throwable -> queryExecutor.execute(() -> stateMachine.transitionToFailed(throwable)));\n});", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r369927055", "createdAt": "2020-01-23T04:29:50Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/dispatcher/LocalDispatchQuery.java", "diffHunk": "@@ -93,10 +95,18 @@ public void startWaitingForResources()\n \n     private void waitForMinimumWorkers()\n     {\n-        ListenableFuture<?> minimumWorkerFuture = clusterSizeMonitor.waitForMinimumWorkers();\n-        // when worker requirement is met, wait for query execution to finish construction and then start the execution\n-        addSuccessCallback(minimumWorkerFuture, () -> addSuccessCallback(queryExecutionFuture, this::startExecution));\n-        addExceptionCallback(minimumWorkerFuture, throwable -> queryExecutor.execute(() -> stateMachine.transitionToFailed(throwable)));\n+        // wait for query execution to finish construction\n+        addSuccessCallback(queryExecutionFuture, queryExecution -> {\n+            Session session = stateMachine.getSession();\n+            int executionMinCount = 1; // always wait for 1 node to be up\n+            if (queryExecution.shouldWaitForMinWorkers()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzMTE0NA==", "bodyText": "I'm not sure about the implications of this matcher rule.  I'd like to hear from @martint and @david on this part.", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r369931144", "createdAt": "2020-01-23T04:57:09Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/execution/SqlQueryExecution.java", "diffHunk": "@@ -599,6 +602,27 @@ private QueryInfo buildQueryInfo(SqlQueryScheduler scheduler)\n         return queryInfo;\n     }\n \n+    @Override\n+    public boolean shouldWaitForMinWorkers()\n+    {\n+        return shouldWaitForMinWorkers(analysis.getStatement());\n+    }\n+\n+    private boolean shouldWaitForMinWorkers(Statement statement)\n+    {\n+        if (statement instanceof Query) {\n+            // Allow set session statements and queries on internal system connectors to run without waiting\n+            Collection<TableHandle> tables = analysis.getTables();\n+            if (tables.isEmpty()) {\n+                return false;\n+            }\n+            return !tables.stream()\n+                    .map(TableHandle::getCatalogName)\n+                    .allMatch(CatalogName::isInternalSystemConnector);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzMTQ1Nw==", "bodyText": "I believe that pure explain (not analyze queries) shouldn't wait either.", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r369931457", "createdAt": "2020-01-23T04:59:06Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/execution/SqlQueryExecution.java", "diffHunk": "@@ -599,6 +602,27 @@ private QueryInfo buildQueryInfo(SqlQueryScheduler scheduler)\n         return queryInfo;\n     }\n \n+    @Override\n+    public boolean shouldWaitForMinWorkers()\n+    {\n+        return shouldWaitForMinWorkers(analysis.getStatement());\n+    }\n+\n+    private boolean shouldWaitForMinWorkers(Statement statement)\n+    {\n+        if (statement instanceof Query) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzNDY4OQ==", "bodyText": "supplyAsync uses the ForkJoinPool.commonPool() which is not managed, so we do not use this method.   Instead, we have the tests create an executor, directly managed the executions, and shutdown the pool.", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r369934689", "createdAt": "2020-01-23T05:12:05Z", "author": {"login": "dain"}, "path": "presto-testing/src/main/java/io/prestosql/testing/DistributedQueryRunner.java", "diffHunk": "@@ -380,6 +410,11 @@ public MaterializedResult execute(Session session, @Language(\"SQL\") String sql)\n         }\n     }\n \n+    public CompletableFuture<ResultWithQueryId<MaterializedResult>> executeAsync(Session session, @Language(\"SQL\") String sql)\n+    {\n+        return supplyAsync(() -> executeWithQueryId(session, sql));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzNTYwNQ==", "bodyText": "Also, we only use ComputableFuture in the SPI because it is built in the JVM and does not require a library dependency.  For main Presto we use Guava's ListenableFuture framework because it is easier to understand making our code more readable.  Please switch to that framework.", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r369935605", "createdAt": "2020-01-23T05:14:26Z", "author": {"login": "dain"}, "path": "presto-testing/src/main/java/io/prestosql/testing/DistributedQueryRunner.java", "diffHunk": "@@ -380,6 +410,11 @@ public MaterializedResult execute(Session session, @Language(\"SQL\") String sql)\n         }\n     }\n \n+    public CompletableFuture<ResultWithQueryId<MaterializedResult>> executeAsync(Session session, @Language(\"SQL\") String sql)\n+    {\n+        return supplyAsync(() -> executeWithQueryId(session, sql));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzNDY4OQ=="}, "originalCommit": null, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzNzM2Mw==", "bodyText": "Lets name these: required_workers_count and required_workers_max_wait_time", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r369937363", "createdAt": "2020-01-23T05:24:25Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/SystemSessionProperties.java", "diffHunk": "@@ -125,6 +125,8 @@\n     public static final String DYNAMIC_FILTERING_MAX_PER_DRIVER_ROW_COUNT = \"dynamic_filtering_max_per_driver_row_count\";\n     public static final String DYNAMIC_FILTERING_MAX_PER_DRIVER_SIZE = \"dynamic_filtering_max_per_driver_size\";\n     public static final String IGNORE_DOWNSTREAM_PREFERENCES = \"ignore_downstream_preferences\";\n+    public static final String REQUIRED_WORKERS = \"required_workers\";\n+    public static final String REQUIRED_WORKERS_MAX_WAIT = \"required_workers_max_wait\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MTc5MDc1", "url": "https://github.com/trinodb/trino/pull/2484#pullrequestreview-348179075", "createdAt": "2020-01-24T19:36:02Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxOTozNjowMlrOFhoSsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxOTozNjowMlrOFhoSsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNzQ3Mg==", "bodyText": "There is a much simpler way to do the background work:\nListeningExecutorService queryExecutor = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(1));\n\nListenableFuture<ResultWithQueryId<MaterializedResult>> queryFuture1 = service.submit(() -> queryRunner.executeWithQueryId(session,  \"SELECT COUNT(*) from lineitem\"));\n\nWith that code, we no longer need the new executeAsync on DistributedQueryRunner.\nBTW. The Guava site has excellent documentation on ListenableFuture usage: https://github.com/google/guava/wiki/ListenableFutureExplained#creation", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r370807472", "createdAt": "2020-01-24T19:36:02Z", "author": {"login": "dain"}, "path": "presto-tests/src/test/java/io/prestosql/tests/TestMinWorkerRequirement.java", "diffHunk": "@@ -69,18 +107,136 @@ public void testInsufficientWorkerNodesAfterDrop()\n                         .build())\n                 .setNodeCount(4)\n                 .build()) {\n-            queryRunner.execute(\"SELECT 1\");\n+            queryRunner.execute(\"SELECT COUNT(*) from lineitem\");\n             assertEquals(queryRunner.getCoordinator().refreshNodes().getActiveNodes().size(), 4);\n \n             try {\n-                // Query should still be allowed to run if active workers drop down below the minimum required nodes\n+                // Query should not be allowed to run if active workers drop down below the minimum required nodes\n                 queryRunner.getServers().get(0).close();\n                 assertEquals(queryRunner.getCoordinator().refreshNodes().getActiveNodes().size(), 3);\n-                queryRunner.execute(\"SELECT 1\");\n+                queryRunner.execute(\"SELECT COUNT(*) from lineitem\");\n+                fail(\"Expected exception due to insufficient active worker nodes\");\n             }\n             catch (RuntimeException e) {\n                 assertEquals(e.getMessage(), \"Insufficient active worker nodes. Waited 1.00ns for at least 4 workers, but only 3 workers are active\");\n             }\n         }\n     }\n+\n+    @Test(expectedExceptions = RuntimeException.class, expectedExceptionsMessageRegExp = \"Insufficient active worker nodes. Waited 99.00ns for at least 3 workers, but only 2 workers are active\")\n+    public void testRequiredNodesMaxWaitSessionOverride()\n+            throws Exception\n+    {\n+        try (DistributedQueryRunner queryRunner = TpchQueryRunnerBuilder.builder()\n+                .setCoordinatorProperties(ImmutableMap.<String, String>builder()\n+                        .put(\"query-manager.required-workers\", \"3\")\n+                        .put(\"query-manager.required-workers-max-wait\", \"1ns\")\n+                        .build())\n+                .setNodeCount(2)\n+                .build()) {\n+            Session session = testSessionBuilder()\n+                    .setSystemProperty(REQUIRED_WORKERS_COUNT, \"3\")\n+                    .setSystemProperty(REQUIRED_WORKERS_MAX_WAIT_TIME, \"99ns\")\n+                    .setCatalog(\"tpch\")\n+                    .setSchema(\"tiny\")\n+                    .build();\n+            queryRunner.execute(session, \"SELECT COUNT(*) from lineitem\");\n+            fail(\"Expected exception due to insufficient active worker nodes\");\n+        }\n+    }\n+\n+    @Test\n+    public void testRequiredWorkerNodesSessionOverride()\n+            throws Exception\n+    {\n+        try (DistributedQueryRunner queryRunner = TpchQueryRunnerBuilder.builder()\n+                .setCoordinatorProperties(ImmutableMap.<String, String>builder()\n+                        .put(\"query-manager.required-workers\", \"5\")\n+                        .put(\"query-manager.required-workers-max-wait\", \"1ns\")\n+                        .build())\n+                .setNodeCount(4)\n+                .build()) {\n+            // Query should be allowed to run if session override allows it\n+            Session session = testSessionBuilder()\n+                    .setSystemProperty(REQUIRED_WORKERS_COUNT, \"4\")\n+                    .setCatalog(\"tpch\")\n+                    .setSchema(\"tiny\")\n+                    .build();\n+            queryRunner.execute(session, \"SELECT COUNT(*) from lineitem\");\n+\n+            // Query should not be allowed to run because we are 2 nodes short of requirement\n+            session = Session.builder(session)\n+                    .setSystemProperty(REQUIRED_WORKERS_COUNT, \"6\")\n+                    .build();\n+            try {\n+                queryRunner.execute(session, \"SELECT COUNT(*) from lineitem\");\n+                fail(\"Expected exception due to insufficient active worker nodes\");\n+            }\n+            catch (RuntimeException e) {\n+                assertEquals(e.getMessage(), \"Insufficient active worker nodes. Waited 1.00ns for at least 6 workers, but only 4 workers are active\");\n+            }\n+\n+            // After adding 2 nodes, query should run\n+            queryRunner.addServers(2);\n+            assertEquals(queryRunner.getCoordinator().refreshNodes().getActiveNodes().size(), 6);\n+            queryRunner.execute(session, \"SELECT COUNT(*) from lineitem\");\n+        }\n+    }\n+\n+    @Test\n+    public void testMultipleRequiredWorkerNodesSessionOverride()\n+            throws Exception\n+    {\n+        ExecutorService queryExecutor = newFixedThreadPool(3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 159}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MjkzNjg1", "url": "https://github.com/trinodb/trino/pull/2484#pullrequestreview-348293685", "createdAt": "2020-01-25T00:40:27Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwMDo0MDoyN1rOFhtzMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwMDo0MDoyN1rOFhtzMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg5NzcxMw==", "bodyText": "@dain I noticed that minimumWorkerFuture is not cancelled if user cancels the query, ClusterSizeMonitor keeps reporting requirement of the cancelled query.\nWould it be correct to add below code here to handle that ?\nstateMachine.addStateChangeListener(state -> {\n    if (state.isDone()) {\n        minimumWorkerFuture.cancel(true);\n    }\n});", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r370897713", "createdAt": "2020-01-25T00:40:27Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/dispatcher/LocalDispatchQuery.java", "diffHunk": "@@ -93,10 +95,18 @@ public void startWaitingForResources()\n \n     private void waitForMinimumWorkers()\n     {\n-        ListenableFuture<?> minimumWorkerFuture = clusterSizeMonitor.waitForMinimumWorkers();\n-        // when worker requirement is met, wait for query execution to finish construction and then start the execution\n-        addSuccessCallback(minimumWorkerFuture, () -> addSuccessCallback(queryExecutionFuture, this::startExecution));\n-        addExceptionCallback(minimumWorkerFuture, throwable -> queryExecutor.execute(() -> stateMachine.transitionToFailed(throwable)));\n+        // wait for query execution to finish construction\n+        addSuccessCallback(queryExecutionFuture, queryExecution -> {\n+            Session session = stateMachine.getSession();\n+            int executionMinCount = 1; // always wait for 1 node to be up\n+            if (queryExecution.shouldWaitForMinWorkers()) {\n+                executionMinCount = getRequiredWorkers(session);\n+            }\n+            ListenableFuture<?> minimumWorkerFuture = clusterSizeMonitor.waitForMinimumWorkers(executionMinCount, getRequiredWorkersMaxWait(session));\n+            // when worker requirement is met, start the execution\n+            addSuccessCallback(minimumWorkerFuture, () -> startExecution(queryExecution));\n+            addExceptionCallback(minimumWorkerFuture, throwable -> queryExecutor.execute(() -> stateMachine.transitionToFailed(throwable)));\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "da1cfa352f4d9fe45dfb0b8e647da61033f78080", "author": {"user": {"login": "raunaqmorarka", "name": "Raunaq Morarka"}}, "url": "https://github.com/trinodb/trino/commit/da1cfa352f4d9fe45dfb0b8e647da61033f78080", "committedDate": "2020-01-27T09:10:24Z", "message": "Allow overriding required workers and required workers max wait time through system session properties"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "da1cfa352f4d9fe45dfb0b8e647da61033f78080", "author": {"user": {"login": "raunaqmorarka", "name": "Raunaq Morarka"}}, "url": "https://github.com/trinodb/trino/commit/da1cfa352f4d9fe45dfb0b8e647da61033f78080", "committedDate": "2020-01-27T09:10:24Z", "message": "Allow overriding required workers and required workers max wait time through system session properties"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4NTI4OTQ1", "url": "https://github.com/trinodb/trino/pull/2484#pullrequestreview-348528945", "createdAt": "2020-01-27T09:34:08Z", "commit": {"oid": "da1cfa352f4d9fe45dfb0b8e647da61033f78080"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QwOTozNDowOFrOFh8W7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QwOTozNDowOFrOFh8W7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEzNjIzOA==", "bodyText": "Oh yes you are correct", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r371136238", "createdAt": "2020-01-27T09:34:08Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/dispatcher/LocalDispatchQuery.java", "diffHunk": "@@ -93,10 +95,18 @@ public void startWaitingForResources()\n \n     private void waitForMinimumWorkers()\n     {\n-        ListenableFuture<?> minimumWorkerFuture = clusterSizeMonitor.waitForMinimumWorkers();\n-        // when worker requirement is met, wait for query execution to finish construction and then start the execution\n-        addSuccessCallback(minimumWorkerFuture, () -> addSuccessCallback(queryExecutionFuture, this::startExecution));\n-        addExceptionCallback(minimumWorkerFuture, throwable -> queryExecutor.execute(() -> stateMachine.transitionToFailed(throwable)));\n+        // wait for query execution to finish construction\n+        addSuccessCallback(queryExecutionFuture, queryExecution -> {\n+            Session session = stateMachine.getSession();\n+            int executionMinCount = 1; // always wait for 1 node to be up\n+            if (queryExecution.shouldWaitForMinWorkers()) {\n+                executionMinCount = getRequiredWorkers(session);\n+            }\n+            ListenableFuture<?> minimumWorkerFuture = clusterSizeMonitor.waitForMinimumWorkers(executionMinCount, getRequiredWorkersMaxWait(session));\n+            // when worker requirement is met, start the execution\n+            addSuccessCallback(minimumWorkerFuture, () -> startExecution(queryExecution));\n+            addExceptionCallback(minimumWorkerFuture, throwable -> queryExecutor.execute(() -> stateMachine.transitionToFailed(throwable)));\n+        });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg5NzcxMw=="}, "originalCommit": null, "originalPosition": 28}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 836, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}