{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4MTUwNDI0", "number": 2654, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMToyMzowNFrODbbQtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMToyNDo0M1rODbbR2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDg0Nzg4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneApplyColumns.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMToyMzowNFrOFi6C2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMToyMzowNFrOFi6C2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE0NjkwNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ImmutableList<Symbol> newCorrelation = applyNode.getCorrelation().stream()\n          \n          \n            \n                    List<Symbol> newCorrelation = applyNode.getCorrelation().stream()", "url": "https://github.com/trinodb/trino/pull/2654#discussion_r372146904", "createdAt": "2020-01-29T01:23:04Z", "author": {"login": "Praveen2112"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneApplyColumns.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.plan.ApplyNode;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.tree.Expression;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.intersection;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractUnique;\n+import static io.prestosql.sql.planner.iterative.rule.Util.restrictOutputs;\n+import static io.prestosql.sql.planner.plan.Patterns.applyNode;\n+\n+/**\n+ * This rule restricts the outputs of ApplyNode's input and subquery\n+ * based on which ApplyNode's output symbols are referenced.\n+ * <p>\n+ * A symbol from input source can be pruned, when\n+ * - it is not a referenced output symbol\n+ * - it is not a correlation symbol\n+ * - it is not referenced in subqueryAssignments\n+ * <p>\n+ * A symbol from subquery source can be pruned, when\n+ * it is not referenced in subqueryAssignments.\n+ * <p>\n+ * A subquery assignment can be removed, when\n+ * its key is not a referenced output symbol.\n+ * <p>\n+ * A symbol can be removed from the correlation list, when\n+ * it is no longer present in the subquery.\n+ * <p>\n+ * Note: this rule does not remove any symbols from the subquery.\n+ * However, the correlated symbol might have been removed from\n+ * the subquery by another rule. This rule checks it so that it can\n+ * update the correlation list and take the advantage of\n+ * pruning the symbol if it is not referenced.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - Project (i1, r1)\n+ *      - Apply\n+ *          correlation: [corr]\n+ *          assignments:\n+ *              r1 -> a in s1,\n+ *              r2 -> b in s2,\n+ *          - Input (a, b, corr)\n+ *          - Subquery (s1, s2)\n+ * </pre>\n+ * Into:\n+ * <pre>\n+ * - Project (i1, r1)\n+ *      - Apply\n+ *          correlation: []\n+ *          assignments:\n+ *              r1 -> a in s1,\n+ *          - Project (a)\n+ *              - Input (a, b, corr)\n+ *          - Project (s1)\n+ *              - Subquery (s1, s2)\n+ * </pre>\n+ */\n+public class PruneApplyColumns\n+        extends ProjectOffPushDownRule<ApplyNode>\n+{\n+    public PruneApplyColumns()\n+    {\n+        super(applyNode());\n+    }\n+\n+    @Override\n+    protected Optional<PlanNode> pushDownProjectOff(\n+            Context context,\n+            ApplyNode applyNode,\n+            Set<Symbol> referencedOutputs)\n+    {\n+        // remove unused apply node\n+        if (intersection(applyNode.getSubqueryAssignments().getSymbols(), referencedOutputs).isEmpty()) {\n+            return Optional.of(applyNode.getInput());\n+        }\n+\n+        // extract referenced assignments\n+        ImmutableSet.Builder<Symbol> requiredSubquerySymbols = ImmutableSet.builder();\n+        Assignments.Builder newSubqueryAssignments = Assignments.builder();\n+        for (Map.Entry<Symbol, Expression> entry : applyNode.getSubqueryAssignments().entrySet()) {\n+            if (referencedOutputs.contains(entry.getKey())) {\n+                requiredSubquerySymbols.addAll(extractUnique(entry.getValue()));\n+                newSubqueryAssignments.put(entry);\n+            }\n+        }\n+\n+        // prune subquery symbols\n+        Optional<PlanNode> newSubquery = restrictOutputs(context.getIdAllocator(), applyNode.getSubquery(), requiredSubquerySymbols.build());\n+\n+        // extract actual correlation symbols\n+        ImmutableList<Symbol> newCorrelation = applyNode.getCorrelation().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDg1MDgzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneApplyColumns.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMToyNDo0M1rOFi6Eig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMToyNDo0M1rOFi6Eig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE0NzMzOA==", "bodyText": "Can we extract the Unique symbols once and check it ?", "url": "https://github.com/trinodb/trino/pull/2654#discussion_r372147338", "createdAt": "2020-01-29T01:24:43Z", "author": {"login": "Praveen2112"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneApplyColumns.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.plan.ApplyNode;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.tree.Expression;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.intersection;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractUnique;\n+import static io.prestosql.sql.planner.iterative.rule.Util.restrictOutputs;\n+import static io.prestosql.sql.planner.plan.Patterns.applyNode;\n+\n+/**\n+ * This rule restricts the outputs of ApplyNode's input and subquery\n+ * based on which ApplyNode's output symbols are referenced.\n+ * <p>\n+ * A symbol from input source can be pruned, when\n+ * - it is not a referenced output symbol\n+ * - it is not a correlation symbol\n+ * - it is not referenced in subqueryAssignments\n+ * <p>\n+ * A symbol from subquery source can be pruned, when\n+ * it is not referenced in subqueryAssignments.\n+ * <p>\n+ * A subquery assignment can be removed, when\n+ * its key is not a referenced output symbol.\n+ * <p>\n+ * A symbol can be removed from the correlation list, when\n+ * it is no longer present in the subquery.\n+ * <p>\n+ * Note: this rule does not remove any symbols from the subquery.\n+ * However, the correlated symbol might have been removed from\n+ * the subquery by another rule. This rule checks it so that it can\n+ * update the correlation list and take the advantage of\n+ * pruning the symbol if it is not referenced.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - Project (i1, r1)\n+ *      - Apply\n+ *          correlation: [corr]\n+ *          assignments:\n+ *              r1 -> a in s1,\n+ *              r2 -> b in s2,\n+ *          - Input (a, b, corr)\n+ *          - Subquery (s1, s2)\n+ * </pre>\n+ * Into:\n+ * <pre>\n+ * - Project (i1, r1)\n+ *      - Apply\n+ *          correlation: []\n+ *          assignments:\n+ *              r1 -> a in s1,\n+ *          - Project (a)\n+ *              - Input (a, b, corr)\n+ *          - Project (s1)\n+ *              - Subquery (s1, s2)\n+ * </pre>\n+ */\n+public class PruneApplyColumns\n+        extends ProjectOffPushDownRule<ApplyNode>\n+{\n+    public PruneApplyColumns()\n+    {\n+        super(applyNode());\n+    }\n+\n+    @Override\n+    protected Optional<PlanNode> pushDownProjectOff(\n+            Context context,\n+            ApplyNode applyNode,\n+            Set<Symbol> referencedOutputs)\n+    {\n+        // remove unused apply node\n+        if (intersection(applyNode.getSubqueryAssignments().getSymbols(), referencedOutputs).isEmpty()) {\n+            return Optional.of(applyNode.getInput());\n+        }\n+\n+        // extract referenced assignments\n+        ImmutableSet.Builder<Symbol> requiredSubquerySymbols = ImmutableSet.builder();\n+        Assignments.Builder newSubqueryAssignments = Assignments.builder();\n+        for (Map.Entry<Symbol, Expression> entry : applyNode.getSubqueryAssignments().entrySet()) {\n+            if (referencedOutputs.contains(entry.getKey())) {\n+                requiredSubquerySymbols.addAll(extractUnique(entry.getValue()));\n+                newSubqueryAssignments.put(entry);\n+            }\n+        }\n+\n+        // prune subquery symbols\n+        Optional<PlanNode> newSubquery = restrictOutputs(context.getIdAllocator(), applyNode.getSubquery(), requiredSubquerySymbols.build());\n+\n+        // extract actual correlation symbols\n+        ImmutableList<Symbol> newCorrelation = applyNode.getCorrelation().stream()\n+                .filter(symbol -> extractUnique(newSubquery.orElse(applyNode.getSubquery()), context.getLookup()).contains(symbol))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 116}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 963, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}