{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgzMTI1OTEx", "number": 5124, "title": "Add support for precision for TIMESTAMP in Postgresql type mapping", "bodyText": "Replaces #4570", "createdAt": "2020-09-09T20:44:19Z", "url": "https://github.com/trinodb/trino/pull/5124", "merged": true, "mergeCommit": {"oid": "be2b97a8480f657f311e673fa38867c8faf4e2df"}, "closed": true, "closedAt": "2020-09-10T12:17:03Z", "author": {"login": "losipiuk"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdHSaASAH2gAyNDgzMTI1OTExOjVhNmEwN2ViZjg1YTA1YTYyYzE3ZmQ4MTY0ZjNiNzYzZjc3Y2ZhYzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdHd5NBABqjM3NTAxMzMyNjQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5a6a07ebf85a05a62c17fd8164f3b763f77cfac6", "author": {"user": {"login": "kokosing", "name": "Grzegorz Kokosi\u0144ski"}}, "url": "https://github.com/trinodb/trino/commit/5a6a07ebf85a05a62c17fd8164f3b763f77cfac6", "committedDate": "2020-09-09T20:41:24Z", "message": "Remove redundant cast"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65fd8511eebe81d937b926ff6919ef10f93d6a23", "author": {"user": {"login": "kokosing", "name": "Grzegorz Kokosi\u0144ski"}}, "url": "https://github.com/trinodb/trino/commit/65fd8511eebe81d937b926ff6919ef10f93d6a23", "committedDate": "2020-09-09T20:41:24Z", "message": "Do not use raw parametrized type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12c690670d8d0274a58a34b0878a0fb3ab228b4d", "author": {"user": {"login": "kokosing", "name": "Grzegorz Kokosi\u0144ski"}}, "url": "https://github.com/trinodb/trino/commit/12c690670d8d0274a58a34b0878a0fb3ab228b4d", "committedDate": "2020-09-09T20:41:24Z", "message": "Remove not needed annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "631f5aad0c932829f1c8a43a04e38068ebe8544c", "author": {"user": {"login": "kokosing", "name": "Grzegorz Kokosi\u0144ski"}}, "url": "https://github.com/trinodb/trino/commit/631f5aad0c932829f1c8a43a04e38068ebe8544c", "committedDate": "2020-09-09T20:42:02Z", "message": "Rename method paremeter to express its meaning"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1Njc3Nzc0", "url": "https://github.com/trinodb/trino/pull/5124#pullrequestreview-485677774", "createdAt": "2020-09-10T08:02:24Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODowMjoyNVrOHPn1Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODoyMDoyOFrOHPohbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0MzI5OQ==", "bodyText": "I would rather drop this commit.\nThe added burden of an overload is not justified for arguably small benefit this brings.", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486143299", "createdAt": "2020-09-10T08:02:25Z", "author": {"login": "findepi"}, "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/PostgreSqlQueryRunner.java", "diffHunk": "@@ -49,11 +49,23 @@ public static DistributedQueryRunner createPostgreSqlQueryRunner(\n             Map<String, String> connectorProperties,\n             Iterable<TpchTable<?>> tables)\n             throws Exception\n+    {\n+        return createPostgreSqlQueryRunner(server, extraProperties, connectorProperties, tables, 3);\n+    }\n+\n+    public static DistributedQueryRunner createPostgreSqlQueryRunner(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0Mzk1OA==", "bodyText": "The cmt title is\n\nRename misleading testTimestampWithTimeZoneDataProvider\n\nit's removal not \"rename\"\n\"misleading\" is misleading. It was very nicely called \"DataProvider\", i do not find anything misleading in that and next time would call it the same.", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486143958", "createdAt": "2020-09-10T08:03:31Z", "author": {"login": "findepi"}, "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1199,15 +1200,6 @@ public void testArrayTimestampWithTimeZone(boolean insertWithPresto)\n         tests.execute(getQueryRunner(), sessionWithArrayAsArray(), dataSetup);\n     }\n \n-    @DataProvider\n-    public Object[][] testTimestampWithTimeZoneDataProvider()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0ODE5MQ==", "bodyText": "if timestampType.precision < 6, you need to round/truncate here\n@martint what is the correct way to do this?\nthere are some utility methods in io.prestosql.spi.type.Timestamps, but I do not see something that's immediately applicable.", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486148191", "createdAt": "2020-09-10T08:09:59Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -382,24 +397,34 @@ public static LongReadFunction timestampReadFunction()\n      * {@link #timestampWriteFunction} instead.\n      */\n     @Deprecated\n-    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp()\n+    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(value)));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(timestampType, value)));\n     }\n \n-    public static LongWriteFunction timestampWriteFunction()\n+    public static LongWriteFunction timestampWriteFunction(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(value));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(timestampType, value));\n     }\n \n-    public static long toPrestoTimestamp(LocalDateTime localDateTime)\n+    public static long toPrestoTimestamp(TimestampType timestampType, LocalDateTime localDateTime)\n     {\n-        return localDateTime.atZone(UTC).toInstant().toEpochMilli() * MICROSECONDS_PER_MILLISECOND;\n+        long precision = timestampType.getPrecision();\n+        checkArgument(precision <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", precision);\n+        Instant instant = localDateTime.atZone(UTC).toInstant();\n+        return instant.getEpochSecond() * MICROSECONDS_PER_SECOND + roundDiv(instant.getNano(), NANOSECONDS_PER_MICROSECOND);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0ODc1MA==", "bodyText": "You do not really need to validate this here. If someone provided epochMicros, it;'s all you need.", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486148750", "createdAt": "2020-09-10T08:10:54Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -382,24 +397,34 @@ public static LongReadFunction timestampReadFunction()\n      * {@link #timestampWriteFunction} instead.\n      */\n     @Deprecated\n-    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp()\n+    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(value)));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(timestampType, value)));\n     }\n \n-    public static LongWriteFunction timestampWriteFunction()\n+    public static LongWriteFunction timestampWriteFunction(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(value));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(timestampType, value));\n     }\n \n-    public static long toPrestoTimestamp(LocalDateTime localDateTime)\n+    public static long toPrestoTimestamp(TimestampType timestampType, LocalDateTime localDateTime)\n     {\n-        return localDateTime.atZone(UTC).toInstant().toEpochMilli() * MICROSECONDS_PER_MILLISECOND;\n+        long precision = timestampType.getPrecision();\n+        checkArgument(precision <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", precision);\n+        Instant instant = localDateTime.atZone(UTC).toInstant();\n+        return instant.getEpochSecond() * MICROSECONDS_PER_SECOND + roundDiv(instant.getNano(), NANOSECONDS_PER_MICROSECOND);\n     }\n \n-    public static LocalDateTime fromPrestoTimestamp(long value)\n+    public static LocalDateTime fromPrestoTimestamp(TimestampType timestampType, long epochMicros)\n     {\n-        return Instant.ofEpochMilli(floorDiv(value, MICROSECONDS_PER_MILLISECOND)).atZone(UTC).toLocalDateTime();\n+        int precision = timestampType.getPrecision();\n+        checkArgument(precision <= MAX_SHORT_PRECISION && precision >= 0, \"Precision is out of range: %s\", precision);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1MDE5MQ==", "bodyText": "we could unify & reuse with io.prestosql.spi.type.Timestamps#formatTimestamp(int precision, long epochMicros, int picosOfMicro)", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486150191", "createdAt": "2020-09-10T08:13:14Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -382,24 +397,34 @@ public static LongReadFunction timestampReadFunction()\n      * {@link #timestampWriteFunction} instead.\n      */\n     @Deprecated\n-    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp()\n+    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(value)));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(timestampType, value)));\n     }\n \n-    public static LongWriteFunction timestampWriteFunction()\n+    public static LongWriteFunction timestampWriteFunction(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(value));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(timestampType, value));\n     }\n \n-    public static long toPrestoTimestamp(LocalDateTime localDateTime)\n+    public static long toPrestoTimestamp(TimestampType timestampType, LocalDateTime localDateTime)\n     {\n-        return localDateTime.atZone(UTC).toInstant().toEpochMilli() * MICROSECONDS_PER_MILLISECOND;\n+        long precision = timestampType.getPrecision();\n+        checkArgument(precision <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", precision);\n+        Instant instant = localDateTime.atZone(UTC).toInstant();\n+        return instant.getEpochSecond() * MICROSECONDS_PER_SECOND + roundDiv(instant.getNano(), NANOSECONDS_PER_MICROSECOND);\n     }\n \n-    public static LocalDateTime fromPrestoTimestamp(long value)\n+    public static LocalDateTime fromPrestoTimestamp(TimestampType timestampType, long epochMicros)\n     {\n-        return Instant.ofEpochMilli(floorDiv(value, MICROSECONDS_PER_MILLISECOND)).atZone(UTC).toLocalDateTime();\n+        int precision = timestampType.getPrecision();\n+        checkArgument(precision <= MAX_SHORT_PRECISION && precision >= 0, \"Precision is out of range: %s\", precision);\n+        long epochSecond = floorDiv(epochMicros, MICROSECONDS_PER_SECOND);\n+        int nanoFraction = floorMod(epochMicros, MICROSECONDS_PER_SECOND) * NANOSECONDS_PER_MICROSECOND;\n+        Instant instant = Instant.ofEpochSecond(epochSecond, nanoFraction);\n+        return LocalDateTime.ofInstant(instant, UTC);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1MDU0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return WriteMapping.longMapping(\"datetime\", timestampWriteFunctionUsingSqlTimestamp(TIMESTAMP));\n          \n          \n            \n                        return WriteMapping.longMapping(\"datetime\", timestampWriteFunctionUsingSqlTimestamp(TIMESTAMP_MILLIS));", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486150544", "createdAt": "2020-09-10T08:13:48Z", "author": {"login": "findepi"}, "path": "presto-mysql/src/main/java/io/prestosql/plugin/mysql/MySqlClient.java", "diffHunk": "@@ -262,7 +262,7 @@ public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n         }\n         if (TIMESTAMP_MILLIS.equals(type)) {\n             // TODO use `timestampWriteFunction`\n-            return WriteMapping.longMapping(\"datetime\", timestampWriteFunctionUsingSqlTimestamp());\n+            return WriteMapping.longMapping(\"datetime\", timestampWriteFunctionUsingSqlTimestamp(TIMESTAMP));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1MzI1Mg==", "bodyText": "\"TIMESTAMP WITH TIME ZONE\"\nalso, is 3 and 6 actually different cases?\ni think in timestamp case, we go with the same code path\n(ok to leave the test coverage, but if true, change the commnt)", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486153252", "createdAt": "2020-09-10T08:18:15Z", "author": {"login": "findepi"}, "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1005,24 +1005,38 @@ public void testTime(boolean insertWithPresto, ZoneId sessionZone)\n     @Test(dataProvider = \"testTimestampDataProvider\")\n     public void testTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     {\n-        // using two non-JVM zones so that we don't need to worry what Postgres system zone is\n-        DataTypeTest tests = DataTypeTest.create(true)\n-                .addRoundTrip(timestampDataType(), beforeEpoch)\n-                .addRoundTrip(timestampDataType(), afterEpoch)\n-                .addRoundTrip(timestampDataType(), timeDoubledInJvmZone)\n-                .addRoundTrip(timestampDataType(), timeDoubledInVilnius)\n-                .addRoundTrip(timestampDataType(), epoch) // epoch also is a gap in JVM zone\n-                .addRoundTrip(timestampDataType(), timeGapInJvmZone1)\n-                .addRoundTrip(timestampDataType(), timeGapInJvmZone2)\n-                .addRoundTrip(timestampDataType(), timeGapInVilnius)\n-                .addRoundTrip(timestampDataType(), timeGapInKathmandu);\n+        DataTypeTest tests = DataTypeTest.create(true);\n+        for (int precision : List.of(3, 6)) {\n+            // test all standard cases with precision 3 and 6 to make sure the long and short TIMESTAMP WITH TIME ZONE", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1NDYwNw==", "bodyText": "this belong to Simplify flow in timestamp with timezone mapping tests commit?", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486154607", "createdAt": "2020-09-10T08:20:28Z", "author": {"login": "findepi"}, "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1032,32 +1046,50 @@ public void testTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     @Test(dataProvider = \"testTimestampDataProvider\")\n     public void testArrayTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     {\n-        DataType<List<LocalDateTime>> dataType;\n-        DataSetup dataSetup;\n-        if (insertWithPresto) {\n-            dataType = arrayDataType(timestampDataType());\n-            dataSetup = prestoCreateAsSelect(sessionWithArrayAsArray(), \"test_array_timestamp\");\n-        }\n-        else {\n-            dataType = arrayDataType(timestampDataType(), \"timestamp[]\");\n-            dataSetup = postgresCreateAndInsert(\"tpch.test_array_timestamp\");\n+        DataTypeTest tests = DataTypeTest.create(true);\n+        for (int precision : List.of(3, 6)) {\n+            // test all standard cases with precision 3 and 6 to make sure the long and short TIMESTAMP WITH TIME ZONE\n+            // is gap friendly.\n+            DataType<List<LocalDateTime>> dataType = arrayOfTimestampDataType(precision, insertWithPresto);\n+            tests.addRoundTrip(dataType, asList(beforeEpoch));\n+            tests.addRoundTrip(dataType, asList(afterEpoch));\n+            tests.addRoundTrip(dataType, asList(timeDoubledInJvmZone));\n+            tests.addRoundTrip(dataType, asList(timeDoubledInVilnius));\n+            tests.addRoundTrip(dataType, asList(epoch));\n+            tests.addRoundTrip(dataType, asList(timeGapInJvmZone1));\n+            tests.addRoundTrip(dataType, asList(timeGapInJvmZone2));\n+            tests.addRoundTrip(dataType, asList(timeGapInVilnius));\n+            tests.addRoundTrip(dataType, asList(timeGapInKathmandu));\n         }\n-        DataTypeTest tests = DataTypeTest.create(true)\n-                .addRoundTrip(dataType, asList(beforeEpoch))\n-                .addRoundTrip(dataType, asList(afterEpoch))\n-                .addRoundTrip(dataType, asList(timeDoubledInJvmZone))\n-                .addRoundTrip(dataType, asList(timeDoubledInVilnius))\n-                .addRoundTrip(dataType, asList(epoch))\n-                .addRoundTrip(dataType, asList(timeGapInJvmZone1))\n-                .addRoundTrip(dataType, asList(timeGapInJvmZone2))\n-                .addRoundTrip(dataType, asList(timeGapInVilnius))\n-                .addRoundTrip(dataType, asList(timeGapInKathmandu));\n+\n+        // test arbitrary time for all supported precisions\n+        tests.addRoundTrip(arrayOfTimestampDataType(1, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 100_000_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(2, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 120_000_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(3, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_000_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(4, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_400_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(5, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_450_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(6, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_456_000)));\n \n         Session session = Session.builder(sessionWithArrayAsArray())\n                 .setTimeZoneKey(TimeZoneKey.getTimeZoneKey(sessionZone.getId()))\n                 .build();\n \n-        tests.execute(getQueryRunner(), session, dataSetup);\n+        if (insertWithPresto) {\n+            tests.execute(getQueryRunner(), session, prestoCreateAsSelect(sessionWithArrayAsArray(), \"test_array_timestamp\"));\n+        }\n+        else {\n+            tests.execute(getQueryRunner(), session, postgresCreateAndInsert(\"tpch.test_array_timestamp\"));\n+        }\n+    }\n+\n+    private DataType<List<LocalDateTime>> arrayOfTimestampDataType(int precision, boolean insertWithPresto)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 131}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b58796e1fcc17adaaa722e8bf9a9a10cfdf7cc3", "author": {"user": {"login": "kokosing", "name": "Grzegorz Kokosi\u0144ski"}}, "url": "https://github.com/trinodb/trino/commit/7b58796e1fcc17adaaa722e8bf9a9a10cfdf7cc3", "committedDate": "2020-09-10T09:16:02Z", "message": "Use generic trueFalse data provider for timestamp tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "570a5699e1046cd7772ca46611688307ce50adff", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/570a5699e1046cd7772ca46611688307ce50adff", "committedDate": "2020-09-10T09:16:27Z", "message": "Simplify flow in timestamp with timezone mapping tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91875da84e897aacb2c9aac09b0fe885745606b8", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/91875da84e897aacb2c9aac09b0fe885745606b8", "committedDate": "2020-09-10T09:16:27Z", "message": "Inline addArrayTimestampTestIfSupported"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7fdfe30707ab52826fdb1b177dde2d989497d5e", "author": {"user": {"login": "kokosing", "name": "Grzegorz Kokosi\u0144ski"}}, "url": "https://github.com/trinodb/trino/commit/e7fdfe30707ab52826fdb1b177dde2d989497d5e", "committedDate": "2020-09-10T09:42:49Z", "message": "Add support for precision for TIMESTAMP in PostgreSQL type mapping\n\nAdd support for mapping TIMESTAMP from Presto to\nPostgreSQL (and vice versa) for precisions 1 to 6. It covers all\nprecisions currently supported by PostgreSQL."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NzU3ODA2", "url": "https://github.com/trinodb/trino/pull/5124#pullrequestreview-485757806", "createdAt": "2020-09-10T09:37:39Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOTozNzozOVrOHPreFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOTo0NjoxMFrOHPrypg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIwMjkwMw==", "bodyText": "no. This is specific to TIMESTAMP not TIMESTAMP w/TZ. So it belongs to last commit.", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486202903", "createdAt": "2020-09-10T09:37:39Z", "author": {"login": "losipiuk"}, "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1032,32 +1046,50 @@ public void testTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     @Test(dataProvider = \"testTimestampDataProvider\")\n     public void testArrayTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     {\n-        DataType<List<LocalDateTime>> dataType;\n-        DataSetup dataSetup;\n-        if (insertWithPresto) {\n-            dataType = arrayDataType(timestampDataType());\n-            dataSetup = prestoCreateAsSelect(sessionWithArrayAsArray(), \"test_array_timestamp\");\n-        }\n-        else {\n-            dataType = arrayDataType(timestampDataType(), \"timestamp[]\");\n-            dataSetup = postgresCreateAndInsert(\"tpch.test_array_timestamp\");\n+        DataTypeTest tests = DataTypeTest.create(true);\n+        for (int precision : List.of(3, 6)) {\n+            // test all standard cases with precision 3 and 6 to make sure the long and short TIMESTAMP WITH TIME ZONE\n+            // is gap friendly.\n+            DataType<List<LocalDateTime>> dataType = arrayOfTimestampDataType(precision, insertWithPresto);\n+            tests.addRoundTrip(dataType, asList(beforeEpoch));\n+            tests.addRoundTrip(dataType, asList(afterEpoch));\n+            tests.addRoundTrip(dataType, asList(timeDoubledInJvmZone));\n+            tests.addRoundTrip(dataType, asList(timeDoubledInVilnius));\n+            tests.addRoundTrip(dataType, asList(epoch));\n+            tests.addRoundTrip(dataType, asList(timeGapInJvmZone1));\n+            tests.addRoundTrip(dataType, asList(timeGapInJvmZone2));\n+            tests.addRoundTrip(dataType, asList(timeGapInVilnius));\n+            tests.addRoundTrip(dataType, asList(timeGapInKathmandu));\n         }\n-        DataTypeTest tests = DataTypeTest.create(true)\n-                .addRoundTrip(dataType, asList(beforeEpoch))\n-                .addRoundTrip(dataType, asList(afterEpoch))\n-                .addRoundTrip(dataType, asList(timeDoubledInJvmZone))\n-                .addRoundTrip(dataType, asList(timeDoubledInVilnius))\n-                .addRoundTrip(dataType, asList(epoch))\n-                .addRoundTrip(dataType, asList(timeGapInJvmZone1))\n-                .addRoundTrip(dataType, asList(timeGapInJvmZone2))\n-                .addRoundTrip(dataType, asList(timeGapInVilnius))\n-                .addRoundTrip(dataType, asList(timeGapInKathmandu));\n+\n+        // test arbitrary time for all supported precisions\n+        tests.addRoundTrip(arrayOfTimestampDataType(1, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 100_000_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(2, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 120_000_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(3, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_000_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(4, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_400_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(5, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_450_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(6, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_456_000)));\n \n         Session session = Session.builder(sessionWithArrayAsArray())\n                 .setTimeZoneKey(TimeZoneKey.getTimeZoneKey(sessionZone.getId()))\n                 .build();\n \n-        tests.execute(getQueryRunner(), session, dataSetup);\n+        if (insertWithPresto) {\n+            tests.execute(getQueryRunner(), session, prestoCreateAsSelect(sessionWithArrayAsArray(), \"test_array_timestamp\"));\n+        }\n+        else {\n+            tests.execute(getQueryRunner(), session, postgresCreateAndInsert(\"tpch.test_array_timestamp\"));\n+        }\n+    }\n+\n+    private DataType<List<LocalDateTime>> arrayOfTimestampDataType(int precision, boolean insertWithPresto)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1NDYwNw=="}, "originalCommit": null, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIwMzI1MA==", "bodyText": "I will drop this for. As representation is same for 3 and 6 for TIMESTAMP", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486203250", "createdAt": "2020-09-10T09:38:19Z", "author": {"login": "losipiuk"}, "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1032,32 +1046,50 @@ public void testTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     @Test(dataProvider = \"testTimestampDataProvider\")\n     public void testArrayTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     {\n-        DataType<List<LocalDateTime>> dataType;\n-        DataSetup dataSetup;\n-        if (insertWithPresto) {\n-            dataType = arrayDataType(timestampDataType());\n-            dataSetup = prestoCreateAsSelect(sessionWithArrayAsArray(), \"test_array_timestamp\");\n-        }\n-        else {\n-            dataType = arrayDataType(timestampDataType(), \"timestamp[]\");\n-            dataSetup = postgresCreateAndInsert(\"tpch.test_array_timestamp\");\n+        DataTypeTest tests = DataTypeTest.create(true);\n+        for (int precision : List.of(3, 6)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIwODE2Ng==", "bodyText": "Oh - you noticed it too - yeah - it same case. I dropped the coverage.", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486208166", "createdAt": "2020-09-10T09:46:10Z", "author": {"login": "losipiuk"}, "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1005,24 +1005,38 @@ public void testTime(boolean insertWithPresto, ZoneId sessionZone)\n     @Test(dataProvider = \"testTimestampDataProvider\")\n     public void testTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     {\n-        // using two non-JVM zones so that we don't need to worry what Postgres system zone is\n-        DataTypeTest tests = DataTypeTest.create(true)\n-                .addRoundTrip(timestampDataType(), beforeEpoch)\n-                .addRoundTrip(timestampDataType(), afterEpoch)\n-                .addRoundTrip(timestampDataType(), timeDoubledInJvmZone)\n-                .addRoundTrip(timestampDataType(), timeDoubledInVilnius)\n-                .addRoundTrip(timestampDataType(), epoch) // epoch also is a gap in JVM zone\n-                .addRoundTrip(timestampDataType(), timeGapInJvmZone1)\n-                .addRoundTrip(timestampDataType(), timeGapInJvmZone2)\n-                .addRoundTrip(timestampDataType(), timeGapInVilnius)\n-                .addRoundTrip(timestampDataType(), timeGapInKathmandu);\n+        DataTypeTest tests = DataTypeTest.create(true);\n+        for (int precision : List.of(3, 6)) {\n+            // test all standard cases with precision 3 and 6 to make sure the long and short TIMESTAMP WITH TIME ZONE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1MzI1Mg=="}, "originalCommit": null, "originalPosition": 37}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "e7fdfe30707ab52826fdb1b177dde2d989497d5e", "author": {"user": {"login": "kokosing", "name": "Grzegorz Kokosi\u0144ski"}}, "url": "https://github.com/trinodb/trino/commit/e7fdfe30707ab52826fdb1b177dde2d989497d5e", "committedDate": "2020-09-10T09:42:49Z", "message": "Add support for precision for TIMESTAMP in PostgreSQL type mapping\n\nAdd support for mapping TIMESTAMP from Presto to\nPostgreSQL (and vice versa) for precisions 1 to 6. It covers all\nprecisions currently supported by PostgreSQL."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3942, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}