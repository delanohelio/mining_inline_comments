{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxNzU1MDEx", "number": 6192, "title": "Support WINDOW clause", "bodyText": "Fixes #651", "createdAt": "2020-12-03T12:49:50Z", "url": "https://github.com/trinodb/trino/pull/6192", "merged": true, "mergeCommit": {"oid": "8436c957c3a270c786bac65d20679f4966bacd4f"}, "closed": true, "closedAt": "2021-01-26T23:32:54Z", "author": {"login": "kasiafi"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdijdP0gBqjQwNjc1OTAwNjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd0CAAjgBqjQyNTI3MTg5ODA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MzcxMzQx", "url": "https://github.com/trinodb/trino/pull/6192#pullrequestreview-545371341", "createdAt": "2020-12-05T00:02:14Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMDowMjoxNFrOH_mfdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMDowMjoxNFrOH_mfdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ1Mjk4MQ==", "bodyText": "I think we need to do the following:\n\nRename Window to Over. Over would have an Expression and a Window as children.\nWindow becomes an interface which could be either a WindowReference that contains an Identifier or a WindowSpecification. WindowSpecification would contain existingWindowName, partitionBy, orderBy and frame.\nWindowDefinition would contain an Identifier (the name) and a WiindowSpecification.\n\nSo,\nclass Over\n    Expression expression\n    Window window\n\ninterface Window\n\nclass WindowReference implements Window\n    Identifier name\n\nclass WindowSpecification implements Window\n    Identifier existingWindowName\n    List<Expression> partitionBy\n    Expression orderBy\n    WindowFrame frame\n\nclass WindowDefinition\n    Identifier name\n    WindowSpecification specification", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r536452981", "createdAt": "2020-12-05T00:02:14Z", "author": {"login": "martint"}, "path": "presto-parser/src/main/java/io/prestosql/sql/tree/Window.java", "diffHunk": "@@ -20,33 +20,55 @@\n import java.util.Optional;\n \n import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n public class Window\n         extends Node\n {\n+    private final Optional<Identifier> existingWindowName;\n+    private final boolean specification;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 11}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4NzM1MjA0", "url": "https://github.com/trinodb/trino/pull/6192#pullrequestreview-568735204", "createdAt": "2021-01-15T00:32:20Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDozMjoyMFrOIT8sLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMToxMzoyNlrOIT9elA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODIwNw==", "bodyText": "I don't think this is necessary. The cast below will produce a similar message if it can't be performed.", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557788207", "createdAt": "2021-01-15T00:32:20Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -970,7 +972,14 @@ protected Type visitNullLiteral(NullLiteral node, StackableAstVisitorContext<Con\n         protected Type visitFunctionCall(FunctionCall node, StackableAstVisitorContext<Context> context)\n         {\n             if (node.getWindow().isPresent()) {\n-                Window window = node.getWindow().get();\n+                Window windowReferenceOrSpecification = node.getWindow().get();\n+\n+                if (windowReferenceOrSpecification instanceof WindowReference || windowReferenceOrSpecification instanceof WindowSpecification && ((WindowSpecification) windowReferenceOrSpecification).getExistingWindowName().isPresent()) {\n+                    throw semanticException(NOT_SUPPORTED, (Node) windowReferenceOrSpecification, \"Reference to other window definition is not yet supported\");\n+                }\n+\n+                checkState(windowReferenceOrSpecification instanceof WindowSpecification, \"unexpected window: \" + windowReferenceOrSpecification.getClass().getSimpleName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODU5Mw==", "bodyText": "Same here. This check is unnecessary, as the cast below will fail with a similar error if it can't be performed.", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557788593", "createdAt": "2021-01-15T00:33:47Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1975,7 +1981,12 @@ private void analyzeWindowFunctions(QuerySpecification node, List<Expression> ou\n                     throw semanticException(NOT_SUPPORTED, windowFunction, \"Window function with ORDER BY is not supported\");\n                 }\n \n-                Window window = windowFunction.getWindow().get();\n+                Window windowReferenceOrSpecification = windowFunction.getWindow().get();\n+                if (windowReferenceOrSpecification instanceof WindowReference || windowReferenceOrSpecification instanceof WindowSpecification && ((WindowSpecification) windowReferenceOrSpecification).getExistingWindowName().isPresent()) {\n+                    throw semanticException(NOT_SUPPORTED, (Node) windowReferenceOrSpecification, \"Reference to other window definition is not yet supported\");\n+                }\n+                checkState(windowReferenceOrSpecification instanceof WindowSpecification, \"unexpected window: \" + windowReferenceOrSpecification.getClass().getSimpleName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODY5Nw==", "bodyText": "Check is unnecessary. See comments above.", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557788697", "createdAt": "2021-01-15T00:34:12Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/sql/planner/QueryPlanner.java", "diffHunk": "@@ -814,7 +819,12 @@ private PlanBuilder window(Node node, PlanBuilder subPlan, List<FunctionCall> wi\n         for (FunctionCall windowFunction : scopeAwareDistinct(subPlan, windowFunctions)) {\n             checkArgument(windowFunction.getFilter().isEmpty(), \"Window functions cannot have filter\");\n \n-            Window window = windowFunction.getWindow().get();\n+            Window windowReferenceOrSpecification = windowFunction.getWindow().get();\n+            if (windowReferenceOrSpecification instanceof WindowReference || windowReferenceOrSpecification instanceof WindowSpecification && ((WindowSpecification) windowReferenceOrSpecification).getExistingWindowName().isPresent()) {\n+                throw semanticException(NOT_SUPPORTED, (Node) windowReferenceOrSpecification, \"Reference to other window definition is not yet supported\");\n+            }\n+            checkState(windowReferenceOrSpecification instanceof WindowSpecification, \"unexpected window: \" + windowReferenceOrSpecification.getClass().getSimpleName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MDQ0Ng==", "bodyText": "What if they are both a WindowReference that match each other? This will cause them to return false always.", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557790446", "createdAt": "2021-01-15T00:39:43Z", "author": {"login": "martint"}, "path": "core/trino-main/src/test/java/io/trino/sql/planner/assertions/FunctionCallProvider.java", "diffHunk": "@@ -138,7 +139,8 @@ public boolean equals(Object object)\n \n             return Objects.equals(name, other.getName()) &&\n                     other.getWindow().isPresent() &&\n-                    Objects.equals(frame, other.getWindow().get().getFrame()) &&\n+                    other.getWindow().get() instanceof WindowSpecification &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MDk1MA==", "bodyText": "Unrelated change", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557790950", "createdAt": "2021-01-15T00:41:09Z", "author": {"login": "martint"}, "path": "core/trino-parser/src/main/java/io/trino/sql/ExpressionFormatter.java", "diffHunk": "@@ -712,7 +659,7 @@ protected String visitRowDataType(RowDataType node, Void context)\n         {\n             return node.getFields().stream()\n                     .map(this::process)\n-                    .collect(Collectors.joining(\", \", \"ROW(\", \")\"));\n+                    .collect(joining(\", \", \"ROW(\", \")\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MTEwMw==", "bodyText": "Unnecessary check. See comments above.", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557791103", "createdAt": "2021-01-15T00:41:42Z", "author": {"login": "martint"}, "path": "core/trino-parser/src/main/java/io/trino/sql/ExpressionFormatter.java", "diffHunk": "@@ -849,6 +796,74 @@ private static String formatSortItems(List<SortItem> sortItems)\n                 .iterator());\n     }\n \n+    private static String formatWindow(Window window)\n+    {\n+        if (window instanceof WindowReference) {\n+            return formatExpression(((WindowReference) window).getName());\n+        }\n+\n+        checkState(window instanceof WindowSpecification, \"unexpected window: \" + window.getClass().getSimpleName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MzQ0OA==", "bodyText": "Unrelated change", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557793448", "createdAt": "2021-01-15T00:48:48Z", "author": {"login": "martint"}, "path": "core/trino-parser/src/main/java/io/trino/sql/ExpressionFormatter.java", "diffHunk": "@@ -739,7 +686,7 @@ protected String visitGenericDataType(GenericDataType node, Void context)\n             if (!node.getArguments().isEmpty()) {\n                 result.append(node.getArguments().stream()\n                         .map(this::process)\n-                        .collect(Collectors.joining(\", \", \"(\", \")\")));\n+                        .collect(joining(\", \", \"(\", \")\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5NDMyMw==", "bodyText": "Break the .append chain across multiple lines for clarity", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557794323", "createdAt": "2021-01-15T00:51:46Z", "author": {"login": "martint"}, "path": "core/trino-parser/src/main/java/io/trino/sql/ExpressionFormatter.java", "diffHunk": "@@ -849,6 +796,74 @@ private static String formatSortItems(List<SortItem> sortItems)\n                 .iterator());\n     }\n \n+    private static String formatWindow(Window window)\n+    {\n+        if (window instanceof WindowReference) {\n+            return formatExpression(((WindowReference) window).getName());\n+        }\n+\n+        checkState(window instanceof WindowSpecification, \"unexpected window: \" + window.getClass().getSimpleName());\n+        return formatWindowSpecification((WindowSpecification) window);\n+    }\n+\n+    static String formatWindowSpecification(WindowSpecification windowSpecification)\n+    {\n+        List<String> parts = new ArrayList<>();\n+\n+        if (windowSpecification.getExistingWindowName().isPresent()) {\n+            parts.add(formatExpression(windowSpecification.getExistingWindowName().get()));\n+        }\n+        if (!windowSpecification.getPartitionBy().isEmpty()) {\n+            parts.add(\"PARTITION BY \" + windowSpecification.getPartitionBy().stream()\n+                    .map(ExpressionFormatter::formatExpression)\n+                    .collect(joining(\", \")));\n+        }\n+        if (windowSpecification.getOrderBy().isPresent()) {\n+            parts.add(formatOrderBy(windowSpecification.getOrderBy().get()));\n+        }\n+        if (windowSpecification.getFrame().isPresent()) {\n+            parts.add(formatFrame(windowSpecification.getFrame().get()));\n+        }\n+\n+        return '(' + Joiner.on(' ').join(parts) + ')';\n+    }\n+\n+    private static String formatFrame(WindowFrame windowFrame)\n+    {\n+        StringBuilder builder = new StringBuilder();\n+\n+        builder.append(windowFrame.getType().toString()).append(' ');", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5NDk0Nw==", "bodyText": "We may want to format these across multiple lines if there are many:\nWINDOW x AS (....)\n\nor\nWINDOW\n     x AS (...),\n     y AS (...),\n     ...", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557794947", "createdAt": "2021-01-15T00:54:00Z", "author": {"login": "martint"}, "path": "core/trino-parser/src/main/java/io/trino/sql/SqlFormatter.java", "diffHunk": "@@ -314,6 +315,13 @@ protected Void visitQuerySpecification(QuerySpecification node, Integer indent)\n                         .append('\\n');\n             }\n \n+            if (!node.getWindows().isEmpty()) {\n+                append(indent, \"WINDOW \" + node.getWindows().stream()\n+                        .map(definition -> formatExpression(definition.getName()) + \" AS \" + formatWindowSpecification(definition.getWindow()))\n+                        .collect(joining(\", \")))\n+                        .append('\\n');", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5NjEzMg==", "bodyText": "window.ifPresent(xxx -> checkArgument(....))", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557796132", "createdAt": "2021-01-15T00:57:33Z", "author": {"login": "martint"}, "path": "core/trino-parser/src/main/java/io/trino/sql/tree/FunctionCall.java", "diffHunk": "@@ -55,6 +56,9 @@ public FunctionCall(\n         super(location);\n         requireNonNull(name, \"name is null\");\n         requireNonNull(window, \"window is null\");\n+        if (window.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5OTE4Mw==", "bodyText": "Unrelated change? Move to a separate commit", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557799183", "createdAt": "2021-01-15T01:07:27Z", "author": {"login": "martint"}, "path": "core/trino-main/src/test/java/io/trino/sql/analyzer/TestAnalyzer.java", "diffHunk": "@@ -651,7 +654,7 @@ public void testNonAggregate()\n                 .hasErrorCode(EXPRESSION_NOT_AGGREGATE);\n         assertFails(\"SELECT count(*) over (ORDER BY count(*) ROWS BETWEEN b PRECEDING AND a PRECEDING) FROM t1 GROUP BY b\")\n                 .hasErrorCode(EXPRESSION_NOT_AGGREGATE);\n-        assertFails(\"SELECT count(*) over (ORDER BY count(*) ROWS BETWEEN a PRECEDING AND UNBOUNDED PRECEDING) FROM t1 GROUP BY b\")\n+        assertFails(\"SELECT count(*) over (ORDER BY count(*) ROWS BETWEEN a PRECEDING AND UNBOUNDED FOLLOWING) FROM t1 GROUP BY b\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5OTk2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!windowDefinitions.containsKey(NodeRef.of(query))) {\n          \n          \n            \n                        windowDefinitions.put(NodeRef.of(query), new LinkedHashMap<>());\n          \n          \n            \n                    }\n          \n          \n            \n                    windowDefinitions.get(NodeRef.of(query)).put(name, window);\n          \n          \n            \n                    windowDefinitions.computeIfAbsent(NodeRef.of(query), LinkedHashMap::new)\n          \n          \n            \n                            .put(name, window);", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557799967", "createdAt": "2021-01-15T01:09:45Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/Analysis.java", "diffHunk": "@@ -449,6 +457,40 @@ public void recordSubqueries(Node node, ExpressionAnalysis expressionAnalysis)\n         return unmodifiableList(quantifiedComparisonSubqueries.get(NodeRef.of(node)));\n     }\n \n+    public void addWindowDefinition(QuerySpecification query, String name, ResolvedWindow window)\n+    {\n+        if (!windowDefinitions.containsKey(NodeRef.of(query))) {\n+            windowDefinitions.put(NodeRef.of(query), new LinkedHashMap<>());\n+        }\n+        windowDefinitions.get(NodeRef.of(query)).put(name, window);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgwMDc1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!windowDefinitions.containsKey(NodeRef.of(query))) {\n          \n          \n            \n                        return null;\n          \n          \n            \n                    }\n          \n          \n            \n                    return windowDefinitions.get(NodeRef.of(query)).get(name);\n          \n          \n            \n                    Map<String, ResolvedWindow> windows = windowDefinitions.get(NodeRef.of(query));\n          \n          \n            \n                    if (windows != null) {\n          \n          \n            \n                        return windows.get(name);\n          \n          \n            \n                    }\n          \n          \n            \n                    \n          \n          \n            \n                    return null;\n          \n      \n    \n    \n  \n\nNot sure we should return null (vs fail), though. If this method is called for a non-existent name, it's probably an indication of an analyzer bug.", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557800751", "createdAt": "2021-01-15T01:12:15Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/Analysis.java", "diffHunk": "@@ -449,6 +457,40 @@ public void recordSubqueries(Node node, ExpressionAnalysis expressionAnalysis)\n         return unmodifiableList(quantifiedComparisonSubqueries.get(NodeRef.of(node)));\n     }\n \n+    public void addWindowDefinition(QuerySpecification query, String name, ResolvedWindow window)\n+    {\n+        if (!windowDefinitions.containsKey(NodeRef.of(query))) {\n+            windowDefinitions.put(NodeRef.of(query), new LinkedHashMap<>());\n+        }\n+        windowDefinitions.get(NodeRef.of(query)).put(name, window);\n+    }\n+\n+    public ResolvedWindow getWindowDefinition(QuerySpecification query, String name)\n+    {\n+        if (!windowDefinitions.containsKey(NodeRef.of(query))) {\n+            return null;\n+        }\n+        return windowDefinitions.get(NodeRef.of(query)).get(name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgwMTEwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (windowDefinitions.containsKey(NodeRef.of(query))) {\n          \n          \n            \n                        return ImmutableList.copyOf(windowDefinitions.get(NodeRef.of(query)).values());\n          \n          \n            \n                    }\n          \n          \n            \n                    return ImmutableList.of();\n          \n          \n            \n                    Map<String, ResolvedWindow> windows = windowDefinitions.get(NodeRef.of(query));\n          \n          \n            \n            \n          \n          \n            \n                    if (windows != null) {\n          \n          \n            \n                        return ImmutableList.copyOf(windows.values());\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    return ImmutableList.of();", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557801108", "createdAt": "2021-01-15T01:13:26Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/Analysis.java", "diffHunk": "@@ -449,6 +457,40 @@ public void recordSubqueries(Node node, ExpressionAnalysis expressionAnalysis)\n         return unmodifiableList(quantifiedComparisonSubqueries.get(NodeRef.of(node)));\n     }\n \n+    public void addWindowDefinition(QuerySpecification query, String name, ResolvedWindow window)\n+    {\n+        if (!windowDefinitions.containsKey(NodeRef.of(query))) {\n+            windowDefinitions.put(NodeRef.of(query), new LinkedHashMap<>());\n+        }\n+        windowDefinitions.get(NodeRef.of(query)).put(name, window);\n+    }\n+\n+    public ResolvedWindow getWindowDefinition(QuerySpecification query, String name)\n+    {\n+        if (!windowDefinitions.containsKey(NodeRef.of(query))) {\n+            return null;\n+        }\n+        return windowDefinitions.get(NodeRef.of(query)).get(name);\n+    }\n+\n+    public List<ResolvedWindow> getWindowDefinitions(QuerySpecification query)\n+    {\n+        if (windowDefinitions.containsKey(NodeRef.of(query))) {\n+            return ImmutableList.copyOf(windowDefinitions.get(NodeRef.of(query)).values());\n+        }\n+        return ImmutableList.of();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 47}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcxNzUxMzA5", "url": "https://github.com/trinodb/trino/pull/6192#pullrequestreview-571751309", "createdAt": "2021-01-19T23:27:29Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQyMzoyNzoyOVrOIWmdfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQwMTo1NDowM1rOIWplBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU2OTcyNA==", "bodyText": "We should resolve window names using proper SQL identifier semantics.", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560569724", "createdAt": "2021-01-19T23:27:29Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1955,6 +1969,134 @@ else if (actualType instanceof RowType) {\n             return createAndAssignScope(node, scope, fields);\n         }\n \n+        private void analyzeWindowDefinitions(QuerySpecification node, Scope scope)\n+        {\n+            for (WindowDefinition windowDefinition : node.getWindows()) {\n+                String name = windowDefinition.getName().getValue().toLowerCase(ENGLISH);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU3MTIxMg==", "bodyText": "Is the resolution scope for window names strictly within a \"query specification\", or can they come from an outer query specification (e.g., when there are no column references involved)?", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560571212", "createdAt": "2021-01-19T23:31:17Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1955,6 +1969,134 @@ else if (actualType instanceof RowType) {\n             return createAndAssignScope(node, scope, fields);\n         }\n \n+        private void analyzeWindowDefinitions(QuerySpecification node, Scope scope)\n+        {\n+            for (WindowDefinition windowDefinition : node.getWindows()) {\n+                String name = windowDefinition.getName().getValue().toLowerCase(ENGLISH);\n+\n+                if (analysis.getWindowDefinition(node, name) != null) {\n+                    throw semanticException(DUPLICATE_WINDOW_NAME, windowDefinition, \"WINDOW name '%s' specified more than once\", name);\n+                }\n+\n+                ResolvedWindow resolvedWindow = resolveWindowSpecification(node, windowDefinition.getWindow());\n+\n+                // Analyze window after it is resolved, because resolving might provide necessary information, e.g. ORDER BY necessary for frame analysis.\n+                // Analyze only newly introduced window properties. Properties of the referenced window have been already analyzed.\n+                analyzeWindow(node, resolvedWindow, scope, windowDefinition.getWindow());\n+\n+                analysis.addWindowDefinition(node, name, resolvedWindow);\n+            }\n+        }\n+\n+        private ResolvedWindow resolveWindowSpecification(QuerySpecification querySpecification, Window window)\n+        {\n+            if (window instanceof WindowReference) {\n+                WindowReference windowReference = (WindowReference) window;\n+                String referencedName = windowReference.getName().getValue().toLowerCase(ENGLISH);\n+                ResolvedWindow referencedWindow = analysis.getWindowDefinition(querySpecification, referencedName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU3MTg2NA==", "bodyText": "This check is unnecessary due to the cast below.", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560571864", "createdAt": "2021-01-19T23:33:13Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1955,6 +1969,134 @@ else if (actualType instanceof RowType) {\n             return createAndAssignScope(node, scope, fields);\n         }\n \n+        private void analyzeWindowDefinitions(QuerySpecification node, Scope scope)\n+        {\n+            for (WindowDefinition windowDefinition : node.getWindows()) {\n+                String name = windowDefinition.getName().getValue().toLowerCase(ENGLISH);\n+\n+                if (analysis.getWindowDefinition(node, name) != null) {\n+                    throw semanticException(DUPLICATE_WINDOW_NAME, windowDefinition, \"WINDOW name '%s' specified more than once\", name);\n+                }\n+\n+                ResolvedWindow resolvedWindow = resolveWindowSpecification(node, windowDefinition.getWindow());\n+\n+                // Analyze window after it is resolved, because resolving might provide necessary information, e.g. ORDER BY necessary for frame analysis.\n+                // Analyze only newly introduced window properties. Properties of the referenced window have been already analyzed.\n+                analyzeWindow(node, resolvedWindow, scope, windowDefinition.getWindow());\n+\n+                analysis.addWindowDefinition(node, name, resolvedWindow);\n+            }\n+        }\n+\n+        private ResolvedWindow resolveWindowSpecification(QuerySpecification querySpecification, Window window)\n+        {\n+            if (window instanceof WindowReference) {\n+                WindowReference windowReference = (WindowReference) window;\n+                String referencedName = windowReference.getName().getValue().toLowerCase(ENGLISH);\n+                ResolvedWindow referencedWindow = analysis.getWindowDefinition(querySpecification, referencedName);\n+                if (referencedWindow == null) {\n+                    throw semanticException(INVALID_WINDOW_REFERENCE, windowReference.getName(), \"Cannot resolve WINDOW name \" + referencedName);\n+                }\n+\n+                return new ResolvedWindow(\n+                        referencedWindow.getPartitionBy(),\n+                        referencedWindow.getOrderBy(),\n+                        referencedWindow.getFrame(),\n+                        !referencedWindow.getPartitionBy().isEmpty(),\n+                        referencedWindow.getOrderBy().isPresent(),\n+                        referencedWindow.getFrame().isPresent());\n+            }\n+\n+            checkArgument(window instanceof WindowSpecification, \"unexpected window: \" + window.getClass().getSimpleName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU4Mjg2NQ==", "bodyText": "Technically, any exact numeric type with scale 0 is allowed (e.g., TINYINT, SMALLINT, DECIMAL(p, 0))", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560582865", "createdAt": "2021-01-20T00:02:49Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -1137,17 +1077,138 @@ else if (node.getArguments().size() > 127) {\n             return setExpressionType(node, type);\n         }\n \n-        private void analyzeFrameRangeOffset(Expression offsetValue, FrameBound.Type boundType, StackableAstVisitorContext<Context> context, WindowSpecification window)\n+        private void analyzeWindow(ResolvedWindow window, StackableAstVisitorContext<Context> context, Node originalNode)\n+        {\n+            // check no nested window functions\n+            ImmutableList.Builder<Node> childNodes = ImmutableList.builder();\n+            if (!window.isPartitionByInherited()) {\n+                childNodes.addAll(window.getPartitionBy());\n+            }\n+            if (!window.isOrderByInherited()) {\n+                window.getOrderBy().ifPresent(orderBy -> childNodes.addAll(orderBy.getSortItems()));\n+            }\n+            if (!window.isFrameInherited()) {\n+                window.getFrame().ifPresent(childNodes::add);\n+            }\n+            List<FunctionCall> nestedWindowFunctions = extractWindowFunctions(childNodes.build());\n+            if (!nestedWindowFunctions.isEmpty()) {\n+                throw semanticException(NESTED_WINDOW, nestedWindowFunctions.get(0), \"Cannot nest window functions inside window specification\");\n+            }\n+\n+            if (!window.isPartitionByInherited()) {\n+                for (Expression expression : window.getPartitionBy()) {\n+                    process(expression, context);\n+                    Type type = getExpressionType(expression);\n+                    if (!type.isComparable()) {\n+                        throw semanticException(TYPE_MISMATCH, expression, \"%s is not comparable, and therefore cannot be used in window function PARTITION BY\", type);\n+                    }\n+                }\n+            }\n+\n+            if (!window.isOrderByInherited()) {\n+                for (SortItem sortItem : getSortItemsFromOrderBy(window.getOrderBy())) {\n+                    process(sortItem.getSortKey(), context);\n+                    Type type = getExpressionType(sortItem.getSortKey());\n+                    if (!type.isOrderable()) {\n+                        throw semanticException(TYPE_MISMATCH, sortItem, \"%s is not orderable, and therefore cannot be used in window function ORDER BY\", type);\n+                    }\n+                }\n+            }\n+\n+            if (window.getFrame().isPresent() && !window.isFrameInherited()) {\n+                WindowFrame frame = window.getFrame().get();\n+\n+                // validate frame start and end types\n+                FrameBound.Type startType = frame.getStart().getType();\n+                FrameBound.Type endType = frame.getEnd().orElse(new FrameBound(CURRENT_ROW)).getType();\n+                if (startType == UNBOUNDED_FOLLOWING) {\n+                    throw semanticException(INVALID_WINDOW_FRAME, frame, \"Window frame start cannot be UNBOUNDED FOLLOWING\");\n+                }\n+                if (endType == UNBOUNDED_PRECEDING) {\n+                    throw semanticException(INVALID_WINDOW_FRAME, frame, \"Window frame end cannot be UNBOUNDED PRECEDING\");\n+                }\n+                if ((startType == CURRENT_ROW) && (endType == PRECEDING)) {\n+                    throw semanticException(INVALID_WINDOW_FRAME, frame, \"Window frame starting from CURRENT ROW cannot end with PRECEDING\");\n+                }\n+                if ((startType == FOLLOWING) && (endType == PRECEDING)) {\n+                    throw semanticException(INVALID_WINDOW_FRAME, frame, \"Window frame starting from FOLLOWING cannot end with PRECEDING\");\n+                }\n+                if ((startType == FOLLOWING) && (endType == CURRENT_ROW)) {\n+                    throw semanticException(INVALID_WINDOW_FRAME, frame, \"Window frame starting from FOLLOWING cannot end with CURRENT ROW\");\n+                }\n+\n+                // analyze frame offset values\n+                if (frame.getType() == ROWS) {\n+                    if (frame.getStart().getValue().isPresent()) {\n+                        Expression startValue = frame.getStart().getValue().get();\n+                        Type type = process(startValue, context);\n+                        if (!type.equals(INTEGER) && !type.equals(BIGINT)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU5OTU3OQ==", "bodyText": "Place the Analysis argument in the first position for clarity.", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560599579", "createdAt": "2021-01-20T00:52:05Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -1956,6 +2031,23 @@ public static ExpressionAnalysis analyzeExpression(\n                 analyzer.getWindowFunctions());\n     }\n \n+    private static void updateAnalysis(ExpressionAnalyzer analyzer, Analysis analysis, Session session, AccessControl accessControl)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 396}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwMjI1NQ==", "bodyText": "Technically, this should happen after aggregations.", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560602255", "createdAt": "2021-01-20T00:59:41Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/sql/planner/QueryPlanner.java", "diffHunk": "@@ -367,6 +363,7 @@ protected PlanNode visitPlan(PlanNode node, RewriteContext<Void> context)\n     public RelationPlan plan(QuerySpecification node)\n     {\n         PlanBuilder builder = planFrom(node);\n+        builder = planWindowDefinitions(builder, analysis.getWindowDefinitions(node), node);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwNDI1Nw==", "bodyText": "We should verify that any subquery in a window clause that's not being referenced is eventually removed from the plan.", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560604257", "createdAt": "2021-01-20T01:05:21Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/sql/planner/QueryPlanner.java", "diffHunk": "@@ -505,6 +502,39 @@ private PlanBuilder planFrom(QuerySpecification node)\n                 new ValuesNode(idAllocator.getNextId(), 1));\n     }\n \n+    // TODO this could be optimized to plan only the window specification parts that are actually used", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwNzE3Mg==", "bodyText": "Add a test for the opposite case: a window in the outer query cannot be referenced by the inner query.", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560607172", "createdAt": "2021-01-20T01:13:41Z", "author": {"login": "martint"}, "path": "core/trino-main/src/test/java/io/trino/sql/analyzer/TestAnalyzer.java", "diffHunk": "@@ -876,6 +879,196 @@ public void testNaturalJoinNotSupported()\n                 .hasErrorCode(NOT_SUPPORTED);\n     }\n \n+    @Test\n+    public void testWindowClause()\n+    {\n+        assertFails(\"SELECT * FROM t1 WINDOW w AS (PARTITION BY a), w AS (PARTITION BY a)\")\n+                .hasErrorCode(DUPLICATE_WINDOW_NAME);\n+\n+        assertFails(\"SELECT * FROM t1 WINDOW w AS (PARTITION BY a), w AS (ORDER BY b)\")\n+                .hasErrorCode(DUPLICATE_WINDOW_NAME);\n+\n+        assertFails(\"SELECT * FROM t1 WINDOW w AS (), w1 as (), w AS (w)\")\n+                .hasErrorCode(DUPLICATE_WINDOW_NAME);\n+\n+        // window definitions with the same names are allowed in different query specifications (in this case, outer and inner query)\n+        analyze(\"SELECT * FROM (SELECT * FROM t1 WINDOW w AS (PARTITION BY a)) \" +\n+                \"WINDOW w AS (PARTITION BY a)\");\n+\n+        // window definition in inner query is not visible in outer query", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwODYwNQ==", "bodyText": "Why did this change?", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560608605", "createdAt": "2021-01-20T01:17:56Z", "author": {"login": "martint"}, "path": "core/trino-main/src/test/java/io/trino/sql/analyzer/TestAnalyzer.java", "diffHunk": "@@ -990,7 +1183,7 @@ public void testWindowFrameTypeRange()\n \n         assertFails(\"SELECT array_agg(x) OVER (RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING) FROM (VALUES 1) T(x)\")\n                 .hasErrorCode(MISSING_ORDER_BY)\n-                .hasMessage(\"line 1:21: Window frame of type RANGE PRECEDING or FOLLOWING requires ORDER BY\");\n+                .hasMessage(\"line 1:27: Window frame of type RANGE PRECEDING or FOLLOWING requires ORDER BY\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwODc4Mw==", "bodyText": "What's in this new projection?", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560608783", "createdAt": "2021-01-20T01:18:20Z", "author": {"login": "martint"}, "path": "core/trino-main/src/test/java/io/trino/sql/planner/TestRecursiveCte.java", "diffHunk": "@@ -61,15 +61,15 @@ public void testRecursiveQuery()\n                                 // base term\n                                 project(project(project(\n                                         ImmutableMap.of(\"expr\", expression(\"1\")),\n-                                        values()))),\n+                                        project(values())))),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYyMDE5Nw==", "bodyText": "lower case table alias: t(a)", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560620197", "createdAt": "2021-01-20T01:52:04Z", "author": {"login": "martint"}, "path": "core/trino-main/src/test/java/io/trino/sql/planner/TestWindowClause.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.trino.spi.connector.SortOrder;\n+import io.trino.sql.planner.assertions.BasePlanTest;\n+import io.trino.sql.planner.assertions.PlanMatchPattern;\n+import io.trino.sql.planner.plan.FilterNode;\n+import io.trino.sql.tree.FunctionCall;\n+import io.trino.sql.tree.QualifiedName;\n+import io.trino.sql.tree.SymbolReference;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.trino.metadata.MetadataManager.createTestMetadataManager;\n+import static io.trino.spi.type.IntegerType.INTEGER;\n+import static io.trino.sql.analyzer.TypeSignatureProvider.fromTypes;\n+import static io.trino.sql.planner.LogicalPlanner.Stage.CREATED;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.any;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.anyTree;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.expression;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.functionCall;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.node;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.sort;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.specification;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.values;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.window;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.windowFrame;\n+import static io.trino.sql.tree.FrameBound.Type.CURRENT_ROW;\n+import static io.trino.sql.tree.FrameBound.Type.FOLLOWING;\n+import static io.trino.sql.tree.FrameBound.Type.PRECEDING;\n+import static io.trino.sql.tree.SortItem.NullOrdering.LAST;\n+import static io.trino.sql.tree.SortItem.Ordering.ASCENDING;\n+import static io.trino.sql.tree.WindowFrame.Type.RANGE;\n+\n+public class TestWindowClause\n+        extends BasePlanTest\n+{\n+    @Test\n+    public void testPreprojectExpression()\n+    {\n+        @Language(\"SQL\") String sql = \"SELECT max(b) OVER w FROM (VALUES (1, 1)) t(a, b) WINDOW w AS (PARTITION BY a + 1)\";\n+        PlanMatchPattern pattern =\n+                anyTree(\n+                        window(\n+                                windowMatcherBuilder -> windowMatcherBuilder\n+                                        .specification(specification(\n+                                                ImmutableList.of(\"expr\"),\n+                                                ImmutableList.of(),\n+                                                ImmutableMap.of()))\n+                                        .addFunction(\n+                                                \"max_result\",\n+                                                functionCall(\"max\", ImmutableList.of(\"b\"))),\n+                                anyTree(project(\n+                                        ImmutableMap.of(\"expr\", expression(\"a + 1\")),\n+                                        anyTree(values(\"a\", \"b\"))))));\n+\n+        assertPlan(sql, CREATED, pattern);\n+    }\n+\n+    @Test\n+    public void testPreprojectExpressions()\n+    {\n+        @Language(\"SQL\") String sql = \"SELECT max(b) OVER w3 FROM (VALUES (1, 1, 1)) t(a, b, c) WINDOW w1 AS (PARTITION BY a + 1), w2 AS (w1 ORDER BY b + 2), w3 AS (w2 RANGE c + 3 PRECEDING)\";\n+        PlanMatchPattern pattern =\n+                anyTree(\n+                        window(\n+                                windowMatcherBuilder -> windowMatcherBuilder\n+                                        .specification(specification(\n+                                                ImmutableList.of(\"expr_a\"),\n+                                                ImmutableList.of(\"expr_b\"),\n+                                                ImmutableMap.of(\"expr_b\", SortOrder.ASC_NULLS_LAST)))\n+                                        .addFunction(\n+                                                \"max_result\",\n+                                                functionCall(\"max\", ImmutableList.of(\"b\")),\n+                                                createTestMetadataManager().resolveFunction(QualifiedName.of(\"max\"), fromTypes(INTEGER)),\n+                                                windowFrame(\n+                                                        RANGE,\n+                                                        PRECEDING,\n+                                                        Optional.of(\"frame_start\"),\n+                                                        Optional.of(\"expr_b\"),\n+                                                        CURRENT_ROW,\n+                                                        Optional.empty(),\n+                                                        Optional.empty())),\n+                                project(\n+                                        ImmutableMap.of(\"frame_start\", expression(new FunctionCall(QualifiedName.of(\"$operator$subtract\"), ImmutableList.of(new SymbolReference(\"expr_b\"), new SymbolReference(\"expr_c\"))))),\n+                                        anyTree(project(\n+                                                ImmutableMap.of(\"expr_a\", expression(\"a + 1\"), \"expr_b\", expression(\"b + 2\"), \"expr_c\", expression(\"c + 3\")),\n+                                                anyTree(values(\"a\", \"b\", \"c\")))))));\n+\n+        assertPlan(sql, CREATED, pattern);\n+    }\n+\n+    @Test\n+    public void testWindowFunctionsInSelectAndOrderBy()\n+    {\n+        @Language(\"SQL\") String sql = \"SELECT array_agg(a) OVER (w ORDER BY a + 1), -a a FROM (VALUES 1, 2, 3) T(a) WINDOW w AS () ORDER BY max(a) OVER (w ORDER BY a + 1)\";\n+        PlanMatchPattern pattern =\n+                anyTree(sort(\n+                        ImmutableList.of(sort(\"max_result\", ASCENDING, LAST)),\n+                        any(window(\n+                                windowMatcherBuilder -> windowMatcherBuilder\n+                                        .specification(specification(\n+                                                ImmutableList.of(),\n+                                                ImmutableList.of(\"order_by_window_sortkey\"),\n+                                                ImmutableMap.of(\"order_by_window_sortkey\", SortOrder.ASC_NULLS_LAST)))\n+                                        .addFunction(\n+                                                \"max_result\",\n+                                                functionCall(\"max\", ImmutableList.of(\"minus_a\"))),\n+                                any(project(\n+                                        ImmutableMap.of(\"order_by_window_sortkey\", expression(\"minus_a + 1\")),\n+                                        project(\n+                                                ImmutableMap.of(\"minus_a\", expression(\"-a\")),\n+                                                window(\n+                                                        windowMatcherBuilder -> windowMatcherBuilder\n+                                                                .specification(specification(\n+                                                                        ImmutableList.of(),\n+                                                                        ImmutableList.of(\"select_window_sortkey\"),\n+                                                                        ImmutableMap.of(\"select_window_sortkey\", SortOrder.ASC_NULLS_LAST)))\n+                                                                .addFunction(\n+                                                                        \"array_agg_result\",\n+                                                                        functionCall(\"array_agg\", ImmutableList.of(\"a\"))),\n+                                                        anyTree(project(\n+                                                                ImmutableMap.of(\"select_window_sortkey\", expression(\"a + 1\")),\n+                                                                anyTree(values(\"a\"))))))))))));\n+\n+        assertPlan(sql, CREATED, pattern);\n+    }\n+\n+    @Test\n+    public void testWindowWithFrameCoercions()\n+    {\n+        @Language(\"SQL\") String sql = \"SELECT a old_a, 2e0 a FROM (VALUES -100, -99, -98) T(a) WINDOW w AS (ORDER BY a + 1) ORDER BY count(*) OVER (w RANGE BETWEEN CURRENT ROW AND a + 1e0 FOLLOWING)\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYyMDQ3Nw==", "bodyText": "lower case table alias: t(a)", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560620477", "createdAt": "2021-01-20T01:53:03Z", "author": {"login": "martint"}, "path": "testing/trino-tests/src/test/java/io/trino/tests/AbstractTestEngineOnlyQueries.java", "diffHunk": "@@ -4288,6 +4288,78 @@ public void testGroupingInTableSubquery()\n                         \"       (37415, NULL, 986.63, 0)\");\n     }\n \n+    @Test\n+    public void testWindow()\n+    {\n+        // reference to named window\n+        assertQuery(\n+                \"SELECT array_agg(b) OVER w FROM (VALUES (1, 'a'), (1, 'b'), (3, 'c')) t(a, b) WINDOW w AS (PARTITION BY a)\",\n+                \"VALUES ARRAY['a', 'b'], ARRAY['a', 'b'], ARRAY['c']\");\n+\n+        assertQuery(\n+                \"SELECT first_value(b) OVER w FROM (VALUES (1, 'a'), (1, 'b'), (3, 'c')) t(a, b) WINDOW w AS (PARTITION BY a ORDER BY b DESC)\",\n+                \"VALUES 'b', 'b', 'c'\");\n+\n+        assertQuery(\n+                \"SELECT first_value(b) OVER w FROM (VALUES (1, 'a'), (1, 'b'), (3, 'c')) t(a, b) WINDOW w AS (PARTITION BY a ORDER BY b DESC ROWS CURRENT ROW)\",\n+                \"VALUES 'a', 'b', 'c'\");\n+\n+        assertQuery(\n+                \"SELECT first_value(b) OVER w FROM (VALUES (1, 'a'), (1, 'b'), (3, 'c')) t(a, b) WINDOW w AS (PARTITION BY a ORDER BY b DESC ROWS CURRENT ROW)\",\n+                \"VALUES 'a', 'b', 'c'\");\n+\n+        // in-line window specification based on named window in SELECT expression\n+        assertQuery(\n+                \"SELECT first_value(b) OVER (w ORDER BY b DESC ROWS CURRENT ROW) FROM (VALUES (1, 'a'), (1, 'b'), (3, 'c')) t(a, b) WINDOW w AS (PARTITION BY a)\",\n+                \"VALUES 'a', 'b', 'c'\");\n+\n+        assertQuery(\n+                \"SELECT first_value(b) OVER (w ROWS CURRENT ROW) FROM (VALUES (1, 'a'), (1, 'b'), (3, 'c')) t(a, b) WINDOW w AS (PARTITION BY a ORDER BY b DESC)\",\n+                \"VALUES 'a', 'b', 'c'\");\n+\n+        // in-line window specification based on named window in ORDER BY expression\n+        assertQueryOrdered(\n+                \"SELECT * FROM (VALUES (1, 'a'), (1, 'b'), (2, 'c'), (2, 'd')) t(a, b) WINDOW w AS (PARTITION BY a) ORDER BY row_number() OVER (w ORDER BY b DESC), b\",\n+                \"VALUES (1, 'b'), (2, 'd'), (1, 'a'), (2, 'c')\");\n+\n+        assertQueryOrdered(\n+                \"SELECT * FROM (VALUES (1, 'a'), (1, 'b'), (2, 'c'), (2, 'd')) t(a, b) WINDOW w AS (PARTITION BY a) ORDER BY max(b) OVER (w ROWS CURRENT ROW), b\",\n+                \"VALUES (1, 'a'), (1, 'b'), (2, 'c'), (2, 'd')\");\n+\n+        // in-line window specification based on named window in ORDER BY expression, resolved against output scope\n+        assertQueryOrdered(\"SELECT -a a, b FROM (VALUES (1, 'a'), (2, 'b'), (3, 'c')) t(a, b) WINDOW w AS () ORDER BY row_number() OVER (w ORDER BY a)\",\n+                \"VALUES (-3, 'c'), (-2, 'b'), (-1, 'a')\");\n+\n+        assertQueryOrdered(\"SELECT a old_a, 2 a FROM (VALUES -100, -99, -98) t(a) WINDOW w AS (ORDER BY a) ORDER BY count(*) OVER (w RANGE BETWEEN CURRENT ROW AND a FOLLOWING)\",\n+                \"VALUES (-98, 2), (-99, 2), (-100, 2)\");\n+\n+        // two syntactically identical window specifications in different scopes\n+        assertQueryOrdered(\"SELECT array_agg(a) OVER (w ORDER BY a), -a a FROM (VALUES 1, 2, 3) T(a) WINDOW w AS () ORDER BY lead(a, 0) OVER (w ORDER BY a)\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYyMDgwNg==", "bodyText": "These would be easier to read if you break them across multiple lines:\nSELECT array_agg(b) OVER w \nFROM (VALUES (1, 'a'), (1, 'b'), (3, 'c')) t(a, b) \nWINDOW w AS (PARTITION BY a)", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560620806", "createdAt": "2021-01-20T01:54:03Z", "author": {"login": "martint"}, "path": "testing/trino-tests/src/test/java/io/trino/tests/AbstractTestEngineOnlyQueries.java", "diffHunk": "@@ -4288,6 +4288,78 @@ public void testGroupingInTableSubquery()\n                         \"       (37415, NULL, 986.63, 0)\");\n     }\n \n+    @Test\n+    public void testWindow()\n+    {\n+        // reference to named window\n+        assertQuery(\n+                \"SELECT array_agg(b) OVER w FROM (VALUES (1, 'a'), (1, 'b'), (3, 'c')) t(a, b) WINDOW w AS (PARTITION BY a)\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 9}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NjI1NTI4", "url": "https://github.com/trinodb/trino/pull/6192#pullrequestreview-574625528", "createdAt": "2021-01-22T21:15:15Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMToxNToxNVrOIY1l_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMToxNToxNVrOIY1l_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkxNDgxNQ==", "bodyText": "Add some tests for window name resolution that involve SQL identifier canonicalization semantics.", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r562914815", "createdAt": "2021-01-22T21:15:15Z", "author": {"login": "martint"}, "path": "core/trino-main/src/test/java/io/trino/sql/analyzer/TestAnalyzer.java", "diffHunk": "@@ -892,6 +892,26 @@ public void testWindowClause()\n                 .hasErrorCode(DUPLICATE_WINDOW_NAME);\n     }\n \n+    @Test\n+    public void testWindowNames()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9518dcdc6142a71c4122675d0beaa6e47b0fc04", "author": {"user": {"login": "kasiafi", "name": null}}, "url": "https://github.com/trinodb/trino/commit/d9518dcdc6142a71c4122675d0beaa6e47b0fc04", "committedDate": "2021-01-26T20:38:21Z", "message": "Add static import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ed75c77bb6ef0f2c7f2f4127e50e51fa8d5d353", "author": {"user": {"login": "kasiafi", "name": null}}, "url": "https://github.com/trinodb/trino/commit/7ed75c77bb6ef0f2c7f2f4127e50e51fa8d5d353", "committedDate": "2021-01-26T20:38:22Z", "message": "Fix test case"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a49453113cf984d8abb9e4a065b505f5261ae63", "author": {"user": {"login": "kasiafi", "name": null}}, "url": "https://github.com/trinodb/trino/commit/7a49453113cf984d8abb9e4a065b505f5261ae63", "committedDate": "2021-01-26T21:00:29Z", "message": "Support WINDOW clause"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "7a49453113cf984d8abb9e4a065b505f5261ae63", "author": {"user": {"login": "kasiafi", "name": null}}, "url": "https://github.com/trinodb/trino/commit/7a49453113cf984d8abb9e4a065b505f5261ae63", "committedDate": "2021-01-26T21:00:29Z", "message": "Support WINDOW clause"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2022, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}