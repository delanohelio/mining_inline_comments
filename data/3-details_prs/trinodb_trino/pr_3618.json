{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzMTU4Mzc5", "number": 3618, "title": "Convert LIKE to ranges", "bodyText": "", "createdAt": "2020-05-04T20:08:04Z", "url": "https://github.com/trinodb/trino/pull/3618", "merged": true, "mergeCommit": {"oid": "6aea881752ef9a83521a4a20bccf510bf9a31d2c"}, "closed": true, "closedAt": "2020-05-07T21:25:21Z", "author": {"login": "findepi"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABceGBaZgBqjMzMDE3MDc5OTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABce6xITABqjMzMTIyNTkyMjg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "beac60af82b0ce3ccab679fcc98ea712d694a24b", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/beac60af82b0ce3ccab679fcc98ea712d694a24b", "committedDate": "2020-05-06T22:11:01Z", "message": "Use Optional instead of @Nullable parameter"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MTEzNzEw", "url": "https://github.com/trinodb/trino/pull/3618#pullrequestreview-407113710", "createdAt": "2020-05-07T02:41:41Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMjo0MTo0MVrOGRsW1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMzoxMjoyMlrOGRs2CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwNTcxNw==", "bodyText": "Why not return true directly here? It's more explicit and doesn't require additional reasoning about what the condition in the return clause below says.", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421205717", "createdAt": "2020-05-07T02:41:41Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/type/LikeFunctions.java", "diffHunk": "@@ -133,11 +135,12 @@ else if (escaped) {\n                 escaped = false;\n             }\n             else if ((currentChar == '%') || (currentChar == '_')) {\n-                isLikePattern = true;\n+                break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwNjA5Mw==", "bodyText": "Extract lengthOfCodePoint(currentChar) above the if and reuse in the else branch.", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421206093", "createdAt": "2020-05-07T02:43:25Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/type/LikeFunctions.java", "diffHunk": "@@ -146,20 +149,27 @@ public static Slice unescapeLiteralLikePattern(Slice pattern, Optional<Slice> es\n             return pattern;\n         }\n \n-        char escapeChar = getEscapeCharacter(escape).get();\n-        String stringPattern = pattern.toStringUtf8();\n-        StringBuilder unescapedPattern = new StringBuilder(stringPattern.length());\n+        int escapeChar = getEscapeCharacter(escape)\n+                .map(c -> (int) c)\n+                .orElse(-1);\n+\n+        @SuppressWarnings(\"resource\")\n+        DynamicSliceOutput output = new DynamicSliceOutput(pattern.length());\n         boolean escaped = false;\n-        for (int currentChar : stringPattern.codePoints().toArray()) {\n+        int position = 0;\n+        while (position < pattern.length()) {\n+            int currentChar = getCodePointAt(pattern, position);\n             if (!escaped && (currentChar == escapeChar)) {\n                 escaped = true;\n             }\n             else {\n-                unescapedPattern.append(Character.toChars(currentChar));\n+                output.writeBytes(pattern, position, lengthOfCodePoint(currentChar));\n                 escaped = false;\n             }\n+            position += lengthOfCodePoint(currentChar);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwODYyOA==", "bodyText": "typo", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421208628", "createdAt": "2020-05-07T02:52:54Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "diffHunk": "@@ -857,6 +867,88 @@ protected ExtractionResult visitBetweenPredicate(BetweenPredicate node, Boolean\n                     new ComparisonExpression(LESS_THAN_OR_EQUAL, node.getValue(), node.getMax())), complement);\n         }\n \n+        @Override\n+        protected ExtractionResult visitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            Optional<ExtractionResult> result = tryVisitLikePredicate(node, complement);\n+            if (result.isPresent()) {\n+                return result.get();\n+            }\n+            return super.visitLikePredicate(node, complement);\n+        }\n+\n+        private Optional<ExtractionResult> tryVisitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            if (!(node.getValue() instanceof SymbolReference)) {\n+                // LIKE not on a symbol\n+                return Optional.empty();\n+            }\n+\n+            if (!(node.getPattern() instanceof StringLiteral)) {\n+                // dyamic pattern", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMTI3Ng==", "bodyText": "This should never really happen. Like expressions with constant patterns are turned into comparison expressions when ExpressionInterpreter is used to optimize expressions.", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421211276", "createdAt": "2020-05-07T03:02:41Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "diffHunk": "@@ -857,6 +867,88 @@ protected ExtractionResult visitBetweenPredicate(BetweenPredicate node, Boolean\n                     new ComparisonExpression(LESS_THAN_OR_EQUAL, node.getValue(), node.getMax())), complement);\n         }\n \n+        @Override\n+        protected ExtractionResult visitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            Optional<ExtractionResult> result = tryVisitLikePredicate(node, complement);\n+            if (result.isPresent()) {\n+                return result.get();\n+            }\n+            return super.visitLikePredicate(node, complement);\n+        }\n+\n+        private Optional<ExtractionResult> tryVisitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            if (!(node.getValue() instanceof SymbolReference)) {\n+                // LIKE not on a symbol\n+                return Optional.empty();\n+            }\n+\n+            if (!(node.getPattern() instanceof StringLiteral)) {\n+                // dyamic pattern\n+                return Optional.empty();\n+            }\n+\n+            if (node.getEscape().isPresent() && !(node.getEscape().get() instanceof StringLiteral)) {\n+                // dynamic escape\n+                return Optional.empty();\n+            }\n+\n+            Type type = typeAnalyzer.getType(session, types, node.getValue());\n+            if (!(type instanceof VarcharType)) {\n+                // not varchar\n+                return Optional.empty();\n+            }\n+            VarcharType varcharType = (VarcharType) type;\n+\n+            Symbol symbol = Symbol.from(node.getValue());\n+            Slice pattern = ((StringLiteral) node.getPattern()).getSlice();\n+            Optional<Slice> escape = node.getEscape()\n+                    .map(StringLiteral.class::cast)\n+                    .map(StringLiteral::getSlice);\n+\n+            int patternConstantPrefixBytes = LikeFunctions.patternConstantPrefixBytes(pattern, escape);\n+            if (patternConstantPrefixBytes == pattern.length()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMjM5OQ==", "bodyText": "This comment is redundant. It'd be useful to, instead, explain why only varchar is supported (the only other option is char)", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421212399", "createdAt": "2020-05-07T03:07:08Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "diffHunk": "@@ -857,6 +867,88 @@ protected ExtractionResult visitBetweenPredicate(BetweenPredicate node, Boolean\n                     new ComparisonExpression(LESS_THAN_OR_EQUAL, node.getValue(), node.getMax())), complement);\n         }\n \n+        @Override\n+        protected ExtractionResult visitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            Optional<ExtractionResult> result = tryVisitLikePredicate(node, complement);\n+            if (result.isPresent()) {\n+                return result.get();\n+            }\n+            return super.visitLikePredicate(node, complement);\n+        }\n+\n+        private Optional<ExtractionResult> tryVisitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            if (!(node.getValue() instanceof SymbolReference)) {\n+                // LIKE not on a symbol\n+                return Optional.empty();\n+            }\n+\n+            if (!(node.getPattern() instanceof StringLiteral)) {\n+                // dyamic pattern\n+                return Optional.empty();\n+            }\n+\n+            if (node.getEscape().isPresent() && !(node.getEscape().get() instanceof StringLiteral)) {\n+                // dynamic escape\n+                return Optional.empty();\n+            }\n+\n+            Type type = typeAnalyzer.getType(session, types, node.getValue());\n+            if (!(type instanceof VarcharType)) {\n+                // not varchar", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMzcwNQ==", "bodyText": "This comment confused me at first reading. I thought it meant that the prefix had to be all ASCII, but the code below says otherwise (i.e., find the last ASCII character).", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421213705", "createdAt": "2020-05-07T03:12:22Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "diffHunk": "@@ -857,6 +867,88 @@ protected ExtractionResult visitBetweenPredicate(BetweenPredicate node, Boolean\n                     new ComparisonExpression(LESS_THAN_OR_EQUAL, node.getValue(), node.getMax())), complement);\n         }\n \n+        @Override\n+        protected ExtractionResult visitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            Optional<ExtractionResult> result = tryVisitLikePredicate(node, complement);\n+            if (result.isPresent()) {\n+                return result.get();\n+            }\n+            return super.visitLikePredicate(node, complement);\n+        }\n+\n+        private Optional<ExtractionResult> tryVisitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            if (!(node.getValue() instanceof SymbolReference)) {\n+                // LIKE not on a symbol\n+                return Optional.empty();\n+            }\n+\n+            if (!(node.getPattern() instanceof StringLiteral)) {\n+                // dyamic pattern\n+                return Optional.empty();\n+            }\n+\n+            if (node.getEscape().isPresent() && !(node.getEscape().get() instanceof StringLiteral)) {\n+                // dynamic escape\n+                return Optional.empty();\n+            }\n+\n+            Type type = typeAnalyzer.getType(session, types, node.getValue());\n+            if (!(type instanceof VarcharType)) {\n+                // not varchar\n+                return Optional.empty();\n+            }\n+            VarcharType varcharType = (VarcharType) type;\n+\n+            Symbol symbol = Symbol.from(node.getValue());\n+            Slice pattern = ((StringLiteral) node.getPattern()).getSlice();\n+            Optional<Slice> escape = node.getEscape()\n+                    .map(StringLiteral.class::cast)\n+                    .map(StringLiteral::getSlice);\n+\n+            int patternConstantPrefixBytes = LikeFunctions.patternConstantPrefixBytes(pattern, escape);\n+            if (patternConstantPrefixBytes == pattern.length()) {\n+                Slice literal = LikeFunctions.unescapeLiteralLikePattern(pattern, escape);\n+                ValueSet valueSet;\n+                if (varcharType.isUnbounded() || countCodePoints(literal) <= varcharType.getBoundedLength()) {\n+                    valueSet = ValueSet.of(type, literal);\n+                }\n+                else {\n+                    // impossible to satisfy\n+                    valueSet = ValueSet.none(type);\n+                }\n+                Domain domain = Domain.create(complementIfNecessary(valueSet, complement), false);\n+                return Optional.of(new ExtractionResult(TupleDomain.withColumnDomains(ImmutableMap.of(symbol, domain)), TRUE_LITERAL));\n+            }\n+\n+            if (complement || patternConstantPrefixBytes == 0) {\n+                // TODO\n+                return Optional.empty();\n+            }\n+\n+            Slice constantPrefix = LikeFunctions.unescapeLiteralLikePattern(pattern.slice(0, patternConstantPrefixBytes), escape);\n+\n+            int lastIncrementable = -1;\n+            for (int position = 0; position < constantPrefix.length(); position += lengthOfCodePoint(constantPrefix, position)) {\n+                // stay within ASCII to be on the safe side with connectors TODO remove this limitation", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 111}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46cd3c97b7326b25e5ab28e1a7fec2ac4759d976", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/46cd3c97b7326b25e5ab28e1a7fec2ac4759d976", "committedDate": "2020-05-07T10:31:44Z", "message": "Operate on Slice directly"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a16d750f741276be360cac50d61998d6fb659841", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/a16d750f741276be360cac50d61998d6fb659841", "committedDate": "2020-05-07T10:31:44Z", "message": "Add patternConstantPrefixBytes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f903a8c7edc30f0d2c4dc684a85e16976d1cdcd", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/5f903a8c7edc30f0d2c4dc684a85e16976d1cdcd", "committedDate": "2020-05-07T10:31:44Z", "message": "Use JDK Predicate interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3ceb7d707298f794c3c255c9d2a802bac0e2bd1", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/f3ceb7d707298f794c3c255c9d2a802bac0e2bd1", "committedDate": "2020-05-07T10:31:44Z", "message": "Fix indentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7df815e4b662175d8ee6c7c65b111cbf9c67f75", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/d7df815e4b662175d8ee6c7c65b111cbf9c67f75", "committedDate": "2020-05-07T10:31:44Z", "message": "Translate LIKE predicate to Domain"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "d7df815e4b662175d8ee6c7c65b111cbf9c67f75", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/d7df815e4b662175d8ee6c7c65b111cbf9c67f75", "committedDate": "2020-05-07T10:31:44Z", "message": "Translate LIKE predicate to Domain"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1378, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}