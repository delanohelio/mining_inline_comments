{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMxNDQ0MDQ4", "number": 3970, "title": "Simplify function binding", "bodyText": "", "createdAt": "2020-06-08T23:12:35Z", "url": "https://github.com/trinodb/trino/pull/3970", "merged": true, "mergeCommit": {"oid": "677d2251dfe4167ad81c3e023d27ddfb4d87dda9"}, "closed": true, "closedAt": "2020-07-30T05:16:56Z", "author": {"login": "dain"}, "timelineItems": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcpbqpqABqjM0MjI3NTAxNzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc534T3gBqjM2MDE5MzQ2MDQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MjEyMDM5", "url": "https://github.com/trinodb/trino/pull/3970#pullrequestreview-429212039", "createdAt": "2020-06-11T19:15:53Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxOToxNTo1M1rOGirOpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxOToyODozN1rOGirn5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxMzAzMQ==", "bodyText": "I removed these methods in an earlier PR because of the case-sensitivity issues. The names in the map can't be used without consideration for case-insensitive matching. There were a bunch of places that were copying the map and then doing lookups, which breaks that assumption. I haven't looked at how they're used in this PR, but we should think about that.", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439013031", "createdAt": "2020-06-11T19:15:53Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/BoundVariables.java", "diffHunk": "@@ -43,6 +43,11 @@ public BoundVariables(Map<String, Type> typeVariables, Map<String, Long> longVar\n                 .collect(toImmutableSortedMap(CASE_INSENSITIVE_ORDER, Map.Entry::getKey, Map.Entry::getValue));\n     }\n \n+    public Map<String, Type> getTypeVariables()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxODU4Ng==", "bodyText": "List", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439018586", "createdAt": "2020-06-11T19:26:51Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ScalarFunctionImplementation.java", "diffHunk": "@@ -158,9 +159,14 @@ public MethodHandle getMethodHandle()\n             return instanceFactory;\n         }\n \n-        public boolean hasSession()\n+        public ImmutableList<Optional<Class<?>>> getLambdaInterfaces()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxODk4NA==", "bodyText": "Each argument on a separate line", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439018984", "createdAt": "2020-06-11T19:27:39Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/metadata/TestPolymorphicScalarFunction.java", "diffHunk": "@@ -106,14 +109,16 @@ public void testSelectsMultipleChoiceWithBlockPosition()\n \n         ScalarFunctionImplementation functionImplementation = function.specialize(SHORT_DECIMAL_BOUND_VARIABLES, 2, METADATA);\n \n-        assertEquals(functionImplementation.getAllChoices().size(), 2);\n-        assertEquals(functionImplementation.getAllChoices().get(0).getArgumentProperties(), Collections.nCopies(2, valueTypeArgumentProperty(USE_NULL_FLAG)));\n-        assertEquals(functionImplementation.getAllChoices().get(1).getArgumentProperties(), Collections.nCopies(2, valueTypeArgumentProperty(BLOCK_AND_POSITION)));\n+        assertEquals(functionImplementation.getChoices().size(), 2);\n+        assertEquals(functionImplementation.getChoices().get(0).getInvocationConvention(),\n+                new InvocationConvention(ImmutableList.of(NULL_FLAG, NULL_FLAG), FAIL_ON_NULL, false, false));\n+        assertEquals(functionImplementation.getChoices().get(1).getInvocationConvention(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxOTQ5NQ==", "bodyText": "List.copyOf", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439019495", "createdAt": "2020-06-11T19:28:37Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/function/InvocationConvention.java", "diffHunk": "@@ -28,7 +33,7 @@ public InvocationConvention(\n             boolean supportsSession,\n             boolean supportsInstanceFactory)\n     {\n-        this.argumentConventionList = argumentConventionList;\n+        this.argumentConventionList = Collections.unmodifiableList(new ArrayList<>(requireNonNull(argumentConventionList, \"argumentConventionList is null\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 18}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5OTEyOTQz", "url": "https://github.com/trinodb/trino/pull/3970#pullrequestreview-429912943", "createdAt": "2020-06-12T17:20:23Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxOToyOToxOFrOGjPYoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMjoxODo0N1rOGjVMCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwNTQwOA==", "bodyText": "What does it mean for this to change from RETURN_NULL_ON_NULL to NEVER_NULL?", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439605408", "createdAt": "2020-06-12T19:29:18Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/PolymorphicScalarFunctionBuilder.java", "diffHunk": "@@ -272,33 +274,33 @@ private ChoiceBuilder(Class<?> clazz, Signature signature)\n         public ChoiceBuilder implementation(Function<MethodsGroupBuilder, MethodsGroupBuilder> methodsGroupSpecification)\n         {\n             // if the argumentProperties is not set yet. We assume it is set to the default value.\n-            if (argumentProperties == null) {\n-                argumentProperties = nCopies(signature.getArgumentTypes().size(), valueTypeArgumentProperty(RETURN_NULL_ON_NULL));\n+            if (argumentConventions == null) {\n+                argumentConventions = nCopies(signature.getArgumentTypes().size(), NEVER_NULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYzMjA5Nw==", "bodyText": "What's the purpose of \"optional\" dependencies?", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439632097", "createdAt": "2020-06-12T20:38:45Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/FunctionDependencyDeclaration.java", "diffHunk": "@@ -0,0 +1,357 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.metadata;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.spi.function.OperatorType;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.sql.tree.QualifiedName;\n+\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class FunctionDependencyDeclaration\n+{\n+    public static final FunctionDependencyDeclaration NO_DEPENDENCIES = builder().build();\n+\n+    private final Set<TypeSignature> typeDependencies;\n+    private final Set<FunctionDependency> functionDependencies;\n+    private final Set<OperatorDependency> operatorDependencies;\n+    private final Set<CastDependency> castDependencies;\n+\n+    public static FunctionDependencyDeclarationBuilder builder()\n+    {\n+        return new FunctionDependencyDeclarationBuilder();\n+    }\n+\n+    private FunctionDependencyDeclaration(\n+            Set<TypeSignature> typeDependencies,\n+            Set<FunctionDependency> functionDependencies,\n+            Set<OperatorDependency> operatorDependencies,\n+            Set<CastDependency> castDependencies)\n+    {\n+        this.typeDependencies = ImmutableSet.copyOf(requireNonNull(typeDependencies, \"typeDependencies is null\"));\n+        this.functionDependencies = ImmutableSet.copyOf(requireNonNull(functionDependencies, \"functionDependencies is null\"));\n+        this.operatorDependencies = ImmutableSet.copyOf(requireNonNull(operatorDependencies, \"operatorDependencies is null\"));\n+        this.castDependencies = ImmutableSet.copyOf(requireNonNull(castDependencies, \"castDependencies is null\"));\n+    }\n+\n+    public Set<TypeSignature> getTypeDependencies()\n+    {\n+        return typeDependencies;\n+    }\n+\n+    public Set<FunctionDependency> getFunctionDependencies()\n+    {\n+        return functionDependencies;\n+    }\n+\n+    public Set<OperatorDependency> getOperatorDependencies()\n+    {\n+        return operatorDependencies;\n+    }\n+\n+    public Set<CastDependency> getCastDependencies()\n+    {\n+        return castDependencies;\n+    }\n+\n+    public static final class FunctionDependencyDeclarationBuilder\n+    {\n+        private final Set<TypeSignature> typeDependencies = new LinkedHashSet<>();\n+        private final Set<FunctionDependency> functionDependencies = new LinkedHashSet<>();\n+        private final Set<OperatorDependency> operatorDependencies = new LinkedHashSet<>();\n+        private final Set<CastDependency> castDependencies = new LinkedHashSet<>();\n+\n+        private FunctionDependencyDeclarationBuilder() {}\n+\n+        public FunctionDependencyDeclarationBuilder addType(TypeSignature typeSignature)\n+        {\n+            typeDependencies.add(typeSignature);\n+            return this;\n+        }\n+\n+        public FunctionDependencyDeclarationBuilder addFunction(QualifiedName name, List<Type> parameterTypes)\n+        {\n+            functionDependencies.add(new FunctionDependency(name, parameterTypes.stream()\n+                    .map(Type::getTypeSignature)\n+                    .collect(toImmutableList()), false));\n+            return this;\n+        }\n+\n+        public FunctionDependencyDeclarationBuilder addFunctionSignature(QualifiedName name, List<TypeSignature> parameterTypes)\n+        {\n+            functionDependencies.add(new FunctionDependency(name, parameterTypes, false));\n+            return this;\n+        }\n+\n+        public FunctionDependencyDeclarationBuilder addOptionalFunction(QualifiedName name, List<Type> parameterTypes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NTE4MQ==", "bodyText": "\"dependent\" conveys that those types and functions depend on this instance. Call them typeDependencies and functionDependencies, instead. There are other places where this should be applied, too.", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439685181", "createdAt": "2020-06-13T00:06:42Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/FunctionDependencies.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.metadata;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.function.OperatorType;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.sql.tree.QualifiedName;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.metadata.Signature.isOperatorName;\n+import static io.prestosql.metadata.Signature.unmangleOperator;\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Function.identity;\n+\n+public class FunctionDependencies\n+{\n+    private final Metadata metadata;\n+    private final Set<Type> types;\n+    private final Map<FunctionKey, ResolvedFunction> functions;\n+    private final Map<OperatorKey, ResolvedFunction> operators;\n+    private final Map<CastKey, ResolvedFunction> casts;\n+\n+    public FunctionDependencies(Metadata metadata, Collection<Type> dependentType, Collection<ResolvedFunction> dependentFunctions)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjAzMg==", "bodyText": "Make this instanceof TimestampWithTimeZoneType so that it works with the upcoming parametric timestamp w/ tz support", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439686032", "createdAt": "2020-06-13T00:13:05Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/FormatFunction.java", "diffHunk": "@@ -111,13 +109,50 @@ private FormatFunction()\n     }\n \n     @Override\n-    public ScalarFunctionImplementation specialize(FunctionBinding functionBinding, Metadata metadata)\n+    public FunctionDependencyDeclaration getFunctionDependencies(FunctionBinding functionBinding)\n+    {\n+        FunctionDependencyDeclarationBuilder builder = FunctionDependencyDeclaration.builder();\n+        functionBinding.getTypeVariable(\"T\").getTypeParameters()\n+                .forEach(type -> addDependencies(builder, type));\n+        return builder.build();\n+    }\n+\n+    private static void addDependencies(FunctionDependencyDeclarationBuilder builder, Type type)\n+    {\n+        if (type.equals(UNKNOWN) ||\n+                type.equals(BOOLEAN) ||\n+                type.equals(TINYINT) ||\n+                type.equals(SMALLINT) ||\n+                type.equals(INTEGER) ||\n+                type.equals(BIGINT) ||\n+                type.equals(REAL) ||\n+                type.equals(DOUBLE) ||\n+                type.equals(DATE) ||\n+                type.equals(TIMESTAMP_WITH_TIME_ZONE) ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NzkxMg==", "bodyText": "What's the purpose of this call?", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439687912", "createdAt": "2020-06-13T00:26:22Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java", "diffHunk": "@@ -1646,6 +1647,7 @@ public WindowFunctionSupplier getWindowFunctionImplementation(ResolvedFunction r\n     @Override\n     public InternalAggregationFunction getAggregateFunctionImplementation(ResolvedFunction resolvedFunction)\n     {\n+        getAggregationFunctionMetadata(resolvedFunction);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NTM1MQ==", "bodyText": "Each argument on a separate line", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439695351", "createdAt": "2020-06-13T01:15:02Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/ParametricAggregation.java", "diffHunk": "@@ -109,6 +110,33 @@ private static void declareDependencies(FunctionBinding functionBinding, Functio\n         }\n     }\n \n+    @Override\n+    public List<TypeSignature> getIntermediateType(FunctionBinding functionBinding, FunctionDependencies functionDependencies)\n+    {\n+        // Find implementation matching arguments\n+        AggregationImplementation concreteImplementation = findMatchingImplementation(functionBinding.getBoundSignature());\n+\n+        // Build state factory and serializer\n+        Type serializedType;\n+        Optional<MethodHandle> stateSerializerFactory = concreteImplementation.getStateSerializerFactory();\n+        if (stateSerializerFactory.isPresent()) {\n+            try {\n+                MethodHandle factoryHandle = bindDependencies(stateSerializerFactory.get(), concreteImplementation.getStateSerializerFactoryDependencies(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NTQwOA==", "bodyText": "stateClass", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439695408", "createdAt": "2020-06-13T01:15:27Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/minmaxby/AbstractMinMaxBy.java", "diffHunk": "@@ -124,6 +124,21 @@ public FunctionDependencyDeclaration getFunctionDependencies(FunctionBinding fun\n                 .build();\n     }\n \n+    @Override\n+    public List<TypeSignature> getIntermediateType(FunctionBinding functionBinding)\n+    {\n+        Type keyType = functionBinding.getTypeVariable(\"K\");\n+        Type valueType = functionBinding.getTypeVariable(\"V\");\n+\n+        Class<?> stateClazz = getStateClass(keyType.getJavaType(), valueType.getJavaType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NTc1MA==", "bodyText": "Why is this method being added again vs the first commit in the list? Is there a commit in the middle that deletes it by mistake?", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439695750", "createdAt": "2020-06-13T01:19:02Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/BoundVariables.java", "diffHunk": "@@ -157,6 +157,11 @@ public boolean containsTypeVariable(String variableName)\n             return containsValue(typeVariables, variableName);\n         }\n \n+        public Map<String, Type> getTypeVariables()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NTkzOA==", "bodyText": "Does this do a case-insensitive comparison? It's not clear. BTW, this is one of the cases I was referring to in my comment in the first commit regarding exposing getTypeVariables. It's easy to get it wrong (or it's confusing, at a minimum)", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439695938", "createdAt": "2020-06-13T01:20:55Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/SignatureBinder.java", "diffHunk": "@@ -185,6 +185,108 @@ public static TypeSignature applyBoundVariables(TypeSignature typeSignature, Bou\n         return new TypeSignature(baseType, parameters);\n     }\n \n+    public static BoundVariables extractBoundVariables(BoundSignature boundSignature, Signature declaredSignature)\n+    {\n+        requireNonNull(declaredSignature, \"declaredSignature is null\");\n+        requireNonNull(boundSignature, \"boundSignature is null\");\n+\n+        checkNoLiteralVariableUsageAcrossTypes(declaredSignature);\n+\n+        Map<String, TypeVariableConstraint> typeVariableConstraints = declaredSignature.getTypeVariableConstraints().stream()\n+                    .collect(toImmutableSortedMap(CASE_INSENSITIVE_ORDER, TypeVariableConstraint::getName, identity()));\n+\n+        boolean variableArity = declaredSignature.isVariableArity();\n+        List<TypeSignature> formalTypeSignatures = declaredSignature.getArgumentTypes();\n+        if (variableArity) {\n+            verifyBoundSignature(boundSignature.getArgumentTypes().size() >= formalTypeSignatures.size() - 1, boundSignature, declaredSignature);\n+            formalTypeSignatures = expandVarargFormalTypeSignature(formalTypeSignatures, boundSignature.getArgumentTypes().size());\n+        }\n+\n+        verifyBoundSignature(formalTypeSignatures.size() == boundSignature.getArgumentTypes().size(), boundSignature, declaredSignature);\n+\n+        BoundVariables.Builder bindings = BoundVariables.builder();\n+        for (int i = 0; i < formalTypeSignatures.size(); i++) {\n+            extractBoundVariables(boundSignature, declaredSignature, typeVariableConstraints, bindings, boundSignature.getArgumentTypes().get(i), formalTypeSignatures.get(i));\n+        }\n+        extractBoundVariables(boundSignature, declaredSignature, typeVariableConstraints, bindings, boundSignature.getReturnType(), declaredSignature.getReturnType());\n+\n+        verifyBoundSignature(bindings.getTypeVariables().keySet().equals(typeVariableConstraints.keySet()), boundSignature, declaredSignature);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5ODYxMw==", "bodyText": "dependentFunctions -> functionDependencies, or just dependencies", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439698613", "createdAt": "2020-06-13T01:53:12Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/gen/BetweenCodeGenerator.java", "diffHunk": "@@ -48,6 +53,20 @@ public BetweenCodeGenerator(SpecialForm specialForm)\n         value = arguments.get(0);\n         min = arguments.get(1);\n         max = arguments.get(2);\n+\n+        checkArgument(specialForm.getDependentFunctions().size() == 1);\n+        lessThanOrEqual = getDependentOperator(specialForm.getDependentFunctions(), LESS_THAN_OR_EQUAL);\n+    }\n+\n+    private static ResolvedFunction getDependentOperator(Collection<ResolvedFunction> dependentFunctions, OperatorType operator)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5ODgzNg==", "bodyText": "getOperatorDependency", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439698836", "createdAt": "2020-06-13T01:55:26Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/gen/BetweenCodeGenerator.java", "diffHunk": "@@ -48,6 +53,20 @@ public BetweenCodeGenerator(SpecialForm specialForm)\n         value = arguments.get(0);\n         min = arguments.get(1);\n         max = arguments.get(2);\n+\n+        checkArgument(specialForm.getDependentFunctions().size() == 1);\n+        lessThanOrEqual = getDependentOperator(specialForm.getDependentFunctions(), LESS_THAN_OR_EQUAL);\n+    }\n+\n+    private static ResolvedFunction getDependentOperator(Collection<ResolvedFunction> dependentFunctions, OperatorType operator)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5ODYxMw=="}, "originalCommit": null, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5OTA1OA==", "bodyText": "This function (or variants of it) are repeated in multiple places. I'd add a static getOperatorDependency(...) to ResolvedFunction and replace all these usages.", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439699058", "createdAt": "2020-06-13T01:58:09Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/gen/NullIfCodeGenerator.java", "diffHunk": "@@ -37,13 +44,48 @@\n     private final RowExpression first;\n     private final RowExpression second;\n \n+    private final ResolvedFunction equalsFunction;\n+    private final Optional<ResolvedFunction> firstCast;\n+    private final Optional<ResolvedFunction> secondCast;\n+\n     public NullIfCodeGenerator(SpecialForm specialForm)\n     {\n         requireNonNull(specialForm, \"specialForm is null\");\n         checkArgument(specialForm.getArguments().size() == 2);\n \n         first = specialForm.getArguments().get(0);\n         second = specialForm.getArguments().get(1);\n+\n+        List<ResolvedFunction> dependentFunctions = specialForm.getDependentFunctions();\n+        checkArgument(dependentFunctions.size() <= 3);\n+        equalsFunction = getEqualsFunction(dependentFunctions);\n+        firstCast = getCastFunction(dependentFunctions, first.getType(), equalsFunction.getSignature().getArgumentTypes().get(0));\n+        secondCast = getCastFunction(dependentFunctions, second.getType(), equalsFunction.getSignature().getArgumentTypes().get(0));\n+    }\n+\n+    private static ResolvedFunction getEqualsFunction(Collection<ResolvedFunction> dependentFunctions)\n+    {\n+        String mangleOperatorName = Signature.mangleOperatorName(EQUAL);\n+        for (ResolvedFunction resolvedFunction : dependentFunctions) {\n+            if (resolvedFunction.getSignature().getName().equals(mangleOperatorName)) {\n+                return resolvedFunction;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Expected an equals function\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5OTMzNg==", "bodyText": "This method name is confusing. I can't tell (without reading the code) whether it's \"is NOT_EQUALS or HASH_CODE operator\" or \"is not EQUALS or HASH_CODE operator\". Maybe reverse the order to clarify: isNotHashCodeOrEqualsOperator", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439699336", "createdAt": "2020-06-13T02:02:25Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/FunctionRegistry.java", "diffHunk": "@@ -706,6 +718,16 @@ public final synchronized void addFunctions(List<? extends SqlFunction> function\n         this.functions = new FunctionMap(this.functions, functions);\n     }\n \n+    private static boolean isNotEqualsOrHashCodeOperator(SqlFunction function)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMDI0OQ==", "bodyText": "What if there was an equals operator with a different convention? (Unless we don't yet support that, in which case, add a comment or TODO)", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439700249", "createdAt": "2020-06-13T02:15:41Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java", "diffHunk": "@@ -1449,6 +1457,30 @@ public void verifyComparableOrderableContract()\n         }\n     }\n \n+    private static boolean hasEqualsMethod(Type type)\n+    {\n+        try {\n+            OperatorInvoker equalsOperator = type.getEqualsOperator(simpleConvention(NULLABLE_RETURN, NEVER_NULL, NEVER_NULL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMDQ4OQ==", "bodyText": "How does the desiredCallingConvention come into play here?", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r439700489", "createdAt": "2020-06-13T02:18:47Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/type/JsonType.java", "diffHunk": "@@ -41,6 +52,18 @@ public boolean isComparable()\n         return true;\n     }\n \n+    @Override\n+    public OperatorInvoker getEqualsOperator(InvocationConvention desiredCallingConvention)\n+    {\n+        return EQUALS_OPERATOR;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNzg2NTIx", "url": "https://github.com/trinodb/trino/pull/3970#pullrequestreview-431786521", "createdAt": "2020-06-16T18:31:56Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODozMTo1NlrOGkoMPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNToxMTo0MlrOGlz8wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2MDQxMw==", "bodyText": "This will return null if the element type is not comparable. We should throw instead, as this method should never be called in that case.", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r441060413", "createdAt": "2020-06-16T18:31:56Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/ArrayType.java", "diffHunk": "@@ -54,6 +125,18 @@ public boolean isComparable()\n         return elementType.isComparable();\n     }\n \n+    @Override\n+    public OperatorInvoker getEqualsOperator(InvocationConvention desiredCallingConvention)\n+    {\n+        return equalsOperator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2MTg5Mg==", "bodyText": "indeterminate -> unknown.\n\"indeterminate\" is a term we used to describe a value that when compared to itself returns null.", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r441061892", "createdAt": "2020-06-16T18:34:31Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/ArrayType.java", "diffHunk": "@@ -212,4 +295,192 @@ public String getDisplayName()\n     {\n         return ARRAY + \"(\" + elementType.getDisplayName() + \")\";\n     }\n+\n+    private static Boolean equalGenericOperator(MethodHandle equalsFunction, Type type, Block leftArray, Block rightArray)\n+    {\n+        if (leftArray.getPositionCount() != rightArray.getPositionCount()) {\n+            return false;\n+        }\n+\n+        boolean indeterminate = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2NjY5OA==", "bodyText": "Same here. This should throw if the element types are not comparable instead of returning null", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r441066698", "createdAt": "2020-06-16T18:42:53Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/MapType.java", "diffHunk": "@@ -102,87 +140,32 @@ public boolean isComparable()\n     }\n \n     @Override\n-    public long hash(Block block, int position)\n+    public OperatorInvoker getEqualsOperator(InvocationConvention desiredCallingConvention)\n     {\n-        Block mapBlock = getObject(block, position);\n-        long result = 0;\n-\n-        for (int i = 0; i < mapBlock.getPositionCount(); i += 2) {\n-            result += hashPosition(keyType, mapBlock, i) ^ hashPosition(valueType, mapBlock, i + 1);\n-        }\n-        return result;\n+        return equalsOperator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2ODExMw==", "bodyText": "This should be squashed with the previous commit", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r441068113", "createdAt": "2020-06-16T18:45:34Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/TimestampOperators.java", "diffHunk": "@@ -180,7 +180,7 @@ public static long hashCode(@SqlType(\"timestamp(p)\") long value)\n         @LiteralParameters(\"p\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3MDE3MA==", "bodyText": "Changes in this file will conflict with the parametric timestamp w/ time zone PR", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r441070170", "createdAt": "2020-06-16T18:49:10Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/type/TimestampWithTimeZoneOperators.java", "diffHunk": "@@ -25,9 +25,7 @@\n import io.prestosql.spi.function.LiteralParameters;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3MjkyMg==", "bodyText": "These should use LongTimestampType", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r441072922", "createdAt": "2020-06-16T18:54:19Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/LongTimestampType.java", "diffHunk": "@@ -31,11 +36,26 @@\n public class LongTimestampType\n         extends TimestampType\n {\n+    private static final OperatorInvoker EQUALS_OPERATOR = lookupStandardEqualsOperator(lookup(), long.class, ShortTimestampType.class, \"equalOperator\");\n+    private static final OperatorInvoker HASH_CODE_OPERATOR = lookupStandardHashCodeOperator(lookup(), long.class, ShortTimestampType.class, \"hashCodeOperator\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTExNDE0NA==", "bodyText": "Why not:\nreturn cache.computeIfAbsent(expectedConvention, convention -> {\n    for (OperatorInvoker invoker : invokers) {\n        InvocationConvention callingConvention = invoker.getCallingConvention();\n        if (functionAdapter.canAdapt(callingConvention, convention)) {\n            return new Adaptation(invoker, convention));\n        }\n    }\n\n    throw new PrestoException(\n            FUNCTION_NOT_FOUND,\n            String.format(\"Function implementation for (%s) can be adapted to convention (%s)\", invokers.get(0).getCallingConvention(), expectedConvention));\n}).get();", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r441114144", "createdAt": "2020-06-16T20:13:02Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/function/ScalarFunctionAdapterCache.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention;\n+import io.prestosql.spi.function.ScalarFunctionAdapter.NullAdaptationPolicy;\n+import io.prestosql.spi.type.Type;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import static io.prestosql.spi.StandardErrorCode.FUNCTION_NOT_FOUND;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BLOCK_POSITION;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NULL_FLAG;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.toList;\n+\n+public class ScalarFunctionAdapterCache\n+{\n+    private final ScalarFunctionAdapter functionAdapter = new ScalarFunctionAdapter(NullAdaptationPolicy.UNSUPPORTED);\n+    private final ConcurrentMap<InvocationConvention, Adaptation> cache = new ConcurrentHashMap<>();\n+\n+    private final List<Type> argumentTypes;\n+    private final List<OperatorInvoker> invokers;\n+\n+    public ScalarFunctionAdapterCache(List<Type> argumentTypes, OperatorInvoker... invokers)\n+    {\n+        this(argumentTypes, Arrays.asList(invokers));\n+    }\n+\n+    public ScalarFunctionAdapterCache(List<Type> argumentTypes, List<OperatorInvoker> invokers)\n+    {\n+        requireNonNull(argumentTypes, \"argumentTypes is null\");\n+        requireNonNull(invokers, \"invokers is null\");\n+        if (invokers.isEmpty()) {\n+            throw new IllegalArgumentException(\"invokers is empty\");\n+        }\n+\n+        this.argumentTypes = Collections.unmodifiableList(new ArrayList<>(argumentTypes));\n+        this.invokers = Collections.unmodifiableList(invokers.stream()\n+                .sorted(Comparator.comparing(ScalarFunctionAdapterCache::getScore).reversed())\n+                .collect(toList()));\n+        invokers.forEach(invoker -> cache.put(invoker.getCallingConvention(), new Adaptation(invoker, invoker.getCallingConvention())));\n+    }\n+\n+    public OperatorInvoker getInvoker(InvocationConvention expectedConvention)\n+    {\n+        Adaptation adaptation = cache.get(expectedConvention);\n+        if (adaptation != null) {\n+            return adaptation.get();\n+        }\n+\n+        for (OperatorInvoker invoker : invokers) {\n+            InvocationConvention callingConvention = invoker.getCallingConvention();\n+            if (functionAdapter.canAdapt(callingConvention, expectedConvention)) {\n+                adaptation = cache.computeIfAbsent(expectedConvention, convention -> new Adaptation(invoker, convention));\n+                return adaptation.get();\n+            }\n+        }\n+\n+        throw new PrestoException(\n+                FUNCTION_NOT_FOUND,\n+                String.format(\"Function implementation for (%s) can be adapted to convention (%s)\", invokers.get(0).getCallingConvention(), expectedConvention));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIyMjg1OA==", "bodyText": "This cache will be per-instance, so every call to createDecimalType(...), createTimestampType(...), new ArrayType(...), etc., will get its own cache. We may want to move the cache to the TypeRegistry and trampoline the calls to get those operators via the registry. If I'm not mistaken, the only places that need access to the operator implementations are within the engine or in contexts where the TypeRegistry is available.", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r441222858", "createdAt": "2020-06-17T01:02:36Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/AbstractType.java", "diffHunk": "@@ -16,19 +16,49 @@\n import io.airlift.slice.Slice;\n import io.prestosql.spi.block.Block;\n import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.function.OperatorInvoker;\n+import io.prestosql.spi.function.ScalarFunctionAdapterCache;\n \n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.List;\n \n+import static java.util.Collections.emptyList;\n+import static java.util.Objects.requireNonNull;\n+\n public abstract class AbstractType\n         implements Type\n {\n     private final TypeSignature signature;\n     private final Class<?> javaType;\n+    private final ScalarFunctionAdapterCache equalsOperatorCache;\n+    private final ScalarFunctionAdapterCache hashCodeOperatorCache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIyNDIyMA==", "bodyText": "Unrelated formatting change", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r441224220", "createdAt": "2020-06-17T01:08:18Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/RowType.java", "diffHunk": "@@ -143,7 +136,9 @@ private static TypeSignature makeSignature(List<Field> fields)\n         }\n \n         List<TypeSignatureParameter> parameters = fields.stream()\n-                .map(field -> TypeSignatureParameter.namedTypeParameter(new NamedTypeSignature(field.getName().map(name -> new RowFieldName(name)), field.getType().getTypeSignature())))\n+                .map(field -> TypeSignatureParameter.namedTypeParameter(new NamedTypeSignature(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIyNjYxOQ==", "bodyText": "Was this a problem before? If so, maybe move it to a separate commit as a performance improvement", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r441226619", "createdAt": "2020-06-17T01:18:09Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/gen/JoinCompiler.java", "diffHunk": "@@ -628,6 +644,26 @@ private void generatePositionNotDistinctFromRowWithPageMethod(\n                     .cast(Block.class);\n             BytecodeExpression rightBlock = page.invoke(\"getBlock\", Block.class, rightChannels.getElement(index));\n             Type type = joinChannelTypes.get(index);\n+\n+            // This is a hack for performance reasons.\n+            // Type.equalTo takes two pairs of Block+position.\n+            // On the other hand, NOT_DISTINCT_FROM is an operator. It takes two Slices.\n+            // As a result, two Slices must be constructed for each invocation, which has a nontrivial cost.\n+            // For these types, their equal semantics is known to be the same as not-distinct-from except for null values.\n+            //\n+            // The plan is to allow scalar function to optionally provide an additional implementation using Block+position calling convention.\n+            // At that point, we'll be able to fully deprecate Type.equalTo (and friends) and remove this hack.\n+            if (type.getJavaType().equals(Slice.class) && (\n+                    type instanceof CharType ||\n+                    type instanceof JsonType ||\n+                    type instanceof DecimalType ||\n+                    type instanceof VarbinaryType ||\n+                    type instanceof VarcharType)) {\n+                body.append(new IfStatement()\n+                        .condition(typeEquals(callSiteBinder, type, leftBlock, leftBlockPosition, rightBlock, rightPosition))\n+                        .ifFalse(constantFalse().ret()));\n+                continue;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIyNzM1OQ==", "bodyText": "I haven't looked closely at how this is being used or whether it's different from before, but these calls are going to be megamorphic, since the equalsOperator can change from instance to instance of BlockEquator.", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r441227359", "createdAt": "2020-06-17T01:21:10Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/type/BlockEquator.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.type;\n+\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.type.Type;\n+\n+import java.lang.invoke.MethodHandle;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Throwables.throwIfUnchecked;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BLOCK_POSITION;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.function.InvocationConvention.simpleConvention;\n+import static io.prestosql.type.TypeUtils.NULL_HASH_CODE;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class BlockEquator\n+{\n+    private final Type type;\n+    private final MethodHandle equalsOperator;\n+    private final MethodHandle hashCodeOperator;\n+\n+    public BlockEquator(Type type)\n+    {\n+        this.type = requireNonNull(type, \"type is null\");\n+        checkArgument(type.isComparable(), \"type is not comparable\");\n+        equalsOperator = type.getEqualsOperator(simpleConvention(NULLABLE_RETURN, BLOCK_POSITION, BLOCK_POSITION)).getMethodHandle();\n+        hashCodeOperator = type.getHashCodeOperator(simpleConvention(FAIL_ON_NULL, BLOCK_POSITION)).getMethodHandle();\n+    }\n+\n+    public boolean equalToNullSafe(Block leftBlock, int leftPosition, Block rightBlock, int rightPosition)\n+    {\n+        boolean leftIsNull = leftBlock.isNull(leftPosition);\n+        boolean rightIsNull = rightBlock.isNull(rightPosition);\n+        if (leftIsNull || rightIsNull) {\n+            return leftIsNull && rightIsNull;\n+        }\n+        return equalTo(leftBlock, leftPosition, rightBlock, rightPosition);\n+    }\n+\n+    public Boolean equalTo(Block leftBlock, int leftPosition, Block rightBlock, int rightPosition)\n+    {\n+        try {\n+            return (Boolean) equalsOperator.invokeExact(leftBlock, leftPosition, rightBlock, rightPosition);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIyNzY1Ng==", "bodyText": "remove commented-out code (or uncomment it)", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r441227656", "createdAt": "2020-06-17T01:22:23Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/operator/scalar/BenchmarkArrayEqualsOperator.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.ResolvedFunction;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.type.ArrayType;\n+import io.prestosql.spi.type.Type;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.Optional;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import static io.prestosql.metadata.MetadataManager.createTestMetadataManager;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BLOCK_POSITION;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.function.OperatorType.EQUAL;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static java.lang.invoke.MethodHandles.lookup;\n+\n+@SuppressWarnings(\"MethodMayBeStatic\")\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(2)\n+@Warmup(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+public class BenchmarkArrayEqualsOperator\n+{\n+    private static final int POSITIONS = 100_000;\n+    private static final int ARRAY_SIZE = 100;\n+    private static final int NUM_TYPES = 4;\n+\n+    @Benchmark\n+    @OperationsPerInvocation(POSITIONS * ARRAY_SIZE * NUM_TYPES)\n+    public long equalsOperator(BenchmarkData data)\n+            throws Throwable\n+    {\n+        return (long) data.getEqualsBlock().invokeExact(data.getLeftBlock(), data.getRightBlock());\n+    }\n+\n+    public static long equalsBlock(MethodHandle hashOperator, Block left, Block right)\n+            throws Throwable\n+    {\n+        int positionCount = left.getPositionCount();\n+        long count = 0;\n+        for (int position = 0; position < positionCount; position++) {\n+            if ((Boolean) hashOperator.invokeExact(left, position, right, position) == Boolean.TRUE) {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    @SuppressWarnings(\"FieldMayBeFinal\")\n+    @State(Scope.Thread)\n+    public static class BenchmarkData\n+    {\n+        @Param({\"BIGINT\", \"VARCHAR\", \"DOUBLE\", \"BOOLEAN\"})\n+        private String type = \"BIGINT\";\n+\n+        private ArrayType arrayType;\n+        private MethodHandle equalsBlock;\n+        private Block leftBlock;\n+        private Block rightBlock;\n+\n+        @Setup\n+        public void setup()\n+        {\n+            Type elementType;\n+            switch (type) {\n+                case \"BIGINT\":\n+                    elementType = BIGINT;\n+                    break;\n+                case \"VARCHAR\":\n+                    elementType = VARCHAR;\n+                    break;\n+                case \"DOUBLE\":\n+                    elementType = DOUBLE;\n+                    break;\n+                case \"BOOLEAN\":\n+                    elementType = BOOLEAN;\n+                    break;\n+                default:\n+                    throw new UnsupportedOperationException();\n+            }\n+            arrayType = new ArrayType(elementType);\n+            Block[] channels = createChannels(POSITIONS, ARRAY_SIZE, arrayType);\n+            leftBlock = channels[0];\n+            rightBlock = channels[1];\n+\n+            Metadata metadata = createTestMetadataManager();\n+            InvocationConvention blockPositionConvention = InvocationConvention.simpleConvention(NULLABLE_RETURN, BLOCK_POSITION, BLOCK_POSITION);\n+            ResolvedFunction resolvedFunction = metadata.resolveOperator(EQUAL, ImmutableList.of(arrayType, arrayType));\n+            MethodHandle hashOperator = metadata.getScalarFunctionInvoker(resolvedFunction, Optional.of(blockPositionConvention)).getMethodHandle();\n+            try {\n+                equalsBlock = lookup().findStatic(BenchmarkArrayEqualsOperator.class, \"equalsBlock\", MethodType.methodType(long.class, MethodHandle.class, Block.class, Block.class))\n+                        .bindTo(hashOperator);\n+            }\n+            catch (NoSuchMethodException | IllegalAccessException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        private static Block[] createChannels(int positionCount, int arraySize, ArrayType arrayType)\n+        {\n+            ThreadLocalRandom random = ThreadLocalRandom.current();\n+            BlockBuilder leftBlockBuilder = arrayType.createBlockBuilder(null, positionCount);\n+            BlockBuilder rightBlockBuilder = arrayType.createBlockBuilder(null, positionCount);\n+            for (int position = 0; position < positionCount; position++) {\n+                BlockBuilder leftEntryBuilder = leftBlockBuilder.beginBlockEntry();\n+                BlockBuilder rightEntryBuilder = rightBlockBuilder.beginBlockEntry();\n+                for (int i = 0; i < arraySize; i++) {\n+                    if (arrayType.getElementType().getJavaType() == long.class) {\n+                        long value = random.nextLong();\n+                        arrayType.getElementType().writeLong(leftEntryBuilder, value);\n+                        arrayType.getElementType().writeLong(rightEntryBuilder, value);\n+                        if (random.nextBoolean()) {\n+                            arrayType.getElementType().writeLong(rightEntryBuilder, value);\n+                        }\n+                        else {\n+                            arrayType.getElementType().writeLong(rightEntryBuilder, random.nextLong());\n+                        }\n+                    }\n+                    else if (arrayType.getElementType().getJavaType() == double.class) {\n+                        double value = random.nextDouble();\n+                        arrayType.getElementType().writeDouble(leftEntryBuilder, value);\n+                        if (random.nextBoolean()) {\n+                            arrayType.getElementType().writeDouble(rightEntryBuilder, value);\n+                        }\n+                        else {\n+                            arrayType.getElementType().writeDouble(rightEntryBuilder, random.nextDouble());\n+                        }\n+                    }\n+                    else if (arrayType.getElementType().getJavaType() == boolean.class) {\n+                        boolean value = random.nextBoolean();\n+                        arrayType.getElementType().writeBoolean(leftEntryBuilder, value);\n+                        if (random.nextBoolean()) {\n+                            arrayType.getElementType().writeBoolean(rightEntryBuilder, value);\n+                        }\n+                        else {\n+                            arrayType.getElementType().writeBoolean(rightEntryBuilder, random.nextBoolean());\n+                        }\n+                    }\n+                    else if (arrayType.getElementType().equals(VARCHAR)) {\n+                        Slice testString = Slices.utf8Slice(\"x\" + random.nextLong(Long.MAX_VALUE));\n+                        arrayType.getElementType().writeSlice(leftEntryBuilder, testString);\n+                        if (random.nextBoolean()) {\n+                            arrayType.getElementType().writeSlice(rightEntryBuilder, testString);\n+                        }\n+                        else {\n+                            arrayType.getElementType().writeSlice(rightEntryBuilder, Slices.utf8Slice(\"x\" + random.nextLong(Long.MAX_VALUE)));\n+                        }\n+                    }\n+                    else {\n+                        throw new UnsupportedOperationException();\n+                    }\n+                }\n+                leftBlockBuilder.closeEntry();\n+                rightBlockBuilder.closeEntry();\n+            }\n+            return new Block[] {leftBlockBuilder.build(), rightBlockBuilder.build()};\n+        }\n+\n+        public Type getArrayType()\n+        {\n+            return arrayType;\n+        }\n+\n+        public MethodHandle getEqualsBlock()\n+        {\n+            return equalsBlock;\n+        }\n+\n+        public Block getLeftBlock()\n+        {\n+            return leftBlock;\n+        }\n+\n+        public Block getRightBlock()\n+        {\n+            return rightBlock;\n+        }\n+    }\n+\n+    public static void main(String[] args)\n+            throws Throwable\n+    {\n+        // assure the benchmarks are valid before running\n+        BenchmarkData data = new BenchmarkData();\n+        data.setup();\n+        new BenchmarkArrayEqualsOperator().equalsOperator(data);\n+\n+        Options options = new OptionsBuilder()\n+                .verbosity(VerboseMode.NORMAL)\n+//                .warmupMode(WarmupMode.BULK)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIyOTU2Nw==", "bodyText": "What's the improvement? Add a description to the commit message", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r441229567", "createdAt": "2020-06-17T01:29:22Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/type/TestRowOperators.java", "diffHunk": "@@ -13,14 +13,15 @@\n  */", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMwMTYzMg==", "bodyText": "HASH_CODE may not be a good way to combine the individual XX64 hashes. Thinking about this more closely, using the previous hash as a seed for the next hash is probably going to be the best approach, but not sure how we can fit that into the current way we compute element hashes.", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r442301632", "createdAt": "2020-06-18T15:11:42Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/ArrayType.java", "diffHunk": "@@ -99,6 +100,15 @@ public ArrayType(Type elementType)\n         return singletonList(new OperatorInvoker(HASH_CODE_CONVENTION, HASH_CODE.bindTo(elementHashCodeOperator)));\n     }\n \n+    private static List<OperatorInvoker> getXxHash64OperatorInvokers(Type elementType)\n+    {\n+        if (!elementType.isComparable()) {\n+            return emptyList();\n+        }\n+        MethodHandle elementHashCodeOperator = elementType.getXxHash64Operator(simpleConvention(FAIL_ON_NULL, BLOCK_POSITION)).getMethodHandle();\n+        return singletonList(new OperatorInvoker(HASH_CODE_CONVENTION, HASH_CODE.bindTo(elementHashCodeOperator)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzA5MDQw", "url": "https://github.com/trinodb/trino/pull/3970#pullrequestreview-433709040", "createdAt": "2020-06-18T23:23:21Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMzoyMzoyMlrOGmDO4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMDo0ODoxMVrOGmEmHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU1MjAzNQ==", "bodyText": "What's the improvement? Can you summarize in the commit message?", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r442552035", "createdAt": "2020-06-18T23:23:22Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/type/AbstractTestType.java", "diffHunk": "@@ -27,13 +27,15 @@\n import io.prestosql.spi.type.Type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2NDI1MQ==", "bodyText": "Where does 64 come from?", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r442564251", "createdAt": "2020-06-19T00:06:59Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/RowType.java", "diffHunk": "@@ -61,15 +63,18 @@\n     private static final InvocationConvention HASH_CODE_CONVENTION = simpleConvention(FAIL_ON_NULL, NEVER_NULL);\n \n     private static final MethodHandle EQUALS;\n-    private static final MethodHandle COMBINE_HASH_CODE;\n-    private static final MethodHandle NULL_SAFE_HASH_CODE;\n+    private static final MethodHandle CHAIN_EQUALS;\n+    private static final MethodHandle HASH_CODE;\n+    private static final MethodHandle CHAIN_HASH_CODE;\n+    private static final int MEGAMORPHIC_FIELD_COUNT = 64;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2OTA3Mw==", "bodyText": "Does fieldIndex correspond to the fields involved in previousFieldsEqual? If so, does it mean we're calling equals on the fields without first checking if either of them is null? That would be a change in behavior compared to the current implementation.", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r442569073", "createdAt": "2020-06-19T00:25:43Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/RowType.java", "diffHunk": "@@ -371,35 +361,92 @@ else if (!result) {\n         return true;\n     }\n \n-    private static long combineHashCode(long previousFieldHashCode, long currentHash)\n+    private static Boolean chainEquals(Boolean previousFieldsEqual, int fieldIndex, MethodHandle nextFieldEqual, Block rightRow, Block leftRow)\n+            throws Throwable\n     {\n-        return 31 * previousFieldHashCode + currentHash;\n+        if (previousFieldsEqual == FALSE) {\n+            return FALSE;\n+        }\n+\n+        if (leftRow.isNull(fieldIndex) || rightRow.isNull(fieldIndex)) {\n+            return null;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU3NDM2Ng==", "bodyText": "This will cause two maps with mixed keys and values to return the same hash:\n{ 'x' -> 1, 'y' -> 2 } vs { 'x' -> 2, 'y' -> 1 }\nIs that intentional?", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r442574366", "createdAt": "2020-06-19T00:48:11Z", "author": {"login": "martint"}, "path": "presto-orc/src/main/java/io/prestosql/orc/ValidationHash.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.orc;\n+\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.type.AbstractLongType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+import static com.google.common.base.Throwables.throwIfUnchecked;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BLOCK_POSITION;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.type.StandardTypes.ARRAY;\n+import static io.prestosql.spi.type.StandardTypes.MAP;\n+import static io.prestosql.spi.type.StandardTypes.ROW;\n+import static io.prestosql.spi.type.TimestampType.TIMESTAMP;\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static java.util.Objects.requireNonNull;\n+\n+class ValidationHash\n+{\n+    // This value is a large arbitrary prime\n+    private static final long NULL_HASH_CODE = 0x6e3efbd56c16a0cbL;\n+\n+    private static final MethodHandle MAP_HASH;\n+    private static final MethodHandle ARRAY_HASH;\n+    private static final MethodHandle ROW_HASH;\n+    private static final MethodHandle TIMESTAMP_HASH;\n+\n+    static {\n+        try {\n+            MAP_HASH = lookup().findStatic(\n+                    ValidationHash.class,\n+                    \"mapSkipNullKeysHash\",\n+                    MethodType.methodType(long.class, Type.class, ValidationHash.class, ValidationHash.class, Block.class, int.class));\n+            ARRAY_HASH = lookup().findStatic(\n+                    ValidationHash.class,\n+                    \"arrayHash\",\n+                    MethodType.methodType(long.class, Type.class, ValidationHash.class, Block.class, int.class));\n+            ROW_HASH = lookup().findStatic(\n+                    ValidationHash.class,\n+                    \"rowHash\",\n+                    MethodType.methodType(long.class, Type.class, ValidationHash[].class, Block.class, int.class));\n+            TIMESTAMP_HASH = lookup().findStatic(\n+                    ValidationHash.class,\n+                    \"timestampHash\",\n+                    MethodType.methodType(long.class, Block.class, int.class));\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static ValidationHash createValidationHash(Type type)\n+    {\n+        requireNonNull(type, \"type is null\");\n+        if (type.getTypeSignature().getBase().equals(MAP)) {\n+            ValidationHash keyHash = createValidationHash(type.getTypeParameters().get(0));\n+            ValidationHash valueHash = createValidationHash(type.getTypeParameters().get(1));\n+            return new ValidationHash(MAP_HASH.bindTo(type).bindTo(keyHash).bindTo(valueHash));\n+        }\n+\n+        if (type.getTypeSignature().getBase().equals(ARRAY)) {\n+            ValidationHash elementHash = createValidationHash(type.getTypeParameters().get(0));\n+            return new ValidationHash(ARRAY_HASH.bindTo(type).bindTo(elementHash));\n+        }\n+\n+        if (type.getTypeSignature().getBase().equals(ROW)) {\n+            ValidationHash[] fieldHashes = type.getTypeParameters().stream()\n+                    .map(ValidationHash::createValidationHash)\n+                    .toArray(ValidationHash[]::new);\n+            return new ValidationHash(ROW_HASH.bindTo(type).bindTo(fieldHashes));\n+        }\n+\n+        if (type.getTypeSignature().getBase().equals(StandardTypes.TIMESTAMP)) {\n+            return new ValidationHash(TIMESTAMP_HASH);\n+        }\n+\n+        return new ValidationHash(type.getHashCodeOperator(InvocationConvention.simpleConvention(FAIL_ON_NULL, BLOCK_POSITION)).getMethodHandle());\n+    }\n+\n+    private final MethodHandle hashCodeOperator;\n+\n+    private ValidationHash(MethodHandle hashCodeOperator)\n+    {\n+        this.hashCodeOperator = requireNonNull(hashCodeOperator, \"hashCodeOperator is null\");\n+    }\n+\n+    public long hash(Block block, int position)\n+    {\n+        if (block.isNull(position)) {\n+            return NULL_HASH_CODE;\n+        }\n+        try {\n+            return (long) hashCodeOperator.invokeExact(block, position);\n+        }\n+        catch (Throwable throwable) {\n+            throwIfUnchecked(throwable);\n+            throw new RuntimeException(throwable);\n+        }\n+    }\n+\n+    private static long mapSkipNullKeysHash(Type type, ValidationHash keyHash, ValidationHash valueHash, Block block, int position)\n+    {\n+        Block mapBlock = (Block) type.getObject(block, position);\n+        long hash = 0;\n+        for (int i = 0; i < mapBlock.getPositionCount(); i += 2) {\n+            if (!mapBlock.isNull(i)) {\n+                hash += keyHash.hash(mapBlock, i);\n+                hash += valueHash.hash(mapBlock, i + 1);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 127}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MjQ0NDI1", "url": "https://github.com/trinodb/trino/pull/3970#pullrequestreview-455244425", "createdAt": "2020-07-25T00:39:09Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMDozOTowOVrOG3A_rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMDo1ODo1MVrOG4enMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0MTE2Nw==", "bodyText": "Which one?", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r460341167", "createdAt": "2020-07-25T00:39:09Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/operator/scalar/BenchmarkArrayEqualOperator.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.type.ArrayType;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import static io.prestosql.operator.scalar.TypeOperatorBenchmarkUtil.addElement;\n+import static io.prestosql.operator.scalar.TypeOperatorBenchmarkUtil.getEqualBlockMethod;\n+import static io.prestosql.operator.scalar.TypeOperatorBenchmarkUtil.toType;\n+\n+@SuppressWarnings(\"MethodMayBeStatic\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM1MTI1Mw==", "bodyText": "The average is actually 8.5. The random value is between 0 and 5 (inclusive), so the average or the random value is 2.5)", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r460351253", "createdAt": "2020-07-25T02:07:17Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/operator/scalar/TypeOperatorBenchmarkUtil.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.ResolvedFunction;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.function.OperatorType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Base64;\n+import java.util.Optional;\n+import java.util.Random;\n+\n+import static io.prestosql.metadata.MetadataManager.createTestMetadataManager;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BLOCK_POSITION;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static java.lang.invoke.MethodType.methodType;\n+\n+final class TypeOperatorBenchmarkUtil\n+{\n+    private TypeOperatorBenchmarkUtil() {}\n+\n+    private static final MethodHandle EQUAL_BLOCK;\n+    private static final MethodHandle HASH_CODE_BLOCK;\n+\n+    static {\n+        try {\n+            HASH_CODE_BLOCK = lookup().findStatic(TypeOperatorBenchmarkUtil.class, \"hashBlock\", methodType(long.class, MethodHandle.class, Block.class));\n+            EQUAL_BLOCK = lookup().findStatic(TypeOperatorBenchmarkUtil.class, \"equalBlock\", methodType(long.class, MethodHandle.class, Block.class, Block.class));\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static Type toType(String type)\n+    {\n+        switch (type) {\n+            case \"BIGINT\":\n+                return BIGINT;\n+            case \"VARCHAR\":\n+                return VARCHAR;\n+            case \"DOUBLE\":\n+                return DOUBLE;\n+            case \"BOOLEAN\":\n+                return BOOLEAN;\n+            default:\n+                throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    public static MethodHandle getEqualBlockMethod(Type type)\n+    {\n+        Metadata metadata = createTestMetadataManager();\n+        ResolvedFunction resolvedFunction = metadata.resolveOperator(OperatorType.EQUAL, ImmutableList.of(type, type));\n+        InvocationConvention invocationConvention = new InvocationConvention(ImmutableList.of(BLOCK_POSITION, BLOCK_POSITION), NULLABLE_RETURN, false, false);\n+        MethodHandle equalOperator = metadata.getScalarFunctionInvoker(resolvedFunction, Optional.of(invocationConvention)).getMethodHandle();\n+        return EQUAL_BLOCK.bindTo(equalOperator);\n+    }\n+\n+    public static MethodHandle getHashCodeBlockMethod(Type type)\n+    {\n+        Metadata metadata = createTestMetadataManager();\n+        ResolvedFunction resolvedFunction = metadata.resolveOperator(OperatorType.HASH_CODE, ImmutableList.of(type));\n+        InvocationConvention invocationConvention = new InvocationConvention(ImmutableList.of(BLOCK_POSITION), FAIL_ON_NULL, false, false);\n+        MethodHandle hashCodeOperator = metadata.getScalarFunctionInvoker(resolvedFunction, Optional.of(invocationConvention)).getMethodHandle();\n+        return HASH_CODE_BLOCK.bindTo(hashCodeOperator);\n+    }\n+\n+    private static long equalBlock(MethodHandle equalOperator, Block left, Block right)\n+            throws Throwable\n+    {\n+        int positionCount = left.getPositionCount();\n+        long count = 0;\n+        for (int position = 0; position < positionCount; position++) {\n+            if ((Boolean) equalOperator.invokeExact(left, position, right, position) == Boolean.TRUE) {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    private static long hashBlock(MethodHandle hashOperator, Block block)\n+            throws Throwable\n+    {\n+        int positionCount = block.getPositionCount();\n+        long hash = 0;\n+        for (int position = 0; position < positionCount; position++) {\n+            hash += (long) hashOperator.invokeExact(block, position);\n+        }\n+        return hash;\n+    }\n+\n+    public static void addElement(Type type, Random random, BlockBuilder builder)\n+    {\n+        if (type.getJavaType() == long.class) {\n+            type.writeLong(builder, random.nextLong());\n+        }\n+        else if (type.getJavaType() == double.class) {\n+            type.writeDouble(builder, random.nextDouble());\n+        }\n+        else if (type.getJavaType() == boolean.class) {\n+            type.writeBoolean(builder, random.nextBoolean());\n+        }\n+        else if (type.equals(VARCHAR)) {\n+            type.writeSlice(builder, randomSlice(random));\n+        }\n+        else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    public static void addElement(Type type, Random random, BlockBuilder leftBuilder, BlockBuilder rightBuilder, boolean equal)\n+    {\n+        if (type.getJavaType() == long.class) {\n+            long value = random.nextLong();\n+            type.writeLong(leftBuilder, value);\n+            if (equal) {\n+                type.writeLong(rightBuilder, value);\n+            }\n+            else {\n+                type.writeLong(rightBuilder, random.nextLong());\n+            }\n+        }\n+        else if (type.getJavaType() == double.class) {\n+            double value = random.nextDouble();\n+            type.writeDouble(leftBuilder, value);\n+            if (equal) {\n+                type.writeDouble(rightBuilder, value);\n+            }\n+            else {\n+                type.writeDouble(rightBuilder, random.nextDouble());\n+            }\n+        }\n+        else if (type.getJavaType() == boolean.class) {\n+            boolean value = random.nextBoolean();\n+            type.writeBoolean(leftBuilder, value);\n+            if (equal) {\n+                type.writeBoolean(rightBuilder, value);\n+            }\n+            else {\n+                type.writeBoolean(rightBuilder, random.nextBoolean());\n+            }\n+        }\n+        else if (type.equals(VARCHAR)) {\n+            Slice testString = randomSlice(random);\n+            type.writeSlice(leftBuilder, testString);\n+            if (equal) {\n+                type.writeSlice(rightBuilder, testString);\n+            }\n+            else {\n+                type.writeSlice(rightBuilder, randomSlice(random));\n+            }\n+        }\n+        else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    private static Slice randomSlice(Random random)\n+    {\n+        // random bytes with length [6, 12) and average length of 10", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MzkwNA==", "bodyText": "This could use zstd instead.", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r461873904", "createdAt": "2020-07-28T20:57:01Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/ResolvedFunction.java", "diffHunk": "@@ -63,42 +84,61 @@ public FunctionId getFunctionId()\n \n     public QualifiedName toQualifiedName()\n     {\n-        return QualifiedName.of(PREFIX + encodeSimpleSignature(signature) + PREFIX + functionId);\n+        byte[] json = JSON_CODEC.toJsonBytes(this);\n+\n+        // json can be large so use gzip to compress\n+        byte[] compressed = compress(json);\n+\n+        // names are case insensitive, so use base32 instead of base64\n+        String base32 = BaseEncoding.base32Hex().encode(compressed);\n+        // add name so expressions are still readable\n+        return QualifiedName.of(PREFIX + signature.getName() + PREFIX + base32);\n     }\n \n-    public static Optional<ResolvedFunction> fromQualifiedName(QualifiedName name)\n+    private static byte[] compress(byte[] json)\n     {\n-        String data = name.getSuffix();\n+        try {\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            GZIPOutputStream gzipOS = new GZIPOutputStream(out);\n+            gzipOS.write(json);\n+            gzipOS.close();\n+            return out.toByteArray();\n+        }\n+        catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    public static Optional<ResolvedFunction> fromQualifiedName(QualifiedName qualifiedName)\n+    {\n+        String data = qualifiedName.getSuffix();\n         if (!data.startsWith(PREFIX)) {\n             return Optional.empty();\n         }\n         List<String> parts = Splitter.on(PREFIX).splitToList(data.subSequence(1, data.length()));\n-        checkArgument(parts.size() == 2, \"Expected encoded resolved function to contain two parts: %s\", name);\n-        Signature signature = decodeSimpleSignature(parts.get(0));\n-        FunctionId functionId = new FunctionId(parts.get(1));\n-        return Optional.of(new ResolvedFunction(signature, functionId));\n-    }\n+        checkArgument(parts.size() == 2, \"Expected encoded resolved function to contain two parts: %s\", qualifiedName);\n+        String name = parts.get(0);\n \n-    private static String encodeSimpleSignature(Signature signature)\n-    {\n-        List<Object> parts = new ArrayList<>(2 + signature.getArgumentTypes().size());\n-        parts.add(signature.getName());\n-        parts.add(signature.getReturnType());\n-        parts.addAll(signature.getArgumentTypes());\n-        // TODO: this needs to be canonicalized elsewhere\n-        return Joiner.on('|').join(parts).toLowerCase(Locale.US);\n+        String base32 = parts.get(1);\n+        // name may have been lower cased, but decoder requires base64\n+        base32 = base32.toUpperCase(Locale.US);\n+        byte[] compressed = BaseEncoding.base32Hex().decode(base32);\n+\n+        byte[] json = decompress(compressed);\n+        ResolvedFunction resolvedFunction = JSON_CODEC.fromJson(json);\n+        checkArgument(resolvedFunction.getSignature().getName().equalsIgnoreCase(name),\n+                \"Expected decoded function to have name %s, but name is %s\", resolvedFunction.getSignature().getName(), name);\n+        return Optional.of(resolvedFunction);\n     }\n \n-    private static Signature decodeSimpleSignature(String encodedSignature)\n+    private static byte[] decompress(byte[] compressed)\n     {\n-        List<String> parts = Splitter.on('|').splitToList(encodedSignature);\n-        checkArgument(parts.size() >= 2, \"Expected encoded signature to contain at least 2 parts: %s\", encodedSignature);\n-        String name = parts.get(0);\n-        TypeSignature returnType = TypeSignatureTranslator.parseTypeSignature(parts.get(1), ImmutableSet.of());\n-        List<TypeSignature> argumentTypes = parts.subList(2, parts.size()).stream()\n-                .map(part -> TypeSignatureTranslator.parseTypeSignature(part, ImmutableSet.of()))\n-                .collect(toImmutableList());\n-        return new Signature(name, returnType, argumentTypes);\n+        try {\n+            return toByteArray(new GZIPInputStream(new ByteArrayInputStream(compressed)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3NDU3MA==", "bodyText": "base32?", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r461874570", "createdAt": "2020-07-28T20:58:05Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/ResolvedFunction.java", "diffHunk": "@@ -63,42 +84,61 @@ public FunctionId getFunctionId()\n \n     public QualifiedName toQualifiedName()\n     {\n-        return QualifiedName.of(PREFIX + encodeSimpleSignature(signature) + PREFIX + functionId);\n+        byte[] json = JSON_CODEC.toJsonBytes(this);\n+\n+        // json can be large so use gzip to compress\n+        byte[] compressed = compress(json);\n+\n+        // names are case insensitive, so use base32 instead of base64\n+        String base32 = BaseEncoding.base32Hex().encode(compressed);\n+        // add name so expressions are still readable\n+        return QualifiedName.of(PREFIX + signature.getName() + PREFIX + base32);\n     }\n \n-    public static Optional<ResolvedFunction> fromQualifiedName(QualifiedName name)\n+    private static byte[] compress(byte[] json)\n     {\n-        String data = name.getSuffix();\n+        try {\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            GZIPOutputStream gzipOS = new GZIPOutputStream(out);\n+            gzipOS.write(json);\n+            gzipOS.close();\n+            return out.toByteArray();\n+        }\n+        catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    public static Optional<ResolvedFunction> fromQualifiedName(QualifiedName qualifiedName)\n+    {\n+        String data = qualifiedName.getSuffix();\n         if (!data.startsWith(PREFIX)) {\n             return Optional.empty();\n         }\n         List<String> parts = Splitter.on(PREFIX).splitToList(data.subSequence(1, data.length()));\n-        checkArgument(parts.size() == 2, \"Expected encoded resolved function to contain two parts: %s\", name);\n-        Signature signature = decodeSimpleSignature(parts.get(0));\n-        FunctionId functionId = new FunctionId(parts.get(1));\n-        return Optional.of(new ResolvedFunction(signature, functionId));\n-    }\n+        checkArgument(parts.size() == 2, \"Expected encoded resolved function to contain two parts: %s\", qualifiedName);\n+        String name = parts.get(0);\n \n-    private static String encodeSimpleSignature(Signature signature)\n-    {\n-        List<Object> parts = new ArrayList<>(2 + signature.getArgumentTypes().size());\n-        parts.add(signature.getName());\n-        parts.add(signature.getReturnType());\n-        parts.addAll(signature.getArgumentTypes());\n-        // TODO: this needs to be canonicalized elsewhere\n-        return Joiner.on('|').join(parts).toLowerCase(Locale.US);\n+        String base32 = parts.get(1);\n+        // name may have been lower cased, but decoder requires base64", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3NDk5Mw==", "bodyText": "We use Locale.ENGLISH everywhere", "url": "https://github.com/trinodb/trino/pull/3970#discussion_r461874993", "createdAt": "2020-07-28T20:58:51Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/ResolvedFunction.java", "diffHunk": "@@ -63,42 +84,61 @@ public FunctionId getFunctionId()\n \n     public QualifiedName toQualifiedName()\n     {\n-        return QualifiedName.of(PREFIX + encodeSimpleSignature(signature) + PREFIX + functionId);\n+        byte[] json = JSON_CODEC.toJsonBytes(this);\n+\n+        // json can be large so use gzip to compress\n+        byte[] compressed = compress(json);\n+\n+        // names are case insensitive, so use base32 instead of base64\n+        String base32 = BaseEncoding.base32Hex().encode(compressed);\n+        // add name so expressions are still readable\n+        return QualifiedName.of(PREFIX + signature.getName() + PREFIX + base32);\n     }\n \n-    public static Optional<ResolvedFunction> fromQualifiedName(QualifiedName name)\n+    private static byte[] compress(byte[] json)\n     {\n-        String data = name.getSuffix();\n+        try {\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            GZIPOutputStream gzipOS = new GZIPOutputStream(out);\n+            gzipOS.write(json);\n+            gzipOS.close();\n+            return out.toByteArray();\n+        }\n+        catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    public static Optional<ResolvedFunction> fromQualifiedName(QualifiedName qualifiedName)\n+    {\n+        String data = qualifiedName.getSuffix();\n         if (!data.startsWith(PREFIX)) {\n             return Optional.empty();\n         }\n         List<String> parts = Splitter.on(PREFIX).splitToList(data.subSequence(1, data.length()));\n-        checkArgument(parts.size() == 2, \"Expected encoded resolved function to contain two parts: %s\", name);\n-        Signature signature = decodeSimpleSignature(parts.get(0));\n-        FunctionId functionId = new FunctionId(parts.get(1));\n-        return Optional.of(new ResolvedFunction(signature, functionId));\n-    }\n+        checkArgument(parts.size() == 2, \"Expected encoded resolved function to contain two parts: %s\", qualifiedName);\n+        String name = parts.get(0);\n \n-    private static String encodeSimpleSignature(Signature signature)\n-    {\n-        List<Object> parts = new ArrayList<>(2 + signature.getArgumentTypes().size());\n-        parts.add(signature.getName());\n-        parts.add(signature.getReturnType());\n-        parts.addAll(signature.getArgumentTypes());\n-        // TODO: this needs to be canonicalized elsewhere\n-        return Joiner.on('|').join(parts).toLowerCase(Locale.US);\n+        String base32 = parts.get(1);\n+        // name may have been lower cased, but decoder requires base64\n+        base32 = base32.toUpperCase(Locale.US);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 109}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d37e6f1a374007c11ddf95ea7444cddc26c744b7", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/d37e6f1a374007c11ddf95ea7444cddc26c744b7", "committedDate": "2020-07-30T01:12:37Z", "message": "Add equal and hash code benchmarks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4954de7333fb161981be371b43bb417aee0ef69e", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/4954de7333fb161981be371b43bb417aee0ef69e", "committedDate": "2020-07-30T01:12:38Z", "message": "Add FunctionBinding"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24ebb96106abfec87faf7885dd318a3ee14c848d", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/24ebb96106abfec87faf7885dd318a3ee14c848d", "committedDate": "2020-07-30T01:12:39Z", "message": "Remove unused methods and data from ScalarFunctionImplementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4152083fad7d68707053d88b2c0e95f7f34ad849", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/4152083fad7d68707053d88b2c0e95f7f34ad849", "committedDate": "2020-07-30T01:12:39Z", "message": "Remove unused methods and data from InternalAggregationFunction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c74619e56f01c9f0f670fbcbdbbe32c612ecab7c", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/c74619e56f01c9f0f670fbcbdbbe32c612ecab7c", "committedDate": "2020-07-30T01:12:39Z", "message": "Remove old calling convention code from scalars"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b6bb43655abf772242609c5d6d6fd98dd0d720b", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/8b6bb43655abf772242609c5d6d6fd98dd0d720b", "committedDate": "2020-07-30T02:31:29Z", "message": "Simplify resolved function encoding to qualified name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12f98979e071dd90eece8c859e5af813c7dd315c", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/12f98979e071dd90eece8c859e5af813c7dd315c", "committedDate": "2020-07-30T02:38:12Z", "message": "Add BoundSignature for use in ResolvedFunction\n\nBoundSignature contains real types and can not be generic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6aceee83c985d47327044abb2d67b203ac5d6435", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/6aceee83c985d47327044abb2d67b203ac5d6435", "committedDate": "2020-07-30T02:38:14Z", "message": "Inline SqlScalarFunction builder method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a45ee075a59d5ca11dcb2ee69fdf29922392e543", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/a45ee075a59d5ca11dcb2ee69fdf29922392e543", "committedDate": "2020-07-30T02:38:14Z", "message": "Change scalar function specialize argument to FunctionBinding"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3aa7e9e407e9184c0b98c9211ec581ccd0bbb57c", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/3aa7e9e407e9184c0b98c9211ec581ccd0bbb57c", "committedDate": "2020-07-30T02:38:14Z", "message": "Change window function specialize argument to FunctionBinding"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94e3b7d46d24a0d45af4557a9bc9e2cef6b4c5ca", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/94e3b7d46d24a0d45af4557a9bc9e2cef6b4c5ca", "committedDate": "2020-07-30T02:38:14Z", "message": "Change aggregation specialize argument to FunctionBinding"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c37b21d718fd787f3a62bad55a6b7dcdc615882", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/6c37b21d718fd787f3a62bad55a6b7dcdc615882", "committedDate": "2020-07-30T02:39:05Z", "message": "Add function and type dependencies to ResolvedFunction"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "266d01c066b209bbb79ecdd01259ea290b3a7ceb", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/266d01c066b209bbb79ecdd01259ea290b3a7ceb", "committedDate": "2020-07-30T04:11:01Z", "message": "Replace Metadata with FunctionDependencies in agg and window"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3dc1f5bf6c133c6f5799a9fae01007a390e87e9a", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/3dc1f5bf6c133c6f5799a9fae01007a390e87e9a", "committedDate": "2020-07-30T04:11:02Z", "message": "Move AggregationFunctionMetadata to SqlAggregationFunction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abaf8a4f181b4428601279f5c20a64e4d67e17dd", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/abaf8a4f181b4428601279f5c20a64e4d67e17dd", "committedDate": "2020-07-30T04:11:02Z", "message": "Add SignatureBinder.extractBoundVariables"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f6dd1182d7639b3cf41a45f4d47e109afa9a668", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/9f6dd1182d7639b3cf41a45f4d47e109afa9a668", "committedDate": "2020-07-30T04:11:02Z", "message": "Simplify SpecialForm byte code generators"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2715d2bb13f8f4ef2b6f6204a5552e608381e48e", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/2715d2bb13f8f4ef2b6f6204a5552e608381e48e", "committedDate": "2020-07-30T04:11:03Z", "message": "Add functions dependencies to RowExpression"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5365604e981cc2b25d429340f1740578f4fee7eb", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/5365604e981cc2b25d429340f1740578f4fee7eb", "committedDate": "2020-07-30T04:11:03Z", "message": "Cleanup RowType makeSignature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dfdbdc2bc219956fec6a08093a857fcaa4fd2f8", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/0dfdbdc2bc219956fec6a08093a857fcaa4fd2f8", "committedDate": "2020-07-30T04:11:03Z", "message": "Remove unused function kind from signature builder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6946f65afe593b86610888481342d6c2483c9d6", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/a6946f65afe593b86610888481342d6c2483c9d6", "committedDate": "2020-07-30T04:11:03Z", "message": "Reduce uses of FunctionBinding in getFunctionDependencies"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "339687cc6208b5a51f78d9d37fc6b53c8d380b51", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/339687cc6208b5a51f78d9d37fc6b53c8d380b51", "committedDate": "2020-07-30T04:11:03Z", "message": "Remove SignatureBinder.bindVariables"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdba391a0dc07e5f6326ff519a4b7668371766ac", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/cdba391a0dc07e5f6326ff519a4b7668371766ac", "committedDate": "2020-07-30T04:11:03Z", "message": "Use BoundVariable.Builder in tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "175b9dec9c659a2b224ed03e5d233defb746579d", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/175b9dec9c659a2b224ed03e5d233defb746579d", "committedDate": "2020-07-30T04:11:03Z", "message": "Encapsulate BoundVariables in SignatureBinder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7971b2e8e39117d34ceeb2599fde63b76780f06f", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/7971b2e8e39117d34ceeb2599fde63b76780f06f", "committedDate": "2020-07-30T04:11:03Z", "message": "Remove bulk getters for FunctionBinding type variables"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "7971b2e8e39117d34ceeb2599fde63b76780f06f", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/7971b2e8e39117d34ceeb2599fde63b76780f06f", "committedDate": "2020-07-30T04:11:03Z", "message": "Remove bulk getters for FunctionBinding type variables"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 626, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}