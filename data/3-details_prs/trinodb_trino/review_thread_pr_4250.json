{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwODE2NDA5", "number": 4250, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMjo0MjozNVrOETBvhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMToyMTowM1rOEVobzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4Mzg2OTUwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMjo0MjozNVrOG4iPhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMjo0MjozNVrOG4iPhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkzNDQ3MQ==", "bodyText": "\"in recursive WITH query\"", "url": "https://github.com/trinodb/trino/pull/4250#discussion_r461934471", "createdAt": "2020-07-28T22:42:35Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -2515,42 +2534,274 @@ private void analyzeColumnMask(String currentIdentity, Table table, QualifiedObj\n \n         private Scope analyzeWith(Query node, Optional<Scope> scope)\n         {\n-            // analyze WITH clause\n             if (node.getWith().isEmpty()) {\n                 return createScope(scope);\n             }\n+\n+            // analyze WITH clause\n             With with = node.getWith().get();\n+            Scope.Builder withScopeBuilder = scopeBuilder(scope);\n+\n             if (with.isRecursive()) {\n-                throw semanticException(NOT_SUPPORTED, with, \"Recursive WITH queries are not supported\");\n-            }\n+                // if RECURSIVE is specified, all queries in the WITH list are considered potentially recursive\n+                for (WithQuery withQuery : with.getQueries()) {\n+                    String name = withQuery.getName().getValue().toLowerCase(ENGLISH);\n+                    if (withScopeBuilder.containsNamedQuery(name)) {\n+                        throw semanticException(DUPLICATE_NAMED_QUERY, withQuery, \"WITH query name '%s' specified more than once\", name);\n+                    }\n+                    if (withQuery.getColumnNames().isEmpty()) {\n+                        throw semanticException(MISSING_COLUMN_ALIASES, withQuery, \"missing column aliases in RECURSIVE WITH-query\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4Mzg3MDAzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMjo0Mjo0OVrOG4iP4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMjo0Mjo0OVrOG4iP4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkzNDU2MA==", "bodyText": "nested recursive WITH query", "url": "https://github.com/trinodb/trino/pull/4250#discussion_r461934560", "createdAt": "2020-07-28T22:42:49Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -2515,42 +2534,274 @@ private void analyzeColumnMask(String currentIdentity, Table table, QualifiedObj\n \n         private Scope analyzeWith(Query node, Optional<Scope> scope)\n         {\n-            // analyze WITH clause\n             if (node.getWith().isEmpty()) {\n                 return createScope(scope);\n             }\n+\n+            // analyze WITH clause\n             With with = node.getWith().get();\n+            Scope.Builder withScopeBuilder = scopeBuilder(scope);\n+\n             if (with.isRecursive()) {\n-                throw semanticException(NOT_SUPPORTED, with, \"Recursive WITH queries are not supported\");\n-            }\n+                // if RECURSIVE is specified, all queries in the WITH list are considered potentially recursive\n+                for (WithQuery withQuery : with.getQueries()) {\n+                    String name = withQuery.getName().getValue().toLowerCase(ENGLISH);\n+                    if (withScopeBuilder.containsNamedQuery(name)) {\n+                        throw semanticException(DUPLICATE_NAMED_QUERY, withQuery, \"WITH query name '%s' specified more than once\", name);\n+                    }\n+                    if (withQuery.getColumnNames().isEmpty()) {\n+                        throw semanticException(MISSING_COLUMN_ALIASES, withQuery, \"missing column aliases in RECURSIVE WITH-query\");\n+                    }\n+                    preOrder(withQuery.getQuery())\n+                            .filter(child -> child instanceof With && ((With) child).isRecursive())\n+                            .findFirst()\n+                            .ifPresent(child -> {\n+                                throw semanticException(NESTED_RECURSIVE, child, \"nested RECURSIVE common table expression\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4Mzg3NzQyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMjo0NTo0MFrOG4iUKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMjo0NTo0MFrOG4iUKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkzNTY1OQ==", "bodyText": "typo: parenthesized", "url": "https://github.com/trinodb/trino/pull/4250#discussion_r461935659", "createdAt": "2020-07-28T22:45:40Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -2515,42 +2534,274 @@ private void analyzeColumnMask(String currentIdentity, Table table, QualifiedObj\n \n         private Scope analyzeWith(Query node, Optional<Scope> scope)\n         {\n-            // analyze WITH clause\n             if (node.getWith().isEmpty()) {\n                 return createScope(scope);\n             }\n+\n+            // analyze WITH clause\n             With with = node.getWith().get();\n+            Scope.Builder withScopeBuilder = scopeBuilder(scope);\n+\n             if (with.isRecursive()) {\n-                throw semanticException(NOT_SUPPORTED, with, \"Recursive WITH queries are not supported\");\n-            }\n+                // if RECURSIVE is specified, all queries in the WITH list are considered potentially recursive\n+                for (WithQuery withQuery : with.getQueries()) {\n+                    String name = withQuery.getName().getValue().toLowerCase(ENGLISH);\n+                    if (withScopeBuilder.containsNamedQuery(name)) {\n+                        throw semanticException(DUPLICATE_NAMED_QUERY, withQuery, \"WITH query name '%s' specified more than once\", name);\n+                    }\n+                    if (withQuery.getColumnNames().isEmpty()) {\n+                        throw semanticException(MISSING_COLUMN_ALIASES, withQuery, \"missing column aliases in RECURSIVE WITH-query\");\n+                    }\n+                    preOrder(withQuery.getQuery())\n+                            .filter(child -> child instanceof With && ((With) child).isRecursive())\n+                            .findFirst()\n+                            .ifPresent(child -> {\n+                                throw semanticException(NESTED_RECURSIVE, child, \"nested RECURSIVE common table expression\");\n+                            });\n+                    // check if this is a plain query, expandable query or other recursive query (unsupported)\n+                    // 1. try resolve WITH query as expandable query\n+                    // a) validate shape of the query and location of recursive reference\n+                    if (withQuery.getQuery().getQueryBody() instanceof Union) {\n+                        Union union = (Union) withQuery.getQuery().getQueryBody();\n+                        if (union.getRelations().size() == 2) {\n+                            Relation anchor = union.getRelations().get(0);\n+                            Relation step = union.getRelations().get(1);\n+                            List<Node> anchorReferences = findReferences(anchor, withQuery.getName());\n+                            if (!anchorReferences.isEmpty()) {\n+                                throw semanticException(INVALID_RECURSIVE_REFERENCE, anchorReferences.get(0), \"WITH table name is referenced in the base relation of recursion\");\n+                            }\n+                            // a WITH query is linearly recursive if it has a single recursive reference\n+                            List<Node> stepReferences = findReferences(step, withQuery.getName());\n+                            if (stepReferences.size() > 1) {\n+                                throw semanticException(INVALID_RECURSIVE_REFERENCE, stepReferences.get(1), \"multiple recursive references in the step relation of recursion\");\n+                            }\n+                            if (stepReferences.size() == 1) {\n+                                // search for QuerySpecification in parenthesed subquery", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4Mzk0NDQ2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMzoxNDo0MlrOG4i8Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMzoxNDo0MlrOG4i8Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0NTk1NQ==", "bodyText": "Move this below the block that checks for type compatibility. It doesn't change the outcome, but it's \"logically\" more correct.", "url": "https://github.com/trinodb/trino/pull/4250#discussion_r461945955", "createdAt": "2020-07-28T23:14:42Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -2515,42 +2534,274 @@ private void analyzeColumnMask(String currentIdentity, Table table, QualifiedObj\n \n         private Scope analyzeWith(Query node, Optional<Scope> scope)\n         {\n-            // analyze WITH clause\n             if (node.getWith().isEmpty()) {\n                 return createScope(scope);\n             }\n+\n+            // analyze WITH clause\n             With with = node.getWith().get();\n+            Scope.Builder withScopeBuilder = scopeBuilder(scope);\n+\n             if (with.isRecursive()) {\n-                throw semanticException(NOT_SUPPORTED, with, \"Recursive WITH queries are not supported\");\n-            }\n+                // if RECURSIVE is specified, all queries in the WITH list are considered potentially recursive\n+                for (WithQuery withQuery : with.getQueries()) {\n+                    String name = withQuery.getName().getValue().toLowerCase(ENGLISH);\n+                    if (withScopeBuilder.containsNamedQuery(name)) {\n+                        throw semanticException(DUPLICATE_NAMED_QUERY, withQuery, \"WITH query name '%s' specified more than once\", name);\n+                    }\n+                    if (withQuery.getColumnNames().isEmpty()) {\n+                        throw semanticException(MISSING_COLUMN_ALIASES, withQuery, \"missing column aliases in RECURSIVE WITH-query\");\n+                    }\n+                    preOrder(withQuery.getQuery())\n+                            .filter(child -> child instanceof With && ((With) child).isRecursive())\n+                            .findFirst()\n+                            .ifPresent(child -> {\n+                                throw semanticException(NESTED_RECURSIVE, child, \"nested RECURSIVE common table expression\");\n+                            });\n+                    // check if this is a plain query, expandable query or other recursive query (unsupported)\n+                    // 1. try resolve WITH query as expandable query\n+                    // a) validate shape of the query and location of recursive reference\n+                    if (withQuery.getQuery().getQueryBody() instanceof Union) {\n+                        Union union = (Union) withQuery.getQuery().getQueryBody();\n+                        if (union.getRelations().size() == 2) {\n+                            Relation anchor = union.getRelations().get(0);\n+                            Relation step = union.getRelations().get(1);\n+                            List<Node> anchorReferences = findReferences(anchor, withQuery.getName());\n+                            if (!anchorReferences.isEmpty()) {\n+                                throw semanticException(INVALID_RECURSIVE_REFERENCE, anchorReferences.get(0), \"WITH table name is referenced in the base relation of recursion\");\n+                            }\n+                            // a WITH query is linearly recursive if it has a single recursive reference\n+                            List<Node> stepReferences = findReferences(step, withQuery.getName());\n+                            if (stepReferences.size() > 1) {\n+                                throw semanticException(INVALID_RECURSIVE_REFERENCE, stepReferences.get(1), \"multiple recursive references in the step relation of recursion\");\n+                            }\n+                            if (stepReferences.size() == 1) {\n+                                // search for QuerySpecification in parenthesed subquery\n+                                Relation specification = step;\n+                                while (specification instanceof TableSubquery) {\n+                                    Query query = ((TableSubquery) specification).getQuery();\n+                                    query.getLimit().ifPresent(limit -> {\n+                                        throw semanticException(INVALID_LIMIT_CLAUSE, limit, \"FETCH FIRST / LIMIT clause in the step relation of recursion\");\n+                                    });\n+                                    specification = query.getQueryBody();\n+                                }\n+                                if (!(specification instanceof QuerySpecification) || ((QuerySpecification) specification).getFrom().isEmpty()) {\n+                                    throw semanticException(INVALID_RECURSIVE_REFERENCE, stepReferences.get(0), \"recursive reference outside of FROM clause of the step relation of recursion\");\n+                                }\n+                                Relation from = ((QuerySpecification) specification).getFrom().get();\n+                                List<Node> fromReferences = findReferences(from, withQuery.getName());\n+                                if (fromReferences.size() == 0) {\n+                                    throw semanticException(INVALID_RECURSIVE_REFERENCE, stepReferences.get(0), \"recursive reference outside of FROM clause of the step relation of recursion\");\n+                                }\n \n-            Scope.Builder withScopeBuilder = scopeBuilder(scope);\n-            for (WithQuery withQuery : with.getQueries()) {\n-                Query query = withQuery.getQuery();\n-                process(query, withScopeBuilder.build());\n+                                // b) validate top-level shape of recursive query\n+                                withQuery.getQuery().getWith().ifPresent(innerWith -> {\n+                                    throw semanticException(NOT_SUPPORTED, innerWith, \"immediate WITH clause in recursive query\");\n+                                });\n+                                withQuery.getQuery().getOrderBy().ifPresent(orderBy -> {\n+                                    throw semanticException(NOT_SUPPORTED, orderBy, \"immediate ORDER BY clause in recursive query\");\n+                                });\n+                                withQuery.getQuery().getOffset().ifPresent(offset -> {\n+                                    throw semanticException(NOT_SUPPORTED, offset, \"immediate OFFSET clause in recursive query\");\n+                                });\n+                                withQuery.getQuery().getLimit().ifPresent(limit -> {\n+                                    throw semanticException(INVALID_LIMIT_CLAUSE, limit, \"immediate FETCH FIRST / LIMIT clause in recursive query\");\n+                                });\n+\n+                                // c) validate recursion step has no illegal clauses\n+                                validateFromClauseOfRecursiveTerm(from, withQuery.getName());\n+\n+                                // shape validation complete - process query as expandable query\n+                                Scope parentScope = withScopeBuilder.build();\n+                                // process expandable query -- anchor\n+                                Scope anchorScope = process(anchor, parentScope);\n+                                // set aliases in anchor scope as defined for WITH query. Recursion step will refer to anchor fields by aliases.\n+                                Scope aliasedAnchorScope = setAliases(anchorScope, withQuery.getName(), withQuery.getColumnNames().get());\n+                                // record expandable query base scope for recursion step analysis\n+                                Node recursiveReference = fromReferences.get(0);\n+                                analysis.setExpandableBaseScope(recursiveReference, aliasedAnchorScope);\n+                                // process expandable query -- recursion step\n+                                Scope stepScope = process(step, parentScope);\n+\n+                                // verify anchor and step have matching descriptors\n+                                RelationType anchorType = aliasedAnchorScope.getRelationType().withOnlyVisibleFields();\n+                                RelationType stepType = stepScope.getRelationType().withOnlyVisibleFields();\n+                                if (anchorType.getVisibleFieldCount() != stepType.getVisibleFieldCount()) {\n+                                    throw semanticException(TYPE_MISMATCH, step, \"base and step relations of recursion have different number of fields: %s, %s\", anchorType.getVisibleFieldCount(), stepType.getVisibleFieldCount());\n+                                }\n \n-                String name = withQuery.getName().getValue().toLowerCase(ENGLISH);\n-                if (withScopeBuilder.containsNamedQuery(name)) {\n-                    throw semanticException(DUPLICATE_NAMED_QUERY, withQuery, \"WITH query name '%s' specified more than once\", name);\n-                }\n+                                List<Type> anchorFieldTypes = anchorType.getVisibleFields().stream()\n+                                        .map(Field::getType)\n+                                        .collect(toImmutableList());\n+                                List<Type> stepFieldTypes = stepType.getVisibleFields().stream()\n+                                        .map(Field::getType)\n+                                        .collect(toImmutableList());\n+                                if (!anchorFieldTypes.equals(stepFieldTypes)) {\n+                                    analysis.addRelationCoercion(step, anchorFieldTypes.toArray(Type[]::new));\n+                                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4Mzk1MDA2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMzoxNzoxM1rOG4i_uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNToxODoyMVrOG6lyrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0NjgwOA==", "bodyText": "Improvement for the future: use the corresponding SELECT expression as the \"node\" in the exception so that error highlighting points at the right place. It won't be trivial to do, so let's defer it (add a TODO)", "url": "https://github.com/trinodb/trino/pull/4250#discussion_r461946808", "createdAt": "2020-07-28T23:17:13Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -2515,42 +2534,274 @@ private void analyzeColumnMask(String currentIdentity, Table table, QualifiedObj\n \n         private Scope analyzeWith(Query node, Optional<Scope> scope)\n         {\n-            // analyze WITH clause\n             if (node.getWith().isEmpty()) {\n                 return createScope(scope);\n             }\n+\n+            // analyze WITH clause\n             With with = node.getWith().get();\n+            Scope.Builder withScopeBuilder = scopeBuilder(scope);\n+\n             if (with.isRecursive()) {\n-                throw semanticException(NOT_SUPPORTED, with, \"Recursive WITH queries are not supported\");\n-            }\n+                // if RECURSIVE is specified, all queries in the WITH list are considered potentially recursive\n+                for (WithQuery withQuery : with.getQueries()) {\n+                    String name = withQuery.getName().getValue().toLowerCase(ENGLISH);\n+                    if (withScopeBuilder.containsNamedQuery(name)) {\n+                        throw semanticException(DUPLICATE_NAMED_QUERY, withQuery, \"WITH query name '%s' specified more than once\", name);\n+                    }\n+                    if (withQuery.getColumnNames().isEmpty()) {\n+                        throw semanticException(MISSING_COLUMN_ALIASES, withQuery, \"missing column aliases in RECURSIVE WITH-query\");\n+                    }\n+                    preOrder(withQuery.getQuery())\n+                            .filter(child -> child instanceof With && ((With) child).isRecursive())\n+                            .findFirst()\n+                            .ifPresent(child -> {\n+                                throw semanticException(NESTED_RECURSIVE, child, \"nested RECURSIVE common table expression\");\n+                            });\n+                    // check if this is a plain query, expandable query or other recursive query (unsupported)\n+                    // 1. try resolve WITH query as expandable query\n+                    // a) validate shape of the query and location of recursive reference\n+                    if (withQuery.getQuery().getQueryBody() instanceof Union) {\n+                        Union union = (Union) withQuery.getQuery().getQueryBody();\n+                        if (union.getRelations().size() == 2) {\n+                            Relation anchor = union.getRelations().get(0);\n+                            Relation step = union.getRelations().get(1);\n+                            List<Node> anchorReferences = findReferences(anchor, withQuery.getName());\n+                            if (!anchorReferences.isEmpty()) {\n+                                throw semanticException(INVALID_RECURSIVE_REFERENCE, anchorReferences.get(0), \"WITH table name is referenced in the base relation of recursion\");\n+                            }\n+                            // a WITH query is linearly recursive if it has a single recursive reference\n+                            List<Node> stepReferences = findReferences(step, withQuery.getName());\n+                            if (stepReferences.size() > 1) {\n+                                throw semanticException(INVALID_RECURSIVE_REFERENCE, stepReferences.get(1), \"multiple recursive references in the step relation of recursion\");\n+                            }\n+                            if (stepReferences.size() == 1) {\n+                                // search for QuerySpecification in parenthesed subquery\n+                                Relation specification = step;\n+                                while (specification instanceof TableSubquery) {\n+                                    Query query = ((TableSubquery) specification).getQuery();\n+                                    query.getLimit().ifPresent(limit -> {\n+                                        throw semanticException(INVALID_LIMIT_CLAUSE, limit, \"FETCH FIRST / LIMIT clause in the step relation of recursion\");\n+                                    });\n+                                    specification = query.getQueryBody();\n+                                }\n+                                if (!(specification instanceof QuerySpecification) || ((QuerySpecification) specification).getFrom().isEmpty()) {\n+                                    throw semanticException(INVALID_RECURSIVE_REFERENCE, stepReferences.get(0), \"recursive reference outside of FROM clause of the step relation of recursion\");\n+                                }\n+                                Relation from = ((QuerySpecification) specification).getFrom().get();\n+                                List<Node> fromReferences = findReferences(from, withQuery.getName());\n+                                if (fromReferences.size() == 0) {\n+                                    throw semanticException(INVALID_RECURSIVE_REFERENCE, stepReferences.get(0), \"recursive reference outside of FROM clause of the step relation of recursion\");\n+                                }\n \n-            Scope.Builder withScopeBuilder = scopeBuilder(scope);\n-            for (WithQuery withQuery : with.getQueries()) {\n-                Query query = withQuery.getQuery();\n-                process(query, withScopeBuilder.build());\n+                                // b) validate top-level shape of recursive query\n+                                withQuery.getQuery().getWith().ifPresent(innerWith -> {\n+                                    throw semanticException(NOT_SUPPORTED, innerWith, \"immediate WITH clause in recursive query\");\n+                                });\n+                                withQuery.getQuery().getOrderBy().ifPresent(orderBy -> {\n+                                    throw semanticException(NOT_SUPPORTED, orderBy, \"immediate ORDER BY clause in recursive query\");\n+                                });\n+                                withQuery.getQuery().getOffset().ifPresent(offset -> {\n+                                    throw semanticException(NOT_SUPPORTED, offset, \"immediate OFFSET clause in recursive query\");\n+                                });\n+                                withQuery.getQuery().getLimit().ifPresent(limit -> {\n+                                    throw semanticException(INVALID_LIMIT_CLAUSE, limit, \"immediate FETCH FIRST / LIMIT clause in recursive query\");\n+                                });\n+\n+                                // c) validate recursion step has no illegal clauses\n+                                validateFromClauseOfRecursiveTerm(from, withQuery.getName());\n+\n+                                // shape validation complete - process query as expandable query\n+                                Scope parentScope = withScopeBuilder.build();\n+                                // process expandable query -- anchor\n+                                Scope anchorScope = process(anchor, parentScope);\n+                                // set aliases in anchor scope as defined for WITH query. Recursion step will refer to anchor fields by aliases.\n+                                Scope aliasedAnchorScope = setAliases(anchorScope, withQuery.getName(), withQuery.getColumnNames().get());\n+                                // record expandable query base scope for recursion step analysis\n+                                Node recursiveReference = fromReferences.get(0);\n+                                analysis.setExpandableBaseScope(recursiveReference, aliasedAnchorScope);\n+                                // process expandable query -- recursion step\n+                                Scope stepScope = process(step, parentScope);\n+\n+                                // verify anchor and step have matching descriptors\n+                                RelationType anchorType = aliasedAnchorScope.getRelationType().withOnlyVisibleFields();\n+                                RelationType stepType = stepScope.getRelationType().withOnlyVisibleFields();\n+                                if (anchorType.getVisibleFieldCount() != stepType.getVisibleFieldCount()) {\n+                                    throw semanticException(TYPE_MISMATCH, step, \"base and step relations of recursion have different number of fields: %s, %s\", anchorType.getVisibleFieldCount(), stepType.getVisibleFieldCount());\n+                                }\n \n-                String name = withQuery.getName().getValue().toLowerCase(ENGLISH);\n-                if (withScopeBuilder.containsNamedQuery(name)) {\n-                    throw semanticException(DUPLICATE_NAMED_QUERY, withQuery, \"WITH query name '%s' specified more than once\", name);\n-                }\n+                                List<Type> anchorFieldTypes = anchorType.getVisibleFields().stream()\n+                                        .map(Field::getType)\n+                                        .collect(toImmutableList());\n+                                List<Type> stepFieldTypes = stepType.getVisibleFields().stream()\n+                                        .map(Field::getType)\n+                                        .collect(toImmutableList());\n+                                if (!anchorFieldTypes.equals(stepFieldTypes)) {\n+                                    analysis.addRelationCoercion(step, anchorFieldTypes.toArray(Type[]::new));\n+                                }\n+\n+                                for (int i = 0; i < anchorFieldTypes.size(); i++) {\n+                                    if (!typeCoercion.canCoerce(stepFieldTypes.get(i), anchorFieldTypes.get(i))) {\n+                                        throw semanticException(\n+                                                TYPE_MISMATCH,\n+                                                step,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA4OTc3Mg==", "bodyText": "The number of the first mismatching column is included in the error message. It is not always possible to highlight the exact select expression, because it might be e.g. a \"row all fields\" expression. I'm not sure what I should write in the TODO.", "url": "https://github.com/trinodb/trino/pull/4250#discussion_r464089772", "createdAt": "2020-08-02T15:18:21Z", "author": {"login": "kasiafi"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -2515,42 +2534,274 @@ private void analyzeColumnMask(String currentIdentity, Table table, QualifiedObj\n \n         private Scope analyzeWith(Query node, Optional<Scope> scope)\n         {\n-            // analyze WITH clause\n             if (node.getWith().isEmpty()) {\n                 return createScope(scope);\n             }\n+\n+            // analyze WITH clause\n             With with = node.getWith().get();\n+            Scope.Builder withScopeBuilder = scopeBuilder(scope);\n+\n             if (with.isRecursive()) {\n-                throw semanticException(NOT_SUPPORTED, with, \"Recursive WITH queries are not supported\");\n-            }\n+                // if RECURSIVE is specified, all queries in the WITH list are considered potentially recursive\n+                for (WithQuery withQuery : with.getQueries()) {\n+                    String name = withQuery.getName().getValue().toLowerCase(ENGLISH);\n+                    if (withScopeBuilder.containsNamedQuery(name)) {\n+                        throw semanticException(DUPLICATE_NAMED_QUERY, withQuery, \"WITH query name '%s' specified more than once\", name);\n+                    }\n+                    if (withQuery.getColumnNames().isEmpty()) {\n+                        throw semanticException(MISSING_COLUMN_ALIASES, withQuery, \"missing column aliases in RECURSIVE WITH-query\");\n+                    }\n+                    preOrder(withQuery.getQuery())\n+                            .filter(child -> child instanceof With && ((With) child).isRecursive())\n+                            .findFirst()\n+                            .ifPresent(child -> {\n+                                throw semanticException(NESTED_RECURSIVE, child, \"nested RECURSIVE common table expression\");\n+                            });\n+                    // check if this is a plain query, expandable query or other recursive query (unsupported)\n+                    // 1. try resolve WITH query as expandable query\n+                    // a) validate shape of the query and location of recursive reference\n+                    if (withQuery.getQuery().getQueryBody() instanceof Union) {\n+                        Union union = (Union) withQuery.getQuery().getQueryBody();\n+                        if (union.getRelations().size() == 2) {\n+                            Relation anchor = union.getRelations().get(0);\n+                            Relation step = union.getRelations().get(1);\n+                            List<Node> anchorReferences = findReferences(anchor, withQuery.getName());\n+                            if (!anchorReferences.isEmpty()) {\n+                                throw semanticException(INVALID_RECURSIVE_REFERENCE, anchorReferences.get(0), \"WITH table name is referenced in the base relation of recursion\");\n+                            }\n+                            // a WITH query is linearly recursive if it has a single recursive reference\n+                            List<Node> stepReferences = findReferences(step, withQuery.getName());\n+                            if (stepReferences.size() > 1) {\n+                                throw semanticException(INVALID_RECURSIVE_REFERENCE, stepReferences.get(1), \"multiple recursive references in the step relation of recursion\");\n+                            }\n+                            if (stepReferences.size() == 1) {\n+                                // search for QuerySpecification in parenthesed subquery\n+                                Relation specification = step;\n+                                while (specification instanceof TableSubquery) {\n+                                    Query query = ((TableSubquery) specification).getQuery();\n+                                    query.getLimit().ifPresent(limit -> {\n+                                        throw semanticException(INVALID_LIMIT_CLAUSE, limit, \"FETCH FIRST / LIMIT clause in the step relation of recursion\");\n+                                    });\n+                                    specification = query.getQueryBody();\n+                                }\n+                                if (!(specification instanceof QuerySpecification) || ((QuerySpecification) specification).getFrom().isEmpty()) {\n+                                    throw semanticException(INVALID_RECURSIVE_REFERENCE, stepReferences.get(0), \"recursive reference outside of FROM clause of the step relation of recursion\");\n+                                }\n+                                Relation from = ((QuerySpecification) specification).getFrom().get();\n+                                List<Node> fromReferences = findReferences(from, withQuery.getName());\n+                                if (fromReferences.size() == 0) {\n+                                    throw semanticException(INVALID_RECURSIVE_REFERENCE, stepReferences.get(0), \"recursive reference outside of FROM clause of the step relation of recursion\");\n+                                }\n \n-            Scope.Builder withScopeBuilder = scopeBuilder(scope);\n-            for (WithQuery withQuery : with.getQueries()) {\n-                Query query = withQuery.getQuery();\n-                process(query, withScopeBuilder.build());\n+                                // b) validate top-level shape of recursive query\n+                                withQuery.getQuery().getWith().ifPresent(innerWith -> {\n+                                    throw semanticException(NOT_SUPPORTED, innerWith, \"immediate WITH clause in recursive query\");\n+                                });\n+                                withQuery.getQuery().getOrderBy().ifPresent(orderBy -> {\n+                                    throw semanticException(NOT_SUPPORTED, orderBy, \"immediate ORDER BY clause in recursive query\");\n+                                });\n+                                withQuery.getQuery().getOffset().ifPresent(offset -> {\n+                                    throw semanticException(NOT_SUPPORTED, offset, \"immediate OFFSET clause in recursive query\");\n+                                });\n+                                withQuery.getQuery().getLimit().ifPresent(limit -> {\n+                                    throw semanticException(INVALID_LIMIT_CLAUSE, limit, \"immediate FETCH FIRST / LIMIT clause in recursive query\");\n+                                });\n+\n+                                // c) validate recursion step has no illegal clauses\n+                                validateFromClauseOfRecursiveTerm(from, withQuery.getName());\n+\n+                                // shape validation complete - process query as expandable query\n+                                Scope parentScope = withScopeBuilder.build();\n+                                // process expandable query -- anchor\n+                                Scope anchorScope = process(anchor, parentScope);\n+                                // set aliases in anchor scope as defined for WITH query. Recursion step will refer to anchor fields by aliases.\n+                                Scope aliasedAnchorScope = setAliases(anchorScope, withQuery.getName(), withQuery.getColumnNames().get());\n+                                // record expandable query base scope for recursion step analysis\n+                                Node recursiveReference = fromReferences.get(0);\n+                                analysis.setExpandableBaseScope(recursiveReference, aliasedAnchorScope);\n+                                // process expandable query -- recursion step\n+                                Scope stepScope = process(step, parentScope);\n+\n+                                // verify anchor and step have matching descriptors\n+                                RelationType anchorType = aliasedAnchorScope.getRelationType().withOnlyVisibleFields();\n+                                RelationType stepType = stepScope.getRelationType().withOnlyVisibleFields();\n+                                if (anchorType.getVisibleFieldCount() != stepType.getVisibleFieldCount()) {\n+                                    throw semanticException(TYPE_MISMATCH, step, \"base and step relations of recursion have different number of fields: %s, %s\", anchorType.getVisibleFieldCount(), stepType.getVisibleFieldCount());\n+                                }\n \n-                String name = withQuery.getName().getValue().toLowerCase(ENGLISH);\n-                if (withScopeBuilder.containsNamedQuery(name)) {\n-                    throw semanticException(DUPLICATE_NAMED_QUERY, withQuery, \"WITH query name '%s' specified more than once\", name);\n-                }\n+                                List<Type> anchorFieldTypes = anchorType.getVisibleFields().stream()\n+                                        .map(Field::getType)\n+                                        .collect(toImmutableList());\n+                                List<Type> stepFieldTypes = stepType.getVisibleFields().stream()\n+                                        .map(Field::getType)\n+                                        .collect(toImmutableList());\n+                                if (!anchorFieldTypes.equals(stepFieldTypes)) {\n+                                    analysis.addRelationCoercion(step, anchorFieldTypes.toArray(Type[]::new));\n+                                }\n+\n+                                for (int i = 0; i < anchorFieldTypes.size(); i++) {\n+                                    if (!typeCoercion.canCoerce(stepFieldTypes.get(i), anchorFieldTypes.get(i))) {\n+                                        throw semanticException(\n+                                                TYPE_MISMATCH,\n+                                                step,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0NjgwOA=="}, "originalCommit": null, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4Mzk5OTI4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMzozOToxM1rOG4jcSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMzo1MjozMlrOG4js4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDEyMw==", "bodyText": "The many levels of nesting and this continue here make it hard to follow the flow of the code. One possible way of reorganizing this is to move this whole section to a new method and have it return \"true\" if it was able to handle the recursive query. Then, the code below would do:\nif (!handled) {\n   // 2. \n   ...\n   // process plain query\n   ...\n}\n\nLet me play with the code a bit to see if I can come up with something better.", "url": "https://github.com/trinodb/trino/pull/4250#discussion_r461954123", "createdAt": "2020-07-28T23:39:13Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -2515,42 +2534,274 @@ private void analyzeColumnMask(String currentIdentity, Table table, QualifiedObj\n \n         private Scope analyzeWith(Query node, Optional<Scope> scope)\n         {\n-            // analyze WITH clause\n             if (node.getWith().isEmpty()) {\n                 return createScope(scope);\n             }\n+\n+            // analyze WITH clause\n             With with = node.getWith().get();\n+            Scope.Builder withScopeBuilder = scopeBuilder(scope);\n+\n             if (with.isRecursive()) {\n-                throw semanticException(NOT_SUPPORTED, with, \"Recursive WITH queries are not supported\");\n-            }\n+                // if RECURSIVE is specified, all queries in the WITH list are considered potentially recursive\n+                for (WithQuery withQuery : with.getQueries()) {\n+                    String name = withQuery.getName().getValue().toLowerCase(ENGLISH);\n+                    if (withScopeBuilder.containsNamedQuery(name)) {\n+                        throw semanticException(DUPLICATE_NAMED_QUERY, withQuery, \"WITH query name '%s' specified more than once\", name);\n+                    }\n+                    if (withQuery.getColumnNames().isEmpty()) {\n+                        throw semanticException(MISSING_COLUMN_ALIASES, withQuery, \"missing column aliases in RECURSIVE WITH-query\");\n+                    }\n+                    preOrder(withQuery.getQuery())\n+                            .filter(child -> child instanceof With && ((With) child).isRecursive())\n+                            .findFirst()\n+                            .ifPresent(child -> {\n+                                throw semanticException(NESTED_RECURSIVE, child, \"nested RECURSIVE common table expression\");\n+                            });\n+                    // check if this is a plain query, expandable query or other recursive query (unsupported)\n+                    // 1. try resolve WITH query as expandable query\n+                    // a) validate shape of the query and location of recursive reference\n+                    if (withQuery.getQuery().getQueryBody() instanceof Union) {\n+                        Union union = (Union) withQuery.getQuery().getQueryBody();\n+                        if (union.getRelations().size() == 2) {\n+                            Relation anchor = union.getRelations().get(0);\n+                            Relation step = union.getRelations().get(1);\n+                            List<Node> anchorReferences = findReferences(anchor, withQuery.getName());\n+                            if (!anchorReferences.isEmpty()) {\n+                                throw semanticException(INVALID_RECURSIVE_REFERENCE, anchorReferences.get(0), \"WITH table name is referenced in the base relation of recursion\");\n+                            }\n+                            // a WITH query is linearly recursive if it has a single recursive reference\n+                            List<Node> stepReferences = findReferences(step, withQuery.getName());\n+                            if (stepReferences.size() > 1) {\n+                                throw semanticException(INVALID_RECURSIVE_REFERENCE, stepReferences.get(1), \"multiple recursive references in the step relation of recursion\");\n+                            }\n+                            if (stepReferences.size() == 1) {\n+                                // search for QuerySpecification in parenthesed subquery\n+                                Relation specification = step;\n+                                while (specification instanceof TableSubquery) {\n+                                    Query query = ((TableSubquery) specification).getQuery();\n+                                    query.getLimit().ifPresent(limit -> {\n+                                        throw semanticException(INVALID_LIMIT_CLAUSE, limit, \"FETCH FIRST / LIMIT clause in the step relation of recursion\");\n+                                    });\n+                                    specification = query.getQueryBody();\n+                                }\n+                                if (!(specification instanceof QuerySpecification) || ((QuerySpecification) specification).getFrom().isEmpty()) {\n+                                    throw semanticException(INVALID_RECURSIVE_REFERENCE, stepReferences.get(0), \"recursive reference outside of FROM clause of the step relation of recursion\");\n+                                }\n+                                Relation from = ((QuerySpecification) specification).getFrom().get();\n+                                List<Node> fromReferences = findReferences(from, withQuery.getName());\n+                                if (fromReferences.size() == 0) {\n+                                    throw semanticException(INVALID_RECURSIVE_REFERENCE, stepReferences.get(0), \"recursive reference outside of FROM clause of the step relation of recursion\");\n+                                }\n \n-            Scope.Builder withScopeBuilder = scopeBuilder(scope);\n-            for (WithQuery withQuery : with.getQueries()) {\n-                Query query = withQuery.getQuery();\n-                process(query, withScopeBuilder.build());\n+                                // b) validate top-level shape of recursive query\n+                                withQuery.getQuery().getWith().ifPresent(innerWith -> {\n+                                    throw semanticException(NOT_SUPPORTED, innerWith, \"immediate WITH clause in recursive query\");\n+                                });\n+                                withQuery.getQuery().getOrderBy().ifPresent(orderBy -> {\n+                                    throw semanticException(NOT_SUPPORTED, orderBy, \"immediate ORDER BY clause in recursive query\");\n+                                });\n+                                withQuery.getQuery().getOffset().ifPresent(offset -> {\n+                                    throw semanticException(NOT_SUPPORTED, offset, \"immediate OFFSET clause in recursive query\");\n+                                });\n+                                withQuery.getQuery().getLimit().ifPresent(limit -> {\n+                                    throw semanticException(INVALID_LIMIT_CLAUSE, limit, \"immediate FETCH FIRST / LIMIT clause in recursive query\");\n+                                });\n+\n+                                // c) validate recursion step has no illegal clauses\n+                                validateFromClauseOfRecursiveTerm(from, withQuery.getName());\n+\n+                                // shape validation complete - process query as expandable query\n+                                Scope parentScope = withScopeBuilder.build();\n+                                // process expandable query -- anchor\n+                                Scope anchorScope = process(anchor, parentScope);\n+                                // set aliases in anchor scope as defined for WITH query. Recursion step will refer to anchor fields by aliases.\n+                                Scope aliasedAnchorScope = setAliases(anchorScope, withQuery.getName(), withQuery.getColumnNames().get());\n+                                // record expandable query base scope for recursion step analysis\n+                                Node recursiveReference = fromReferences.get(0);\n+                                analysis.setExpandableBaseScope(recursiveReference, aliasedAnchorScope);\n+                                // process expandable query -- recursion step\n+                                Scope stepScope = process(step, parentScope);\n+\n+                                // verify anchor and step have matching descriptors\n+                                RelationType anchorType = aliasedAnchorScope.getRelationType().withOnlyVisibleFields();\n+                                RelationType stepType = stepScope.getRelationType().withOnlyVisibleFields();\n+                                if (anchorType.getVisibleFieldCount() != stepType.getVisibleFieldCount()) {\n+                                    throw semanticException(TYPE_MISMATCH, step, \"base and step relations of recursion have different number of fields: %s, %s\", anchorType.getVisibleFieldCount(), stepType.getVisibleFieldCount());\n+                                }\n \n-                String name = withQuery.getName().getValue().toLowerCase(ENGLISH);\n-                if (withScopeBuilder.containsNamedQuery(name)) {\n-                    throw semanticException(DUPLICATE_NAMED_QUERY, withQuery, \"WITH query name '%s' specified more than once\", name);\n-                }\n+                                List<Type> anchorFieldTypes = anchorType.getVisibleFields().stream()\n+                                        .map(Field::getType)\n+                                        .collect(toImmutableList());\n+                                List<Type> stepFieldTypes = stepType.getVisibleFields().stream()\n+                                        .map(Field::getType)\n+                                        .collect(toImmutableList());\n+                                if (!anchorFieldTypes.equals(stepFieldTypes)) {\n+                                    analysis.addRelationCoercion(step, anchorFieldTypes.toArray(Type[]::new));\n+                                }\n+\n+                                for (int i = 0; i < anchorFieldTypes.size(); i++) {\n+                                    if (!typeCoercion.canCoerce(stepFieldTypes.get(i), anchorFieldTypes.get(i))) {\n+                                        throw semanticException(\n+                                                TYPE_MISMATCH,\n+                                                step,\n+                                                \"recursion step relation output type (%s) is not coercible to recursion base relation output type (%s) at column %s\",\n+                                                stepFieldTypes.get(i),\n+                                                anchorFieldTypes.get(i),\n+                                                i + 1);\n+                                    }\n+                                }\n \n-                // check if all or none of the columns are explicitly alias\n-                if (withQuery.getColumnNames().isPresent()) {\n-                    List<Identifier> columnNames = withQuery.getColumnNames().get();\n-                    RelationType queryDescriptor = analysis.getOutputDescriptor(query);\n-                    if (columnNames.size() != queryDescriptor.getVisibleFieldCount()) {\n-                        throw semanticException(MISMATCHED_COLUMN_ALIASES, withQuery, \"WITH column alias list has %s entries but WITH query(%s) has %s columns\", columnNames.size(), name, queryDescriptor.getVisibleFieldCount());\n+                                analysis.setScope(withQuery.getQuery(), aliasedAnchorScope);\n+                                analysis.registerExpandableQuery(withQuery.getQuery(), recursiveReference);\n+                                withScopeBuilder.withNamedQuery(name, withQuery);\n+                                continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1ODM2OA==", "bodyText": "Also, instead of splitting the method into two sections based on with.isRecursive(), it seems we should be able to structure in a similar manner to this and avoid a bit of duplication:\nWith with = node.getWith().get();\nScope.Builder withScopeBuilder = scopeBuilder(scope);\n\nfor (WithQuery withQuery : with.getQueries()) {\n    String name = withQuery.getName().getValue().toLowerCase(ENGLISH);\n    if (withScopeBuilder.containsNamedQuery(name)) {\n        throw semanticException(DUPLICATE_NAMED_QUERY, withQuery, \"WITH query name '%s' specified more than once\", name);\n    }\n\n    boolean isRecursive = false;\n    if (with.isRecursive()) {\n        isRecursive = tryProcessRecursiveQuery(...);\n    }\n\n    if (!isRecursive) {\n        // check if all or none of the columns are explicitly alias\n        Query query = withQuery.getQuery();\n        if (withQuery.getColumnNames().isPresent()) {\n            validateColumnAliases(withQuery.getColumnNames().get(), analysis.getOutputDescriptor(query).getVisibleFieldCount());\n        }\n\n        process(query, withScopeBuilder.build());\n        withScopeBuilder.withNamedQuery(name, withQuery);\n    }\n}\n\nScope withScope = withScopeBuilder.build();\nanalysis.setScope(with, withScope);\nreturn withScope;\nPossibly, even this for the inner condition, but I'm not a big fan of the side-effect in the if condition:\n...\nif (!with.isRecursive() || !tryProcessRecursiveQuery(...)) {\n   ...\n}\n...", "url": "https://github.com/trinodb/trino/pull/4250#discussion_r461958368", "createdAt": "2020-07-28T23:52:32Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -2515,42 +2534,274 @@ private void analyzeColumnMask(String currentIdentity, Table table, QualifiedObj\n \n         private Scope analyzeWith(Query node, Optional<Scope> scope)\n         {\n-            // analyze WITH clause\n             if (node.getWith().isEmpty()) {\n                 return createScope(scope);\n             }\n+\n+            // analyze WITH clause\n             With with = node.getWith().get();\n+            Scope.Builder withScopeBuilder = scopeBuilder(scope);\n+\n             if (with.isRecursive()) {\n-                throw semanticException(NOT_SUPPORTED, with, \"Recursive WITH queries are not supported\");\n-            }\n+                // if RECURSIVE is specified, all queries in the WITH list are considered potentially recursive\n+                for (WithQuery withQuery : with.getQueries()) {\n+                    String name = withQuery.getName().getValue().toLowerCase(ENGLISH);\n+                    if (withScopeBuilder.containsNamedQuery(name)) {\n+                        throw semanticException(DUPLICATE_NAMED_QUERY, withQuery, \"WITH query name '%s' specified more than once\", name);\n+                    }\n+                    if (withQuery.getColumnNames().isEmpty()) {\n+                        throw semanticException(MISSING_COLUMN_ALIASES, withQuery, \"missing column aliases in RECURSIVE WITH-query\");\n+                    }\n+                    preOrder(withQuery.getQuery())\n+                            .filter(child -> child instanceof With && ((With) child).isRecursive())\n+                            .findFirst()\n+                            .ifPresent(child -> {\n+                                throw semanticException(NESTED_RECURSIVE, child, \"nested RECURSIVE common table expression\");\n+                            });\n+                    // check if this is a plain query, expandable query or other recursive query (unsupported)\n+                    // 1. try resolve WITH query as expandable query\n+                    // a) validate shape of the query and location of recursive reference\n+                    if (withQuery.getQuery().getQueryBody() instanceof Union) {\n+                        Union union = (Union) withQuery.getQuery().getQueryBody();\n+                        if (union.getRelations().size() == 2) {\n+                            Relation anchor = union.getRelations().get(0);\n+                            Relation step = union.getRelations().get(1);\n+                            List<Node> anchorReferences = findReferences(anchor, withQuery.getName());\n+                            if (!anchorReferences.isEmpty()) {\n+                                throw semanticException(INVALID_RECURSIVE_REFERENCE, anchorReferences.get(0), \"WITH table name is referenced in the base relation of recursion\");\n+                            }\n+                            // a WITH query is linearly recursive if it has a single recursive reference\n+                            List<Node> stepReferences = findReferences(step, withQuery.getName());\n+                            if (stepReferences.size() > 1) {\n+                                throw semanticException(INVALID_RECURSIVE_REFERENCE, stepReferences.get(1), \"multiple recursive references in the step relation of recursion\");\n+                            }\n+                            if (stepReferences.size() == 1) {\n+                                // search for QuerySpecification in parenthesed subquery\n+                                Relation specification = step;\n+                                while (specification instanceof TableSubquery) {\n+                                    Query query = ((TableSubquery) specification).getQuery();\n+                                    query.getLimit().ifPresent(limit -> {\n+                                        throw semanticException(INVALID_LIMIT_CLAUSE, limit, \"FETCH FIRST / LIMIT clause in the step relation of recursion\");\n+                                    });\n+                                    specification = query.getQueryBody();\n+                                }\n+                                if (!(specification instanceof QuerySpecification) || ((QuerySpecification) specification).getFrom().isEmpty()) {\n+                                    throw semanticException(INVALID_RECURSIVE_REFERENCE, stepReferences.get(0), \"recursive reference outside of FROM clause of the step relation of recursion\");\n+                                }\n+                                Relation from = ((QuerySpecification) specification).getFrom().get();\n+                                List<Node> fromReferences = findReferences(from, withQuery.getName());\n+                                if (fromReferences.size() == 0) {\n+                                    throw semanticException(INVALID_RECURSIVE_REFERENCE, stepReferences.get(0), \"recursive reference outside of FROM clause of the step relation of recursion\");\n+                                }\n \n-            Scope.Builder withScopeBuilder = scopeBuilder(scope);\n-            for (WithQuery withQuery : with.getQueries()) {\n-                Query query = withQuery.getQuery();\n-                process(query, withScopeBuilder.build());\n+                                // b) validate top-level shape of recursive query\n+                                withQuery.getQuery().getWith().ifPresent(innerWith -> {\n+                                    throw semanticException(NOT_SUPPORTED, innerWith, \"immediate WITH clause in recursive query\");\n+                                });\n+                                withQuery.getQuery().getOrderBy().ifPresent(orderBy -> {\n+                                    throw semanticException(NOT_SUPPORTED, orderBy, \"immediate ORDER BY clause in recursive query\");\n+                                });\n+                                withQuery.getQuery().getOffset().ifPresent(offset -> {\n+                                    throw semanticException(NOT_SUPPORTED, offset, \"immediate OFFSET clause in recursive query\");\n+                                });\n+                                withQuery.getQuery().getLimit().ifPresent(limit -> {\n+                                    throw semanticException(INVALID_LIMIT_CLAUSE, limit, \"immediate FETCH FIRST / LIMIT clause in recursive query\");\n+                                });\n+\n+                                // c) validate recursion step has no illegal clauses\n+                                validateFromClauseOfRecursiveTerm(from, withQuery.getName());\n+\n+                                // shape validation complete - process query as expandable query\n+                                Scope parentScope = withScopeBuilder.build();\n+                                // process expandable query -- anchor\n+                                Scope anchorScope = process(anchor, parentScope);\n+                                // set aliases in anchor scope as defined for WITH query. Recursion step will refer to anchor fields by aliases.\n+                                Scope aliasedAnchorScope = setAliases(anchorScope, withQuery.getName(), withQuery.getColumnNames().get());\n+                                // record expandable query base scope for recursion step analysis\n+                                Node recursiveReference = fromReferences.get(0);\n+                                analysis.setExpandableBaseScope(recursiveReference, aliasedAnchorScope);\n+                                // process expandable query -- recursion step\n+                                Scope stepScope = process(step, parentScope);\n+\n+                                // verify anchor and step have matching descriptors\n+                                RelationType anchorType = aliasedAnchorScope.getRelationType().withOnlyVisibleFields();\n+                                RelationType stepType = stepScope.getRelationType().withOnlyVisibleFields();\n+                                if (anchorType.getVisibleFieldCount() != stepType.getVisibleFieldCount()) {\n+                                    throw semanticException(TYPE_MISMATCH, step, \"base and step relations of recursion have different number of fields: %s, %s\", anchorType.getVisibleFieldCount(), stepType.getVisibleFieldCount());\n+                                }\n \n-                String name = withQuery.getName().getValue().toLowerCase(ENGLISH);\n-                if (withScopeBuilder.containsNamedQuery(name)) {\n-                    throw semanticException(DUPLICATE_NAMED_QUERY, withQuery, \"WITH query name '%s' specified more than once\", name);\n-                }\n+                                List<Type> anchorFieldTypes = anchorType.getVisibleFields().stream()\n+                                        .map(Field::getType)\n+                                        .collect(toImmutableList());\n+                                List<Type> stepFieldTypes = stepType.getVisibleFields().stream()\n+                                        .map(Field::getType)\n+                                        .collect(toImmutableList());\n+                                if (!anchorFieldTypes.equals(stepFieldTypes)) {\n+                                    analysis.addRelationCoercion(step, anchorFieldTypes.toArray(Type[]::new));\n+                                }\n+\n+                                for (int i = 0; i < anchorFieldTypes.size(); i++) {\n+                                    if (!typeCoercion.canCoerce(stepFieldTypes.get(i), anchorFieldTypes.get(i))) {\n+                                        throw semanticException(\n+                                                TYPE_MISMATCH,\n+                                                step,\n+                                                \"recursion step relation output type (%s) is not coercible to recursion base relation output type (%s) at column %s\",\n+                                                stepFieldTypes.get(i),\n+                                                anchorFieldTypes.get(i),\n+                                                i + 1);\n+                                    }\n+                                }\n \n-                // check if all or none of the columns are explicitly alias\n-                if (withQuery.getColumnNames().isPresent()) {\n-                    List<Identifier> columnNames = withQuery.getColumnNames().get();\n-                    RelationType queryDescriptor = analysis.getOutputDescriptor(query);\n-                    if (columnNames.size() != queryDescriptor.getVisibleFieldCount()) {\n-                        throw semanticException(MISMATCHED_COLUMN_ALIASES, withQuery, \"WITH column alias list has %s entries but WITH query(%s) has %s columns\", columnNames.size(), name, queryDescriptor.getVisibleFieldCount());\n+                                analysis.setScope(withQuery.getQuery(), aliasedAnchorScope);\n+                                analysis.registerExpandableQuery(withQuery.getQuery(), recursiveReference);\n+                                withScopeBuilder.withNamedQuery(name, withQuery);\n+                                continue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDEyMw=="}, "originalCommit": null, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NDAzODcwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMzo1NzozNlrOG4jzFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQxNTo1MTowNFrOG6mApQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1OTk1Nw==", "bodyText": "Why do we need this? As long as the field mappings don't reference the unnecessary columns, it shouldn't matter -- the columns will get pruned later during optimization.", "url": "https://github.com/trinodb/trino/pull/4250#discussion_r461959957", "createdAt": "2020-07-28T23:57:36Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -161,6 +185,172 @@ public RelationPlan plan(Query query)\n                 outerContext);\n     }\n \n+    public RelationPlan planExpand(Query query)\n+    {\n+        checkArgument(analysis.isExpandableQuery(query), \"query is not registered as expandable\");\n+\n+        Union union = (Union) query.getQueryBody();\n+        ImmutableList.Builder<PlanNode> recursionSteps = ImmutableList.builder();\n+\n+        // plan anchor relation\n+        Relation anchorNode = union.getRelations().get(0);\n+        RelationPlan anchorPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session, replacementMap)\n+                .process(anchorNode, null);\n+\n+        // prune anchor plan outputs to contain only the symbols exposed in the scope\n+        List<Symbol> anchorOutputs = anchorPlan.getRoot().getOutputSymbols().stream()\n+                .filter(ImmutableSet.copyOf(anchorPlan.getFieldMappings())::contains)\n+                .collect(toImmutableList());\n+        PlanNode anchorPlanRoot = new ProjectNode(idAllocator.getNextId(), anchorPlan.getRoot(), Assignments.identity(anchorOutputs));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5MzM0OQ==", "bodyText": "This is necessary for successful replacement. At some point we must plug recursion step plan in the place where anchor plan was.\nAs both anchor plan and step plan might have additional output symbols, they need to be pruned so that the replacement fits and the output symbols match their \"continuations\".", "url": "https://github.com/trinodb/trino/pull/4250#discussion_r464093349", "createdAt": "2020-08-02T15:51:04Z", "author": {"login": "kasiafi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -161,6 +185,172 @@ public RelationPlan plan(Query query)\n                 outerContext);\n     }\n \n+    public RelationPlan planExpand(Query query)\n+    {\n+        checkArgument(analysis.isExpandableQuery(query), \"query is not registered as expandable\");\n+\n+        Union union = (Union) query.getQueryBody();\n+        ImmutableList.Builder<PlanNode> recursionSteps = ImmutableList.builder();\n+\n+        // plan anchor relation\n+        Relation anchorNode = union.getRelations().get(0);\n+        RelationPlan anchorPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session, replacementMap)\n+                .process(anchorNode, null);\n+\n+        // prune anchor plan outputs to contain only the symbols exposed in the scope\n+        List<Symbol> anchorOutputs = anchorPlan.getRoot().getOutputSymbols().stream()\n+                .filter(ImmutableSet.copyOf(anchorPlan.getFieldMappings())::contains)\n+                .collect(toImmutableList());\n+        PlanNode anchorPlanRoot = new ProjectNode(idAllocator.getNextId(), anchorPlan.getRoot(), Assignments.identity(anchorOutputs));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1OTk1Nw=="}, "originalCommit": null, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NDAzOTI4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMzo1Nzo1NFrOG4jzYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMzo1Nzo1NFrOG4jzYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk2MDAzNQ==", "bodyText": "Arguments can go on the same line", "url": "https://github.com/trinodb/trino/pull/4250#discussion_r461960035", "createdAt": "2020-07-28T23:57:54Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -161,6 +185,172 @@ public RelationPlan plan(Query query)\n                 outerContext);\n     }\n \n+    public RelationPlan planExpand(Query query)\n+    {\n+        checkArgument(analysis.isExpandableQuery(query), \"query is not registered as expandable\");\n+\n+        Union union = (Union) query.getQueryBody();\n+        ImmutableList.Builder<PlanNode> recursionSteps = ImmutableList.builder();\n+\n+        // plan anchor relation\n+        Relation anchorNode = union.getRelations().get(0);\n+        RelationPlan anchorPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session, replacementMap)\n+                .process(anchorNode, null);\n+\n+        // prune anchor plan outputs to contain only the symbols exposed in the scope\n+        List<Symbol> anchorOutputs = anchorPlan.getRoot().getOutputSymbols().stream()\n+                .filter(ImmutableSet.copyOf(anchorPlan.getFieldMappings())::contains)\n+                .collect(toImmutableList());\n+        PlanNode anchorPlanRoot = new ProjectNode(idAllocator.getNextId(), anchorPlan.getRoot(), Assignments.identity(anchorOutputs));\n+\n+        anchorPlan = new RelationPlan(\n+                anchorPlanRoot,\n+                analysis.getScope(query),\n+                anchorOutputs,\n+                outerContext);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NDA1NzM5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMDowNjozOFrOG4j9jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMDowNjozOFrOG4j9jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk2MjYzOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    UnionNode unionNode = new UnionNode(idAllocator.getNextId(), recursionStepsToUnion, unionSymbolMapping.build(), unionOutputSymbols);\n          \n          \n            \n            \n          \n          \n            \n                    AggregationNode distinctAggregation = new AggregationNode(\n          \n          \n            \n                            idAllocator.getNextId(),\n          \n          \n            \n                            unionNode,\n          \n          \n            \n                            ImmutableMap.of(),\n          \n          \n            \n                            singleGroupingSet(unionNode.getOutputSymbols()),\n          \n          \n            \n                            ImmutableList.of(),\n          \n          \n            \n                            AggregationNode.Step.SINGLE,\n          \n          \n            \n                            Optional.empty(),\n          \n          \n            \n                            Optional.empty());\n          \n          \n            \n            \n          \n          \n            \n                    return new RelationPlan(\n          \n          \n            \n                            union.isDistinct() ? distinctAggregation : unionNode,\n          \n          \n            \n                            anchorPlan.getScope(),\n          \n          \n            \n                            unionOutputSymbols,\n          \n          \n            \n                            outerContext);\n          \n          \n            \n                    PlanNode result = new UnionNode(idAllocator.getNextId(), recursionStepsToUnion, unionSymbolMapping.build(), unionOutputSymbols);\n          \n          \n            \n            \n          \n          \n            \n                    if (union.isDistinct()) {\n          \n          \n            \n                        result = new AggregationNode(\n          \n          \n            \n                                idAllocator.getNextId(),\n          \n          \n            \n                                result,\n          \n          \n            \n                                ImmutableMap.of(),\n          \n          \n            \n                                singleGroupingSet(result.getOutputSymbols()),\n          \n          \n            \n                                ImmutableList.of(),\n          \n          \n            \n                                AggregationNode.Step.SINGLE,\n          \n          \n            \n                                Optional.empty(),\n          \n          \n            \n                                Optional.empty());\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    return new RelationPlan(result, anchorPlan.getScope(), unionOutputSymbols, outerContext);", "url": "https://github.com/trinodb/trino/pull/4250#discussion_r461962639", "createdAt": "2020-07-29T00:06:38Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -161,6 +185,172 @@ public RelationPlan plan(Query query)\n                 outerContext);\n     }\n \n+    public RelationPlan planExpand(Query query)\n+    {\n+        checkArgument(analysis.isExpandableQuery(query), \"query is not registered as expandable\");\n+\n+        Union union = (Union) query.getQueryBody();\n+        ImmutableList.Builder<PlanNode> recursionSteps = ImmutableList.builder();\n+\n+        // plan anchor relation\n+        Relation anchorNode = union.getRelations().get(0);\n+        RelationPlan anchorPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session, replacementMap)\n+                .process(anchorNode, null);\n+\n+        // prune anchor plan outputs to contain only the symbols exposed in the scope\n+        List<Symbol> anchorOutputs = anchorPlan.getRoot().getOutputSymbols().stream()\n+                .filter(ImmutableSet.copyOf(anchorPlan.getFieldMappings())::contains)\n+                .collect(toImmutableList());\n+        PlanNode anchorPlanRoot = new ProjectNode(idAllocator.getNextId(), anchorPlan.getRoot(), Assignments.identity(anchorOutputs));\n+\n+        anchorPlan = new RelationPlan(\n+                anchorPlanRoot,\n+                analysis.getScope(query),\n+                anchorOutputs,\n+                outerContext);\n+\n+        recursionSteps.add(copy(anchorPlan.getRoot()));\n+\n+        // plan recursion step\n+        Relation recursionStepRelation = union.getRelations().get(1);\n+        RelationPlan recursionStepPlan = new RelationPlanner(\n+                analysis,\n+                symbolAllocator,\n+                idAllocator,\n+                lambdaDeclarationToSymbolMap,\n+                metadata,\n+                outerContext,\n+                session,\n+                ImmutableMap.of(NodeRef.of(analysis.getRecursiveReference(query)), anchorPlan))\n+                .process(recursionStepRelation, null);\n+\n+        // coerce recursion step outputs and prune them to contain only the symbols exposed in the scope\n+        NodeAndMappings coercedRecursionStep;\n+        List<Type> types = analysis.getRelationCoercion(recursionStepRelation);\n+        if (types == null) {\n+            coercedRecursionStep = pruneInvisibleFields(recursionStepPlan, idAllocator);\n+        }\n+        else {\n+            coercedRecursionStep = coerce(recursionStepPlan, types, symbolAllocator, idAllocator);\n+        }\n+\n+        PlanNode replacementSpot = anchorPlan.getRoot();\n+        PlanNode recursionStep = coercedRecursionStep.getNode();\n+\n+        // unroll recursion\n+        int maxRecursionDepth = getMaxRecursionDepth(session);\n+        for (int i = 0; i < maxRecursionDepth; i++) {\n+            recursionSteps.add(copy(recursionStep));\n+            PlanNode replacement = copy(recursionStep);\n+            recursionStep = replace(recursionStep, replacementSpot, replacement);\n+            replacementSpot = replacement;\n+        }\n+\n+        // after the last recursion step, check if the recursion converged. the last step is expected to return empty result\n+        // 1. append window to count rows\n+        Symbol countSymbol = symbolAllocator.newSymbol(\"count\", BIGINT);\n+        ResolvedFunction function = metadata.resolveFunction(QualifiedName.of(\"count\"), ImmutableList.of());\n+        WindowNode.Frame frame = new WindowNode.Frame(RANGE, UNBOUNDED_PRECEDING, Optional.empty(), CURRENT_ROW, Optional.empty(), Optional.empty(), Optional.empty());\n+        WindowNode.Function countFunction = new WindowNode.Function(function, ImmutableList.of(), frame, false);\n+\n+        WindowNode windowNode = new WindowNode(\n+                idAllocator.getNextId(),\n+                copy(recursionStep),\n+                new WindowNode.Specification(ImmutableList.of(), Optional.empty()),\n+                ImmutableMap.of(countSymbol, countFunction),\n+                Optional.empty(),\n+                ImmutableSet.of(),\n+                0);\n+\n+        // 2. append filter to fail on non-empty result\n+        ResolvedFunction fail = metadata.resolveFunction(QualifiedName.of(\"fail\"), fromTypes(VARCHAR));\n+        String recursionLimitExceededMessage = format(\"Recursion depth limit exceeded (%s). Use 'max_recursion_depth' session property to modify the limit.\", maxRecursionDepth);\n+        Expression predicate = new IfExpression(\n+                new ComparisonExpression(\n+                        GREATER_THAN_OR_EQUAL,\n+                        countSymbol.toSymbolReference(),\n+                        new GenericLiteral(\"BIGINT\", \"0\")),\n+                new Cast(\n+                        new FunctionCall(\n+                                fail.toQualifiedName(),\n+                                ImmutableList.of(new Cast(new StringLiteral(recursionLimitExceededMessage), toSqlType(VARCHAR)))),\n+                        toSqlType(BOOLEAN)),\n+                TRUE_LITERAL);\n+        FilterNode filterNode = new FilterNode(idAllocator.getNextId(), windowNode, predicate);\n+\n+        // 3. append projection to prune count symbol\n+        ProjectNode projectNode = new ProjectNode(idAllocator.getNextId(), filterNode, Assignments.identity(recursionStep.getOutputSymbols()));\n+\n+        recursionSteps.add(projectNode);\n+\n+        // union all the recursion steps\n+        List<PlanNode> recursionStepsToUnion = recursionSteps.build();\n+\n+        List<Symbol> unionOutputSymbols = anchorPlan.getRoot().getOutputSymbols().stream()\n+                .map(symbol -> symbolAllocator.newSymbol(symbol, \"_expanded\"))\n+                .collect(toImmutableList());\n+\n+        ImmutableListMultimap.Builder<Symbol, Symbol> unionSymbolMapping = ImmutableListMultimap.builder();\n+        for (PlanNode plan : recursionStepsToUnion) {\n+            for (int i = 0; i < unionOutputSymbols.size(); i++) {\n+                unionSymbolMapping.put(unionOutputSymbols.get(i), plan.getOutputSymbols().get(i));\n+            }\n+        }\n+\n+        UnionNode unionNode = new UnionNode(idAllocator.getNextId(), recursionStepsToUnion, unionSymbolMapping.build(), unionOutputSymbols);\n+\n+        AggregationNode distinctAggregation = new AggregationNode(\n+                idAllocator.getNextId(),\n+                unionNode,\n+                ImmutableMap.of(),\n+                singleGroupingSet(unionNode.getOutputSymbols()),\n+                ImmutableList.of(),\n+                AggregationNode.Step.SINGLE,\n+                Optional.empty(),\n+                Optional.empty());\n+\n+        return new RelationPlan(\n+                union.isDistinct() ? distinctAggregation : unionNode,\n+                anchorPlan.getScope(),\n+                unionOutputSymbols,\n+                outerContext);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NDA2NDU4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/RelationPlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMDoxMDoxNlrOG4kBsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMDoxMDoxNlrOG4kBsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk2MzY5Ng==", "bodyText": "replacementMap is too vague of a name. Maybe rename to something more precise, such as \"recursiveSubqueries\".", "url": "https://github.com/trinodb/trino/pull/4250#discussion_r461963696", "createdAt": "2020-07-29T00:10:16Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/RelationPlanner.java", "diffHunk": "@@ -114,6 +114,7 @@\n     private final Optional<TranslationMap> outerContext;\n     private final Session session;\n     private final SubqueryPlanner subqueryPlanner;\n+    private final Map<NodeRef<Node>, RelationPlan> replacementMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMTAxNjgwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMzo1MDo1N1rOG8eaew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxMjo0ODo0M1rOG8yABQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2NjA0Mw==", "bodyText": "Do we need this anymore? With the field mappings as a reference, it doesn't matter how many fields the underlying plan node produces.", "url": "https://github.com/trinodb/trino/pull/4250#discussion_r466066043", "createdAt": "2020-08-05T23:50:57Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -198,14 +198,10 @@ public RelationPlan planExpand(Query query)\n                 .process(anchorNode, null);\n \n         // prune anchor plan outputs to contain only the symbols exposed in the scope\n-        List<Symbol> anchorOutputs = anchorPlan.getRoot().getOutputSymbols().stream()\n-                .filter(ImmutableSet.copyOf(anchorPlan.getFieldMappings())::contains)\n-                .collect(toImmutableList());\n-        PlanNode anchorPlanRoot = new ProjectNode(idAllocator.getNextId(), anchorPlan.getRoot(), Assignments.identity(anchorOutputs));\n-\n-        anchorPlan = new RelationPlan(anchorPlanRoot, analysis.getScope(query), anchorOutputs, outerContext);\n+        NodeAndMappings prunedAnchorPlan = pruneInvisibleFields(anchorPlan, idAllocator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM4Njk0OQ==", "bodyText": "It is necessary to prune anchor outputs. If we leave those extra symbols in the anchor plan, they will \"leak\" to the recursion step plan. Later, when anchor plan is replaced with step plan, they will become orphaned.", "url": "https://github.com/trinodb/trino/pull/4250#discussion_r466386949", "createdAt": "2020-08-06T12:48:43Z", "author": {"login": "kasiafi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -198,14 +198,10 @@ public RelationPlan planExpand(Query query)\n                 .process(anchorNode, null);\n \n         // prune anchor plan outputs to contain only the symbols exposed in the scope\n-        List<Symbol> anchorOutputs = anchorPlan.getRoot().getOutputSymbols().stream()\n-                .filter(ImmutableSet.copyOf(anchorPlan.getFieldMappings())::contains)\n-                .collect(toImmutableList());\n-        PlanNode anchorPlanRoot = new ProjectNode(idAllocator.getNextId(), anchorPlan.getRoot(), Assignments.identity(anchorOutputs));\n-\n-        anchorPlan = new RelationPlan(anchorPlanRoot, analysis.getScope(query), anchorOutputs, outerContext);\n+        NodeAndMappings prunedAnchorPlan = pruneInvisibleFields(anchorPlan, idAllocator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2NjA0Mw=="}, "originalCommit": null, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMTAyMjExOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMzo1Mzo0NlrOG8edjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxMjo1MDo0MFrOG8yEbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2NjgyOQ==", "bodyText": "Why do we need to call alignOutputs? That seems to mean that some node relies on the physical order of the output symbols of the underlying plan node, which should not be the case.", "url": "https://github.com/trinodb/trino/pull/4250#discussion_r466066829", "createdAt": "2020-08-05T23:53:46Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -232,26 +228,28 @@ public RelationPlan planExpand(Query query)\n \n         PlanNode replacementSpot = anchorPlan.getRoot();\n         PlanNode recursionStep = coercedRecursionStep.getNode();\n+        List<Symbol> mappings = coercedRecursionStep.getFields();\n \n         // unroll recursion\n         int maxRecursionDepth = getMaxRecursionDepth(session);\n         for (int i = 0; i < maxRecursionDepth; i++) {\n-            recursionSteps.add(copy(recursionStep));\n-            PlanNode replacement = copy(recursionStep);\n+            recursionSteps.add(alignOutputs(copy(recursionStep, mappings)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM4ODA3OQ==", "bodyText": "I changed it so that mappings are passed along with the PlanNode and whenever we need to bind symbols properly (that is, when replacing and when building UnionNode), it is done via mapping.", "url": "https://github.com/trinodb/trino/pull/4250#discussion_r466388079", "createdAt": "2020-08-06T12:50:40Z", "author": {"login": "kasiafi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -232,26 +228,28 @@ public RelationPlan planExpand(Query query)\n \n         PlanNode replacementSpot = anchorPlan.getRoot();\n         PlanNode recursionStep = coercedRecursionStep.getNode();\n+        List<Symbol> mappings = coercedRecursionStep.getFields();\n \n         // unroll recursion\n         int maxRecursionDepth = getMaxRecursionDepth(session);\n         for (int i = 0; i < maxRecursionDepth; i++) {\n-            recursionSteps.add(copy(recursionStep));\n-            PlanNode replacement = copy(recursionStep);\n+            recursionSteps.add(alignOutputs(copy(recursionStep, mappings)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2NjgyOQ=="}, "originalCommit": null, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMTE4MDI4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/AbstractSymbolMapper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMToyMTowM1rOG8f6HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMToyMTowM1rOG8f6HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA5MDUyNA==", "bodyText": "Using inheritance to share code is generally not a good approach. It introduces issues of poor encapsulation, unclear thread-safety semantics (for code that can be accessed concurrently), etc. It's better to do it via delegation. In this case, you could make SymbolMapper take an object during construction that is responsible for doing the primordial mapping. You'd customize that for each of the two use cases we need here.", "url": "https://github.com/trinodb/trino/pull/4250#discussion_r466090524", "createdAt": "2020-08-06T01:21:03Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/AbstractSymbolMapper.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.optimizations;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.PartitioningScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.DistinctLimitNode;\n+import io.prestosql.sql.planner.plan.GroupIdNode;\n+import io.prestosql.sql.planner.plan.LimitNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.PlanNodeId;\n+import io.prestosql.sql.planner.plan.RowNumberNode;\n+import io.prestosql.sql.planner.plan.StatisticAggregations;\n+import io.prestosql.sql.planner.plan.StatisticsWriterNode;\n+import io.prestosql.sql.planner.plan.TableFinishNode;\n+import io.prestosql.sql.planner.plan.TableWriterNode;\n+import io.prestosql.sql.planner.plan.TopNNode;\n+import io.prestosql.sql.planner.plan.TopNRowNumberNode;\n+import io.prestosql.sql.planner.plan.WindowNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.ExpressionRewriter;\n+import io.prestosql.sql.tree.ExpressionTreeRewriter;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static io.prestosql.sql.planner.plan.AggregationNode.groupingSets;\n+import static java.util.Objects.requireNonNull;\n+\n+public abstract class AbstractSymbolMapper", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 53}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3979, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}