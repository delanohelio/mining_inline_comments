{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxOTE3MTg3", "number": 4932, "title": "Use predicates on non-partition columns in Iceberg", "bodyText": "This has two benefits: (w.r.t. predicates on non-partition columns)\n\npredicates can be used during split generation, reducing the number of splits scheduled\npredicates can be used by ORC/Parquet readers\n\nFor example, without this patch, the SELECT query in the sequence below would schedule 2 splits instead of 1.\nCREATE TABLE T (a bigint, b bigint) WITH (partitioning=array['b'])\nINSERT INTO T VALUES (5, 6), (6, 7);\nSELECT * FROM T WHERE a = 5;\n\nIN predicates with large value set throw a stackoverflow error in iceberg because iceberg seems to translate it to OR expressions. To avoid this, we loosen up such conditions in tableScan.filter  for predicates on non-partition columns. However, we cannot do the same for partition columns to maintain correctness.", "createdAt": "2020-08-22T01:35:38Z", "url": "https://github.com/trinodb/trino/pull/4932", "merged": true, "mergeCommit": {"oid": "25f803f420e558bffef69401d16a8ed39e50cab7"}, "closed": true, "closedAt": "2020-12-08T18:25:34Z", "author": {"login": "phd3"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdDJsZlgBqjM3MDE4NjA0ODI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdj-AH5AFqTU0NjYxOTU0Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMDM3NzUx", "url": "https://github.com/trinodb/trino/pull/4932#pullrequestreview-493037751", "createdAt": "2020-09-21T23:01:33Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMzowMTozM1rOHVlS8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMzowODoyOVrOHVlb1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM5MzIwMA==", "bodyText": "We can also handle the case when icebergTable.specs().values().stream().allMatch(spec -> spec.fields().containsAll(fields)) is false. Currently,\n        if (newDomain.equals(table.getPredicate().intersect(table.getEnforcedPredicate()))) {\n            return Optional.empty();\n        }\n\nEven in this case the pushed predicate can be used in table scans.", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r492393200", "createdAt": "2020-09-21T23:01:33Z", "author": {"login": "lxynov"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergMetadata.java", "diffHunk": "@@ -613,7 +613,6 @@ public void rollback()\n     {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM5NTQ3OA==", "bodyText": "We should also make a change to the function call icebergTableHandle.getPredicate() in TableStatisticsMaker::makeTableStatistics?", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r492395478", "createdAt": "2020-09-21T23:08:29Z", "author": {"login": "lxynov"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergTableHandle.java", "diffHunk": "@@ -90,6 +97,12 @@ public TableType getTableType()\n         return predicate;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MDU3ODg0", "url": "https://github.com/trinodb/trino/pull/4932#pullrequestreview-518057884", "createdAt": "2020-10-27T19:19:18Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOToxOToxOVrOHpMwVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOToyMjoyOFrOHpM5FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MjY0NQ==", "bodyText": "This seems wrong to me. Shouldn't we return \"none\" to the engine?", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r512962645", "createdAt": "2020-10-27T19:19:19Z", "author": {"login": "electrum"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergMetadata.java", "diffHunk": "@@ -612,47 +612,45 @@ public void rollback()\n     public Optional<ConstraintApplicationResult<ConnectorTableHandle>> applyFilter(ConnectorSession session, ConnectorTableHandle handle, Constraint constraint)\n     {\n         IcebergTableHandle table = (IcebergTableHandle) handle;\n+        org.apache.iceberg.Table icebergTable = getIcebergTable(metastore, hdfsEnvironment, session, table.getSchemaTableName());\n \n-        // TODO: Remove TupleDomain#simplify once Iceberg supports IN expression\n-        TupleDomain<IcebergColumnHandle> newDomain = constraint.getSummary()\n-                .transform(IcebergColumnHandle.class::cast)\n-                .intersect(table.getPredicate());\n-\n-        if (newDomain.isNone()) {\n-            return Optional.empty();\n-        }\n+        // Extract identity partition column source ids common to ALL specs\n+        Set<Integer> partitionSourceIds = icebergTable.spec().fields().stream()\n+                .filter(field -> field.transform().isIdentity())\n+                .filter(field -> icebergTable.specs().values().stream().allMatch(spec -> spec.fields().contains(field)))\n+                .map(PartitionField::sourceId)\n+                .collect(toImmutableSet());\n \n-        if (newDomain.equals(table.getPredicate())) {\n-            return Optional.empty();\n-        }\n+        BiPredicate<IcebergColumnHandle, Domain> isIdentityPartition = (column, domain) -> partitionSourceIds.contains(column.getId());\n \n-        org.apache.iceberg.Table icebergTable = getIcebergTable(metastore, hdfsEnvironment, session, table.getSchemaTableName());\n+        TupleDomain<IcebergColumnHandle> newEnforcedConstraint = constraint.getSummary()\n+                .transform(IcebergColumnHandle.class::cast)\n+                .filter(isIdentityPartition)\n+                .intersect(table.getEnforcedPredicate());\n \n-        List<PartitionField> fields = icebergTable.spec().fields().stream()\n-                .filter(field -> field.transform().isIdentity())\n-                .collect(toImmutableList());\n+        TupleDomain<IcebergColumnHandle> newUnenforcedConstraint = constraint.getSummary()\n+                .transform(IcebergColumnHandle.class::cast)\n+                .filter(isIdentityPartition.negate())\n+                .intersect(table.getPredicate());\n \n-        // Ensure partition specs in all manifests contain the identity fields from the predicate\n-        if (!icebergTable.specs().values().stream().allMatch(spec -> spec.fields().containsAll(fields))) {\n+        if (newEnforcedConstraint.equals(table.getEnforcedPredicate())\n+                && newUnenforcedConstraint.equals(table.getPredicate())) {\n             return Optional.empty();\n         }\n \n-        Set<Integer> partitionSourceIds = icebergTable.spec().fields().stream()\n-                .filter(field -> field.transform().isIdentity())\n-                .map(PartitionField::sourceId)\n-                .collect(toImmutableSet());\n-\n-        BiPredicate<IcebergColumnHandle, Domain> contains = (column, domain) -> partitionSourceIds.contains(column.getId());\n-        TupleDomain<ColumnHandle> remainingTupleDomain = newDomain.filter(contains.negate()).transform(ColumnHandle.class::cast);\n-        TupleDomain<IcebergColumnHandle> enforcedTupleDomain = newDomain.filter(contains);\n+        if (newEnforcedConstraint.isNone()) {\n+            // If no tuple satisfies the constraint, no need to do additional filtering in the engine\n+            newUnenforcedConstraint = TupleDomain.all();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MzY0Nw==", "bodyText": "Should this move inside toIcebergExpression()?", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r512963647", "createdAt": "2020-10-27T19:21:04Z", "author": {"login": "electrum"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergSplitManager.java", "diffHunk": "@@ -57,7 +57,12 @@ public ConnectorSplitSource getSplits(\n         HiveMetastore metastore = transactionManager.get(transaction).getMetastore();\n         Table icebergTable = getIcebergTable(metastore, hdfsEnvironment, session, table.getSchemaTableName());\n \n-        TableScan tableScan = getTableScan(table.getPredicate(), table.getSnapshotId(), icebergTable);\n+        TableScan tableScan = getTableScan(\n+                // TODO: Remove TupleDomain#simplify once Iceberg supports IN expression\n+                table.getEnforcedPredicate()\n+                        .intersect(table.getPredicate()).simplify(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2NDg4NA==", "bodyText": "This can use orElseThrow()", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r512964884", "createdAt": "2020-10-27T19:22:28Z", "author": {"login": "electrum"}, "path": "presto-iceberg/src/test/java/io/prestosql/plugin/iceberg/AbstractTestIcebergSmoke.java", "diffHunk": "@@ -1204,6 +1209,72 @@ public void testStatisticsConstraints()\n         dropTable(tableName);\n     }\n \n+    @Test\n+    public void testPredicatePushdown()\n+    {\n+        QualifiedObjectName tableName = new QualifiedObjectName(\"iceberg\", \"tpch\", \"test_predicate\");\n+        assertUpdate(format(\"CREATE TABLE %s (col1 BIGINT, col2 BIGINT, col3 BIGINT) WITH (partitioning = ARRAY['col2', 'col3'])\", tableName));\n+        assertUpdate(format(\"INSERT INTO %s VALUES (1, 10, 100)\", tableName), 1L);\n+        assertUpdate(format(\"INSERT INTO %s VALUES (2, 20, 200)\", tableName), 1L);\n+\n+        assertFilterPushdown(tableName,\n+                ImmutableMap.of(\"col1\", NullableValue.of(BIGINT, 1L)),\n+                ImmutableMap.of(),\n+                ImmutableMap.of(\"col1\", NullableValue.of(BIGINT, 1L)));\n+\n+        assertFilterPushdown(tableName,\n+                ImmutableMap.of(\"col2\", NullableValue.of(BIGINT, 10L)),\n+                ImmutableMap.of(\"col2\", NullableValue.of(BIGINT, 10L)),\n+                ImmutableMap.of());\n+\n+        assertFilterPushdown(tableName,\n+                ImmutableMap.of(\"col1\", NullableValue.of(BIGINT, 1L), \"col2\", NullableValue.of(BIGINT, 10L)),\n+                ImmutableMap.of(\"col2\", NullableValue.of(BIGINT, 10L)),\n+                ImmutableMap.of(\"col1\", NullableValue.of(BIGINT, 1L)));\n+\n+        dropTable(tableName.getObjectName());\n+    }\n+\n+    private void assertFilterPushdown(\n+            QualifiedObjectName tableName,\n+            Map<String, NullableValue> filter,\n+            Map<String, NullableValue> expectedEnforcedPredicate,\n+            Map<String, NullableValue> expectedPredicate)\n+    {\n+        Metadata metadata = getQueryRunner().getMetadata();\n+\n+        newTransaction().execute(getSession(), session -> {\n+            Optional<TableHandle> table = metadata.getTableHandle(session, tableName);\n+            checkArgument(table.isPresent(), \"Could not create table handle for table %s\", tableName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 75}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2ODU0MDY1", "url": "https://github.com/trinodb/trino/pull/4932#pullrequestreview-536854065", "createdAt": "2020-11-23T21:19:49Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMToxOTo0OVrOH4fz6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMTo0MDoxM1rOH4gbvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAwMzQ5Ng==", "bodyText": "What are the semantics of IcebergTableHandle.getEnforcedPredicate? Is it guaranteed to be a tight bound?", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r529003496", "createdAt": "2020-11-23T21:19:49Z", "author": {"login": "martint"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergTableHandle.java", "diffHunk": "@@ -79,6 +86,12 @@ public TableType getTableType()\n         return predicate;\n     }\n \n+    @JsonProperty\n+    public TupleDomain<IcebergColumnHandle> getEnforcedPredicate()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAxMzY5Mg==", "bodyText": "In particular how do predicate and enforcedPredicate differ from each other. From my reading of the above code, this is just about whether the predicate is over the partition columns vs non-partition columns.\nMaybe it'd make more sense to model it as two complementary sets of predicates (partitionColumnPredicate vs nonPartitionColumnPredicate). It would also make it easier to interpret and understand all the places where they are referenced.", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r529013692", "createdAt": "2020-11-23T21:40:13Z", "author": {"login": "martint"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergTableHandle.java", "diffHunk": "@@ -79,6 +86,12 @@ public TableType getTableType()\n         return predicate;\n     }\n \n+    @JsonProperty\n+    public TupleDomain<IcebergColumnHandle> getEnforcedPredicate()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAwMzQ5Ng=="}, "originalCommit": null, "originalPosition": 35}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ca382468b2da8bbc500fed75a990e239c87bf6a", "author": {"user": {"login": "phd3", "name": "Pratham"}}, "url": "https://github.com/trinodb/trino/commit/6ca382468b2da8bbc500fed75a990e239c87bf6a", "committedDate": "2020-12-05T00:38:52Z", "message": "Add test asserting failures for large IN predicates in Iceberg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d97e7dcbf86ecbfcbcd096877653c5863df9daf", "author": {"user": {"login": "phd3", "name": "Pratham"}}, "url": "https://github.com/trinodb/trino/commit/7d97e7dcbf86ecbfcbcd096877653c5863df9daf", "committedDate": "2020-12-05T00:38:53Z", "message": "Use predicates on non-partition columns\n\nWith this change, predicates that cannot be enforced by iceberg\nconnector will still be used during split generation, reducing\nthe number of splits scheduled.\n\nThese predicates will also be used by ORC/Parquet readers for\noptimizing reads."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66b8a1366a7ac2aa9ea864e371e93377ccb30d89", "author": {"user": {"login": "phd3", "name": "Pratham"}}, "url": "https://github.com/trinodb/trino/commit/66b8a1366a7ac2aa9ea864e371e93377ccb30d89", "committedDate": "2020-12-05T00:38:53Z", "message": "Fix Iceberg Expression conversion for timestamp with timezone"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4c6668dbac8e07ab7d7939e5f2e472eea4bcac3", "author": {"user": {"login": "phd3", "name": "Pratham"}}, "url": "https://github.com/trinodb/trino/commit/b4c6668dbac8e07ab7d7939e5f2e472eea4bcac3", "committedDate": "2020-12-05T01:20:38Z", "message": "Rename predicate to unenforcedPredicate\n\nThe new naming more accurately represents the\nexpected behavior of the variable, and the\ncomplementary relationship with enforcedPredicate."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "b4c6668dbac8e07ab7d7939e5f2e472eea4bcac3", "author": {"user": {"login": "phd3", "name": "Pratham"}}, "url": "https://github.com/trinodb/trino/commit/b4c6668dbac8e07ab7d7939e5f2e472eea4bcac3", "committedDate": "2020-12-05T01:20:38Z", "message": "Rename predicate to unenforcedPredicate\n\nThe new naming more accurately represents the\nexpected behavior of the variable, and the\ncomplementary relationship with enforcedPredicate."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NjE5NTQ2", "url": "https://github.com/trinodb/trino/pull/4932#pullrequestreview-546619546", "createdAt": "2020-12-07T23:18:50Z", "commit": {"oid": "b4c6668dbac8e07ab7d7939e5f2e472eea4bcac3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4076, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}