{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxMjEwMTk4", "number": 4905, "reviewThreads": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMFQyMTowNTozMFrOEeGsdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMDowMDoxNlrOEehqZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDAyNDIwOnYy", "diffSide": "RIGHT", "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/AbstractPrestoResultSet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMFQyMTowNTozMFrOHJlnhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzo0ODoxMlrOHLBsVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNTU1OQ==", "bodyText": "There are no limits on the number of digits in fraction, so can this throw?", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r479815559", "createdAt": "2020-08-30T21:05:30Z", "author": {"login": "dain"}, "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/AbstractPrestoResultSet.java", "diffHunk": "@@ -1867,6 +1860,39 @@ private static Time parseTime(String value, ZoneId localTimeZone)\n         return new Time(epochMilli);\n     }\n \n+    private static Time parseTimeWithTimeZone(String value)\n+    {\n+        Matcher matcher = TIME_WITH_TIME_ZONE_PATTERN.matcher(value);\n+        if (!matcher.matches()) {\n+            throw new IllegalArgumentException(\"Invalid time: \" + value);\n+        }\n+\n+        int hour = Integer.parseInt(matcher.group(\"hour\"));\n+        int minute = Integer.parseInt(matcher.group(\"minute\"));\n+        int second = matcher.group(\"second\") == null ? 0 : Integer.parseInt(matcher.group(\"second\"));\n+        int offsetHour = Integer.parseInt((matcher.group(\"offsetHour\")));\n+        int offsetMinute = Integer.parseInt((matcher.group(\"offsetMinute\")));\n+\n+        if (hour > 23 || minute > 59 || second > 59 || !isValidOffset(offsetHour, offsetMinute)) {\n+            throw new IllegalArgumentException(\"Invalid time with time zone: \" + value);\n+        }\n+\n+        int precision = 0;\n+        String fraction = matcher.group(\"fraction\");\n+        long fractionValue = 0;\n+        if (fraction != null) {\n+            precision = fraction.length();\n+            fractionValue = Long.parseLong(fraction);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyNDExOA==", "bodyText": "Yes, I'll add a check", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r481324118", "createdAt": "2020-09-01T17:48:12Z", "author": {"login": "martint"}, "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/AbstractPrestoResultSet.java", "diffHunk": "@@ -1867,6 +1860,39 @@ private static Time parseTime(String value, ZoneId localTimeZone)\n         return new Time(epochMilli);\n     }\n \n+    private static Time parseTimeWithTimeZone(String value)\n+    {\n+        Matcher matcher = TIME_WITH_TIME_ZONE_PATTERN.matcher(value);\n+        if (!matcher.matches()) {\n+            throw new IllegalArgumentException(\"Invalid time: \" + value);\n+        }\n+\n+        int hour = Integer.parseInt(matcher.group(\"hour\"));\n+        int minute = Integer.parseInt(matcher.group(\"minute\"));\n+        int second = matcher.group(\"second\") == null ? 0 : Integer.parseInt(matcher.group(\"second\"));\n+        int offsetHour = Integer.parseInt((matcher.group(\"offsetHour\")));\n+        int offsetMinute = Integer.parseInt((matcher.group(\"offsetMinute\")));\n+\n+        if (hour > 23 || minute > 59 || second > 59 || !isValidOffset(offsetHour, offsetMinute)) {\n+            throw new IllegalArgumentException(\"Invalid time with time zone: \" + value);\n+        }\n+\n+        int precision = 0;\n+        String fraction = matcher.group(\"fraction\");\n+        long fractionValue = 0;\n+        if (fraction != null) {\n+            precision = fraction.length();\n+            fractionValue = Long.parseLong(fraction);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNTU1OQ=="}, "originalCommit": null, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDAyNzQ2OnYy", "diffSide": "RIGHT", "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/AbstractPrestoResultSet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMFQyMTowOTo1NVrOHJlpGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzo0OTo1NlrOHLBwbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNTk2MA==", "bodyText": "Why not just multiply this out?  If not, I expect that OffsetDateTime will be faster.", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r479815960", "createdAt": "2020-08-30T21:09:55Z", "author": {"login": "dain"}, "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/AbstractPrestoResultSet.java", "diffHunk": "@@ -1867,6 +1860,39 @@ private static Time parseTime(String value, ZoneId localTimeZone)\n         return new Time(epochMilli);\n     }\n \n+    private static Time parseTimeWithTimeZone(String value)\n+    {\n+        Matcher matcher = TIME_WITH_TIME_ZONE_PATTERN.matcher(value);\n+        if (!matcher.matches()) {\n+            throw new IllegalArgumentException(\"Invalid time: \" + value);\n+        }\n+\n+        int hour = Integer.parseInt(matcher.group(\"hour\"));\n+        int minute = Integer.parseInt(matcher.group(\"minute\"));\n+        int second = matcher.group(\"second\") == null ? 0 : Integer.parseInt(matcher.group(\"second\"));\n+        int offsetHour = Integer.parseInt((matcher.group(\"offsetHour\")));\n+        int offsetMinute = Integer.parseInt((matcher.group(\"offsetMinute\")));\n+\n+        if (hour > 23 || minute > 59 || second > 59 || !isValidOffset(offsetHour, offsetMinute)) {\n+            throw new IllegalArgumentException(\"Invalid time with time zone: \" + value);\n+        }\n+\n+        int precision = 0;\n+        String fraction = matcher.group(\"fraction\");\n+        long fractionValue = 0;\n+        if (fraction != null) {\n+            precision = fraction.length();\n+            fractionValue = Long.parseLong(fraction);\n+        }\n+\n+        ZoneOffset zoneOffset = ZoneOffset.ofHoursMinutes(offsetHour, offsetMinute);\n+        long epochMilli = ZonedDateTime.of(1970, 1, 1, hour, minute, second, (int) rescale(fractionValue, precision, 9), zoneOffset)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyNTE2Ng==", "bodyText": "Good catch. I must have copied/adapted this from some other place.", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r481325166", "createdAt": "2020-09-01T17:49:56Z", "author": {"login": "martint"}, "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/AbstractPrestoResultSet.java", "diffHunk": "@@ -1867,6 +1860,39 @@ private static Time parseTime(String value, ZoneId localTimeZone)\n         return new Time(epochMilli);\n     }\n \n+    private static Time parseTimeWithTimeZone(String value)\n+    {\n+        Matcher matcher = TIME_WITH_TIME_ZONE_PATTERN.matcher(value);\n+        if (!matcher.matches()) {\n+            throw new IllegalArgumentException(\"Invalid time: \" + value);\n+        }\n+\n+        int hour = Integer.parseInt(matcher.group(\"hour\"));\n+        int minute = Integer.parseInt(matcher.group(\"minute\"));\n+        int second = matcher.group(\"second\") == null ? 0 : Integer.parseInt(matcher.group(\"second\"));\n+        int offsetHour = Integer.parseInt((matcher.group(\"offsetHour\")));\n+        int offsetMinute = Integer.parseInt((matcher.group(\"offsetMinute\")));\n+\n+        if (hour > 23 || minute > 59 || second > 59 || !isValidOffset(offsetHour, offsetMinute)) {\n+            throw new IllegalArgumentException(\"Invalid time with time zone: \" + value);\n+        }\n+\n+        int precision = 0;\n+        String fraction = matcher.group(\"fraction\");\n+        long fractionValue = 0;\n+        if (fraction != null) {\n+            precision = fraction.length();\n+            fractionValue = Long.parseLong(fraction);\n+        }\n+\n+        ZoneOffset zoneOffset = ZoneOffset.ofHoursMinutes(offsetHour, offsetMinute);\n+        long epochMilli = ZonedDateTime.of(1970, 1, 1, hour, minute, second, (int) rescale(fractionValue, precision, 9), zoneOffset)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNTk2MA=="}, "originalCommit": null, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDMxODYzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/TimestampToTimeWithTimezoneCast.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMjoxNDowNFrOHJn-_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMjoxNDowNFrOHJn-_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg1NDMzMw==", "bodyText": "maybe name this timestamp", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r479854333", "createdAt": "2020-08-31T02:14:04Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/TimestampToTimeWithTimezoneCast.java", "diffHunk": "@@ -18,40 +18,98 @@\n import io.prestosql.spi.function.LiteralParameters;\n import io.prestosql.spi.function.ScalarOperator;\n import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n import io.prestosql.spi.type.LongTimestamp;\n-import io.prestosql.spi.type.StandardTypes;\n-import org.joda.time.chrono.ISOChronology;\n \n import static io.prestosql.spi.function.OperatorType.CAST;\n-import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n-import static io.prestosql.type.DateTimeOperators.modulo24Hour;\n+import static io.prestosql.spi.type.DateTimeEncoding.packTimeWithTimeZone;\n+import static io.prestosql.type.DateTimes.MICROSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.type.DateTimes.getOffsetMinutes;\n+import static io.prestosql.type.DateTimes.rescale;\n import static io.prestosql.type.DateTimes.round;\n-import static io.prestosql.type.DateTimes.scaleEpochMicrosToMillis;\n-import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+import static io.prestosql.type.DateTimes.scaleEpochMillisToMicros;\n+import static java.lang.Math.floorMod;\n \n @ScalarOperator(CAST)\n public final class TimestampToTimeWithTimezoneCast\n {\n     private TimestampToTimeWithTimezoneCast() {}\n \n-    @LiteralParameters(\"p\")\n-    @SqlType(StandardTypes.TIME_WITH_TIME_ZONE)\n-    public static long cast(@LiteralParameter(\"p\") long precision, ConnectorSession session, @SqlType(\"timestamp(p)\") long value)\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision) with time zone\")\n+    public static long shortToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"timestamp(sourcePrecision)\") long value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDMxOTQ2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/TimestampToTimeWithTimezoneCast.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMjoxNDoyNlrOHJn_Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMjoxNDoyNlrOHJn_Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg1NDQzMA==", "bodyText": "maybe rename value to timestamp", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r479854430", "createdAt": "2020-08-31T02:14:26Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/TimestampToTimeWithTimezoneCast.java", "diffHunk": "@@ -18,40 +18,98 @@\n import io.prestosql.spi.function.LiteralParameters;\n import io.prestosql.spi.function.ScalarOperator;\n import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n import io.prestosql.spi.type.LongTimestamp;\n-import io.prestosql.spi.type.StandardTypes;\n-import org.joda.time.chrono.ISOChronology;\n \n import static io.prestosql.spi.function.OperatorType.CAST;\n-import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n-import static io.prestosql.type.DateTimeOperators.modulo24Hour;\n+import static io.prestosql.spi.type.DateTimeEncoding.packTimeWithTimeZone;\n+import static io.prestosql.type.DateTimes.MICROSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.type.DateTimes.getOffsetMinutes;\n+import static io.prestosql.type.DateTimes.rescale;\n import static io.prestosql.type.DateTimes.round;\n-import static io.prestosql.type.DateTimes.scaleEpochMicrosToMillis;\n-import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+import static io.prestosql.type.DateTimes.scaleEpochMillisToMicros;\n+import static java.lang.Math.floorMod;\n \n @ScalarOperator(CAST)\n public final class TimestampToTimeWithTimezoneCast\n {\n     private TimestampToTimeWithTimezoneCast() {}\n \n-    @LiteralParameters(\"p\")\n-    @SqlType(StandardTypes.TIME_WITH_TIME_ZONE)\n-    public static long cast(@LiteralParameter(\"p\") long precision, ConnectorSession session, @SqlType(\"timestamp(p)\") long value)\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision) with time zone\")\n+    public static long shortToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"timestamp(sourcePrecision)\") long value)\n     {\n-        if (precision > 3) {\n-            value = scaleEpochMicrosToMillis(round(value, 3));\n-        }\n+        // source precision <= 6\n+        // target precision <= 9\n+        long nanos = getMicros(sourcePrecision, value) * NANOSECONDS_PER_MICROSECOND;\n+\n+        nanos = round(nanos, (int) (9 - targetPrecision)) % NANOSECONDS_PER_DAY;\n+\n+        return packTimeWithTimeZone(nanos, getOffsetMinutes(session.getStart(), session.getTimeZoneKey()));\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision) with time zone\")\n+    public static long longToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"timestamp(sourcePrecision)\") LongTimestamp timestamp)\n+    {\n+        // source precision > 6\n+        // target precision <= 9\n+        long picos = getMicros(sourcePrecision, timestamp.getEpochMicros()) * PICOSECONDS_PER_MICROSECOND + timestamp.getPicosOfMicro();\n+        picos = round(picos, (int) (12 - targetPrecision));\n+\n+        long nanos = rescale(picos, 12, 9) % NANOSECONDS_PER_DAY;\n+        return packTimeWithTimeZone(nanos, getOffsetMinutes(session.getStart(), session.getTimeZoneKey()));\n+    }\n \n-        ISOChronology localChronology = getChronology(session.getTimeZoneKey());\n-        // This cast does treat TIMESTAMP as wall time in session TZ. This means that in order to get\n-        // its UTC representation we need to shift the value by the offset of TZ.\n-        return packDateTimeWithZone(localChronology.getZone().convertLocalToUTC(modulo24Hour(value), false), session.getTimeZoneKey());\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision) with time zone\")\n+    public static LongTimeWithTimeZone shortToLong(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            ConnectorSession session,\n+            @SqlType(\"timestamp(sourcePrecision)\") long value)\n+    {\n+        // source precision <= 6\n+        // target precision > 9\n+        long picos = getMicros(sourcePrecision, value) * PICOSECONDS_PER_MICROSECOND;\n+        return new LongTimeWithTimeZone(picos, getOffsetMinutes(session.getStart(), session.getTimeZoneKey()));\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision) with time zone\")\n+    public static LongTimeWithTimeZone longToLong(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"timestamp(sourcePrecision)\") LongTimestamp timestamp)\n+    {\n+        // source precision > 6\n+        // target precision > 9\n+        long picos = getMicros(sourcePrecision, timestamp.getEpochMicros()) * PICOSECONDS_PER_MICROSECOND + timestamp.getPicosOfMicro();\n+\n+        picos = round(picos, (int) (12 - targetPrecision)) % PICOSECONDS_PER_DAY;\n+\n+        return new LongTimeWithTimeZone(picos, getOffsetMinutes(session.getStart(), session.getTimeZoneKey()));\n     }\n \n-    @LiteralParameters(\"p\")\n-    @SqlType(StandardTypes.TIME_WITH_TIME_ZONE)\n-    public static long cast(ConnectorSession session, @SqlType(\"timestamp(p)\") LongTimestamp timestamp)\n+    private static long getMicros(long sourcePrecision, long value)\n     {\n-        return cast(6, session, timestamp.getEpochMicros());\n+        long epochMicros = value;\n+        if (sourcePrecision <= 3) {\n+            epochMicros = scaleEpochMillisToMicros(value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDMxOTc0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/TimestampToTimeWithTimezoneCast.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMjoxNDo0MVrOHJn_hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMjoxNDo0MVrOHJn_hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg1NDQ2OA==", "bodyText": "maybe rename value to timestamp", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r479854468", "createdAt": "2020-08-31T02:14:41Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/TimestampToTimeWithTimezoneCast.java", "diffHunk": "@@ -18,40 +18,98 @@\n import io.prestosql.spi.function.LiteralParameters;\n import io.prestosql.spi.function.ScalarOperator;\n import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n import io.prestosql.spi.type.LongTimestamp;\n-import io.prestosql.spi.type.StandardTypes;\n-import org.joda.time.chrono.ISOChronology;\n \n import static io.prestosql.spi.function.OperatorType.CAST;\n-import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n-import static io.prestosql.type.DateTimeOperators.modulo24Hour;\n+import static io.prestosql.spi.type.DateTimeEncoding.packTimeWithTimeZone;\n+import static io.prestosql.type.DateTimes.MICROSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.type.DateTimes.getOffsetMinutes;\n+import static io.prestosql.type.DateTimes.rescale;\n import static io.prestosql.type.DateTimes.round;\n-import static io.prestosql.type.DateTimes.scaleEpochMicrosToMillis;\n-import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+import static io.prestosql.type.DateTimes.scaleEpochMillisToMicros;\n+import static java.lang.Math.floorMod;\n \n @ScalarOperator(CAST)\n public final class TimestampToTimeWithTimezoneCast\n {\n     private TimestampToTimeWithTimezoneCast() {}\n \n-    @LiteralParameters(\"p\")\n-    @SqlType(StandardTypes.TIME_WITH_TIME_ZONE)\n-    public static long cast(@LiteralParameter(\"p\") long precision, ConnectorSession session, @SqlType(\"timestamp(p)\") long value)\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision) with time zone\")\n+    public static long shortToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"timestamp(sourcePrecision)\") long value)\n     {\n-        if (precision > 3) {\n-            value = scaleEpochMicrosToMillis(round(value, 3));\n-        }\n+        // source precision <= 6\n+        // target precision <= 9\n+        long nanos = getMicros(sourcePrecision, value) * NANOSECONDS_PER_MICROSECOND;\n+\n+        nanos = round(nanos, (int) (9 - targetPrecision)) % NANOSECONDS_PER_DAY;\n+\n+        return packTimeWithTimeZone(nanos, getOffsetMinutes(session.getStart(), session.getTimeZoneKey()));\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision) with time zone\")\n+    public static long longToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"timestamp(sourcePrecision)\") LongTimestamp timestamp)\n+    {\n+        // source precision > 6\n+        // target precision <= 9\n+        long picos = getMicros(sourcePrecision, timestamp.getEpochMicros()) * PICOSECONDS_PER_MICROSECOND + timestamp.getPicosOfMicro();\n+        picos = round(picos, (int) (12 - targetPrecision));\n+\n+        long nanos = rescale(picos, 12, 9) % NANOSECONDS_PER_DAY;\n+        return packTimeWithTimeZone(nanos, getOffsetMinutes(session.getStart(), session.getTimeZoneKey()));\n+    }\n \n-        ISOChronology localChronology = getChronology(session.getTimeZoneKey());\n-        // This cast does treat TIMESTAMP as wall time in session TZ. This means that in order to get\n-        // its UTC representation we need to shift the value by the offset of TZ.\n-        return packDateTimeWithZone(localChronology.getZone().convertLocalToUTC(modulo24Hour(value), false), session.getTimeZoneKey());\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision) with time zone\")\n+    public static LongTimeWithTimeZone shortToLong(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            ConnectorSession session,\n+            @SqlType(\"timestamp(sourcePrecision)\") long value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDMyMzAwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamptz/TimestampWithTimeZoneToTimeWithTimezoneCast.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMjoxNjo0OVrOHJoBLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwMjoxNjo0OVrOHJoBLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg1NDg5NA==", "bodyText": "maybe name this packedTimestamp", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r479854894", "createdAt": "2020-08-31T02:16:49Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamptz/TimestampWithTimeZoneToTimeWithTimezoneCast.java", "diffHunk": "@@ -13,44 +13,113 @@\n  */\n package io.prestosql.operator.scalar.timestamptz;\n \n+import io.prestosql.spi.function.LiteralParameter;\n import io.prestosql.spi.function.LiteralParameters;\n import io.prestosql.spi.function.ScalarOperator;\n import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n import io.prestosql.spi.type.LongTimestampWithTimeZone;\n-import io.prestosql.spi.type.StandardTypes;\n import io.prestosql.spi.type.TimeZoneKey;\n+import io.prestosql.type.DateTimes;\n+\n+import java.time.Instant;\n \n import static io.prestosql.spi.function.OperatorType.CAST;\n-import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.DateTimeEncoding.packTimeWithTimeZone;\n import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n import static io.prestosql.spi.type.DateTimeEncoding.unpackZoneKey;\n import static io.prestosql.spi.type.TimeZoneKey.getTimeZoneKey;\n-import static io.prestosql.type.DateTimes.roundToEpochMillis;\n+import static io.prestosql.type.DateTimes.MILLISECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+import static java.lang.Math.floorMod;\n \n @ScalarOperator(CAST)\n public final class TimestampWithTimeZoneToTimeWithTimezoneCast\n {\n     private TimestampWithTimeZoneToTimeWithTimezoneCast() {}\n \n-    @LiteralParameters(\"p\")\n-    @SqlType(StandardTypes.TIME_WITH_TIME_ZONE)\n-    public static long cast(@SqlType(\"timestamp(p) with time zone\") long packedEpochMillis)\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision) with time zone\")\n+    public static long shortToShort(\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            @SqlType(\"timestamp(sourcePrecision) with time zone\") long timestamp)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzcxMjQ2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/DateAdd.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDoxMDo1NVrOHKHlsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDoxMDo1NVrOHKHlsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3MjE0NQ==", "bodyText": "We maybe bel able to use toStringAscii here since there is an exact ascii match below", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480372145", "createdAt": "2020-08-31T20:10:55Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/DateAdd.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.operator.scalar.time.TimeOperators;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.function.Description;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+import io.prestosql.spi.type.StandardTypes;\n+\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.type.DateTimeEncoding.packTimeWithTimeZone;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackOffsetMinutes;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackTimeNanos;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.MAX_PRECISION;\n+import static io.prestosql.type.DateTimes.HOURS_PER_DAY;\n+import static io.prestosql.type.DateTimes.MILLISECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_NANOSECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.round;\n+import static java.util.Locale.ENGLISH;\n+import static org.joda.time.DateTimeConstants.MINUTES_PER_DAY;\n+\n+@Description(\"Add the specified amount of time to the given time\")\n+@ScalarFunction(\"date_add\")\n+public class DateAdd\n+{\n+    private DateAdd() {}\n+\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p) with time zone\")\n+    public static long add(\n+            @LiteralParameter(\"p\") long precision,\n+            @SqlType(\"varchar(x)\") Slice unit,\n+            @SqlType(StandardTypes.BIGINT) long value,\n+            @SqlType(\"time(p) with time zone\") long packedTime)\n+    {\n+        long picos = add(unpackTimeNanos(packedTime) * PICOSECONDS_PER_NANOSECOND, unit, value);\n+\n+        // smallest unit for \"value\" is millisecond, so we only need to round in the case below\n+        if (precision <= 3) {\n+            picos = round(picos, (int) (MAX_PRECISION - precision)) % PICOSECONDS_PER_DAY;\n+        }\n+\n+        return packTimeWithTimeZone(picos / PICOSECONDS_PER_NANOSECOND, unpackOffsetMinutes(packedTime));\n+    }\n+\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p) with time zone\")\n+    public static LongTimeWithTimeZone add(\n+            @SqlType(\"varchar(x)\") Slice unit,\n+            @SqlType(StandardTypes.BIGINT) long value,\n+            @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone time)\n+    {\n+        long picos = add(time.getPicoSeconds(), unit, value);\n+\n+        return new LongTimeWithTimeZone(picos, time.getOffsetMinutes());\n+    }\n+\n+    private static long add(long picos, Slice unit, long value)\n+    {\n+        long delta = value;\n+        String unitString = unit.toStringUtf8().toLowerCase(ENGLISH);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzcxOTE3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/ExtractHour.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDoxMzoxMVrOHKHp_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxODoxNToyNVrOHLCnhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3MzI0NA==", "bodyText": "Doesn't this need to be adjusted to the TZ offset?", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480373244", "createdAt": "2020-08-31T20:13:11Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/ExtractHour.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.prestosql.spi.function.Description;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+import io.prestosql.spi.type.StandardTypes;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackTimeNanos;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_HOUR;\n+\n+@Description(\"Hour of the day of the given time\")\n+@ScalarFunction(\"hour\")\n+public class ExtractHour\n+{\n+    private ExtractHour() {}\n+\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long extract(@SqlType(\"time(p) with time zone\") long packedTime)\n+    {\n+        return unpackTimeNanos(packedTime) / NANOSECONDS_PER_HOUR;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMzOTI2OQ==", "bodyText": "No. The encoded time is the time since midnight without consideration for the offset. Think of it as time w/ tz storing four separate fields: hour, minute, second, offset minutes.", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r481339269", "createdAt": "2020-09-01T18:15:25Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/ExtractHour.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.prestosql.spi.function.Description;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+import io.prestosql.spi.type.StandardTypes;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackTimeNanos;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_HOUR;\n+\n+@Description(\"Hour of the day of the given time\")\n+@ScalarFunction(\"hour\")\n+public class ExtractHour\n+{\n+    private ExtractHour() {}\n+\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long extract(@SqlType(\"time(p) with time zone\") long packedTime)\n+    {\n+        return unpackTimeNanos(packedTime) / NANOSECONDS_PER_HOUR;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3MzI0NA=="}, "originalCommit": null, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzcyMTYwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/ExtractMinute.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDoxMzo1OFrOHKHrdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxODoxNTo0M1rOHLCoNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3MzYyMw==", "bodyText": "Doesn't this need to be updated to TZ offset?", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480373623", "createdAt": "2020-08-31T20:13:58Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/ExtractMinute.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.prestosql.spi.function.Description;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+import io.prestosql.spi.type.StandardTypes;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackTimeNanos;\n+import static io.prestosql.type.DateTimes.MINUTES_PER_HOUR;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+\n+@Description(\"Minute of the hour of the given time\")\n+@ScalarFunction(\"minute\")\n+public class ExtractMinute\n+{\n+    private ExtractMinute() {}\n+\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long extract(@SqlType(\"time(p) with time zone\") long packedTime)\n+    {\n+        return (unpackTimeNanos(packedTime) / NANOSECONDS_PER_MINUTE) % MINUTES_PER_HOUR;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMzOTQ0NQ==", "bodyText": "No, see above.", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r481339445", "createdAt": "2020-09-01T18:15:43Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/ExtractMinute.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.prestosql.spi.function.Description;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+import io.prestosql.spi.type.StandardTypes;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackTimeNanos;\n+import static io.prestosql.type.DateTimes.MINUTES_PER_HOUR;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+\n+@Description(\"Minute of the hour of the given time\")\n+@ScalarFunction(\"minute\")\n+public class ExtractMinute\n+{\n+    private ExtractMinute() {}\n+\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long extract(@SqlType(\"time(p) with time zone\") long packedTime)\n+    {\n+        return (unpackTimeNanos(packedTime) / NANOSECONDS_PER_MINUTE) % MINUTES_PER_HOUR;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3MzYyMw=="}, "originalCommit": null, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDA2NTI2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/TimeWithTimeZoneOperators.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjowODo0NlrOHKK5OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjowODo0NlrOHKK5OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQyNjI5Ng==", "bodyText": "I think this code will be more readable if you have a normalize that takes packed long and one that takes the object version.  It might need names like normalizeShort and normalizeLong.  It is a little confusing to see the unpacking everywhere and to see the unnecessary multiply by PICOSECONDS_PER_NANOSECOND... this is especially true given subtract take packed values.", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480426296", "createdAt": "2020-08-31T22:08:46Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/TimeWithTimeZoneOperators.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.operator.scalar.time.TimeOperators;\n+import io.prestosql.spi.function.IsNull;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlNullable;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.type.Constraint;\n+\n+import static io.prestosql.spi.function.OperatorType.ADD;\n+import static io.prestosql.spi.function.OperatorType.EQUAL;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.HASH_CODE;\n+import static io.prestosql.spi.function.OperatorType.INDETERMINATE;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.NOT_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.SUBTRACT;\n+import static io.prestosql.spi.function.OperatorType.XX_HASH_64;\n+import static io.prestosql.spi.type.DateTimeEncoding.packTimeWithTimeZone;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackOffsetMinutes;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackTimeNanos;\n+import static io.prestosql.spi.type.TimeWithTimezoneTypes.hashLongTimeWithTimeZone;\n+import static io.prestosql.spi.type.TimeWithTimezoneTypes.hashShortTimeWithTimeZone;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_NANOSECOND;\n+import static io.prestosql.type.DateTimes.rescaleWithRounding;\n+import static java.lang.Math.floorMod;\n+\n+@SuppressWarnings(\"UtilityClassWithoutPrivateConstructor\")\n+public final class TimeWithTimeZoneOperators\n+{\n+    private TimeWithTimeZoneOperators() {}\n+\n+    /**\n+     * Normalize to offset +00:00. The calculation is done modulo 24h\n+     */\n+    private static long normalize(long picos, int offsetMinutes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDA5MjYyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/TimeWithTimeZoneOperators.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjoxOTo0MlrOHKLJYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjoxOTo0MlrOHKLJYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQzMDQzNA==", "bodyText": "maybe inline this?", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480430434", "createdAt": "2020-08-31T22:19:42Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/TimeWithTimeZoneOperators.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.operator.scalar.time.TimeOperators;\n+import io.prestosql.spi.function.IsNull;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlNullable;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.type.Constraint;\n+\n+import static io.prestosql.spi.function.OperatorType.ADD;\n+import static io.prestosql.spi.function.OperatorType.EQUAL;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.HASH_CODE;\n+import static io.prestosql.spi.function.OperatorType.INDETERMINATE;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.NOT_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.SUBTRACT;\n+import static io.prestosql.spi.function.OperatorType.XX_HASH_64;\n+import static io.prestosql.spi.type.DateTimeEncoding.packTimeWithTimeZone;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackOffsetMinutes;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackTimeNanos;\n+import static io.prestosql.spi.type.TimeWithTimezoneTypes.hashLongTimeWithTimeZone;\n+import static io.prestosql.spi.type.TimeWithTimezoneTypes.hashShortTimeWithTimeZone;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_NANOSECOND;\n+import static io.prestosql.type.DateTimes.rescaleWithRounding;\n+import static java.lang.Math.floorMod;\n+\n+@SuppressWarnings(\"UtilityClassWithoutPrivateConstructor\")\n+public final class TimeWithTimeZoneOperators\n+{\n+    private TimeWithTimeZoneOperators() {}\n+\n+    /**\n+     * Normalize to offset +00:00. The calculation is done modulo 24h\n+     */\n+    private static long normalize(long picos, int offsetMinutes)\n+    {\n+        return floorMod(picos - offsetMinutes * PICOSECONDS_PER_MINUTE, PICOSECONDS_PER_DAY);\n+    }\n+\n+    static long subtract(LongTimeWithTimeZone left, LongTimeWithTimeZone right)\n+    {\n+        long leftPicos = normalize(left.getPicoSeconds(), left.getOffsetMinutes());\n+        long rightPicos = normalize(right.getPicoSeconds(), right.getOffsetMinutes());\n+\n+        return leftPicos - rightPicos;\n+    }\n+\n+    static long subtract(long packedLeft, long packedRight)\n+    {\n+        long leftPicos = normalize(unpackTimeNanos(packedLeft) * PICOSECONDS_PER_NANOSECOND, unpackOffsetMinutes(packedLeft));\n+        long rightPicos = normalize(unpackTimeNanos(packedRight) * PICOSECONDS_PER_NANOSECOND, unpackOffsetMinutes(packedRight));\n+\n+        return leftPicos - rightPicos;\n+    }\n+\n+    @ScalarOperator(EQUAL)\n+    public static final class Equal\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlNullable\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static Boolean equal(@SqlType(\"time(p) with time zone\") long left, @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            long leftPicos = normalize(unpackTimeNanos(left) * PICOSECONDS_PER_NANOSECOND, unpackOffsetMinutes(left));\n+            long rightPicos = normalize(unpackTimeNanos(right) * PICOSECONDS_PER_NANOSECOND, unpackOffsetMinutes(right));\n+\n+            return leftPicos == rightPicos;\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlNullable\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static Boolean equal(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left, @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            long leftPicos = normalize(left.getPicoSeconds(), left.getOffsetMinutes());\n+            long rightPicos = normalize(right.getPicoSeconds(), right.getOffsetMinutes());\n+\n+            return leftPicos == rightPicos;\n+        }\n+    }\n+\n+    @ScalarOperator(NOT_EQUAL)\n+    public static final class NotEqual\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean notEqual(@SqlType(\"time(p) with time zone\") long left, @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            return !Equal.equal(left, right);\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean notEqual(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left, @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            return !Equal.equal(left, right);\n+        }\n+    }\n+\n+    @ScalarOperator(LESS_THAN)\n+    public static final class LessThan\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean lessThan(@SqlType(\"time(p) with time zone\") long left, @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            return subtract(left, right) < 0;\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean lessThan(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left, @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            return subtract(left, right) < 0;\n+        }\n+    }\n+\n+    @ScalarOperator(LESS_THAN_OR_EQUAL)\n+    public static final class LessThanOrEqual\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean lessThanOrEqual(@SqlType(\"time(p) with time zone\") long left, @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            return subtract(left, right) <= 0;\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean lessThanOrEqual(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left, @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            return subtract(left, right) <= 0;\n+        }\n+    }\n+\n+    @ScalarOperator(GREATER_THAN)\n+    public static final class GreaterThan\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean greaterThan(@SqlType(\"time(p) with time zone\") long left, @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            return !LessThanOrEqual.lessThanOrEqual(left, right);\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean greaterThan(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left, @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            return !LessThanOrEqual.lessThanOrEqual(left, right);\n+        }\n+    }\n+\n+    @ScalarOperator(GREATER_THAN_OR_EQUAL)\n+    public static final class GreaterThanOrEqual\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean greaterThanOrEqual(@SqlType(\"time(p) with time zone\") long left, @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            return !LessThan.lessThan(left, right);\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean greaterThanOrEqual(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left, @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            return !LessThan.lessThan(left, right);\n+        }\n+    }\n+\n+    @ScalarOperator(HASH_CODE)\n+    public static final class HashCode\n+    {\n+        @SqlType(StandardTypes.BIGINT)\n+        @LiteralParameters(\"p\")\n+        public static long hashCode(@SqlType(\"time(p) with time zone\") long packedTime)\n+        {\n+            return hashShortTimeWithTimeZone(packedTime);\n+        }\n+\n+        @SqlType(StandardTypes.BIGINT)\n+        @LiteralParameters(\"p\")\n+        public static long hashCode(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone time)\n+        {\n+            return hashLongTimeWithTimeZone(time);\n+        }\n+    }\n+\n+    @ScalarOperator(INDETERMINATE)\n+    public static final class Indeterminate\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean indeterminate(@SqlType(\"time(p) with time zone\") long value, @IsNull boolean isNull)\n+        {\n+            return isNull;\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean indeterminate(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone value, @IsNull boolean isNull)\n+        {\n+            return isNull;\n+        }\n+    }\n+\n+    @ScalarOperator(XX_HASH_64)\n+    public static final class XxHash64Operator\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BIGINT)\n+        public static long xxHash64(@SqlType(\"time(p) with time zone\") long packedTime)\n+        {\n+            return XxHash64.hash(normalize(unpackTimeNanos(packedTime) * PICOSECONDS_PER_NANOSECOND, unpackOffsetMinutes(packedTime)));\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BIGINT)\n+        public static long xxHash64(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone value)\n+        {\n+            return XxHash64.hash(normalize(value.getPicoSeconds(), value.getOffsetMinutes()));\n+        }\n+    }\n+\n+    @ScalarOperator(ADD)\n+    public static final class TimePlusIntervalDayToSecond\n+    {\n+        @LiteralParameters({\"p\", \"u\"})\n+        @SqlType(\"time(u) with time zone\")\n+        @Constraint(variable = \"u\", expression = \"max(3, p)\") // Interval is currently p = 3, so the minimum result precision is 3.\n+        public static long add(\n+                @SqlType(\"time(p) with time zone\") long packedTime,\n+                @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval)\n+        {\n+            long picos = unpackTimeNanos(packedTime) * PICOSECONDS_PER_NANOSECOND;\n+            int offsetMinutes = unpackOffsetMinutes(packedTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDEwMjI1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/TimeWithTimeZoneOperators.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjoyMzoyNlrOHKLO9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjoyMzoyNlrOHKLO9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQzMTg2Mg==", "bodyText": "I believe this is just subtract?", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480431862", "createdAt": "2020-08-31T22:23:26Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/TimeWithTimeZoneOperators.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.operator.scalar.time.TimeOperators;\n+import io.prestosql.spi.function.IsNull;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlNullable;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.type.Constraint;\n+\n+import static io.prestosql.spi.function.OperatorType.ADD;\n+import static io.prestosql.spi.function.OperatorType.EQUAL;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.HASH_CODE;\n+import static io.prestosql.spi.function.OperatorType.INDETERMINATE;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.NOT_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.SUBTRACT;\n+import static io.prestosql.spi.function.OperatorType.XX_HASH_64;\n+import static io.prestosql.spi.type.DateTimeEncoding.packTimeWithTimeZone;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackOffsetMinutes;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackTimeNanos;\n+import static io.prestosql.spi.type.TimeWithTimezoneTypes.hashLongTimeWithTimeZone;\n+import static io.prestosql.spi.type.TimeWithTimezoneTypes.hashShortTimeWithTimeZone;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_NANOSECOND;\n+import static io.prestosql.type.DateTimes.rescaleWithRounding;\n+import static java.lang.Math.floorMod;\n+\n+@SuppressWarnings(\"UtilityClassWithoutPrivateConstructor\")\n+public final class TimeWithTimeZoneOperators\n+{\n+    private TimeWithTimeZoneOperators() {}\n+\n+    /**\n+     * Normalize to offset +00:00. The calculation is done modulo 24h\n+     */\n+    private static long normalize(long picos, int offsetMinutes)\n+    {\n+        return floorMod(picos - offsetMinutes * PICOSECONDS_PER_MINUTE, PICOSECONDS_PER_DAY);\n+    }\n+\n+    static long subtract(LongTimeWithTimeZone left, LongTimeWithTimeZone right)\n+    {\n+        long leftPicos = normalize(left.getPicoSeconds(), left.getOffsetMinutes());\n+        long rightPicos = normalize(right.getPicoSeconds(), right.getOffsetMinutes());\n+\n+        return leftPicos - rightPicos;\n+    }\n+\n+    static long subtract(long packedLeft, long packedRight)\n+    {\n+        long leftPicos = normalize(unpackTimeNanos(packedLeft) * PICOSECONDS_PER_NANOSECOND, unpackOffsetMinutes(packedLeft));\n+        long rightPicos = normalize(unpackTimeNanos(packedRight) * PICOSECONDS_PER_NANOSECOND, unpackOffsetMinutes(packedRight));\n+\n+        return leftPicos - rightPicos;\n+    }\n+\n+    @ScalarOperator(EQUAL)\n+    public static final class Equal\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlNullable\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static Boolean equal(@SqlType(\"time(p) with time zone\") long left, @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            long leftPicos = normalize(unpackTimeNanos(left) * PICOSECONDS_PER_NANOSECOND, unpackOffsetMinutes(left));\n+            long rightPicos = normalize(unpackTimeNanos(right) * PICOSECONDS_PER_NANOSECOND, unpackOffsetMinutes(right));\n+\n+            return leftPicos == rightPicos;\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlNullable\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static Boolean equal(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left, @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            long leftPicos = normalize(left.getPicoSeconds(), left.getOffsetMinutes());\n+            long rightPicos = normalize(right.getPicoSeconds(), right.getOffsetMinutes());\n+\n+            return leftPicos == rightPicos;\n+        }\n+    }\n+\n+    @ScalarOperator(NOT_EQUAL)\n+    public static final class NotEqual\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean notEqual(@SqlType(\"time(p) with time zone\") long left, @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            return !Equal.equal(left, right);\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean notEqual(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left, @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            return !Equal.equal(left, right);\n+        }\n+    }\n+\n+    @ScalarOperator(LESS_THAN)\n+    public static final class LessThan\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean lessThan(@SqlType(\"time(p) with time zone\") long left, @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            return subtract(left, right) < 0;\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean lessThan(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left, @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            return subtract(left, right) < 0;\n+        }\n+    }\n+\n+    @ScalarOperator(LESS_THAN_OR_EQUAL)\n+    public static final class LessThanOrEqual\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean lessThanOrEqual(@SqlType(\"time(p) with time zone\") long left, @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            return subtract(left, right) <= 0;\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean lessThanOrEqual(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left, @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            return subtract(left, right) <= 0;\n+        }\n+    }\n+\n+    @ScalarOperator(GREATER_THAN)\n+    public static final class GreaterThan\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean greaterThan(@SqlType(\"time(p) with time zone\") long left, @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            return !LessThanOrEqual.lessThanOrEqual(left, right);\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean greaterThan(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left, @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            return !LessThanOrEqual.lessThanOrEqual(left, right);\n+        }\n+    }\n+\n+    @ScalarOperator(GREATER_THAN_OR_EQUAL)\n+    public static final class GreaterThanOrEqual\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean greaterThanOrEqual(@SqlType(\"time(p) with time zone\") long left, @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            return !LessThan.lessThan(left, right);\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean greaterThanOrEqual(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left, @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            return !LessThan.lessThan(left, right);\n+        }\n+    }\n+\n+    @ScalarOperator(HASH_CODE)\n+    public static final class HashCode\n+    {\n+        @SqlType(StandardTypes.BIGINT)\n+        @LiteralParameters(\"p\")\n+        public static long hashCode(@SqlType(\"time(p) with time zone\") long packedTime)\n+        {\n+            return hashShortTimeWithTimeZone(packedTime);\n+        }\n+\n+        @SqlType(StandardTypes.BIGINT)\n+        @LiteralParameters(\"p\")\n+        public static long hashCode(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone time)\n+        {\n+            return hashLongTimeWithTimeZone(time);\n+        }\n+    }\n+\n+    @ScalarOperator(INDETERMINATE)\n+    public static final class Indeterminate\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean indeterminate(@SqlType(\"time(p) with time zone\") long value, @IsNull boolean isNull)\n+        {\n+            return isNull;\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean indeterminate(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone value, @IsNull boolean isNull)\n+        {\n+            return isNull;\n+        }\n+    }\n+\n+    @ScalarOperator(XX_HASH_64)\n+    public static final class XxHash64Operator\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BIGINT)\n+        public static long xxHash64(@SqlType(\"time(p) with time zone\") long packedTime)\n+        {\n+            return XxHash64.hash(normalize(unpackTimeNanos(packedTime) * PICOSECONDS_PER_NANOSECOND, unpackOffsetMinutes(packedTime)));\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BIGINT)\n+        public static long xxHash64(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone value)\n+        {\n+            return XxHash64.hash(normalize(value.getPicoSeconds(), value.getOffsetMinutes()));\n+        }\n+    }\n+\n+    @ScalarOperator(ADD)\n+    public static final class TimePlusIntervalDayToSecond\n+    {\n+        @LiteralParameters({\"p\", \"u\"})\n+        @SqlType(\"time(u) with time zone\")\n+        @Constraint(variable = \"u\", expression = \"max(3, p)\") // Interval is currently p = 3, so the minimum result precision is 3.\n+        public static long add(\n+                @SqlType(\"time(p) with time zone\") long packedTime,\n+                @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval)\n+        {\n+            long picos = unpackTimeNanos(packedTime) * PICOSECONDS_PER_NANOSECOND;\n+            int offsetMinutes = unpackOffsetMinutes(packedTime);\n+\n+            long nanos = TimeOperators.add(picos, interval * PICOSECONDS_PER_MILLISECOND) / PICOSECONDS_PER_NANOSECOND;\n+\n+            return packTimeWithTimeZone(nanos, offsetMinutes);\n+        }\n+\n+        @LiteralParameters({\"p\", \"u\"})\n+        @SqlType(\"time(u) with time zone\")\n+        @Constraint(variable = \"u\", expression = \"max(3, p)\") // Interval is currently p = 3, so the minimum result precision is 3.\n+        public static LongTimeWithTimeZone add(\n+                @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone time,\n+                @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval)\n+        {\n+            long picos = TimeOperators.add(time.getPicoSeconds(), interval * PICOSECONDS_PER_MILLISECOND);\n+            return new LongTimeWithTimeZone(picos, time.getOffsetMinutes());\n+        }\n+    }\n+\n+    @ScalarOperator(ADD)\n+    public static final class IntervalDayToSecondPlusTime\n+    {\n+        @LiteralParameters({\"p\", \"u\"})\n+        @SqlType(\"time(u) with time zone\")\n+        @Constraint(variable = \"u\", expression = \"max(3, p)\") // Interval is currently p = 3, so the minimum result precision is 3.\n+        public static long add(\n+                @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval,\n+                @SqlType(\"time(p) with time zone\") long time)\n+        {\n+            return TimePlusIntervalDayToSecond.add(time, interval);\n+        }\n+\n+        @LiteralParameters({\"p\", \"u\"})\n+        @SqlType(\"time(u) with time zone\")\n+        @Constraint(variable = \"u\", expression = \"max(3, p)\") // Interval is currently p = 3, so the minimum result precision is 3.\n+        public static LongTimeWithTimeZone add(\n+                @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval,\n+                @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone time)\n+        {\n+            return TimePlusIntervalDayToSecond.add(time, interval);\n+        }\n+    }\n+\n+    @ScalarOperator(SUBTRACT)\n+    public static final class TimeMinusIntervalDayToSecond\n+    {\n+        @LiteralParameters({\"p\", \"u\"})\n+        @SqlType(\"time(u) with time zone\")\n+        @Constraint(variable = \"u\", expression = \"max(3, p)\") // Interval is currently p = 3, so the minimum result precision is 3.\n+        public static long subtract(\n+                @SqlType(\"time(p) with time zone\") long packedTime,\n+                @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval)\n+        {\n+            return TimePlusIntervalDayToSecond.add(packedTime, -interval);\n+        }\n+\n+        @LiteralParameters({\"p\", \"u\"})\n+        @SqlType(\"time(u) with time zone\")\n+        @Constraint(variable = \"u\", expression = \"max(3, p)\") // Interval is currently p = 3, so the minimum result precision is 3.\n+        public static LongTimeWithTimeZone subtract(\n+                @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone time,\n+                @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval)\n+        {\n+            return TimePlusIntervalDayToSecond.add(time, -interval);\n+        }\n+    }\n+\n+    @ScalarOperator(SUBTRACT)\n+    public static final class TimeMinusTime\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND)\n+        public static long subtract(\n+                @SqlType(\"time(p) with time zone\") long left,\n+                @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            long leftPicos = unpackTimeNanos(left) * PICOSECONDS_PER_NANOSECOND;\n+            int leftOffsetMinutes = unpackOffsetMinutes(left);\n+            long rightPicos = unpackTimeNanos(right) * PICOSECONDS_PER_NANOSECOND;\n+            int rightOffsetMinutes = unpackOffsetMinutes(right);\n+\n+            long interval = normalize(leftPicos, leftOffsetMinutes) - normalize(rightPicos, rightOffsetMinutes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 341}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDEwMjYwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/TimeWithTimeZoneOperators.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjoyMzozNFrOHKLPKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjoyMzozNFrOHKLPKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQzMTkxNA==", "bodyText": "same", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480431914", "createdAt": "2020-08-31T22:23:34Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/TimeWithTimeZoneOperators.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.operator.scalar.time.TimeOperators;\n+import io.prestosql.spi.function.IsNull;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlNullable;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.type.Constraint;\n+\n+import static io.prestosql.spi.function.OperatorType.ADD;\n+import static io.prestosql.spi.function.OperatorType.EQUAL;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.HASH_CODE;\n+import static io.prestosql.spi.function.OperatorType.INDETERMINATE;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.NOT_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.SUBTRACT;\n+import static io.prestosql.spi.function.OperatorType.XX_HASH_64;\n+import static io.prestosql.spi.type.DateTimeEncoding.packTimeWithTimeZone;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackOffsetMinutes;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackTimeNanos;\n+import static io.prestosql.spi.type.TimeWithTimezoneTypes.hashLongTimeWithTimeZone;\n+import static io.prestosql.spi.type.TimeWithTimezoneTypes.hashShortTimeWithTimeZone;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_NANOSECOND;\n+import static io.prestosql.type.DateTimes.rescaleWithRounding;\n+import static java.lang.Math.floorMod;\n+\n+@SuppressWarnings(\"UtilityClassWithoutPrivateConstructor\")\n+public final class TimeWithTimeZoneOperators\n+{\n+    private TimeWithTimeZoneOperators() {}\n+\n+    /**\n+     * Normalize to offset +00:00. The calculation is done modulo 24h\n+     */\n+    private static long normalize(long picos, int offsetMinutes)\n+    {\n+        return floorMod(picos - offsetMinutes * PICOSECONDS_PER_MINUTE, PICOSECONDS_PER_DAY);\n+    }\n+\n+    static long subtract(LongTimeWithTimeZone left, LongTimeWithTimeZone right)\n+    {\n+        long leftPicos = normalize(left.getPicoSeconds(), left.getOffsetMinutes());\n+        long rightPicos = normalize(right.getPicoSeconds(), right.getOffsetMinutes());\n+\n+        return leftPicos - rightPicos;\n+    }\n+\n+    static long subtract(long packedLeft, long packedRight)\n+    {\n+        long leftPicos = normalize(unpackTimeNanos(packedLeft) * PICOSECONDS_PER_NANOSECOND, unpackOffsetMinutes(packedLeft));\n+        long rightPicos = normalize(unpackTimeNanos(packedRight) * PICOSECONDS_PER_NANOSECOND, unpackOffsetMinutes(packedRight));\n+\n+        return leftPicos - rightPicos;\n+    }\n+\n+    @ScalarOperator(EQUAL)\n+    public static final class Equal\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlNullable\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static Boolean equal(@SqlType(\"time(p) with time zone\") long left, @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            long leftPicos = normalize(unpackTimeNanos(left) * PICOSECONDS_PER_NANOSECOND, unpackOffsetMinutes(left));\n+            long rightPicos = normalize(unpackTimeNanos(right) * PICOSECONDS_PER_NANOSECOND, unpackOffsetMinutes(right));\n+\n+            return leftPicos == rightPicos;\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlNullable\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static Boolean equal(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left, @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            long leftPicos = normalize(left.getPicoSeconds(), left.getOffsetMinutes());\n+            long rightPicos = normalize(right.getPicoSeconds(), right.getOffsetMinutes());\n+\n+            return leftPicos == rightPicos;\n+        }\n+    }\n+\n+    @ScalarOperator(NOT_EQUAL)\n+    public static final class NotEqual\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean notEqual(@SqlType(\"time(p) with time zone\") long left, @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            return !Equal.equal(left, right);\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean notEqual(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left, @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            return !Equal.equal(left, right);\n+        }\n+    }\n+\n+    @ScalarOperator(LESS_THAN)\n+    public static final class LessThan\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean lessThan(@SqlType(\"time(p) with time zone\") long left, @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            return subtract(left, right) < 0;\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean lessThan(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left, @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            return subtract(left, right) < 0;\n+        }\n+    }\n+\n+    @ScalarOperator(LESS_THAN_OR_EQUAL)\n+    public static final class LessThanOrEqual\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean lessThanOrEqual(@SqlType(\"time(p) with time zone\") long left, @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            return subtract(left, right) <= 0;\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean lessThanOrEqual(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left, @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            return subtract(left, right) <= 0;\n+        }\n+    }\n+\n+    @ScalarOperator(GREATER_THAN)\n+    public static final class GreaterThan\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean greaterThan(@SqlType(\"time(p) with time zone\") long left, @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            return !LessThanOrEqual.lessThanOrEqual(left, right);\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean greaterThan(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left, @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            return !LessThanOrEqual.lessThanOrEqual(left, right);\n+        }\n+    }\n+\n+    @ScalarOperator(GREATER_THAN_OR_EQUAL)\n+    public static final class GreaterThanOrEqual\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean greaterThanOrEqual(@SqlType(\"time(p) with time zone\") long left, @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            return !LessThan.lessThan(left, right);\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean greaterThanOrEqual(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left, @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            return !LessThan.lessThan(left, right);\n+        }\n+    }\n+\n+    @ScalarOperator(HASH_CODE)\n+    public static final class HashCode\n+    {\n+        @SqlType(StandardTypes.BIGINT)\n+        @LiteralParameters(\"p\")\n+        public static long hashCode(@SqlType(\"time(p) with time zone\") long packedTime)\n+        {\n+            return hashShortTimeWithTimeZone(packedTime);\n+        }\n+\n+        @SqlType(StandardTypes.BIGINT)\n+        @LiteralParameters(\"p\")\n+        public static long hashCode(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone time)\n+        {\n+            return hashLongTimeWithTimeZone(time);\n+        }\n+    }\n+\n+    @ScalarOperator(INDETERMINATE)\n+    public static final class Indeterminate\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean indeterminate(@SqlType(\"time(p) with time zone\") long value, @IsNull boolean isNull)\n+        {\n+            return isNull;\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean indeterminate(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone value, @IsNull boolean isNull)\n+        {\n+            return isNull;\n+        }\n+    }\n+\n+    @ScalarOperator(XX_HASH_64)\n+    public static final class XxHash64Operator\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BIGINT)\n+        public static long xxHash64(@SqlType(\"time(p) with time zone\") long packedTime)\n+        {\n+            return XxHash64.hash(normalize(unpackTimeNanos(packedTime) * PICOSECONDS_PER_NANOSECOND, unpackOffsetMinutes(packedTime)));\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BIGINT)\n+        public static long xxHash64(@SqlType(\"time(p) with time zone\") LongTimeWithTimeZone value)\n+        {\n+            return XxHash64.hash(normalize(value.getPicoSeconds(), value.getOffsetMinutes()));\n+        }\n+    }\n+\n+    @ScalarOperator(ADD)\n+    public static final class TimePlusIntervalDayToSecond\n+    {\n+        @LiteralParameters({\"p\", \"u\"})\n+        @SqlType(\"time(u) with time zone\")\n+        @Constraint(variable = \"u\", expression = \"max(3, p)\") // Interval is currently p = 3, so the minimum result precision is 3.\n+        public static long add(\n+                @SqlType(\"time(p) with time zone\") long packedTime,\n+                @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval)\n+        {\n+            long picos = unpackTimeNanos(packedTime) * PICOSECONDS_PER_NANOSECOND;\n+            int offsetMinutes = unpackOffsetMinutes(packedTime);\n+\n+            long nanos = TimeOperators.add(picos, interval * PICOSECONDS_PER_MILLISECOND) / PICOSECONDS_PER_NANOSECOND;\n+\n+            return packTimeWithTimeZone(nanos, offsetMinutes);\n+        }\n+\n+        @LiteralParameters({\"p\", \"u\"})\n+        @SqlType(\"time(u) with time zone\")\n+        @Constraint(variable = \"u\", expression = \"max(3, p)\") // Interval is currently p = 3, so the minimum result precision is 3.\n+        public static LongTimeWithTimeZone add(\n+                @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone time,\n+                @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval)\n+        {\n+            long picos = TimeOperators.add(time.getPicoSeconds(), interval * PICOSECONDS_PER_MILLISECOND);\n+            return new LongTimeWithTimeZone(picos, time.getOffsetMinutes());\n+        }\n+    }\n+\n+    @ScalarOperator(ADD)\n+    public static final class IntervalDayToSecondPlusTime\n+    {\n+        @LiteralParameters({\"p\", \"u\"})\n+        @SqlType(\"time(u) with time zone\")\n+        @Constraint(variable = \"u\", expression = \"max(3, p)\") // Interval is currently p = 3, so the minimum result precision is 3.\n+        public static long add(\n+                @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval,\n+                @SqlType(\"time(p) with time zone\") long time)\n+        {\n+            return TimePlusIntervalDayToSecond.add(time, interval);\n+        }\n+\n+        @LiteralParameters({\"p\", \"u\"})\n+        @SqlType(\"time(u) with time zone\")\n+        @Constraint(variable = \"u\", expression = \"max(3, p)\") // Interval is currently p = 3, so the minimum result precision is 3.\n+        public static LongTimeWithTimeZone add(\n+                @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval,\n+                @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone time)\n+        {\n+            return TimePlusIntervalDayToSecond.add(time, interval);\n+        }\n+    }\n+\n+    @ScalarOperator(SUBTRACT)\n+    public static final class TimeMinusIntervalDayToSecond\n+    {\n+        @LiteralParameters({\"p\", \"u\"})\n+        @SqlType(\"time(u) with time zone\")\n+        @Constraint(variable = \"u\", expression = \"max(3, p)\") // Interval is currently p = 3, so the minimum result precision is 3.\n+        public static long subtract(\n+                @SqlType(\"time(p) with time zone\") long packedTime,\n+                @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval)\n+        {\n+            return TimePlusIntervalDayToSecond.add(packedTime, -interval);\n+        }\n+\n+        @LiteralParameters({\"p\", \"u\"})\n+        @SqlType(\"time(u) with time zone\")\n+        @Constraint(variable = \"u\", expression = \"max(3, p)\") // Interval is currently p = 3, so the minimum result precision is 3.\n+        public static LongTimeWithTimeZone subtract(\n+                @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone time,\n+                @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval)\n+        {\n+            return TimePlusIntervalDayToSecond.add(time, -interval);\n+        }\n+    }\n+\n+    @ScalarOperator(SUBTRACT)\n+    public static final class TimeMinusTime\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND)\n+        public static long subtract(\n+                @SqlType(\"time(p) with time zone\") long left,\n+                @SqlType(\"time(p) with time zone\") long right)\n+        {\n+            long leftPicos = unpackTimeNanos(left) * PICOSECONDS_PER_NANOSECOND;\n+            int leftOffsetMinutes = unpackOffsetMinutes(left);\n+            long rightPicos = unpackTimeNanos(right) * PICOSECONDS_PER_NANOSECOND;\n+            int rightOffsetMinutes = unpackOffsetMinutes(right);\n+\n+            long interval = normalize(leftPicos, leftOffsetMinutes) - normalize(rightPicos, rightOffsetMinutes);\n+\n+            return rescaleWithRounding(interval, 12, 3);\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND)\n+        public static long subtract(\n+                @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone left,\n+                @SqlType(\"time(p) with time zone\") LongTimeWithTimeZone right)\n+        {\n+            long leftPicos = left.getPicoSeconds();\n+            int leftOffsetMinutes = left.getOffsetMinutes();\n+            long rightPicos = right.getPicoSeconds();\n+            int rightOffsetMinutes = right.getOffsetMinutes();\n+\n+            long interval = normalize(leftPicos, leftOffsetMinutes) - normalize(rightPicos, rightOffsetMinutes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 357}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDEwNTc0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/TimeWithTimeZoneToTimeCast.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjoyNDo1OFrOHKLREg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDo1NTo0OFrOHLzLOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQzMjQwMg==", "bodyText": "I'm surprised there isn't already a helper for this", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480432402", "createdAt": "2020-08-31T22:24:58Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/TimeWithTimeZoneToTimeCast.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackTimeNanos;\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_NANOSECOND;\n+import static io.prestosql.type.DateTimes.round;\n+\n+@ScalarOperator(CAST)\n+public final class TimeWithTimeZoneToTimeCast\n+{\n+    private TimeWithTimeZoneToTimeCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision)\")\n+    public static long cast(\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            @SqlType(\"time(sourcePrecision) with time zone\") long packedTime)\n+    {\n+        return convert(targetPrecision, unpackTimeNanos(packedTime) * PICOSECONDS_PER_NANOSECOND);\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision)\")\n+    public static long cast(\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            @SqlType(\"time(sourcePrecision) with time zone\") LongTimeWithTimeZone timestamp)\n+    {\n+        return convert(targetPrecision, timestamp.getPicoSeconds());\n+    }\n+\n+    private static long convert(long targetPrecision, long picos)\n+    {\n+        return round(picos, (int) (MAX_PRECISION - targetPrecision)) % PICOSECONDS_PER_DAY;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEzNDg0Mg==", "bodyText": "I considered adding one, but it'd look like: roundMod(picos, (int) (MAX_PRECISION - targetPrecision), PICOSECONDS_PER_DAY) so it doesn't abstract much (it's needed for picos and for nanos)", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r482134842", "createdAt": "2020-09-02T14:55:48Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/TimeWithTimeZoneToTimeCast.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackTimeNanos;\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_NANOSECOND;\n+import static io.prestosql.type.DateTimes.round;\n+\n+@ScalarOperator(CAST)\n+public final class TimeWithTimeZoneToTimeCast\n+{\n+    private TimeWithTimeZoneToTimeCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision)\")\n+    public static long cast(\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            @SqlType(\"time(sourcePrecision) with time zone\") long packedTime)\n+    {\n+        return convert(targetPrecision, unpackTimeNanos(packedTime) * PICOSECONDS_PER_NANOSECOND);\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision)\")\n+    public static long cast(\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            @SqlType(\"time(sourcePrecision) with time zone\") LongTimeWithTimeZone timestamp)\n+    {\n+        return convert(targetPrecision, timestamp.getPicoSeconds());\n+    }\n+\n+    private static long convert(long targetPrecision, long picos)\n+    {\n+        return round(picos, (int) (MAX_PRECISION - targetPrecision)) % PICOSECONDS_PER_DAY;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQzMjQwMg=="}, "originalCommit": null, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDExMTYyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/TimeWithTimeZoneToTimeWithTimeZoneCast.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjoyNjowOFrOHKLUTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxODo0MDoyNVrOHLDcqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQzMzIzMA==", "bodyText": "should this be floor mod?  same for all the variants", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480433230", "createdAt": "2020-08-31T22:26:08Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/TimeWithTimeZoneToTimeWithTimeZoneCast.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.type.DateTimeEncoding.packTimeWithTimeZone;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackOffsetMinutes;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackTimeNanos;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.MAX_SHORT_PRECISION;\n+import static io.prestosql.spi.type.Timestamps.NANOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_NANOSECOND;\n+import static io.prestosql.type.DateTimes.round;\n+\n+@ScalarOperator(CAST)\n+public final class TimeWithTimeZoneToTimeWithTimeZoneCast\n+{\n+    private TimeWithTimeZoneToTimeWithTimeZoneCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision) with time zone\")\n+    public static long shortToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            @SqlType(\"time(sourcePrecision) with time zone\") long packedTime)\n+    {\n+        if (sourcePrecision <= targetPrecision) {\n+            return packedTime;\n+        }\n+\n+        long nanos = unpackTimeNanos(packedTime);\n+        nanos = round(nanos, (int) (MAX_SHORT_PRECISION - targetPrecision));\n+        return packTimeWithTimeZone(nanos % NANOSECONDS_PER_DAY, unpackOffsetMinutes(packedTime));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1Mjg3Mg==", "bodyText": "mod is fine, since nanos is guaranteed to be positive. floorMod is required for epoch-based numbers that can be negative.", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r481352872", "createdAt": "2020-09-01T18:40:25Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/TimeWithTimeZoneToTimeWithTimeZoneCast.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.type.DateTimeEncoding.packTimeWithTimeZone;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackOffsetMinutes;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackTimeNanos;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.MAX_SHORT_PRECISION;\n+import static io.prestosql.spi.type.Timestamps.NANOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_NANOSECOND;\n+import static io.prestosql.type.DateTimes.round;\n+\n+@ScalarOperator(CAST)\n+public final class TimeWithTimeZoneToTimeWithTimeZoneCast\n+{\n+    private TimeWithTimeZoneToTimeWithTimeZoneCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision) with time zone\")\n+    public static long shortToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            @SqlType(\"time(sourcePrecision) with time zone\") long packedTime)\n+    {\n+        if (sourcePrecision <= targetPrecision) {\n+            return packedTime;\n+        }\n+\n+        long nanos = unpackTimeNanos(packedTime);\n+        nanos = round(nanos, (int) (MAX_SHORT_PRECISION - targetPrecision));\n+        return packTimeWithTimeZone(nanos % NANOSECONDS_PER_DAY, unpackOffsetMinutes(packedTime));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQzMzIzMA=="}, "originalCommit": null, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDE1MDQxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/TimeWithTimeZoneToTimestampWithTimeZoneCast.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjozNDowNVrOHKLpbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNTowOTo1NlrOHLz9Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQzODYzNg==", "bodyText": "Is it possible to combine this to something like multiplyExact(epochDay, MILLISECONDS_PER_DAY) + (picos /  PICOSECONDS_PER_MILLISECOND)", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480438636", "createdAt": "2020-08-31T22:34:05Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/TimeWithTimeZoneToTimestampWithTimeZoneCast.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+import io.prestosql.spi.type.LongTimestampWithTimeZone;\n+\n+import java.time.LocalDate;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackOffsetMinutes;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackTimeNanos;\n+import static io.prestosql.spi.type.TimeZoneKey.getTimeZoneKeyForOffset;\n+import static io.prestosql.type.DateTimes.MILLISECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n+import static java.lang.Math.floorMod;\n+import static java.lang.Math.multiplyExact;\n+\n+@ScalarOperator(CAST)\n+public final class TimeWithTimeZoneToTimestampWithTimeZoneCast\n+{\n+    private TimeWithTimeZoneToTimestampWithTimeZoneCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision) with time zone\")\n+    public static long shortToShort(\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision) with time zone\") long packedTime)\n+    {\n+        // source precision <= 9\n+        // target precision <= 3\n+        long picos = normalizeAndRound(targetPrecision, rescale(unpackTimeNanos(packedTime), 9, 12), unpackOffsetMinutes(packedTime));\n+\n+        return packDateTimeWithZone(calculateEpochMillis(session, picos), getTimeZoneKeyForOffset(unpackOffsetMinutes(packedTime)));\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision) with time zone\")\n+    public static long longToShort(\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision) with time zone\") LongTimeWithTimeZone time)\n+    {\n+        // source precision > 9\n+        // target precision <= 3\n+        long picos = normalizeAndRound(targetPrecision, time.getPicoSeconds(), time.getOffsetMinutes());\n+\n+        return packDateTimeWithZone(calculateEpochMillis(session, picos), getTimeZoneKeyForOffset(time.getOffsetMinutes()));\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision) with time zone\")\n+    public static LongTimestampWithTimeZone shortToLong(\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision) with time zone\") long packedTime)\n+    {\n+        // source precision <= 9\n+        // target precision > 3\n+        long picos = normalizeAndRound(targetPrecision, rescale(unpackTimeNanos(packedTime), 9, 12), unpackOffsetMinutes(packedTime));\n+\n+        return LongTimestampWithTimeZone.fromEpochMillisAndFraction(\n+                calculateEpochMillis(session, picos),\n+                (int) (picos % PICOSECONDS_PER_MILLISECOND),\n+                getTimeZoneKeyForOffset(unpackOffsetMinutes(packedTime)));\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision) with time zone\")\n+    public static LongTimestampWithTimeZone longToLong(\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision) with time zone\") LongTimeWithTimeZone time)\n+    {\n+        // source precision > 9\n+        // target precision > 3\n+        long picos = normalizeAndRound(targetPrecision, time.getPicoSeconds(), time.getOffsetMinutes());\n+\n+        return LongTimestampWithTimeZone.fromEpochMillisAndFraction(\n+                calculateEpochMillis(session, picos),\n+                (int) (picos % PICOSECONDS_PER_MILLISECOND),\n+                getTimeZoneKeyForOffset(time.getOffsetMinutes()));\n+    }\n+\n+    private static long normalizeAndRound(long targetPrecision, long picos, int offsetMinutes)\n+    {\n+        picos = picos - offsetMinutes * PICOSECONDS_PER_MINUTE;\n+        picos = floorMod(picos, PICOSECONDS_PER_DAY);\n+        picos = round(picos, (int) (12 - targetPrecision));\n+        return picos;\n+    }\n+\n+    private static long calculateEpochMillis(ConnectorSession session, long picos)\n+    {\n+        // TODO: consider using something more efficient than LocalDate.ofInstant() to compute epochDay\n+        long epochDay = LocalDate.ofInstant(session.getStart(), session.getTimeZoneKey().getZoneId())\n+                .toEpochDay();\n+\n+        long epochSecond = multiplyExact(epochDay, SECONDS_PER_DAY) + picos / PICOSECONDS_PER_SECOND;\n+        long picoFraction = picos % PICOSECONDS_PER_SECOND;\n+        return multiplyExact(epochSecond, MILLISECONDS_PER_SECOND) + rescale(picoFraction, 12, 3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE0NzY1NA==", "bodyText": "Close. It needs to be multiplyExact(epochDay, MILLISECONDS_PER_DAY) + rescale(picos % PICOSECONDS_PER_DAY, 12, 3)", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r482147654", "createdAt": "2020-09-02T15:09:56Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/TimeWithTimeZoneToTimestampWithTimeZoneCast.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+import io.prestosql.spi.type.LongTimestampWithTimeZone;\n+\n+import java.time.LocalDate;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackOffsetMinutes;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackTimeNanos;\n+import static io.prestosql.spi.type.TimeZoneKey.getTimeZoneKeyForOffset;\n+import static io.prestosql.type.DateTimes.MILLISECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n+import static java.lang.Math.floorMod;\n+import static java.lang.Math.multiplyExact;\n+\n+@ScalarOperator(CAST)\n+public final class TimeWithTimeZoneToTimestampWithTimeZoneCast\n+{\n+    private TimeWithTimeZoneToTimestampWithTimeZoneCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision) with time zone\")\n+    public static long shortToShort(\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision) with time zone\") long packedTime)\n+    {\n+        // source precision <= 9\n+        // target precision <= 3\n+        long picos = normalizeAndRound(targetPrecision, rescale(unpackTimeNanos(packedTime), 9, 12), unpackOffsetMinutes(packedTime));\n+\n+        return packDateTimeWithZone(calculateEpochMillis(session, picos), getTimeZoneKeyForOffset(unpackOffsetMinutes(packedTime)));\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision) with time zone\")\n+    public static long longToShort(\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision) with time zone\") LongTimeWithTimeZone time)\n+    {\n+        // source precision > 9\n+        // target precision <= 3\n+        long picos = normalizeAndRound(targetPrecision, time.getPicoSeconds(), time.getOffsetMinutes());\n+\n+        return packDateTimeWithZone(calculateEpochMillis(session, picos), getTimeZoneKeyForOffset(time.getOffsetMinutes()));\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision) with time zone\")\n+    public static LongTimestampWithTimeZone shortToLong(\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision) with time zone\") long packedTime)\n+    {\n+        // source precision <= 9\n+        // target precision > 3\n+        long picos = normalizeAndRound(targetPrecision, rescale(unpackTimeNanos(packedTime), 9, 12), unpackOffsetMinutes(packedTime));\n+\n+        return LongTimestampWithTimeZone.fromEpochMillisAndFraction(\n+                calculateEpochMillis(session, picos),\n+                (int) (picos % PICOSECONDS_PER_MILLISECOND),\n+                getTimeZoneKeyForOffset(unpackOffsetMinutes(packedTime)));\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision) with time zone\")\n+    public static LongTimestampWithTimeZone longToLong(\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision) with time zone\") LongTimeWithTimeZone time)\n+    {\n+        // source precision > 9\n+        // target precision > 3\n+        long picos = normalizeAndRound(targetPrecision, time.getPicoSeconds(), time.getOffsetMinutes());\n+\n+        return LongTimestampWithTimeZone.fromEpochMillisAndFraction(\n+                calculateEpochMillis(session, picos),\n+                (int) (picos % PICOSECONDS_PER_MILLISECOND),\n+                getTimeZoneKeyForOffset(time.getOffsetMinutes()));\n+    }\n+\n+    private static long normalizeAndRound(long targetPrecision, long picos, int offsetMinutes)\n+    {\n+        picos = picos - offsetMinutes * PICOSECONDS_PER_MINUTE;\n+        picos = floorMod(picos, PICOSECONDS_PER_DAY);\n+        picos = round(picos, (int) (12 - targetPrecision));\n+        return picos;\n+    }\n+\n+    private static long calculateEpochMillis(ConnectorSession session, long picos)\n+    {\n+        // TODO: consider using something more efficient than LocalDate.ofInstant() to compute epochDay\n+        long epochDay = LocalDate.ofInstant(session.getStart(), session.getTimeZoneKey().getZoneId())\n+                .toEpochDay();\n+\n+        long epochSecond = multiplyExact(epochDay, SECONDS_PER_DAY) + picos / PICOSECONDS_PER_SECOND;\n+        long picoFraction = picos % PICOSECONDS_PER_SECOND;\n+        return multiplyExact(epochSecond, MILLISECONDS_PER_SECOND) + rescale(picoFraction, 12, 3);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQzODYzNg=="}, "originalCommit": null, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDE5MDMxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/VarcharToTimeWithTimeZoneCast.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjo0MjoyMFrOHKMADA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxODo0MDo0OFrOHLDdiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ0NDQyOA==", "bodyText": "Does this need to be floor mod?", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480444428", "createdAt": "2020-08-31T22:42:20Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/VarcharToTimeWithTimeZoneCast.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+import io.prestosql.type.DateTimes;\n+\n+import java.util.regex.Matcher;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.operator.scalar.StringFunctions.trim;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.type.DateTimeEncoding.packTimeWithTimeZone;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.MAX_SHORT_PRECISION;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.getOffsetMinutes;\n+import static io.prestosql.type.DateTimes.isValidOffset;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n+\n+@ScalarOperator(CAST)\n+public final class VarcharToTimeWithTimeZoneCast\n+{\n+    private VarcharToTimeWithTimeZoneCast() {}\n+\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p) with time zone\")\n+    public static long castToShort(@LiteralParameter(\"p\") long precision, ConnectorSession session, @SqlType(\"varchar(x)\") Slice value)\n+    {\n+        checkArgument((int) precision <= MAX_SHORT_PRECISION, \"precision must be less than max short timestamp precision\");\n+\n+        Matcher matcher = DateTimes.TIME_PATTERN.matcher(trim(value).toStringUtf8());\n+        if (!matcher.matches()) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to timestamp: \" + value.toStringUtf8());\n+        }\n+\n+        try {\n+            long nanos = parseTime(matcher) * NANOSECONDS_PER_SECOND + parseFraction((int) precision, matcher, 9);\n+            nanos %= NANOSECONDS_PER_DAY;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1MzA5Nw==", "bodyText": "No, see comment above", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r481353097", "createdAt": "2020-09-01T18:40:48Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/VarcharToTimeWithTimeZoneCast.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+import io.prestosql.type.DateTimes;\n+\n+import java.util.regex.Matcher;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.operator.scalar.StringFunctions.trim;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.type.DateTimeEncoding.packTimeWithTimeZone;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.MAX_SHORT_PRECISION;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.getOffsetMinutes;\n+import static io.prestosql.type.DateTimes.isValidOffset;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n+\n+@ScalarOperator(CAST)\n+public final class VarcharToTimeWithTimeZoneCast\n+{\n+    private VarcharToTimeWithTimeZoneCast() {}\n+\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p) with time zone\")\n+    public static long castToShort(@LiteralParameter(\"p\") long precision, ConnectorSession session, @SqlType(\"varchar(x)\") Slice value)\n+    {\n+        checkArgument((int) precision <= MAX_SHORT_PRECISION, \"precision must be less than max short timestamp precision\");\n+\n+        Matcher matcher = DateTimes.TIME_PATTERN.matcher(trim(value).toStringUtf8());\n+        if (!matcher.matches()) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to timestamp: \" + value.toStringUtf8());\n+        }\n+\n+        try {\n+            long nanos = parseTime(matcher) * NANOSECONDS_PER_SECOND + parseFraction((int) precision, matcher, 9);\n+            nanos %= NANOSECONDS_PER_DAY;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ0NDQyOA=="}, "originalCommit": null, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDE5MTcxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/VarcharToTimeWithTimeZoneCast.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjo0Mjo0MFrOHKMAyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjo0Mjo0MFrOHKMAyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ0NDYxNg==", "bodyText": "same", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480444616", "createdAt": "2020-08-31T22:42:40Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/VarcharToTimeWithTimeZoneCast.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+import io.prestosql.type.DateTimes;\n+\n+import java.util.regex.Matcher;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.operator.scalar.StringFunctions.trim;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.type.DateTimeEncoding.packTimeWithTimeZone;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.MAX_SHORT_PRECISION;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.getOffsetMinutes;\n+import static io.prestosql.type.DateTimes.isValidOffset;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n+\n+@ScalarOperator(CAST)\n+public final class VarcharToTimeWithTimeZoneCast\n+{\n+    private VarcharToTimeWithTimeZoneCast() {}\n+\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p) with time zone\")\n+    public static long castToShort(@LiteralParameter(\"p\") long precision, ConnectorSession session, @SqlType(\"varchar(x)\") Slice value)\n+    {\n+        checkArgument((int) precision <= MAX_SHORT_PRECISION, \"precision must be less than max short timestamp precision\");\n+\n+        Matcher matcher = DateTimes.TIME_PATTERN.matcher(trim(value).toStringUtf8());\n+        if (!matcher.matches()) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to timestamp: \" + value.toStringUtf8());\n+        }\n+\n+        try {\n+            long nanos = parseTime(matcher) * NANOSECONDS_PER_SECOND + parseFraction((int) precision, matcher, 9);\n+            nanos %= NANOSECONDS_PER_DAY;\n+\n+            int offsetMinutes = parseOffset(session, matcher);\n+\n+            return packTimeWithTimeZone(nanos, offsetMinutes);\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to timestamp: \" + value.toStringUtf8(), e);\n+        }\n+    }\n+\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p) with time zone\")\n+    public static LongTimeWithTimeZone castToLong(@LiteralParameter(\"p\") long precision, ConnectorSession session, @SqlType(\"varchar(x)\") Slice value)\n+    {\n+        checkArgument((int) precision > MAX_SHORT_PRECISION && (int) precision <= MAX_PRECISION, \"precision out of range\");\n+\n+        Matcher matcher = DateTimes.TIME_PATTERN.matcher(trim(value).toStringUtf8());\n+        if (!matcher.matches()) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to timestamp: \" + value.toStringUtf8());\n+        }\n+\n+        try {\n+            long picos = parseTime(matcher) * PICOSECONDS_PER_SECOND + parseFraction((int) precision, matcher, 12);\n+            picos %= PICOSECONDS_PER_DAY;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDIxMTM4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/VarcharToTimeWithTimeZoneCast.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjo0NzowNVrOHKMLuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjo0NzowNVrOHKMLuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ0NzQxNg==", "bodyText": "I'd place this method at the bottom", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480447416", "createdAt": "2020-08-31T22:47:05Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/VarcharToTimeWithTimeZoneCast.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+import io.prestosql.type.DateTimes;\n+\n+import java.util.regex.Matcher;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.operator.scalar.StringFunctions.trim;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.type.DateTimeEncoding.packTimeWithTimeZone;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.MAX_SHORT_PRECISION;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.getOffsetMinutes;\n+import static io.prestosql.type.DateTimes.isValidOffset;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n+\n+@ScalarOperator(CAST)\n+public final class VarcharToTimeWithTimeZoneCast\n+{\n+    private VarcharToTimeWithTimeZoneCast() {}\n+\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p) with time zone\")\n+    public static long castToShort(@LiteralParameter(\"p\") long precision, ConnectorSession session, @SqlType(\"varchar(x)\") Slice value)\n+    {\n+        checkArgument((int) precision <= MAX_SHORT_PRECISION, \"precision must be less than max short timestamp precision\");\n+\n+        Matcher matcher = DateTimes.TIME_PATTERN.matcher(trim(value).toStringUtf8());\n+        if (!matcher.matches()) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to timestamp: \" + value.toStringUtf8());\n+        }\n+\n+        try {\n+            long nanos = parseTime(matcher) * NANOSECONDS_PER_SECOND + parseFraction((int) precision, matcher, 9);\n+            nanos %= NANOSECONDS_PER_DAY;\n+\n+            int offsetMinutes = parseOffset(session, matcher);\n+\n+            return packTimeWithTimeZone(nanos, offsetMinutes);\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to timestamp: \" + value.toStringUtf8(), e);\n+        }\n+    }\n+\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p) with time zone\")\n+    public static LongTimeWithTimeZone castToLong(@LiteralParameter(\"p\") long precision, ConnectorSession session, @SqlType(\"varchar(x)\") Slice value)\n+    {\n+        checkArgument((int) precision > MAX_SHORT_PRECISION && (int) precision <= MAX_PRECISION, \"precision out of range\");\n+\n+        Matcher matcher = DateTimes.TIME_PATTERN.matcher(trim(value).toStringUtf8());\n+        if (!matcher.matches()) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to timestamp: \" + value.toStringUtf8());\n+        }\n+\n+        try {\n+            long picos = parseTime(matcher) * PICOSECONDS_PER_SECOND + parseFraction((int) precision, matcher, 12);\n+            picos %= PICOSECONDS_PER_DAY;\n+\n+            int offsetMinutes = parseOffset(session, matcher);\n+\n+            return new LongTimeWithTimeZone(picos, offsetMinutes);\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to timestamp: \" + value.toStringUtf8(), e);\n+        }\n+    }\n+\n+    private static long parseFraction(int precision, Matcher matcher, int targetMagnitude)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDIzMDUzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/VarcharToTimeWithTimeZoneCast.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjo1MToxM1rOHKMWBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxODo0NjowMVrOHLDoKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ1MDA1Mg==", "bodyText": "can you just return this value?", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480450052", "createdAt": "2020-08-31T22:51:13Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/VarcharToTimeWithTimeZoneCast.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+import io.prestosql.type.DateTimes;\n+\n+import java.util.regex.Matcher;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.operator.scalar.StringFunctions.trim;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.type.DateTimeEncoding.packTimeWithTimeZone;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.MAX_SHORT_PRECISION;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.getOffsetMinutes;\n+import static io.prestosql.type.DateTimes.isValidOffset;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n+\n+@ScalarOperator(CAST)\n+public final class VarcharToTimeWithTimeZoneCast\n+{\n+    private VarcharToTimeWithTimeZoneCast() {}\n+\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p) with time zone\")\n+    public static long castToShort(@LiteralParameter(\"p\") long precision, ConnectorSession session, @SqlType(\"varchar(x)\") Slice value)\n+    {\n+        checkArgument((int) precision <= MAX_SHORT_PRECISION, \"precision must be less than max short timestamp precision\");\n+\n+        Matcher matcher = DateTimes.TIME_PATTERN.matcher(trim(value).toStringUtf8());\n+        if (!matcher.matches()) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to timestamp: \" + value.toStringUtf8());\n+        }\n+\n+        try {\n+            long nanos = parseTime(matcher) * NANOSECONDS_PER_SECOND + parseFraction((int) precision, matcher, 9);\n+            nanos %= NANOSECONDS_PER_DAY;\n+\n+            int offsetMinutes = parseOffset(session, matcher);\n+\n+            return packTimeWithTimeZone(nanos, offsetMinutes);\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to timestamp: \" + value.toStringUtf8(), e);\n+        }\n+    }\n+\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p) with time zone\")\n+    public static LongTimeWithTimeZone castToLong(@LiteralParameter(\"p\") long precision, ConnectorSession session, @SqlType(\"varchar(x)\") Slice value)\n+    {\n+        checkArgument((int) precision > MAX_SHORT_PRECISION && (int) precision <= MAX_PRECISION, \"precision out of range\");\n+\n+        Matcher matcher = DateTimes.TIME_PATTERN.matcher(trim(value).toStringUtf8());\n+        if (!matcher.matches()) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to timestamp: \" + value.toStringUtf8());\n+        }\n+\n+        try {\n+            long picos = parseTime(matcher) * PICOSECONDS_PER_SECOND + parseFraction((int) precision, matcher, 12);\n+            picos %= PICOSECONDS_PER_DAY;\n+\n+            int offsetMinutes = parseOffset(session, matcher);\n+\n+            return new LongTimeWithTimeZone(picos, offsetMinutes);\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to timestamp: \" + value.toStringUtf8(), e);\n+        }\n+    }\n+\n+    private static long parseFraction(int precision, Matcher matcher, int targetMagnitude)\n+    {\n+        String fraction = matcher.group(\"fraction\");\n+        int actualPrecision = 0;\n+        long fractionValue = 0;\n+        if (fraction != null) {\n+            actualPrecision = fraction.length();\n+            fractionValue = Long.parseLong(fraction);\n+        }\n+\n+        if (actualPrecision > MAX_PRECISION) {\n+            throw new IllegalArgumentException(\"Invalid time\");\n+        }\n+\n+        if (actualPrecision > precision) {\n+            fractionValue = round(fractionValue, actualPrecision - precision);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NTgxOQ==", "bodyText": "No, this just rounds but maintains the current scale. The call below rescales to a different magnitude (targetMagniutde), which can be either picos or nanos depending on the caller.", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r481355819", "createdAt": "2020-09-01T18:46:01Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timetz/VarcharToTimeWithTimeZoneCast.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimeWithTimeZone;\n+import io.prestosql.type.DateTimes;\n+\n+import java.util.regex.Matcher;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.operator.scalar.StringFunctions.trim;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.type.DateTimeEncoding.packTimeWithTimeZone;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.MAX_SHORT_PRECISION;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.NANOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.getOffsetMinutes;\n+import static io.prestosql.type.DateTimes.isValidOffset;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n+\n+@ScalarOperator(CAST)\n+public final class VarcharToTimeWithTimeZoneCast\n+{\n+    private VarcharToTimeWithTimeZoneCast() {}\n+\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p) with time zone\")\n+    public static long castToShort(@LiteralParameter(\"p\") long precision, ConnectorSession session, @SqlType(\"varchar(x)\") Slice value)\n+    {\n+        checkArgument((int) precision <= MAX_SHORT_PRECISION, \"precision must be less than max short timestamp precision\");\n+\n+        Matcher matcher = DateTimes.TIME_PATTERN.matcher(trim(value).toStringUtf8());\n+        if (!matcher.matches()) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to timestamp: \" + value.toStringUtf8());\n+        }\n+\n+        try {\n+            long nanos = parseTime(matcher) * NANOSECONDS_PER_SECOND + parseFraction((int) precision, matcher, 9);\n+            nanos %= NANOSECONDS_PER_DAY;\n+\n+            int offsetMinutes = parseOffset(session, matcher);\n+\n+            return packTimeWithTimeZone(nanos, offsetMinutes);\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to timestamp: \" + value.toStringUtf8(), e);\n+        }\n+    }\n+\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p) with time zone\")\n+    public static LongTimeWithTimeZone castToLong(@LiteralParameter(\"p\") long precision, ConnectorSession session, @SqlType(\"varchar(x)\") Slice value)\n+    {\n+        checkArgument((int) precision > MAX_SHORT_PRECISION && (int) precision <= MAX_PRECISION, \"precision out of range\");\n+\n+        Matcher matcher = DateTimes.TIME_PATTERN.matcher(trim(value).toStringUtf8());\n+        if (!matcher.matches()) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to timestamp: \" + value.toStringUtf8());\n+        }\n+\n+        try {\n+            long picos = parseTime(matcher) * PICOSECONDS_PER_SECOND + parseFraction((int) precision, matcher, 12);\n+            picos %= PICOSECONDS_PER_DAY;\n+\n+            int offsetMinutes = parseOffset(session, matcher);\n+\n+            return new LongTimeWithTimeZone(picos, offsetMinutes);\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to timestamp: \" + value.toStringUtf8(), e);\n+        }\n+    }\n+\n+    private static long parseFraction(int precision, Matcher matcher, int targetMagnitude)\n+    {\n+        String fraction = matcher.group(\"fraction\");\n+        int actualPrecision = 0;\n+        long fractionValue = 0;\n+        if (fraction != null) {\n+            actualPrecision = fraction.length();\n+            fractionValue = Long.parseLong(fraction);\n+        }\n+\n+        if (actualPrecision > MAX_PRECISION) {\n+            throw new IllegalArgumentException(\"Invalid time\");\n+        }\n+\n+        if (actualPrecision > precision) {\n+            fractionValue = round(fractionValue, actualPrecision - precision);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ1MDA1Mg=="}, "originalCommit": null, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDI0MjQ0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjo1Mzo0M1rOHKMcQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxODo0OToxM1rOHLDu7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ1MTY0OA==", "bodyText": "do you need to assert there is no precision here?", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480451648", "createdAt": "2020-08-31T22:53:43Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -378,20 +379,18 @@ protected Type visitRow(Row node, StackableAstVisitorContext<Context> context)\n         @Override\n         protected Type visitCurrentTime(CurrentTime node, StackableAstVisitorContext<Context> context)\n         {\n-            if (node.getPrecision() != null &&\n-                    node.getFunction() != LOCALTIMESTAMP &&\n-                    node.getFunction() != CurrentTime.Function.TIMESTAMP &&\n-                    node.getFunction() != LOCALTIME) {\n-                throw semanticException(NOT_SUPPORTED, node, \"non-default precision not yet supported\");\n-            }\n-\n             Type type;\n             switch (node.getFunction()) {\n                 case DATE:\n                     type = DATE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NzQwNg==", "bodyText": "It can't happen in practice -- the parser will never generate that. Really, what we should do is separate the various syntactic forms into different AST nodes instead of a union structure, like we have today.", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r481357406", "createdAt": "2020-09-01T18:48:54Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -378,20 +379,18 @@ protected Type visitRow(Row node, StackableAstVisitorContext<Context> context)\n         @Override\n         protected Type visitCurrentTime(CurrentTime node, StackableAstVisitorContext<Context> context)\n         {\n-            if (node.getPrecision() != null &&\n-                    node.getFunction() != LOCALTIMESTAMP &&\n-                    node.getFunction() != CurrentTime.Function.TIMESTAMP &&\n-                    node.getFunction() != LOCALTIME) {\n-                throw semanticException(NOT_SUPPORTED, node, \"non-default precision not yet supported\");\n-            }\n-\n             Type type;\n             switch (node.getFunction()) {\n                 case DATE:\n                     type = DATE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ1MTY0OA=="}, "originalCommit": null, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NzU1MA==", "bodyText": "I'll add a check for now, anyway.", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r481357550", "createdAt": "2020-09-01T18:49:13Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -378,20 +379,18 @@ protected Type visitRow(Row node, StackableAstVisitorContext<Context> context)\n         @Override\n         protected Type visitCurrentTime(CurrentTime node, StackableAstVisitorContext<Context> context)\n         {\n-            if (node.getPrecision() != null &&\n-                    node.getFunction() != LOCALTIMESTAMP &&\n-                    node.getFunction() != CurrentTime.Function.TIMESTAMP &&\n-                    node.getFunction() != LOCALTIME) {\n-                throw semanticException(NOT_SUPPORTED, node, \"non-default precision not yet supported\");\n-            }\n-\n             Type type;\n             switch (node.getFunction()) {\n                 case DATE:\n                     type = DATE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ1MTY0OA=="}, "originalCommit": null, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDMwODI0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/CanonicalizeExpressionRewriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzowODoyMlrOHKNBCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzowODoyMlrOHKNBCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ2MTA2NQ==", "bodyText": "Do we need to have the precision check here?", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480461065", "createdAt": "2020-08-31T23:08:22Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/CanonicalizeExpressionRewriter.java", "diffHunk": "@@ -137,21 +135,15 @@ public Expression rewriteIfExpression(IfExpression node, Void context, Expressio\n         @Override\n         public Expression rewriteCurrentTime(CurrentTime node, Void context, ExpressionTreeRewriter<Void> treeRewriter)\n         {\n-            if (node.getPrecision() != null &&\n-                    node.getFunction() != LOCALTIMESTAMP &&\n-                    node.getFunction() != CurrentTime.Function.TIMESTAMP &&\n-                    node.getFunction() != LOCALTIME) {\n-                throw new UnsupportedOperationException(\"not yet implemented: non-default precision\");\n-            }\n-\n             switch (node.getFunction()) {\n                 case DATE:", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDMxNzk5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/type/DateTimes.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzoxMDoyNFrOHKNGpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzoxMDoyNFrOHKNGpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ2MjUwMg==", "bodyText": "Maybe put this like first and use it in NANOSECONDS_PER_DAY", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480462502", "createdAt": "2020-08-31T23:10:24Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/type/DateTimes.java", "diffHunk": "@@ -73,11 +76,16 @@\n     };\n \n     public static final int MILLISECONDS_PER_SECOND = 1000;\n+    public static final long MILLISECONDS_PER_MINUTE = 60 * MILLISECONDS_PER_SECOND;\n     public static final long MILLISECONDS_PER_DAY = 24 * 60 * 60 * MILLISECONDS_PER_SECOND;\n     public static final int MICROSECONDS_PER_SECOND = 1_000_000;\n     public static final int MICROSECONDS_PER_MILLISECOND = 1000;\n     public static final long MICROSECONDS_PER_DAY = MILLISECONDS_PER_DAY * MICROSECONDS_PER_MILLISECOND;\n     public static final long PICOSECONDS_PER_SECOND = 1_000_000_000_000L;\n+    public static final long NANOSECONDS_PER_DAY = 1_000_000_000L * 60 * 60 * 24;\n+    public static final long NANOSECONDS_PER_SECOND = 1_000_000_000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDM2MjcwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/operator/scalar/timetz/TestOperators.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzoyMDoyNlrOHKNf5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzoyMDoyNlrOHKNf5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ2ODk2Ng==", "bodyText": "You should have a test that returns false", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480468966", "createdAt": "2020-08-31T23:20:26Z", "author": {"login": "dain"}, "path": "presto-main/src/test/java/io/prestosql/operator/scalar/timetz/TestOperators.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timetz;\n+\n+import io.prestosql.sql.query.QueryAssertions;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestOperators\n+{\n+    protected QueryAssertions assertions;\n+\n+    @BeforeClass\n+    public void init()\n+    {\n+        assertions = new QueryAssertions();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void teardown()\n+    {\n+        assertions.close();\n+        assertions = null;\n+    }\n+\n+    @Test\n+    public void testEqual()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDQwMTQxOnYy", "diffSide": "RIGHT", "path": "presto-spi/src/main/java/io/prestosql/spi/type/LongTimeWithTimeZone.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzozOTozN1rOHKN2mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxODo1Mzo1MFrOHLD6Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3NDc3OQ==", "bodyText": "For LongTimestampWithTimeZone we did not include the TZ. I suggest we do the same here?", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480474779", "createdAt": "2020-08-31T23:39:37Z", "author": {"login": "dain"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/LongTimeWithTimeZone.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.type;\n+\n+import java.util.Objects;\n+\n+import static io.prestosql.spi.type.TimeWithTimezoneTypes.normalize;\n+\n+public final class LongTimeWithTimeZone\n+        implements Comparable<LongTimeWithTimeZone>\n+{\n+    private final long picoSeconds;\n+    private final int offsetMinutes;\n+\n+    public LongTimeWithTimeZone(long picoSeconds, int offsetMinutes)\n+    {\n+        this.picoSeconds = picoSeconds;\n+        this.offsetMinutes = offsetMinutes;\n+    }\n+\n+    public long getPicoSeconds()\n+    {\n+        return picoSeconds;\n+    }\n+\n+    public int getOffsetMinutes()\n+    {\n+        return offsetMinutes;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        LongTimeWithTimeZone that = (LongTimeWithTimeZone) o;\n+        return picoSeconds == that.picoSeconds &&\n+                offsetMinutes == that.offsetMinutes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MDQ3NQ==", "bodyText": "Timestamp w/ TZ is different. The instant is captured by the epoch time. For time w/ tz we need both, since the time part just represents the time since midnight.", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r481360475", "createdAt": "2020-09-01T18:53:50Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/LongTimeWithTimeZone.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.type;\n+\n+import java.util.Objects;\n+\n+import static io.prestosql.spi.type.TimeWithTimezoneTypes.normalize;\n+\n+public final class LongTimeWithTimeZone\n+        implements Comparable<LongTimeWithTimeZone>\n+{\n+    private final long picoSeconds;\n+    private final int offsetMinutes;\n+\n+    public LongTimeWithTimeZone(long picoSeconds, int offsetMinutes)\n+    {\n+        this.picoSeconds = picoSeconds;\n+        this.offsetMinutes = offsetMinutes;\n+    }\n+\n+    public long getPicoSeconds()\n+    {\n+        return picoSeconds;\n+    }\n+\n+    public int getOffsetMinutes()\n+    {\n+        return offsetMinutes;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        LongTimeWithTimeZone that = (LongTimeWithTimeZone) o;\n+        return picoSeconds == that.picoSeconds &&\n+                offsetMinutes == that.offsetMinutes;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3NDc3OQ=="}, "originalCommit": null, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDQwMzQ0OnYy", "diffSide": "RIGHT", "path": "presto-spi/src/main/java/io/prestosql/spi/type/LongTimeWithTimeZone.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzo0MDoyOVrOHKN3qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzo0MDoyOVrOHKN3qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3NTA1MQ==", "bodyText": "I think you can just use Long.compare(normalize(picoSeconds, offsetMinutes), normalize(other.picoSeconds, other.offsetMinutes))", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480475051", "createdAt": "2020-08-31T23:40:29Z", "author": {"login": "dain"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/LongTimeWithTimeZone.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.type;\n+\n+import java.util.Objects;\n+\n+import static io.prestosql.spi.type.TimeWithTimezoneTypes.normalize;\n+\n+public final class LongTimeWithTimeZone\n+        implements Comparable<LongTimeWithTimeZone>\n+{\n+    private final long picoSeconds;\n+    private final int offsetMinutes;\n+\n+    public LongTimeWithTimeZone(long picoSeconds, int offsetMinutes)\n+    {\n+        this.picoSeconds = picoSeconds;\n+        this.offsetMinutes = offsetMinutes;\n+    }\n+\n+    public long getPicoSeconds()\n+    {\n+        return picoSeconds;\n+    }\n+\n+    public int getOffsetMinutes()\n+    {\n+        return offsetMinutes;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        LongTimeWithTimeZone that = (LongTimeWithTimeZone) o;\n+        return picoSeconds == that.picoSeconds &&\n+                offsetMinutes == that.offsetMinutes;\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return Objects.hash(picoSeconds, offsetMinutes);\n+    }\n+\n+    @Override\n+    public int compareTo(LongTimeWithTimeZone other)\n+    {\n+        long delta = normalize(picoSeconds, offsetMinutes) - normalize(other.picoSeconds, other.offsetMinutes);\n+        if (delta < 0) {\n+            return -1;\n+        }\n+        if (delta > 0) {\n+            return 1;\n+        }\n+        return 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDQwOTQwOnYy", "diffSide": "RIGHT", "path": "presto-spi/src/main/java/io/prestosql/spi/type/LongTimeWithTimeZoneType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzo0Mzo0MVrOHKN7RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzo0Mzo0MVrOHKN7RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3NTk3Mg==", "bodyText": "static import normalize", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480475972", "createdAt": "2020-08-31T23:43:41Z", "author": {"login": "dain"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/LongTimeWithTimeZoneType.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.type;\n+\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.Int96ArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+\n+import static io.airlift.slice.SizeOf.SIZE_OF_LONG;\n+import static io.prestosql.spi.type.TimeWithTimezoneTypes.hashLongTimeWithTimeZone;\n+import static java.lang.String.format;\n+\n+class LongTimeWithTimeZoneType\n+        extends TimeWithTimeZoneType\n+{\n+    public LongTimeWithTimeZoneType(int precision)\n+    {\n+        super(precision, LongTimeWithTimeZone.class);\n+\n+        if (precision < MAX_SHORT_PRECISION + 1 || precision > MAX_PRECISION) {\n+            throw new IllegalArgumentException(format(\"Precision must be in the range [%s, %s]\", MAX_SHORT_PRECISION + 1, MAX_PRECISION));\n+        }\n+    }\n+\n+    @Override\n+    public int getFixedSize()\n+    {\n+        return Long.BYTES + Integer.BYTES;\n+    }\n+\n+    @Override\n+    public BlockBuilder createBlockBuilder(BlockBuilderStatus blockBuilderStatus, int expectedEntries, int expectedBytesPerEntry)\n+    {\n+        int maxBlockSizeInBytes;\n+        if (blockBuilderStatus == null) {\n+            maxBlockSizeInBytes = PageBuilderStatus.DEFAULT_MAX_PAGE_SIZE_IN_BYTES;\n+        }\n+        else {\n+            maxBlockSizeInBytes = blockBuilderStatus.getMaxPageSizeInBytes();\n+        }\n+        return new Int96ArrayBlockBuilder(\n+                blockBuilderStatus,\n+                Math.min(expectedEntries, maxBlockSizeInBytes / getFixedSize()));\n+    }\n+\n+    @Override\n+    public BlockBuilder createBlockBuilder(BlockBuilderStatus blockBuilderStatus, int expectedEntries)\n+    {\n+        return createBlockBuilder(blockBuilderStatus, expectedEntries, getFixedSize());\n+    }\n+\n+    @Override\n+    public BlockBuilder createFixedSizeBlockBuilder(int positionCount)\n+    {\n+        return new Int96ArrayBlockBuilder(null, positionCount);\n+    }\n+\n+    @Override\n+    public boolean equalTo(Block leftBlock, int leftPosition, Block rightBlock, int rightPosition)\n+    {\n+        long leftPicos = getPicos(leftBlock, leftPosition);\n+        int leftOffsetMinutes = getOffsetMinutes(leftBlock, leftPosition);\n+\n+        long rightPicos = getPicos(rightBlock, rightPosition);\n+        int rightOffsetMinutes = getOffsetMinutes(rightBlock, leftPosition);\n+\n+        return TimeWithTimezoneTypes.normalize(leftPicos, leftOffsetMinutes) == TimeWithTimezoneTypes.normalize(rightPicos, rightOffsetMinutes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDQxMDEyOnYy", "diffSide": "RIGHT", "path": "presto-spi/src/main/java/io/prestosql/spi/type/LongTimeWithTimeZoneType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzo0NDowN1rOHKN7sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzo0NDowN1rOHKN7sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3NjA4Mw==", "bodyText": "I think you can use long compare as I suggested in the other file", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480476083", "createdAt": "2020-08-31T23:44:07Z", "author": {"login": "dain"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/LongTimeWithTimeZoneType.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.type;\n+\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.Int96ArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+\n+import static io.airlift.slice.SizeOf.SIZE_OF_LONG;\n+import static io.prestosql.spi.type.TimeWithTimezoneTypes.hashLongTimeWithTimeZone;\n+import static java.lang.String.format;\n+\n+class LongTimeWithTimeZoneType\n+        extends TimeWithTimeZoneType\n+{\n+    public LongTimeWithTimeZoneType(int precision)\n+    {\n+        super(precision, LongTimeWithTimeZone.class);\n+\n+        if (precision < MAX_SHORT_PRECISION + 1 || precision > MAX_PRECISION) {\n+            throw new IllegalArgumentException(format(\"Precision must be in the range [%s, %s]\", MAX_SHORT_PRECISION + 1, MAX_PRECISION));\n+        }\n+    }\n+\n+    @Override\n+    public int getFixedSize()\n+    {\n+        return Long.BYTES + Integer.BYTES;\n+    }\n+\n+    @Override\n+    public BlockBuilder createBlockBuilder(BlockBuilderStatus blockBuilderStatus, int expectedEntries, int expectedBytesPerEntry)\n+    {\n+        int maxBlockSizeInBytes;\n+        if (blockBuilderStatus == null) {\n+            maxBlockSizeInBytes = PageBuilderStatus.DEFAULT_MAX_PAGE_SIZE_IN_BYTES;\n+        }\n+        else {\n+            maxBlockSizeInBytes = blockBuilderStatus.getMaxPageSizeInBytes();\n+        }\n+        return new Int96ArrayBlockBuilder(\n+                blockBuilderStatus,\n+                Math.min(expectedEntries, maxBlockSizeInBytes / getFixedSize()));\n+    }\n+\n+    @Override\n+    public BlockBuilder createBlockBuilder(BlockBuilderStatus blockBuilderStatus, int expectedEntries)\n+    {\n+        return createBlockBuilder(blockBuilderStatus, expectedEntries, getFixedSize());\n+    }\n+\n+    @Override\n+    public BlockBuilder createFixedSizeBlockBuilder(int positionCount)\n+    {\n+        return new Int96ArrayBlockBuilder(null, positionCount);\n+    }\n+\n+    @Override\n+    public boolean equalTo(Block leftBlock, int leftPosition, Block rightBlock, int rightPosition)\n+    {\n+        long leftPicos = getPicos(leftBlock, leftPosition);\n+        int leftOffsetMinutes = getOffsetMinutes(leftBlock, leftPosition);\n+\n+        long rightPicos = getPicos(rightBlock, rightPosition);\n+        int rightOffsetMinutes = getOffsetMinutes(rightBlock, leftPosition);\n+\n+        return TimeWithTimezoneTypes.normalize(leftPicos, leftOffsetMinutes) == TimeWithTimezoneTypes.normalize(rightPicos, rightOffsetMinutes);\n+    }\n+\n+    @Override\n+    public int compareTo(Block leftBlock, int leftPosition, Block rightBlock, int rightPosition)\n+    {\n+        long leftPicos = getPicos(leftBlock, leftPosition);\n+        int leftOffsetMinutes = getOffsetMinutes(leftBlock, leftPosition);\n+\n+        long rightPicos = getPicos(rightBlock, rightPosition);\n+        int rightOffsetMinutes = getOffsetMinutes(rightBlock, leftPosition);\n+\n+        long delta = TimeWithTimezoneTypes.normalize(leftPicos, leftOffsetMinutes) - TimeWithTimezoneTypes.normalize(rightPicos, rightOffsetMinutes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDQxNzM1OnYy", "diffSide": "RIGHT", "path": "presto-spi/src/main/java/io/prestosql/spi/type/ShortTimeWithTimeZoneType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzo0Nzo0NVrOHKN__w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzo0Nzo0NVrOHKN__w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3NzE4Mw==", "bodyText": "static import", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480477183", "createdAt": "2020-08-31T23:47:45Z", "author": {"login": "dain"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/ShortTimeWithTimeZoneType.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.type;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.LongArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackOffsetMinutes;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackTimeNanos;\n+import static io.prestosql.spi.type.TimeWithTimezoneTypes.hashShortTimeWithTimeZone;\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_NANOSECOND;\n+import static java.lang.String.format;\n+\n+/**\n+ * Encodes time with time zone up to p = 9.\n+ */\n+class ShortTimeWithTimeZoneType\n+        extends TimeWithTimeZoneType\n+{\n+    public ShortTimeWithTimeZoneType(int precision)\n+    {\n+        super(precision, long.class);\n+\n+        if (precision < 0 || precision > MAX_SHORT_PRECISION) {\n+            throw new IllegalArgumentException(format(\"Precision must be in the range [0, %s]\", MAX_SHORT_PRECISION));\n+        }\n+    }\n+\n+    @Override\n+    public final int getFixedSize()\n+    {\n+        return Long.BYTES;\n+    }\n+\n+    @Override\n+    public final long getLong(Block block, int position)\n+    {\n+        return block.getLong(position, 0);\n+    }\n+\n+    @Override\n+    public final Slice getSlice(Block block, int position)\n+    {\n+        return block.getSlice(position, 0, getFixedSize());\n+    }\n+\n+    @Override\n+    public final void writeLong(BlockBuilder blockBuilder, long value)\n+    {\n+        blockBuilder.writeLong(value).closeEntry();\n+    }\n+\n+    @Override\n+    public final void appendTo(Block block, int position, BlockBuilder blockBuilder)\n+    {\n+        if (block.isNull(position)) {\n+            blockBuilder.appendNull();\n+        }\n+        else {\n+            blockBuilder.writeLong(block.getLong(position, 0)).closeEntry();\n+        }\n+    }\n+\n+    @Override\n+    public boolean equalTo(Block leftBlock, int leftPosition, Block rightBlock, int rightPosition)\n+    {\n+        long left = leftBlock.getLong(leftPosition, 0);\n+        long leftPicos = unpackTimeNanos(left) * PICOSECONDS_PER_NANOSECOND;\n+        int leftOffsetMinutes = unpackOffsetMinutes(left);\n+\n+        long right = rightBlock.getLong(rightPosition, 0);\n+        long rightPicos = unpackTimeNanos(right) * PICOSECONDS_PER_NANOSECOND;\n+        int rightOffsetMinutes = unpackOffsetMinutes(right);\n+\n+        return TimeWithTimezoneTypes.normalize(leftPicos, leftOffsetMinutes) == TimeWithTimezoneTypes.normalize(rightPicos, rightOffsetMinutes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDQxNzg2OnYy", "diffSide": "RIGHT", "path": "presto-spi/src/main/java/io/prestosql/spi/type/ShortTimeWithTimeZoneType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzo0ODowMVrOHKOAUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzo0ODowMVrOHKOAUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3NzI2Ng==", "bodyText": "Comparison", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480477266", "createdAt": "2020-08-31T23:48:01Z", "author": {"login": "dain"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/ShortTimeWithTimeZoneType.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.type;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.LongArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackOffsetMinutes;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackTimeNanos;\n+import static io.prestosql.spi.type.TimeWithTimezoneTypes.hashShortTimeWithTimeZone;\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_NANOSECOND;\n+import static java.lang.String.format;\n+\n+/**\n+ * Encodes time with time zone up to p = 9.\n+ */\n+class ShortTimeWithTimeZoneType\n+        extends TimeWithTimeZoneType\n+{\n+    public ShortTimeWithTimeZoneType(int precision)\n+    {\n+        super(precision, long.class);\n+\n+        if (precision < 0 || precision > MAX_SHORT_PRECISION) {\n+            throw new IllegalArgumentException(format(\"Precision must be in the range [0, %s]\", MAX_SHORT_PRECISION));\n+        }\n+    }\n+\n+    @Override\n+    public final int getFixedSize()\n+    {\n+        return Long.BYTES;\n+    }\n+\n+    @Override\n+    public final long getLong(Block block, int position)\n+    {\n+        return block.getLong(position, 0);\n+    }\n+\n+    @Override\n+    public final Slice getSlice(Block block, int position)\n+    {\n+        return block.getSlice(position, 0, getFixedSize());\n+    }\n+\n+    @Override\n+    public final void writeLong(BlockBuilder blockBuilder, long value)\n+    {\n+        blockBuilder.writeLong(value).closeEntry();\n+    }\n+\n+    @Override\n+    public final void appendTo(Block block, int position, BlockBuilder blockBuilder)\n+    {\n+        if (block.isNull(position)) {\n+            blockBuilder.appendNull();\n+        }\n+        else {\n+            blockBuilder.writeLong(block.getLong(position, 0)).closeEntry();\n+        }\n+    }\n+\n+    @Override\n+    public boolean equalTo(Block leftBlock, int leftPosition, Block rightBlock, int rightPosition)\n+    {\n+        long left = leftBlock.getLong(leftPosition, 0);\n+        long leftPicos = unpackTimeNanos(left) * PICOSECONDS_PER_NANOSECOND;\n+        int leftOffsetMinutes = unpackOffsetMinutes(left);\n+\n+        long right = rightBlock.getLong(rightPosition, 0);\n+        long rightPicos = unpackTimeNanos(right) * PICOSECONDS_PER_NANOSECOND;\n+        int rightOffsetMinutes = unpackOffsetMinutes(right);\n+\n+        return TimeWithTimezoneTypes.normalize(leftPicos, leftOffsetMinutes) == TimeWithTimezoneTypes.normalize(rightPicos, rightOffsetMinutes);\n+    }\n+\n+    @Override\n+    public long hash(Block block, int position)\n+    {\n+        long packedTime = block.getLong(position, 0);\n+        return hashShortTimeWithTimeZone(packedTime);\n+    }\n+\n+    @Override\n+    public int compareTo(Block leftBlock, int leftPosition, Block rightBlock, int rightPosition)\n+    {\n+        long left = leftBlock.getLong(leftPosition, 0);\n+        long leftPicos = unpackTimeNanos(left) * PICOSECONDS_PER_NANOSECOND;\n+        int leftOffsetMinutes = unpackOffsetMinutes(left);\n+\n+        long right = rightBlock.getLong(rightPosition, 0);\n+        long rightPicos = unpackTimeNanos(right) * PICOSECONDS_PER_NANOSECOND;\n+        int rightOffsetMinutes = unpackOffsetMinutes(right);\n+\n+        long delta = TimeWithTimezoneTypes.normalize(leftPicos, leftOffsetMinutes) - TimeWithTimezoneTypes.normalize(rightPicos, rightOffsetMinutes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDQzNDc1OnYy", "diffSide": "RIGHT", "path": "presto-spi/src/main/java/io/prestosql/spi/type/TimeWithTimeZoneType.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzo1NjoyMVrOHKOKPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzo1NjoyMVrOHKOKPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3OTgwNQ==", "bodyText": "Update this to the same style in the other date time types.", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480479805", "createdAt": "2020-08-31T23:56:21Z", "author": {"login": "dain"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/TimeWithTimeZoneType.java", "diffHunk": "@@ -13,63 +13,63 @@\n  */\n package io.prestosql.spi.type;\n \n-import io.prestosql.spi.block.Block;\n-import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.PrestoException;\n \n-import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.StandardErrorCode.NUMERIC_VALUE_OUT_OF_RANGE;\n+import static java.lang.String.format;\n \n-public final class TimeWithTimeZoneType\n-        extends AbstractLongType\n+public abstract class TimeWithTimeZoneType\n+        extends AbstractType\n+        implements FixedWidthType\n {\n-    public static final TimeWithTimeZoneType TIME_WITH_TIME_ZONE = new TimeWithTimeZoneType();\n+    public static final int MAX_PRECISION = 12;\n+    public static final int MAX_SHORT_PRECISION = 9;\n \n-    private TimeWithTimeZoneType()\n-    {\n-        super(new TypeSignature(StandardTypes.TIME_WITH_TIME_ZONE));\n-    }\n+    public static final int DEFAULT_PRECISION = 3; // TODO: should be 6 per SQL spec\n \n-    @Override\n-    public Object getObjectValue(ConnectorSession session, Block block, int position)\n+    @Deprecated\n+    public static final TimeWithTimeZoneType TIME_WITH_TIME_ZONE = new ShortTimeWithTimeZoneType(DEFAULT_PRECISION);\n+\n+    private final int precision;\n+\n+    public static TimeWithTimeZoneType createTimeWithTimeZoneType(int precision)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDQzODIwOnYy", "diffSide": "RIGHT", "path": "presto-spi/src/main/java/io/prestosql/spi/type/TimeWithTimeZoneType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzo1ODowNVrOHKOMQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzo1ODowNVrOHKOMQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ4MDMyMQ==", "bodyText": "These should be final", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480480321", "createdAt": "2020-08-31T23:58:05Z", "author": {"login": "dain"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/TimeWithTimeZoneType.java", "diffHunk": "@@ -13,63 +13,63 @@\n  */\n package io.prestosql.spi.type;\n \n-import io.prestosql.spi.block.Block;\n-import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.PrestoException;\n \n-import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.StandardErrorCode.NUMERIC_VALUE_OUT_OF_RANGE;\n+import static java.lang.String.format;\n \n-public final class TimeWithTimeZoneType\n-        extends AbstractLongType\n+public abstract class TimeWithTimeZoneType\n+        extends AbstractType\n+        implements FixedWidthType\n {\n-    public static final TimeWithTimeZoneType TIME_WITH_TIME_ZONE = new TimeWithTimeZoneType();\n+    public static final int MAX_PRECISION = 12;\n+    public static final int MAX_SHORT_PRECISION = 9;\n \n-    private TimeWithTimeZoneType()\n-    {\n-        super(new TypeSignature(StandardTypes.TIME_WITH_TIME_ZONE));\n-    }\n+    public static final int DEFAULT_PRECISION = 3; // TODO: should be 6 per SQL spec\n \n-    @Override\n-    public Object getObjectValue(ConnectorSession session, Block block, int position)\n+    @Deprecated\n+    public static final TimeWithTimeZoneType TIME_WITH_TIME_ZONE = new ShortTimeWithTimeZoneType(DEFAULT_PRECISION);\n+\n+    private final int precision;\n+\n+    public static TimeWithTimeZoneType createTimeWithTimeZoneType(int precision)\n     {\n-        if (block.isNull(position)) {\n-            return null;\n+        if (precision == DEFAULT_PRECISION) {\n+            // Use singleton for backwards compatibility with code checking `type == TIME_WITH_TIME_ZONE`\n+            return TIME_WITH_TIME_ZONE;\n         }\n \n-        return new SqlTimeWithTimeZone(block.getLong(position, 0));\n-    }\n+        if (precision < 0 || precision > MAX_PRECISION) {\n+            throw new PrestoException(NUMERIC_VALUE_OUT_OF_RANGE, format(\"TIME WITH TIME ZONE precision must be in range [0, %s]\", MAX_PRECISION));\n+        }\n \n-    @Override\n-    public boolean equalTo(Block leftBlock, int leftPosition, Block rightBlock, int rightPosition)\n-    {\n-        long leftValue = unpackMillisUtc(leftBlock.getLong(leftPosition, 0));\n-        long rightValue = unpackMillisUtc(rightBlock.getLong(rightPosition, 0));\n-        return leftValue == rightValue;\n+        if (precision <= MAX_SHORT_PRECISION) {\n+            return new ShortTimeWithTimeZoneType(precision);\n+        }\n+\n+        return new LongTimeWithTimeZoneType(precision);\n     }\n \n-    @Override\n-    public long hash(Block block, int position)\n+    protected TimeWithTimeZoneType(int precision, Class<?> javaType)\n     {\n-        return AbstractLongType.hash(unpackMillisUtc(block.getLong(position, 0)));\n+        super(new TypeSignature(StandardTypes.TIME_WITH_TIME_ZONE, TypeSignatureParameter.numericParameter(precision)), javaType);\n+        this.precision = precision;\n     }\n \n-    @Override\n-    public int compareTo(Block leftBlock, int leftPosition, Block rightBlock, int rightPosition)\n+    public int getPrecision()\n     {\n-        long leftValue = unpackMillisUtc(leftBlock.getLong(leftPosition, 0));\n-        long rightValue = unpackMillisUtc(rightBlock.getLong(rightPosition, 0));\n-        return Long.compare(leftValue, rightValue);\n+        return precision;\n     }\n \n     @Override\n-    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n-    public boolean equals(Object other)\n+    public boolean isComparable()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDQ0MjYzOnYy", "diffSide": "RIGHT", "path": "presto-spi/src/main/java/io/prestosql/spi/type/TimeWithTimezoneTypes.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMDowMDoxNlrOHKOO5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMDowMDoxNlrOHKOO5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ4MDk5Nw==", "bodyText": "we should consider having public \"normalize\" for short and long in the SPI", "url": "https://github.com/trinodb/trino/pull/4905#discussion_r480480997", "createdAt": "2020-09-01T00:00:16Z", "author": {"login": "dain"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/TimeWithTimezoneTypes.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.type;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackOffsetMinutes;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackTimeNanos;\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_DAY;\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_NANOSECOND;\n+import static java.lang.Math.floorMod;\n+\n+public final class TimeWithTimezoneTypes\n+{\n+    private TimeWithTimezoneTypes() {}\n+\n+    public static long hashLongTimeWithTimeZone(LongTimeWithTimeZone value)\n+    {\n+        return hashLongTimeWithTimeZone(value.getPicoSeconds(), value.getOffsetMinutes());\n+    }\n+\n+    public static long hashShortTimeWithTimeZone(long packedTime)\n+    {\n+        long picos = unpackTimeNanos(packedTime) * PICOSECONDS_PER_NANOSECOND;\n+        int offsetMinutes = unpackOffsetMinutes(packedTime);\n+\n+        return AbstractLongType.hash(normalize(picos, offsetMinutes));\n+    }\n+\n+    static long hashLongTimeWithTimeZone(long picos, int offsetMinutes)\n+    {\n+        return AbstractLongType.hash(normalize(picos, offsetMinutes));\n+    }\n+\n+    /**\n+     * Normalize to offset +00:00. The calculation is done modulo 24h\n+     */\n+    static long normalize(long picos, int offsetMinutes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3230, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}