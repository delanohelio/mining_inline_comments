{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3MjAyNzI0", "number": 4101, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOToxNjozNFrOEHfd8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDoyNzozNVrOEHg-gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjkxMDU5OnYy", "diffSide": "RIGHT", "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOToxNjozNFrOGm4ebw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOToxNjozNFrOGm4ebw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQyNDM2Nw==", "bodyText": "use static import for\u00a0NON and PARTITIONED", "url": "https://github.com/trinodb/trino/pull/4101#discussion_r443424367", "createdAt": "2020-06-22T09:16:34Z", "author": {"login": "sopel39"}, "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.Duration;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.plugin.tpch.TpchPlugin;\n+import io.prestosql.spi.Plugin;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.Connector;\n+import io.prestosql.spi.connector.ConnectorContext;\n+import io.prestosql.spi.connector.ConnectorFactory;\n+import io.prestosql.spi.connector.ConnectorHandleResolver;\n+import io.prestosql.spi.connector.ConnectorMetadata;\n+import io.prestosql.spi.connector.ConnectorPageSinkProvider;\n+import io.prestosql.spi.connector.ConnectorPageSource;\n+import io.prestosql.spi.connector.ConnectorPageSourceProvider;\n+import io.prestosql.spi.connector.ConnectorPartitionHandle;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorSplit;\n+import io.prestosql.spi.connector.ConnectorSplitManager;\n+import io.prestosql.spi.connector.ConnectorSplitSource;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.ConnectorTransactionHandle;\n+import io.prestosql.spi.connector.EmptyPageSource;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.transaction.IsolationLevel;\n+import io.prestosql.split.EmptySplit;\n+import io.prestosql.sql.analyzer.FeaturesConfig;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.TestingHandleResolver;\n+import io.prestosql.testing.TestingMetadata;\n+import io.prestosql.testing.TestingPageSinkProvider;\n+import io.prestosql.testing.TestingTransactionHandle;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+import static java.util.Collections.nCopies;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.CompletableFuture.completedFuture;\n+\n+@Test(singleThreaded = true)\n+public class TestCoordinatorDynamicFiltering\n+        extends AbstractTestQueryFramework\n+{\n+    private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter = new AtomicReference<>(TupleDomain.all());\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(\"test\")\n+                .setSchema(\"default\")\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, FeaturesConfig.JoinReorderingStrategy.NONE.name())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjkxNDA4OnYy", "diffSide": "RIGHT", "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOToxNzo0MFrOGm4gsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOToxNzo0MFrOGm4gsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQyNDk0NQ==", "bodyText": "static import singleValue", "url": "https://github.com/trinodb/trino/pull/4101#discussion_r443424945", "createdAt": "2020-06-22T09:17:40Z", "author": {"login": "sopel39"}, "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.Duration;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.plugin.tpch.TpchPlugin;\n+import io.prestosql.spi.Plugin;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.Connector;\n+import io.prestosql.spi.connector.ConnectorContext;\n+import io.prestosql.spi.connector.ConnectorFactory;\n+import io.prestosql.spi.connector.ConnectorHandleResolver;\n+import io.prestosql.spi.connector.ConnectorMetadata;\n+import io.prestosql.spi.connector.ConnectorPageSinkProvider;\n+import io.prestosql.spi.connector.ConnectorPageSource;\n+import io.prestosql.spi.connector.ConnectorPageSourceProvider;\n+import io.prestosql.spi.connector.ConnectorPartitionHandle;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorSplit;\n+import io.prestosql.spi.connector.ConnectorSplitManager;\n+import io.prestosql.spi.connector.ConnectorSplitSource;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.ConnectorTransactionHandle;\n+import io.prestosql.spi.connector.EmptyPageSource;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.transaction.IsolationLevel;\n+import io.prestosql.split.EmptySplit;\n+import io.prestosql.sql.analyzer.FeaturesConfig;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.TestingHandleResolver;\n+import io.prestosql.testing.TestingMetadata;\n+import io.prestosql.testing.TestingPageSinkProvider;\n+import io.prestosql.testing.TestingTransactionHandle;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+import static java.util.Collections.nCopies;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.CompletableFuture.completedFuture;\n+\n+@Test(singleThreaded = true)\n+public class TestCoordinatorDynamicFiltering\n+        extends AbstractTestQueryFramework\n+{\n+    private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter = new AtomicReference<>(TupleDomain.all());\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(\"test\")\n+                .setSchema(\"default\")\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, FeaturesConfig.JoinReorderingStrategy.NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.PARTITIONED.name())\n+                .build();\n+        return DistributedQueryRunner.builder(session).build();\n+    }\n+\n+    @BeforeClass\n+    public void setUp()\n+    {\n+        getQueryRunner().installPlugin(new TestPlugin(expectedDynamicFilter));\n+        getQueryRunner().installPlugin(new TpchPlugin());\n+        getQueryRunner().createCatalog(\"test\", \"test\", ImmutableMap.of());\n+        getQueryRunner().createCatalog(\"tpch\", \"tpch\", ImmutableMap.of());\n+        computeActual(\"CREATE TABLE lineitem AS SELECT * FROM tpch.tiny.lineitem\");\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void afterMethod()\n+    {\n+        expectedDynamicFilter.set(TupleDomain.all());\n+    }\n+\n+    @Test\n+    public void testWithEmptyBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\",\n+                TupleDomain.none());\n+    }\n+\n+    @Test\n+    public void testWithSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'Supplier#000000001'\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new TestingMetadata.TestingColumnHandle(\"suppkey\", 2, BIGINT),\n+                        Domain.singleValue(BIGINT, 1L))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjkyMDE2OnYy", "diffSide": "RIGHT", "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOToxOToxNVrOGm4kaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDoxOTo1MFrOGm6n_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQyNTg5Nw==", "bodyText": "make it private static final since it's used in multiple tests", "url": "https://github.com/trinodb/trino/pull/4101#discussion_r443425897", "createdAt": "2020-06-22T09:19:15Z", "author": {"login": "sopel39"}, "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.Duration;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.plugin.tpch.TpchPlugin;\n+import io.prestosql.spi.Plugin;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.Connector;\n+import io.prestosql.spi.connector.ConnectorContext;\n+import io.prestosql.spi.connector.ConnectorFactory;\n+import io.prestosql.spi.connector.ConnectorHandleResolver;\n+import io.prestosql.spi.connector.ConnectorMetadata;\n+import io.prestosql.spi.connector.ConnectorPageSinkProvider;\n+import io.prestosql.spi.connector.ConnectorPageSource;\n+import io.prestosql.spi.connector.ConnectorPageSourceProvider;\n+import io.prestosql.spi.connector.ConnectorPartitionHandle;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorSplit;\n+import io.prestosql.spi.connector.ConnectorSplitManager;\n+import io.prestosql.spi.connector.ConnectorSplitSource;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.ConnectorTransactionHandle;\n+import io.prestosql.spi.connector.EmptyPageSource;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.transaction.IsolationLevel;\n+import io.prestosql.split.EmptySplit;\n+import io.prestosql.sql.analyzer.FeaturesConfig;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.TestingHandleResolver;\n+import io.prestosql.testing.TestingMetadata;\n+import io.prestosql.testing.TestingPageSinkProvider;\n+import io.prestosql.testing.TestingTransactionHandle;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+import static java.util.Collections.nCopies;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.CompletableFuture.completedFuture;\n+\n+@Test(singleThreaded = true)\n+public class TestCoordinatorDynamicFiltering\n+        extends AbstractTestQueryFramework\n+{\n+    private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter = new AtomicReference<>(TupleDomain.all());\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(\"test\")\n+                .setSchema(\"default\")\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, FeaturesConfig.JoinReorderingStrategy.NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.PARTITIONED.name())\n+                .build();\n+        return DistributedQueryRunner.builder(session).build();\n+    }\n+\n+    @BeforeClass\n+    public void setUp()\n+    {\n+        getQueryRunner().installPlugin(new TestPlugin(expectedDynamicFilter));\n+        getQueryRunner().installPlugin(new TpchPlugin());\n+        getQueryRunner().createCatalog(\"test\", \"test\", ImmutableMap.of());\n+        getQueryRunner().createCatalog(\"tpch\", \"tpch\", ImmutableMap.of());\n+        computeActual(\"CREATE TABLE lineitem AS SELECT * FROM tpch.tiny.lineitem\");\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void afterMethod()\n+    {\n+        expectedDynamicFilter.set(TupleDomain.all());\n+    }\n+\n+    @Test\n+    public void testWithEmptyBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\",\n+                TupleDomain.none());\n+    }\n+\n+    @Test\n+    public void testWithSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'Supplier#000000001'\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new TestingMetadata.TestingColumnHandle(\"suppkey\", 2, BIGINT),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1OTU4MA==", "bodyText": "done", "url": "https://github.com/trinodb/trino/pull/4101#discussion_r443459580", "createdAt": "2020-06-22T10:19:50Z", "author": {"login": "raunaqmorarka"}, "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.Duration;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.plugin.tpch.TpchPlugin;\n+import io.prestosql.spi.Plugin;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.Connector;\n+import io.prestosql.spi.connector.ConnectorContext;\n+import io.prestosql.spi.connector.ConnectorFactory;\n+import io.prestosql.spi.connector.ConnectorHandleResolver;\n+import io.prestosql.spi.connector.ConnectorMetadata;\n+import io.prestosql.spi.connector.ConnectorPageSinkProvider;\n+import io.prestosql.spi.connector.ConnectorPageSource;\n+import io.prestosql.spi.connector.ConnectorPageSourceProvider;\n+import io.prestosql.spi.connector.ConnectorPartitionHandle;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorSplit;\n+import io.prestosql.spi.connector.ConnectorSplitManager;\n+import io.prestosql.spi.connector.ConnectorSplitSource;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.ConnectorTransactionHandle;\n+import io.prestosql.spi.connector.EmptyPageSource;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.transaction.IsolationLevel;\n+import io.prestosql.split.EmptySplit;\n+import io.prestosql.sql.analyzer.FeaturesConfig;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.TestingHandleResolver;\n+import io.prestosql.testing.TestingMetadata;\n+import io.prestosql.testing.TestingPageSinkProvider;\n+import io.prestosql.testing.TestingTransactionHandle;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+import static java.util.Collections.nCopies;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.CompletableFuture.completedFuture;\n+\n+@Test(singleThreaded = true)\n+public class TestCoordinatorDynamicFiltering\n+        extends AbstractTestQueryFramework\n+{\n+    private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter = new AtomicReference<>(TupleDomain.all());\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(\"test\")\n+                .setSchema(\"default\")\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, FeaturesConfig.JoinReorderingStrategy.NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.PARTITIONED.name())\n+                .build();\n+        return DistributedQueryRunner.builder(session).build();\n+    }\n+\n+    @BeforeClass\n+    public void setUp()\n+    {\n+        getQueryRunner().installPlugin(new TestPlugin(expectedDynamicFilter));\n+        getQueryRunner().installPlugin(new TpchPlugin());\n+        getQueryRunner().createCatalog(\"test\", \"test\", ImmutableMap.of());\n+        getQueryRunner().createCatalog(\"tpch\", \"tpch\", ImmutableMap.of());\n+        computeActual(\"CREATE TABLE lineitem AS SELECT * FROM tpch.tiny.lineitem\");\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void afterMethod()\n+    {\n+        expectedDynamicFilter.set(TupleDomain.all());\n+    }\n+\n+    @Test\n+    public void testWithEmptyBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\",\n+                TupleDomain.none());\n+    }\n+\n+    @Test\n+    public void testWithSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'Supplier#000000001'\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new TestingMetadata.TestingColumnHandle(\"suppkey\", 2, BIGINT),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQyNTg5Nw=="}, "originalCommit": null, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjkyNDA4OnYy", "diffSide": "RIGHT", "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOToyMDoyN1rOGm4m9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOToyMDoyN1rOGm4m9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQyNjU1MA==", "bodyText": "add a comment what key values 'Supplier#000000001', 'Supplier#000000002' match to.", "url": "https://github.com/trinodb/trino/pull/4101#discussion_r443426550", "createdAt": "2020-06-22T09:20:27Z", "author": {"login": "sopel39"}, "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.Duration;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.plugin.tpch.TpchPlugin;\n+import io.prestosql.spi.Plugin;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.Connector;\n+import io.prestosql.spi.connector.ConnectorContext;\n+import io.prestosql.spi.connector.ConnectorFactory;\n+import io.prestosql.spi.connector.ConnectorHandleResolver;\n+import io.prestosql.spi.connector.ConnectorMetadata;\n+import io.prestosql.spi.connector.ConnectorPageSinkProvider;\n+import io.prestosql.spi.connector.ConnectorPageSource;\n+import io.prestosql.spi.connector.ConnectorPageSourceProvider;\n+import io.prestosql.spi.connector.ConnectorPartitionHandle;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorSplit;\n+import io.prestosql.spi.connector.ConnectorSplitManager;\n+import io.prestosql.spi.connector.ConnectorSplitSource;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.ConnectorTransactionHandle;\n+import io.prestosql.spi.connector.EmptyPageSource;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.transaction.IsolationLevel;\n+import io.prestosql.split.EmptySplit;\n+import io.prestosql.sql.analyzer.FeaturesConfig;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.TestingHandleResolver;\n+import io.prestosql.testing.TestingMetadata;\n+import io.prestosql.testing.TestingPageSinkProvider;\n+import io.prestosql.testing.TestingTransactionHandle;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+import static java.util.Collections.nCopies;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.CompletableFuture.completedFuture;\n+\n+@Test(singleThreaded = true)\n+public class TestCoordinatorDynamicFiltering\n+        extends AbstractTestQueryFramework\n+{\n+    private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter = new AtomicReference<>(TupleDomain.all());\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(\"test\")\n+                .setSchema(\"default\")\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, FeaturesConfig.JoinReorderingStrategy.NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.PARTITIONED.name())\n+                .build();\n+        return DistributedQueryRunner.builder(session).build();\n+    }\n+\n+    @BeforeClass\n+    public void setUp()\n+    {\n+        getQueryRunner().installPlugin(new TestPlugin(expectedDynamicFilter));\n+        getQueryRunner().installPlugin(new TpchPlugin());\n+        getQueryRunner().createCatalog(\"test\", \"test\", ImmutableMap.of());\n+        getQueryRunner().createCatalog(\"tpch\", \"tpch\", ImmutableMap.of());\n+        computeActual(\"CREATE TABLE lineitem AS SELECT * FROM tpch.tiny.lineitem\");\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void afterMethod()\n+    {\n+        expectedDynamicFilter.set(TupleDomain.all());\n+    }\n+\n+    @Test\n+    public void testWithEmptyBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\",\n+                TupleDomain.none());\n+    }\n+\n+    @Test\n+    public void testWithSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'Supplier#000000001'\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new TestingMetadata.TestingColumnHandle(\"suppkey\", 2, BIGINT),\n+                        Domain.singleValue(BIGINT, 1L))));\n+    }\n+\n+    @Test\n+    public void testWithNonSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new TestingMetadata.TestingColumnHandle(\"suppkey\", 2, BIGINT),\n+                        Domain.create(ValueSet.ofRanges(Range.range(BIGINT, 1L, true, 100L, true)), false))));\n+    }\n+\n+    @Test\n+    public void testWithMultipleDynamicFiltersOnProbe()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM (\" +\n+                        \"SELECT supplier.suppkey FROM \" +\n+                            \"lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name IN ('Supplier#000000001', 'Supplier#000000002')\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2Mjk0NzQwOnYy", "diffSide": "RIGHT", "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOToyNjo1MlrOGm41pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOToyNjo1MlrOGm41pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQzMDMxMA==", "bodyText": "static import format", "url": "https://github.com/trinodb/trino/pull/4101#discussion_r443430310", "createdAt": "2020-06-22T09:26:52Z", "author": {"login": "sopel39"}, "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.Duration;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.plugin.tpch.TpchPlugin;\n+import io.prestosql.spi.Plugin;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.Connector;\n+import io.prestosql.spi.connector.ConnectorContext;\n+import io.prestosql.spi.connector.ConnectorFactory;\n+import io.prestosql.spi.connector.ConnectorHandleResolver;\n+import io.prestosql.spi.connector.ConnectorMetadata;\n+import io.prestosql.spi.connector.ConnectorPageSinkProvider;\n+import io.prestosql.spi.connector.ConnectorPageSource;\n+import io.prestosql.spi.connector.ConnectorPageSourceProvider;\n+import io.prestosql.spi.connector.ConnectorPartitionHandle;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorSplit;\n+import io.prestosql.spi.connector.ConnectorSplitManager;\n+import io.prestosql.spi.connector.ConnectorSplitSource;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.ConnectorTransactionHandle;\n+import io.prestosql.spi.connector.EmptyPageSource;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.transaction.IsolationLevel;\n+import io.prestosql.split.EmptySplit;\n+import io.prestosql.sql.analyzer.FeaturesConfig;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.TestingHandleResolver;\n+import io.prestosql.testing.TestingMetadata;\n+import io.prestosql.testing.TestingPageSinkProvider;\n+import io.prestosql.testing.TestingTransactionHandle;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+import static java.util.Collections.nCopies;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.CompletableFuture.completedFuture;\n+\n+@Test(singleThreaded = true)\n+public class TestCoordinatorDynamicFiltering\n+        extends AbstractTestQueryFramework\n+{\n+    private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter = new AtomicReference<>(TupleDomain.all());\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(\"test\")\n+                .setSchema(\"default\")\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, FeaturesConfig.JoinReorderingStrategy.NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.PARTITIONED.name())\n+                .build();\n+        return DistributedQueryRunner.builder(session).build();\n+    }\n+\n+    @BeforeClass\n+    public void setUp()\n+    {\n+        getQueryRunner().installPlugin(new TestPlugin(expectedDynamicFilter));\n+        getQueryRunner().installPlugin(new TpchPlugin());\n+        getQueryRunner().createCatalog(\"test\", \"test\", ImmutableMap.of());\n+        getQueryRunner().createCatalog(\"tpch\", \"tpch\", ImmutableMap.of());\n+        computeActual(\"CREATE TABLE lineitem AS SELECT * FROM tpch.tiny.lineitem\");\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void afterMethod()\n+    {\n+        expectedDynamicFilter.set(TupleDomain.all());\n+    }\n+\n+    @Test\n+    public void testWithEmptyBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\",\n+                TupleDomain.none());\n+    }\n+\n+    @Test\n+    public void testWithSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'Supplier#000000001'\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new TestingMetadata.TestingColumnHandle(\"suppkey\", 2, BIGINT),\n+                        Domain.singleValue(BIGINT, 1L))));\n+    }\n+\n+    @Test\n+    public void testWithNonSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new TestingMetadata.TestingColumnHandle(\"suppkey\", 2, BIGINT),\n+                        Domain.create(ValueSet.ofRanges(Range.range(BIGINT, 1L, true, 100L, true)), false))));\n+    }\n+\n+    @Test\n+    public void testWithMultipleDynamicFiltersOnProbe()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM (\" +\n+                        \"SELECT supplier.suppkey FROM \" +\n+                            \"lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name IN ('Supplier#000000001', 'Supplier#000000002')\" +\n+                        \") t JOIN tpch.tiny.partsupp ON t.suppkey = partsupp.suppkey AND partsupp.suppkey IN (2, 3)\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new TestingMetadata.TestingColumnHandle(\"suppkey\", 2, BIGINT),\n+                        Domain.singleValue(BIGINT, 2L))));\n+    }\n+\n+    private void assertQueryDynamicFilters(@Language(\"SQL\") String query, TupleDomain<ColumnHandle> expectedTupleDomain)\n+    {\n+        expectedDynamicFilter.set(expectedTupleDomain);\n+        computeActual(query);\n+    }\n+\n+    private static class TestPlugin\n+            implements Plugin\n+    {\n+        private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter;\n+\n+        private TestPlugin(AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter)\n+        {\n+            this.expectedDynamicFilter = requireNonNull(expectedDynamicFilter, \"expectedDynamicFilter is null\");\n+        }\n+\n+        @Override\n+        public Iterable<ConnectorFactory> getConnectorFactories()\n+        {\n+            return ImmutableList.of(new ConnectorFactory()\n+            {\n+                private final ConnectorMetadata metadata = new TestingMetadata();\n+\n+                @Override\n+                public String getName()\n+                {\n+                    return \"test\";\n+                }\n+\n+                @Override\n+                public ConnectorHandleResolver getHandleResolver()\n+                {\n+                    return new TestingHandleResolver();\n+                }\n+\n+                @Override\n+                public Connector create(String catalogName, Map<String, String> config, ConnectorContext context)\n+                {\n+                    return new TestConnector(metadata, Duration.valueOf(\"5s\"), expectedDynamicFilter);\n+                }\n+            });\n+        }\n+    }\n+\n+    private static class TestConnector\n+            implements Connector\n+    {\n+        private final ConnectorMetadata metadata;\n+        private final Duration scanDuration;\n+        private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter;\n+\n+        private TestConnector(ConnectorMetadata metadata, Duration scanDuration, AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter)\n+        {\n+            this.metadata = requireNonNull(metadata, \"metadata is null\");\n+            this.scanDuration = requireNonNull(scanDuration, \"scanDuration is null\");\n+            this.expectedDynamicFilter = requireNonNull(expectedDynamicFilter, \"expectedDynamicFilter is null\");\n+        }\n+\n+        @Override\n+        public ConnectorTransactionHandle beginTransaction(IsolationLevel isolationLevel, boolean readOnly)\n+        {\n+            return TestingTransactionHandle.create();\n+        }\n+\n+        @Override\n+        public ConnectorMetadata getMetadata(ConnectorTransactionHandle transactionHandle)\n+        {\n+            return metadata;\n+        }\n+\n+        @Override\n+        public ConnectorSplitManager getSplitManager()\n+        {\n+            return new ConnectorSplitManager()\n+            {\n+                @Override\n+                public ConnectorSplitSource getSplits(\n+                        ConnectorTransactionHandle transaction,\n+                        ConnectorSession session,\n+                        ConnectorTableHandle table,\n+                        SplitSchedulingStrategy splitSchedulingStrategy,\n+                        Supplier<TupleDomain<ColumnHandle>> dynamicFilter)\n+                {\n+                    long start = System.nanoTime();\n+                    return new ConnectorSplitSource()\n+                    {\n+                        @Override\n+                        public CompletableFuture<ConnectorSplitBatch> getNextBatch(ConnectorPartitionHandle partitionHandle, int maxSize)\n+                        {\n+                            return completedFuture(new ConnectorSplitBatch(\n+                                    nCopies(maxSize, new EmptySplit(new CatalogName(\"test\"))),\n+                                    isFinished()));\n+                        }\n+\n+                        @Override\n+                        public void close()\n+                        {\n+                        }\n+\n+                        @Override\n+                        public boolean isFinished()\n+                        {\n+                            if (Duration.nanosSince(start).compareTo(scanDuration) > 0) {\n+                                if (dynamicFilter.get().equals(expectedDynamicFilter.get())) {\n+                                    // if we received expected dynamic filter then we are done\n+                                    return true;\n+                                }\n+                                else {\n+                                    throw new AssertionError(String.format(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 257}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2Mjk1OTQzOnYy", "diffSide": "RIGHT", "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOTozMDoxMFrOGm49Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDoyMDo1MFrOGm6qFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQzMjIyMw==", "bodyText": "this will cause each test to take 5 seconds.\nChange the condition to:\nif (dynamicFilter.get().equals(expectedDynamicFilter.get())) {\n  return true;\n} else if (Duration.nanosSince(start).compareTo(scanDuration) > 0) {\n  throw new AssertionError(...))\n}\n\n// expected dynamic filter is not set yet\nreturn false;", "url": "https://github.com/trinodb/trino/pull/4101#discussion_r443432223", "createdAt": "2020-06-22T09:30:10Z", "author": {"login": "sopel39"}, "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.Duration;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.plugin.tpch.TpchPlugin;\n+import io.prestosql.spi.Plugin;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.Connector;\n+import io.prestosql.spi.connector.ConnectorContext;\n+import io.prestosql.spi.connector.ConnectorFactory;\n+import io.prestosql.spi.connector.ConnectorHandleResolver;\n+import io.prestosql.spi.connector.ConnectorMetadata;\n+import io.prestosql.spi.connector.ConnectorPageSinkProvider;\n+import io.prestosql.spi.connector.ConnectorPageSource;\n+import io.prestosql.spi.connector.ConnectorPageSourceProvider;\n+import io.prestosql.spi.connector.ConnectorPartitionHandle;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorSplit;\n+import io.prestosql.spi.connector.ConnectorSplitManager;\n+import io.prestosql.spi.connector.ConnectorSplitSource;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.ConnectorTransactionHandle;\n+import io.prestosql.spi.connector.EmptyPageSource;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.transaction.IsolationLevel;\n+import io.prestosql.split.EmptySplit;\n+import io.prestosql.sql.analyzer.FeaturesConfig;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.TestingHandleResolver;\n+import io.prestosql.testing.TestingMetadata;\n+import io.prestosql.testing.TestingPageSinkProvider;\n+import io.prestosql.testing.TestingTransactionHandle;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+import static java.util.Collections.nCopies;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.CompletableFuture.completedFuture;\n+\n+@Test(singleThreaded = true)\n+public class TestCoordinatorDynamicFiltering\n+        extends AbstractTestQueryFramework\n+{\n+    private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter = new AtomicReference<>(TupleDomain.all());\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(\"test\")\n+                .setSchema(\"default\")\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, FeaturesConfig.JoinReorderingStrategy.NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.PARTITIONED.name())\n+                .build();\n+        return DistributedQueryRunner.builder(session).build();\n+    }\n+\n+    @BeforeClass\n+    public void setUp()\n+    {\n+        getQueryRunner().installPlugin(new TestPlugin(expectedDynamicFilter));\n+        getQueryRunner().installPlugin(new TpchPlugin());\n+        getQueryRunner().createCatalog(\"test\", \"test\", ImmutableMap.of());\n+        getQueryRunner().createCatalog(\"tpch\", \"tpch\", ImmutableMap.of());\n+        computeActual(\"CREATE TABLE lineitem AS SELECT * FROM tpch.tiny.lineitem\");\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void afterMethod()\n+    {\n+        expectedDynamicFilter.set(TupleDomain.all());\n+    }\n+\n+    @Test\n+    public void testWithEmptyBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\",\n+                TupleDomain.none());\n+    }\n+\n+    @Test\n+    public void testWithSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'Supplier#000000001'\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new TestingMetadata.TestingColumnHandle(\"suppkey\", 2, BIGINT),\n+                        Domain.singleValue(BIGINT, 1L))));\n+    }\n+\n+    @Test\n+    public void testWithNonSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new TestingMetadata.TestingColumnHandle(\"suppkey\", 2, BIGINT),\n+                        Domain.create(ValueSet.ofRanges(Range.range(BIGINT, 1L, true, 100L, true)), false))));\n+    }\n+\n+    @Test\n+    public void testWithMultipleDynamicFiltersOnProbe()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM (\" +\n+                        \"SELECT supplier.suppkey FROM \" +\n+                            \"lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name IN ('Supplier#000000001', 'Supplier#000000002')\" +\n+                        \") t JOIN tpch.tiny.partsupp ON t.suppkey = partsupp.suppkey AND partsupp.suppkey IN (2, 3)\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new TestingMetadata.TestingColumnHandle(\"suppkey\", 2, BIGINT),\n+                        Domain.singleValue(BIGINT, 2L))));\n+    }\n+\n+    private void assertQueryDynamicFilters(@Language(\"SQL\") String query, TupleDomain<ColumnHandle> expectedTupleDomain)\n+    {\n+        expectedDynamicFilter.set(expectedTupleDomain);\n+        computeActual(query);\n+    }\n+\n+    private static class TestPlugin\n+            implements Plugin\n+    {\n+        private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter;\n+\n+        private TestPlugin(AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter)\n+        {\n+            this.expectedDynamicFilter = requireNonNull(expectedDynamicFilter, \"expectedDynamicFilter is null\");\n+        }\n+\n+        @Override\n+        public Iterable<ConnectorFactory> getConnectorFactories()\n+        {\n+            return ImmutableList.of(new ConnectorFactory()\n+            {\n+                private final ConnectorMetadata metadata = new TestingMetadata();\n+\n+                @Override\n+                public String getName()\n+                {\n+                    return \"test\";\n+                }\n+\n+                @Override\n+                public ConnectorHandleResolver getHandleResolver()\n+                {\n+                    return new TestingHandleResolver();\n+                }\n+\n+                @Override\n+                public Connector create(String catalogName, Map<String, String> config, ConnectorContext context)\n+                {\n+                    return new TestConnector(metadata, Duration.valueOf(\"5s\"), expectedDynamicFilter);\n+                }\n+            });\n+        }\n+    }\n+\n+    private static class TestConnector\n+            implements Connector\n+    {\n+        private final ConnectorMetadata metadata;\n+        private final Duration scanDuration;\n+        private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter;\n+\n+        private TestConnector(ConnectorMetadata metadata, Duration scanDuration, AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter)\n+        {\n+            this.metadata = requireNonNull(metadata, \"metadata is null\");\n+            this.scanDuration = requireNonNull(scanDuration, \"scanDuration is null\");\n+            this.expectedDynamicFilter = requireNonNull(expectedDynamicFilter, \"expectedDynamicFilter is null\");\n+        }\n+\n+        @Override\n+        public ConnectorTransactionHandle beginTransaction(IsolationLevel isolationLevel, boolean readOnly)\n+        {\n+            return TestingTransactionHandle.create();\n+        }\n+\n+        @Override\n+        public ConnectorMetadata getMetadata(ConnectorTransactionHandle transactionHandle)\n+        {\n+            return metadata;\n+        }\n+\n+        @Override\n+        public ConnectorSplitManager getSplitManager()\n+        {\n+            return new ConnectorSplitManager()\n+            {\n+                @Override\n+                public ConnectorSplitSource getSplits(\n+                        ConnectorTransactionHandle transaction,\n+                        ConnectorSession session,\n+                        ConnectorTableHandle table,\n+                        SplitSchedulingStrategy splitSchedulingStrategy,\n+                        Supplier<TupleDomain<ColumnHandle>> dynamicFilter)\n+                {\n+                    long start = System.nanoTime();\n+                    return new ConnectorSplitSource()\n+                    {\n+                        @Override\n+                        public CompletableFuture<ConnectorSplitBatch> getNextBatch(ConnectorPartitionHandle partitionHandle, int maxSize)\n+                        {\n+                            return completedFuture(new ConnectorSplitBatch(\n+                                    nCopies(maxSize, new EmptySplit(new CatalogName(\"test\"))),\n+                                    isFinished()));\n+                        }\n+\n+                        @Override\n+                        public void close()\n+                        {\n+                        }\n+\n+                        @Override\n+                        public boolean isFinished()\n+                        {\n+                            if (Duration.nanosSince(start).compareTo(scanDuration) > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2MDExNw==", "bodyText": "Changed, also increased scanDuration to 10s to avoid any flakiness in tests from late arrival of DF.", "url": "https://github.com/trinodb/trino/pull/4101#discussion_r443460117", "createdAt": "2020-06-22T10:20:50Z", "author": {"login": "raunaqmorarka"}, "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.Duration;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.plugin.tpch.TpchPlugin;\n+import io.prestosql.spi.Plugin;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.Connector;\n+import io.prestosql.spi.connector.ConnectorContext;\n+import io.prestosql.spi.connector.ConnectorFactory;\n+import io.prestosql.spi.connector.ConnectorHandleResolver;\n+import io.prestosql.spi.connector.ConnectorMetadata;\n+import io.prestosql.spi.connector.ConnectorPageSinkProvider;\n+import io.prestosql.spi.connector.ConnectorPageSource;\n+import io.prestosql.spi.connector.ConnectorPageSourceProvider;\n+import io.prestosql.spi.connector.ConnectorPartitionHandle;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorSplit;\n+import io.prestosql.spi.connector.ConnectorSplitManager;\n+import io.prestosql.spi.connector.ConnectorSplitSource;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.ConnectorTransactionHandle;\n+import io.prestosql.spi.connector.EmptyPageSource;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.transaction.IsolationLevel;\n+import io.prestosql.split.EmptySplit;\n+import io.prestosql.sql.analyzer.FeaturesConfig;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.TestingHandleResolver;\n+import io.prestosql.testing.TestingMetadata;\n+import io.prestosql.testing.TestingPageSinkProvider;\n+import io.prestosql.testing.TestingTransactionHandle;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+import static java.util.Collections.nCopies;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.CompletableFuture.completedFuture;\n+\n+@Test(singleThreaded = true)\n+public class TestCoordinatorDynamicFiltering\n+        extends AbstractTestQueryFramework\n+{\n+    private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter = new AtomicReference<>(TupleDomain.all());\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(\"test\")\n+                .setSchema(\"default\")\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, FeaturesConfig.JoinReorderingStrategy.NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.PARTITIONED.name())\n+                .build();\n+        return DistributedQueryRunner.builder(session).build();\n+    }\n+\n+    @BeforeClass\n+    public void setUp()\n+    {\n+        getQueryRunner().installPlugin(new TestPlugin(expectedDynamicFilter));\n+        getQueryRunner().installPlugin(new TpchPlugin());\n+        getQueryRunner().createCatalog(\"test\", \"test\", ImmutableMap.of());\n+        getQueryRunner().createCatalog(\"tpch\", \"tpch\", ImmutableMap.of());\n+        computeActual(\"CREATE TABLE lineitem AS SELECT * FROM tpch.tiny.lineitem\");\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void afterMethod()\n+    {\n+        expectedDynamicFilter.set(TupleDomain.all());\n+    }\n+\n+    @Test\n+    public void testWithEmptyBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\",\n+                TupleDomain.none());\n+    }\n+\n+    @Test\n+    public void testWithSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'Supplier#000000001'\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new TestingMetadata.TestingColumnHandle(\"suppkey\", 2, BIGINT),\n+                        Domain.singleValue(BIGINT, 1L))));\n+    }\n+\n+    @Test\n+    public void testWithNonSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new TestingMetadata.TestingColumnHandle(\"suppkey\", 2, BIGINT),\n+                        Domain.create(ValueSet.ofRanges(Range.range(BIGINT, 1L, true, 100L, true)), false))));\n+    }\n+\n+    @Test\n+    public void testWithMultipleDynamicFiltersOnProbe()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM (\" +\n+                        \"SELECT supplier.suppkey FROM \" +\n+                            \"lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name IN ('Supplier#000000001', 'Supplier#000000002')\" +\n+                        \") t JOIN tpch.tiny.partsupp ON t.suppkey = partsupp.suppkey AND partsupp.suppkey IN (2, 3)\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new TestingMetadata.TestingColumnHandle(\"suppkey\", 2, BIGINT),\n+                        Domain.singleValue(BIGINT, 2L))));\n+    }\n+\n+    private void assertQueryDynamicFilters(@Language(\"SQL\") String query, TupleDomain<ColumnHandle> expectedTupleDomain)\n+    {\n+        expectedDynamicFilter.set(expectedTupleDomain);\n+        computeActual(query);\n+    }\n+\n+    private static class TestPlugin\n+            implements Plugin\n+    {\n+        private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter;\n+\n+        private TestPlugin(AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter)\n+        {\n+            this.expectedDynamicFilter = requireNonNull(expectedDynamicFilter, \"expectedDynamicFilter is null\");\n+        }\n+\n+        @Override\n+        public Iterable<ConnectorFactory> getConnectorFactories()\n+        {\n+            return ImmutableList.of(new ConnectorFactory()\n+            {\n+                private final ConnectorMetadata metadata = new TestingMetadata();\n+\n+                @Override\n+                public String getName()\n+                {\n+                    return \"test\";\n+                }\n+\n+                @Override\n+                public ConnectorHandleResolver getHandleResolver()\n+                {\n+                    return new TestingHandleResolver();\n+                }\n+\n+                @Override\n+                public Connector create(String catalogName, Map<String, String> config, ConnectorContext context)\n+                {\n+                    return new TestConnector(metadata, Duration.valueOf(\"5s\"), expectedDynamicFilter);\n+                }\n+            });\n+        }\n+    }\n+\n+    private static class TestConnector\n+            implements Connector\n+    {\n+        private final ConnectorMetadata metadata;\n+        private final Duration scanDuration;\n+        private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter;\n+\n+        private TestConnector(ConnectorMetadata metadata, Duration scanDuration, AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter)\n+        {\n+            this.metadata = requireNonNull(metadata, \"metadata is null\");\n+            this.scanDuration = requireNonNull(scanDuration, \"scanDuration is null\");\n+            this.expectedDynamicFilter = requireNonNull(expectedDynamicFilter, \"expectedDynamicFilter is null\");\n+        }\n+\n+        @Override\n+        public ConnectorTransactionHandle beginTransaction(IsolationLevel isolationLevel, boolean readOnly)\n+        {\n+            return TestingTransactionHandle.create();\n+        }\n+\n+        @Override\n+        public ConnectorMetadata getMetadata(ConnectorTransactionHandle transactionHandle)\n+        {\n+            return metadata;\n+        }\n+\n+        @Override\n+        public ConnectorSplitManager getSplitManager()\n+        {\n+            return new ConnectorSplitManager()\n+            {\n+                @Override\n+                public ConnectorSplitSource getSplits(\n+                        ConnectorTransactionHandle transaction,\n+                        ConnectorSession session,\n+                        ConnectorTableHandle table,\n+                        SplitSchedulingStrategy splitSchedulingStrategy,\n+                        Supplier<TupleDomain<ColumnHandle>> dynamicFilter)\n+                {\n+                    long start = System.nanoTime();\n+                    return new ConnectorSplitSource()\n+                    {\n+                        @Override\n+                        public CompletableFuture<ConnectorSplitBatch> getNextBatch(ConnectorPartitionHandle partitionHandle, int maxSize)\n+                        {\n+                            return completedFuture(new ConnectorSplitBatch(\n+                                    nCopies(maxSize, new EmptySplit(new CatalogName(\"test\"))),\n+                                    isFinished()));\n+                        }\n+\n+                        @Override\n+                        public void close()\n+                        {\n+                        }\n+\n+                        @Override\n+                        public boolean isFinished()\n+                        {\n+                            if (Duration.nanosSince(start).compareTo(scanDuration) > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQzMjIyMw=="}, "originalCommit": null, "originalPosition": 251}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzE1Nzc5OnYy", "diffSide": "RIGHT", "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDoyNzozNVrOGm63ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMToxNDoyMFrOGm8QSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2MzYxMA==", "bodyText": "nanos might flip in comparison, see: https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#nanoTime()\nEither use difference for comparison or https://guava.dev/releases/18.0/api/docs/com/google/common/base/Stopwatch.html", "url": "https://github.com/trinodb/trino/pull/4101#discussion_r443463610", "createdAt": "2020-06-22T10:27:35Z", "author": {"login": "sopel39"}, "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.Duration;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.plugin.tpch.TpchPlugin;\n+import io.prestosql.spi.Plugin;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.Connector;\n+import io.prestosql.spi.connector.ConnectorContext;\n+import io.prestosql.spi.connector.ConnectorFactory;\n+import io.prestosql.spi.connector.ConnectorHandleResolver;\n+import io.prestosql.spi.connector.ConnectorMetadata;\n+import io.prestosql.spi.connector.ConnectorPageSinkProvider;\n+import io.prestosql.spi.connector.ConnectorPageSource;\n+import io.prestosql.spi.connector.ConnectorPageSourceProvider;\n+import io.prestosql.spi.connector.ConnectorPartitionHandle;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorSplit;\n+import io.prestosql.spi.connector.ConnectorSplitManager;\n+import io.prestosql.spi.connector.ConnectorSplitSource;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.ConnectorTransactionHandle;\n+import io.prestosql.spi.connector.EmptyPageSource;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.transaction.IsolationLevel;\n+import io.prestosql.split.EmptySplit;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.TestingHandleResolver;\n+import io.prestosql.testing.TestingMetadata;\n+import io.prestosql.testing.TestingPageSinkProvider;\n+import io.prestosql.testing.TestingTransactionHandle;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.testing.TestingMetadata.TestingColumnHandle;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+import static java.lang.String.format;\n+import static java.util.Collections.nCopies;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.CompletableFuture.completedFuture;\n+\n+@Test(singleThreaded = true)\n+public class TestCoordinatorDynamicFiltering\n+        extends AbstractTestQueryFramework\n+{\n+    private static final TestingColumnHandle suppKeyHandle = new TestingColumnHandle(\"suppkey\", 2, BIGINT);\n+    private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter = new AtomicReference<>(TupleDomain.all());\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(\"test\")\n+                .setSchema(\"default\")\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name())\n+                .build();\n+        return DistributedQueryRunner.builder(session).build();\n+    }\n+\n+    @BeforeClass\n+    public void setUp()\n+    {\n+        getQueryRunner().installPlugin(new TestPlugin(expectedDynamicFilter));\n+        getQueryRunner().installPlugin(new TpchPlugin());\n+        getQueryRunner().createCatalog(\"test\", \"test\", ImmutableMap.of());\n+        getQueryRunner().createCatalog(\"tpch\", \"tpch\", ImmutableMap.of());\n+        computeActual(\"CREATE TABLE lineitem AS SELECT * FROM tpch.tiny.lineitem\");\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void afterMethod()\n+    {\n+        expectedDynamicFilter.set(TupleDomain.all());\n+    }\n+\n+    @Test\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\",\n+                TupleDomain.none());\n+    }\n+\n+    @Test\n+    public void testJoinWithSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'Supplier#000000001'\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        suppKeyHandle,\n+                        singleValue(BIGINT, 1L))));\n+    }\n+\n+    @Test\n+    public void testJoinWithNonSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        suppKeyHandle,\n+                        Domain.create(ValueSet.ofRanges(Range.range(BIGINT, 1L, true, 100L, true)), false))));\n+    }\n+\n+    @Test\n+    public void testJoinWithMultipleDynamicFiltersOnProbe()\n+    {\n+        // supplier names Supplier#000000001 and Supplier#000000002 match suppkey 1 and 2\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM (\" +\n+                        \"SELECT supplier.suppkey FROM \" +\n+                            \"lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name IN ('Supplier#000000001', 'Supplier#000000002')\" +\n+                        \") t JOIN tpch.tiny.partsupp ON t.suppkey = partsupp.suppkey AND partsupp.suppkey IN (2, 3)\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        suppKeyHandle,\n+                        singleValue(BIGINT, 2L))));\n+    }\n+\n+    private void assertQueryDynamicFilters(@Language(\"SQL\") String query, TupleDomain<ColumnHandle> expectedTupleDomain)\n+    {\n+        expectedDynamicFilter.set(expectedTupleDomain);\n+        computeActual(query);\n+    }\n+\n+    private static class TestPlugin\n+            implements Plugin\n+    {\n+        private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter;\n+\n+        private TestPlugin(AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter)\n+        {\n+            this.expectedDynamicFilter = requireNonNull(expectedDynamicFilter, \"expectedDynamicFilter is null\");\n+        }\n+\n+        @Override\n+        public Iterable<ConnectorFactory> getConnectorFactories()\n+        {\n+            return ImmutableList.of(new ConnectorFactory()\n+            {\n+                private final ConnectorMetadata metadata = new TestingMetadata();\n+\n+                @Override\n+                public String getName()\n+                {\n+                    return \"test\";\n+                }\n+\n+                @Override\n+                public ConnectorHandleResolver getHandleResolver()\n+                {\n+                    return new TestingHandleResolver();\n+                }\n+\n+                @Override\n+                public Connector create(String catalogName, Map<String, String> config, ConnectorContext context)\n+                {\n+                    return new TestConnector(metadata, Duration.valueOf(\"10s\"), expectedDynamicFilter);\n+                }\n+            });\n+        }\n+    }\n+\n+    private static class TestConnector\n+            implements Connector\n+    {\n+        private final ConnectorMetadata metadata;\n+        private final Duration scanDuration;\n+        private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter;\n+\n+        private TestConnector(ConnectorMetadata metadata, Duration scanDuration, AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter)\n+        {\n+            this.metadata = requireNonNull(metadata, \"metadata is null\");\n+            this.scanDuration = requireNonNull(scanDuration, \"scanDuration is null\");\n+            this.expectedDynamicFilter = requireNonNull(expectedDynamicFilter, \"expectedDynamicFilter is null\");\n+        }\n+\n+        @Override\n+        public ConnectorTransactionHandle beginTransaction(IsolationLevel isolationLevel, boolean readOnly)\n+        {\n+            return TestingTransactionHandle.create();\n+        }\n+\n+        @Override\n+        public ConnectorMetadata getMetadata(ConnectorTransactionHandle transactionHandle)\n+        {\n+            return metadata;\n+        }\n+\n+        @Override\n+        public ConnectorSplitManager getSplitManager()\n+        {\n+            return new ConnectorSplitManager()\n+            {\n+                @Override\n+                public ConnectorSplitSource getSplits(\n+                        ConnectorTransactionHandle transaction,\n+                        ConnectorSession session,\n+                        ConnectorTableHandle table,\n+                        SplitSchedulingStrategy splitSchedulingStrategy,\n+                        Supplier<TupleDomain<ColumnHandle>> dynamicFilter)\n+                {\n+                    long start = System.nanoTime();\n+                    return new ConnectorSplitSource()\n+                    {\n+                        @Override\n+                        public CompletableFuture<ConnectorSplitBatch> getNextBatch(ConnectorPartitionHandle partitionHandle, int maxSize)\n+                        {\n+                            return completedFuture(new ConnectorSplitBatch(\n+                                    nCopies(maxSize, new EmptySplit(new CatalogName(\"test\"))),\n+                                    isFinished()));\n+                        }\n+\n+                        @Override\n+                        public void close()\n+                        {\n+                        }\n+\n+                        @Override\n+                        public boolean isFinished()\n+                        {\n+                            if (dynamicFilter.get().equals(expectedDynamicFilter.get())) {\n+                                // if we received expected dynamic filter then we are done\n+                                return true;\n+                            }\n+                            else if (Duration.nanosSince(start).compareTo(scanDuration) > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce4f1927049a95e515cb7d27859a0e5199b0ebcf"}, "originalPosition": 261}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3NDYyOA==", "bodyText": "I think this should ok since Duration. nanosSince performs subtraction between the nano time recordings and creates a duration interval from it. I see multiple examples of this way of comparing else where in the code\nE.g.: https://github.com/prestosql/presto/blob/f66f62e2cdc752cd30d0acb2040a9a7ec1bde3c0/presto-main/src/main/java/io/prestosql/failuredetector/HeartbeatFailureDetector.java#L358", "url": "https://github.com/trinodb/trino/pull/4101#discussion_r443474628", "createdAt": "2020-06-22T10:50:21Z", "author": {"login": "raunaqmorarka"}, "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.Duration;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.plugin.tpch.TpchPlugin;\n+import io.prestosql.spi.Plugin;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.Connector;\n+import io.prestosql.spi.connector.ConnectorContext;\n+import io.prestosql.spi.connector.ConnectorFactory;\n+import io.prestosql.spi.connector.ConnectorHandleResolver;\n+import io.prestosql.spi.connector.ConnectorMetadata;\n+import io.prestosql.spi.connector.ConnectorPageSinkProvider;\n+import io.prestosql.spi.connector.ConnectorPageSource;\n+import io.prestosql.spi.connector.ConnectorPageSourceProvider;\n+import io.prestosql.spi.connector.ConnectorPartitionHandle;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorSplit;\n+import io.prestosql.spi.connector.ConnectorSplitManager;\n+import io.prestosql.spi.connector.ConnectorSplitSource;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.ConnectorTransactionHandle;\n+import io.prestosql.spi.connector.EmptyPageSource;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.transaction.IsolationLevel;\n+import io.prestosql.split.EmptySplit;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.TestingHandleResolver;\n+import io.prestosql.testing.TestingMetadata;\n+import io.prestosql.testing.TestingPageSinkProvider;\n+import io.prestosql.testing.TestingTransactionHandle;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.testing.TestingMetadata.TestingColumnHandle;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+import static java.lang.String.format;\n+import static java.util.Collections.nCopies;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.CompletableFuture.completedFuture;\n+\n+@Test(singleThreaded = true)\n+public class TestCoordinatorDynamicFiltering\n+        extends AbstractTestQueryFramework\n+{\n+    private static final TestingColumnHandle suppKeyHandle = new TestingColumnHandle(\"suppkey\", 2, BIGINT);\n+    private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter = new AtomicReference<>(TupleDomain.all());\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(\"test\")\n+                .setSchema(\"default\")\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name())\n+                .build();\n+        return DistributedQueryRunner.builder(session).build();\n+    }\n+\n+    @BeforeClass\n+    public void setUp()\n+    {\n+        getQueryRunner().installPlugin(new TestPlugin(expectedDynamicFilter));\n+        getQueryRunner().installPlugin(new TpchPlugin());\n+        getQueryRunner().createCatalog(\"test\", \"test\", ImmutableMap.of());\n+        getQueryRunner().createCatalog(\"tpch\", \"tpch\", ImmutableMap.of());\n+        computeActual(\"CREATE TABLE lineitem AS SELECT * FROM tpch.tiny.lineitem\");\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void afterMethod()\n+    {\n+        expectedDynamicFilter.set(TupleDomain.all());\n+    }\n+\n+    @Test\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\",\n+                TupleDomain.none());\n+    }\n+\n+    @Test\n+    public void testJoinWithSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'Supplier#000000001'\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        suppKeyHandle,\n+                        singleValue(BIGINT, 1L))));\n+    }\n+\n+    @Test\n+    public void testJoinWithNonSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        suppKeyHandle,\n+                        Domain.create(ValueSet.ofRanges(Range.range(BIGINT, 1L, true, 100L, true)), false))));\n+    }\n+\n+    @Test\n+    public void testJoinWithMultipleDynamicFiltersOnProbe()\n+    {\n+        // supplier names Supplier#000000001 and Supplier#000000002 match suppkey 1 and 2\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM (\" +\n+                        \"SELECT supplier.suppkey FROM \" +\n+                            \"lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name IN ('Supplier#000000001', 'Supplier#000000002')\" +\n+                        \") t JOIN tpch.tiny.partsupp ON t.suppkey = partsupp.suppkey AND partsupp.suppkey IN (2, 3)\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        suppKeyHandle,\n+                        singleValue(BIGINT, 2L))));\n+    }\n+\n+    private void assertQueryDynamicFilters(@Language(\"SQL\") String query, TupleDomain<ColumnHandle> expectedTupleDomain)\n+    {\n+        expectedDynamicFilter.set(expectedTupleDomain);\n+        computeActual(query);\n+    }\n+\n+    private static class TestPlugin\n+            implements Plugin\n+    {\n+        private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter;\n+\n+        private TestPlugin(AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter)\n+        {\n+            this.expectedDynamicFilter = requireNonNull(expectedDynamicFilter, \"expectedDynamicFilter is null\");\n+        }\n+\n+        @Override\n+        public Iterable<ConnectorFactory> getConnectorFactories()\n+        {\n+            return ImmutableList.of(new ConnectorFactory()\n+            {\n+                private final ConnectorMetadata metadata = new TestingMetadata();\n+\n+                @Override\n+                public String getName()\n+                {\n+                    return \"test\";\n+                }\n+\n+                @Override\n+                public ConnectorHandleResolver getHandleResolver()\n+                {\n+                    return new TestingHandleResolver();\n+                }\n+\n+                @Override\n+                public Connector create(String catalogName, Map<String, String> config, ConnectorContext context)\n+                {\n+                    return new TestConnector(metadata, Duration.valueOf(\"10s\"), expectedDynamicFilter);\n+                }\n+            });\n+        }\n+    }\n+\n+    private static class TestConnector\n+            implements Connector\n+    {\n+        private final ConnectorMetadata metadata;\n+        private final Duration scanDuration;\n+        private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter;\n+\n+        private TestConnector(ConnectorMetadata metadata, Duration scanDuration, AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter)\n+        {\n+            this.metadata = requireNonNull(metadata, \"metadata is null\");\n+            this.scanDuration = requireNonNull(scanDuration, \"scanDuration is null\");\n+            this.expectedDynamicFilter = requireNonNull(expectedDynamicFilter, \"expectedDynamicFilter is null\");\n+        }\n+\n+        @Override\n+        public ConnectorTransactionHandle beginTransaction(IsolationLevel isolationLevel, boolean readOnly)\n+        {\n+            return TestingTransactionHandle.create();\n+        }\n+\n+        @Override\n+        public ConnectorMetadata getMetadata(ConnectorTransactionHandle transactionHandle)\n+        {\n+            return metadata;\n+        }\n+\n+        @Override\n+        public ConnectorSplitManager getSplitManager()\n+        {\n+            return new ConnectorSplitManager()\n+            {\n+                @Override\n+                public ConnectorSplitSource getSplits(\n+                        ConnectorTransactionHandle transaction,\n+                        ConnectorSession session,\n+                        ConnectorTableHandle table,\n+                        SplitSchedulingStrategy splitSchedulingStrategy,\n+                        Supplier<TupleDomain<ColumnHandle>> dynamicFilter)\n+                {\n+                    long start = System.nanoTime();\n+                    return new ConnectorSplitSource()\n+                    {\n+                        @Override\n+                        public CompletableFuture<ConnectorSplitBatch> getNextBatch(ConnectorPartitionHandle partitionHandle, int maxSize)\n+                        {\n+                            return completedFuture(new ConnectorSplitBatch(\n+                                    nCopies(maxSize, new EmptySplit(new CatalogName(\"test\"))),\n+                                    isFinished()));\n+                        }\n+\n+                        @Override\n+                        public void close()\n+                        {\n+                        }\n+\n+                        @Override\n+                        public boolean isFinished()\n+                        {\n+                            if (dynamicFilter.get().equals(expectedDynamicFilter.get())) {\n+                                // if we received expected dynamic filter then we are done\n+                                return true;\n+                            }\n+                            else if (Duration.nanosSince(start).compareTo(scanDuration) > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2MzYxMA=="}, "originalCommit": {"oid": "ce4f1927049a95e515cb7d27859a0e5199b0ebcf"}, "originalPosition": 261}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4NjI4MQ==", "bodyText": "Ah, Right. Thanks!", "url": "https://github.com/trinodb/trino/pull/4101#discussion_r443486281", "createdAt": "2020-06-22T11:14:20Z", "author": {"login": "sopel39"}, "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.Duration;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.plugin.tpch.TpchPlugin;\n+import io.prestosql.spi.Plugin;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.Connector;\n+import io.prestosql.spi.connector.ConnectorContext;\n+import io.prestosql.spi.connector.ConnectorFactory;\n+import io.prestosql.spi.connector.ConnectorHandleResolver;\n+import io.prestosql.spi.connector.ConnectorMetadata;\n+import io.prestosql.spi.connector.ConnectorPageSinkProvider;\n+import io.prestosql.spi.connector.ConnectorPageSource;\n+import io.prestosql.spi.connector.ConnectorPageSourceProvider;\n+import io.prestosql.spi.connector.ConnectorPartitionHandle;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorSplit;\n+import io.prestosql.spi.connector.ConnectorSplitManager;\n+import io.prestosql.spi.connector.ConnectorSplitSource;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.ConnectorTransactionHandle;\n+import io.prestosql.spi.connector.EmptyPageSource;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.transaction.IsolationLevel;\n+import io.prestosql.split.EmptySplit;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.TestingHandleResolver;\n+import io.prestosql.testing.TestingMetadata;\n+import io.prestosql.testing.TestingPageSinkProvider;\n+import io.prestosql.testing.TestingTransactionHandle;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.testing.TestingMetadata.TestingColumnHandle;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+import static java.lang.String.format;\n+import static java.util.Collections.nCopies;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.CompletableFuture.completedFuture;\n+\n+@Test(singleThreaded = true)\n+public class TestCoordinatorDynamicFiltering\n+        extends AbstractTestQueryFramework\n+{\n+    private static final TestingColumnHandle suppKeyHandle = new TestingColumnHandle(\"suppkey\", 2, BIGINT);\n+    private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter = new AtomicReference<>(TupleDomain.all());\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(\"test\")\n+                .setSchema(\"default\")\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name())\n+                .build();\n+        return DistributedQueryRunner.builder(session).build();\n+    }\n+\n+    @BeforeClass\n+    public void setUp()\n+    {\n+        getQueryRunner().installPlugin(new TestPlugin(expectedDynamicFilter));\n+        getQueryRunner().installPlugin(new TpchPlugin());\n+        getQueryRunner().createCatalog(\"test\", \"test\", ImmutableMap.of());\n+        getQueryRunner().createCatalog(\"tpch\", \"tpch\", ImmutableMap.of());\n+        computeActual(\"CREATE TABLE lineitem AS SELECT * FROM tpch.tiny.lineitem\");\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void afterMethod()\n+    {\n+        expectedDynamicFilter.set(TupleDomain.all());\n+    }\n+\n+    @Test\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\",\n+                TupleDomain.none());\n+    }\n+\n+    @Test\n+    public void testJoinWithSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'Supplier#000000001'\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        suppKeyHandle,\n+                        singleValue(BIGINT, 1L))));\n+    }\n+\n+    @Test\n+    public void testJoinWithNonSelectiveBuildSide()\n+    {\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        suppKeyHandle,\n+                        Domain.create(ValueSet.ofRanges(Range.range(BIGINT, 1L, true, 100L, true)), false))));\n+    }\n+\n+    @Test\n+    public void testJoinWithMultipleDynamicFiltersOnProbe()\n+    {\n+        // supplier names Supplier#000000001 and Supplier#000000002 match suppkey 1 and 2\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM (\" +\n+                        \"SELECT supplier.suppkey FROM \" +\n+                            \"lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name IN ('Supplier#000000001', 'Supplier#000000002')\" +\n+                        \") t JOIN tpch.tiny.partsupp ON t.suppkey = partsupp.suppkey AND partsupp.suppkey IN (2, 3)\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        suppKeyHandle,\n+                        singleValue(BIGINT, 2L))));\n+    }\n+\n+    private void assertQueryDynamicFilters(@Language(\"SQL\") String query, TupleDomain<ColumnHandle> expectedTupleDomain)\n+    {\n+        expectedDynamicFilter.set(expectedTupleDomain);\n+        computeActual(query);\n+    }\n+\n+    private static class TestPlugin\n+            implements Plugin\n+    {\n+        private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter;\n+\n+        private TestPlugin(AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter)\n+        {\n+            this.expectedDynamicFilter = requireNonNull(expectedDynamicFilter, \"expectedDynamicFilter is null\");\n+        }\n+\n+        @Override\n+        public Iterable<ConnectorFactory> getConnectorFactories()\n+        {\n+            return ImmutableList.of(new ConnectorFactory()\n+            {\n+                private final ConnectorMetadata metadata = new TestingMetadata();\n+\n+                @Override\n+                public String getName()\n+                {\n+                    return \"test\";\n+                }\n+\n+                @Override\n+                public ConnectorHandleResolver getHandleResolver()\n+                {\n+                    return new TestingHandleResolver();\n+                }\n+\n+                @Override\n+                public Connector create(String catalogName, Map<String, String> config, ConnectorContext context)\n+                {\n+                    return new TestConnector(metadata, Duration.valueOf(\"10s\"), expectedDynamicFilter);\n+                }\n+            });\n+        }\n+    }\n+\n+    private static class TestConnector\n+            implements Connector\n+    {\n+        private final ConnectorMetadata metadata;\n+        private final Duration scanDuration;\n+        private final AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter;\n+\n+        private TestConnector(ConnectorMetadata metadata, Duration scanDuration, AtomicReference<TupleDomain<ColumnHandle>> expectedDynamicFilter)\n+        {\n+            this.metadata = requireNonNull(metadata, \"metadata is null\");\n+            this.scanDuration = requireNonNull(scanDuration, \"scanDuration is null\");\n+            this.expectedDynamicFilter = requireNonNull(expectedDynamicFilter, \"expectedDynamicFilter is null\");\n+        }\n+\n+        @Override\n+        public ConnectorTransactionHandle beginTransaction(IsolationLevel isolationLevel, boolean readOnly)\n+        {\n+            return TestingTransactionHandle.create();\n+        }\n+\n+        @Override\n+        public ConnectorMetadata getMetadata(ConnectorTransactionHandle transactionHandle)\n+        {\n+            return metadata;\n+        }\n+\n+        @Override\n+        public ConnectorSplitManager getSplitManager()\n+        {\n+            return new ConnectorSplitManager()\n+            {\n+                @Override\n+                public ConnectorSplitSource getSplits(\n+                        ConnectorTransactionHandle transaction,\n+                        ConnectorSession session,\n+                        ConnectorTableHandle table,\n+                        SplitSchedulingStrategy splitSchedulingStrategy,\n+                        Supplier<TupleDomain<ColumnHandle>> dynamicFilter)\n+                {\n+                    long start = System.nanoTime();\n+                    return new ConnectorSplitSource()\n+                    {\n+                        @Override\n+                        public CompletableFuture<ConnectorSplitBatch> getNextBatch(ConnectorPartitionHandle partitionHandle, int maxSize)\n+                        {\n+                            return completedFuture(new ConnectorSplitBatch(\n+                                    nCopies(maxSize, new EmptySplit(new CatalogName(\"test\"))),\n+                                    isFinished()));\n+                        }\n+\n+                        @Override\n+                        public void close()\n+                        {\n+                        }\n+\n+                        @Override\n+                        public boolean isFinished()\n+                        {\n+                            if (dynamicFilter.get().equals(expectedDynamicFilter.get())) {\n+                                // if we received expected dynamic filter then we are done\n+                                return true;\n+                            }\n+                            else if (Duration.nanosSince(start).compareTo(scanDuration) > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2MzYxMA=="}, "originalCommit": {"oid": "ce4f1927049a95e515cb7d27859a0e5199b0ebcf"}, "originalPosition": 261}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4133, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}