{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1NjYwNTI2", "number": 3283, "title": "Support syntax and AST building for Materialized View Commands ...", "bodyText": "... like CREATE MATERIALIZED VIEW, REFRESH MATERIALIZED VIEW\nand DROP MATERIALIZED VIEW.\nMuch like a logical view, a materialized view has a SQL query associated with it.\nUnlike logical view, it stores data corresponding to the SQL query.\nThis commit adds support to parse the materialized view related commands and\nbuild an AST for those commands. This commit does not include connector-side\nimplementation of materialized views.\nMaterialized views are modeled as an extension of logical views with additional\nproperties such as partitioning.\nGiven that materialized views can be seen as a combination of a view and a table,\naccess control for a CREATE MATERIALIZED VIEW command is a combination of access\nchecks for CREATE TABLE and CREATE VIEW commands.\nSimilarly, a REFRESH MATERIALIZED VIEW command is a combination of DELETE and INSERT\noperations and access checks for this command is a combination of access checks\nfor DELETE and INSERT.\nLastly, a DROP MATERIALIZED VIEW access check is a combination of DROP TABLE and\nDROP VIEW command.", "createdAt": "2020-03-30T13:43:16Z", "url": "https://github.com/trinodb/trino/pull/3283", "merged": true, "mergeCommit": {"oid": "88116a4a3fda92f0caa725d9b1a83e9b22f7dcf4"}, "closed": true, "closedAt": "2020-09-01T01:46:15Z", "author": {"login": "anjalinorwood"}, "timelineItems": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABce8yqVgFqTQwNzQ0MDI5MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdEZFQZABqjM3MTE2MTkwODQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NDQwMjkx", "url": "https://github.com/trinodb/trino/pull/3283#pullrequestreview-407440291", "createdAt": "2020-05-07T12:53:26Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMjo1MzoyNlrOGR9FSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMjo1MzoyNlrOGR9FSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ3OTc1NA==", "bodyText": "Refresh design is outlined here: https://docs.google.com/document/d/1GYIyEhJQ3ngvOPmJYWU-8zwDQRCMXkBDZaSn3c3MF0k/edit# , please ignore the open question here.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r421479754", "createdAt": "2020-05-07T12:53:26Z", "author": {"login": "anjalinorwood"}, "path": "presto-main/src/main/java/io/prestosql/execution/RefreshMaterializedViewTask.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.security.AccessControl;\n+import io.prestosql.sql.analyzer.FeaturesConfig;\n+import io.prestosql.sql.parser.SqlParser;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.RefreshMaterializedView;\n+import io.prestosql.transaction.TransactionManager;\n+\n+import javax.inject.Inject;\n+\n+import java.util.List;\n+\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n+import static io.prestosql.metadata.MetadataUtil.createQualifiedObjectName;\n+import static java.util.Objects.requireNonNull;\n+\n+public class RefreshMaterializedViewTask\n+        implements DataDefinitionTask<RefreshMaterializedView>\n+{\n+    private final SqlParser sqlParser;\n+\n+    @Inject\n+    public RefreshMaterializedViewTask(SqlParser sqlParser, FeaturesConfig featuresConfig)\n+    {\n+        this.sqlParser = requireNonNull(sqlParser, \"sqlParser is null\");\n+        requireNonNull(featuresConfig, \"featuresConfig is null\");\n+    }\n+\n+    @Override\n+    public String getName()\n+    {\n+        return \"REFRESH MATERIALIZED VIEW\";\n+    }\n+\n+    @Override\n+    public String explain(RefreshMaterializedView statement, List<Expression> parameters)\n+    {\n+        return \"REFRESH MATERIALIZED VIEW \" + statement.getName();\n+    }\n+\n+    @Override\n+    public ListenableFuture<?> execute(RefreshMaterializedView statement, TransactionManager transactionManager, Metadata metadata, AccessControl accessControl, QueryStateMachine stateMachine, List<Expression> parameters)\n+    {\n+        Session session = stateMachine.getSession();\n+        QualifiedObjectName name = createQualifiedObjectName(session, statement, statement.getName());\n+\n+        accessControl.checkCanDeleteFromTable(session.toSecurityContext(), name);\n+        accessControl.checkCanInsertIntoTable(session.toSecurityContext(), name);\n+\n+        // OPEN QUESTION", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 69}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NjgxMDg2", "url": "https://github.com/trinodb/trino/pull/3283#pullrequestreview-425681086", "createdAt": "2020-06-05T23:41:09Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0MTowOVrOGgAA8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0MTowOVrOGgAA8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNzg1OQ==", "bodyText": "There's a major revamp of the planner on the way, so you may want to rebase on that change to avoid conflicts later on: #3600", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r436207859", "createdAt": "2020-06-05T23:41:09Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LogicalPlanner.java", "diffHunk": "@@ -409,6 +414,80 @@ private RelationPlan createInsertPlan(Analysis analysis, Insert insertStatement)\n                 statisticsMetadata);\n     }\n \n+    private RelationPlan createRefreshMVPlan(Analysis analysis, RefreshMV refreshMVStatement)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NDk2NTUx", "url": "https://github.com/trinodb/trino/pull/3283#pullrequestreview-428496551", "createdAt": "2020-06-10T23:31:41Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzozMTo0MlrOGiJngQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzo1NTo1NFrOGiKC2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MjMzNw==", "bodyText": "Place each argument on a separate line when splitting across multiple lines.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r438462337", "createdAt": "2020-06-10T23:31:42Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/execution/CreateMaterializedViewTask.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.security.AccessControl;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorMaterializedViewDefinition;\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.Analyzer;\n+import io.prestosql.sql.analyzer.FeaturesConfig;\n+import io.prestosql.sql.parser.SqlParser;\n+import io.prestosql.sql.tree.CreateMaterializedView;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.NodeRef;\n+import io.prestosql.sql.tree.Parameter;\n+import io.prestosql.sql.tree.Statement;\n+import io.prestosql.transaction.TransactionManager;\n+\n+import javax.inject.Inject;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n+import static io.prestosql.metadata.MetadataUtil.createQualifiedObjectName;\n+import static io.prestosql.spi.StandardErrorCode.NOT_FOUND;\n+import static io.prestosql.spi.connector.ConnectorViewDefinition.ViewColumn;\n+import static io.prestosql.sql.NodeUtils.mapFromProperties;\n+import static io.prestosql.sql.ParameterUtils.parameterExtractor;\n+import static io.prestosql.sql.SqlFormatterUtil.getFormattedSql;\n+import static java.util.Objects.requireNonNull;\n+\n+public class CreateMaterializedViewTask\n+        implements DataDefinitionTask<CreateMaterializedView>\n+{\n+    private final SqlParser sqlParser;\n+\n+    @Inject\n+    public CreateMaterializedViewTask(SqlParser sqlParser, FeaturesConfig featuresConfig)\n+    {\n+        this.sqlParser = requireNonNull(sqlParser, \"sqlParser is null\");\n+        requireNonNull(featuresConfig, \"featuresConfig is null\");\n+    }\n+\n+    @Override\n+    public String getName()\n+    {\n+        return \"CREATE MATERIALIZED VIEW\";\n+    }\n+\n+    @Override\n+    public String explain(CreateMaterializedView statement, List<Expression> parameters)\n+    {\n+        return \"CREATE MATERIALIZED VIEW \" + statement.getName();\n+    }\n+\n+    @Override\n+    public ListenableFuture<?> execute(CreateMaterializedView statement, TransactionManager transactionManager, Metadata metadata, AccessControl accessControl, QueryStateMachine stateMachine, List<Expression> parameters)\n+    {\n+        Session session = stateMachine.getSession();\n+        QualifiedObjectName name = createQualifiedObjectName(session, statement, statement.getName());\n+        Map<NodeRef<Parameter>, Expression> parameterLookup = parameterExtractor(statement, parameters);\n+\n+        accessControl.checkCanCreateView(session.toSecurityContext(), name);\n+        accessControl.checkCanCreateTable(session.toSecurityContext(), name);\n+\n+        String sql = getFormattedSql(statement.getQuery(), sqlParser);\n+\n+        Analysis analysis = analyzeStatement(statement, session, metadata, accessControl, parameters, parameterLookup, stateMachine.getWarningCollector(), sql);\n+\n+        List<ViewColumn> columns = analysis.getOutputDescriptor(statement.getQuery())\n+                .getVisibleFields().stream()\n+                .map(field -> new ViewColumn(field.getName().get(), field.getType().getTypeId()))\n+                .collect(toImmutableList());\n+\n+        Optional<String> owner = Optional.of(session.getUser());\n+\n+        CatalogName catalogName = metadata.getCatalogHandle(session, name.getCatalogName())\n+                .orElseThrow(() -> new PrestoException(NOT_FOUND, \"Catalog does not exist: \" + name.getCatalogName()));\n+\n+        Map<String, Expression> sqlProperties = mapFromProperties(statement.getProperties());\n+        Map<String, Object> properties = metadata.getTablePropertyManager().getProperties(\n+                catalogName,\n+                name.getCatalogName(),\n+                sqlProperties,\n+                session,\n+                metadata,\n+                accessControl,\n+                parameterLookup);\n+\n+        Map<String, Object> finalProperties = combineProperties(sqlProperties.keySet(), properties);\n+\n+        ConnectorMaterializedViewDefinition definition = new ConnectorMaterializedViewDefinition(\n+                sql,\n+                null,\n+                session.getCatalog(),\n+                session.getSchema(),\n+                columns,\n+                owner,\n+                false,\n+                statement.getComment(),\n+                finalProperties);\n+\n+        metadata.createMaterializedView(session, name, definition, statement.isReplace(), statement.isNotExists());\n+\n+        return immediateFuture(null);\n+    }\n+\n+    private Analysis analyzeStatement(Statement statement, Session session, Metadata metadata, AccessControl accessControl, List<Expression> parameters,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2NTQ4Nw==", "bodyText": "This method is a no-op. The !finalProperties.containsKey(entry.getKey()) will cause every entry from defaultProperties to be copied to the result map. It's equivalent to just returning the input map.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r438465487", "createdAt": "2020-06-10T23:43:02Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/execution/CreateMaterializedViewTask.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.security.AccessControl;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorMaterializedViewDefinition;\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.Analyzer;\n+import io.prestosql.sql.analyzer.FeaturesConfig;\n+import io.prestosql.sql.parser.SqlParser;\n+import io.prestosql.sql.tree.CreateMaterializedView;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.NodeRef;\n+import io.prestosql.sql.tree.Parameter;\n+import io.prestosql.sql.tree.Statement;\n+import io.prestosql.transaction.TransactionManager;\n+\n+import javax.inject.Inject;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n+import static io.prestosql.metadata.MetadataUtil.createQualifiedObjectName;\n+import static io.prestosql.spi.StandardErrorCode.NOT_FOUND;\n+import static io.prestosql.spi.connector.ConnectorViewDefinition.ViewColumn;\n+import static io.prestosql.sql.NodeUtils.mapFromProperties;\n+import static io.prestosql.sql.ParameterUtils.parameterExtractor;\n+import static io.prestosql.sql.SqlFormatterUtil.getFormattedSql;\n+import static java.util.Objects.requireNonNull;\n+\n+public class CreateMaterializedViewTask\n+        implements DataDefinitionTask<CreateMaterializedView>\n+{\n+    private final SqlParser sqlParser;\n+\n+    @Inject\n+    public CreateMaterializedViewTask(SqlParser sqlParser, FeaturesConfig featuresConfig)\n+    {\n+        this.sqlParser = requireNonNull(sqlParser, \"sqlParser is null\");\n+        requireNonNull(featuresConfig, \"featuresConfig is null\");\n+    }\n+\n+    @Override\n+    public String getName()\n+    {\n+        return \"CREATE MATERIALIZED VIEW\";\n+    }\n+\n+    @Override\n+    public String explain(CreateMaterializedView statement, List<Expression> parameters)\n+    {\n+        return \"CREATE MATERIALIZED VIEW \" + statement.getName();\n+    }\n+\n+    @Override\n+    public ListenableFuture<?> execute(CreateMaterializedView statement, TransactionManager transactionManager, Metadata metadata, AccessControl accessControl, QueryStateMachine stateMachine, List<Expression> parameters)\n+    {\n+        Session session = stateMachine.getSession();\n+        QualifiedObjectName name = createQualifiedObjectName(session, statement, statement.getName());\n+        Map<NodeRef<Parameter>, Expression> parameterLookup = parameterExtractor(statement, parameters);\n+\n+        accessControl.checkCanCreateView(session.toSecurityContext(), name);\n+        accessControl.checkCanCreateTable(session.toSecurityContext(), name);\n+\n+        String sql = getFormattedSql(statement.getQuery(), sqlParser);\n+\n+        Analysis analysis = analyzeStatement(statement, session, metadata, accessControl, parameters, parameterLookup, stateMachine.getWarningCollector(), sql);\n+\n+        List<ViewColumn> columns = analysis.getOutputDescriptor(statement.getQuery())\n+                .getVisibleFields().stream()\n+                .map(field -> new ViewColumn(field.getName().get(), field.getType().getTypeId()))\n+                .collect(toImmutableList());\n+\n+        Optional<String> owner = Optional.of(session.getUser());\n+\n+        CatalogName catalogName = metadata.getCatalogHandle(session, name.getCatalogName())\n+                .orElseThrow(() -> new PrestoException(NOT_FOUND, \"Catalog does not exist: \" + name.getCatalogName()));\n+\n+        Map<String, Expression> sqlProperties = mapFromProperties(statement.getProperties());\n+        Map<String, Object> properties = metadata.getTablePropertyManager().getProperties(\n+                catalogName,\n+                name.getCatalogName(),\n+                sqlProperties,\n+                session,\n+                metadata,\n+                accessControl,\n+                parameterLookup);\n+\n+        Map<String, Object> finalProperties = combineProperties(sqlProperties.keySet(), properties);\n+\n+        ConnectorMaterializedViewDefinition definition = new ConnectorMaterializedViewDefinition(\n+                sql,\n+                null,\n+                session.getCatalog(),\n+                session.getSchema(),\n+                columns,\n+                owner,\n+                false,\n+                statement.getComment(),\n+                finalProperties);\n+\n+        metadata.createMaterializedView(session, name, definition, statement.isReplace(), statement.isNotExists());\n+\n+        return immediateFuture(null);\n+    }\n+\n+    private Analysis analyzeStatement(Statement statement, Session session, Metadata metadata, AccessControl accessControl, List<Expression> parameters,\n+        Map<NodeRef<Parameter>, Expression> parameterLookup, WarningCollector warningCollector, String query)\n+    {\n+        Analyzer analyzer = new Analyzer(session, metadata, sqlParser, accessControl, Optional.empty(), parameters, parameterLookup, warningCollector);\n+        return analyzer.analyze(statement);\n+    }\n+\n+    private static Map<String, Object> combineProperties(Set<String> specifiedPropertyKeys, Map<String, Object> defaultProperties)\n+    {\n+        Map<String, Object> finalProperties = new HashMap<>();\n+        for (Map.Entry<String, Object> entry : defaultProperties.entrySet()) {\n+            if (specifiedPropertyKeys.contains(entry.getKey()) || !finalProperties.containsKey(entry.getKey())) {\n+                finalProperties.put(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        return finalProperties;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2NTgyMA==", "bodyText": "Why both?", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r438465820", "createdAt": "2020-06-10T23:44:08Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/execution/CreateMaterializedViewTask.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.security.AccessControl;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorMaterializedViewDefinition;\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.Analyzer;\n+import io.prestosql.sql.analyzer.FeaturesConfig;\n+import io.prestosql.sql.parser.SqlParser;\n+import io.prestosql.sql.tree.CreateMaterializedView;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.NodeRef;\n+import io.prestosql.sql.tree.Parameter;\n+import io.prestosql.sql.tree.Statement;\n+import io.prestosql.transaction.TransactionManager;\n+\n+import javax.inject.Inject;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n+import static io.prestosql.metadata.MetadataUtil.createQualifiedObjectName;\n+import static io.prestosql.spi.StandardErrorCode.NOT_FOUND;\n+import static io.prestosql.spi.connector.ConnectorViewDefinition.ViewColumn;\n+import static io.prestosql.sql.NodeUtils.mapFromProperties;\n+import static io.prestosql.sql.ParameterUtils.parameterExtractor;\n+import static io.prestosql.sql.SqlFormatterUtil.getFormattedSql;\n+import static java.util.Objects.requireNonNull;\n+\n+public class CreateMaterializedViewTask\n+        implements DataDefinitionTask<CreateMaterializedView>\n+{\n+    private final SqlParser sqlParser;\n+\n+    @Inject\n+    public CreateMaterializedViewTask(SqlParser sqlParser, FeaturesConfig featuresConfig)\n+    {\n+        this.sqlParser = requireNonNull(sqlParser, \"sqlParser is null\");\n+        requireNonNull(featuresConfig, \"featuresConfig is null\");\n+    }\n+\n+    @Override\n+    public String getName()\n+    {\n+        return \"CREATE MATERIALIZED VIEW\";\n+    }\n+\n+    @Override\n+    public String explain(CreateMaterializedView statement, List<Expression> parameters)\n+    {\n+        return \"CREATE MATERIALIZED VIEW \" + statement.getName();\n+    }\n+\n+    @Override\n+    public ListenableFuture<?> execute(CreateMaterializedView statement, TransactionManager transactionManager, Metadata metadata, AccessControl accessControl, QueryStateMachine stateMachine, List<Expression> parameters)\n+    {\n+        Session session = stateMachine.getSession();\n+        QualifiedObjectName name = createQualifiedObjectName(session, statement, statement.getName());\n+        Map<NodeRef<Parameter>, Expression> parameterLookup = parameterExtractor(statement, parameters);\n+\n+        accessControl.checkCanCreateView(session.toSecurityContext(), name);\n+        accessControl.checkCanCreateTable(session.toSecurityContext(), name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2NjM4NA==", "bodyText": "No need to wrap arguments here.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r438466384", "createdAt": "2020-06-10T23:46:03Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/Metadata.java", "diffHunk": "@@ -508,4 +509,25 @@ default ResolvedFunction getCoercion(Type fromType, Type toType)\n     ColumnPropertyManager getColumnPropertyManager();\n \n     AnalyzePropertyManager getAnalyzePropertyManager();\n+\n+    /**\n+     * Creates the specified materialized view with the specified view definition.\n+     */\n+    void createMaterializedView(Session session, QualifiedObjectName viewName, ConnectorMaterializedViewDefinition definition, boolean replace,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2NjUxNA==", "bodyText": "No need to wrap arguments here", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r438466514", "createdAt": "2020-06-10T23:46:24Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java", "diffHunk": "@@ -1054,6 +1055,46 @@ public void dropView(Session session, QualifiedObjectName viewName)\n         metadata.dropView(session.toConnectorSession(catalogName), viewName.asSchemaTableName());\n     }\n \n+    @Override\n+    public void createMaterializedView(Session session, QualifiedObjectName viewName, ConnectorMaterializedViewDefinition definition, boolean replace,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2NzU1Ng==", "bodyText": "Also, permissions are being checked in the analyzer, as well, so this is redundant", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r438467556", "createdAt": "2020-06-10T23:50:04Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/execution/CreateMaterializedViewTask.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.security.AccessControl;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorMaterializedViewDefinition;\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.Analyzer;\n+import io.prestosql.sql.analyzer.FeaturesConfig;\n+import io.prestosql.sql.parser.SqlParser;\n+import io.prestosql.sql.tree.CreateMaterializedView;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.NodeRef;\n+import io.prestosql.sql.tree.Parameter;\n+import io.prestosql.sql.tree.Statement;\n+import io.prestosql.transaction.TransactionManager;\n+\n+import javax.inject.Inject;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n+import static io.prestosql.metadata.MetadataUtil.createQualifiedObjectName;\n+import static io.prestosql.spi.StandardErrorCode.NOT_FOUND;\n+import static io.prestosql.spi.connector.ConnectorViewDefinition.ViewColumn;\n+import static io.prestosql.sql.NodeUtils.mapFromProperties;\n+import static io.prestosql.sql.ParameterUtils.parameterExtractor;\n+import static io.prestosql.sql.SqlFormatterUtil.getFormattedSql;\n+import static java.util.Objects.requireNonNull;\n+\n+public class CreateMaterializedViewTask\n+        implements DataDefinitionTask<CreateMaterializedView>\n+{\n+    private final SqlParser sqlParser;\n+\n+    @Inject\n+    public CreateMaterializedViewTask(SqlParser sqlParser, FeaturesConfig featuresConfig)\n+    {\n+        this.sqlParser = requireNonNull(sqlParser, \"sqlParser is null\");\n+        requireNonNull(featuresConfig, \"featuresConfig is null\");\n+    }\n+\n+    @Override\n+    public String getName()\n+    {\n+        return \"CREATE MATERIALIZED VIEW\";\n+    }\n+\n+    @Override\n+    public String explain(CreateMaterializedView statement, List<Expression> parameters)\n+    {\n+        return \"CREATE MATERIALIZED VIEW \" + statement.getName();\n+    }\n+\n+    @Override\n+    public ListenableFuture<?> execute(CreateMaterializedView statement, TransactionManager transactionManager, Metadata metadata, AccessControl accessControl, QueryStateMachine stateMachine, List<Expression> parameters)\n+    {\n+        Session session = stateMachine.getSession();\n+        QualifiedObjectName name = createQualifiedObjectName(session, statement, statement.getName());\n+        Map<NodeRef<Parameter>, Expression> parameterLookup = parameterExtractor(statement, parameters);\n+\n+        accessControl.checkCanCreateView(session.toSecurityContext(), name);\n+        accessControl.checkCanCreateTable(session.toSecurityContext(), name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2NTgyMA=="}, "originalCommit": null, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2NzkyMw==", "bodyText": "No need to wrap arguments here", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r438467923", "createdAt": "2020-06-10T23:51:13Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/metadata/AbstractMockMetadata.java", "diffHunk": "@@ -710,4 +711,29 @@ public AnalyzePropertyManager getAnalyzePropertyManager()\n     {\n         return Optional.empty();\n     }\n+\n+    @Override\n+    public void createMaterializedView(Session session, QualifiedObjectName viewName, ConnectorMaterializedViewDefinition definition, boolean replace,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2ODE1MQ==", "bodyText": "SECURITY INVOKER doesn't make sense for materialized views. They need to run with DEFINER mode always, so let's just get rid of this", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r438468151", "createdAt": "2020-06-10T23:51:55Z", "author": {"login": "martint"}, "path": "presto-parser/src/main/antlr4/io/prestosql/sql/parser/SqlBase.g4", "diffHunk": "@@ -64,9 +64,17 @@ statement\n     | ALTER TABLE tableName=qualifiedName\n         ADD COLUMN column=columnDefinition                             #addColumn\n     | ANALYZE qualifiedName (WITH properties)?                         #analyze\n+    | CREATE (OR REPLACE)?  MATERIALIZED VIEW\n+        (IF NOT EXISTS)?\n+        qualifiedName\n+        (SECURITY (DEFINER | INVOKER))?", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2ODQyOQ==", "bodyText": "See comment above", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r438468429", "createdAt": "2020-06-10T23:52:46Z", "author": {"login": "martint"}, "path": "presto-parser/src/main/java/io/prestosql/sql/parser/AstBuilder.java", "diffHunk": "@@ -348,6 +352,57 @@ public Node visitCreateTable(SqlBaseParser.CreateTableContext context)\n                 comment);\n     }\n \n+    @Override\n+    public Node visitCreateMaterializedView(SqlBaseParser.CreateMaterializedViewContext context)\n+    {\n+        Optional<String> comment = Optional.empty();\n+        if (context.COMMENT() != null) {\n+            comment = Optional.of(((StringLiteral) visit(context.string())).getValue());\n+        }\n+\n+        List<Property> properties = ImmutableList.of();\n+        if (context.properties() != null) {\n+            properties = visit(context.properties().property(), Property.class);\n+        }\n+\n+        Optional<CreateMaterializedView.Security> security = Optional.empty();\n+        if (context.DEFINER() != null) {\n+            security = Optional.of(CreateMaterializedView.Security.DEFINER);\n+        }\n+        else if (context.INVOKER() != null) {\n+            security = Optional.of(CreateMaterializedView.Security.INVOKER);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2ODQ5Mg==", "bodyText": "Don't use final for local variables", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r438468492", "createdAt": "2020-06-10T23:53:02Z", "author": {"login": "martint"}, "path": "presto-parser/src/main/java/io/prestosql/sql/parser/AstBuilder.java", "diffHunk": "@@ -348,6 +352,57 @@ public Node visitCreateTable(SqlBaseParser.CreateTableContext context)\n                 comment);\n     }\n \n+    @Override\n+    public Node visitCreateMaterializedView(SqlBaseParser.CreateMaterializedViewContext context)\n+    {\n+        Optional<String> comment = Optional.empty();\n+        if (context.COMMENT() != null) {\n+            comment = Optional.of(((StringLiteral) visit(context.string())).getValue());\n+        }\n+\n+        List<Property> properties = ImmutableList.of();\n+        if (context.properties() != null) {\n+            properties = visit(context.properties().property(), Property.class);\n+        }\n+\n+        Optional<CreateMaterializedView.Security> security = Optional.empty();\n+        if (context.DEFINER() != null) {\n+            security = Optional.of(CreateMaterializedView.Security.DEFINER);\n+        }\n+        else if (context.INVOKER() != null) {\n+            security = Optional.of(CreateMaterializedView.Security.INVOKER);\n+        }\n+\n+        final Token start = context.query().start;\n+        final Interval interval = new Interval(start.getStartIndex(), context.stop.getStopIndex());\n+        final Optional<String> originalSql = Optional.of(start.getInputStream().getText(interval));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2ODc4MA==", "bodyText": "Place each argument on a separate line when splitting across multiple lines.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r438468780", "createdAt": "2020-06-10T23:53:58Z", "author": {"login": "martint"}, "path": "presto-parser/src/main/java/io/prestosql/sql/tree/CreateMaterializedView.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.tree;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static java.util.Objects.requireNonNull;\n+\n+public class CreateMaterializedView\n+        extends Statement\n+{\n+    public enum Security\n+    {\n+        INVOKER, DEFINER\n+    }\n+\n+    private final QualifiedName name;\n+    private final Query query;\n+    private final boolean replace;\n+    private final boolean notExists;\n+    private final List<Property> properties;\n+    private final Optional<String> comment;\n+    private final Optional<String> originalSql;\n+    private final Optional<CreateMaterializedView.Security> security;\n+\n+    public CreateMaterializedView(Optional<NodeLocation> location, QualifiedName name, Query query, boolean replace, boolean notExists,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2OTA1OA==", "bodyText": "Why is this being stored in textual form in this class?", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r438469058", "createdAt": "2020-06-10T23:54:59Z", "author": {"login": "martint"}, "path": "presto-parser/src/main/java/io/prestosql/sql/tree/CreateMaterializedView.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.tree;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static java.util.Objects.requireNonNull;\n+\n+public class CreateMaterializedView\n+        extends Statement\n+{\n+    public enum Security\n+    {\n+        INVOKER, DEFINER\n+    }\n+\n+    private final QualifiedName name;\n+    private final Query query;\n+    private final boolean replace;\n+    private final boolean notExists;\n+    private final List<Property> properties;\n+    private final Optional<String> comment;\n+    private final Optional<String> originalSql;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2OTMzOQ==", "bodyText": "No need to wrap arguments here", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r438469339", "createdAt": "2020-06-10T23:55:54Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -848,4 +848,38 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n      * <p>\n      */\n     default void validateScan(ConnectorSession session, ConnectorTableHandle handle) {}\n+\n+    /**\n+     * Create the specified materialized view. The view definition is intended to\n+     * be serialized by the connector for permanent storage.\n+     */\n+    default void createMaterializedView(ConnectorSession session, SchemaTableName viewName, ConnectorMaterializedViewDefinition definition, boolean replace,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 9}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwOTA5MzY5", "url": "https://github.com/trinodb/trino/pull/3283#pullrequestreview-430909369", "createdAt": "2020-06-15T18:55:17Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODo1NToxOFrOGj-rZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODo1NToxOFrOGj-rZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4MDI2MQ==", "bodyText": "Enhance the message to say:\n'writerTarget must be CreateTarget, InsertTarget or RefreshMVTarget'", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r440380261", "createdAt": "2020-06-15T18:55:18Z", "author": {"login": "anjalinorwood"}, "path": "presto-main/src/main/java/io/prestosql/operator/TableWriterOperator.java", "diffHunk": "@@ -89,7 +90,8 @@ public TableWriterOperatorFactory(\n             this.planNodeId = requireNonNull(planNodeId, \"planNodeId is null\");\n             this.columnChannels = requireNonNull(columnChannels, \"columnChannels is null\");\n             this.pageSinkManager = requireNonNull(pageSinkManager, \"pageSinkManager is null\");\n-            checkArgument(writerTarget instanceof CreateTarget || writerTarget instanceof InsertTarget, \"writerTarget must be CreateTarget or InsertTarget\");\n+            checkArgument(writerTarget instanceof CreateTarget || writerTarget instanceof InsertTarget || writerTarget instanceof TableWriterNode.RefreshMVTarget,\n+                    \"writerTarget must be CreateTarget or InsertTarget\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzM2OTU1", "url": "https://github.com/trinodb/trino/pull/3283#pullrequestreview-433736955", "createdAt": "2020-06-19T00:54:25Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMDo1NDoyNVrOGmEr4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMTowMDo1N1rOGmExqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU3NTg0Mg==", "bodyText": "That makes sense. We need to make sure the refresh actions execute with the permissions of the owner of the materialized view. We need to consider how that will work, if at all, for credential pass-through.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r442575842", "createdAt": "2020-06-19T00:54:25Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/execution/CreateMaterializedViewTask.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.security.AccessControl;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorMaterializedViewDefinition;\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.Analyzer;\n+import io.prestosql.sql.analyzer.FeaturesConfig;\n+import io.prestosql.sql.parser.SqlParser;\n+import io.prestosql.sql.tree.CreateMaterializedView;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.NodeRef;\n+import io.prestosql.sql.tree.Parameter;\n+import io.prestosql.sql.tree.Statement;\n+import io.prestosql.transaction.TransactionManager;\n+\n+import javax.inject.Inject;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n+import static io.prestosql.metadata.MetadataUtil.createQualifiedObjectName;\n+import static io.prestosql.spi.StandardErrorCode.NOT_FOUND;\n+import static io.prestosql.spi.connector.ConnectorViewDefinition.ViewColumn;\n+import static io.prestosql.sql.NodeUtils.mapFromProperties;\n+import static io.prestosql.sql.ParameterUtils.parameterExtractor;\n+import static io.prestosql.sql.SqlFormatterUtil.getFormattedSql;\n+import static java.util.Objects.requireNonNull;\n+\n+public class CreateMaterializedViewTask\n+        implements DataDefinitionTask<CreateMaterializedView>\n+{\n+    private final SqlParser sqlParser;\n+\n+    @Inject\n+    public CreateMaterializedViewTask(SqlParser sqlParser, FeaturesConfig featuresConfig)\n+    {\n+        this.sqlParser = requireNonNull(sqlParser, \"sqlParser is null\");\n+        requireNonNull(featuresConfig, \"featuresConfig is null\");\n+    }\n+\n+    @Override\n+    public String getName()\n+    {\n+        return \"CREATE MATERIALIZED VIEW\";\n+    }\n+\n+    @Override\n+    public String explain(CreateMaterializedView statement, List<Expression> parameters)\n+    {\n+        return \"CREATE MATERIALIZED VIEW \" + statement.getName();\n+    }\n+\n+    @Override\n+    public ListenableFuture<?> execute(CreateMaterializedView statement, TransactionManager transactionManager, Metadata metadata, AccessControl accessControl, QueryStateMachine stateMachine, List<Expression> parameters)\n+    {\n+        Session session = stateMachine.getSession();\n+        QualifiedObjectName name = createQualifiedObjectName(session, statement, statement.getName());\n+        Map<NodeRef<Parameter>, Expression> parameterLookup = parameterExtractor(statement, parameters);\n+\n+        accessControl.checkCanCreateView(session.toSecurityContext(), name);\n+        accessControl.checkCanCreateTable(session.toSecurityContext(), name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2NTgyMA=="}, "originalCommit": null, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU3Njc0Ng==", "bodyText": "This shouldn't be a rewrite (actually, rewrites are a bit of a mis-feature). Instead, it should go through analysis and planning, similar to how views are resolved and expanded.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r442576746", "createdAt": "2020-06-19T00:58:28Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/rewrite/RefreshMaterializedViewRewrite.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.rewrite;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import io.prestosql.Session;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.security.AccessControl;\n+import io.prestosql.spi.connector.ConnectorMaterializedViewDefinition;\n+import io.prestosql.sql.analyzer.QueryExplainer;\n+import io.prestosql.sql.parser.ParsingException;\n+import io.prestosql.sql.parser.SqlParser;\n+import io.prestosql.sql.tree.AstVisitor;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.Identifier;\n+import io.prestosql.sql.tree.Node;\n+import io.prestosql.sql.tree.NodeRef;\n+import io.prestosql.sql.tree.Parameter;\n+import io.prestosql.sql.tree.QualifiedName;\n+import io.prestosql.sql.tree.Query;\n+import io.prestosql.sql.tree.RefreshMV;\n+import io.prestosql.sql.tree.RefreshMaterializedView;\n+import io.prestosql.sql.tree.Statement;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static io.prestosql.metadata.MetadataUtil.createQualifiedObjectName;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_VIEW;\n+import static io.prestosql.spi.StandardErrorCode.TABLE_NOT_FOUND;\n+import static io.prestosql.sql.ParsingUtil.createParsingOptions;\n+import static io.prestosql.sql.analyzer.SemanticExceptions.semanticException;\n+import static java.util.Objects.requireNonNull;\n+\n+final class RefreshMaterializedViewRewrite", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU3Njg4Mg==", "bodyText": "Don't use abbreviations. Cal this RefreshMaterializedView", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r442576882", "createdAt": "2020-06-19T00:59:06Z", "author": {"login": "martint"}, "path": "presto-parser/src/main/java/io/prestosql/sql/tree/RefreshMV.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.tree;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class RefreshMV", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU3NzMyMg==", "bodyText": "The node should be a reflection of the query syntax. As such, the Query has no place here, since it's not something that would be typed as part of the REFRESH MATERIALIZED VIEW xxx command. I understand why you added it, but see my comment in RefreshMaterializedViewRewrite for how to approach it.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r442577322", "createdAt": "2020-06-19T01:00:57Z", "author": {"login": "martint"}, "path": "presto-parser/src/main/java/io/prestosql/sql/tree/RefreshMV.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.tree;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class RefreshMV\n+        extends Statement\n+{\n+    private final QualifiedName target;\n+    private final Query query;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MDA5NDc5", "url": "https://github.com/trinodb/trino/pull/3283#pullrequestreview-446009479", "createdAt": "2020-07-09T22:25:25Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMjoyNToyNlrOGvj17Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMDo0MDoxNVrOGvmQcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUyMzUwMQ==", "bodyText": "Rename notExists to ignoreExisting", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452523501", "createdAt": "2020-07-09T22:25:26Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/Metadata.java", "diffHunk": "@@ -508,4 +509,24 @@ default ResolvedFunction getCoercion(Type fromType, Type toType)\n     ColumnPropertyManager getColumnPropertyManager();\n \n     AnalyzePropertyManager getAnalyzePropertyManager();\n+\n+    /**\n+     * Creates the specified materialized view with the specified view definition.\n+     */\n+    void createMaterializedView(Session session, QualifiedObjectName viewName, ConnectorMaterializedViewDefinition definition, boolean replace, boolean notExists);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUyNzI5MQ==", "bodyText": "What does AbstractMap.SimpleEntry<Boolean, Optional<String>> represent? Consider adding a dedicated holder object for that concept instead of using AbstractMap.SimpleEntry, which is supposed to represent at key-value pair for a map.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452527291", "createdAt": "2020-07-09T22:36:44Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/Metadata.java", "diffHunk": "@@ -529,4 +536,9 @@ default ResolvedFunction getCoercion(Type fromType, Type toType)\n      * Returns the materialized view definition for the specified view name.\n      */\n     Optional<ConnectorMaterializedViewDefinition> getMaterializedView(Session session, QualifiedObjectName viewName);\n+\n+    /**\n+     * Method for the engine to determine if a materialized view is current with respect to the tables it depends on.\n+     */\n+    AbstractMap.SimpleEntry<Boolean, Optional<String>> isMaterializedViewCurrent(Session session, TableHandle tableHandle);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzNDc1NQ==", "bodyText": "Place each argument on a separate line when splitting across multiple lines.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452534755", "createdAt": "2020-07-09T22:59:51Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java", "diffHunk": "@@ -822,6 +823,34 @@ public boolean supportsMissingColumnsOnInsert(Session session, TableHandle table\n         return metadata.finishInsert(session.toConnectorSession(catalogName), tableHandle.getConnectorHandle(), fragments, computedStatistics);\n     }\n \n+    @Override\n+    public InsertTableHandle beginRefreshMaterializedView(Session session, TableHandle tableHandle, boolean skipRefresh)\n+    {\n+        CatalogName catalogName = tableHandle.getCatalogName();\n+        CatalogMetadata catalogMetadata = getCatalogMetadataForWrite(session, catalogName);\n+        ConnectorMetadata metadata = catalogMetadata.getMetadata();\n+        ConnectorTransactionHandle transactionHandle = catalogMetadata.getTransactionHandleFor(catalogName);\n+        ConnectorInsertTableHandle handle = metadata.beginRefreshMaterializedView(session.toConnectorSession(catalogName), tableHandle.getConnectorHandle(), skipRefresh);\n+        return new InsertTableHandle(tableHandle.getCatalogName(), transactionHandle, handle);\n+    }\n+\n+    @Override\n+    public Optional<ConnectorOutputMetadata> finishRefreshMaterializedView(Session session,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzOTI2Ng==", "bodyText": "Don't abbreviate the variable name.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452539266", "createdAt": "2020-07-09T23:14:29Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java", "diffHunk": "@@ -162,6 +162,7 @@\n     private final Map<NodeRef<Unnest>, UnnestAnalysis> unnestAnalysis = new LinkedHashMap<>();\n     private Optional<Create> create = Optional.empty();\n     private Optional<Insert> insert = Optional.empty();\n+    private Optional<RefreshMaterializedView> refreshMV = Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzOTQ1NA==", "bodyText": "Do not abbreviate variable names.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452539454", "createdAt": "2020-07-09T23:15:04Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java", "diffHunk": "@@ -602,6 +603,16 @@ public void setInsert(Insert insert)\n         return insert;\n     }\n \n+    public void setRefreshMaterializedView(RefreshMaterializedView refreshMV)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzOTk3Mg==", "bodyText": "I'd suggest naming this RefreshMaterializedViewAnalysis", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452539972", "createdAt": "2020-07-09T23:16:43Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java", "diffHunk": "@@ -942,6 +953,44 @@ public TableHandle getTarget()\n         }\n     }\n \n+    @Immutable\n+    public static final class RefreshMaterializedView", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU0MTA2NA==", "bodyText": "Don't abbreviate variable names (optionalMatView). Just call it optionalView", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452541064", "createdAt": "2020-07-09T23:20:30Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -439,6 +442,69 @@ protected Scope visitInsert(Insert insert, Optional<Scope> scope)\n             return createAndAssignScope(insert, scope, Field.newUnqualified(\"rows\", BIGINT));\n         }\n \n+        @Override\n+        protected Scope visitRefreshMaterializedView(RefreshMaterializedView refreshMaterializedView, Optional<Scope> scope)\n+        {\n+            QualifiedObjectName name = createQualifiedObjectName(session, refreshMaterializedView, refreshMaterializedView.getName());\n+            Optional<ConnectorMaterializedViewDefinition> optionalMatView = metadata.getMaterializedView(session, name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU0MTkxNQ==", "bodyText": "node isn't used.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452541915", "createdAt": "2020-07-09T23:23:22Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1044,6 +1104,32 @@ protected Scope visitLateral(Lateral node, Optional<Scope> scope)\n             return createAndAssignScope(node, scope, queryScope.getRelationType());\n         }\n \n+        Optional<QualifiedName> getMaterializedViewStorageTableName(Node node, QualifiedObjectName name)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU0MjAxNg==", "bodyText": "optionalMatView -> optionalView (avoid abbreviations)", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452542016", "createdAt": "2020-07-09T23:23:46Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1044,6 +1104,32 @@ protected Scope visitLateral(Lateral node, Optional<Scope> scope)\n             return createAndAssignScope(node, scope, queryScope.getRelationType());\n         }\n \n+        Optional<QualifiedName> getMaterializedViewStorageTableName(Node node, QualifiedObjectName name)\n+        {\n+            Optional<ConnectorMaterializedViewDefinition> optionalMatView = metadata.getMaterializedView(session, name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU0MjM5MA==", "bodyText": "This can be declared below where the assignment is made. I would just get rid of the variable altogether, though and inline it in the return call.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452542390", "createdAt": "2020-07-09T23:24:55Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1044,6 +1104,32 @@ protected Scope visitLateral(Lateral node, Optional<Scope> scope)\n             return createAndAssignScope(node, scope, queryScope.getRelationType());\n         }\n \n+        Optional<QualifiedName> getMaterializedViewStorageTableName(Node node, QualifiedObjectName name)\n+        {\n+            Optional<ConnectorMaterializedViewDefinition> optionalMatView = metadata.getMaterializedView(session, name);\n+            if (!optionalMatView.isPresent()) {\n+                return Optional.empty();\n+            }\n+\n+            QualifiedName storageName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU0MjU1NQ==", "bodyText": "private", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452542555", "createdAt": "2020-07-09T23:25:21Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1044,6 +1104,32 @@ protected Scope visitLateral(Lateral node, Optional<Scope> scope)\n             return createAndAssignScope(node, scope, queryScope.getRelationType());\n         }\n \n+        Optional<QualifiedName> getMaterializedViewStorageTableName(Node node, QualifiedObjectName name)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU0MzA1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (!optionalMatView.isPresent()) {\n          \n          \n            \n                        if (optionalMatView.isEmpty()) {", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452543057", "createdAt": "2020-07-09T23:26:58Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1044,6 +1104,32 @@ protected Scope visitLateral(Lateral node, Optional<Scope> scope)\n             return createAndAssignScope(node, scope, queryScope.getRelationType());\n         }\n \n+        Optional<QualifiedName> getMaterializedViewStorageTableName(Node node, QualifiedObjectName name)\n+        {\n+            Optional<ConnectorMaterializedViewDefinition> optionalMatView = metadata.getMaterializedView(session, name);\n+            if (!optionalMatView.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU0Mzc3OQ==", "bodyText": "getProperties().getOrDefault(\"storage_table\", \"\") should be a proper attribute of ConnectorMaterializedViewDefinition. Storing it and accessing it as a dynamic property is brittle. Also, it might conflict with properties defined by the connector.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452543779", "createdAt": "2020-07-09T23:29:07Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1044,6 +1104,32 @@ protected Scope visitLateral(Lateral node, Optional<Scope> scope)\n             return createAndAssignScope(node, scope, queryScope.getRelationType());\n         }\n \n+        Optional<QualifiedName> getMaterializedViewStorageTableName(Node node, QualifiedObjectName name)\n+        {\n+            Optional<ConnectorMaterializedViewDefinition> optionalMatView = metadata.getMaterializedView(session, name);\n+            if (!optionalMatView.isPresent()) {\n+                return Optional.empty();\n+            }\n+\n+            QualifiedName storageName;\n+\n+            String storageTable = String.valueOf(optionalMatView.get().getProperties().getOrDefault(\"storage_table\", \"\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU0NDQwMg==", "bodyText": "schema is not used below. I belive viewExpandedText is being passed incorrectly in the position of catalog, and catalog is being passed in the position of schema.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452544402", "createdAt": "2020-07-09T23:31:10Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMaterializedViewDefinition.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+public class ConnectorMaterializedViewDefinition\n+        extends ConnectorViewDefinition\n+{\n+    private final Map<String, Object> properties;\n+    private final Optional<String> comment;\n+\n+    public Map<String, Object> getProperties()\n+    {\n+        return properties;\n+    }\n+\n+    @Override\n+    public Optional<String> getComment()\n+    {\n+        return comment;\n+    }\n+\n+    @JsonCreator\n+    public ConnectorMaterializedViewDefinition(\n+            @JsonProperty(\"originalSql\") String originalSql,\n+            @JsonProperty(\"viewExpandedText\") Optional<String> viewExpandedText,\n+            @JsonProperty(\"catalog\") Optional<String> catalog,\n+            @JsonProperty(\"schema\") Optional<String> schema,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU0NDg5Ng==", "bodyText": "I don't think we should model materialized views as subtypes of ConnectorViewDefinition. They are separate entities (despite their name) with their own characteristics and behaviors that don't necessarily line up with views.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452544896", "createdAt": "2020-07-09T23:32:51Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMaterializedViewDefinition.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+public class ConnectorMaterializedViewDefinition\n+        extends ConnectorViewDefinition", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU0ODI0NQ==", "bodyText": "What's viewExpandedText?", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452548245", "createdAt": "2020-07-09T23:43:50Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMaterializedViewDefinition.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+public class ConnectorMaterializedViewDefinition\n+        extends ConnectorViewDefinition\n+{\n+    private final Map<String, Object> properties;\n+    private final Optional<String> comment;\n+\n+    public Map<String, Object> getProperties()\n+    {\n+        return properties;\n+    }\n+\n+    @Override\n+    public Optional<String> getComment()\n+    {\n+        return comment;\n+    }\n+\n+    @JsonCreator\n+    public ConnectorMaterializedViewDefinition(\n+            @JsonProperty(\"originalSql\") String originalSql,\n+            @JsonProperty(\"viewExpandedText\") Optional<String> viewExpandedText,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU0ODc3MQ==", "bodyText": "These probably need to be \"delimited\" (new Identifier(..., true)) to avoid issues with case sensitivity or ambiguities.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452548771", "createdAt": "2020-07-09T23:45:39Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1044,6 +1104,32 @@ protected Scope visitLateral(Lateral node, Optional<Scope> scope)\n             return createAndAssignScope(node, scope, queryScope.getRelationType());\n         }\n \n+        Optional<QualifiedName> getMaterializedViewStorageTableName(Node node, QualifiedObjectName name)\n+        {\n+            Optional<ConnectorMaterializedViewDefinition> optionalMatView = metadata.getMaterializedView(session, name);\n+            if (!optionalMatView.isPresent()) {\n+                return Optional.empty();\n+            }\n+\n+            QualifiedName storageName;\n+\n+            String storageTable = String.valueOf(optionalMatView.get().getProperties().getOrDefault(\"storage_table\", \"\"));\n+            if (StringUtils.isEmpty(storageTable)) {\n+                return Optional.empty();\n+            }\n+            Identifier catalogName = new Identifier(name.getCatalogName());\n+            Identifier schemaName = new Identifier(name.getSchemaName());\n+            Identifier tableName = new Identifier(storageTable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU0OTg4MQ==", "bodyText": "There's nothing specific about \"materialized view storage table\" in this method -- it could work for any table. Since it's a rather trivial method, it's used in just one place, and it doesn't seem specific to materialized views, inline it and remove it.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452549881", "createdAt": "2020-07-09T23:49:22Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1044,6 +1104,32 @@ protected Scope visitLateral(Lateral node, Optional<Scope> scope)\n             return createAndAssignScope(node, scope, queryScope.getRelationType());\n         }\n \n+        Optional<QualifiedName> getMaterializedViewStorageTableName(Node node, QualifiedObjectName name)\n+        {\n+            Optional<ConnectorMaterializedViewDefinition> optionalMatView = metadata.getMaterializedView(session, name);\n+            if (!optionalMatView.isPresent()) {\n+                return Optional.empty();\n+            }\n+\n+            QualifiedName storageName;\n+\n+            String storageTable = String.valueOf(optionalMatView.get().getProperties().getOrDefault(\"storage_table\", \"\"));\n+            if (StringUtils.isEmpty(storageTable)) {\n+                return Optional.empty();\n+            }\n+            Identifier catalogName = new Identifier(name.getCatalogName());\n+            Identifier schemaName = new Identifier(name.getSchemaName());\n+            Identifier tableName = new Identifier(storageTable);\n+            storageName = QualifiedName.of(ImmutableList.of(catalogName, schemaName, tableName));\n+            return Optional.of(storageName);\n+        }\n+\n+        Optional<TableHandle> getMaterializedViewStorageTableHandle(Node node, QualifiedName storageName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU1Mjg0MQ==", "bodyText": "== true is unnecessary", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452552841", "createdAt": "2020-07-10T00:00:00Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1058,10 +1144,28 @@ protected Scope visitTable(Table table, Optional<Scope> scope)\n             QualifiedObjectName name = createQualifiedObjectName(session, table, table.getName());\n             analysis.addEmptyColumnReferencesForTable(accessControl, session.getIdentity(), name);\n \n-            // is this a reference to a view?\n-            Optional<ConnectorViewDefinition> optionalView = metadata.getView(session, name);\n-            if (optionalView.isPresent()) {\n-                return createScopeForView(table, name, scope, optionalView.get());\n+            // If this is a materialized view, get the name of the storage table\n+            Optional<QualifiedName> storageName = getMaterializedViewStorageTableName(table, name);\n+            Optional<TableHandle> storageHandle = Optional.empty();\n+            if (storageName.isPresent()) {\n+                storageHandle = getMaterializedViewStorageTableHandle(table, storageName.get());\n+            }\n+\n+            // If materialized view is current, answer the query using the storage table\n+            Identifier catalogName = new Identifier(name.getCatalogName());\n+            Identifier schemaName = new Identifier(name.getSchemaName());\n+            Identifier tableName = new Identifier(name.getObjectName());\n+            QualifiedName mvName = QualifiedName.of(ImmutableList.of(catalogName, schemaName, tableName));\n+            Optional<TableHandle> mvHandle = metadata.getTableHandle(session, createQualifiedObjectName(session, table, mvName));\n+            if (storageHandle.isPresent() && metadata.isMaterializedViewCurrent(session, mvHandle.get()).getKey() == true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU1MjkyMQ==", "bodyText": "Don't abbreviate variable names", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452552921", "createdAt": "2020-07-10T00:00:17Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1058,10 +1144,28 @@ protected Scope visitTable(Table table, Optional<Scope> scope)\n             QualifiedObjectName name = createQualifiedObjectName(session, table, table.getName());\n             analysis.addEmptyColumnReferencesForTable(accessControl, session.getIdentity(), name);\n \n-            // is this a reference to a view?\n-            Optional<ConnectorViewDefinition> optionalView = metadata.getView(session, name);\n-            if (optionalView.isPresent()) {\n-                return createScopeForView(table, name, scope, optionalView.get());\n+            // If this is a materialized view, get the name of the storage table\n+            Optional<QualifiedName> storageName = getMaterializedViewStorageTableName(table, name);\n+            Optional<TableHandle> storageHandle = Optional.empty();\n+            if (storageName.isPresent()) {\n+                storageHandle = getMaterializedViewStorageTableHandle(table, storageName.get());\n+            }\n+\n+            // If materialized view is current, answer the query using the storage table\n+            Identifier catalogName = new Identifier(name.getCatalogName());\n+            Identifier schemaName = new Identifier(name.getSchemaName());\n+            Identifier tableName = new Identifier(name.getObjectName());\n+            QualifiedName mvName = QualifiedName.of(ImmutableList.of(catalogName, schemaName, tableName));\n+            Optional<TableHandle> mvHandle = metadata.getTableHandle(session, createQualifiedObjectName(session, table, mvName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU1NDM3MA==", "bodyText": "We already have the storage table handle at this point. No need to roundtrip again via the table name.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452554370", "createdAt": "2020-07-10T00:05:46Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1058,10 +1144,28 @@ protected Scope visitTable(Table table, Optional<Scope> scope)\n             QualifiedObjectName name = createQualifiedObjectName(session, table, table.getName());\n             analysis.addEmptyColumnReferencesForTable(accessControl, session.getIdentity(), name);\n \n-            // is this a reference to a view?\n-            Optional<ConnectorViewDefinition> optionalView = metadata.getView(session, name);\n-            if (optionalView.isPresent()) {\n-                return createScopeForView(table, name, scope, optionalView.get());\n+            // If this is a materialized view, get the name of the storage table\n+            Optional<QualifiedName> storageName = getMaterializedViewStorageTableName(table, name);\n+            Optional<TableHandle> storageHandle = Optional.empty();\n+            if (storageName.isPresent()) {\n+                storageHandle = getMaterializedViewStorageTableHandle(table, storageName.get());\n+            }\n+\n+            // If materialized view is current, answer the query using the storage table\n+            Identifier catalogName = new Identifier(name.getCatalogName());\n+            Identifier schemaName = new Identifier(name.getSchemaName());\n+            Identifier tableName = new Identifier(name.getObjectName());\n+            QualifiedName mvName = QualifiedName.of(ImmutableList.of(catalogName, schemaName, tableName));\n+            Optional<TableHandle> mvHandle = metadata.getTableHandle(session, createQualifiedObjectName(session, table, mvName));\n+            if (storageHandle.isPresent() && metadata.isMaterializedViewCurrent(session, mvHandle.get()).getKey() == true) {\n+                name = createQualifiedObjectName(session, table, storageName.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU1ODEyMg==", "bodyText": "This change doesn't seem necessary.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452558122", "createdAt": "2020-07-10T00:19:50Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1124,20 +1228,21 @@ private void analyzeFiltersAndMasks(Table table, QualifiedObjectName name, Optio\n                     .withRelationType(RelationId.anonymous(), new RelationType(fields))\n                     .build();\n \n+            final QualifiedObjectName finalName = name;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU1ODQwMg==", "bodyText": "Don't abbreviate names. In this case, it could be renamed to just refreshTarget as a concise and to-the-point name.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452558402", "createdAt": "2020-07-10T00:20:47Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -2906,6 +2906,11 @@ private static TableFinisher createTableFinisher(Session session, TableFinishNod\n             else if (target instanceof InsertTarget) {\n                 return metadata.finishInsert(session, ((InsertTarget) target).getHandle(), fragments, statistics);\n             }\n+            else if (target instanceof TableWriterNode.RefreshMaterializedViewTarget) {\n+                TableWriterNode.RefreshMaterializedViewTarget refreshMVTarget = (TableWriterNode.RefreshMaterializedViewTarget) target;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU1OTQzMw==", "bodyText": "Don't abbreviate variable names", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452559433", "createdAt": "2020-07-10T00:25:05Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LogicalPlanner.java", "diffHunk": "@@ -411,6 +416,76 @@ private RelationPlan createInsertPlan(Analysis analysis, Insert insertStatement)\n                 statisticsMetadata);\n     }\n \n+    private RelationPlan createRefreshMaterializedViewPlan(Analysis analysis)\n+    {\n+        Analysis.RefreshMaterializedView refreshMV = analysis.getRefreshMaterializedView().get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2MjYyOA==", "bodyText": "This looks exactly the same as createInsertPlan, except for that target table handles and a couple of other things. There's probably some opportunity for reuse, especially given the complexity of this method.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452562628", "createdAt": "2020-07-10T00:38:20Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LogicalPlanner.java", "diffHunk": "@@ -411,6 +416,76 @@ private RelationPlan createInsertPlan(Analysis analysis, Insert insertStatement)\n                 statisticsMetadata);\n     }\n \n+    private RelationPlan createRefreshMaterializedViewPlan(Analysis analysis)\n+    {\n+        Analysis.RefreshMaterializedView refreshMV = analysis.getRefreshMaterializedView().get();\n+\n+        TableMetadata tableMetadata = metadata.getTableMetadata(session, refreshMV.getTarget());\n+\n+        RelationPlan plan = createRelationPlan(analysis, refreshMV.getQuery());\n+\n+        Map<String, ColumnHandle> columns = metadata.getColumnHandles(session, refreshMV.getTarget());\n+        Assignments.Builder assignments = Assignments.builder();\n+        boolean supportsMissingColumnsOnInsert = metadata.supportsMissingColumnsOnInsert(session, refreshMV.getTarget());\n+        ImmutableList.Builder<ColumnMetadata> insertedColumnsBuilder = ImmutableList.builder();\n+\n+        for (ColumnMetadata column : tableMetadata.getColumns()) {\n+            if (column.isHidden()) {\n+                continue;\n+            }\n+            Symbol output = symbolAllocator.newSymbol(column.getName(), column.getType());\n+            int index = refreshMV.getColumns().indexOf(columns.get(column.getName()));\n+            if (index < 0) {\n+                if (supportsMissingColumnsOnInsert) {\n+                    continue;\n+                }\n+                Expression cast = new Cast(new NullLiteral(), toSqlType(column.getType()));\n+                assignments.put(output, cast);\n+                insertedColumnsBuilder.add(column);\n+            }\n+            else {\n+                Symbol input = plan.getSymbol(index);\n+                Type tableType = column.getType();\n+                Type queryType = symbolAllocator.getTypes().get(input);\n+\n+                if (queryType.equals(tableType) || typeCoercion.isTypeOnlyCoercion(queryType, tableType)) {\n+                    assignments.put(output, input.toSymbolReference());\n+                }\n+                else {\n+                    Expression cast = noTruncationCast(input.toSymbolReference(), queryType, tableType);\n+                    assignments.put(output, cast);\n+                }\n+                insertedColumnsBuilder.add(column);\n+            }\n+        }\n+\n+        ProjectNode projectNode = new ProjectNode(idAllocator.getNextId(), plan.getRoot(), assignments.build());\n+\n+        List<ColumnMetadata> insertedColumns = insertedColumnsBuilder.build();\n+        List<Field> fields = insertedColumns.stream()\n+                .map(column -> Field.newUnqualified(column.getName(), column.getType()))\n+                .collect(toImmutableList());\n+        Scope scope = Scope.builder().withRelationType(RelationId.anonymous(), new RelationType(fields)).build();\n+\n+        plan = new RelationPlan(projectNode, scope, projectNode.getOutputSymbols(), Optional.empty());\n+\n+        String catalogName = refreshMV.getTarget().getCatalogName().getCatalogName();\n+        TableStatisticsMetadata statisticsMetadata = metadata.getStatisticsCollectionMetadataForWrite(session, catalogName, tableMetadata.getMetadata());\n+\n+        List<String> insertedTableColumnNames = insertedColumns.stream()\n+                .map(ColumnMetadata::getName)\n+                .collect(toImmutableList());\n+\n+        Optional<NewTableLayout> newTableLayout = metadata.getInsertLayout(session, refreshMV.getTarget());\n+        return createTableWriterPlan(\n+            analysis,\n+            plan,\n+            new TableWriterNode.RefreshMaterializedViewReference(refreshMV.getMaterializedViewHandle(), refreshMV.getTarget(), new ArrayList<>(analysis.getTables())),\n+            insertedTableColumnNames,\n+            newTableLayout,\n+            statisticsMetadata);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2MjcyMQ==", "bodyText": "Unrelated formatting change", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452562721", "createdAt": "2020-07-10T00:38:53Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -307,7 +307,7 @@ private PlanBuilder planFrom(QuerySpecification node)\n \n         if (node.getFrom().isPresent()) {\n             relationPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session)\n-                .process(node.getFrom().get(), null);\n+                    .process(node.getFrom().get(), null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2Mjg0Mw==", "bodyText": "ImmutableList.copyOf()", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452562843", "createdAt": "2020-07-10T00:39:20Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/plan/TableWriterNode.java", "diffHunk": "@@ -317,6 +318,94 @@ public String toString()\n         }\n     }\n \n+    public static class RefreshMaterializedViewReference\n+            extends WriterTarget\n+    {\n+        private final TableHandle materializedViewHandle;\n+        private final TableHandle storageTableHandle;\n+        private final List<TableHandle> sourceTableHandles;\n+\n+        public RefreshMaterializedViewReference(TableHandle materializedViewHandle, TableHandle storageTableHandle, List<TableHandle> sourceTableHandles)\n+        {\n+            this.materializedViewHandle = requireNonNull(materializedViewHandle, \"Materialized view handle is null\");\n+            this.storageTableHandle = requireNonNull(storageTableHandle, \"Storage table handle is null\");\n+            this.sourceTableHandles = sourceTableHandles;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2MjkxOA==", "bodyText": "ImmutableList.copyOf()", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452562918", "createdAt": "2020-07-10T00:39:39Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/plan/TableWriterNode.java", "diffHunk": "@@ -317,6 +318,94 @@ public String toString()\n         }\n     }\n \n+    public static class RefreshMaterializedViewReference\n+            extends WriterTarget\n+    {\n+        private final TableHandle materializedViewHandle;\n+        private final TableHandle storageTableHandle;\n+        private final List<TableHandle> sourceTableHandles;\n+\n+        public RefreshMaterializedViewReference(TableHandle materializedViewHandle, TableHandle storageTableHandle, List<TableHandle> sourceTableHandles)\n+        {\n+            this.materializedViewHandle = requireNonNull(materializedViewHandle, \"Materialized view handle is null\");\n+            this.storageTableHandle = requireNonNull(storageTableHandle, \"Storage table handle is null\");\n+            this.sourceTableHandles = sourceTableHandles;\n+        }\n+\n+        public TableHandle getMaterializedViewHandle()\n+        {\n+            return materializedViewHandle;\n+        }\n+\n+        public TableHandle getStorageTableHandle()\n+        {\n+            return storageTableHandle;\n+        }\n+\n+        public List<TableHandle> getSourceTableHandles()\n+        {\n+            return sourceTableHandles;\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return materializedViewHandle.toString();\n+        }\n+    }\n+\n+    public static class RefreshMaterializedViewTarget\n+            extends WriterTarget\n+    {\n+        private final InsertTableHandle handle;\n+        private final SchemaTableName schemaTableName;\n+        private final boolean skipRefresh;\n+        private final List<TableHandle> sourceTableHandles;\n+\n+        @JsonCreator\n+        public RefreshMaterializedViewTarget(\n+                @JsonProperty(\"handle\") InsertTableHandle handle,\n+                @JsonProperty(\"schemaTableName\") SchemaTableName schemaTableName,\n+                @JsonProperty(\"skipRefresh\") boolean skipRefresh,\n+                @JsonProperty(\"sourceTableHandles\") List<TableHandle> sourceTableHandles)\n+        {\n+            this.handle = handle;\n+            this.schemaTableName = requireNonNull(schemaTableName, \"schemaTableName is null\");\n+            this.skipRefresh = skipRefresh;\n+            this.sourceTableHandles = sourceTableHandles;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2MzA1OA==", "bodyText": "requireNonNull", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r452563058", "createdAt": "2020-07-10T00:40:15Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/plan/TableWriterNode.java", "diffHunk": "@@ -317,6 +318,94 @@ public String toString()\n         }\n     }\n \n+    public static class RefreshMaterializedViewReference\n+            extends WriterTarget\n+    {\n+        private final TableHandle materializedViewHandle;\n+        private final TableHandle storageTableHandle;\n+        private final List<TableHandle> sourceTableHandles;\n+\n+        public RefreshMaterializedViewReference(TableHandle materializedViewHandle, TableHandle storageTableHandle, List<TableHandle> sourceTableHandles)\n+        {\n+            this.materializedViewHandle = requireNonNull(materializedViewHandle, \"Materialized view handle is null\");\n+            this.storageTableHandle = requireNonNull(storageTableHandle, \"Storage table handle is null\");\n+            this.sourceTableHandles = sourceTableHandles;\n+        }\n+\n+        public TableHandle getMaterializedViewHandle()\n+        {\n+            return materializedViewHandle;\n+        }\n+\n+        public TableHandle getStorageTableHandle()\n+        {\n+            return storageTableHandle;\n+        }\n+\n+        public List<TableHandle> getSourceTableHandles()\n+        {\n+            return sourceTableHandles;\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return materializedViewHandle.toString();\n+        }\n+    }\n+\n+    public static class RefreshMaterializedViewTarget\n+            extends WriterTarget\n+    {\n+        private final InsertTableHandle handle;\n+        private final SchemaTableName schemaTableName;\n+        private final boolean skipRefresh;\n+        private final List<TableHandle> sourceTableHandles;\n+\n+        @JsonCreator\n+        public RefreshMaterializedViewTarget(\n+                @JsonProperty(\"handle\") InsertTableHandle handle,\n+                @JsonProperty(\"schemaTableName\") SchemaTableName schemaTableName,\n+                @JsonProperty(\"skipRefresh\") boolean skipRefresh,\n+                @JsonProperty(\"sourceTableHandles\") List<TableHandle> sourceTableHandles)\n+        {\n+            this.handle = handle;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNTM0MjM3", "url": "https://github.com/trinodb/trino/pull/3283#pullrequestreview-460534237", "createdAt": "2020-08-04T06:40:34Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwNjo0MDozNFrOG7TF4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwNjo0MDozNFrOG7TF4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgzMTk2OQ==", "bodyText": "@martint I had proposed that we perform checkCanCreateTable access check on storage table, but storage table name is generated by the connector and is not available at this point in code.\nTo keep code symmetric, dropMaterializedView also performs the checkCanDropTable check on materialized view.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r464831969", "createdAt": "2020-08-04T06:40:34Z", "author": {"login": "anjalinorwood"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -925,6 +924,7 @@ protected Scope visitCreateMaterializedView(CreateMaterializedView node, Optiona\n             Scope queryScope = analyzer.analyze(node.getQuery(), scope);\n \n             accessControl.checkCanCreateView(session.toSecurityContext(), viewName);\n+            accessControl.checkCanCreateTable(session.toSecurityContext(), viewName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNTM4Mjc2", "url": "https://github.com/trinodb/trino/pull/3283#pullrequestreview-460538276", "createdAt": "2020-08-04T06:48:36Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwNjo0ODozN1rOG7TSkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwNjo0ODozN1rOG7TSkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgzNTIxNw==", "bodyText": "@martint I wanted to point out that, here we read materialized view like a logical view since it is stale. Another option would be:\nAnalyze materialized view to get columns and other attributes and create a new logical view and create scope for that. This analysis is necessary since the columns exposed by the materialized view is a single dummy column of type varchar. (This is similar to how a presto view exposes a single dummy column of type varchar).\nStoring actual column list at create materialized view time also poses issues since the column list needs to be a list of hive metastore columns and the connector does not have the correct TypeManager to do that conversion from SPI TypeId to hive column type.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r464835217", "createdAt": "2020-08-04T06:48:37Z", "author": {"login": "anjalinorwood"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1143,22 +1134,23 @@ protected Scope visitTable(Table table, Optional<Scope> scope)\n \n             QualifiedObjectName name = createQualifiedObjectName(session, table, table.getName());\n             analysis.addEmptyColumnReferencesForTable(accessControl, session.getIdentity(), name);\n+            Optional<TableHandle> tableHandle = metadata.getTableHandle(session, name);\n \n             // If this is a materialized view, get the name of the storage table\n-            Optional<QualifiedName> storageName = getMaterializedViewStorageTableName(table, name);\n+            Optional<QualifiedName> storageName = getMaterializedViewStorageTableName(name);\n             Optional<TableHandle> storageHandle = Optional.empty();\n             if (storageName.isPresent()) {\n-                storageHandle = getMaterializedViewStorageTableHandle(table, storageName.get());\n+                storageHandle = metadata.getTableHandle(session, createQualifiedObjectName(session, table, storageName.get()));\n             }\n \n             // If materialized view is current, answer the query using the storage table\n             Identifier catalogName = new Identifier(name.getCatalogName());\n             Identifier schemaName = new Identifier(name.getSchemaName());\n             Identifier tableName = new Identifier(name.getObjectName());\n-            QualifiedName mvName = QualifiedName.of(ImmutableList.of(catalogName, schemaName, tableName));\n-            Optional<TableHandle> mvHandle = metadata.getTableHandle(session, createQualifiedObjectName(session, table, mvName));\n-            if (storageHandle.isPresent() && metadata.isMaterializedViewCurrent(session, mvHandle.get()).getKey() == true) {\n-                name = createQualifiedObjectName(session, table, storageName.get());\n+            QualifiedName materializedViewName = QualifiedName.of(ImmutableList.of(catalogName, schemaName, tableName));\n+            Optional<TableHandle> materializedViewHandle = metadata.getTableHandle(session, createQualifiedObjectName(session, table, materializedViewName));\n+            if (storageHandle.isPresent() && metadata.isMaterializedViewCurrent(session, materializedViewHandle.get()).getIsFresh()) {\n+                tableHandle = storageHandle;\n             }\n             else {\n                 // Either this is a reference to a logical view or the materialized view is not current and should be expanded like a logical view", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 122}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMDI0NDM2", "url": "https://github.com/trinodb/trino/pull/3283#pullrequestreview-463024436", "createdAt": "2020-08-07T04:21:02Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwNDoyMTowMlrOG9L92Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMzozOTozNFrOHAhM4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgxMjM3Nw==", "bodyText": "First argument should go on the next line", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r466812377", "createdAt": "2020-08-07T04:21:02Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/execution/CreateMaterializedViewTask.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.security.AccessControl;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorMaterializedViewDefinition;\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.Analyzer;\n+import io.prestosql.sql.analyzer.FeaturesConfig;\n+import io.prestosql.sql.parser.SqlParser;\n+import io.prestosql.sql.tree.CreateMaterializedView;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.NodeRef;\n+import io.prestosql.sql.tree.Parameter;\n+import io.prestosql.sql.tree.Statement;\n+import io.prestosql.transaction.TransactionManager;\n+\n+import javax.inject.Inject;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n+import static io.prestosql.metadata.MetadataUtil.createQualifiedObjectName;\n+import static io.prestosql.spi.StandardErrorCode.NOT_FOUND;\n+import static io.prestosql.sql.NodeUtils.mapFromProperties;\n+import static io.prestosql.sql.ParameterUtils.parameterExtractor;\n+import static io.prestosql.sql.SqlFormatterUtil.getFormattedSql;\n+import static java.util.Objects.requireNonNull;\n+\n+public class CreateMaterializedViewTask\n+        implements DataDefinitionTask<CreateMaterializedView>\n+{\n+    private final SqlParser sqlParser;\n+\n+    @Inject\n+    public CreateMaterializedViewTask(SqlParser sqlParser, FeaturesConfig featuresConfig)\n+    {\n+        this.sqlParser = requireNonNull(sqlParser, \"sqlParser is null\");\n+        requireNonNull(featuresConfig, \"featuresConfig is null\");\n+    }\n+\n+    @Override\n+    public String getName()\n+    {\n+        return \"CREATE MATERIALIZED VIEW\";\n+    }\n+\n+    @Override\n+    public String explain(CreateMaterializedView statement, List<Expression> parameters)\n+    {\n+        return \"CREATE MATERIALIZED VIEW \" + statement.getName();\n+    }\n+\n+    @Override\n+    public ListenableFuture<?> execute(CreateMaterializedView statement,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgxMzExNw==", "bodyText": "That's for the case when the user doesn't specify a storage table right? In that case, it's appropriate to not check, since it's expected that the connector will generate a table the user has access to.\nFor the case where a user specifies a storage table, that should be validated.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r466813117", "createdAt": "2020-08-07T04:24:29Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -925,6 +924,7 @@ protected Scope visitCreateMaterializedView(CreateMaterializedView node, Optiona\n             Scope queryScope = analyzer.analyze(node.getQuery(), scope);\n \n             accessControl.checkCanCreateView(session.toSecurityContext(), viewName);\n+            accessControl.checkCanCreateTable(session.toSecurityContext(), viewName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgzMTk2OQ=="}, "originalCommit": null, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMwNDg4Ng==", "bodyText": "Unrelated formatting change", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r470304886", "createdAt": "2020-08-13T23:35:38Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LogicalPlanner.java", "diffHunk": "@@ -294,14 +321,14 @@ private RelationPlan createAnalyzePlan(Analysis analysis, Analyze analyzeStateme\n         PlanNode planNode = new StatisticsWriterNode(\n                 idAllocator.getNextId(),\n                 new AggregationNode(\n-                        idAllocator.getNextId(),\n-                        TableScanNode.newInstance(idAllocator.getNextId(), targetTable, tableScanOutputs.build(), symbolToColumnHandle.build()),\n-                        statisticAggregations.getAggregations(),\n-                        singleGroupingSet(groupingSymbols),\n-                        ImmutableList.of(),\n-                        AggregationNode.Step.SINGLE,\n-                        Optional.empty(),\n-                        Optional.empty()),\n+                idAllocator.getNextId(),\n+                TableScanNode.newInstance(idAllocator.getNextId(), targetTable, tableScanOutputs.build(), symbolToColumnHandle.build()),\n+                statisticAggregations.getAggregations(),\n+                singleGroupingSet(groupingSymbols),\n+                ImmutableList.of(),\n+                AggregationNode.Step.SINGLE,\n+                Optional.empty(),\n+                Optional.empty()),\n                 new StatisticsWriterNode.WriteStatisticsReference(targetTable),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMwNDk2OA==", "bodyText": "Why did this get removed?", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r470304968", "createdAt": "2020-08-13T23:35:55Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LogicalPlanner.java", "diffHunk": "@@ -123,13 +124,7 @@\n \n public class LogicalPlanner\n {\n-    public enum Stage\n-    {\n-        CREATED, OPTIMIZED, OPTIMIZED_AND_VALIDATED\n-    }\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMwNTAxNg==", "bodyText": "Unrelated formatting change", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r470305016", "createdAt": "2020-08-13T23:36:04Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LogicalPlanner.java", "diffHunk": "@@ -123,13 +124,7 @@\n \n public class LogicalPlanner\n {\n-    public enum Stage\n-    {\n-        CREATED, OPTIMIZED, OPTIMIZED_AND_VALIDATED\n-    }\n-\n     private final PlanNodeIdAllocator idAllocator;\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMwNTEzOA==", "bodyText": "First argument should go on the next line", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r470305138", "createdAt": "2020-08-13T23:36:30Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LogicalPlanner.java", "diffHunk": "@@ -341,25 +368,29 @@ private RelationPlan createTableCreationPlan(Analysis analysis, Query query)\n                 statisticsMetadata);\n     }\n \n-    private RelationPlan createInsertPlan(Analysis analysis, Insert insertStatement)\n+    private RelationPlan getInsertPlan(Analysis analysis,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMwNTI4OQ==", "bodyText": "Unrelated formatting change?", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r470305289", "createdAt": "2020-08-13T23:37:04Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LogicalPlanner.java", "diffHunk": "@@ -549,21 +610,21 @@ private Expression noTruncationCast(Expression expression, Type fromType, Type t\n         ResolvedFunction fail = metadata.resolveFunction(QualifiedName.of(\"fail\"), fromTypes(VARCHAR));\n \n         return new IfExpression(\n-                // check if the trimmed value fits in the target type\n-                new ComparisonExpression(\n-                        GREATER_THAN_OR_EQUAL,\n-                        new GenericLiteral(\"BIGINT\", Integer.toString(targetLength)),\n-                        new CoalesceExpression(\n-                                new FunctionCall(\n-                                        spaceTrimmedLength.toQualifiedName(),\n-                                        ImmutableList.of(new Cast(expression, toSqlType(VARCHAR)))),\n-                                new GenericLiteral(\"BIGINT\", \"0\"))),\n-                new Cast(expression, toSqlType(toType)),\n-                new Cast(\n-                        new FunctionCall(\n-                                fail.toQualifiedName(),\n-                                ImmutableList.of(new Cast(new StringLiteral(\"Cannot truncate non-space characters on INSERT\"), toSqlType(VARCHAR)))),\n-                        toSqlType(toType)));\n+            // check if the trimmed value fits in the target type\n+            new ComparisonExpression(\n+                GREATER_THAN_OR_EQUAL,\n+                new GenericLiteral(\"BIGINT\", Integer.toString(targetLength)),\n+                new CoalesceExpression(\n+                    new FunctionCall(\n+                        spaceTrimmedLength.toQualifiedName(),\n+                        ImmutableList.of(new Cast(expression, toSqlType(VARCHAR)))),\n+                    new GenericLiteral(\"BIGINT\", \"0\"))),\n+            new Cast(expression, toSqlType(toType)),\n+            new Cast(\n+                new FunctionCall(\n+                    fail.toQualifiedName(),\n+                    ImmutableList.of(new Cast(new StringLiteral(\"Cannot truncate non-space characters on INSERT\"), toSqlType(VARCHAR)))),\n+                toSqlType(toType)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMwNTQ5NA==", "bodyText": "Why did this method move?", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r470305494", "createdAt": "2020-08-13T23:37:42Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LogicalPlanner.java", "diffHunk": "@@ -179,6 +174,34 @@ public LogicalPlanner(\n         this.warningCollector = requireNonNull(warningCollector, \"warningCollector is null\");\n     }\n \n+    private static Map<NodeRef<LambdaArgumentDeclaration>, Symbol> buildLambdaDeclarationToSymbolMap(Analysis analysis, SymbolAllocator symbolAllocator)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMwNjAxNg==", "bodyText": "As we discussed offline, the freshness check and short-circuiting should be done in the RefreshMaterializedView task class, before we even get to the planner/optimizer.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r470306016", "createdAt": "2020-08-13T23:39:34Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/BeginTableWrite.java", "diffHunk": "@@ -187,6 +187,16 @@ private WriterTarget createWriterTarget(WriterTarget target)\n                 DeleteTarget delete = (DeleteTarget) target;\n                 return new DeleteTarget(metadata.beginDelete(session, delete.getHandle()), delete.getSchemaTableName());\n             }\n+            if (target instanceof TableWriterNode.RefreshMaterializedViewReference) {\n+                TableWriterNode.RefreshMaterializedViewReference refreshMV = (TableWriterNode.RefreshMaterializedViewReference) target;\n+                boolean skipRefresh = false;\n+\n+                if (metadata.isMaterializedViewCurrent(session, refreshMV.getMaterializedViewHandle()).getIsFresh()) {\n+                    skipRefresh = true;\n+                }\n+                return new TableWriterNode.RefreshMaterializedViewTarget(metadata.beginRefreshMaterializedView(session, refreshMV.getStorageTableHandle(), skipRefresh),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 11}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "525b75f14844372817ffc85e8d69b918b22e17e7", "author": {"user": {"login": "anjalinorwood", "name": "Anjali Norwood"}}, "url": "https://github.com/trinodb/trino/commit/525b75f14844372817ffc85e8d69b918b22e17e7", "committedDate": "2020-08-15T22:59:27Z", "message": "skip refresh\n\nskip refresh connector api calls when materialized view is fresh"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwNjkwMTI2", "url": "https://github.com/trinodb/trino/pull/3283#pullrequestreview-470690126", "createdAt": "2020-08-19T17:30:12Z", "commit": {"oid": "525b75f14844372817ffc85e8d69b918b22e17e7"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNzozMDoxMlrOHDSIew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxODoxODozNlrOHDTyhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwNDg1OQ==", "bodyText": "Let's make this more specific: isSkipMaterializedViewRefresh", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r473204859", "createdAt": "2020-08-19T17:30:12Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java", "diffHunk": "@@ -214,6 +215,16 @@ public void resetUpdateType()\n         this.target = Optional.empty();\n     }\n \n+    public boolean isSkipRefresh()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "525b75f14844372817ffc85e8d69b918b22e17e7"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwNzEyMw==", "bodyText": "First argument should go on the next line", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r473207123", "createdAt": "2020-08-19T17:34:05Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/execution/CreateMaterializedViewTask.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.security.AccessControl;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorMaterializedViewDefinition;\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.Analyzer;\n+import io.prestosql.sql.analyzer.FeaturesConfig;\n+import io.prestosql.sql.parser.SqlParser;\n+import io.prestosql.sql.tree.CreateMaterializedView;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.NodeRef;\n+import io.prestosql.sql.tree.Parameter;\n+import io.prestosql.sql.tree.Statement;\n+import io.prestosql.transaction.TransactionManager;\n+\n+import javax.inject.Inject;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n+import static io.prestosql.metadata.MetadataUtil.createQualifiedObjectName;\n+import static io.prestosql.spi.StandardErrorCode.NOT_FOUND;\n+import static io.prestosql.sql.NodeUtils.mapFromProperties;\n+import static io.prestosql.sql.ParameterUtils.parameterExtractor;\n+import static io.prestosql.sql.SqlFormatterUtil.getFormattedSql;\n+import static java.util.Objects.requireNonNull;\n+\n+public class CreateMaterializedViewTask\n+        implements DataDefinitionTask<CreateMaterializedView>\n+{\n+    private final SqlParser sqlParser;\n+\n+    @Inject\n+    public CreateMaterializedViewTask(SqlParser sqlParser, FeaturesConfig featuresConfig)\n+    {\n+        this.sqlParser = requireNonNull(sqlParser, \"sqlParser is null\");\n+        requireNonNull(featuresConfig, \"featuresConfig is null\");\n+    }\n+\n+    @Override\n+    public String getName()\n+    {\n+        return \"CREATE MATERIALIZED VIEW\";\n+    }\n+\n+    @Override\n+    public String explain(CreateMaterializedView statement, List<Expression> parameters)\n+    {\n+        return \"CREATE MATERIALIZED VIEW \" + statement.getName();\n+    }\n+\n+    @Override\n+    public ListenableFuture<?> execute(\n+            CreateMaterializedView statement,\n+            TransactionManager transactionManager,\n+            Metadata metadata,\n+            AccessControl accessControl,\n+            QueryStateMachine stateMachine,\n+            List<Expression> parameters)\n+    {\n+        Session session = stateMachine.getSession();\n+        QualifiedObjectName name = createQualifiedObjectName(session, statement, statement.getName());\n+        Map<NodeRef<Parameter>, Expression> parameterLookup = parameterExtractor(statement, parameters);\n+\n+        String sql = getFormattedSql(statement.getQuery(), sqlParser);\n+\n+        Analysis analysis = analyzeStatement(statement, session, metadata, accessControl, parameters, parameterLookup, stateMachine.getWarningCollector(), sql);\n+\n+        List<ConnectorMaterializedViewDefinition.Column> columns = analysis.getOutputDescriptor(statement.getQuery())\n+                .getVisibleFields().stream()\n+                .map(field -> new ConnectorMaterializedViewDefinition.Column(field.getName().get(), field.getType().getTypeId()))\n+                .collect(toImmutableList());\n+\n+        Optional<String> owner = Optional.of(session.getUser());\n+\n+        CatalogName catalogName = metadata.getCatalogHandle(session, name.getCatalogName())\n+                .orElseThrow(() -> new PrestoException(NOT_FOUND, \"Catalog does not exist: \" + name.getCatalogName()));\n+\n+        Map<String, Expression> sqlProperties = mapFromProperties(statement.getProperties());\n+        Map<String, Object> properties = metadata.getTablePropertyManager().getProperties(\n+                catalogName,\n+                name.getCatalogName(),\n+                sqlProperties,\n+                session,\n+                metadata,\n+                accessControl,\n+                parameterLookup);\n+\n+        ConnectorMaterializedViewDefinition definition = new ConnectorMaterializedViewDefinition(\n+                sql,\n+                null,\n+                session.getCatalog(),\n+                session.getSchema(),\n+                columns,\n+                statement.getComment(),\n+                owner,\n+                properties);\n+\n+        metadata.createMaterializedView(session, name, definition, statement.isReplace(), statement.isNotExists());\n+\n+        return immediateFuture(null);\n+    }\n+\n+    private Analysis analyzeStatement(Statement statement,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMjAwNQ==", "bodyText": "One argument per line when breaking across multiple lines", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r473232005", "createdAt": "2020-08-19T18:18:36Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/Metadata.java", "diffHunk": "@@ -264,6 +266,17 @@\n      */\n     Optional<ConnectorOutputMetadata> finishInsert(Session session, InsertTableHandle tableHandle, Collection<Slice> fragments, Collection<ComputedStatistics> computedStatistics);\n \n+    /**\n+     * Begin refresh materialized view query\n+     */\n+    InsertTableHandle beginRefreshMaterializedView(Session session, TableHandle tableHandle);\n+\n+    /**\n+     * Finish refresh materialized view query\n+     */\n+    Optional<ConnectorOutputMetadata> finishRefreshMaterializedView(Session session, InsertTableHandle tableHandle, Collection<Slice> fragments,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2OTY5Nzkz", "url": "https://github.com/trinodb/trino/pull/3283#pullrequestreview-476969793", "createdAt": "2020-08-27T18:17:00Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxODoxNzowMFrOHIb8IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxODoxOTowMFrOHIcAIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYwODQxNg==", "bodyText": "This isn't used in this PR. Let's remove it.", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r478608416", "createdAt": "2020-08-27T18:17:00Z", "author": {"login": "martint"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/util/HiveUtil.java", "diffHunk": "@@ -677,6 +682,23 @@ public static ConnectorViewDefinition decodeViewData(String data)\n         return VIEW_CODEC.fromJson(bytes);\n     }\n \n+    public static String encodeMaterializedViewData(ConnectorMaterializedViewDefinition definition)\n+    {\n+        byte[] bytes = MATERIALIZED_VIEW_CODEC.toJsonBytes(definition);\n+        String data = Base64.getEncoder().encodeToString(bytes);\n+        return MATERIALIZED_VIEW_PREFIX + data + MATERIALIZED_VIEW_SUFFIX;\n+    }\n+\n+    public static ConnectorMaterializedViewDefinition decodeMaterializedViewData(String data)\n+    {\n+        checkCondition(data.startsWith(MATERIALIZED_VIEW_PREFIX), HIVE_INVALID_VIEW_DATA, \"Materialized View data missing prefix: %s\", data);\n+        checkCondition(data.endsWith(MATERIALIZED_VIEW_SUFFIX), HIVE_INVALID_VIEW_DATA, \"Materialized View data missing suffix: %s\", data);\n+        data = data.substring(MATERIALIZED_VIEW_PREFIX.length());\n+        data = data.substring(0, data.length() - MATERIALIZED_VIEW_SUFFIX.length());\n+        byte[] bytes = Base64.getDecoder().decode(data);\n+        return MATERIALIZED_VIEW_CODEC.fromJson(bytes);\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYwOTQ0Mw==", "bodyText": "This isn't used. Let's remove it", "url": "https://github.com/trinodb/trino/pull/3283#discussion_r478609443", "createdAt": "2020-08-27T18:19:00Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/TableToken.java", "diffHunk": "@@ -0,0 +1,18 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+public interface TableToken", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "abc24ae6d9ca5450f1e5ce7ea30666fd40f46404", "author": {"user": {"login": "anjalinorwood", "name": "Anjali Norwood"}}, "url": "https://github.com/trinodb/trino/commit/abc24ae6d9ca5450f1e5ce7ea30666fd40f46404", "committedDate": "2020-08-31T20:32:51Z", "message": "Support Materialized Views\n\nThis commit adds support for Materialized Views in Presto engine.\nMuch like a logical view, a materialized view has a SQL query associated with it.\nUnlike logical view, it stores data corresponding to the SQL query.\n\nThe commit adds support for commands like CREATE MATERIALIZED VIEW, REFRESH MATERIALIZED VIEW,\nSHOW CREATE MATERIALIZED VIEW and DROP MATERIALIZED VIEW.\nThe commit adds support for reading data from a  materialized view when it is fresh with\nrespect to its underlying base tables. When a materialized view is stale with respect to its\nbase tables, the materialized view is resolved to base tables using the associated definition.\nQuerying the materialized view always returns the current/fresh data irrespective of the state\nof the materialized view.\n\nA materialized view is modeled as a combination of a SQL definition and a storage table\nthat holds the data.\n\nThe \u2018Refresh Materialized View\u2019 command is implemented as follows:\nREFRESH MATERIALIZED VIEW Implementation:\n+ Refresh materialized view operation is implemented as a table writer that drops partitions from,\n  deletes data from and inserts data into the storage table as needed. The source of the data is\n  the query associated with the materialized view.\n+ A new type of TableWriterOperator, \u2018RefreshMaterializedViewTarget\u2019 is implemented. This translates\n  into two connector API calls \u2018beginRefreshMaterializedView\u2019 and \u2018finishRefreshMaterializedView\u2019.\n+ StatementAnalyzer determines if the materialized view is fresh and sets the flag in Analysis.\n  If the materialized view is fresh, logical planner plans the refresh operation as a no-op.\n+ The \u2018beginRefreshMaterializedView\u2019 implementation for a connector is expected to do the following:\n  + Start a transaction\n  + Drop specified partitions of the storage table based on input parameters (applicable only\n    for incremental refresh of the materialized view)\n  + Delete data from specified partitions of the storage table or all of the data from the\n    storage table based on input parameters (applicable for incremental refresh and full refresh\n    respectively)\n  + Return a ConnectorInsertTableHandle\n+ The \u2018finishRefreshMaterializedView\u2019 implementation for a connector is expected to do the following:\n  + Insert data into the storage table based on parameters\n  + Store the table tokens for the base tables in the storage table\n  + Commit the transaction.\n+ Note that the refresh materialized view operation is performed in the scope of a single\n  transaction in the connector.\n\nAccess control:\nGiven that materialized views can be seen as a combination of a view and a table,\naccess control for a CREATE MATERIALIZED VIEW command is a combination of access\nchecks for CREATE TABLE and CREATE VIEW commands.\nSimilarly, a REFRESH MATERIALIZED VIEW command is a combination of DELETE and INSERT\noperations and access checks for this command is a combination of access checks\nfor DELETE and INSERT.\nLastly, a DROP MATERIALIZED VIEW access check is a combination of DROP TABLE and\nDROP VIEW command."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "abc24ae6d9ca5450f1e5ce7ea30666fd40f46404", "author": {"user": {"login": "anjalinorwood", "name": "Anjali Norwood"}}, "url": "https://github.com/trinodb/trino/commit/abc24ae6d9ca5450f1e5ce7ea30666fd40f46404", "committedDate": "2020-08-31T20:32:51Z", "message": "Support Materialized Views\n\nThis commit adds support for Materialized Views in Presto engine.\nMuch like a logical view, a materialized view has a SQL query associated with it.\nUnlike logical view, it stores data corresponding to the SQL query.\n\nThe commit adds support for commands like CREATE MATERIALIZED VIEW, REFRESH MATERIALIZED VIEW,\nSHOW CREATE MATERIALIZED VIEW and DROP MATERIALIZED VIEW.\nThe commit adds support for reading data from a  materialized view when it is fresh with\nrespect to its underlying base tables. When a materialized view is stale with respect to its\nbase tables, the materialized view is resolved to base tables using the associated definition.\nQuerying the materialized view always returns the current/fresh data irrespective of the state\nof the materialized view.\n\nA materialized view is modeled as a combination of a SQL definition and a storage table\nthat holds the data.\n\nThe \u2018Refresh Materialized View\u2019 command is implemented as follows:\nREFRESH MATERIALIZED VIEW Implementation:\n+ Refresh materialized view operation is implemented as a table writer that drops partitions from,\n  deletes data from and inserts data into the storage table as needed. The source of the data is\n  the query associated with the materialized view.\n+ A new type of TableWriterOperator, \u2018RefreshMaterializedViewTarget\u2019 is implemented. This translates\n  into two connector API calls \u2018beginRefreshMaterializedView\u2019 and \u2018finishRefreshMaterializedView\u2019.\n+ StatementAnalyzer determines if the materialized view is fresh and sets the flag in Analysis.\n  If the materialized view is fresh, logical planner plans the refresh operation as a no-op.\n+ The \u2018beginRefreshMaterializedView\u2019 implementation for a connector is expected to do the following:\n  + Start a transaction\n  + Drop specified partitions of the storage table based on input parameters (applicable only\n    for incremental refresh of the materialized view)\n  + Delete data from specified partitions of the storage table or all of the data from the\n    storage table based on input parameters (applicable for incremental refresh and full refresh\n    respectively)\n  + Return a ConnectorInsertTableHandle\n+ The \u2018finishRefreshMaterializedView\u2019 implementation for a connector is expected to do the following:\n  + Insert data into the storage table based on parameters\n  + Store the table tokens for the base tables in the storage table\n  + Commit the transaction.\n+ Note that the refresh materialized view operation is performed in the scope of a single\n  transaction in the connector.\n\nAccess control:\nGiven that materialized views can be seen as a combination of a view and a table,\naccess control for a CREATE MATERIALIZED VIEW command is a combination of access\nchecks for CREATE TABLE and CREATE VIEW commands.\nSimilarly, a REFRESH MATERIALIZED VIEW command is a combination of DELETE and INSERT\noperations and access checks for this command is a combination of access checks\nfor DELETE and INSERT.\nLastly, a DROP MATERIALIZED VIEW access check is a combination of DROP TABLE and\nDROP VIEW command."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2091, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}