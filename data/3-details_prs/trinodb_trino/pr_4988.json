{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczOTE1Mjg5", "number": 4988, "title": "Fetch dynamic filters continuously", "bodyText": "", "createdAt": "2020-08-26T13:40:20Z", "url": "https://github.com/trinodb/trino/pull/4988", "merged": true, "mergeCommit": {"oid": "fc80e630d85a4e59fe3363ee74db784e0d63c15e"}, "closed": true, "closedAt": "2020-09-16T09:09:04Z", "author": {"login": "sopel39"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdC_GthABqjM2OTkyNzE1NTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJZ5FgAFqTQ4OTQ5MTY1Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MjAwMzMw", "url": "https://github.com/trinodb/trino/pull/4988#pullrequestreview-488200330", "createdAt": "2020-09-14T22:32:11Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjozMjoxMVrOHRpmnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMzoyNDo0MVrOHRq-Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI2OTQ3MQ==", "bodyText": "This notification happens while holding a lock on this which is pretty dangerous.  Do you really want to do this?", "url": "https://github.com/trinodb/trino/pull/4988#discussion_r488269471", "createdAt": "2020-09-14T22:32:11Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/execution/DynamicFiltersCollector.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.lang.Math.max;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DynamicFiltersCollector\n+{\n+    public static final long INITIAL_DYNAMIC_FILTERS_VERSION = 0L;\n+    public static final VersionedDynamicFilterDomains INITIAL_DYNAMIC_FILTER_DOMAINS =\n+            new VersionedDynamicFilterDomains(INITIAL_DYNAMIC_FILTERS_VERSION, ImmutableMap.of());\n+\n+    private final Runnable notifyTaskStatusChanged;\n+    @GuardedBy(\"this\")\n+    private final Map<DynamicFilterId, VersionedDomain> dynamicFilterDomains = new HashMap<>();\n+    @GuardedBy(\"this\")\n+    private long currentVersion;\n+\n+    public DynamicFiltersCollector(Runnable notifyTaskStatusChanged)\n+    {\n+        this.notifyTaskStatusChanged = requireNonNull(notifyTaskStatusChanged, \"notifyTaskStatusChanged is null\");\n+    }\n+\n+    public synchronized void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> newDynamicFilterDomains)\n+    {\n+        if (newDynamicFilterDomains.isEmpty()) {\n+            return;\n+        }\n+\n+        long currentVersion = ++this.currentVersion;\n+        for (Map.Entry<DynamicFilterId, Domain> entry : newDynamicFilterDomains.entrySet()) {\n+            dynamicFilterDomains.merge(\n+                    entry.getKey(),\n+                    new VersionedDomain(currentVersion, entry.getValue().simplify()),\n+                    (oldDomain, newDomain) -> new VersionedDomain(\n+                            max(oldDomain.getVersion(), newDomain.getVersion()),\n+                            oldDomain.getDomain().intersect(newDomain.getDomain())));\n+        }\n+\n+        notifyTaskStatusChanged.run();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MDI3Mg==", "bodyText": "I would call this addDomains  or updateDomains... maybe mergeDomains", "url": "https://github.com/trinodb/trino/pull/4988#discussion_r488270272", "createdAt": "2020-09-14T22:33:15Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/execution/DynamicFiltersCollector.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.lang.Math.max;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DynamicFiltersCollector\n+{\n+    public static final long INITIAL_DYNAMIC_FILTERS_VERSION = 0L;\n+    public static final VersionedDynamicFilterDomains INITIAL_DYNAMIC_FILTER_DOMAINS =\n+            new VersionedDynamicFilterDomains(INITIAL_DYNAMIC_FILTERS_VERSION, ImmutableMap.of());\n+\n+    private final Runnable notifyTaskStatusChanged;\n+    @GuardedBy(\"this\")\n+    private final Map<DynamicFilterId, VersionedDomain> dynamicFilterDomains = new HashMap<>();\n+    @GuardedBy(\"this\")\n+    private long currentVersion;\n+\n+    public DynamicFiltersCollector(Runnable notifyTaskStatusChanged)\n+    {\n+        this.notifyTaskStatusChanged = requireNonNull(notifyTaskStatusChanged, \"notifyTaskStatusChanged is null\");\n+    }\n+\n+    public synchronized void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> newDynamicFilterDomains)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MTUwOA==", "bodyText": "You can verify this by throwing an exception on an old version... the client would need to be able to \"ignore\" the exception since it would be an old, out of order, request.  We do this in some of the APIs.", "url": "https://github.com/trinodb/trino/pull/4988#discussion_r488271508", "createdAt": "2020-09-14T22:34:55Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/execution/DynamicFiltersCollector.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.lang.Math.max;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DynamicFiltersCollector\n+{\n+    public static final long INITIAL_DYNAMIC_FILTERS_VERSION = 0L;\n+    public static final VersionedDynamicFilterDomains INITIAL_DYNAMIC_FILTER_DOMAINS =\n+            new VersionedDynamicFilterDomains(INITIAL_DYNAMIC_FILTERS_VERSION, ImmutableMap.of());\n+\n+    private final Runnable notifyTaskStatusChanged;\n+    @GuardedBy(\"this\")\n+    private final Map<DynamicFilterId, VersionedDomain> dynamicFilterDomains = new HashMap<>();\n+    @GuardedBy(\"this\")\n+    private long currentVersion;\n+\n+    public DynamicFiltersCollector(Runnable notifyTaskStatusChanged)\n+    {\n+        this.notifyTaskStatusChanged = requireNonNull(notifyTaskStatusChanged, \"notifyTaskStatusChanged is null\");\n+    }\n+\n+    public synchronized void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> newDynamicFilterDomains)\n+    {\n+        if (newDynamicFilterDomains.isEmpty()) {\n+            return;\n+        }\n+\n+        long currentVersion = ++this.currentVersion;\n+        for (Map.Entry<DynamicFilterId, Domain> entry : newDynamicFilterDomains.entrySet()) {\n+            dynamicFilterDomains.merge(\n+                    entry.getKey(),\n+                    new VersionedDomain(currentVersion, entry.getValue().simplify()),\n+                    (oldDomain, newDomain) -> new VersionedDomain(\n+                            max(oldDomain.getVersion(), newDomain.getVersion()),\n+                            oldDomain.getDomain().intersect(newDomain.getDomain())));\n+        }\n+\n+        notifyTaskStatusChanged.run();\n+    }\n+\n+    public synchronized long getDynamicFiltersVersion()\n+    {\n+        return currentVersion;\n+    }\n+\n+    public synchronized VersionedDynamicFilterDomains getDynamicFilterDomains(long callersCurrentVersion)\n+    {\n+        // Remove dynamic filter domains that are already received by caller.\n+        // This assumes there is only one dynamic filters consumer.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3Mjk5NA==", "bodyText": "Maybe name this something like acknowledgAndGetNewDomains or just getNewDomains... I'd like it to imply this is just the new domains, and it might be helpful to let people know this isn't a pure getter, so that is why I suggest adding acknowledge to the name", "url": "https://github.com/trinodb/trino/pull/4988#discussion_r488272994", "createdAt": "2020-09-14T22:36:38Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/execution/DynamicFiltersCollector.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.lang.Math.max;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DynamicFiltersCollector\n+{\n+    public static final long INITIAL_DYNAMIC_FILTERS_VERSION = 0L;\n+    public static final VersionedDynamicFilterDomains INITIAL_DYNAMIC_FILTER_DOMAINS =\n+            new VersionedDynamicFilterDomains(INITIAL_DYNAMIC_FILTERS_VERSION, ImmutableMap.of());\n+\n+    private final Runnable notifyTaskStatusChanged;\n+    @GuardedBy(\"this\")\n+    private final Map<DynamicFilterId, VersionedDomain> dynamicFilterDomains = new HashMap<>();\n+    @GuardedBy(\"this\")\n+    private long currentVersion;\n+\n+    public DynamicFiltersCollector(Runnable notifyTaskStatusChanged)\n+    {\n+        this.notifyTaskStatusChanged = requireNonNull(notifyTaskStatusChanged, \"notifyTaskStatusChanged is null\");\n+    }\n+\n+    public synchronized void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> newDynamicFilterDomains)\n+    {\n+        if (newDynamicFilterDomains.isEmpty()) {\n+            return;\n+        }\n+\n+        long currentVersion = ++this.currentVersion;\n+        for (Map.Entry<DynamicFilterId, Domain> entry : newDynamicFilterDomains.entrySet()) {\n+            dynamicFilterDomains.merge(\n+                    entry.getKey(),\n+                    new VersionedDomain(currentVersion, entry.getValue().simplify()),\n+                    (oldDomain, newDomain) -> new VersionedDomain(\n+                            max(oldDomain.getVersion(), newDomain.getVersion()),\n+                            oldDomain.getDomain().intersect(newDomain.getDomain())));\n+        }\n+\n+        notifyTaskStatusChanged.run();\n+    }\n+\n+    public synchronized long getDynamicFiltersVersion()\n+    {\n+        return currentVersion;\n+    }\n+\n+    public synchronized VersionedDynamicFilterDomains getDynamicFilterDomains(long callersCurrentVersion)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MzMzMA==", "bodyText": "Add a defensive copy", "url": "https://github.com/trinodb/trino/pull/4988#discussion_r488273330", "createdAt": "2020-09-14T22:37:04Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/execution/DynamicFiltersCollector.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.lang.Math.max;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DynamicFiltersCollector\n+{\n+    public static final long INITIAL_DYNAMIC_FILTERS_VERSION = 0L;\n+    public static final VersionedDynamicFilterDomains INITIAL_DYNAMIC_FILTER_DOMAINS =\n+            new VersionedDynamicFilterDomains(INITIAL_DYNAMIC_FILTERS_VERSION, ImmutableMap.of());\n+\n+    private final Runnable notifyTaskStatusChanged;\n+    @GuardedBy(\"this\")\n+    private final Map<DynamicFilterId, VersionedDomain> dynamicFilterDomains = new HashMap<>();\n+    @GuardedBy(\"this\")\n+    private long currentVersion;\n+\n+    public DynamicFiltersCollector(Runnable notifyTaskStatusChanged)\n+    {\n+        this.notifyTaskStatusChanged = requireNonNull(notifyTaskStatusChanged, \"notifyTaskStatusChanged is null\");\n+    }\n+\n+    public synchronized void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> newDynamicFilterDomains)\n+    {\n+        if (newDynamicFilterDomains.isEmpty()) {\n+            return;\n+        }\n+\n+        long currentVersion = ++this.currentVersion;\n+        for (Map.Entry<DynamicFilterId, Domain> entry : newDynamicFilterDomains.entrySet()) {\n+            dynamicFilterDomains.merge(\n+                    entry.getKey(),\n+                    new VersionedDomain(currentVersion, entry.getValue().simplify()),\n+                    (oldDomain, newDomain) -> new VersionedDomain(\n+                            max(oldDomain.getVersion(), newDomain.getVersion()),\n+                            oldDomain.getDomain().intersect(newDomain.getDomain())));\n+        }\n+\n+        notifyTaskStatusChanged.run();\n+    }\n+\n+    public synchronized long getDynamicFiltersVersion()\n+    {\n+        return currentVersion;\n+    }\n+\n+    public synchronized VersionedDynamicFilterDomains getDynamicFilterDomains(long callersCurrentVersion)\n+    {\n+        // Remove dynamic filter domains that are already received by caller.\n+        // This assumes there is only one dynamic filters consumer.\n+        dynamicFilterDomains.values().removeIf(domain -> domain.getVersion() <= callersCurrentVersion);\n+\n+        return new VersionedDynamicFilterDomains(\n+                currentVersion,\n+                dynamicFilterDomains.entrySet().stream()\n+                        .collect(toImmutableMap(Map.Entry::getKey, entry -> entry.getValue().getDomain())));\n+    }\n+\n+    public static class VersionedDynamicFilterDomains\n+    {\n+        private final long version;\n+        private final Map<DynamicFilterId, Domain> dynamicFilterDomains;\n+\n+        @JsonCreator\n+        public VersionedDynamicFilterDomains(long version, Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+        {\n+            this.version = version;\n+            this.dynamicFilterDomains = requireNonNull(dynamicFilterDomains, \"dynamicFilterDomains is null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3NDA0Mw==", "bodyText": "Same comment about naming", "url": "https://github.com/trinodb/trino/pull/4988#discussion_r488274043", "createdAt": "2020-09-14T22:37:52Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/execution/SqlTask.java", "diffHunk": "@@ -230,6 +228,22 @@ public TaskStatus getTaskStatus()\n         }\n     }\n \n+    public VersionedDynamicFilterDomains getDynamicFiltersDomains(long callersDynamicFiltersVersion)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3OTQ4Mw==", "bodyText": "Verify the value is >= INITIAL_DYNAMIC_FILTERS_VERSION", "url": "https://github.com/trinodb/trino/pull/4988#discussion_r488279483", "createdAt": "2020-09-14T22:45:40Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/execution/TaskStatus.java", "diffHunk": "@@ -121,7 +118,7 @@ public TaskStatus(\n         checkArgument(fullGcCount >= 0, \"fullGcCount is negative\");\n         this.fullGcCount = fullGcCount;\n         this.fullGcTime = requireNonNull(fullGcTime, \"fullGcTime is null\");\n-        this.dynamicFilterDomains = ImmutableMap.copyOf(requireNonNull(dynamicFilterDomains, \"dynamicFilterDomains is null\"));\n+        this.dynamicFiltersVersion = dynamicFiltersVersion;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3OTk0MA==", "bodyText": "same comments about naming, except these need DF in the name", "url": "https://github.com/trinodb/trino/pull/4988#discussion_r488279940", "createdAt": "2020-09-14T22:46:57Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/TaskContext.java", "diffHunk": "@@ -395,16 +394,19 @@ public int getFullGcCount()\n         return toIntExact(max(0, endFullGcCount - startFullGcCount));\n     }\n \n-    public synchronized void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilterDomains)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4MjI3MA==", "bodyText": "static import JsonResponse", "url": "https://github.com/trinodb/trino/pull/4988#discussion_r488282270", "createdAt": "2020-09-14T22:53:48Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/server/remotetask/DynamicFiltersFetcher.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.remotetask;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.airlift.concurrent.SetThreadName;\n+import io.airlift.http.client.FullJsonResponseHandler;\n+import io.airlift.http.client.HttpClient;\n+import io.airlift.http.client.Request;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.units.Duration;\n+import io.prestosql.execution.DynamicFiltersCollector.VersionedDynamicFilterDomains;\n+import io.prestosql.execution.TaskId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.net.URI;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Streams.concat;\n+import static com.google.common.net.HttpHeaders.CONTENT_TYPE;\n+import static com.google.common.net.MediaType.JSON_UTF_8;\n+import static io.airlift.http.client.FullJsonResponseHandler.createFullJsonResponseHandler;\n+import static io.airlift.http.client.HttpUriBuilder.uriBuilderFrom;\n+import static io.airlift.http.client.Request.Builder.prepareGet;\n+import static io.airlift.units.Duration.nanosSince;\n+import static io.prestosql.client.PrestoHeaders.PRESTO_CURRENT_VERSION;\n+import static io.prestosql.client.PrestoHeaders.PRESTO_MAX_WAIT;\n+import static io.prestosql.execution.DynamicFiltersCollector.INITIAL_DYNAMIC_FILTERS_VERSION;\n+import static java.util.Objects.requireNonNull;\n+\n+class DynamicFiltersFetcher\n+        implements SimpleHttpResponseCallback<VersionedDynamicFilterDomains>\n+{\n+    private final TaskId taskId;\n+    private final URI taskUri;\n+    private final Consumer<Throwable> onFail;\n+    private final JsonCodec<VersionedDynamicFilterDomains> dynamicFilterDomainsCodec;\n+    private final Duration refreshMaxWait;\n+    private final Executor executor;\n+    private final HttpClient httpClient;\n+    private final RequestErrorTracker errorTracker;\n+    private final RemoteTaskStats stats;\n+    private final AtomicLong currentRequestStartNanos = new AtomicLong();\n+\n+    @GuardedBy(\"this\")\n+    private long dynamicFiltersVersion = INITIAL_DYNAMIC_FILTERS_VERSION;\n+    @GuardedBy(\"this\")\n+    private long localDynamicFiltersVersion;\n+    @GuardedBy(\"this\")\n+    private Map<DynamicFilterId, Domain> dynamicFilterDomains = ImmutableMap.of();\n+    @GuardedBy(\"this\")\n+    private boolean running;\n+    @GuardedBy(\"this\")\n+    private ListenableFuture<FullJsonResponseHandler.JsonResponse<VersionedDynamicFilterDomains>> future;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NTYxNw==", "bodyText": "Should this be initialized to INITIAL_DYNAMIC_FILTERS_VERSION?", "url": "https://github.com/trinodb/trino/pull/4988#discussion_r488285617", "createdAt": "2020-09-14T23:04:06Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/server/remotetask/DynamicFiltersFetcher.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.remotetask;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.airlift.concurrent.SetThreadName;\n+import io.airlift.http.client.FullJsonResponseHandler;\n+import io.airlift.http.client.HttpClient;\n+import io.airlift.http.client.Request;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.units.Duration;\n+import io.prestosql.execution.DynamicFiltersCollector.VersionedDynamicFilterDomains;\n+import io.prestosql.execution.TaskId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.net.URI;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Streams.concat;\n+import static com.google.common.net.HttpHeaders.CONTENT_TYPE;\n+import static com.google.common.net.MediaType.JSON_UTF_8;\n+import static io.airlift.http.client.FullJsonResponseHandler.createFullJsonResponseHandler;\n+import static io.airlift.http.client.HttpUriBuilder.uriBuilderFrom;\n+import static io.airlift.http.client.Request.Builder.prepareGet;\n+import static io.airlift.units.Duration.nanosSince;\n+import static io.prestosql.client.PrestoHeaders.PRESTO_CURRENT_VERSION;\n+import static io.prestosql.client.PrestoHeaders.PRESTO_MAX_WAIT;\n+import static io.prestosql.execution.DynamicFiltersCollector.INITIAL_DYNAMIC_FILTERS_VERSION;\n+import static java.util.Objects.requireNonNull;\n+\n+class DynamicFiltersFetcher\n+        implements SimpleHttpResponseCallback<VersionedDynamicFilterDomains>\n+{\n+    private final TaskId taskId;\n+    private final URI taskUri;\n+    private final Consumer<Throwable> onFail;\n+    private final JsonCodec<VersionedDynamicFilterDomains> dynamicFilterDomainsCodec;\n+    private final Duration refreshMaxWait;\n+    private final Executor executor;\n+    private final HttpClient httpClient;\n+    private final RequestErrorTracker errorTracker;\n+    private final RemoteTaskStats stats;\n+    private final AtomicLong currentRequestStartNanos = new AtomicLong();\n+\n+    @GuardedBy(\"this\")\n+    private long dynamicFiltersVersion = INITIAL_DYNAMIC_FILTERS_VERSION;\n+    @GuardedBy(\"this\")\n+    private long localDynamicFiltersVersion;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NTc4OQ==", "bodyText": "static import", "url": "https://github.com/trinodb/trino/pull/4988#discussion_r488285789", "createdAt": "2020-09-14T23:04:39Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/server/remotetask/DynamicFiltersFetcher.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.remotetask;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.airlift.concurrent.SetThreadName;\n+import io.airlift.http.client.FullJsonResponseHandler;\n+import io.airlift.http.client.HttpClient;\n+import io.airlift.http.client.Request;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.units.Duration;\n+import io.prestosql.execution.DynamicFiltersCollector.VersionedDynamicFilterDomains;\n+import io.prestosql.execution.TaskId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.net.URI;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Streams.concat;\n+import static com.google.common.net.HttpHeaders.CONTENT_TYPE;\n+import static com.google.common.net.MediaType.JSON_UTF_8;\n+import static io.airlift.http.client.FullJsonResponseHandler.createFullJsonResponseHandler;\n+import static io.airlift.http.client.HttpUriBuilder.uriBuilderFrom;\n+import static io.airlift.http.client.Request.Builder.prepareGet;\n+import static io.airlift.units.Duration.nanosSince;\n+import static io.prestosql.client.PrestoHeaders.PRESTO_CURRENT_VERSION;\n+import static io.prestosql.client.PrestoHeaders.PRESTO_MAX_WAIT;\n+import static io.prestosql.execution.DynamicFiltersCollector.INITIAL_DYNAMIC_FILTERS_VERSION;\n+import static java.util.Objects.requireNonNull;\n+\n+class DynamicFiltersFetcher\n+        implements SimpleHttpResponseCallback<VersionedDynamicFilterDomains>\n+{\n+    private final TaskId taskId;\n+    private final URI taskUri;\n+    private final Consumer<Throwable> onFail;\n+    private final JsonCodec<VersionedDynamicFilterDomains> dynamicFilterDomainsCodec;\n+    private final Duration refreshMaxWait;\n+    private final Executor executor;\n+    private final HttpClient httpClient;\n+    private final RequestErrorTracker errorTracker;\n+    private final RemoteTaskStats stats;\n+    private final AtomicLong currentRequestStartNanos = new AtomicLong();\n+\n+    @GuardedBy(\"this\")\n+    private long dynamicFiltersVersion = INITIAL_DYNAMIC_FILTERS_VERSION;\n+    @GuardedBy(\"this\")\n+    private long localDynamicFiltersVersion;\n+    @GuardedBy(\"this\")\n+    private Map<DynamicFilterId, Domain> dynamicFilterDomains = ImmutableMap.of();\n+    @GuardedBy(\"this\")\n+    private boolean running;\n+    @GuardedBy(\"this\")\n+    private ListenableFuture<FullJsonResponseHandler.JsonResponse<VersionedDynamicFilterDomains>> future;\n+\n+    public DynamicFiltersFetcher(\n+            Consumer<Throwable> onFail,\n+            TaskId taskId,\n+            URI taskUri,\n+            Duration refreshMaxWait,\n+            JsonCodec<VersionedDynamicFilterDomains> dynamicFilterDomainsCodec,\n+            Executor executor,\n+            HttpClient httpClient,\n+            Duration maxErrorDuration,\n+            ScheduledExecutorService errorScheduledExecutor,\n+            RemoteTaskStats stats)\n+    {\n+        this.taskId = requireNonNull(taskId, \"taskId is null\");\n+        this.taskUri = requireNonNull(taskUri, \"taskUri is null\");\n+        this.onFail = requireNonNull(onFail, \"onFail is null\");\n+\n+        this.refreshMaxWait = requireNonNull(refreshMaxWait, \"refreshMaxWait is null\");\n+        this.dynamicFilterDomainsCodec = requireNonNull(dynamicFilterDomainsCodec, \"dynamicFilterDomainsCodec is null\");\n+\n+        this.executor = requireNonNull(executor, \"executor is null\");\n+        this.httpClient = requireNonNull(httpClient, \"httpClient is null\");\n+\n+        this.errorTracker = new RequestErrorTracker(taskId, taskUri, maxErrorDuration, errorScheduledExecutor, \"getting dynamic filter domains\");\n+        this.stats = requireNonNull(stats, \"stats is null\");\n+    }\n+\n+    public synchronized void start()\n+    {\n+        if (running) {\n+            // already running\n+            return;\n+        }\n+        running = true;\n+        scheduleNextRequestIfNecessary();\n+    }\n+\n+    public synchronized void stop()\n+    {\n+        running = false;\n+        if (future != null) {\n+            future.cancel(true);\n+            future = null;\n+        }\n+    }\n+\n+    public synchronized Map<DynamicFilterId, Domain> getDynamicFilterDomains()\n+    {\n+        return dynamicFilterDomains;\n+    }\n+\n+    public synchronized void updateDynamicFiltersVersion(long newDynamicFiltersVersion)\n+    {\n+        if (dynamicFiltersVersion >= newDynamicFiltersVersion) {\n+            return;\n+        }\n+\n+        dynamicFiltersVersion = newDynamicFiltersVersion;\n+        scheduleNextRequestIfNecessary();\n+    }\n+\n+    private synchronized void scheduleNextRequestIfNecessary()\n+    {\n+        // stopped?\n+        if (!running) {\n+            return;\n+        }\n+\n+        // local dynamic filters are up to date\n+        if (localDynamicFiltersVersion >= dynamicFiltersVersion) {\n+            return;\n+        }\n+\n+        // outstanding request?\n+        if (future != null && !future.isDone()) {\n+            return;\n+        }\n+\n+        // if throttled due to error, asynchronously wait for timeout and try again\n+        ListenableFuture<?> errorRateLimit = errorTracker.acquireRequestPermit();\n+        if (!errorRateLimit.isDone()) {\n+            errorRateLimit.addListener(this::scheduleNextRequestIfNecessary, executor);\n+            return;\n+        }\n+\n+        Request request = prepareGet()\n+                .setUri(uriBuilderFrom(taskUri).appendPath(\"dynamicfilters\").build())\n+                .setHeader(CONTENT_TYPE, JSON_UTF_8.toString())\n+                .setHeader(PRESTO_CURRENT_VERSION, Long.toString(localDynamicFiltersVersion))\n+                .setHeader(PRESTO_MAX_WAIT, refreshMaxWait.toString())\n+                .build();\n+\n+        errorTracker.startRequest();\n+        future = httpClient.executeAsync(request, createFullJsonResponseHandler(dynamicFilterDomainsCodec));\n+        currentRequestStartNanos.set(System.nanoTime());\n+        Futures.addCallback(future, new SimpleHttpResponseHandler<>(this, request.getUri(), stats), executor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NzUxMQ==", "bodyText": "I would name this \"fetchDynamicFilterIfNecessary\".. This name is used for the continuous fetchers, so seems a little misleading here.", "url": "https://github.com/trinodb/trino/pull/4988#discussion_r488287511", "createdAt": "2020-09-14T23:10:03Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/server/remotetask/DynamicFiltersFetcher.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.remotetask;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.airlift.concurrent.SetThreadName;\n+import io.airlift.http.client.FullJsonResponseHandler;\n+import io.airlift.http.client.HttpClient;\n+import io.airlift.http.client.Request;\n+import io.airlift.json.JsonCodec;\n+import io.airlift.units.Duration;\n+import io.prestosql.execution.DynamicFiltersCollector.VersionedDynamicFilterDomains;\n+import io.prestosql.execution.TaskId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.net.URI;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Streams.concat;\n+import static com.google.common.net.HttpHeaders.CONTENT_TYPE;\n+import static com.google.common.net.MediaType.JSON_UTF_8;\n+import static io.airlift.http.client.FullJsonResponseHandler.createFullJsonResponseHandler;\n+import static io.airlift.http.client.HttpUriBuilder.uriBuilderFrom;\n+import static io.airlift.http.client.Request.Builder.prepareGet;\n+import static io.airlift.units.Duration.nanosSince;\n+import static io.prestosql.client.PrestoHeaders.PRESTO_CURRENT_VERSION;\n+import static io.prestosql.client.PrestoHeaders.PRESTO_MAX_WAIT;\n+import static io.prestosql.execution.DynamicFiltersCollector.INITIAL_DYNAMIC_FILTERS_VERSION;\n+import static java.util.Objects.requireNonNull;\n+\n+class DynamicFiltersFetcher\n+        implements SimpleHttpResponseCallback<VersionedDynamicFilterDomains>\n+{\n+    private final TaskId taskId;\n+    private final URI taskUri;\n+    private final Consumer<Throwable> onFail;\n+    private final JsonCodec<VersionedDynamicFilterDomains> dynamicFilterDomainsCodec;\n+    private final Duration refreshMaxWait;\n+    private final Executor executor;\n+    private final HttpClient httpClient;\n+    private final RequestErrorTracker errorTracker;\n+    private final RemoteTaskStats stats;\n+    private final AtomicLong currentRequestStartNanos = new AtomicLong();\n+\n+    @GuardedBy(\"this\")\n+    private long dynamicFiltersVersion = INITIAL_DYNAMIC_FILTERS_VERSION;\n+    @GuardedBy(\"this\")\n+    private long localDynamicFiltersVersion;\n+    @GuardedBy(\"this\")\n+    private Map<DynamicFilterId, Domain> dynamicFilterDomains = ImmutableMap.of();\n+    @GuardedBy(\"this\")\n+    private boolean running;\n+    @GuardedBy(\"this\")\n+    private ListenableFuture<FullJsonResponseHandler.JsonResponse<VersionedDynamicFilterDomains>> future;\n+\n+    public DynamicFiltersFetcher(\n+            Consumer<Throwable> onFail,\n+            TaskId taskId,\n+            URI taskUri,\n+            Duration refreshMaxWait,\n+            JsonCodec<VersionedDynamicFilterDomains> dynamicFilterDomainsCodec,\n+            Executor executor,\n+            HttpClient httpClient,\n+            Duration maxErrorDuration,\n+            ScheduledExecutorService errorScheduledExecutor,\n+            RemoteTaskStats stats)\n+    {\n+        this.taskId = requireNonNull(taskId, \"taskId is null\");\n+        this.taskUri = requireNonNull(taskUri, \"taskUri is null\");\n+        this.onFail = requireNonNull(onFail, \"onFail is null\");\n+\n+        this.refreshMaxWait = requireNonNull(refreshMaxWait, \"refreshMaxWait is null\");\n+        this.dynamicFilterDomainsCodec = requireNonNull(dynamicFilterDomainsCodec, \"dynamicFilterDomainsCodec is null\");\n+\n+        this.executor = requireNonNull(executor, \"executor is null\");\n+        this.httpClient = requireNonNull(httpClient, \"httpClient is null\");\n+\n+        this.errorTracker = new RequestErrorTracker(taskId, taskUri, maxErrorDuration, errorScheduledExecutor, \"getting dynamic filter domains\");\n+        this.stats = requireNonNull(stats, \"stats is null\");\n+    }\n+\n+    public synchronized void start()\n+    {\n+        if (running) {\n+            // already running\n+            return;\n+        }\n+        running = true;\n+        scheduleNextRequestIfNecessary();\n+    }\n+\n+    public synchronized void stop()\n+    {\n+        running = false;\n+        if (future != null) {\n+            future.cancel(true);\n+            future = null;\n+        }\n+    }\n+\n+    public synchronized Map<DynamicFilterId, Domain> getDynamicFilterDomains()\n+    {\n+        return dynamicFilterDomains;\n+    }\n+\n+    public synchronized void updateDynamicFiltersVersion(long newDynamicFiltersVersion)\n+    {\n+        if (dynamicFiltersVersion >= newDynamicFiltersVersion) {\n+            return;\n+        }\n+\n+        dynamicFiltersVersion = newDynamicFiltersVersion;\n+        scheduleNextRequestIfNecessary();\n+    }\n+\n+    private synchronized void scheduleNextRequestIfNecessary()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5MTkzMQ==", "bodyText": "This one of these calls should have a new value in addition to  an existing value.  With this code, the implementation could simply ignore the updates and the test would still work.", "url": "https://github.com/trinodb/trino/pull/4988#discussion_r488291931", "createdAt": "2020-09-14T23:24:41Z", "author": {"login": "dain"}, "path": "presto-main/src/test/java/io/prestosql/execution/TestDynamicFiltersCollector.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.execution.DynamicFiltersCollector.VersionedDynamicFilterDomains;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n+import org.testng.annotations.Test;\n+\n+import static io.prestosql.execution.DynamicFiltersCollector.INITIAL_DYNAMIC_FILTERS_VERSION;\n+import static io.prestosql.spi.predicate.Domain.multipleValues;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestDynamicFiltersCollector\n+{\n+    @Test\n+    public void testDynamicFiltersCollector()\n+    {\n+        DynamicFilterId filter = new DynamicFilterId(\"filter\");\n+        DynamicFiltersCollector collector = new DynamicFiltersCollector(() -> {});\n+\n+        VersionedDynamicFilterDomains domains = collector.getDynamicFilterDomains(INITIAL_DYNAMIC_FILTERS_VERSION);\n+\n+        // there should be no domains initially\n+        assertEquals(domains.getVersion(), INITIAL_DYNAMIC_FILTERS_VERSION);\n+        assertEquals(domains.getDynamicFilterDomains(), ImmutableMap.of());\n+\n+        Domain initialDomain = multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L));\n+        collector.collectDynamicFilterDomains(ImmutableMap.of(filter, initialDomain));\n+\n+        domains = collector.getDynamicFilterDomains(INITIAL_DYNAMIC_FILTERS_VERSION);\n+        assertEquals(domains.getVersion(), 1L);\n+        assertEquals(domains.getDynamicFilterDomains(), ImmutableMap.of(filter, initialDomain));\n+\n+        // make sure domains are still available when requested again with old version\n+        domains = collector.getDynamicFilterDomains(INITIAL_DYNAMIC_FILTERS_VERSION);\n+        assertEquals(domains.getVersion(), 1L);\n+        assertEquals(domains.getDynamicFilterDomains(), ImmutableMap.of(filter, initialDomain));\n+\n+        // make sure domains are intersected\n+        collector.collectDynamicFilterDomains(ImmutableMap.of(filter, multipleValues(BIGINT, ImmutableList.of(2L))));\n+        collector.collectDynamicFilterDomains(ImmutableMap.of(filter, multipleValues(BIGINT, ImmutableList.of(3L))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 57}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4NzMwNTEy", "url": "https://github.com/trinodb/trino/pull/4988#pullrequestreview-488730512", "createdAt": "2020-09-15T14:15:11Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNDoxNToxMlrOHSEC5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNDoyODowMFrOHSEq4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODcwMjY5NQ==", "bodyText": "moved outside of synchronized section", "url": "https://github.com/trinodb/trino/pull/4988#discussion_r488702695", "createdAt": "2020-09-15T14:15:12Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/execution/DynamicFiltersCollector.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.lang.Math.max;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DynamicFiltersCollector\n+{\n+    public static final long INITIAL_DYNAMIC_FILTERS_VERSION = 0L;\n+    public static final VersionedDynamicFilterDomains INITIAL_DYNAMIC_FILTER_DOMAINS =\n+            new VersionedDynamicFilterDomains(INITIAL_DYNAMIC_FILTERS_VERSION, ImmutableMap.of());\n+\n+    private final Runnable notifyTaskStatusChanged;\n+    @GuardedBy(\"this\")\n+    private final Map<DynamicFilterId, VersionedDomain> dynamicFilterDomains = new HashMap<>();\n+    @GuardedBy(\"this\")\n+    private long currentVersion;\n+\n+    public DynamicFiltersCollector(Runnable notifyTaskStatusChanged)\n+    {\n+        this.notifyTaskStatusChanged = requireNonNull(notifyTaskStatusChanged, \"notifyTaskStatusChanged is null\");\n+    }\n+\n+    public synchronized void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> newDynamicFilterDomains)\n+    {\n+        if (newDynamicFilterDomains.isEmpty()) {\n+            return;\n+        }\n+\n+        long currentVersion = ++this.currentVersion;\n+        for (Map.Entry<DynamicFilterId, Domain> entry : newDynamicFilterDomains.entrySet()) {\n+            dynamicFilterDomains.merge(\n+                    entry.getKey(),\n+                    new VersionedDomain(currentVersion, entry.getValue().simplify()),\n+                    (oldDomain, newDomain) -> new VersionedDomain(\n+                            max(oldDomain.getVersion(), newDomain.getVersion()),\n+                            oldDomain.getDomain().intersect(newDomain.getDomain())));\n+        }\n+\n+        notifyTaskStatusChanged.run();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI2OTQ3MQ=="}, "originalCommit": null, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODcxMjkzMQ==", "bodyText": "Old callersCurrentVersion is fine. Here we return DF delta between callersCurrentVersion and currentVersion.\nI guess for the exception you mean we would also need to store max observed callersCurrentVersion here to see if any older request comes. I'm not sure extra state is worth it though.", "url": "https://github.com/trinodb/trino/pull/4988#discussion_r488712931", "createdAt": "2020-09-15T14:28:00Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/execution/DynamicFiltersCollector.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.lang.Math.max;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DynamicFiltersCollector\n+{\n+    public static final long INITIAL_DYNAMIC_FILTERS_VERSION = 0L;\n+    public static final VersionedDynamicFilterDomains INITIAL_DYNAMIC_FILTER_DOMAINS =\n+            new VersionedDynamicFilterDomains(INITIAL_DYNAMIC_FILTERS_VERSION, ImmutableMap.of());\n+\n+    private final Runnable notifyTaskStatusChanged;\n+    @GuardedBy(\"this\")\n+    private final Map<DynamicFilterId, VersionedDomain> dynamicFilterDomains = new HashMap<>();\n+    @GuardedBy(\"this\")\n+    private long currentVersion;\n+\n+    public DynamicFiltersCollector(Runnable notifyTaskStatusChanged)\n+    {\n+        this.notifyTaskStatusChanged = requireNonNull(notifyTaskStatusChanged, \"notifyTaskStatusChanged is null\");\n+    }\n+\n+    public synchronized void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> newDynamicFilterDomains)\n+    {\n+        if (newDynamicFilterDomains.isEmpty()) {\n+            return;\n+        }\n+\n+        long currentVersion = ++this.currentVersion;\n+        for (Map.Entry<DynamicFilterId, Domain> entry : newDynamicFilterDomains.entrySet()) {\n+            dynamicFilterDomains.merge(\n+                    entry.getKey(),\n+                    new VersionedDomain(currentVersion, entry.getValue().simplify()),\n+                    (oldDomain, newDomain) -> new VersionedDomain(\n+                            max(oldDomain.getVersion(), newDomain.getVersion()),\n+                            oldDomain.getDomain().intersect(newDomain.getDomain())));\n+        }\n+\n+        notifyTaskStatusChanged.run();\n+    }\n+\n+    public synchronized long getDynamicFiltersVersion()\n+    {\n+        return currentVersion;\n+    }\n+\n+    public synchronized VersionedDynamicFilterDomains getDynamicFilterDomains(long callersCurrentVersion)\n+    {\n+        // Remove dynamic filter domains that are already received by caller.\n+        // This assumes there is only one dynamic filters consumer.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MTUwOA=="}, "originalCommit": null, "originalPosition": 75}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5MTc3Njg2", "url": "https://github.com/trinodb/trino/pull/4988#pullrequestreview-489177686", "createdAt": "2020-09-15T23:37:51Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMzozNzo1MVrOHSa3lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMzozNzo1MVrOHSa3lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA3NjYyOQ==", "bodyText": "I don't feel strongly, just pointing out the alternative.", "url": "https://github.com/trinodb/trino/pull/4988#discussion_r489076629", "createdAt": "2020-09-15T23:37:51Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/execution/DynamicFiltersCollector.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.lang.Math.max;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DynamicFiltersCollector\n+{\n+    public static final long INITIAL_DYNAMIC_FILTERS_VERSION = 0L;\n+    public static final VersionedDynamicFilterDomains INITIAL_DYNAMIC_FILTER_DOMAINS =\n+            new VersionedDynamicFilterDomains(INITIAL_DYNAMIC_FILTERS_VERSION, ImmutableMap.of());\n+\n+    private final Runnable notifyTaskStatusChanged;\n+    @GuardedBy(\"this\")\n+    private final Map<DynamicFilterId, VersionedDomain> dynamicFilterDomains = new HashMap<>();\n+    @GuardedBy(\"this\")\n+    private long currentVersion;\n+\n+    public DynamicFiltersCollector(Runnable notifyTaskStatusChanged)\n+    {\n+        this.notifyTaskStatusChanged = requireNonNull(notifyTaskStatusChanged, \"notifyTaskStatusChanged is null\");\n+    }\n+\n+    public synchronized void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> newDynamicFilterDomains)\n+    {\n+        if (newDynamicFilterDomains.isEmpty()) {\n+            return;\n+        }\n+\n+        long currentVersion = ++this.currentVersion;\n+        for (Map.Entry<DynamicFilterId, Domain> entry : newDynamicFilterDomains.entrySet()) {\n+            dynamicFilterDomains.merge(\n+                    entry.getKey(),\n+                    new VersionedDomain(currentVersion, entry.getValue().simplify()),\n+                    (oldDomain, newDomain) -> new VersionedDomain(\n+                            max(oldDomain.getVersion(), newDomain.getVersion()),\n+                            oldDomain.getDomain().intersect(newDomain.getDomain())));\n+        }\n+\n+        notifyTaskStatusChanged.run();\n+    }\n+\n+    public synchronized long getDynamicFiltersVersion()\n+    {\n+        return currentVersion;\n+    }\n+\n+    public synchronized VersionedDynamicFilterDomains getDynamicFilterDomains(long callersCurrentVersion)\n+    {\n+        // Remove dynamic filter domains that are already received by caller.\n+        // This assumes there is only one dynamic filters consumer.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MTUwOA=="}, "originalCommit": null, "originalPosition": 75}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd0bdcbc448c237eec883af638439d9cfb893416", "author": {"user": {"login": "ssquan", "name": "Quan Shi"}}, "url": "https://github.com/trinodb/trino/commit/fd0bdcbc448c237eec883af638439d9cfb893416", "committedDate": "2020-09-16T09:03:05Z", "message": "Fetch dynamic filters continuously\n\nA new task resource endpoint is added\nthat provides task collected dynamic filters.\nDynamic filters are versioned and only\nnew dynamic filters are returned.\nDynamic filters version is obtained continuously\nas part of TaskStatus request."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "fd0bdcbc448c237eec883af638439d9cfb893416", "author": {"user": {"login": "ssquan", "name": "Quan Shi"}}, "url": "https://github.com/trinodb/trino/commit/fd0bdcbc448c237eec883af638439d9cfb893416", "committedDate": "2020-09-16T09:03:05Z", "message": "Fetch dynamic filters continuously\n\nA new task resource endpoint is added\nthat provides task collected dynamic filters.\nDynamic filters are versioned and only\nnew dynamic filters are returned.\nDynamic filters version is obtained continuously\nas part of TaskStatus request."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5NDkxNjUy", "url": "https://github.com/trinodb/trino/pull/4988#pullrequestreview-489491652", "createdAt": "2020-09-16T10:32:31Z", "commit": {"oid": "fd0bdcbc448c237eec883af638439d9cfb893416"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDozMjozMVrOHSqqMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMDozMjozMVrOHSqqMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMzNTM0Ng==", "bodyText": "should there be simplify after intersect too?", "url": "https://github.com/trinodb/trino/pull/4988#discussion_r489335346", "createdAt": "2020-09-16T10:32:31Z", "author": {"login": "rohangarg"}, "path": "presto-main/src/main/java/io/prestosql/execution/DynamicFiltersCollector.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.lang.Math.max;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DynamicFiltersCollector\n+{\n+    public static final long INITIAL_DYNAMIC_FILTERS_VERSION = 0L;\n+    public static final VersionedDynamicFilterDomains INITIAL_DYNAMIC_FILTER_DOMAINS =\n+            new VersionedDynamicFilterDomains(INITIAL_DYNAMIC_FILTERS_VERSION, ImmutableMap.of());\n+\n+    private final Runnable notifyTaskStatusChanged;\n+    @GuardedBy(\"this\")\n+    private final Map<DynamicFilterId, VersionedDomain> dynamicFilterDomains = new HashMap<>();\n+    @GuardedBy(\"this\")\n+    private long currentVersion;\n+\n+    public DynamicFiltersCollector(Runnable notifyTaskStatusChanged)\n+    {\n+        this.notifyTaskStatusChanged = requireNonNull(notifyTaskStatusChanged, \"notifyTaskStatusChanged is null\");\n+    }\n+\n+    public void updateDomains(Map<DynamicFilterId, Domain> newDynamicFilterDomains)\n+    {\n+        if (newDynamicFilterDomains.isEmpty()) {\n+            return;\n+        }\n+\n+        synchronized (this) {\n+            long currentVersion = ++this.currentVersion;\n+            for (Map.Entry<DynamicFilterId, Domain> entry : newDynamicFilterDomains.entrySet()) {\n+                dynamicFilterDomains.merge(\n+                        entry.getKey(),\n+                        new VersionedDomain(currentVersion, entry.getValue().simplify()),\n+                        (oldDomain, newDomain) -> new VersionedDomain(\n+                                max(oldDomain.getVersion(), newDomain.getVersion()),\n+                                oldDomain.getDomain().intersect(newDomain.getDomain())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd0bdcbc448c237eec883af638439d9cfb893416"}, "originalPosition": 62}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4196, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}