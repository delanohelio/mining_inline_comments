{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2ODIwNzEw", "number": 2619, "title": "Flattening optimizer for set operations", "bodyText": "Purpose\nMigrate legacy SetFlatteningOptimizer to new rule.\nSee: #811\nOverview\n\nAdd MergeUnion\nAdd MergeIntersect\nAdd MergeExcept\nAdd PruneDistrinctAggregation", "createdAt": "2020-01-24T12:46:39Z", "url": "https://github.com/trinodb/trino/pull/2619", "merged": true, "mergeCommit": {"oid": "eb220d466f228601ff3b0b749bf84495c45b90f7"}, "closed": true, "closedAt": "2020-05-15T16:36:51Z", "author": {"login": "Lewuathe"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb9kGXtgFqTM0ODE2MzY4OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABchiSqCABqjMzNDA5ODA0Mzk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MTYzNjg4", "url": "https://github.com/trinodb/trino/pull/2619#pullrequestreview-348163688", "createdAt": "2020-01-24T19:08:17Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxOTowODoxOFrOFhnitw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxOToyNzo0MVrOFhoD-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc5NTE5MQ==", "bodyText": "I'd call this MergeIntersect", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r370795191", "createdAt": "2020-01-24T19:08:18Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/FlatteningIntersect.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.IntersectNode;\n+\n+import static io.prestosql.sql.planner.plan.Patterns.intersect;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ * - Intersect\n+ *   - Intersect\n+ *     - Relation1\n+ *     - Relation2\n+ *   - Intersect\n+ *     - Relation3\n+ *     - Relation4\n+ * </pre>\n+ * Into\n+ * <pre>\n+ * - Intersect\n+ *   - Relation1\n+ *   - Relation2\n+ *   - Relation3\n+ *   - Relation4\n+ * </pre>\n+ */\n+public class FlatteningIntersect", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc5NTI3Mg==", "bodyText": "I'd call this MergeUnion", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r370795272", "createdAt": "2020-01-24T19:08:31Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/FlatteningUnion.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.UnionNode;\n+\n+import static io.prestosql.sql.planner.plan.Patterns.union;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ * - Union\n+ *   - Union\n+ *     - Relation1\n+ *     - Relation2\n+ *   - Union\n+ *     - Relation3\n+ *     - Relation4\n+ * </pre>\n+ * Into\n+ * <pre>\n+ * - Union\n+ *   - Relation1\n+ *   - Relation2\n+ *   - Relation3\n+ *   - Relation4\n+ * </pre>\n+ */\n+public class FlatteningUnion", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwMzcwNw==", "bodyText": "Instead of using inheritance for code reuse, it'd be cleaner to model this as a method that takes a callback to abstract newSetOperationNode. Then, you can pass an inline lambda which does the appropriate new XXXNode as the callback. Something like:\npublic static SetOperationNode flatten(SetOperationNode node, Context context, NodeInstantiator instantiator)\n{\n    if (flattening not necessary) {\n        return null;\n    }   \n    ...\n    return instantiator.create(....);\n}\n(NodeInstantiator would be a single-method interface that takes the arguments needed to instantiate an IntersectNode, UnionNode, etc)\nand in the rule:\nSetOperationNode result = flatten(node, IntersectNode::new);\nif (result != null) {\n    return Optional.ofPlanNode(result);\n}", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r370803707", "createdAt": "2020-01-24T19:27:41Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/SetOperationFlattening.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableListMultimap;\n+import com.google.common.collect.Iterables;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule.Context;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.SetOperationNode;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+abstract class SetOperationFlattening", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4NTAxMDMx", "url": "https://github.com/trinodb/trino/pull/2619#pullrequestreview-348501031", "createdAt": "2020-01-27T08:41:45Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QwODo0MTo0NlrOFh6_pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMDoyNDozNFrOFh9z0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExMzg5NA==", "bodyText": "These can all be private", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r371113894", "createdAt": "2020-01-27T08:41:46Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/SetOperationMerge.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableListMultimap;\n+import com.google.common.collect.Iterables;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule.Context;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.SetOperationNode;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+class SetOperationMerge\n+{\n+    private final Context context;\n+    protected final SetOperationNode node;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExMzk5Mg==", "bodyText": "This can be final", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r371113992", "createdAt": "2020-01-27T08:42:00Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/SetOperationMerge.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableListMultimap;\n+import com.google.common.collect.Iterables;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule.Context;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.SetOperationNode;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+class SetOperationMerge\n+{\n+    private final Context context;\n+    protected final SetOperationNode node;\n+    protected List<PlanNode> newSources;\n+    protected ImmutableListMultimap<Symbol, Symbol> newMappings;\n+    private SetOperationNodeInstantiator instantiator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE1ODA3OQ==", "bodyText": "newMappings is not used outside this call, so inline it and get rid of the class-level field.", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r371158079", "createdAt": "2020-01-27T10:20:43Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/SetOperationMerge.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableListMultimap;\n+import com.google.common.collect.Iterables;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule.Context;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.SetOperationNode;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+class SetOperationMerge\n+{\n+    private final Context context;\n+    protected final SetOperationNode node;\n+    protected List<PlanNode> newSources;\n+    protected ImmutableListMultimap<Symbol, Symbol> newMappings;\n+    private SetOperationNodeInstantiator instantiator;\n+\n+    public SetOperationMerge(SetOperationNode node, Context context, SetOperationNodeInstantiator instantiator)\n+    {\n+        this.node = node;\n+        this.context = context;\n+        this.newSources = new ArrayList<>();\n+        this.instantiator = instantiator;\n+    }\n+\n+    /**\n+     * Only merge first source node, which is assumed to be used for non-associative set operation.\n+     * @return Merged plan node if applied.\n+     */\n+    public Optional<SetOperationNode> mergeFirstSource()\n+    {\n+        Lookup lookup = context.getLookup();\n+        List<PlanNode> sources = node.getSources().stream()\n+                .flatMap(lookup::resolveGroup)\n+                .collect(Collectors.toList());\n+\n+        // If the first child is not the same with the parent, do nothing.\n+        if (!sources.get(0).getClass().equals(node.getClass())) {\n+            return Optional.empty();\n+        }\n+\n+        ImmutableListMultimap.Builder<Symbol, Symbol> newMappingsBuilder = ImmutableListMultimap.builder();\n+\n+        SetOperationNode child = (SetOperationNode) sources.get(0);\n+        // Merge all sources of the first source.\n+        addMergedMappings(child, 0, newMappingsBuilder);\n+\n+        // Keep remaining as it is\n+        for (int i = 1; i < sources.size(); i++) {\n+            PlanNode source = sources.get(i);\n+            addOriginalMappings(source, i, newMappingsBuilder);\n+        }\n+\n+        newMappings = newMappingsBuilder.build();\n+        return Optional.of(instantiator.create(node.getId(), newSources, newMappings, node.getOutputSymbols()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE1ODU2Mw==", "bodyText": "Don't use abbreviations. Rename s to source for clarity", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r371158563", "createdAt": "2020-01-27T10:21:44Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/SetOperationMerge.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableListMultimap;\n+import com.google.common.collect.Iterables;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule.Context;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.SetOperationNode;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+class SetOperationMerge\n+{\n+    private final Context context;\n+    protected final SetOperationNode node;\n+    protected List<PlanNode> newSources;\n+    protected ImmutableListMultimap<Symbol, Symbol> newMappings;\n+    private SetOperationNodeInstantiator instantiator;\n+\n+    public SetOperationMerge(SetOperationNode node, Context context, SetOperationNodeInstantiator instantiator)\n+    {\n+        this.node = node;\n+        this.context = context;\n+        this.newSources = new ArrayList<>();\n+        this.instantiator = instantiator;\n+    }\n+\n+    /**\n+     * Only merge first source node, which is assumed to be used for non-associative set operation.\n+     * @return Merged plan node if applied.\n+     */\n+    public Optional<SetOperationNode> mergeFirstSource()\n+    {\n+        Lookup lookup = context.getLookup();\n+        List<PlanNode> sources = node.getSources().stream()\n+                .flatMap(lookup::resolveGroup)\n+                .collect(Collectors.toList());\n+\n+        // If the first child is not the same with the parent, do nothing.\n+        if (!sources.get(0).getClass().equals(node.getClass())) {\n+            return Optional.empty();\n+        }\n+\n+        ImmutableListMultimap.Builder<Symbol, Symbol> newMappingsBuilder = ImmutableListMultimap.builder();\n+\n+        SetOperationNode child = (SetOperationNode) sources.get(0);\n+        // Merge all sources of the first source.\n+        addMergedMappings(child, 0, newMappingsBuilder);\n+\n+        // Keep remaining as it is\n+        for (int i = 1; i < sources.size(); i++) {\n+            PlanNode source = sources.get(i);\n+            addOriginalMappings(source, i, newMappingsBuilder);\n+        }\n+\n+        newMappings = newMappingsBuilder.build();\n+        return Optional.of(instantiator.create(node.getId(), newSources, newMappings, node.getOutputSymbols()));\n+    }\n+\n+    /**\n+     * Constructs the new mapping and source nodes\n+     * @return Merged plan node if applied.\n+     */\n+    public Optional<SetOperationNode> merge()\n+    {\n+        Lookup lookup = context.getLookup();\n+        List<PlanNode> sources = node.getSources().stream()\n+                .flatMap(lookup::resolveGroup)\n+                .collect(Collectors.toList());\n+\n+        // There must be one same source node at least.\n+        if (sources.stream().noneMatch(s -> node.getClass().equals(s.getClass()))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE2MDAxOA==", "bodyText": "Also, this can be replaced with:\nif (sources.stream().noneMatch(node.getClass()::isInstance)) {\n\nIt's a little more robust, as it's checking for instanceof instead of class equality.", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r371160018", "createdAt": "2020-01-27T10:24:34Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/SetOperationMerge.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableListMultimap;\n+import com.google.common.collect.Iterables;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule.Context;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.SetOperationNode;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+class SetOperationMerge\n+{\n+    private final Context context;\n+    protected final SetOperationNode node;\n+    protected List<PlanNode> newSources;\n+    protected ImmutableListMultimap<Symbol, Symbol> newMappings;\n+    private SetOperationNodeInstantiator instantiator;\n+\n+    public SetOperationMerge(SetOperationNode node, Context context, SetOperationNodeInstantiator instantiator)\n+    {\n+        this.node = node;\n+        this.context = context;\n+        this.newSources = new ArrayList<>();\n+        this.instantiator = instantiator;\n+    }\n+\n+    /**\n+     * Only merge first source node, which is assumed to be used for non-associative set operation.\n+     * @return Merged plan node if applied.\n+     */\n+    public Optional<SetOperationNode> mergeFirstSource()\n+    {\n+        Lookup lookup = context.getLookup();\n+        List<PlanNode> sources = node.getSources().stream()\n+                .flatMap(lookup::resolveGroup)\n+                .collect(Collectors.toList());\n+\n+        // If the first child is not the same with the parent, do nothing.\n+        if (!sources.get(0).getClass().equals(node.getClass())) {\n+            return Optional.empty();\n+        }\n+\n+        ImmutableListMultimap.Builder<Symbol, Symbol> newMappingsBuilder = ImmutableListMultimap.builder();\n+\n+        SetOperationNode child = (SetOperationNode) sources.get(0);\n+        // Merge all sources of the first source.\n+        addMergedMappings(child, 0, newMappingsBuilder);\n+\n+        // Keep remaining as it is\n+        for (int i = 1; i < sources.size(); i++) {\n+            PlanNode source = sources.get(i);\n+            addOriginalMappings(source, i, newMappingsBuilder);\n+        }\n+\n+        newMappings = newMappingsBuilder.build();\n+        return Optional.of(instantiator.create(node.getId(), newSources, newMappings, node.getOutputSymbols()));\n+    }\n+\n+    /**\n+     * Constructs the new mapping and source nodes\n+     * @return Merged plan node if applied.\n+     */\n+    public Optional<SetOperationNode> merge()\n+    {\n+        Lookup lookup = context.getLookup();\n+        List<PlanNode> sources = node.getSources().stream()\n+                .flatMap(lookup::resolveGroup)\n+                .collect(Collectors.toList());\n+\n+        // There must be one same source node at least.\n+        if (sources.stream().noneMatch(s -> node.getClass().equals(s.getClass()))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE1ODU2Mw=="}, "originalCommit": null, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4NjEzOTQz", "url": "https://github.com/trinodb/trino/pull/2619#pullrequestreview-348613943", "createdAt": "2020-01-27T12:04:28Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0ODU0NjYx", "url": "https://github.com/trinodb/trino/pull/2619#pullrequestreview-384854661", "createdAt": "2020-03-31T15:33:16Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNTozMzoxNlrOF-bsvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNTozMzoxNlrOF-bsvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAwOTg1Mw==", "bodyText": "Instead of using a visitor, this should be done pairwise by a rule that matches the expected pattern. I.e., it if matches Aggregation -> SetOperation -> {Aggregation -> X, ... }, it should rewrite to Aggregation -> SetOperation -> {X, ...}.", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r401009853", "createdAt": "2020-03-31T15:33:16Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneDistinctAggregation.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.ExceptNode;\n+import io.prestosql.sql.planner.plan.IntersectNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.PlanVisitor;\n+import io.prestosql.sql.planner.plan.UnionNode;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.plan.ChildReplacer.replaceChildren;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+\n+public class PruneDistinctAggregation\n+        implements Rule<AggregationNode>\n+{\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .matching(PruneDistinctAggregation::isDistinctOperator);\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        Lookup lookup = context.getLookup();\n+        DistinctAggregationRewriter rewriter = new DistinctAggregationRewriter(lookup);\n+\n+        List<PlanNode> newSources = node.getSources().stream()\n+                .flatMap(lookup::resolveGroup)\n+                .map(source -> source.accept(rewriter, true))\n+                .collect(Collectors.toList());\n+\n+        if (rewriter.isRewritten()) {\n+            return Result.ofPlanNode(replaceChildren(node, newSources));\n+        }\n+        else {\n+            return Result.empty();\n+        }\n+    }\n+\n+    private static boolean isDistinctOperator(AggregationNode node)\n+    {\n+        return node.getAggregations().isEmpty();\n+    }\n+\n+    private static class DistinctAggregationRewriter", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMzg3NjY3", "url": "https://github.com/trinodb/trino/pull/2619#pullrequestreview-412387667", "createdAt": "2020-05-15T06:48:16Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71100e0c8b16496d290d96f30d62ee1d0670f530", "author": {"user": {"login": "Lewuathe", "name": "Kai Sasaki"}}, "url": "https://github.com/trinodb/trino/commit/71100e0c8b16496d290d96f30d62ee1d0670f530", "committedDate": "2020-05-15T13:42:26Z", "message": "Optimizer for merging set operations"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "71100e0c8b16496d290d96f30d62ee1d0670f530", "author": {"user": {"login": "Lewuathe", "name": "Kai Sasaki"}}, "url": "https://github.com/trinodb/trino/commit/71100e0c8b16496d290d96f30d62ee1d0670f530", "committedDate": "2020-05-15T13:42:26Z", "message": "Optimizer for merging set operations"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 991, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}