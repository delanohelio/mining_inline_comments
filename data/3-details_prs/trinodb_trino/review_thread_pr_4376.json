{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1NjEzNzAz", "number": 4376, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMjoyNTowN1rOEMQ5sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwODo1ODo1MlrOEQDomQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjk1MjgxOnYy", "diffSide": "RIGHT", "path": "presto-jdbc/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMjoyNTowN1rOGuRu6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMjoyNTowN1rOGuRu6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3ODIxOQ==", "bodyText": "Oracle is very heavyweight and not open source. Can we use MySQL or PostgreSQL?", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r451178219", "createdAt": "2020-07-07T22:25:07Z", "author": {"login": "electrum"}, "path": "presto-jdbc/pom.xml", "diffHunk": "@@ -131,6 +131,25 @@\n             <scope>test</scope>\n         </dependency>\n \n+        <dependency>\n+            <groupId>org.testcontainers</groupId>\n+            <artifactId>testcontainers</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.testcontainers</groupId>\n+            <artifactId>oracle-xe</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjk1NjgxOnYy", "diffSide": "RIGHT", "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMjoyNjozNlrOGuRxPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMjoyNjozNlrOGuRxPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3ODgxNA==", "bodyText": "If one of these throws, the rest won't be closed. A better way is to use a Closer.\nAlso, we avoid using forEach() for simple for-each loops. Only use it when there is a specific benefit, such as the terminal operation of a stream.", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r451178814", "createdAt": "2020-07-07T22:26:36Z", "author": {"login": "electrum"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.jdbc;\n+\n+import io.airlift.log.Logging;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testcontainers.containers.OracleContainer;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import static io.prestosql.jdbc.TestPrestoDriver.closeQuietly;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+/**\n+ * Checks that JDBC dates and timestamps are interpreted in the client JVM timezone and should not\n+ * be affected by the session timezone.  We also compare the behavior to a reference JDBC driver\n+ * (we picked Oracle).\n+ */\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetTimezone\n+{\n+    private TestingPrestoServer server;\n+    private List<ReferenceDriver> referenceDrivers;\n+\n+    private Connection connection;\n+    private Statement statement;\n+\n+    @BeforeClass\n+    public void setupServer()\n+    {\n+        Logging.initialize();\n+        server = TestingPrestoServer.create();\n+        referenceDrivers = ImmutableList.of(new OracleReferenceDriver());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDownServer()\n+    {\n+        closeQuietly(server);\n+        referenceDrivers.forEach(ReferenceDriver::close);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNDA4NjA3OnYy", "diffSide": "RIGHT", "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNzo1MDowM1rOGucNZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNzo1MDowM1rOGucNZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM0OTg2Mw==", "bodyText": "Update this one as you are switching to PSQL", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r451349863", "createdAt": "2020-07-08T07:50:03Z", "author": {"login": "losipiuk"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.jdbc;\n+\n+import com.google.common.io.Closer;\n+import io.airlift.log.Logging;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testcontainers.containers.OracleContainer;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import static io.prestosql.jdbc.TestPrestoDriver.closeQuietly;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+/**\n+ * Checks that JDBC dates and timestamps are interpreted in the client JVM timezone and should not\n+ * be affected by the session timezone.  We also compare the behavior to a reference JDBC driver\n+ * (we picked Oracle).", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNDEzMzI4OnYy", "diffSide": "RIGHT", "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODowMjo0N1rOGucqkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMjo0MDozN1rOGumLJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM1NzMyOA==", "bodyText": "Is the timezone returned by this method meaningful (the assertions test should pass - no matter which one we return here). If for some reason we want it to match JVM timezone please add an assertion that it actually does.\nOr maybe we have such assertion somewhere globally? I vaguely remember that we may have such.", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r451357328", "createdAt": "2020-07-08T08:02:47Z", "author": {"login": "losipiuk"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.jdbc;\n+\n+import com.google.common.io.Closer;\n+import io.airlift.log.Logging;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testcontainers.containers.OracleContainer;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import static io.prestosql.jdbc.TestPrestoDriver.closeQuietly;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+/**\n+ * Checks that JDBC dates and timestamps are interpreted in the client JVM timezone and should not\n+ * be affected by the session timezone.  We also compare the behavior to a reference JDBC driver\n+ * (we picked Oracle).\n+ */\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetTimezone\n+{\n+    private TestingPrestoServer server;\n+    private List<ReferenceDriver> referenceDrivers;\n+\n+    private Connection connection;\n+    private Statement statement;\n+\n+    @BeforeClass\n+    public void setupServer()\n+    {\n+        Logging.initialize();\n+        server = TestingPrestoServer.create();\n+        referenceDrivers = ImmutableList.of(new PostgresqlReferenceDriver()/*, new OracleReferenceDriver()*/);\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDownServer()\n+    {\n+        closeQuietly(server);\n+        referenceDrivers.forEach(ReferenceDriver::close);\n+    }\n+\n+    @SuppressWarnings(\"JDBCResourceOpenedButNotSafelyClosed\")\n+    @BeforeMethod\n+    public void setup()\n+            throws Exception\n+    {\n+        connection = DriverManager.getConnection(\"jdbc:presto://\" + server.getAddress(), \"test\", null);\n+        statement = connection.createStatement();\n+        referenceDrivers.forEach(ReferenceDriver::setup);\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void teardown()\n+            throws IOException\n+    {\n+        closeQuietly(statement);\n+        closeQuietly(connection);\n+        try (Closer closer = Closer.create()) {\n+            for (ReferenceDriver driver : referenceDrivers) {\n+                closer.register(driver::teardown);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] timeZoneIds()\n+    {\n+        return new Object[][] {\n+                {\"UTC\"},\n+                {\"Europe/Warsaw\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testDate(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"DATE '2018-02-13'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getDate(column), reference.getDate(column));\n+            assertEquals(rs.getDate(column), Date.valueOf(LocalDate.of(2018, 2, 13)));\n+        });\n+\n+        checkRepresentation(\"DATE '2018-02-13'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getDate(column, getCalendar()), reference.getDate(column, getCalendar()));\n+            assertEquals(rs.getDate(column, getCalendar()), new Date(LocalDate.of(2018, 2, 13).atStartOfDay(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTimestamp(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"TIMESTAMP '2018-02-13 13:14:15.123'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTimestamp(column), reference.getTimestamp(column));\n+            assertEquals(\n+                    rs.getTimestamp(column),\n+                    Timestamp.valueOf(LocalDateTime.of(2018, 2, 13, 13, 14, 15, 123_000_000)));\n+        });\n+\n+        checkRepresentation(\"TIMESTAMP '2018-02-13 13:14:15.123'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTimestamp(column, getCalendar()), reference.getTimestamp(column, getCalendar()));\n+            assertEquals(\n+                    rs.getTimestamp(column, getCalendar()),\n+                    new Timestamp(LocalDateTime.of(2018, 2, 13, 13, 14, 15, 123_000_000).atZone(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTime(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"TIME '09:39:05'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTime(column), reference.getTime(column));\n+            assertEquals(rs.getTime(column), Time.valueOf(LocalTime.of(9, 39, 5)));\n+        });\n+\n+        checkRepresentation(\"TIME '09:39:05'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTime(column, getCalendar()), reference.getTime(column, getCalendar()));\n+            assertEquals(rs.getTime(column, getCalendar()), new Time(LocalDate.of(1970, 1, 1).atTime(LocalTime.of(9, 39, 5)).atZone(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testDateRoundTrip(String sessionTimezoneId)\n+            throws SQLException\n+    {\n+        LocalDate date = LocalDate.of(2001, 5, 6);\n+        Date sqlDate = Date.valueOf(date);\n+        java.util.Date javaDate = new java.util.Date(sqlDate.getTime());\n+        LocalDateTime dateTime = LocalDateTime.of(date, LocalTime.of(12, 34, 56));\n+        Timestamp sqlTimestamp = Timestamp.valueOf(dateTime);\n+\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setDate(i, sqlDate));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, javaDate, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, date, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, dateTime, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, \"2001-05-06\", Types.DATE));\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTimestampRoundTrip(String sessionTimezoneId)\n+            throws SQLException\n+    {\n+        LocalDateTime dateTime = LocalDateTime.of(2001, 5, 6, 12, 34, 56);\n+        Date sqlDate = Date.valueOf(dateTime.toLocalDate());\n+        Time sqlTime = Time.valueOf(dateTime.toLocalTime());\n+        Timestamp sqlTimestamp = Timestamp.valueOf(dateTime);\n+        Timestamp sameInstantInWarsawZone = Timestamp.valueOf(dateTime.atZone(ZoneId.systemDefault()).withZoneSameInstant(ZoneId.of(\"Europe/Warsaw\")).toLocalDateTime());\n+        java.util.Date javaDate = java.util.Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant());\n+\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, null));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, Calendar.getInstance()));\n+        assertParameter(sameInstantInWarsawZone, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, Calendar.getInstance(TimeZone.getTimeZone(\"Europe/Warsaw\"))));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp));\n+        assertParameter(new Timestamp(sqlDate.getTime()), sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate, Types.TIMESTAMP));\n+        assertParameter(new Timestamp(sqlTime.getTime()), sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTime, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, javaDate, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, dateTime, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, \"2001-05-06 12:34:56\", Types.TIMESTAMP));\n+    }\n+\n+    private void assertParameter(Object expectedValue, String sessionTimezoneId, Binder binder)\n+            throws SQLException\n+    {\n+        connection.unwrap(PrestoConnection.class).setTimeZoneId(sessionTimezoneId);\n+        try (PreparedStatement statement = connection.prepareStatement(\"SELECT ?\")) {\n+            binder.bind(statement, 1);\n+\n+            try (ResultSet rs = statement.executeQuery()) {\n+                assertTrue(rs.next());\n+                assertEquals(expectedValue, rs.getObject(1));\n+                assertFalse(rs.next());\n+            }\n+        }\n+    }\n+\n+    private void checkRepresentation(String expression, String sessionTimezoneId, ResultAssertion assertion)\n+            throws Exception\n+    {\n+        for (ReferenceDriver driver : referenceDrivers) {\n+            // log the name of the driver if we're going to use more than one\n+            checkRepresentation(expression, sessionTimezoneId, driver, assertion);\n+        }\n+    }\n+\n+    private void checkRepresentation(String expression, String sessionTimezoneId, ReferenceDriver reference, ResultAssertion assertion)\n+            throws Exception\n+    {\n+        try (ResultSet rs = prestoQuery(expression, sessionTimezoneId); ResultSet referenceResultSet = reference.query(expression, sessionTimezoneId)) {\n+            assertTrue(rs.next());\n+            assertTrue(referenceResultSet.next());\n+            assertion.accept(rs, referenceResultSet, 1);\n+            assertFalse(rs.next());\n+            assertFalse(referenceResultSet.next());\n+        }\n+    }\n+\n+    private ResultSet prestoQuery(String expression, String timezoneId)\n+            throws Exception\n+    {\n+        connection.unwrap(PrestoConnection.class).setTimeZoneId(timezoneId);\n+        return statement.executeQuery(\"SELECT \" + expression);\n+    }\n+\n+    private Calendar getCalendar()\n+    {\n+        return Calendar.getInstance(TimeZone.getTimeZone(\"Asia/Kathmandu\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTUwMTY4MQ==", "bodyText": "Nothing special, it's just a timezone that's different from the JVM timezone (America/Bahia_Banderas).  Maybe an assert that the 2 are different would be useful.  I'll also add a comment.", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r451501681", "createdAt": "2020-07-08T12:20:32Z", "author": {"login": "aalbu"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.jdbc;\n+\n+import com.google.common.io.Closer;\n+import io.airlift.log.Logging;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testcontainers.containers.OracleContainer;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import static io.prestosql.jdbc.TestPrestoDriver.closeQuietly;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+/**\n+ * Checks that JDBC dates and timestamps are interpreted in the client JVM timezone and should not\n+ * be affected by the session timezone.  We also compare the behavior to a reference JDBC driver\n+ * (we picked Oracle).\n+ */\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetTimezone\n+{\n+    private TestingPrestoServer server;\n+    private List<ReferenceDriver> referenceDrivers;\n+\n+    private Connection connection;\n+    private Statement statement;\n+\n+    @BeforeClass\n+    public void setupServer()\n+    {\n+        Logging.initialize();\n+        server = TestingPrestoServer.create();\n+        referenceDrivers = ImmutableList.of(new PostgresqlReferenceDriver()/*, new OracleReferenceDriver()*/);\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDownServer()\n+    {\n+        closeQuietly(server);\n+        referenceDrivers.forEach(ReferenceDriver::close);\n+    }\n+\n+    @SuppressWarnings(\"JDBCResourceOpenedButNotSafelyClosed\")\n+    @BeforeMethod\n+    public void setup()\n+            throws Exception\n+    {\n+        connection = DriverManager.getConnection(\"jdbc:presto://\" + server.getAddress(), \"test\", null);\n+        statement = connection.createStatement();\n+        referenceDrivers.forEach(ReferenceDriver::setup);\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void teardown()\n+            throws IOException\n+    {\n+        closeQuietly(statement);\n+        closeQuietly(connection);\n+        try (Closer closer = Closer.create()) {\n+            for (ReferenceDriver driver : referenceDrivers) {\n+                closer.register(driver::teardown);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] timeZoneIds()\n+    {\n+        return new Object[][] {\n+                {\"UTC\"},\n+                {\"Europe/Warsaw\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testDate(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"DATE '2018-02-13'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getDate(column), reference.getDate(column));\n+            assertEquals(rs.getDate(column), Date.valueOf(LocalDate.of(2018, 2, 13)));\n+        });\n+\n+        checkRepresentation(\"DATE '2018-02-13'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getDate(column, getCalendar()), reference.getDate(column, getCalendar()));\n+            assertEquals(rs.getDate(column, getCalendar()), new Date(LocalDate.of(2018, 2, 13).atStartOfDay(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTimestamp(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"TIMESTAMP '2018-02-13 13:14:15.123'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTimestamp(column), reference.getTimestamp(column));\n+            assertEquals(\n+                    rs.getTimestamp(column),\n+                    Timestamp.valueOf(LocalDateTime.of(2018, 2, 13, 13, 14, 15, 123_000_000)));\n+        });\n+\n+        checkRepresentation(\"TIMESTAMP '2018-02-13 13:14:15.123'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTimestamp(column, getCalendar()), reference.getTimestamp(column, getCalendar()));\n+            assertEquals(\n+                    rs.getTimestamp(column, getCalendar()),\n+                    new Timestamp(LocalDateTime.of(2018, 2, 13, 13, 14, 15, 123_000_000).atZone(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTime(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"TIME '09:39:05'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTime(column), reference.getTime(column));\n+            assertEquals(rs.getTime(column), Time.valueOf(LocalTime.of(9, 39, 5)));\n+        });\n+\n+        checkRepresentation(\"TIME '09:39:05'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTime(column, getCalendar()), reference.getTime(column, getCalendar()));\n+            assertEquals(rs.getTime(column, getCalendar()), new Time(LocalDate.of(1970, 1, 1).atTime(LocalTime.of(9, 39, 5)).atZone(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testDateRoundTrip(String sessionTimezoneId)\n+            throws SQLException\n+    {\n+        LocalDate date = LocalDate.of(2001, 5, 6);\n+        Date sqlDate = Date.valueOf(date);\n+        java.util.Date javaDate = new java.util.Date(sqlDate.getTime());\n+        LocalDateTime dateTime = LocalDateTime.of(date, LocalTime.of(12, 34, 56));\n+        Timestamp sqlTimestamp = Timestamp.valueOf(dateTime);\n+\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setDate(i, sqlDate));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, javaDate, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, date, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, dateTime, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, \"2001-05-06\", Types.DATE));\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTimestampRoundTrip(String sessionTimezoneId)\n+            throws SQLException\n+    {\n+        LocalDateTime dateTime = LocalDateTime.of(2001, 5, 6, 12, 34, 56);\n+        Date sqlDate = Date.valueOf(dateTime.toLocalDate());\n+        Time sqlTime = Time.valueOf(dateTime.toLocalTime());\n+        Timestamp sqlTimestamp = Timestamp.valueOf(dateTime);\n+        Timestamp sameInstantInWarsawZone = Timestamp.valueOf(dateTime.atZone(ZoneId.systemDefault()).withZoneSameInstant(ZoneId.of(\"Europe/Warsaw\")).toLocalDateTime());\n+        java.util.Date javaDate = java.util.Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant());\n+\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, null));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, Calendar.getInstance()));\n+        assertParameter(sameInstantInWarsawZone, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, Calendar.getInstance(TimeZone.getTimeZone(\"Europe/Warsaw\"))));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp));\n+        assertParameter(new Timestamp(sqlDate.getTime()), sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate, Types.TIMESTAMP));\n+        assertParameter(new Timestamp(sqlTime.getTime()), sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTime, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, javaDate, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, dateTime, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, \"2001-05-06 12:34:56\", Types.TIMESTAMP));\n+    }\n+\n+    private void assertParameter(Object expectedValue, String sessionTimezoneId, Binder binder)\n+            throws SQLException\n+    {\n+        connection.unwrap(PrestoConnection.class).setTimeZoneId(sessionTimezoneId);\n+        try (PreparedStatement statement = connection.prepareStatement(\"SELECT ?\")) {\n+            binder.bind(statement, 1);\n+\n+            try (ResultSet rs = statement.executeQuery()) {\n+                assertTrue(rs.next());\n+                assertEquals(expectedValue, rs.getObject(1));\n+                assertFalse(rs.next());\n+            }\n+        }\n+    }\n+\n+    private void checkRepresentation(String expression, String sessionTimezoneId, ResultAssertion assertion)\n+            throws Exception\n+    {\n+        for (ReferenceDriver driver : referenceDrivers) {\n+            // log the name of the driver if we're going to use more than one\n+            checkRepresentation(expression, sessionTimezoneId, driver, assertion);\n+        }\n+    }\n+\n+    private void checkRepresentation(String expression, String sessionTimezoneId, ReferenceDriver reference, ResultAssertion assertion)\n+            throws Exception\n+    {\n+        try (ResultSet rs = prestoQuery(expression, sessionTimezoneId); ResultSet referenceResultSet = reference.query(expression, sessionTimezoneId)) {\n+            assertTrue(rs.next());\n+            assertTrue(referenceResultSet.next());\n+            assertion.accept(rs, referenceResultSet, 1);\n+            assertFalse(rs.next());\n+            assertFalse(referenceResultSet.next());\n+        }\n+    }\n+\n+    private ResultSet prestoQuery(String expression, String timezoneId)\n+            throws Exception\n+    {\n+        connection.unwrap(PrestoConnection.class).setTimeZoneId(timezoneId);\n+        return statement.executeQuery(\"SELECT \" + expression);\n+    }\n+\n+    private Calendar getCalendar()\n+    {\n+        return Calendar.getInstance(TimeZone.getTimeZone(\"Asia/Kathmandu\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM1NzMyOA=="}, "originalCommit": null, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTUxMzEyNQ==", "bodyText": "O yeah my bad. We are using specifically Asia/Kathmandu too. But i think it is used as hive session time zone.\nComment and assertion will be helpful. Thanks.", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r451513125", "createdAt": "2020-07-08T12:40:37Z", "author": {"login": "losipiuk"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.jdbc;\n+\n+import com.google.common.io.Closer;\n+import io.airlift.log.Logging;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testcontainers.containers.OracleContainer;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import static io.prestosql.jdbc.TestPrestoDriver.closeQuietly;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+/**\n+ * Checks that JDBC dates and timestamps are interpreted in the client JVM timezone and should not\n+ * be affected by the session timezone.  We also compare the behavior to a reference JDBC driver\n+ * (we picked Oracle).\n+ */\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetTimezone\n+{\n+    private TestingPrestoServer server;\n+    private List<ReferenceDriver> referenceDrivers;\n+\n+    private Connection connection;\n+    private Statement statement;\n+\n+    @BeforeClass\n+    public void setupServer()\n+    {\n+        Logging.initialize();\n+        server = TestingPrestoServer.create();\n+        referenceDrivers = ImmutableList.of(new PostgresqlReferenceDriver()/*, new OracleReferenceDriver()*/);\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDownServer()\n+    {\n+        closeQuietly(server);\n+        referenceDrivers.forEach(ReferenceDriver::close);\n+    }\n+\n+    @SuppressWarnings(\"JDBCResourceOpenedButNotSafelyClosed\")\n+    @BeforeMethod\n+    public void setup()\n+            throws Exception\n+    {\n+        connection = DriverManager.getConnection(\"jdbc:presto://\" + server.getAddress(), \"test\", null);\n+        statement = connection.createStatement();\n+        referenceDrivers.forEach(ReferenceDriver::setup);\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void teardown()\n+            throws IOException\n+    {\n+        closeQuietly(statement);\n+        closeQuietly(connection);\n+        try (Closer closer = Closer.create()) {\n+            for (ReferenceDriver driver : referenceDrivers) {\n+                closer.register(driver::teardown);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] timeZoneIds()\n+    {\n+        return new Object[][] {\n+                {\"UTC\"},\n+                {\"Europe/Warsaw\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testDate(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"DATE '2018-02-13'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getDate(column), reference.getDate(column));\n+            assertEquals(rs.getDate(column), Date.valueOf(LocalDate.of(2018, 2, 13)));\n+        });\n+\n+        checkRepresentation(\"DATE '2018-02-13'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getDate(column, getCalendar()), reference.getDate(column, getCalendar()));\n+            assertEquals(rs.getDate(column, getCalendar()), new Date(LocalDate.of(2018, 2, 13).atStartOfDay(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTimestamp(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"TIMESTAMP '2018-02-13 13:14:15.123'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTimestamp(column), reference.getTimestamp(column));\n+            assertEquals(\n+                    rs.getTimestamp(column),\n+                    Timestamp.valueOf(LocalDateTime.of(2018, 2, 13, 13, 14, 15, 123_000_000)));\n+        });\n+\n+        checkRepresentation(\"TIMESTAMP '2018-02-13 13:14:15.123'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTimestamp(column, getCalendar()), reference.getTimestamp(column, getCalendar()));\n+            assertEquals(\n+                    rs.getTimestamp(column, getCalendar()),\n+                    new Timestamp(LocalDateTime.of(2018, 2, 13, 13, 14, 15, 123_000_000).atZone(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTime(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"TIME '09:39:05'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTime(column), reference.getTime(column));\n+            assertEquals(rs.getTime(column), Time.valueOf(LocalTime.of(9, 39, 5)));\n+        });\n+\n+        checkRepresentation(\"TIME '09:39:05'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTime(column, getCalendar()), reference.getTime(column, getCalendar()));\n+            assertEquals(rs.getTime(column, getCalendar()), new Time(LocalDate.of(1970, 1, 1).atTime(LocalTime.of(9, 39, 5)).atZone(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testDateRoundTrip(String sessionTimezoneId)\n+            throws SQLException\n+    {\n+        LocalDate date = LocalDate.of(2001, 5, 6);\n+        Date sqlDate = Date.valueOf(date);\n+        java.util.Date javaDate = new java.util.Date(sqlDate.getTime());\n+        LocalDateTime dateTime = LocalDateTime.of(date, LocalTime.of(12, 34, 56));\n+        Timestamp sqlTimestamp = Timestamp.valueOf(dateTime);\n+\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setDate(i, sqlDate));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, javaDate, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, date, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, dateTime, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, \"2001-05-06\", Types.DATE));\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTimestampRoundTrip(String sessionTimezoneId)\n+            throws SQLException\n+    {\n+        LocalDateTime dateTime = LocalDateTime.of(2001, 5, 6, 12, 34, 56);\n+        Date sqlDate = Date.valueOf(dateTime.toLocalDate());\n+        Time sqlTime = Time.valueOf(dateTime.toLocalTime());\n+        Timestamp sqlTimestamp = Timestamp.valueOf(dateTime);\n+        Timestamp sameInstantInWarsawZone = Timestamp.valueOf(dateTime.atZone(ZoneId.systemDefault()).withZoneSameInstant(ZoneId.of(\"Europe/Warsaw\")).toLocalDateTime());\n+        java.util.Date javaDate = java.util.Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant());\n+\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, null));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, Calendar.getInstance()));\n+        assertParameter(sameInstantInWarsawZone, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, Calendar.getInstance(TimeZone.getTimeZone(\"Europe/Warsaw\"))));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp));\n+        assertParameter(new Timestamp(sqlDate.getTime()), sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate, Types.TIMESTAMP));\n+        assertParameter(new Timestamp(sqlTime.getTime()), sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTime, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, javaDate, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, dateTime, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, \"2001-05-06 12:34:56\", Types.TIMESTAMP));\n+    }\n+\n+    private void assertParameter(Object expectedValue, String sessionTimezoneId, Binder binder)\n+            throws SQLException\n+    {\n+        connection.unwrap(PrestoConnection.class).setTimeZoneId(sessionTimezoneId);\n+        try (PreparedStatement statement = connection.prepareStatement(\"SELECT ?\")) {\n+            binder.bind(statement, 1);\n+\n+            try (ResultSet rs = statement.executeQuery()) {\n+                assertTrue(rs.next());\n+                assertEquals(expectedValue, rs.getObject(1));\n+                assertFalse(rs.next());\n+            }\n+        }\n+    }\n+\n+    private void checkRepresentation(String expression, String sessionTimezoneId, ResultAssertion assertion)\n+            throws Exception\n+    {\n+        for (ReferenceDriver driver : referenceDrivers) {\n+            // log the name of the driver if we're going to use more than one\n+            checkRepresentation(expression, sessionTimezoneId, driver, assertion);\n+        }\n+    }\n+\n+    private void checkRepresentation(String expression, String sessionTimezoneId, ReferenceDriver reference, ResultAssertion assertion)\n+            throws Exception\n+    {\n+        try (ResultSet rs = prestoQuery(expression, sessionTimezoneId); ResultSet referenceResultSet = reference.query(expression, sessionTimezoneId)) {\n+            assertTrue(rs.next());\n+            assertTrue(referenceResultSet.next());\n+            assertion.accept(rs, referenceResultSet, 1);\n+            assertFalse(rs.next());\n+            assertFalse(referenceResultSet.next());\n+        }\n+    }\n+\n+    private ResultSet prestoQuery(String expression, String timezoneId)\n+            throws Exception\n+    {\n+        connection.unwrap(PrestoConnection.class).setTimeZoneId(timezoneId);\n+        return statement.executeQuery(\"SELECT \" + expression);\n+    }\n+\n+    private Calendar getCalendar()\n+    {\n+        return Calendar.getInstance(TimeZone.getTimeZone(\"Asia/Kathmandu\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM1NzMyOA=="}, "originalCommit": null, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjYyOTgwOnYy", "diffSide": "RIGHT", "path": "presto-client/src/main/java/io/prestosql/client/ClientSession.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDowMjo1MlrOGzNOzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDowMjo1MlrOGzNOzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0NzM0Mw==", "bodyText": "add a builder's setter method as well and mark it\n@Deprecated // TODO remove the fallback mechanism", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r456347343", "createdAt": "2020-07-17T10:02:52Z", "author": {"login": "findepi"}, "path": "presto-client/src/main/java/io/prestosql/client/ClientSession.java", "diffHunk": "@@ -262,6 +271,7 @@ public String toString()\n         private String schema;\n         private String path;\n         private ZoneId timeZone;\n+        private boolean useSessionTimeZone;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjYzMDIyOnYy", "diffSide": "RIGHT", "path": "presto-client/src/main/java/io/prestosql/client/ClientSession.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDowMzowMFrOGzNPEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDowMzowMFrOGzNPEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0NzQxMA==", "bodyText": "@Deprecated // TODO remove the fallback mechanism", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r456347410", "createdAt": "2020-07-17T10:03:00Z", "author": {"login": "findepi"}, "path": "presto-client/src/main/java/io/prestosql/client/ClientSession.java", "diffHunk": "@@ -182,6 +185,11 @@ public ZoneId getTimeZone()\n         return timeZone;\n     }\n \n+    public boolean useSessionTimeZone()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjYzNTg1OnYy", "diffSide": "RIGHT", "path": "presto-client/src/main/java/io/prestosql/client/StatementClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDowNDozMFrOGzNSQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDowNDozMFrOGzNSQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0ODIyNw==", "bodyText": "@Deprecated // TODO remove the fallback mechanism", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r456348227", "createdAt": "2020-07-17T10:04:30Z", "author": {"login": "findepi"}, "path": "presto-client/src/main/java/io/prestosql/client/StatementClient.java", "diffHunk": "@@ -28,6 +28,8 @@\n \n     ZoneId getTimeZone();\n \n+    boolean useSessionTimeZone();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjYzODk4OnYy", "diffSide": "RIGHT", "path": "presto-docs/src/main/sphinx/installation/jdbc.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDowNToyOVrOGzNUOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDowNToyOVrOGzNUOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0ODczMQ==", "bodyText": "We should make it explicit this option will be removed in the future.", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r456348731", "createdAt": "2020-07-17T10:05:29Z", "author": {"login": "findepi"}, "path": "presto-docs/src/main/sphinx/installation/jdbc.rst", "diffHunk": "@@ -117,6 +117,7 @@ Name                                   Description\n ``KerberosConfigPath``                 Kerberos configuration file.\n ``KerberosKeytabPath``                 Kerberos keytab file.\n ``KerberosCredentialCachePath``        Kerberos credential cache.\n+``useSessionTimeZone``                 Should dates and timestamps use the session time zone (default: false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjY0NDA4OnYy", "diffSide": "RIGHT", "path": "presto-jdbc/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDowNzoxNlrOGzNXWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDowNzoxNlrOGzNXWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0OTUzMA==", "bodyText": "Let's define this depedency in root pom, as it's used in presto-oracle as well", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r456349530", "createdAt": "2020-07-17T10:07:16Z", "author": {"login": "findepi"}, "path": "presto-jdbc/pom.xml", "diffHunk": "@@ -131,6 +131,37 @@\n             <scope>test</scope>\n         </dependency>\n \n+        <dependency>\n+            <groupId>org.testcontainers</groupId>\n+            <artifactId>testcontainers</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.testcontainers</groupId>\n+            <artifactId>oracle-xe</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>com.oracle.ojdbc</groupId>\n+            <artifactId>ojdbc8</artifactId>\n+            <version>19.3.0.0</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjY1MTA5OnYy", "diffSide": "RIGHT", "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/PrestoResultSet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDowOTo0M1rOGzNbpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDowOTo0M1rOGzNbpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MDYzMQ==", "bodyText": "getResultTimeZone", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r456350631", "createdAt": "2020-07-17T10:09:43Z", "author": {"login": "findepi"}, "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/PrestoResultSet.java", "diffHunk": "@@ -66,6 +67,16 @@ private PrestoResultSet(StatementClient client, List<Column> columns, long maxRo\n         this.queryId = client.currentStatusInfo().getId();\n     }\n \n+    private static ZoneId timeZone(StatementClient client)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjY1MjMzOnYy", "diffSide": "RIGHT", "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/PrestoResultSet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoxMDoxMFrOGzNcbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoxMDoxMFrOGzNcbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MDgzMQ==", "bodyText": "else is redundant since the if branch always returns", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r456350831", "createdAt": "2020-07-17T10:10:10Z", "author": {"login": "findepi"}, "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/PrestoResultSet.java", "diffHunk": "@@ -66,6 +67,16 @@ private PrestoResultSet(StatementClient client, List<Column> columns, long maxRo\n         this.queryId = client.currentStatusInfo().getId();\n     }\n \n+    private static ZoneId timeZone(StatementClient client)\n+    {\n+        if (client.useSessionTimeZone()) {\n+            return client.getTimeZone();\n+        }\n+        else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjY1ODk5OnYy", "diffSide": "RIGHT", "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoxMjoyM1rOGzNgbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMzozNzowM1rOGzoTzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MTg1Mw==", "bodyText": "?", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r456351853", "createdAt": "2020-07-17T10:12:23Z", "author": {"login": "findepi"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.jdbc;\n+\n+import com.google.common.io.Closer;\n+import io.airlift.log.Logging;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testcontainers.containers.OracleContainer;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import static io.prestosql.jdbc.TestPrestoDriver.closeQuietly;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+/**\n+ * Checks that JDBC dates and timestamps are interpreted in the client JVM timezone and should not\n+ * be affected by the session timezone.  We also compare the behavior to a reference JDBC driver.\n+ */\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetTimezone\n+{\n+    private static final String OTHER_TIMEZONE = \"Asia/Kathmandu\";\n+\n+    private TestingPrestoServer server;\n+    private List<ReferenceDriver> referenceDrivers;\n+\n+    private Connection connection;\n+    private Statement statement;\n+\n+    @BeforeClass\n+    public void setupServer()\n+    {\n+        assertNotEquals(OTHER_TIMEZONE, TimeZone.getDefault().getID(), \"We need a timezone different from the default JVM one\");\n+        Logging.initialize();\n+        server = TestingPrestoServer.create();\n+        referenceDrivers = ImmutableList.of(new PostgresqlReferenceDriver()/*, new OracleReferenceDriver()*/);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1NDQzNQ==", "bodyText": "BTW when i uncommented this, i got a failure\njava.lang.AssertionError: ud.udsoac.oacdty: 178\n\tat oracle.jdbc.driver.T4CTTIdcb.fillupAccessors(T4CTTIdcb.java:1049)\n\tat oracle.jdbc.driver.T4CTTIdcb.receiveCommon(T4CTTIdcb.java:234)\n\tat oracle.jdbc.driver.T4CTTIdcb.receive(T4CTTIdcb.java:168)\n\tat oracle.jdbc.driver.T4C8Oall.readDCB(T4C8Oall.java:1040)\n\tat oracle.jdbc.driver.T4CTTIfun.receive(T4CTTIfun.java:482)\n\tat oracle.jdbc.driver.T4CTTIfun.doRPC(T4CTTIfun.java:268)\n\tat oracle.jdbc.driver.T4C8Oall.doOALL(T4C8Oall.java:655)\n\tat oracle.jdbc.driver.T4CStatement.doOall8(T4CStatement.java:229)\n\tat oracle.jdbc.driver.T4CStatement.doOall8(T4CStatement.java:41)\n\tat oracle.jdbc.driver.T4CStatement.executeForDescribe(T4CStatement.java:765)\n\tat oracle.jdbc.driver.OracleStatement.executeMaybeDescribe(OracleStatement.java:983)\n\tat oracle.jdbc.driver.OracleStatement.doExecuteWithTimeout(OracleStatement.java:1168)\n\tat oracle.jdbc.driver.OracleStatement.executeQuery(OracleStatement.java:1362)\n\tat oracle.jdbc.driver.OracleStatementWrapper.executeQuery(OracleStatementWrapper.java:369)\n\tat io.prestosql.jdbc.TestJdbcResultSetTimezone$OracleReferenceDriver.query(TestJdbcResultSetTimezone.java:293)\n\tat io.prestosql.jdbc.TestJdbcResultSetTimezone.checkRepresentation(TestJdbcResultSetTimezone.java:238)\n\tat io.prestosql.jdbc.TestJdbcResultSetTimezone.checkRepresentation(TestJdbcResultSetTimezone.java:231)\n\tat io.prestosql.jdbc.TestJdbcResultSetTimezone.testTime(TestJdbcResultSetTimezone.java:156)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:566)\n\tat org.testng.internal.MethodInvocationHelper.invokeMethod(MethodInvocationHelper.java:104)\n\tat org.testng.internal.Invoker.invokeMethod(Invoker.java:645)\n\tat org.testng.internal.Invoker.invokeTestMethod(Invoker.java:851)\n\tat org.testng.internal.Invoker.invokeTestMethods(Invoker.java:1177)\n\tat org.testng.internal.TestMethodWorker.invokeTestMethods(TestMethodWorker.java:129)\n\tat org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:112)\n\tat org.testng.TestRunner.privateRun(TestRunner.java:756)\n\tat org.testng.TestRunner.run(TestRunner.java:610)\n\tat org.testng.SuiteRunner.runTest(SuiteRunner.java:387)\n\tat org.testng.SuiteRunner.runSequentially(SuiteRunner.java:382)\n\tat org.testng.SuiteRunner.privateRun(SuiteRunner.java:340)\n\tat org.testng.SuiteRunner.run(SuiteRunner.java:289)\n\nfor testTime for UTC and Warsaw time zones", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r456354435", "createdAt": "2020-07-17T10:17:54Z", "author": {"login": "findepi"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.jdbc;\n+\n+import com.google.common.io.Closer;\n+import io.airlift.log.Logging;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testcontainers.containers.OracleContainer;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import static io.prestosql.jdbc.TestPrestoDriver.closeQuietly;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+/**\n+ * Checks that JDBC dates and timestamps are interpreted in the client JVM timezone and should not\n+ * be affected by the session timezone.  We also compare the behavior to a reference JDBC driver.\n+ */\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetTimezone\n+{\n+    private static final String OTHER_TIMEZONE = \"Asia/Kathmandu\";\n+\n+    private TestingPrestoServer server;\n+    private List<ReferenceDriver> referenceDrivers;\n+\n+    private Connection connection;\n+    private Statement statement;\n+\n+    @BeforeClass\n+    public void setupServer()\n+    {\n+        assertNotEquals(OTHER_TIMEZONE, TimeZone.getDefault().getID(), \"We need a timezone different from the default JVM one\");\n+        Logging.initialize();\n+        server = TestingPrestoServer.create();\n+        referenceDrivers = ImmutableList.of(new PostgresqlReferenceDriver()/*, new OracleReferenceDriver()*/);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MTg1Mw=="}, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2NzgyNQ==", "bodyText": "I started with Oracle as the reference driver and David suggested using PostgreSQL instead.  I added PostgreSQL and was going to wait until the review is complete to remove Oracle, just in case.\ntestTime() was added after the switch and it turns out that it failed because Oracle does has no support for the TIME type (which should have been pretty clear from the assertion error).  I am removing Oracle as a reference driver.", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r456667825", "createdAt": "2020-07-17T20:49:40Z", "author": {"login": "aalbu"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.jdbc;\n+\n+import com.google.common.io.Closer;\n+import io.airlift.log.Logging;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testcontainers.containers.OracleContainer;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import static io.prestosql.jdbc.TestPrestoDriver.closeQuietly;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+/**\n+ * Checks that JDBC dates and timestamps are interpreted in the client JVM timezone and should not\n+ * be affected by the session timezone.  We also compare the behavior to a reference JDBC driver.\n+ */\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetTimezone\n+{\n+    private static final String OTHER_TIMEZONE = \"Asia/Kathmandu\";\n+\n+    private TestingPrestoServer server;\n+    private List<ReferenceDriver> referenceDrivers;\n+\n+    private Connection connection;\n+    private Statement statement;\n+\n+    @BeforeClass\n+    public void setupServer()\n+    {\n+        assertNotEquals(OTHER_TIMEZONE, TimeZone.getDefault().getID(), \"We need a timezone different from the default JVM one\");\n+        Logging.initialize();\n+        server = TestingPrestoServer.create();\n+        referenceDrivers = ImmutableList.of(new PostgresqlReferenceDriver()/*, new OracleReferenceDriver()*/);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MTg1Mw=="}, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc5MDk4OA==", "bodyText": "i see value in keeping Oracle as the reference. Would it be possible to keep it except for TIME?", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r456790988", "createdAt": "2020-07-18T13:37:03Z", "author": {"login": "findepi"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.jdbc;\n+\n+import com.google.common.io.Closer;\n+import io.airlift.log.Logging;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testcontainers.containers.OracleContainer;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import static io.prestosql.jdbc.TestPrestoDriver.closeQuietly;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+/**\n+ * Checks that JDBC dates and timestamps are interpreted in the client JVM timezone and should not\n+ * be affected by the session timezone.  We also compare the behavior to a reference JDBC driver.\n+ */\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetTimezone\n+{\n+    private static final String OTHER_TIMEZONE = \"Asia/Kathmandu\";\n+\n+    private TestingPrestoServer server;\n+    private List<ReferenceDriver> referenceDrivers;\n+\n+    private Connection connection;\n+    private Statement statement;\n+\n+    @BeforeClass\n+    public void setupServer()\n+    {\n+        assertNotEquals(OTHER_TIMEZONE, TimeZone.getDefault().getID(), \"We need a timezone different from the default JVM one\");\n+        Logging.initialize();\n+        server = TestingPrestoServer.create();\n+        referenceDrivers = ImmutableList.of(new PostgresqlReferenceDriver()/*, new OracleReferenceDriver()*/);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MTg1Mw=="}, "originalCommit": null, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjY4MjU1OnYy", "diffSide": "RIGHT", "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoyMDoyMVrOGzNvHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoyMDoyMVrOGzNvHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1NTYxMw==", "bodyText": "Add also ZoneId.systemDefault().getId()\nand some other zone west of Greenwich (even though ZoneId.systemDefault().getId() is west of Greenwich)", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r456355613", "createdAt": "2020-07-17T10:20:21Z", "author": {"login": "findepi"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.jdbc;\n+\n+import com.google.common.io.Closer;\n+import io.airlift.log.Logging;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testcontainers.containers.OracleContainer;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import static io.prestosql.jdbc.TestPrestoDriver.closeQuietly;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+/**\n+ * Checks that JDBC dates and timestamps are interpreted in the client JVM timezone and should not\n+ * be affected by the session timezone.  We also compare the behavior to a reference JDBC driver.\n+ */\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetTimezone\n+{\n+    private static final String OTHER_TIMEZONE = \"Asia/Kathmandu\";\n+\n+    private TestingPrestoServer server;\n+    private List<ReferenceDriver> referenceDrivers;\n+\n+    private Connection connection;\n+    private Statement statement;\n+\n+    @BeforeClass\n+    public void setupServer()\n+    {\n+        assertNotEquals(OTHER_TIMEZONE, TimeZone.getDefault().getID(), \"We need a timezone different from the default JVM one\");\n+        Logging.initialize();\n+        server = TestingPrestoServer.create();\n+        referenceDrivers = ImmutableList.of(new PostgresqlReferenceDriver()/*, new OracleReferenceDriver()*/);\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDownServer()\n+    {\n+        closeQuietly(server);\n+        referenceDrivers.forEach(ReferenceDriver::close);\n+    }\n+\n+    @SuppressWarnings(\"JDBCResourceOpenedButNotSafelyClosed\")\n+    @BeforeMethod\n+    public void setup()\n+            throws Exception\n+    {\n+        connection = DriverManager.getConnection(\"jdbc:presto://\" + server.getAddress(), \"test\", null);\n+        statement = connection.createStatement();\n+        referenceDrivers.forEach(ReferenceDriver::setup);\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void teardown()\n+            throws IOException\n+    {\n+        closeQuietly(statement);\n+        closeQuietly(connection);\n+        try (Closer closer = Closer.create()) {\n+            for (ReferenceDriver driver : referenceDrivers) {\n+                closer.register(driver::teardown);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] timeZoneIds()\n+    {\n+        return new Object[][] {\n+                {\"UTC\"},\n+                {\"Europe/Warsaw\"}", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjY4Mzk3OnYy", "diffSide": "RIGHT", "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoyMDo1MFrOGzNv9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMzozNzoyOVrOGzoT8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1NTgyOA==", "bodyText": "pgServer -> postgresqlContainer or postgresqlServer\nPostgreSQLContainer is a generic type", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r456355828", "createdAt": "2020-07-17T10:20:50Z", "author": {"login": "findepi"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.jdbc;\n+\n+import com.google.common.io.Closer;\n+import io.airlift.log.Logging;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testcontainers.containers.OracleContainer;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import static io.prestosql.jdbc.TestPrestoDriver.closeQuietly;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+/**\n+ * Checks that JDBC dates and timestamps are interpreted in the client JVM timezone and should not\n+ * be affected by the session timezone.  We also compare the behavior to a reference JDBC driver.\n+ */\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetTimezone\n+{\n+    private static final String OTHER_TIMEZONE = \"Asia/Kathmandu\";\n+\n+    private TestingPrestoServer server;\n+    private List<ReferenceDriver> referenceDrivers;\n+\n+    private Connection connection;\n+    private Statement statement;\n+\n+    @BeforeClass\n+    public void setupServer()\n+    {\n+        assertNotEquals(OTHER_TIMEZONE, TimeZone.getDefault().getID(), \"We need a timezone different from the default JVM one\");\n+        Logging.initialize();\n+        server = TestingPrestoServer.create();\n+        referenceDrivers = ImmutableList.of(new PostgresqlReferenceDriver()/*, new OracleReferenceDriver()*/);\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDownServer()\n+    {\n+        closeQuietly(server);\n+        referenceDrivers.forEach(ReferenceDriver::close);\n+    }\n+\n+    @SuppressWarnings(\"JDBCResourceOpenedButNotSafelyClosed\")\n+    @BeforeMethod\n+    public void setup()\n+            throws Exception\n+    {\n+        connection = DriverManager.getConnection(\"jdbc:presto://\" + server.getAddress(), \"test\", null);\n+        statement = connection.createStatement();\n+        referenceDrivers.forEach(ReferenceDriver::setup);\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void teardown()\n+            throws IOException\n+    {\n+        closeQuietly(statement);\n+        closeQuietly(connection);\n+        try (Closer closer = Closer.create()) {\n+            for (ReferenceDriver driver : referenceDrivers) {\n+                closer.register(driver::teardown);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] timeZoneIds()\n+    {\n+        return new Object[][] {\n+                {\"UTC\"},\n+                {\"Europe/Warsaw\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testDate(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"DATE '2018-02-13'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getDate(column), reference.getDate(column));\n+            assertEquals(rs.getDate(column), Date.valueOf(LocalDate.of(2018, 2, 13)));\n+        });\n+\n+        checkRepresentation(\"DATE '2018-02-13'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getDate(column, getCalendar()), reference.getDate(column, getCalendar()));\n+            assertEquals(rs.getDate(column, getCalendar()), new Date(LocalDate.of(2018, 2, 13).atStartOfDay(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTimestamp(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"TIMESTAMP '2018-02-13 13:14:15.123'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTimestamp(column), reference.getTimestamp(column));\n+            assertEquals(\n+                    rs.getTimestamp(column),\n+                    Timestamp.valueOf(LocalDateTime.of(2018, 2, 13, 13, 14, 15, 123_000_000)));\n+        });\n+\n+        checkRepresentation(\"TIMESTAMP '2018-02-13 13:14:15.123'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTimestamp(column, getCalendar()), reference.getTimestamp(column, getCalendar()));\n+            assertEquals(\n+                    rs.getTimestamp(column, getCalendar()),\n+                    new Timestamp(LocalDateTime.of(2018, 2, 13, 13, 14, 15, 123_000_000).atZone(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTime(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"TIME '09:39:05'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTime(column), reference.getTime(column));\n+            assertEquals(rs.getTime(column), Time.valueOf(LocalTime.of(9, 39, 5)));\n+        });\n+\n+        checkRepresentation(\"TIME '09:39:05'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTime(column, getCalendar()), reference.getTime(column, getCalendar()));\n+            assertEquals(rs.getTime(column, getCalendar()), new Time(LocalDate.of(1970, 1, 1).atTime(LocalTime.of(9, 39, 5)).atZone(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testDateRoundTrip(String sessionTimezoneId)\n+            throws SQLException\n+    {\n+        LocalDate date = LocalDate.of(2001, 5, 6);\n+        Date sqlDate = Date.valueOf(date);\n+        java.util.Date javaDate = new java.util.Date(sqlDate.getTime());\n+        LocalDateTime dateTime = LocalDateTime.of(date, LocalTime.of(12, 34, 56));\n+        Timestamp sqlTimestamp = Timestamp.valueOf(dateTime);\n+\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setDate(i, sqlDate));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, javaDate, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, date, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, dateTime, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, \"2001-05-06\", Types.DATE));\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTimestampRoundTrip(String sessionTimezoneId)\n+            throws SQLException\n+    {\n+        LocalDateTime dateTime = LocalDateTime.of(2001, 5, 6, 12, 34, 56);\n+        Date sqlDate = Date.valueOf(dateTime.toLocalDate());\n+        Time sqlTime = Time.valueOf(dateTime.toLocalTime());\n+        Timestamp sqlTimestamp = Timestamp.valueOf(dateTime);\n+        Timestamp sameInstantInWarsawZone = Timestamp.valueOf(dateTime.atZone(ZoneId.systemDefault()).withZoneSameInstant(ZoneId.of(\"Europe/Warsaw\")).toLocalDateTime());\n+        java.util.Date javaDate = java.util.Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant());\n+\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, null));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, Calendar.getInstance()));\n+        assertParameter(sameInstantInWarsawZone, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, Calendar.getInstance(TimeZone.getTimeZone(\"Europe/Warsaw\"))));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp));\n+        assertParameter(new Timestamp(sqlDate.getTime()), sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate, Types.TIMESTAMP));\n+        assertParameter(new Timestamp(sqlTime.getTime()), sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTime, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, javaDate, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, dateTime, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, \"2001-05-06 12:34:56\", Types.TIMESTAMP));\n+    }\n+\n+    private void assertParameter(Object expectedValue, String sessionTimezoneId, Binder binder)\n+            throws SQLException\n+    {\n+        connection.unwrap(PrestoConnection.class).setTimeZoneId(sessionTimezoneId);\n+        try (PreparedStatement statement = connection.prepareStatement(\"SELECT ?\")) {\n+            binder.bind(statement, 1);\n+\n+            try (ResultSet rs = statement.executeQuery()) {\n+                assertTrue(rs.next());\n+                assertEquals(expectedValue, rs.getObject(1));\n+                assertFalse(rs.next());\n+            }\n+        }\n+    }\n+\n+    private void checkRepresentation(String expression, String sessionTimezoneId, ResultAssertion assertion)\n+            throws Exception\n+    {\n+        for (ReferenceDriver driver : referenceDrivers) {\n+            // log the name of the driver if we're going to use more than one\n+            checkRepresentation(expression, sessionTimezoneId, driver, assertion);\n+        }\n+    }\n+\n+    private void checkRepresentation(String expression, String sessionTimezoneId, ReferenceDriver reference, ResultAssertion assertion)\n+            throws Exception\n+    {\n+        try (ResultSet rs = prestoQuery(expression, sessionTimezoneId); ResultSet referenceResultSet = reference.query(expression, sessionTimezoneId)) {\n+            assertTrue(rs.next());\n+            assertTrue(referenceResultSet.next());\n+            assertion.accept(rs, referenceResultSet, 1);\n+            assertFalse(rs.next());\n+            assertFalse(referenceResultSet.next());\n+        }\n+    }\n+\n+    private ResultSet prestoQuery(String expression, String timezoneId)\n+            throws Exception\n+    {\n+        connection.unwrap(PrestoConnection.class).setTimeZoneId(timezoneId);\n+        return statement.executeQuery(\"SELECT \" + expression);\n+    }\n+\n+    private Calendar getCalendar()\n+    {\n+        return Calendar.getInstance(TimeZone.getTimeZone(OTHER_TIMEZONE));\n+    }\n+\n+    private ZoneId getZoneId()\n+    {\n+        return ZoneId.of(getCalendar().getTimeZone().getID());\n+    }\n+\n+    private interface ReferenceDriver\n+    {\n+        ResultSet query(String expression, String timezoneId) throws Exception;\n+\n+        void setup();\n+\n+        void teardown();\n+\n+        void close();\n+    }\n+\n+    private static class OracleReferenceDriver\n+            implements ReferenceDriver\n+    {\n+        private OracleContainer oracleServer;\n+        private Connection connection;\n+        private Statement statement;\n+\n+        OracleReferenceDriver()\n+        {\n+            oracleServer = new OracleContainer(\"wnameless/oracle-xe-11g-r2\");\n+            oracleServer.start();\n+        }\n+\n+        @Override\n+        public ResultSet query(String expression, String timezoneId)\n+                throws Exception\n+        {\n+            statement.execute(format(\"ALTER SESSION SET TIME_ZONE='%s'\", timezoneId));\n+            return statement.executeQuery(format(\"SELECT %s FROM dual\", expression));\n+        }\n+\n+        @Override\n+        public void setup()\n+        {\n+            try {\n+                connection = DriverManager.getConnection(oracleServer.getJdbcUrl(), oracleServer.getUsername(), oracleServer.getPassword());\n+                statement = connection.createStatement();\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public void teardown()\n+        {\n+            closeQuietly(statement);\n+            closeQuietly(connection);\n+        }\n+\n+        @Override\n+        public void close()\n+        {\n+            oracleServer.stop();\n+        }\n+    }\n+\n+    private static class PostgresqlReferenceDriver\n+            implements ReferenceDriver\n+    {\n+        private PostgreSQLContainer pgServer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY5MzA3Ng==", "bodyText": "Yeah, but it has a recursive bound on its generic type parameter.  I don't know how to use a generic type here \ud83e\udd28", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r456693076", "createdAt": "2020-07-17T22:03:30Z", "author": {"login": "aalbu"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.jdbc;\n+\n+import com.google.common.io.Closer;\n+import io.airlift.log.Logging;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testcontainers.containers.OracleContainer;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import static io.prestosql.jdbc.TestPrestoDriver.closeQuietly;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+/**\n+ * Checks that JDBC dates and timestamps are interpreted in the client JVM timezone and should not\n+ * be affected by the session timezone.  We also compare the behavior to a reference JDBC driver.\n+ */\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetTimezone\n+{\n+    private static final String OTHER_TIMEZONE = \"Asia/Kathmandu\";\n+\n+    private TestingPrestoServer server;\n+    private List<ReferenceDriver> referenceDrivers;\n+\n+    private Connection connection;\n+    private Statement statement;\n+\n+    @BeforeClass\n+    public void setupServer()\n+    {\n+        assertNotEquals(OTHER_TIMEZONE, TimeZone.getDefault().getID(), \"We need a timezone different from the default JVM one\");\n+        Logging.initialize();\n+        server = TestingPrestoServer.create();\n+        referenceDrivers = ImmutableList.of(new PostgresqlReferenceDriver()/*, new OracleReferenceDriver()*/);\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDownServer()\n+    {\n+        closeQuietly(server);\n+        referenceDrivers.forEach(ReferenceDriver::close);\n+    }\n+\n+    @SuppressWarnings(\"JDBCResourceOpenedButNotSafelyClosed\")\n+    @BeforeMethod\n+    public void setup()\n+            throws Exception\n+    {\n+        connection = DriverManager.getConnection(\"jdbc:presto://\" + server.getAddress(), \"test\", null);\n+        statement = connection.createStatement();\n+        referenceDrivers.forEach(ReferenceDriver::setup);\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void teardown()\n+            throws IOException\n+    {\n+        closeQuietly(statement);\n+        closeQuietly(connection);\n+        try (Closer closer = Closer.create()) {\n+            for (ReferenceDriver driver : referenceDrivers) {\n+                closer.register(driver::teardown);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] timeZoneIds()\n+    {\n+        return new Object[][] {\n+                {\"UTC\"},\n+                {\"Europe/Warsaw\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testDate(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"DATE '2018-02-13'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getDate(column), reference.getDate(column));\n+            assertEquals(rs.getDate(column), Date.valueOf(LocalDate.of(2018, 2, 13)));\n+        });\n+\n+        checkRepresentation(\"DATE '2018-02-13'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getDate(column, getCalendar()), reference.getDate(column, getCalendar()));\n+            assertEquals(rs.getDate(column, getCalendar()), new Date(LocalDate.of(2018, 2, 13).atStartOfDay(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTimestamp(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"TIMESTAMP '2018-02-13 13:14:15.123'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTimestamp(column), reference.getTimestamp(column));\n+            assertEquals(\n+                    rs.getTimestamp(column),\n+                    Timestamp.valueOf(LocalDateTime.of(2018, 2, 13, 13, 14, 15, 123_000_000)));\n+        });\n+\n+        checkRepresentation(\"TIMESTAMP '2018-02-13 13:14:15.123'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTimestamp(column, getCalendar()), reference.getTimestamp(column, getCalendar()));\n+            assertEquals(\n+                    rs.getTimestamp(column, getCalendar()),\n+                    new Timestamp(LocalDateTime.of(2018, 2, 13, 13, 14, 15, 123_000_000).atZone(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTime(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"TIME '09:39:05'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTime(column), reference.getTime(column));\n+            assertEquals(rs.getTime(column), Time.valueOf(LocalTime.of(9, 39, 5)));\n+        });\n+\n+        checkRepresentation(\"TIME '09:39:05'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTime(column, getCalendar()), reference.getTime(column, getCalendar()));\n+            assertEquals(rs.getTime(column, getCalendar()), new Time(LocalDate.of(1970, 1, 1).atTime(LocalTime.of(9, 39, 5)).atZone(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testDateRoundTrip(String sessionTimezoneId)\n+            throws SQLException\n+    {\n+        LocalDate date = LocalDate.of(2001, 5, 6);\n+        Date sqlDate = Date.valueOf(date);\n+        java.util.Date javaDate = new java.util.Date(sqlDate.getTime());\n+        LocalDateTime dateTime = LocalDateTime.of(date, LocalTime.of(12, 34, 56));\n+        Timestamp sqlTimestamp = Timestamp.valueOf(dateTime);\n+\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setDate(i, sqlDate));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, javaDate, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, date, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, dateTime, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, \"2001-05-06\", Types.DATE));\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTimestampRoundTrip(String sessionTimezoneId)\n+            throws SQLException\n+    {\n+        LocalDateTime dateTime = LocalDateTime.of(2001, 5, 6, 12, 34, 56);\n+        Date sqlDate = Date.valueOf(dateTime.toLocalDate());\n+        Time sqlTime = Time.valueOf(dateTime.toLocalTime());\n+        Timestamp sqlTimestamp = Timestamp.valueOf(dateTime);\n+        Timestamp sameInstantInWarsawZone = Timestamp.valueOf(dateTime.atZone(ZoneId.systemDefault()).withZoneSameInstant(ZoneId.of(\"Europe/Warsaw\")).toLocalDateTime());\n+        java.util.Date javaDate = java.util.Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant());\n+\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, null));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, Calendar.getInstance()));\n+        assertParameter(sameInstantInWarsawZone, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, Calendar.getInstance(TimeZone.getTimeZone(\"Europe/Warsaw\"))));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp));\n+        assertParameter(new Timestamp(sqlDate.getTime()), sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate, Types.TIMESTAMP));\n+        assertParameter(new Timestamp(sqlTime.getTime()), sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTime, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, javaDate, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, dateTime, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, \"2001-05-06 12:34:56\", Types.TIMESTAMP));\n+    }\n+\n+    private void assertParameter(Object expectedValue, String sessionTimezoneId, Binder binder)\n+            throws SQLException\n+    {\n+        connection.unwrap(PrestoConnection.class).setTimeZoneId(sessionTimezoneId);\n+        try (PreparedStatement statement = connection.prepareStatement(\"SELECT ?\")) {\n+            binder.bind(statement, 1);\n+\n+            try (ResultSet rs = statement.executeQuery()) {\n+                assertTrue(rs.next());\n+                assertEquals(expectedValue, rs.getObject(1));\n+                assertFalse(rs.next());\n+            }\n+        }\n+    }\n+\n+    private void checkRepresentation(String expression, String sessionTimezoneId, ResultAssertion assertion)\n+            throws Exception\n+    {\n+        for (ReferenceDriver driver : referenceDrivers) {\n+            // log the name of the driver if we're going to use more than one\n+            checkRepresentation(expression, sessionTimezoneId, driver, assertion);\n+        }\n+    }\n+\n+    private void checkRepresentation(String expression, String sessionTimezoneId, ReferenceDriver reference, ResultAssertion assertion)\n+            throws Exception\n+    {\n+        try (ResultSet rs = prestoQuery(expression, sessionTimezoneId); ResultSet referenceResultSet = reference.query(expression, sessionTimezoneId)) {\n+            assertTrue(rs.next());\n+            assertTrue(referenceResultSet.next());\n+            assertion.accept(rs, referenceResultSet, 1);\n+            assertFalse(rs.next());\n+            assertFalse(referenceResultSet.next());\n+        }\n+    }\n+\n+    private ResultSet prestoQuery(String expression, String timezoneId)\n+            throws Exception\n+    {\n+        connection.unwrap(PrestoConnection.class).setTimeZoneId(timezoneId);\n+        return statement.executeQuery(\"SELECT \" + expression);\n+    }\n+\n+    private Calendar getCalendar()\n+    {\n+        return Calendar.getInstance(TimeZone.getTimeZone(OTHER_TIMEZONE));\n+    }\n+\n+    private ZoneId getZoneId()\n+    {\n+        return ZoneId.of(getCalendar().getTimeZone().getID());\n+    }\n+\n+    private interface ReferenceDriver\n+    {\n+        ResultSet query(String expression, String timezoneId) throws Exception;\n+\n+        void setup();\n+\n+        void teardown();\n+\n+        void close();\n+    }\n+\n+    private static class OracleReferenceDriver\n+            implements ReferenceDriver\n+    {\n+        private OracleContainer oracleServer;\n+        private Connection connection;\n+        private Statement statement;\n+\n+        OracleReferenceDriver()\n+        {\n+            oracleServer = new OracleContainer(\"wnameless/oracle-xe-11g-r2\");\n+            oracleServer.start();\n+        }\n+\n+        @Override\n+        public ResultSet query(String expression, String timezoneId)\n+                throws Exception\n+        {\n+            statement.execute(format(\"ALTER SESSION SET TIME_ZONE='%s'\", timezoneId));\n+            return statement.executeQuery(format(\"SELECT %s FROM dual\", expression));\n+        }\n+\n+        @Override\n+        public void setup()\n+        {\n+            try {\n+                connection = DriverManager.getConnection(oracleServer.getJdbcUrl(), oracleServer.getUsername(), oracleServer.getPassword());\n+                statement = connection.createStatement();\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public void teardown()\n+        {\n+            closeQuietly(statement);\n+            closeQuietly(connection);\n+        }\n+\n+        @Override\n+        public void close()\n+        {\n+            oracleServer.stop();\n+        }\n+    }\n+\n+    private static class PostgresqlReferenceDriver\n+            implements ReferenceDriver\n+    {\n+        private PostgreSQLContainer pgServer;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1NTgyOA=="}, "originalCommit": null, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc5MTAyNQ==", "bodyText": "PostgreSQLContainer<?>", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r456791025", "createdAt": "2020-07-18T13:37:29Z", "author": {"login": "findepi"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.jdbc;\n+\n+import com.google.common.io.Closer;\n+import io.airlift.log.Logging;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testcontainers.containers.OracleContainer;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import static io.prestosql.jdbc.TestPrestoDriver.closeQuietly;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+/**\n+ * Checks that JDBC dates and timestamps are interpreted in the client JVM timezone and should not\n+ * be affected by the session timezone.  We also compare the behavior to a reference JDBC driver.\n+ */\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetTimezone\n+{\n+    private static final String OTHER_TIMEZONE = \"Asia/Kathmandu\";\n+\n+    private TestingPrestoServer server;\n+    private List<ReferenceDriver> referenceDrivers;\n+\n+    private Connection connection;\n+    private Statement statement;\n+\n+    @BeforeClass\n+    public void setupServer()\n+    {\n+        assertNotEquals(OTHER_TIMEZONE, TimeZone.getDefault().getID(), \"We need a timezone different from the default JVM one\");\n+        Logging.initialize();\n+        server = TestingPrestoServer.create();\n+        referenceDrivers = ImmutableList.of(new PostgresqlReferenceDriver()/*, new OracleReferenceDriver()*/);\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDownServer()\n+    {\n+        closeQuietly(server);\n+        referenceDrivers.forEach(ReferenceDriver::close);\n+    }\n+\n+    @SuppressWarnings(\"JDBCResourceOpenedButNotSafelyClosed\")\n+    @BeforeMethod\n+    public void setup()\n+            throws Exception\n+    {\n+        connection = DriverManager.getConnection(\"jdbc:presto://\" + server.getAddress(), \"test\", null);\n+        statement = connection.createStatement();\n+        referenceDrivers.forEach(ReferenceDriver::setup);\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void teardown()\n+            throws IOException\n+    {\n+        closeQuietly(statement);\n+        closeQuietly(connection);\n+        try (Closer closer = Closer.create()) {\n+            for (ReferenceDriver driver : referenceDrivers) {\n+                closer.register(driver::teardown);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] timeZoneIds()\n+    {\n+        return new Object[][] {\n+                {\"UTC\"},\n+                {\"Europe/Warsaw\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testDate(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"DATE '2018-02-13'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getDate(column), reference.getDate(column));\n+            assertEquals(rs.getDate(column), Date.valueOf(LocalDate.of(2018, 2, 13)));\n+        });\n+\n+        checkRepresentation(\"DATE '2018-02-13'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getDate(column, getCalendar()), reference.getDate(column, getCalendar()));\n+            assertEquals(rs.getDate(column, getCalendar()), new Date(LocalDate.of(2018, 2, 13).atStartOfDay(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTimestamp(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"TIMESTAMP '2018-02-13 13:14:15.123'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTimestamp(column), reference.getTimestamp(column));\n+            assertEquals(\n+                    rs.getTimestamp(column),\n+                    Timestamp.valueOf(LocalDateTime.of(2018, 2, 13, 13, 14, 15, 123_000_000)));\n+        });\n+\n+        checkRepresentation(\"TIMESTAMP '2018-02-13 13:14:15.123'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTimestamp(column, getCalendar()), reference.getTimestamp(column, getCalendar()));\n+            assertEquals(\n+                    rs.getTimestamp(column, getCalendar()),\n+                    new Timestamp(LocalDateTime.of(2018, 2, 13, 13, 14, 15, 123_000_000).atZone(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTime(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"TIME '09:39:05'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTime(column), reference.getTime(column));\n+            assertEquals(rs.getTime(column), Time.valueOf(LocalTime.of(9, 39, 5)));\n+        });\n+\n+        checkRepresentation(\"TIME '09:39:05'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTime(column, getCalendar()), reference.getTime(column, getCalendar()));\n+            assertEquals(rs.getTime(column, getCalendar()), new Time(LocalDate.of(1970, 1, 1).atTime(LocalTime.of(9, 39, 5)).atZone(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testDateRoundTrip(String sessionTimezoneId)\n+            throws SQLException\n+    {\n+        LocalDate date = LocalDate.of(2001, 5, 6);\n+        Date sqlDate = Date.valueOf(date);\n+        java.util.Date javaDate = new java.util.Date(sqlDate.getTime());\n+        LocalDateTime dateTime = LocalDateTime.of(date, LocalTime.of(12, 34, 56));\n+        Timestamp sqlTimestamp = Timestamp.valueOf(dateTime);\n+\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setDate(i, sqlDate));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, javaDate, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, date, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, dateTime, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, \"2001-05-06\", Types.DATE));\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTimestampRoundTrip(String sessionTimezoneId)\n+            throws SQLException\n+    {\n+        LocalDateTime dateTime = LocalDateTime.of(2001, 5, 6, 12, 34, 56);\n+        Date sqlDate = Date.valueOf(dateTime.toLocalDate());\n+        Time sqlTime = Time.valueOf(dateTime.toLocalTime());\n+        Timestamp sqlTimestamp = Timestamp.valueOf(dateTime);\n+        Timestamp sameInstantInWarsawZone = Timestamp.valueOf(dateTime.atZone(ZoneId.systemDefault()).withZoneSameInstant(ZoneId.of(\"Europe/Warsaw\")).toLocalDateTime());\n+        java.util.Date javaDate = java.util.Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant());\n+\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, null));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, Calendar.getInstance()));\n+        assertParameter(sameInstantInWarsawZone, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, Calendar.getInstance(TimeZone.getTimeZone(\"Europe/Warsaw\"))));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp));\n+        assertParameter(new Timestamp(sqlDate.getTime()), sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate, Types.TIMESTAMP));\n+        assertParameter(new Timestamp(sqlTime.getTime()), sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTime, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, javaDate, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, dateTime, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, \"2001-05-06 12:34:56\", Types.TIMESTAMP));\n+    }\n+\n+    private void assertParameter(Object expectedValue, String sessionTimezoneId, Binder binder)\n+            throws SQLException\n+    {\n+        connection.unwrap(PrestoConnection.class).setTimeZoneId(sessionTimezoneId);\n+        try (PreparedStatement statement = connection.prepareStatement(\"SELECT ?\")) {\n+            binder.bind(statement, 1);\n+\n+            try (ResultSet rs = statement.executeQuery()) {\n+                assertTrue(rs.next());\n+                assertEquals(expectedValue, rs.getObject(1));\n+                assertFalse(rs.next());\n+            }\n+        }\n+    }\n+\n+    private void checkRepresentation(String expression, String sessionTimezoneId, ResultAssertion assertion)\n+            throws Exception\n+    {\n+        for (ReferenceDriver driver : referenceDrivers) {\n+            // log the name of the driver if we're going to use more than one\n+            checkRepresentation(expression, sessionTimezoneId, driver, assertion);\n+        }\n+    }\n+\n+    private void checkRepresentation(String expression, String sessionTimezoneId, ReferenceDriver reference, ResultAssertion assertion)\n+            throws Exception\n+    {\n+        try (ResultSet rs = prestoQuery(expression, sessionTimezoneId); ResultSet referenceResultSet = reference.query(expression, sessionTimezoneId)) {\n+            assertTrue(rs.next());\n+            assertTrue(referenceResultSet.next());\n+            assertion.accept(rs, referenceResultSet, 1);\n+            assertFalse(rs.next());\n+            assertFalse(referenceResultSet.next());\n+        }\n+    }\n+\n+    private ResultSet prestoQuery(String expression, String timezoneId)\n+            throws Exception\n+    {\n+        connection.unwrap(PrestoConnection.class).setTimeZoneId(timezoneId);\n+        return statement.executeQuery(\"SELECT \" + expression);\n+    }\n+\n+    private Calendar getCalendar()\n+    {\n+        return Calendar.getInstance(TimeZone.getTimeZone(OTHER_TIMEZONE));\n+    }\n+\n+    private ZoneId getZoneId()\n+    {\n+        return ZoneId.of(getCalendar().getTimeZone().getID());\n+    }\n+\n+    private interface ReferenceDriver\n+    {\n+        ResultSet query(String expression, String timezoneId) throws Exception;\n+\n+        void setup();\n+\n+        void teardown();\n+\n+        void close();\n+    }\n+\n+    private static class OracleReferenceDriver\n+            implements ReferenceDriver\n+    {\n+        private OracleContainer oracleServer;\n+        private Connection connection;\n+        private Statement statement;\n+\n+        OracleReferenceDriver()\n+        {\n+            oracleServer = new OracleContainer(\"wnameless/oracle-xe-11g-r2\");\n+            oracleServer.start();\n+        }\n+\n+        @Override\n+        public ResultSet query(String expression, String timezoneId)\n+                throws Exception\n+        {\n+            statement.execute(format(\"ALTER SESSION SET TIME_ZONE='%s'\", timezoneId));\n+            return statement.executeQuery(format(\"SELECT %s FROM dual\", expression));\n+        }\n+\n+        @Override\n+        public void setup()\n+        {\n+            try {\n+                connection = DriverManager.getConnection(oracleServer.getJdbcUrl(), oracleServer.getUsername(), oracleServer.getPassword());\n+                statement = connection.createStatement();\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public void teardown()\n+        {\n+            closeQuietly(statement);\n+            closeQuietly(connection);\n+        }\n+\n+        @Override\n+        public void close()\n+        {\n+            oracleServer.stop();\n+        }\n+    }\n+\n+    private static class PostgresqlReferenceDriver\n+            implements ReferenceDriver\n+    {\n+        private PostgreSQLContainer pgServer;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1NTgyOA=="}, "originalCommit": null, "originalPosition": 325}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjY4NzEwOnYy", "diffSide": "RIGHT", "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoyMTo1NFrOGzNx3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMjoyOToyOVrOGziwlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1NjMxNw==", "bodyText": "This should be not be necessary.\njust replace\nconnection = DriverManager.getConnection(pgServer.getJdbcUrl(), \"test\", \"test\");\n\nbelow with\nconnection = pgServer.createConnection(\"\");", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r456356317", "createdAt": "2020-07-17T10:21:54Z", "author": {"login": "findepi"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.jdbc;\n+\n+import com.google.common.io.Closer;\n+import io.airlift.log.Logging;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testcontainers.containers.OracleContainer;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import static io.prestosql.jdbc.TestPrestoDriver.closeQuietly;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+/**\n+ * Checks that JDBC dates and timestamps are interpreted in the client JVM timezone and should not\n+ * be affected by the session timezone.  We also compare the behavior to a reference JDBC driver.\n+ */\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetTimezone\n+{\n+    private static final String OTHER_TIMEZONE = \"Asia/Kathmandu\";\n+\n+    private TestingPrestoServer server;\n+    private List<ReferenceDriver> referenceDrivers;\n+\n+    private Connection connection;\n+    private Statement statement;\n+\n+    @BeforeClass\n+    public void setupServer()\n+    {\n+        assertNotEquals(OTHER_TIMEZONE, TimeZone.getDefault().getID(), \"We need a timezone different from the default JVM one\");\n+        Logging.initialize();\n+        server = TestingPrestoServer.create();\n+        referenceDrivers = ImmutableList.of(new PostgresqlReferenceDriver()/*, new OracleReferenceDriver()*/);\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDownServer()\n+    {\n+        closeQuietly(server);\n+        referenceDrivers.forEach(ReferenceDriver::close);\n+    }\n+\n+    @SuppressWarnings(\"JDBCResourceOpenedButNotSafelyClosed\")\n+    @BeforeMethod\n+    public void setup()\n+            throws Exception\n+    {\n+        connection = DriverManager.getConnection(\"jdbc:presto://\" + server.getAddress(), \"test\", null);\n+        statement = connection.createStatement();\n+        referenceDrivers.forEach(ReferenceDriver::setup);\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void teardown()\n+            throws IOException\n+    {\n+        closeQuietly(statement);\n+        closeQuietly(connection);\n+        try (Closer closer = Closer.create()) {\n+            for (ReferenceDriver driver : referenceDrivers) {\n+                closer.register(driver::teardown);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] timeZoneIds()\n+    {\n+        return new Object[][] {\n+                {\"UTC\"},\n+                {\"Europe/Warsaw\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testDate(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"DATE '2018-02-13'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getDate(column), reference.getDate(column));\n+            assertEquals(rs.getDate(column), Date.valueOf(LocalDate.of(2018, 2, 13)));\n+        });\n+\n+        checkRepresentation(\"DATE '2018-02-13'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getDate(column, getCalendar()), reference.getDate(column, getCalendar()));\n+            assertEquals(rs.getDate(column, getCalendar()), new Date(LocalDate.of(2018, 2, 13).atStartOfDay(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTimestamp(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"TIMESTAMP '2018-02-13 13:14:15.123'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTimestamp(column), reference.getTimestamp(column));\n+            assertEquals(\n+                    rs.getTimestamp(column),\n+                    Timestamp.valueOf(LocalDateTime.of(2018, 2, 13, 13, 14, 15, 123_000_000)));\n+        });\n+\n+        checkRepresentation(\"TIMESTAMP '2018-02-13 13:14:15.123'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTimestamp(column, getCalendar()), reference.getTimestamp(column, getCalendar()));\n+            assertEquals(\n+                    rs.getTimestamp(column, getCalendar()),\n+                    new Timestamp(LocalDateTime.of(2018, 2, 13, 13, 14, 15, 123_000_000).atZone(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTime(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"TIME '09:39:05'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTime(column), reference.getTime(column));\n+            assertEquals(rs.getTime(column), Time.valueOf(LocalTime.of(9, 39, 5)));\n+        });\n+\n+        checkRepresentation(\"TIME '09:39:05'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTime(column, getCalendar()), reference.getTime(column, getCalendar()));\n+            assertEquals(rs.getTime(column, getCalendar()), new Time(LocalDate.of(1970, 1, 1).atTime(LocalTime.of(9, 39, 5)).atZone(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testDateRoundTrip(String sessionTimezoneId)\n+            throws SQLException\n+    {\n+        LocalDate date = LocalDate.of(2001, 5, 6);\n+        Date sqlDate = Date.valueOf(date);\n+        java.util.Date javaDate = new java.util.Date(sqlDate.getTime());\n+        LocalDateTime dateTime = LocalDateTime.of(date, LocalTime.of(12, 34, 56));\n+        Timestamp sqlTimestamp = Timestamp.valueOf(dateTime);\n+\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setDate(i, sqlDate));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, javaDate, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, date, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, dateTime, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, \"2001-05-06\", Types.DATE));\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTimestampRoundTrip(String sessionTimezoneId)\n+            throws SQLException\n+    {\n+        LocalDateTime dateTime = LocalDateTime.of(2001, 5, 6, 12, 34, 56);\n+        Date sqlDate = Date.valueOf(dateTime.toLocalDate());\n+        Time sqlTime = Time.valueOf(dateTime.toLocalTime());\n+        Timestamp sqlTimestamp = Timestamp.valueOf(dateTime);\n+        Timestamp sameInstantInWarsawZone = Timestamp.valueOf(dateTime.atZone(ZoneId.systemDefault()).withZoneSameInstant(ZoneId.of(\"Europe/Warsaw\")).toLocalDateTime());\n+        java.util.Date javaDate = java.util.Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant());\n+\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, null));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, Calendar.getInstance()));\n+        assertParameter(sameInstantInWarsawZone, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, Calendar.getInstance(TimeZone.getTimeZone(\"Europe/Warsaw\"))));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp));\n+        assertParameter(new Timestamp(sqlDate.getTime()), sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate, Types.TIMESTAMP));\n+        assertParameter(new Timestamp(sqlTime.getTime()), sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTime, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, javaDate, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, dateTime, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, \"2001-05-06 12:34:56\", Types.TIMESTAMP));\n+    }\n+\n+    private void assertParameter(Object expectedValue, String sessionTimezoneId, Binder binder)\n+            throws SQLException\n+    {\n+        connection.unwrap(PrestoConnection.class).setTimeZoneId(sessionTimezoneId);\n+        try (PreparedStatement statement = connection.prepareStatement(\"SELECT ?\")) {\n+            binder.bind(statement, 1);\n+\n+            try (ResultSet rs = statement.executeQuery()) {\n+                assertTrue(rs.next());\n+                assertEquals(expectedValue, rs.getObject(1));\n+                assertFalse(rs.next());\n+            }\n+        }\n+    }\n+\n+    private void checkRepresentation(String expression, String sessionTimezoneId, ResultAssertion assertion)\n+            throws Exception\n+    {\n+        for (ReferenceDriver driver : referenceDrivers) {\n+            // log the name of the driver if we're going to use more than one\n+            checkRepresentation(expression, sessionTimezoneId, driver, assertion);\n+        }\n+    }\n+\n+    private void checkRepresentation(String expression, String sessionTimezoneId, ReferenceDriver reference, ResultAssertion assertion)\n+            throws Exception\n+    {\n+        try (ResultSet rs = prestoQuery(expression, sessionTimezoneId); ResultSet referenceResultSet = reference.query(expression, sessionTimezoneId)) {\n+            assertTrue(rs.next());\n+            assertTrue(referenceResultSet.next());\n+            assertion.accept(rs, referenceResultSet, 1);\n+            assertFalse(rs.next());\n+            assertFalse(referenceResultSet.next());\n+        }\n+    }\n+\n+    private ResultSet prestoQuery(String expression, String timezoneId)\n+            throws Exception\n+    {\n+        connection.unwrap(PrestoConnection.class).setTimeZoneId(timezoneId);\n+        return statement.executeQuery(\"SELECT \" + expression);\n+    }\n+\n+    private Calendar getCalendar()\n+    {\n+        return Calendar.getInstance(TimeZone.getTimeZone(OTHER_TIMEZONE));\n+    }\n+\n+    private ZoneId getZoneId()\n+    {\n+        return ZoneId.of(getCalendar().getTimeZone().getID());\n+    }\n+\n+    private interface ReferenceDriver\n+    {\n+        ResultSet query(String expression, String timezoneId) throws Exception;\n+\n+        void setup();\n+\n+        void teardown();\n+\n+        void close();\n+    }\n+\n+    private static class OracleReferenceDriver\n+            implements ReferenceDriver\n+    {\n+        private OracleContainer oracleServer;\n+        private Connection connection;\n+        private Statement statement;\n+\n+        OracleReferenceDriver()\n+        {\n+            oracleServer = new OracleContainer(\"wnameless/oracle-xe-11g-r2\");\n+            oracleServer.start();\n+        }\n+\n+        @Override\n+        public ResultSet query(String expression, String timezoneId)\n+                throws Exception\n+        {\n+            statement.execute(format(\"ALTER SESSION SET TIME_ZONE='%s'\", timezoneId));\n+            return statement.executeQuery(format(\"SELECT %s FROM dual\", expression));\n+        }\n+\n+        @Override\n+        public void setup()\n+        {\n+            try {\n+                connection = DriverManager.getConnection(oracleServer.getJdbcUrl(), oracleServer.getUsername(), oracleServer.getPassword());\n+                statement = connection.createStatement();\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public void teardown()\n+        {\n+            closeQuietly(statement);\n+            closeQuietly(connection);\n+        }\n+\n+        @Override\n+        public void close()\n+        {\n+            oracleServer.stop();\n+        }\n+    }\n+\n+    private static class PostgresqlReferenceDriver\n+            implements ReferenceDriver\n+    {\n+        private PostgreSQLContainer pgServer;\n+        private Connection connection;\n+        private Statement statement;\n+\n+        PostgresqlReferenceDriver()\n+        {\n+            pgServer = new PostgreSQLContainer(\"postgres:10.3\")\n+                    .withDatabaseName(\"tpch\")\n+                    .withUsername(\"test\")\n+                    .withPassword(\"test\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwMDA1Mg==", "bodyText": "Neat.", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r456700052", "createdAt": "2020-07-17T22:29:29Z", "author": {"login": "aalbu"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.jdbc;\n+\n+import com.google.common.io.Closer;\n+import io.airlift.log.Logging;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testcontainers.containers.OracleContainer;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import static io.prestosql.jdbc.TestPrestoDriver.closeQuietly;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+/**\n+ * Checks that JDBC dates and timestamps are interpreted in the client JVM timezone and should not\n+ * be affected by the session timezone.  We also compare the behavior to a reference JDBC driver.\n+ */\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetTimezone\n+{\n+    private static final String OTHER_TIMEZONE = \"Asia/Kathmandu\";\n+\n+    private TestingPrestoServer server;\n+    private List<ReferenceDriver> referenceDrivers;\n+\n+    private Connection connection;\n+    private Statement statement;\n+\n+    @BeforeClass\n+    public void setupServer()\n+    {\n+        assertNotEquals(OTHER_TIMEZONE, TimeZone.getDefault().getID(), \"We need a timezone different from the default JVM one\");\n+        Logging.initialize();\n+        server = TestingPrestoServer.create();\n+        referenceDrivers = ImmutableList.of(new PostgresqlReferenceDriver()/*, new OracleReferenceDriver()*/);\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDownServer()\n+    {\n+        closeQuietly(server);\n+        referenceDrivers.forEach(ReferenceDriver::close);\n+    }\n+\n+    @SuppressWarnings(\"JDBCResourceOpenedButNotSafelyClosed\")\n+    @BeforeMethod\n+    public void setup()\n+            throws Exception\n+    {\n+        connection = DriverManager.getConnection(\"jdbc:presto://\" + server.getAddress(), \"test\", null);\n+        statement = connection.createStatement();\n+        referenceDrivers.forEach(ReferenceDriver::setup);\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void teardown()\n+            throws IOException\n+    {\n+        closeQuietly(statement);\n+        closeQuietly(connection);\n+        try (Closer closer = Closer.create()) {\n+            for (ReferenceDriver driver : referenceDrivers) {\n+                closer.register(driver::teardown);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] timeZoneIds()\n+    {\n+        return new Object[][] {\n+                {\"UTC\"},\n+                {\"Europe/Warsaw\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testDate(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"DATE '2018-02-13'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getDate(column), reference.getDate(column));\n+            assertEquals(rs.getDate(column), Date.valueOf(LocalDate.of(2018, 2, 13)));\n+        });\n+\n+        checkRepresentation(\"DATE '2018-02-13'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getDate(column, getCalendar()), reference.getDate(column, getCalendar()));\n+            assertEquals(rs.getDate(column, getCalendar()), new Date(LocalDate.of(2018, 2, 13).atStartOfDay(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTimestamp(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"TIMESTAMP '2018-02-13 13:14:15.123'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTimestamp(column), reference.getTimestamp(column));\n+            assertEquals(\n+                    rs.getTimestamp(column),\n+                    Timestamp.valueOf(LocalDateTime.of(2018, 2, 13, 13, 14, 15, 123_000_000)));\n+        });\n+\n+        checkRepresentation(\"TIMESTAMP '2018-02-13 13:14:15.123'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTimestamp(column, getCalendar()), reference.getTimestamp(column, getCalendar()));\n+            assertEquals(\n+                    rs.getTimestamp(column, getCalendar()),\n+                    new Timestamp(LocalDateTime.of(2018, 2, 13, 13, 14, 15, 123_000_000).atZone(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTime(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"TIME '09:39:05'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTime(column), reference.getTime(column));\n+            assertEquals(rs.getTime(column), Time.valueOf(LocalTime.of(9, 39, 5)));\n+        });\n+\n+        checkRepresentation(\"TIME '09:39:05'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTime(column, getCalendar()), reference.getTime(column, getCalendar()));\n+            assertEquals(rs.getTime(column, getCalendar()), new Time(LocalDate.of(1970, 1, 1).atTime(LocalTime.of(9, 39, 5)).atZone(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testDateRoundTrip(String sessionTimezoneId)\n+            throws SQLException\n+    {\n+        LocalDate date = LocalDate.of(2001, 5, 6);\n+        Date sqlDate = Date.valueOf(date);\n+        java.util.Date javaDate = new java.util.Date(sqlDate.getTime());\n+        LocalDateTime dateTime = LocalDateTime.of(date, LocalTime.of(12, 34, 56));\n+        Timestamp sqlTimestamp = Timestamp.valueOf(dateTime);\n+\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setDate(i, sqlDate));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, javaDate, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, date, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, dateTime, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, \"2001-05-06\", Types.DATE));\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTimestampRoundTrip(String sessionTimezoneId)\n+            throws SQLException\n+    {\n+        LocalDateTime dateTime = LocalDateTime.of(2001, 5, 6, 12, 34, 56);\n+        Date sqlDate = Date.valueOf(dateTime.toLocalDate());\n+        Time sqlTime = Time.valueOf(dateTime.toLocalTime());\n+        Timestamp sqlTimestamp = Timestamp.valueOf(dateTime);\n+        Timestamp sameInstantInWarsawZone = Timestamp.valueOf(dateTime.atZone(ZoneId.systemDefault()).withZoneSameInstant(ZoneId.of(\"Europe/Warsaw\")).toLocalDateTime());\n+        java.util.Date javaDate = java.util.Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant());\n+\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, null));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, Calendar.getInstance()));\n+        assertParameter(sameInstantInWarsawZone, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, Calendar.getInstance(TimeZone.getTimeZone(\"Europe/Warsaw\"))));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp));\n+        assertParameter(new Timestamp(sqlDate.getTime()), sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate, Types.TIMESTAMP));\n+        assertParameter(new Timestamp(sqlTime.getTime()), sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTime, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, javaDate, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, dateTime, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, \"2001-05-06 12:34:56\", Types.TIMESTAMP));\n+    }\n+\n+    private void assertParameter(Object expectedValue, String sessionTimezoneId, Binder binder)\n+            throws SQLException\n+    {\n+        connection.unwrap(PrestoConnection.class).setTimeZoneId(sessionTimezoneId);\n+        try (PreparedStatement statement = connection.prepareStatement(\"SELECT ?\")) {\n+            binder.bind(statement, 1);\n+\n+            try (ResultSet rs = statement.executeQuery()) {\n+                assertTrue(rs.next());\n+                assertEquals(expectedValue, rs.getObject(1));\n+                assertFalse(rs.next());\n+            }\n+        }\n+    }\n+\n+    private void checkRepresentation(String expression, String sessionTimezoneId, ResultAssertion assertion)\n+            throws Exception\n+    {\n+        for (ReferenceDriver driver : referenceDrivers) {\n+            // log the name of the driver if we're going to use more than one\n+            checkRepresentation(expression, sessionTimezoneId, driver, assertion);\n+        }\n+    }\n+\n+    private void checkRepresentation(String expression, String sessionTimezoneId, ReferenceDriver reference, ResultAssertion assertion)\n+            throws Exception\n+    {\n+        try (ResultSet rs = prestoQuery(expression, sessionTimezoneId); ResultSet referenceResultSet = reference.query(expression, sessionTimezoneId)) {\n+            assertTrue(rs.next());\n+            assertTrue(referenceResultSet.next());\n+            assertion.accept(rs, referenceResultSet, 1);\n+            assertFalse(rs.next());\n+            assertFalse(referenceResultSet.next());\n+        }\n+    }\n+\n+    private ResultSet prestoQuery(String expression, String timezoneId)\n+            throws Exception\n+    {\n+        connection.unwrap(PrestoConnection.class).setTimeZoneId(timezoneId);\n+        return statement.executeQuery(\"SELECT \" + expression);\n+    }\n+\n+    private Calendar getCalendar()\n+    {\n+        return Calendar.getInstance(TimeZone.getTimeZone(OTHER_TIMEZONE));\n+    }\n+\n+    private ZoneId getZoneId()\n+    {\n+        return ZoneId.of(getCalendar().getTimeZone().getID());\n+    }\n+\n+    private interface ReferenceDriver\n+    {\n+        ResultSet query(String expression, String timezoneId) throws Exception;\n+\n+        void setup();\n+\n+        void teardown();\n+\n+        void close();\n+    }\n+\n+    private static class OracleReferenceDriver\n+            implements ReferenceDriver\n+    {\n+        private OracleContainer oracleServer;\n+        private Connection connection;\n+        private Statement statement;\n+\n+        OracleReferenceDriver()\n+        {\n+            oracleServer = new OracleContainer(\"wnameless/oracle-xe-11g-r2\");\n+            oracleServer.start();\n+        }\n+\n+        @Override\n+        public ResultSet query(String expression, String timezoneId)\n+                throws Exception\n+        {\n+            statement.execute(format(\"ALTER SESSION SET TIME_ZONE='%s'\", timezoneId));\n+            return statement.executeQuery(format(\"SELECT %s FROM dual\", expression));\n+        }\n+\n+        @Override\n+        public void setup()\n+        {\n+            try {\n+                connection = DriverManager.getConnection(oracleServer.getJdbcUrl(), oracleServer.getUsername(), oracleServer.getPassword());\n+                statement = connection.createStatement();\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public void teardown()\n+        {\n+            closeQuietly(statement);\n+            closeQuietly(connection);\n+        }\n+\n+        @Override\n+        public void close()\n+        {\n+            oracleServer.stop();\n+        }\n+    }\n+\n+    private static class PostgresqlReferenceDriver\n+            implements ReferenceDriver\n+    {\n+        private PostgreSQLContainer pgServer;\n+        private Connection connection;\n+        private Statement statement;\n+\n+        PostgresqlReferenceDriver()\n+        {\n+            pgServer = new PostgreSQLContainer(\"postgres:10.3\")\n+                    .withDatabaseName(\"tpch\")\n+                    .withUsername(\"test\")\n+                    .withPassword(\"test\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1NjMxNw=="}, "originalCommit": null, "originalPosition": 334}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjY5MjQ3OnYy", "diffSide": "RIGHT", "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoyMzo0MFrOGzN08Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoyMzo0MFrOGzN08Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1NzEwNQ==", "bodyText": "https://prestosql.slack.com/archives/CP1MUNEUX/p1586372796137000\n& airlift/airlift#844\n& #4482", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r456357105", "createdAt": "2020-07-17T10:23:40Z", "author": {"login": "findepi"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.jdbc;\n+\n+import com.google.common.io.Closer;\n+import io.airlift.log.Logging;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testcontainers.containers.OracleContainer;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import static io.prestosql.jdbc.TestPrestoDriver.closeQuietly;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+/**\n+ * Checks that JDBC dates and timestamps are interpreted in the client JVM timezone and should not\n+ * be affected by the session timezone.  We also compare the behavior to a reference JDBC driver.\n+ */\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetTimezone\n+{\n+    private static final String OTHER_TIMEZONE = \"Asia/Kathmandu\";\n+\n+    private TestingPrestoServer server;\n+    private List<ReferenceDriver> referenceDrivers;\n+\n+    private Connection connection;\n+    private Statement statement;\n+\n+    @BeforeClass\n+    public void setupServer()\n+    {\n+        assertNotEquals(OTHER_TIMEZONE, TimeZone.getDefault().getID(), \"We need a timezone different from the default JVM one\");\n+        Logging.initialize();\n+        server = TestingPrestoServer.create();\n+        referenceDrivers = ImmutableList.of(new PostgresqlReferenceDriver()/*, new OracleReferenceDriver()*/);\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDownServer()\n+    {\n+        closeQuietly(server);\n+        referenceDrivers.forEach(ReferenceDriver::close);\n+    }\n+\n+    @SuppressWarnings(\"JDBCResourceOpenedButNotSafelyClosed\")\n+    @BeforeMethod\n+    public void setup()\n+            throws Exception\n+    {\n+        connection = DriverManager.getConnection(\"jdbc:presto://\" + server.getAddress(), \"test\", null);\n+        statement = connection.createStatement();\n+        referenceDrivers.forEach(ReferenceDriver::setup);\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void teardown()\n+            throws IOException\n+    {\n+        closeQuietly(statement);\n+        closeQuietly(connection);\n+        try (Closer closer = Closer.create()) {\n+            for (ReferenceDriver driver : referenceDrivers) {\n+                closer.register(driver::teardown);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] timeZoneIds()\n+    {\n+        return new Object[][] {\n+                {\"UTC\"},\n+                {\"Europe/Warsaw\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testDate(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"DATE '2018-02-13'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getDate(column), reference.getDate(column));\n+            assertEquals(rs.getDate(column), Date.valueOf(LocalDate.of(2018, 2, 13)));\n+        });\n+\n+        checkRepresentation(\"DATE '2018-02-13'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getDate(column, getCalendar()), reference.getDate(column, getCalendar()));\n+            assertEquals(rs.getDate(column, getCalendar()), new Date(LocalDate.of(2018, 2, 13).atStartOfDay(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTimestamp(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"TIMESTAMP '2018-02-13 13:14:15.123'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTimestamp(column), reference.getTimestamp(column));\n+            assertEquals(\n+                    rs.getTimestamp(column),\n+                    Timestamp.valueOf(LocalDateTime.of(2018, 2, 13, 13, 14, 15, 123_000_000)));\n+        });\n+\n+        checkRepresentation(\"TIMESTAMP '2018-02-13 13:14:15.123'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTimestamp(column, getCalendar()), reference.getTimestamp(column, getCalendar()));\n+            assertEquals(\n+                    rs.getTimestamp(column, getCalendar()),\n+                    new Timestamp(LocalDateTime.of(2018, 2, 13, 13, 14, 15, 123_000_000).atZone(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTime(String sessionTimezoneId)\n+            throws Exception\n+    {\n+        checkRepresentation(\"TIME '09:39:05'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTime(column), reference.getTime(column));\n+            assertEquals(rs.getTime(column), Time.valueOf(LocalTime.of(9, 39, 5)));\n+        });\n+\n+        checkRepresentation(\"TIME '09:39:05'\", sessionTimezoneId, (rs, reference, column) -> {\n+            assertEquals(rs.getTime(column, getCalendar()), reference.getTime(column, getCalendar()));\n+            assertEquals(rs.getTime(column, getCalendar()), new Time(LocalDate.of(1970, 1, 1).atTime(LocalTime.of(9, 39, 5)).atZone(getZoneId()).toInstant().toEpochMilli()));\n+        });\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testDateRoundTrip(String sessionTimezoneId)\n+            throws SQLException\n+    {\n+        LocalDate date = LocalDate.of(2001, 5, 6);\n+        Date sqlDate = Date.valueOf(date);\n+        java.util.Date javaDate = new java.util.Date(sqlDate.getTime());\n+        LocalDateTime dateTime = LocalDateTime.of(date, LocalTime.of(12, 34, 56));\n+        Timestamp sqlTimestamp = Timestamp.valueOf(dateTime);\n+\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setDate(i, sqlDate));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, javaDate, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, date, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, dateTime, Types.DATE));\n+        assertParameter(sqlDate, sessionTimezoneId, (ps, i) -> ps.setObject(i, \"2001-05-06\", Types.DATE));\n+    }\n+\n+    @Test(dataProvider = \"timeZoneIds\")\n+    public void testTimestampRoundTrip(String sessionTimezoneId)\n+            throws SQLException\n+    {\n+        LocalDateTime dateTime = LocalDateTime.of(2001, 5, 6, 12, 34, 56);\n+        Date sqlDate = Date.valueOf(dateTime.toLocalDate());\n+        Time sqlTime = Time.valueOf(dateTime.toLocalTime());\n+        Timestamp sqlTimestamp = Timestamp.valueOf(dateTime);\n+        Timestamp sameInstantInWarsawZone = Timestamp.valueOf(dateTime.atZone(ZoneId.systemDefault()).withZoneSameInstant(ZoneId.of(\"Europe/Warsaw\")).toLocalDateTime());\n+        java.util.Date javaDate = java.util.Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant());\n+\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, null));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, Calendar.getInstance()));\n+        assertParameter(sameInstantInWarsawZone, sessionTimezoneId, (ps, i) -> ps.setTimestamp(i, sqlTimestamp, Calendar.getInstance(TimeZone.getTimeZone(\"Europe/Warsaw\"))));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp));\n+        assertParameter(new Timestamp(sqlDate.getTime()), sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlDate, Types.TIMESTAMP));\n+        assertParameter(new Timestamp(sqlTime.getTime()), sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTime, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, sqlTimestamp, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, javaDate, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, dateTime, Types.TIMESTAMP));\n+        assertParameter(sqlTimestamp, sessionTimezoneId, (ps, i) -> ps.setObject(i, \"2001-05-06 12:34:56\", Types.TIMESTAMP));\n+    }\n+\n+    private void assertParameter(Object expectedValue, String sessionTimezoneId, Binder binder)\n+            throws SQLException\n+    {\n+        connection.unwrap(PrestoConnection.class).setTimeZoneId(sessionTimezoneId);\n+        try (PreparedStatement statement = connection.prepareStatement(\"SELECT ?\")) {\n+            binder.bind(statement, 1);\n+\n+            try (ResultSet rs = statement.executeQuery()) {\n+                assertTrue(rs.next());\n+                assertEquals(expectedValue, rs.getObject(1));\n+                assertFalse(rs.next());\n+            }\n+        }\n+    }\n+\n+    private void checkRepresentation(String expression, String sessionTimezoneId, ResultAssertion assertion)\n+            throws Exception\n+    {\n+        for (ReferenceDriver driver : referenceDrivers) {\n+            // log the name of the driver if we're going to use more than one\n+            checkRepresentation(expression, sessionTimezoneId, driver, assertion);\n+        }\n+    }\n+\n+    private void checkRepresentation(String expression, String sessionTimezoneId, ReferenceDriver reference, ResultAssertion assertion)\n+            throws Exception\n+    {\n+        try (ResultSet rs = prestoQuery(expression, sessionTimezoneId); ResultSet referenceResultSet = reference.query(expression, sessionTimezoneId)) {\n+            assertTrue(rs.next());\n+            assertTrue(referenceResultSet.next());\n+            assertion.accept(rs, referenceResultSet, 1);\n+            assertFalse(rs.next());\n+            assertFalse(referenceResultSet.next());\n+        }\n+    }\n+\n+    private ResultSet prestoQuery(String expression, String timezoneId)\n+            throws Exception\n+    {\n+        connection.unwrap(PrestoConnection.class).setTimeZoneId(timezoneId);\n+        return statement.executeQuery(\"SELECT \" + expression);\n+    }\n+\n+    private Calendar getCalendar()\n+    {\n+        return Calendar.getInstance(TimeZone.getTimeZone(OTHER_TIMEZONE));\n+    }\n+\n+    private ZoneId getZoneId()\n+    {\n+        return ZoneId.of(getCalendar().getTimeZone().getID());\n+    }\n+\n+    private interface ReferenceDriver\n+    {\n+        ResultSet query(String expression, String timezoneId) throws Exception;\n+\n+        void setup();\n+\n+        void teardown();\n+\n+        void close();\n+    }\n+\n+    private static class OracleReferenceDriver\n+            implements ReferenceDriver\n+    {\n+        private OracleContainer oracleServer;\n+        private Connection connection;\n+        private Statement statement;\n+\n+        OracleReferenceDriver()\n+        {\n+            oracleServer = new OracleContainer(\"wnameless/oracle-xe-11g-r2\");\n+            oracleServer.start();\n+        }\n+\n+        @Override\n+        public ResultSet query(String expression, String timezoneId)\n+                throws Exception\n+        {\n+            statement.execute(format(\"ALTER SESSION SET TIME_ZONE='%s'\", timezoneId));\n+            return statement.executeQuery(format(\"SELECT %s FROM dual\", expression));\n+        }\n+\n+        @Override\n+        public void setup()\n+        {\n+            try {\n+                connection = DriverManager.getConnection(oracleServer.getJdbcUrl(), oracleServer.getUsername(), oracleServer.getPassword());\n+                statement = connection.createStatement();\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public void teardown()\n+        {\n+            closeQuietly(statement);\n+            closeQuietly(connection);\n+        }\n+\n+        @Override\n+        public void close()\n+        {\n+            oracleServer.stop();\n+        }\n+    }\n+\n+    private static class PostgresqlReferenceDriver\n+            implements ReferenceDriver\n+    {\n+        private PostgreSQLContainer pgServer;\n+        private Connection connection;\n+        private Statement statement;\n+\n+        PostgresqlReferenceDriver()\n+        {\n+            pgServer = new PostgreSQLContainer(\"postgres:10.3\")\n+                    .withDatabaseName(\"tpch\")\n+                    .withUsername(\"test\")\n+                    .withPassword(\"test\");\n+            pgServer.start();\n+        }\n+\n+        @Override\n+        public ResultSet query(String expression, String timezoneId)\n+                throws Exception\n+        {\n+            statement.execute(format(\"SET SESSION TIME ZONE '%s'\", timezoneId));\n+            return statement.executeQuery(format(\"SELECT %s\", expression));\n+        }\n+\n+        @Override\n+        public void setup()\n+        {\n+            try {\n+                connection = DriverManager.getConnection(pgServer.getJdbcUrl(), \"test\", \"test\");\n+                statement = connection.createStatement();\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public void teardown()\n+        {\n+            closeQuietly(statement);\n+            closeQuietly(connection);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 362}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MjcyMjE3OnYy", "diffSide": "RIGHT", "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwODo1ODo1MlrOG0BBLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwODo1ODo1MlrOG0BBLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5NTgyMQ==", "bodyText": "Document why you included these zones.", "url": "https://github.com/trinodb/trino/pull/4376#discussion_r457195821", "createdAt": "2020-07-20T08:58:52Z", "author": {"login": "findepi"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestJdbcResultSetTimezone.java", "diffHunk": "@@ -0,0 +1,431 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.jdbc;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.io.Closer;\n+import io.airlift.log.Logger;\n+import io.airlift.log.Logging;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testcontainers.containers.OracleContainer;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.Closeable;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.DriverManager;\n+import java.sql.JDBCType;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TimeZone;\n+\n+import static java.lang.String.format;\n+import static java.sql.JDBCType.DATE;\n+import static java.sql.JDBCType.TIME;\n+import static java.sql.JDBCType.TIMESTAMP;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+/**\n+ * Checks that JDBC dates and timestamps are interpreted in the client JVM timezone and should not\n+ * be affected by the session timezone.  We also compare the behavior to reference JDBC drivers.\n+ */\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetTimezone\n+{\n+    private static final String OTHER_TIMEZONE = \"Asia/Kathmandu\";\n+\n+    private Logger log;\n+    private TestingPrestoServer server;\n+    private List<ReferenceDriver> referenceDrivers;\n+\n+    private Connection connection;\n+    private Statement statement;\n+\n+    @BeforeClass\n+    public void setupServer()\n+    {\n+        assertNotEquals(OTHER_TIMEZONE, TimeZone.getDefault().getID(), \"We need a timezone different from the default JVM one\");\n+        Logging.initialize();\n+        log = Logger.get(TestJdbcResultSetTimezone.class);\n+        server = TestingPrestoServer.create();\n+        referenceDrivers = ImmutableList.of(new PostgresqlReferenceDriver(), new OracleReferenceDriver());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDownServer()\n+            throws Exception\n+    {\n+        try (Closer closer = Closer.create()) {\n+            referenceDrivers.forEach(closer::register);\n+            closer.register(server);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"JDBCResourceOpenedButNotSafelyClosed\")\n+    @BeforeMethod\n+    public void setUp()\n+            throws Exception\n+    {\n+        connection = DriverManager.getConnection(\"jdbc:presto://\" + server.getAddress(), \"test\", null);\n+        statement = connection.createStatement();\n+        referenceDrivers.forEach(ReferenceDriver::setUp);\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void tearDown()\n+            throws Exception\n+    {\n+        statement.close();\n+        connection.close();\n+        for (ReferenceDriver driver : referenceDrivers) {\n+            try {\n+                driver.tearDown();\n+            }\n+            catch (Exception e) {\n+                log.warn(e, \"Failed to close reference JDBC driver %s; continuing\", driver);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] timeZoneIds()\n+    {\n+        return new Object[][] {\n+                {\"UTC\"},\n+                {\"Europe/Warsaw\"},\n+                {\"America/Denver\"},\n+                {ZoneId.systemDefault().getId()}", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 130}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3832, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}