{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzMTE1MDI4", "number": 5756, "title": "Push DistinctLimit into TableScan", "bodyText": "Fixes #5522", "createdAt": "2020-10-30T16:14:19Z", "url": "https://github.com/trinodb/trino/pull/5756", "merged": true, "mergeCommit": {"oid": "862fcf6bc924ca53d38b2a6f1bd7415bae8d2dcd"}, "closed": true, "closedAt": "2020-11-04T21:45:31Z", "author": {"login": "findepi"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdYiKIDgFqTUyMTUxMzA5Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZPz_FABqjM5NTgyNDgxNzM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxNTEzMDky", "url": "https://github.com/trinodb/trino/pull/5756#pullrequestreview-521513092", "createdAt": "2020-11-02T10:39:07Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMDozOTowN1rOHr-9dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMDozOTowN1rOHr-9dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4MjM1Nw==", "bodyText": "Maybe PushDistinctLimitAsAggregationIntoTableScan", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r515882357", "createdAt": "2020-11-02T10:39:07Z", "author": {"login": "losipiuk"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushDistinctLimitIntoTableScan.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.DistinctLimitNode;\n+import io.prestosql.sql.planner.plan.LimitNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.SystemSessionProperties.isAllowPushdownIntoConnectors;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.PushAggregationIntoTableScan.pushAggregationIntoTableScan;\n+import static io.prestosql.sql.planner.plan.Patterns.distinctLimit;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushDistinctLimitIntoTableScan", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxNTgyMDE1", "url": "https://github.com/trinodb/trino/pull/5756#pullrequestreview-521582015", "createdAt": "2020-11-02T12:25:36Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMjoyNTozNlrOHsCQlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMjoyOTo1MVrOHsCX7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzNjQwNA==", "bodyText": "rnn?", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r515936404", "createdAt": "2020-11-02T12:25:36Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushDistinctLimitIntoTableScan.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.DistinctLimitNode;\n+import io.prestosql.sql.planner.plan.LimitNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.SystemSessionProperties.isAllowPushdownIntoConnectors;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.PushAggregationIntoTableScan.pushAggregationIntoTableScan;\n+import static io.prestosql.sql.planner.plan.Patterns.distinctLimit;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushDistinctLimitIntoTableScan\n+        implements Rule<DistinctLimitNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<DistinctLimitNode> PATTERN =\n+            distinctLimit()\n+                    .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushDistinctLimitIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzODE1MA==", "bodyText": "I see:\n        assertThat(query(\"SELECT DISTINCT regionkey FROM nation LIMIT 5\")).isFullyPushedDown();\n\nThat means that LimitNode is pushed down in separate rule application. It is not obvious, please add a comment.", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r515938150", "createdAt": "2020-11-02T12:29:32Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushDistinctLimitIntoTableScan.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.DistinctLimitNode;\n+import io.prestosql.sql.planner.plan.LimitNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.SystemSessionProperties.isAllowPushdownIntoConnectors;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.PushAggregationIntoTableScan.pushAggregationIntoTableScan;\n+import static io.prestosql.sql.planner.plan.Patterns.distinctLimit;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushDistinctLimitIntoTableScan\n+        implements Rule<DistinctLimitNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<DistinctLimitNode> PATTERN =\n+            distinctLimit()\n+                    .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushDistinctLimitIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<DistinctLimitNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isAllowPushdownIntoConnectors(session);\n+    }\n+\n+    @Override\n+    public Result apply(DistinctLimitNode node, Captures captures, Context context)\n+    {\n+        Optional<PlanNode> result = pushAggregationIntoTableScan(\n+                metadata,\n+                context,\n+                captures.get(TABLE_SCAN),\n+                ImmutableMap.of(),\n+                node.getDistinctSymbols());\n+\n+        if (result.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        return Result.ofPlanNode(\n+                new LimitNode(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzODI4NQ==", "bodyText": "Rule unit tests?", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r515938285", "createdAt": "2020-11-02T12:29:51Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushDistinctLimitIntoTableScan.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.DistinctLimitNode;\n+import io.prestosql.sql.planner.plan.LimitNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.SystemSessionProperties.isAllowPushdownIntoConnectors;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.PushAggregationIntoTableScan.pushAggregationIntoTableScan;\n+import static io.prestosql.sql.planner.plan.Patterns.distinctLimit;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushDistinctLimitIntoTableScan", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "937c4955b5de95f92dc0d4cbce17b3675bd80b56", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/937c4955b5de95f92dc0d4cbce17b3675bd80b56", "committedDate": "2020-11-04T12:17:30Z", "message": "Replace @Test(expectedExceptions) with assertThatThrownBy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30229d0f197bc93e3df80abc8c5aef574cf3981c", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/30229d0f197bc93e3df80abc8c5aef574cf3981c", "committedDate": "2020-11-04T12:17:30Z", "message": "Move helper rule implementation to the test method\n\nThis way the test method is self-contained."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecd1a9805e97f2310897c0f415fdf91edc208861", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/ecd1a9805e97f2310897c0f415fdf91edc208861", "committedDate": "2020-11-04T12:17:30Z", "message": "Add more RuleTester tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50e3fcc51c76064fe5c3f94167483609535ebb2c", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/50e3fcc51c76064fe5c3f94167483609535ebb2c", "committedDate": "2020-11-04T12:17:30Z", "message": "Fix stats collection for plan printing in RuleAssert\n\nPreviously the stats collection would be bound to the session outside of\ntransaction, leading to \"Not in a transaction\" exceptions being logged.\n\n(The stats collection failures are suppressed by default.)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c776eb8da075e9c330880134ae9664da3c26fdd", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/5c776eb8da075e9c330880134ae9664da3c26fdd", "committedDate": "2020-11-04T12:17:30Z", "message": "Improve code style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "583f01fe112706bba13c2e576a19067ab8b28a60", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/583f01fe112706bba13c2e576a19067ab8b28a60", "committedDate": "2020-11-04T12:17:30Z", "message": "Extract method with PushAggregationIntoTableScan logic"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzE2MjM3", "url": "https://github.com/trinodb/trino/pull/5756#pullrequestreview-523316237", "createdAt": "2020-11-04T12:30:52Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMjozMDo1MlrOHtWErw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMjozOTowMlrOHtWVew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMwOTYxNQ==", "bodyText": "This is not much readable, please extract local variable, just before aggregationPushdownResult", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517309615", "createdAt": "2020-11-04T12:30:52Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -139,14 +135,18 @@ public Result apply(AggregationNode node, Captures captures, Context context)\n                 .collect(toImmutableList());\n \n         List<ColumnHandle> groupByColumns = groupingKeys.stream()\n-                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .map(tableScan.getAssignments()::get)\n                 .collect(toImmutableList());\n \n         Optional<AggregationApplicationResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n                 context.getSession(),\n                 tableScan.getTable(),\n                 aggregateFunctions,\n-                assignments,\n+                aggregateFunctions.isEmpty()\n+                        ? Map.of()\n+                        : tableScan.getAssignments()\n+                        .entrySet().stream()\n+                        .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxMDU3NQ==", "bodyText": "Abstain from passing assignments when no aggregate functions\n\nWhat is the benefit of that?\nI see a cost, of new corner case.\nMaybe you should pass Optional then? To make it explicit that it may or may not be given.", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517310575", "createdAt": "2020-11-04T12:32:42Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -121,10 +121,6 @@ public Result apply(AggregationNode node, Captures captures, Context context)\n             Map<Symbol, AggregationNode.Aggregation> aggregations,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxMDg2MQ==", "bodyText": "Thanks", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517310861", "createdAt": "2020-11-04T12:33:15Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushDistinctLimitIntoTableScan.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.DistinctLimitNode;\n+import io.prestosql.sql.planner.plan.LimitNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.SystemSessionProperties.isAllowPushdownIntoConnectors;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.PushAggregationIntoTableScan.pushAggregationIntoTableScan;\n+import static io.prestosql.sql.planner.plan.Patterns.distinctLimit;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushDistinctLimitIntoTableScan\n+        implements Rule<DistinctLimitNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<DistinctLimitNode> PATTERN =\n+            distinctLimit()\n+                    .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushDistinctLimitIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<DistinctLimitNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isAllowPushdownIntoConnectors(session);\n+    }\n+\n+    @Override\n+    public Result apply(DistinctLimitNode node, Captures captures, Context context)\n+    {\n+        Optional<PlanNode> result = pushAggregationIntoTableScan(\n+                metadata,\n+                context,\n+                captures.get(TABLE_SCAN),\n+                ImmutableMap.of(),\n+                node.getDistinctSymbols());\n+\n+        if (result.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        return Result.ofPlanNode(\n+                new LimitNode(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzODE1MA=="}, "originalCommit": null, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxMTAyOQ==", "bodyText": "\u2764\ufe0f", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517311029", "createdAt": "2020-11-04T12:33:33Z", "author": {"login": "kokosing"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestPushDistinctLimitIntoTableScan.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorFactory.ApplyAggregation;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.connector.MockConnectorTransactionHandle;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationApplicationResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.rule.test.BaseRuleTest;\n+import io.prestosql.testing.LocalQueryRunner;\n+import io.prestosql.testing.TestingSession;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.limit;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@Test(singleThreaded = true) // shared mutable state\n+public class TestPushDistinctLimitIntoTableScan", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxMzM3MQ==", "bodyText": "It is single threaded, no need to have atomic here", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517313371", "createdAt": "2020-11-04T12:37:54Z", "author": {"login": "kokosing"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestPushDistinctLimitIntoTableScan.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorFactory.ApplyAggregation;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.connector.MockConnectorTransactionHandle;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationApplicationResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.rule.test.BaseRuleTest;\n+import io.prestosql.testing.LocalQueryRunner;\n+import io.prestosql.testing.TestingSession;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.limit;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@Test(singleThreaded = true) // shared mutable state\n+public class TestPushDistinctLimitIntoTableScan\n+        extends BaseRuleTest\n+{\n+    private static final CatalogName TEST_CATALOG = new CatalogName(\"test_push_dl_catalog\");\n+\n+    private PushDistinctLimitIntoTableScan rule;\n+\n+    private AtomicReference<ApplyAggregation> testApplyAggregation = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxMzkxNQ==", "bodyText": "require non null applyAggregation? To make sure it is always set in test.", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517313915", "createdAt": "2020-11-04T12:39:02Z", "author": {"login": "kokosing"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestPushDistinctLimitIntoTableScan.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorFactory.ApplyAggregation;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.connector.MockConnectorTransactionHandle;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationApplicationResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.rule.test.BaseRuleTest;\n+import io.prestosql.testing.LocalQueryRunner;\n+import io.prestosql.testing.TestingSession;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.limit;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@Test(singleThreaded = true) // shared mutable state\n+public class TestPushDistinctLimitIntoTableScan\n+        extends BaseRuleTest\n+{\n+    private static final CatalogName TEST_CATALOG = new CatalogName(\"test_push_dl_catalog\");\n+\n+    private PushDistinctLimitIntoTableScan rule;\n+\n+    private AtomicReference<ApplyAggregation> testApplyAggregation = new AtomicReference<>();\n+\n+    private TableHandle tableHandle;\n+\n+    @Override\n+    protected Optional<LocalQueryRunner> createLocalQueryRunner()\n+    {\n+        Session defaultSession = TestingSession.testSessionBuilder()\n+                .setCatalog(TEST_CATALOG.getCatalogName())\n+                .setSchema(\"tiny\")\n+                .build();\n+\n+        LocalQueryRunner queryRunner = LocalQueryRunner.create(defaultSession);\n+\n+        queryRunner.createCatalog(\n+                TEST_CATALOG.getCatalogName(),\n+                MockConnectorFactory.builder()\n+                        .withApplyAggregation(\n+                                (session, handle, aggregates, assignments, groupingSets) -> {\n+                                    ApplyAggregation applyAggregation = testApplyAggregation.get();\n+                                    if (applyAggregation != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 79}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNDYxMzUx", "url": "https://github.com/trinodb/trino/pull/5756#pullrequestreview-523461351", "createdAt": "2020-11-04T15:17:47Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNToxNzo0N1rOHtcyXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNToxNzo0N1rOHtcyXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxOTYxNQ==", "bodyText": "nit: doesNotFire is kinda misleading here. As rule is fired. Yet it returns empty() so it does nothing.", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517419615", "createdAt": "2020-11-04T15:17:47Z", "author": {"login": "losipiuk"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestPushDistinctLimitIntoTableScan.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorFactory.ApplyAggregation;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.connector.MockConnectorTransactionHandle;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationApplicationResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.rule.test.BaseRuleTest;\n+import io.prestosql.testing.LocalQueryRunner;\n+import io.prestosql.testing.TestingSession;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.limit;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@Test(singleThreaded = true) // shared mutable state\n+public class TestPushDistinctLimitIntoTableScan\n+        extends BaseRuleTest\n+{\n+    private static final CatalogName TEST_CATALOG = new CatalogName(\"test_push_dl_catalog\");\n+\n+    private PushDistinctLimitIntoTableScan rule;\n+    private TableHandle tableHandle;\n+\n+    private ApplyAggregation testApplyAggregation;\n+\n+    @Override\n+    protected Optional<LocalQueryRunner> createLocalQueryRunner()\n+    {\n+        Session defaultSession = TestingSession.testSessionBuilder()\n+                .setCatalog(TEST_CATALOG.getCatalogName())\n+                .setSchema(\"tiny\")\n+                .build();\n+\n+        LocalQueryRunner queryRunner = LocalQueryRunner.create(defaultSession);\n+\n+        queryRunner.createCatalog(\n+                TEST_CATALOG.getCatalogName(),\n+                MockConnectorFactory.builder()\n+                        .withApplyAggregation(\n+                                (session, handle, aggregates, assignments, groupingSets) -> {\n+                                    if (testApplyAggregation != null) {\n+                                        return testApplyAggregation.apply(session, handle, aggregates, assignments, groupingSets);\n+                                    }\n+                                    return Optional.empty();\n+                                })\n+                        .build(),\n+                Map.of());\n+\n+        return Optional.of(queryRunner);\n+    }\n+\n+    @BeforeClass\n+    public void init()\n+    {\n+        rule = new PushDistinctLimitIntoTableScan(tester().getMetadata());\n+\n+        tableHandle = new TableHandle(\n+                TEST_CATALOG,\n+                new MockConnectorTableHandle(new SchemaTableName(\"mock_schema\", \"mock_nation\")),\n+                MockConnectorTransactionHandle.INSTANCE,\n+                Optional.empty());\n+    }\n+\n+    @BeforeMethod\n+    public void reset()\n+    {\n+        testApplyAggregation = null;\n+    }\n+\n+    @Test\n+    public void testDoesNotFireIfNoTableScan()\n+    {\n+        tester().assertThat(rule)\n+                .on(p -> p.values(p.symbol(\"a\", BIGINT)))\n+                .doesNotFire();\n+    }\n+\n+    @Test\n+    public void testNoEffect()\n+    {\n+        AtomicInteger applyCallCounter = new AtomicInteger();\n+        testApplyAggregation = (session, handle, aggregates, assignments, groupingSets) -> {\n+            applyCallCounter.incrementAndGet();\n+            return Optional.empty();\n+        };\n+\n+        tester().assertThat(rule)\n+                .on(p -> {\n+                    Symbol regionkey = p.symbol(\"regionkey\");\n+                    return p.distinctLimit(10, List.of(regionkey),\n+                            p.tableScan(\n+                                    tableHandle,\n+                                    ImmutableList.of(regionkey),\n+                                    ImmutableMap.of(regionkey, new MockConnectorColumnHandle(\"regionkey\", BIGINT))));\n+                })\n+                .doesNotFire();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNDY3NTY5", "url": "https://github.com/trinodb/trino/pull/5756#pullrequestreview-523467569", "createdAt": "2020-11-04T15:24:15Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d20cdc98caa9772ea400cc9bd6eacaadf96cc449", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/d20cdc98caa9772ea400cc9bd6eacaadf96cc449", "committedDate": "2020-11-04T15:50:33Z", "message": "Push DistinctLimit into TableScan"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "d20cdc98caa9772ea400cc9bd6eacaadf96cc449", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/d20cdc98caa9772ea400cc9bd6eacaadf96cc449", "committedDate": "2020-11-04T15:50:33Z", "message": "Push DistinctLimit into TableScan"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2712, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}