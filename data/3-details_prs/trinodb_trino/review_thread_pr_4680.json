{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyNDU3OTY1", "number": 4680, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoyNDoyNFrOEkq0cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMzoxNzowNlrOEszzSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODg1NzQ3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoyNDoyNFrOHTvu6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoyNDoyNFrOHTvu6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NzA1MQ==", "bodyText": "Change this comment to remove the hive reference, just describe the behavior.", "url": "https://github.com/trinodb/trino/pull/4680#discussion_r490467051", "createdAt": "2020-09-17T18:24:24Z", "author": {"login": "phd3"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.bytecode.BytecodeBlock;\n+import io.airlift.bytecode.ClassDefinition;\n+import io.airlift.bytecode.DynamicClassLoader;\n+import io.airlift.bytecode.MethodDefinition;\n+import io.airlift.bytecode.Parameter;\n+import io.airlift.bytecode.ParameterizedType;\n+import io.airlift.bytecode.Scope;\n+import io.airlift.bytecode.Variable;\n+import io.airlift.bytecode.expression.BytecodeExpression;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.prestosql.annotation.UsedByGeneratedCode;\n+import io.prestosql.metadata.FunctionArgumentDefinition;\n+import io.prestosql.metadata.FunctionBinding;\n+import io.prestosql.metadata.FunctionMetadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.SqlScalarFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.VarcharType;\n+import io.prestosql.type.UnknownType;\n+import io.prestosql.util.CompilerUtils;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.airlift.bytecode.Access.FINAL;\n+import static io.airlift.bytecode.Access.PRIVATE;\n+import static io.airlift.bytecode.Access.PUBLIC;\n+import static io.airlift.bytecode.Access.STATIC;\n+import static io.airlift.bytecode.Access.a;\n+import static io.airlift.bytecode.Parameter.arg;\n+import static io.airlift.bytecode.ParameterizedType.type;\n+import static io.airlift.bytecode.expression.BytecodeExpressions.invokeStatic;\n+import static io.airlift.bytecode.expression.BytecodeExpressions.newArray;\n+import static io.prestosql.metadata.FunctionKind.SCALAR;\n+import static io.prestosql.metadata.Signature.typeVariable;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BOXED_NULLABLE;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.type.TypeSignature.arrayType;\n+import static io.prestosql.spi.type.VarcharType.createUnboundedVarcharType;\n+import static io.prestosql.util.CompilerUtils.defineClass;\n+import static io.prestosql.util.Reflection.methodHandle;\n+import static java.lang.Math.addExact;\n+\n+/**\n+ * Presto version of Hive's concat_ws UDF.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODg2MzY1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/metadata/FunctionRegistry.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoyNTo1OFrOHTvymQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoyNTo1OFrOHTvymQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2Nzk5Mw==", "bodyText": "Add corresponding documentation", "url": "https://github.com/trinodb/trino/pull/4680#discussion_r490467993", "createdAt": "2020-09-17T18:25:58Z", "author": {"login": "phd3"}, "path": "presto-main/src/main/java/io/prestosql/metadata/FunctionRegistry.java", "diffHunk": "@@ -621,6 +623,8 @@ public FunctionRegistry(Supplier<BlockEncodingSerde> blockEncodingSerdeSupplier,\n                 .function(COUNT_COLUMN)\n                 .functions(ROW_HASH_CODE, ROW_TO_JSON, JSON_TO_ROW, JSON_STRING_TO_ROW, ROW_DISTINCT_FROM, ROW_EQUAL, ROW_GREATER_THAN, ROW_GREATER_THAN_OR_EQUAL, ROW_LESS_THAN, ROW_LESS_THAN_OR_EQUAL, ROW_NOT_EQUAL, ROW_TO_ROW_CAST, ROW_INDETERMINATE)\n                 .functions(VARCHAR_CONCAT, VARBINARY_CONCAT)\n+                .function(CONCAT_WS)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMTQxNTMzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQyMDozMzo1N1rOHYifTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQyMDozMzo1N1rOHYifTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5Mjk0Mg==", "bodyText": "Generating bytecode for this is overkill. This can probably be done with MethodHandle combinators.", "url": "https://github.com/trinodb/trino/pull/4680#discussion_r495492942", "createdAt": "2020-09-26T20:33:57Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.bytecode.BytecodeBlock;\n+import io.airlift.bytecode.ClassDefinition;\n+import io.airlift.bytecode.DynamicClassLoader;\n+import io.airlift.bytecode.MethodDefinition;\n+import io.airlift.bytecode.Parameter;\n+import io.airlift.bytecode.ParameterizedType;\n+import io.airlift.bytecode.Scope;\n+import io.airlift.bytecode.Variable;\n+import io.airlift.bytecode.expression.BytecodeExpression;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.prestosql.annotation.UsedByGeneratedCode;\n+import io.prestosql.metadata.FunctionArgumentDefinition;\n+import io.prestosql.metadata.FunctionBinding;\n+import io.prestosql.metadata.FunctionMetadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.SqlScalarFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.VarcharType;\n+import io.prestosql.type.UnknownType;\n+import io.prestosql.util.CompilerUtils;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.airlift.bytecode.Access.FINAL;\n+import static io.airlift.bytecode.Access.PRIVATE;\n+import static io.airlift.bytecode.Access.PUBLIC;\n+import static io.airlift.bytecode.Access.STATIC;\n+import static io.airlift.bytecode.Access.a;\n+import static io.airlift.bytecode.Parameter.arg;\n+import static io.airlift.bytecode.ParameterizedType.type;\n+import static io.airlift.bytecode.expression.BytecodeExpressions.invokeStatic;\n+import static io.airlift.bytecode.expression.BytecodeExpressions.newArray;\n+import static io.prestosql.metadata.FunctionKind.SCALAR;\n+import static io.prestosql.metadata.Signature.typeVariable;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BOXED_NULLABLE;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.type.TypeSignature.arrayType;\n+import static io.prestosql.spi.type.VarcharType.createUnboundedVarcharType;\n+import static io.prestosql.util.CompilerUtils.defineClass;\n+import static io.prestosql.util.Reflection.methodHandle;\n+import static java.lang.Math.addExact;\n+\n+/**\n+ * Concatenate all but the first argument with separators. The first parameter is used as a separator.\n+ * The function needs at least 2 params.\n+ *\n+ * Null behavior:\n+ * concat_ws(null, ...) returns null.\n+ * concat_ws(sep, arg1, arg2,..., argN) returns arg1 through argN concatenated with separator 'sep'.\n+ * Null arguments are ignored.\n+ *\n+ * concat_ws(sep, array[strings]) returns elements in the array concatenated with separators.\n+ */\n+public final class ConcatWsFunction\n+        extends SqlScalarFunction\n+{\n+    public static final ConcatWsFunction CONCAT_WS = new ConcatWsFunction();\n+    public static final ConcatArrayWs CONCAT_ARRAY_WS = new ConcatArrayWs();\n+\n+    private static final class ConcatArrayWs\n+            extends SqlScalarFunction\n+    {\n+        ConcatArrayWs()\n+        {\n+            super(new FunctionMetadata(\n+                    new Signature(\n+                            \"concat_ws\",\n+                            ImmutableList.of(typeVariable(\"T\")),\n+                            ImmutableList.of(),\n+                            VarcharType.createUnboundedVarcharType().getTypeSignature(),\n+                            ImmutableList.of(createUnboundedVarcharType().getTypeSignature(), arrayType(new TypeSignature(\"T\"))),\n+                            false),\n+                    true,\n+                    ImmutableList.of(new FunctionArgumentDefinition(false), new FunctionArgumentDefinition(false)),\n+                    false,\n+                    true,\n+                    \"Concatenates array elements using separator\",\n+                    SCALAR));\n+        }\n+\n+        @Override\n+        public ScalarFunctionImplementation specialize(FunctionBinding functionBinding)\n+        {\n+            if (functionBinding.getArity() != 2) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"There must be two arguments\");\n+            }\n+\n+            Type arrayValueType = functionBinding.getTypeVariable(\"T\");\n+            if (!(arrayValueType instanceof VarcharType) && !(arrayValueType instanceof UnknownType)) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Array values must be varchar types\");\n+            }\n+\n+            return new ScalarFunctionImplementation(\n+                    NULLABLE_RETURN,\n+                    ImmutableList.of(NEVER_NULL, NEVER_NULL),\n+                    methodHandle(ConcatWsFunction.class, \"concatWsArray\", Slice.class, Block.class),\n+                    Optional.empty());\n+        }\n+    }\n+\n+    public ConcatWsFunction()\n+    {\n+        super(new FunctionMetadata(\n+                new Signature(\n+                        \"concat_ws\",\n+                        ImmutableList.of(),\n+                        ImmutableList.of(),\n+                        VarcharType.createUnboundedVarcharType().getTypeSignature(),\n+                        ImmutableList.of(createUnboundedVarcharType().getTypeSignature(), createUnboundedVarcharType().getTypeSignature()),\n+                        true),\n+                true,\n+                ImmutableList.of(new FunctionArgumentDefinition(false), new FunctionArgumentDefinition(true)),\n+                false,\n+                true,\n+                \"Concatenates elements using separator\",\n+                SCALAR));\n+    }\n+\n+    @Override\n+    public ScalarFunctionImplementation specialize(FunctionBinding binding)\n+    {\n+        if (binding.getArity() < 2) {\n+            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"There must be two or more arguments\");\n+        }\n+\n+        Class<?> clazz = generateConcatWsVarArgs(binding.getArity());\n+        MethodHandle methodHandle = methodHandle(clazz, \"concatWs\", Collections.nCopies(binding.getArity(), Slice.class).toArray(new Class<?>[binding.getArity()]));\n+\n+        return new ScalarFunctionImplementation(\n+                NULLABLE_RETURN,\n+                ImmutableList.<InvocationConvention.InvocationArgumentConvention>builder()\n+                        .add(NEVER_NULL)\n+                        .addAll(Collections.nCopies(binding.getArity() - 1, BOXED_NULLABLE))\n+                        .build(),\n+                methodHandle,\n+                Optional.empty());\n+    }\n+\n+    private static Class<?> generateConcatWsVarArgs(int arity)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NDE1MDk4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjo0NzoxOVrOHgPjFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNzoxODozOFrOHgxg8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MTIyMQ==", "bodyText": "This can be a checkArgument. This method shouldn't be called with fewer than 2 arguments unless there's a bug in the engine or in the function declaration.", "url": "https://github.com/trinodb/trino/pull/4680#discussion_r503571221", "createdAt": "2020-10-12T22:47:19Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.prestosql.annotation.UsedByGeneratedCode;\n+import io.prestosql.metadata.FunctionArgumentDefinition;\n+import io.prestosql.metadata.FunctionBinding;\n+import io.prestosql.metadata.FunctionMetadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.SqlScalarFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.VarcharType;\n+import io.prestosql.type.UnknownType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Collections;\n+\n+import static io.prestosql.metadata.FunctionKind.SCALAR;\n+import static io.prestosql.metadata.Signature.typeVariable;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BOXED_NULLABLE;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.type.TypeSignature.arrayType;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.util.Reflection.methodHandle;\n+import static java.lang.Math.addExact;\n+\n+/**\n+ * Concatenate all but the first argument with separators. The first parameter is used as a separator.\n+ * The function needs at least 2 params.\n+ *\n+ * Null behavior:\n+ * concat_ws(null, ...) returns null.\n+ * concat_ws(sep, arg1, arg2,..., argN) returns arg1 through argN concatenated with separator 'sep'.\n+ * Null arguments are ignored.\n+ *\n+ * concat_ws(sep, array[strings]) returns elements in the array concatenated with separators.\n+ */\n+public final class ConcatWsFunction\n+        extends SqlScalarFunction\n+{\n+    public static final ConcatWsFunction CONCAT_WS = new ConcatWsFunction();\n+    public static final ConcatArrayWs CONCAT_ARRAY_WS = new ConcatArrayWs();\n+\n+    private static final class ConcatArrayWs\n+            extends SqlScalarFunction\n+    {\n+        ConcatArrayWs()\n+        {\n+            super(new FunctionMetadata(\n+                    new Signature(\n+                            \"concat_ws\",\n+                            ImmutableList.of(typeVariable(\"T\")),\n+                            ImmutableList.of(),\n+                            VARCHAR.getTypeSignature(),\n+                            ImmutableList.of(VARCHAR.getTypeSignature(), arrayType(new TypeSignature(\"T\"))),\n+                            false),\n+                    true,\n+                    ImmutableList.of(new FunctionArgumentDefinition(false), new FunctionArgumentDefinition(false)),\n+                    false,\n+                    true,\n+                    \"Concatenates array elements using a separator\",\n+                    SCALAR));\n+        }\n+\n+        @Override\n+        public ScalarFunctionImplementation specialize(FunctionBinding functionBinding)\n+        {\n+            if (functionBinding.getArity() != 2) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"There must be two arguments\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyNzcyOA==", "bodyText": "I see. I added this as a PrestoException because bindVariables seems to allow 0 trailing arguments in case of variable arity.\nhttps://github.com/prestosql/presto/blob/master/presto-main/src/main/java/io/prestosql/metadata/SignatureBinder.java#L372\nDo you know if function implementations assume that the trailing argument can be absent? or should we change the condition here to actualTypes.size() < formalTypeSignatures.size() ?", "url": "https://github.com/trinodb/trino/pull/4680#discussion_r504127728", "createdAt": "2020-10-13T17:18:38Z", "author": {"login": "phd3"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.prestosql.annotation.UsedByGeneratedCode;\n+import io.prestosql.metadata.FunctionArgumentDefinition;\n+import io.prestosql.metadata.FunctionBinding;\n+import io.prestosql.metadata.FunctionMetadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.SqlScalarFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.VarcharType;\n+import io.prestosql.type.UnknownType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Collections;\n+\n+import static io.prestosql.metadata.FunctionKind.SCALAR;\n+import static io.prestosql.metadata.Signature.typeVariable;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BOXED_NULLABLE;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.type.TypeSignature.arrayType;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.util.Reflection.methodHandle;\n+import static java.lang.Math.addExact;\n+\n+/**\n+ * Concatenate all but the first argument with separators. The first parameter is used as a separator.\n+ * The function needs at least 2 params.\n+ *\n+ * Null behavior:\n+ * concat_ws(null, ...) returns null.\n+ * concat_ws(sep, arg1, arg2,..., argN) returns arg1 through argN concatenated with separator 'sep'.\n+ * Null arguments are ignored.\n+ *\n+ * concat_ws(sep, array[strings]) returns elements in the array concatenated with separators.\n+ */\n+public final class ConcatWsFunction\n+        extends SqlScalarFunction\n+{\n+    public static final ConcatWsFunction CONCAT_WS = new ConcatWsFunction();\n+    public static final ConcatArrayWs CONCAT_ARRAY_WS = new ConcatArrayWs();\n+\n+    private static final class ConcatArrayWs\n+            extends SqlScalarFunction\n+    {\n+        ConcatArrayWs()\n+        {\n+            super(new FunctionMetadata(\n+                    new Signature(\n+                            \"concat_ws\",\n+                            ImmutableList.of(typeVariable(\"T\")),\n+                            ImmutableList.of(),\n+                            VARCHAR.getTypeSignature(),\n+                            ImmutableList.of(VARCHAR.getTypeSignature(), arrayType(new TypeSignature(\"T\"))),\n+                            false),\n+                    true,\n+                    ImmutableList.of(new FunctionArgumentDefinition(false), new FunctionArgumentDefinition(false)),\n+                    false,\n+                    true,\n+                    \"Concatenates array elements using a separator\",\n+                    SCALAR));\n+        }\n+\n+        @Override\n+        public ScalarFunctionImplementation specialize(FunctionBinding functionBinding)\n+        {\n+            if (functionBinding.getArity() != 2) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"There must be two arguments\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MTIyMQ=="}, "originalCommit": null, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NDE1NTQ3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjo0OToyM1rOHgPloQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QyMjo0MzoxNFrOHg8B2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MTg3Mw==", "bodyText": "Why is this function parameterized? Aren't all the arguments required to be VARCHAR/ARRAY(VARCHAR)?", "url": "https://github.com/trinodb/trino/pull/4680#discussion_r503571873", "createdAt": "2020-10-12T22:49:23Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.prestosql.annotation.UsedByGeneratedCode;\n+import io.prestosql.metadata.FunctionArgumentDefinition;\n+import io.prestosql.metadata.FunctionBinding;\n+import io.prestosql.metadata.FunctionMetadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.SqlScalarFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.VarcharType;\n+import io.prestosql.type.UnknownType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Collections;\n+\n+import static io.prestosql.metadata.FunctionKind.SCALAR;\n+import static io.prestosql.metadata.Signature.typeVariable;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BOXED_NULLABLE;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.type.TypeSignature.arrayType;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.util.Reflection.methodHandle;\n+import static java.lang.Math.addExact;\n+\n+/**\n+ * Concatenate all but the first argument with separators. The first parameter is used as a separator.\n+ * The function needs at least 2 params.\n+ *\n+ * Null behavior:\n+ * concat_ws(null, ...) returns null.\n+ * concat_ws(sep, arg1, arg2,..., argN) returns arg1 through argN concatenated with separator 'sep'.\n+ * Null arguments are ignored.\n+ *\n+ * concat_ws(sep, array[strings]) returns elements in the array concatenated with separators.\n+ */\n+public final class ConcatWsFunction\n+        extends SqlScalarFunction\n+{\n+    public static final ConcatWsFunction CONCAT_WS = new ConcatWsFunction();\n+    public static final ConcatArrayWs CONCAT_ARRAY_WS = new ConcatArrayWs();\n+\n+    private static final class ConcatArrayWs\n+            extends SqlScalarFunction\n+    {\n+        ConcatArrayWs()\n+        {\n+            super(new FunctionMetadata(\n+                    new Signature(\n+                            \"concat_ws\",\n+                            ImmutableList.of(typeVariable(\"T\")),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI5OTk5Mw==", "bodyText": "IIRC it was required for processing array[null]  input in the previous implementation. With the implementation suggested by you, this is gone.", "url": "https://github.com/trinodb/trino/pull/4680#discussion_r504299993", "createdAt": "2020-10-13T22:43:14Z", "author": {"login": "phd3"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.prestosql.annotation.UsedByGeneratedCode;\n+import io.prestosql.metadata.FunctionArgumentDefinition;\n+import io.prestosql.metadata.FunctionBinding;\n+import io.prestosql.metadata.FunctionMetadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.SqlScalarFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.VarcharType;\n+import io.prestosql.type.UnknownType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Collections;\n+\n+import static io.prestosql.metadata.FunctionKind.SCALAR;\n+import static io.prestosql.metadata.Signature.typeVariable;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BOXED_NULLABLE;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.type.TypeSignature.arrayType;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.util.Reflection.methodHandle;\n+import static java.lang.Math.addExact;\n+\n+/**\n+ * Concatenate all but the first argument with separators. The first parameter is used as a separator.\n+ * The function needs at least 2 params.\n+ *\n+ * Null behavior:\n+ * concat_ws(null, ...) returns null.\n+ * concat_ws(sep, arg1, arg2,..., argN) returns arg1 through argN concatenated with separator 'sep'.\n+ * Null arguments are ignored.\n+ *\n+ * concat_ws(sep, array[strings]) returns elements in the array concatenated with separators.\n+ */\n+public final class ConcatWsFunction\n+        extends SqlScalarFunction\n+{\n+    public static final ConcatWsFunction CONCAT_WS = new ConcatWsFunction();\n+    public static final ConcatArrayWs CONCAT_ARRAY_WS = new ConcatArrayWs();\n+\n+    private static final class ConcatArrayWs\n+            extends SqlScalarFunction\n+    {\n+        ConcatArrayWs()\n+        {\n+            super(new FunctionMetadata(\n+                    new Signature(\n+                            \"concat_ws\",\n+                            ImmutableList.of(typeVariable(\"T\")),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MTg3Mw=="}, "originalCommit": null, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NDE1OTEzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjo1MDozOFrOHgPnkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QyMjo0MTo1NlrOHg8APQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MjM2OA==", "bodyText": "This should be enforced statically by using the appropriate function signature declaration (see comment above).\nAnd since this shouldn't be a parametric function, there's no need for specialize. It can be implemented as any other simple function.", "url": "https://github.com/trinodb/trino/pull/4680#discussion_r503572368", "createdAt": "2020-10-12T22:50:38Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.prestosql.annotation.UsedByGeneratedCode;\n+import io.prestosql.metadata.FunctionArgumentDefinition;\n+import io.prestosql.metadata.FunctionBinding;\n+import io.prestosql.metadata.FunctionMetadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.SqlScalarFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.VarcharType;\n+import io.prestosql.type.UnknownType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Collections;\n+\n+import static io.prestosql.metadata.FunctionKind.SCALAR;\n+import static io.prestosql.metadata.Signature.typeVariable;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BOXED_NULLABLE;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.type.TypeSignature.arrayType;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.util.Reflection.methodHandle;\n+import static java.lang.Math.addExact;\n+\n+/**\n+ * Concatenate all but the first argument with separators. The first parameter is used as a separator.\n+ * The function needs at least 2 params.\n+ *\n+ * Null behavior:\n+ * concat_ws(null, ...) returns null.\n+ * concat_ws(sep, arg1, arg2,..., argN) returns arg1 through argN concatenated with separator 'sep'.\n+ * Null arguments are ignored.\n+ *\n+ * concat_ws(sep, array[strings]) returns elements in the array concatenated with separators.\n+ */\n+public final class ConcatWsFunction\n+        extends SqlScalarFunction\n+{\n+    public static final ConcatWsFunction CONCAT_WS = new ConcatWsFunction();\n+    public static final ConcatArrayWs CONCAT_ARRAY_WS = new ConcatArrayWs();\n+\n+    private static final class ConcatArrayWs\n+            extends SqlScalarFunction\n+    {\n+        ConcatArrayWs()\n+        {\n+            super(new FunctionMetadata(\n+                    new Signature(\n+                            \"concat_ws\",\n+                            ImmutableList.of(typeVariable(\"T\")),\n+                            ImmutableList.of(),\n+                            VARCHAR.getTypeSignature(),\n+                            ImmutableList.of(VARCHAR.getTypeSignature(), arrayType(new TypeSignature(\"T\"))),\n+                            false),\n+                    true,\n+                    ImmutableList.of(new FunctionArgumentDefinition(false), new FunctionArgumentDefinition(false)),\n+                    false,\n+                    true,\n+                    \"Concatenates array elements using a separator\",\n+                    SCALAR));\n+        }\n+\n+        @Override\n+        public ScalarFunctionImplementation specialize(FunctionBinding functionBinding)\n+        {\n+            if (functionBinding.getArity() != 2) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"There must be two arguments\");\n+            }\n+\n+            Type arrayValueType = functionBinding.getTypeVariable(\"T\");\n+            if (!(arrayValueType instanceof VarcharType) && !(arrayValueType instanceof UnknownType)) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Array values must be varchar types\");\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3NzE3Nw==", "bodyText": "So, the ConcatArrayWs class could be replaced wholesale with something like this, possibly with an optimized implementation that avoid creating the intermediate Slice array.\npublic final class ConcatArrayWs\n{\n    @ScalarFunction(\"concat_ws\")\n    @SqlType(\"varchar\")\n    public static Slice concatWsArray(@SqlType(\"varchar\") Slice separator, @SqlType(\"array(varchar)\") Block elements)\n    {\n        if (separator == null || elements == null) {\n            return null;\n        }\n        Slice[] args = new Slice[elements.getPositionCount()];\n        for (int i = 0; i < elements.getPositionCount(); i++) {\n            if (elements.isNull(i)) {\n                args[i] = null;\n            }\n            else {\n                int sliceLength = elements.getSliceLength(i);\n                args[i] = elements.getSlice(i, 0, sliceLength);\n            }\n        }\n        return concatWs(separator, args);\n    }\n}", "url": "https://github.com/trinodb/trino/pull/4680#discussion_r503577177", "createdAt": "2020-10-12T23:05:18Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.prestosql.annotation.UsedByGeneratedCode;\n+import io.prestosql.metadata.FunctionArgumentDefinition;\n+import io.prestosql.metadata.FunctionBinding;\n+import io.prestosql.metadata.FunctionMetadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.SqlScalarFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.VarcharType;\n+import io.prestosql.type.UnknownType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Collections;\n+\n+import static io.prestosql.metadata.FunctionKind.SCALAR;\n+import static io.prestosql.metadata.Signature.typeVariable;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BOXED_NULLABLE;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.type.TypeSignature.arrayType;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.util.Reflection.methodHandle;\n+import static java.lang.Math.addExact;\n+\n+/**\n+ * Concatenate all but the first argument with separators. The first parameter is used as a separator.\n+ * The function needs at least 2 params.\n+ *\n+ * Null behavior:\n+ * concat_ws(null, ...) returns null.\n+ * concat_ws(sep, arg1, arg2,..., argN) returns arg1 through argN concatenated with separator 'sep'.\n+ * Null arguments are ignored.\n+ *\n+ * concat_ws(sep, array[strings]) returns elements in the array concatenated with separators.\n+ */\n+public final class ConcatWsFunction\n+        extends SqlScalarFunction\n+{\n+    public static final ConcatWsFunction CONCAT_WS = new ConcatWsFunction();\n+    public static final ConcatArrayWs CONCAT_ARRAY_WS = new ConcatArrayWs();\n+\n+    private static final class ConcatArrayWs\n+            extends SqlScalarFunction\n+    {\n+        ConcatArrayWs()\n+        {\n+            super(new FunctionMetadata(\n+                    new Signature(\n+                            \"concat_ws\",\n+                            ImmutableList.of(typeVariable(\"T\")),\n+                            ImmutableList.of(),\n+                            VARCHAR.getTypeSignature(),\n+                            ImmutableList.of(VARCHAR.getTypeSignature(), arrayType(new TypeSignature(\"T\"))),\n+                            false),\n+                    true,\n+                    ImmutableList.of(new FunctionArgumentDefinition(false), new FunctionArgumentDefinition(false)),\n+                    false,\n+                    true,\n+                    \"Concatenates array elements using a separator\",\n+                    SCALAR));\n+        }\n+\n+        @Override\n+        public ScalarFunctionImplementation specialize(FunctionBinding functionBinding)\n+        {\n+            if (functionBinding.getArity() != 2) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"There must be two arguments\");\n+            }\n+\n+            Type arrayValueType = functionBinding.getTypeVariable(\"T\");\n+            if (!(arrayValueType instanceof VarcharType) && !(arrayValueType instanceof UnknownType)) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Array values must be varchar types\");\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MjM2OA=="}, "originalCommit": null, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI5OTU4MQ==", "bodyText": "replaced with a modified version of your suggestion that avoids creating additional Slice[].", "url": "https://github.com/trinodb/trino/pull/4680#discussion_r504299581", "createdAt": "2020-10-13T22:41:56Z", "author": {"login": "phd3"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.prestosql.annotation.UsedByGeneratedCode;\n+import io.prestosql.metadata.FunctionArgumentDefinition;\n+import io.prestosql.metadata.FunctionBinding;\n+import io.prestosql.metadata.FunctionMetadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.SqlScalarFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.VarcharType;\n+import io.prestosql.type.UnknownType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Collections;\n+\n+import static io.prestosql.metadata.FunctionKind.SCALAR;\n+import static io.prestosql.metadata.Signature.typeVariable;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BOXED_NULLABLE;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.type.TypeSignature.arrayType;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.util.Reflection.methodHandle;\n+import static java.lang.Math.addExact;\n+\n+/**\n+ * Concatenate all but the first argument with separators. The first parameter is used as a separator.\n+ * The function needs at least 2 params.\n+ *\n+ * Null behavior:\n+ * concat_ws(null, ...) returns null.\n+ * concat_ws(sep, arg1, arg2,..., argN) returns arg1 through argN concatenated with separator 'sep'.\n+ * Null arguments are ignored.\n+ *\n+ * concat_ws(sep, array[strings]) returns elements in the array concatenated with separators.\n+ */\n+public final class ConcatWsFunction\n+        extends SqlScalarFunction\n+{\n+    public static final ConcatWsFunction CONCAT_WS = new ConcatWsFunction();\n+    public static final ConcatArrayWs CONCAT_ARRAY_WS = new ConcatArrayWs();\n+\n+    private static final class ConcatArrayWs\n+            extends SqlScalarFunction\n+    {\n+        ConcatArrayWs()\n+        {\n+            super(new FunctionMetadata(\n+                    new Signature(\n+                            \"concat_ws\",\n+                            ImmutableList.of(typeVariable(\"T\")),\n+                            ImmutableList.of(),\n+                            VARCHAR.getTypeSignature(),\n+                            ImmutableList.of(VARCHAR.getTypeSignature(), arrayType(new TypeSignature(\"T\"))),\n+                            false),\n+                    true,\n+                    ImmutableList.of(new FunctionArgumentDefinition(false), new FunctionArgumentDefinition(false)),\n+                    false,\n+                    true,\n+                    \"Concatenates array elements using a separator\",\n+                    SCALAR));\n+        }\n+\n+        @Override\n+        public ScalarFunctionImplementation specialize(FunctionBinding functionBinding)\n+        {\n+            if (functionBinding.getArity() != 2) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"There must be two arguments\");\n+            }\n+\n+            Type arrayValueType = functionBinding.getTypeVariable(\"T\");\n+            if (!(arrayValueType instanceof VarcharType) && !(arrayValueType instanceof UnknownType)) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Array values must be varchar types\");\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MjM2OA=="}, "originalCommit": null, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NDIwNTgzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMzoxMTo0NlrOHgQBnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QyMjo0MToxM1rOHg7_Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3OTAzOQ==", "bodyText": "When would this happen? The separator argument is marked as non-nullable, and the values array is the result of collecting all the remaining arguments, so it should always be a non-null array, with possibly no elements.", "url": "https://github.com/trinodb/trino/pull/4680#discussion_r503579039", "createdAt": "2020-10-12T23:11:46Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.prestosql.annotation.UsedByGeneratedCode;\n+import io.prestosql.metadata.FunctionArgumentDefinition;\n+import io.prestosql.metadata.FunctionBinding;\n+import io.prestosql.metadata.FunctionMetadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.SqlScalarFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.VarcharType;\n+import io.prestosql.type.UnknownType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Collections;\n+\n+import static io.prestosql.metadata.FunctionKind.SCALAR;\n+import static io.prestosql.metadata.Signature.typeVariable;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BOXED_NULLABLE;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.type.TypeSignature.arrayType;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.util.Reflection.methodHandle;\n+import static java.lang.Math.addExact;\n+\n+/**\n+ * Concatenate all but the first argument with separators. The first parameter is used as a separator.\n+ * The function needs at least 2 params.\n+ *\n+ * Null behavior:\n+ * concat_ws(null, ...) returns null.\n+ * concat_ws(sep, arg1, arg2,..., argN) returns arg1 through argN concatenated with separator 'sep'.\n+ * Null arguments are ignored.\n+ *\n+ * concat_ws(sep, array[strings]) returns elements in the array concatenated with separators.\n+ */\n+public final class ConcatWsFunction\n+        extends SqlScalarFunction\n+{\n+    public static final ConcatWsFunction CONCAT_WS = new ConcatWsFunction();\n+    public static final ConcatArrayWs CONCAT_ARRAY_WS = new ConcatArrayWs();\n+\n+    private static final class ConcatArrayWs\n+            extends SqlScalarFunction\n+    {\n+        ConcatArrayWs()\n+        {\n+            super(new FunctionMetadata(\n+                    new Signature(\n+                            \"concat_ws\",\n+                            ImmutableList.of(typeVariable(\"T\")),\n+                            ImmutableList.of(),\n+                            VARCHAR.getTypeSignature(),\n+                            ImmutableList.of(VARCHAR.getTypeSignature(), arrayType(new TypeSignature(\"T\"))),\n+                            false),\n+                    true,\n+                    ImmutableList.of(new FunctionArgumentDefinition(false), new FunctionArgumentDefinition(false)),\n+                    false,\n+                    true,\n+                    \"Concatenates array elements using a separator\",\n+                    SCALAR));\n+        }\n+\n+        @Override\n+        public ScalarFunctionImplementation specialize(FunctionBinding functionBinding)\n+        {\n+            if (functionBinding.getArity() != 2) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"There must be two arguments\");\n+            }\n+\n+            Type arrayValueType = functionBinding.getTypeVariable(\"T\");\n+            if (!(arrayValueType instanceof VarcharType) && !(arrayValueType instanceof UnknownType)) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Array values must be varchar types\");\n+            }\n+\n+            return new ChoicesScalarFunctionImplementation(\n+                    functionBinding,\n+                    NULLABLE_RETURN,\n+                    ImmutableList.of(NEVER_NULL, NEVER_NULL),\n+                    methodHandle(ConcatWsFunction.class, \"concatWsArray\", Slice.class, Block.class));\n+        }\n+    }\n+\n+    public ConcatWsFunction()\n+    {\n+        super(new FunctionMetadata(\n+                new Signature(\n+                        \"concat_ws\",\n+                        ImmutableList.of(),\n+                        ImmutableList.of(),\n+                        VARCHAR.getTypeSignature(),\n+                        ImmutableList.of(VARCHAR.getTypeSignature(), VARCHAR.getTypeSignature()),\n+                        true),\n+                true,\n+                ImmutableList.of(new FunctionArgumentDefinition(false), new FunctionArgumentDefinition(true)),\n+                false,\n+                true,\n+                \"Concatenates elements using separator\",\n+                SCALAR));\n+    }\n+\n+    @Override\n+    public ScalarFunctionImplementation specialize(FunctionBinding binding)\n+    {\n+        if (binding.getArity() < 2) {\n+            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"There must be two or more arguments\");\n+        }\n+\n+        int valueCount = binding.getArity() - 1;\n+        MethodHandle arrayMethodHandle = methodHandle(ConcatWsFunction.class, \"concatWs\", Slice.class, Slice[].class);\n+        MethodHandle customMethodHandle = arrayMethodHandle.asCollector(Slice[].class, valueCount);\n+\n+        return new ChoicesScalarFunctionImplementation(\n+                binding,\n+                NULLABLE_RETURN,\n+                ImmutableList.<InvocationConvention.InvocationArgumentConvention>builder()\n+                        .add(NEVER_NULL)\n+                        .addAll(Collections.nCopies(valueCount, BOXED_NULLABLE))\n+                        .build(),\n+                customMethodHandle);\n+    }\n+\n+    @UsedByGeneratedCode\n+    public static Slice concatWsArray(Slice separator, Block block)\n+    {\n+        if (separator == null || block == null) {\n+            return null;\n+        }\n+        Slice[] args = new Slice[block.getPositionCount()];\n+        for (int i = 0; i < block.getPositionCount(); i++) {\n+            if (block.isNull(i)) {\n+                args[i] = null;\n+            }\n+            else {\n+                int sliceLength = block.getSliceLength(i);\n+                args[i] = block.getSlice(i, 0, sliceLength);\n+            }\n+        }\n+        return concatWs(separator, args);\n+    }\n+\n+    @UsedByGeneratedCode\n+    public static Slice concatWs(Slice separator, Slice[] values)\n+    {\n+        if (separator == null || values == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI5OTM1NQ==", "bodyText": "you're right, removed.", "url": "https://github.com/trinodb/trino/pull/4680#discussion_r504299355", "createdAt": "2020-10-13T22:41:13Z", "author": {"login": "phd3"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.prestosql.annotation.UsedByGeneratedCode;\n+import io.prestosql.metadata.FunctionArgumentDefinition;\n+import io.prestosql.metadata.FunctionBinding;\n+import io.prestosql.metadata.FunctionMetadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.SqlScalarFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.VarcharType;\n+import io.prestosql.type.UnknownType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Collections;\n+\n+import static io.prestosql.metadata.FunctionKind.SCALAR;\n+import static io.prestosql.metadata.Signature.typeVariable;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BOXED_NULLABLE;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.type.TypeSignature.arrayType;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.util.Reflection.methodHandle;\n+import static java.lang.Math.addExact;\n+\n+/**\n+ * Concatenate all but the first argument with separators. The first parameter is used as a separator.\n+ * The function needs at least 2 params.\n+ *\n+ * Null behavior:\n+ * concat_ws(null, ...) returns null.\n+ * concat_ws(sep, arg1, arg2,..., argN) returns arg1 through argN concatenated with separator 'sep'.\n+ * Null arguments are ignored.\n+ *\n+ * concat_ws(sep, array[strings]) returns elements in the array concatenated with separators.\n+ */\n+public final class ConcatWsFunction\n+        extends SqlScalarFunction\n+{\n+    public static final ConcatWsFunction CONCAT_WS = new ConcatWsFunction();\n+    public static final ConcatArrayWs CONCAT_ARRAY_WS = new ConcatArrayWs();\n+\n+    private static final class ConcatArrayWs\n+            extends SqlScalarFunction\n+    {\n+        ConcatArrayWs()\n+        {\n+            super(new FunctionMetadata(\n+                    new Signature(\n+                            \"concat_ws\",\n+                            ImmutableList.of(typeVariable(\"T\")),\n+                            ImmutableList.of(),\n+                            VARCHAR.getTypeSignature(),\n+                            ImmutableList.of(VARCHAR.getTypeSignature(), arrayType(new TypeSignature(\"T\"))),\n+                            false),\n+                    true,\n+                    ImmutableList.of(new FunctionArgumentDefinition(false), new FunctionArgumentDefinition(false)),\n+                    false,\n+                    true,\n+                    \"Concatenates array elements using a separator\",\n+                    SCALAR));\n+        }\n+\n+        @Override\n+        public ScalarFunctionImplementation specialize(FunctionBinding functionBinding)\n+        {\n+            if (functionBinding.getArity() != 2) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"There must be two arguments\");\n+            }\n+\n+            Type arrayValueType = functionBinding.getTypeVariable(\"T\");\n+            if (!(arrayValueType instanceof VarcharType) && !(arrayValueType instanceof UnknownType)) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Array values must be varchar types\");\n+            }\n+\n+            return new ChoicesScalarFunctionImplementation(\n+                    functionBinding,\n+                    NULLABLE_RETURN,\n+                    ImmutableList.of(NEVER_NULL, NEVER_NULL),\n+                    methodHandle(ConcatWsFunction.class, \"concatWsArray\", Slice.class, Block.class));\n+        }\n+    }\n+\n+    public ConcatWsFunction()\n+    {\n+        super(new FunctionMetadata(\n+                new Signature(\n+                        \"concat_ws\",\n+                        ImmutableList.of(),\n+                        ImmutableList.of(),\n+                        VARCHAR.getTypeSignature(),\n+                        ImmutableList.of(VARCHAR.getTypeSignature(), VARCHAR.getTypeSignature()),\n+                        true),\n+                true,\n+                ImmutableList.of(new FunctionArgumentDefinition(false), new FunctionArgumentDefinition(true)),\n+                false,\n+                true,\n+                \"Concatenates elements using separator\",\n+                SCALAR));\n+    }\n+\n+    @Override\n+    public ScalarFunctionImplementation specialize(FunctionBinding binding)\n+    {\n+        if (binding.getArity() < 2) {\n+            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"There must be two or more arguments\");\n+        }\n+\n+        int valueCount = binding.getArity() - 1;\n+        MethodHandle arrayMethodHandle = methodHandle(ConcatWsFunction.class, \"concatWs\", Slice.class, Slice[].class);\n+        MethodHandle customMethodHandle = arrayMethodHandle.asCollector(Slice[].class, valueCount);\n+\n+        return new ChoicesScalarFunctionImplementation(\n+                binding,\n+                NULLABLE_RETURN,\n+                ImmutableList.<InvocationConvention.InvocationArgumentConvention>builder()\n+                        .add(NEVER_NULL)\n+                        .addAll(Collections.nCopies(valueCount, BOXED_NULLABLE))\n+                        .build(),\n+                customMethodHandle);\n+    }\n+\n+    @UsedByGeneratedCode\n+    public static Slice concatWsArray(Slice separator, Block block)\n+    {\n+        if (separator == null || block == null) {\n+            return null;\n+        }\n+        Slice[] args = new Slice[block.getPositionCount()];\n+        for (int i = 0; i < block.getPositionCount(); i++) {\n+            if (block.isNull(i)) {\n+                args[i] = null;\n+            }\n+            else {\n+                int sliceLength = block.getSliceLength(i);\n+                args[i] = block.getSlice(i, 0, sliceLength);\n+            }\n+        }\n+        return concatWs(separator, args);\n+    }\n+\n+    @UsedByGeneratedCode\n+    public static Slice concatWs(Slice separator, Slice[] values)\n+    {\n+        if (separator == null || values == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3OTAzOQ=="}, "originalCommit": null, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NDIxNTEyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMzoxNzowNlrOHgQHKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QyMjozODowMVrOHg760w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4MDQ1OA==", "bodyText": "This will happen when the length is larger than Integer.MAX_VALUE. This is way too big. The engine can't handle pages that big anyway. I'd cap this to a much lower value, in the order of megabytes (current target size for pages is ~1MB -- see PageBuilderStatus.DEFAULT_MAX_PAGE_SIZE_IN_BYTES).", "url": "https://github.com/trinodb/trino/pull/4680#discussion_r503580458", "createdAt": "2020-10-12T23:17:06Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.prestosql.annotation.UsedByGeneratedCode;\n+import io.prestosql.metadata.FunctionArgumentDefinition;\n+import io.prestosql.metadata.FunctionBinding;\n+import io.prestosql.metadata.FunctionMetadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.SqlScalarFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.VarcharType;\n+import io.prestosql.type.UnknownType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Collections;\n+\n+import static io.prestosql.metadata.FunctionKind.SCALAR;\n+import static io.prestosql.metadata.Signature.typeVariable;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BOXED_NULLABLE;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.type.TypeSignature.arrayType;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.util.Reflection.methodHandle;\n+import static java.lang.Math.addExact;\n+\n+/**\n+ * Concatenate all but the first argument with separators. The first parameter is used as a separator.\n+ * The function needs at least 2 params.\n+ *\n+ * Null behavior:\n+ * concat_ws(null, ...) returns null.\n+ * concat_ws(sep, arg1, arg2,..., argN) returns arg1 through argN concatenated with separator 'sep'.\n+ * Null arguments are ignored.\n+ *\n+ * concat_ws(sep, array[strings]) returns elements in the array concatenated with separators.\n+ */\n+public final class ConcatWsFunction\n+        extends SqlScalarFunction\n+{\n+    public static final ConcatWsFunction CONCAT_WS = new ConcatWsFunction();\n+    public static final ConcatArrayWs CONCAT_ARRAY_WS = new ConcatArrayWs();\n+\n+    private static final class ConcatArrayWs\n+            extends SqlScalarFunction\n+    {\n+        ConcatArrayWs()\n+        {\n+            super(new FunctionMetadata(\n+                    new Signature(\n+                            \"concat_ws\",\n+                            ImmutableList.of(typeVariable(\"T\")),\n+                            ImmutableList.of(),\n+                            VARCHAR.getTypeSignature(),\n+                            ImmutableList.of(VARCHAR.getTypeSignature(), arrayType(new TypeSignature(\"T\"))),\n+                            false),\n+                    true,\n+                    ImmutableList.of(new FunctionArgumentDefinition(false), new FunctionArgumentDefinition(false)),\n+                    false,\n+                    true,\n+                    \"Concatenates array elements using a separator\",\n+                    SCALAR));\n+        }\n+\n+        @Override\n+        public ScalarFunctionImplementation specialize(FunctionBinding functionBinding)\n+        {\n+            if (functionBinding.getArity() != 2) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"There must be two arguments\");\n+            }\n+\n+            Type arrayValueType = functionBinding.getTypeVariable(\"T\");\n+            if (!(arrayValueType instanceof VarcharType) && !(arrayValueType instanceof UnknownType)) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Array values must be varchar types\");\n+            }\n+\n+            return new ChoicesScalarFunctionImplementation(\n+                    functionBinding,\n+                    NULLABLE_RETURN,\n+                    ImmutableList.of(NEVER_NULL, NEVER_NULL),\n+                    methodHandle(ConcatWsFunction.class, \"concatWsArray\", Slice.class, Block.class));\n+        }\n+    }\n+\n+    public ConcatWsFunction()\n+    {\n+        super(new FunctionMetadata(\n+                new Signature(\n+                        \"concat_ws\",\n+                        ImmutableList.of(),\n+                        ImmutableList.of(),\n+                        VARCHAR.getTypeSignature(),\n+                        ImmutableList.of(VARCHAR.getTypeSignature(), VARCHAR.getTypeSignature()),\n+                        true),\n+                true,\n+                ImmutableList.of(new FunctionArgumentDefinition(false), new FunctionArgumentDefinition(true)),\n+                false,\n+                true,\n+                \"Concatenates elements using separator\",\n+                SCALAR));\n+    }\n+\n+    @Override\n+    public ScalarFunctionImplementation specialize(FunctionBinding binding)\n+    {\n+        if (binding.getArity() < 2) {\n+            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"There must be two or more arguments\");\n+        }\n+\n+        int valueCount = binding.getArity() - 1;\n+        MethodHandle arrayMethodHandle = methodHandle(ConcatWsFunction.class, \"concatWs\", Slice.class, Slice[].class);\n+        MethodHandle customMethodHandle = arrayMethodHandle.asCollector(Slice[].class, valueCount);\n+\n+        return new ChoicesScalarFunctionImplementation(\n+                binding,\n+                NULLABLE_RETURN,\n+                ImmutableList.<InvocationConvention.InvocationArgumentConvention>builder()\n+                        .add(NEVER_NULL)\n+                        .addAll(Collections.nCopies(valueCount, BOXED_NULLABLE))\n+                        .build(),\n+                customMethodHandle);\n+    }\n+\n+    @UsedByGeneratedCode\n+    public static Slice concatWsArray(Slice separator, Block block)\n+    {\n+        if (separator == null || block == null) {\n+            return null;\n+        }\n+        Slice[] args = new Slice[block.getPositionCount()];\n+        for (int i = 0; i < block.getPositionCount(); i++) {\n+            if (block.isNull(i)) {\n+                args[i] = null;\n+            }\n+            else {\n+                int sliceLength = block.getSliceLength(i);\n+                args[i] = block.getSlice(i, 0, sliceLength);\n+            }\n+        }\n+        return concatWs(separator, args);\n+    }\n+\n+    @UsedByGeneratedCode\n+    public static Slice concatWs(Slice separator, Slice[] values)\n+    {\n+        if (separator == null || values == null) {\n+            return null;\n+        }\n+\n+        // Validate size of output\n+        int length = 0;\n+        boolean requiresSeparator = false;\n+\n+        for (Slice value : values) {\n+            if (value == null) {\n+                continue;\n+            }\n+            try {\n+                if (requiresSeparator) {\n+                    length = addExact(length, separator.length());\n+                }\n+                length = addExact(length, value.length());\n+                requiresSeparator = true;\n+            }\n+            catch (ArithmeticException e) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Concatenated string is too large\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI5ODE5NQ==", "bodyText": "I've added a stricter upper bound, and removed the ArithmeticException check for brevity, which is very unlikely to be thrown given this tighter bound.", "url": "https://github.com/trinodb/trino/pull/4680#discussion_r504298195", "createdAt": "2020-10-13T22:38:01Z", "author": {"login": "phd3"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ConcatWsFunction.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.prestosql.annotation.UsedByGeneratedCode;\n+import io.prestosql.metadata.FunctionArgumentDefinition;\n+import io.prestosql.metadata.FunctionBinding;\n+import io.prestosql.metadata.FunctionMetadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.SqlScalarFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.VarcharType;\n+import io.prestosql.type.UnknownType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Collections;\n+\n+import static io.prestosql.metadata.FunctionKind.SCALAR;\n+import static io.prestosql.metadata.Signature.typeVariable;\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BOXED_NULLABLE;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.type.TypeSignature.arrayType;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.util.Reflection.methodHandle;\n+import static java.lang.Math.addExact;\n+\n+/**\n+ * Concatenate all but the first argument with separators. The first parameter is used as a separator.\n+ * The function needs at least 2 params.\n+ *\n+ * Null behavior:\n+ * concat_ws(null, ...) returns null.\n+ * concat_ws(sep, arg1, arg2,..., argN) returns arg1 through argN concatenated with separator 'sep'.\n+ * Null arguments are ignored.\n+ *\n+ * concat_ws(sep, array[strings]) returns elements in the array concatenated with separators.\n+ */\n+public final class ConcatWsFunction\n+        extends SqlScalarFunction\n+{\n+    public static final ConcatWsFunction CONCAT_WS = new ConcatWsFunction();\n+    public static final ConcatArrayWs CONCAT_ARRAY_WS = new ConcatArrayWs();\n+\n+    private static final class ConcatArrayWs\n+            extends SqlScalarFunction\n+    {\n+        ConcatArrayWs()\n+        {\n+            super(new FunctionMetadata(\n+                    new Signature(\n+                            \"concat_ws\",\n+                            ImmutableList.of(typeVariable(\"T\")),\n+                            ImmutableList.of(),\n+                            VARCHAR.getTypeSignature(),\n+                            ImmutableList.of(VARCHAR.getTypeSignature(), arrayType(new TypeSignature(\"T\"))),\n+                            false),\n+                    true,\n+                    ImmutableList.of(new FunctionArgumentDefinition(false), new FunctionArgumentDefinition(false)),\n+                    false,\n+                    true,\n+                    \"Concatenates array elements using a separator\",\n+                    SCALAR));\n+        }\n+\n+        @Override\n+        public ScalarFunctionImplementation specialize(FunctionBinding functionBinding)\n+        {\n+            if (functionBinding.getArity() != 2) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"There must be two arguments\");\n+            }\n+\n+            Type arrayValueType = functionBinding.getTypeVariable(\"T\");\n+            if (!(arrayValueType instanceof VarcharType) && !(arrayValueType instanceof UnknownType)) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Array values must be varchar types\");\n+            }\n+\n+            return new ChoicesScalarFunctionImplementation(\n+                    functionBinding,\n+                    NULLABLE_RETURN,\n+                    ImmutableList.of(NEVER_NULL, NEVER_NULL),\n+                    methodHandle(ConcatWsFunction.class, \"concatWsArray\", Slice.class, Block.class));\n+        }\n+    }\n+\n+    public ConcatWsFunction()\n+    {\n+        super(new FunctionMetadata(\n+                new Signature(\n+                        \"concat_ws\",\n+                        ImmutableList.of(),\n+                        ImmutableList.of(),\n+                        VARCHAR.getTypeSignature(),\n+                        ImmutableList.of(VARCHAR.getTypeSignature(), VARCHAR.getTypeSignature()),\n+                        true),\n+                true,\n+                ImmutableList.of(new FunctionArgumentDefinition(false), new FunctionArgumentDefinition(true)),\n+                false,\n+                true,\n+                \"Concatenates elements using separator\",\n+                SCALAR));\n+    }\n+\n+    @Override\n+    public ScalarFunctionImplementation specialize(FunctionBinding binding)\n+    {\n+        if (binding.getArity() < 2) {\n+            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"There must be two or more arguments\");\n+        }\n+\n+        int valueCount = binding.getArity() - 1;\n+        MethodHandle arrayMethodHandle = methodHandle(ConcatWsFunction.class, \"concatWs\", Slice.class, Slice[].class);\n+        MethodHandle customMethodHandle = arrayMethodHandle.asCollector(Slice[].class, valueCount);\n+\n+        return new ChoicesScalarFunctionImplementation(\n+                binding,\n+                NULLABLE_RETURN,\n+                ImmutableList.<InvocationConvention.InvocationArgumentConvention>builder()\n+                        .add(NEVER_NULL)\n+                        .addAll(Collections.nCopies(valueCount, BOXED_NULLABLE))\n+                        .build(),\n+                customMethodHandle);\n+    }\n+\n+    @UsedByGeneratedCode\n+    public static Slice concatWsArray(Slice separator, Block block)\n+    {\n+        if (separator == null || block == null) {\n+            return null;\n+        }\n+        Slice[] args = new Slice[block.getPositionCount()];\n+        for (int i = 0; i < block.getPositionCount(); i++) {\n+            if (block.isNull(i)) {\n+                args[i] = null;\n+            }\n+            else {\n+                int sliceLength = block.getSliceLength(i);\n+                args[i] = block.getSlice(i, 0, sliceLength);\n+            }\n+        }\n+        return concatWs(separator, args);\n+    }\n+\n+    @UsedByGeneratedCode\n+    public static Slice concatWs(Slice separator, Slice[] values)\n+    {\n+        if (separator == null || values == null) {\n+            return null;\n+        }\n+\n+        // Validate size of output\n+        int length = 0;\n+        boolean requiresSeparator = false;\n+\n+        for (Slice value : values) {\n+            if (value == null) {\n+                continue;\n+            }\n+            try {\n+                if (requiresSeparator) {\n+                    length = addExact(length, separator.length());\n+                }\n+                length = addExact(length, value.length());\n+                requiresSeparator = true;\n+            }\n+            catch (ArithmeticException e) {\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Concatenated string is too large\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4MDQ1OA=="}, "originalCommit": null, "originalPosition": 186}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3589, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}