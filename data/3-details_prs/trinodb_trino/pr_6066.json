{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI2MDM5NjE0", "number": 6066, "title": "Add support for coercions in table scan redirections", "bodyText": "Depends on: #6030", "createdAt": "2020-11-23T22:41:05Z", "url": "https://github.com/trinodb/trino/pull/6066", "merged": true, "mergeCommit": {"oid": "36ead567ea11e0d3d236f13df8bb8d2944eecc2a"}, "closed": true, "closedAt": "2021-05-28T08:19:47Z", "author": {"login": "sopel39"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdfmEv6ABqjQwMzE2MjI3MzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABea-GdFgFqTY3MDYxNDA4OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/c8dcea9ff07cb83a68421ee32fb2e9d8c8102042", "committedDate": "2020-11-24T09:10:14Z", "message": "Add support for coercions in table scan redirections"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MjY3MzIz", "url": "https://github.com/trinodb/trino/pull/6066#pullrequestreview-669267323", "createdAt": "2021-05-26T16:36:22Z", "commit": {"oid": "a1f28760519f36f1d7083eedc1460ed401e522b9"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yNlQxNjozNjoyMlrOJiRAWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yNlQxNjo0NzowMVrOJiRiSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkwOTk3OQ==", "bodyText": "What's dest_col_a in this example?", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r639909979", "createdAt": "2021-05-26T16:36:22Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -201,6 +211,25 @@ public void testRedirectAfterColumnPruningOnPushedDownPredicate()\n         }\n     }\n \n+    @Test\n+    public void testPredicateTypeMismatch()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(typeMismatchedRedirectionMappingBC, Optional.of(ImmutableSet.of(sourceColumnHandleB))),\n+                Optional.of(this::mockApplyProjection),\n+                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleC))))) {\n+            // After 'source_col_c = 1' is pushed into source table scan, it's possible for 'source_col_c' table scan assignment to be pruned\n+            // Redirection results in Project('dest_col_b') -> Filter('dest_col_c = 1') -> TableScan for such case\n+            // but dest_col_a has mismatched type compared to source domain", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1f28760519f36f1d7083eedc1460ed401e522b9"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxMTkyMQ==", "bodyText": "Commit message should provide some explanation on what this change is about", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r639911921", "createdAt": "2021-05-26T16:37:51Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -16,6 +16,8 @@\n import com.google.common.collect.ImmutableBiMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNDA0OQ==", "bodyText": "When and why would this ever be false? This doesn't seem necessary. If the connector doesn't want to allow coercions, it should just not perform the redirection.", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r639914049", "createdAt": "2021-05-26T16:40:40Z", "author": {"login": "martint"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/TableScanRedirectApplicationResult.java", "diffHunk": "@@ -26,12 +26,27 @@\n     private final Map<ColumnHandle, String> destinationColumns;\n     // filter that needs to be applied on top of table scan\n     private final TupleDomain<String> filter;\n+    // should coercions be used when source and redirected column types don't match\n+    private boolean allowCoercions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNTExNg==", "bodyText": "This belongs in the previous commit", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r639915116", "createdAt": "2021-05-26T16:42:03Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -215,12 +223,12 @@ public void testRedirectAfterColumnPruningOnPushedDownPredicate()\n     public void testPredicateTypeMismatch()\n     {\n         try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n-                getMockApplyRedirectAfterPredicatePushdown(typeMismatchedRedirectionMappingBC, Optional.of(ImmutableSet.of(sourceColumnHandleB))),\n+                getMockApplyRedirectAfterPredicatePushdown(typeMismatchedRedirectionMappingBC, Optional.of(ImmutableSet.of(sourceColumnHandleB)), false),\n                 Optional.of(this::mockApplyProjection),\n                 Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleC))))) {\n             // After 'source_col_c = 1' is pushed into source table scan, it's possible for 'source_col_c' table scan assignment to be pruned\n             // Redirection results in Project('dest_col_b') -> Filter('dest_col_c = 1') -> TableScan for such case\n-            // but dest_col_a has mismatched type compared to source domain\n+            // but dest_col_c has mismatched type compared to source domain", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNjA2Nw==", "bodyText": "TrinoException", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r639916067", "createdAt": "2021-05-26T16:43:19Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -88,49 +94,56 @@ public Result apply(TableScanNode scanNode, Captures captures, Context context)\n \n         Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n         Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n-        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n-                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n-                    String destinationColumn = columnMapping.get(entry.getValue());\n-                    if (destinationColumn == null) {\n-                        throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n-                    }\n-                    ColumnHandle destinationColumnHandle = destinationColumnHandles.get(destinationColumn);\n-                    if (destinationColumnHandle == null) {\n-                        throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n-                    }\n-\n-                    // validate that redirected types match source types\n-                    Type sourceType = context.getSymbolAllocator().getTypes().get(entry.getKey());\n-                    Type redirectedType = metadata.getColumnMetadata(context.getSession(), destinationTableHandle.get(), destinationColumnHandle).getType();\n-                    if (!sourceType.equals(redirectedType)) {\n-                        throwTypeMismatchException(\n-                                destinationTable,\n-                                destinationColumn,\n-                                redirectedType,\n-                                scanNode.getTable(),\n-                                entry.getValue(),\n-                                sourceType);\n-                    }\n-\n-                    return destinationColumnHandle;\n-                }));\n+        ImmutableMap.Builder<Symbol, Cast> casts = ImmutableMap.builder();\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.builder();\n+        for (Map.Entry<Symbol, ColumnHandle> assignment : scanNode.getAssignments().entrySet()) {\n+            String destinationColumn = columnMapping.get(assignment.getValue());\n+            if (destinationColumn == null) {\n+                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find mapping for source column %s in table scan redirection\", assignment.getValue()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxODY2NA==", "bodyText": "This is missing the typeOnlyCoercion flag.", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r639918664", "createdAt": "2021-05-26T16:47:01Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -144,70 +157,118 @@ public Result apply(TableScanNode scanNode, Captures captures, Context context)\n                 return symbol;\n             }\n \n-            // validate that redirected types match source types\n+            // Column pruning after predicate is pushed into table scan can remove assignments for filter columns from the scan node\n             Type domainType = requiredFilter.getDomains().get().get(destinationColumn).getType();\n+            symbol = context.getSymbolAllocator().newSymbol(destinationColumn, domainType);\n+\n             ColumnHandle destinationColumnHandle = destinationColumnHandles.get(destinationColumn);\n+            if (destinationColumnHandle == null) {\n+                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+            }\n+\n+            // insert casts if redirected types don't match domain types\n             Type redirectedType = metadata.getColumnMetadata(context.getSession(), destinationTableHandle.get(), destinationColumnHandle).getType();\n             if (!domainType.equals(redirectedType)) {\n-                throwTypeMismatchException(\n+                Symbol redirectedSymbol = context.getSymbolAllocator().newSymbol(destinationColumn, redirectedType);\n+                Cast cast = getCast(\n+                        tableScanRedirectApplicationResult.get().isAllowCoercions(),\n                         destinationTable,\n                         destinationColumn,\n                         redirectedType,\n+                        redirectedSymbol,\n                         scanNode.getTable(),\n                         sourceColumnHandle,\n                         domainType);\n+                casts.put(symbol, cast);\n+                newAssignmentsBuilder.put(redirectedSymbol, destinationColumnHandle);\n             }\n-\n-            // Column pruning after predicate is pushed into table scan can remove assignments for filter columns from the scan node\n-            symbol = context.getSymbolAllocator().newSymbol(destinationColumn, domainType);\n-            if (destinationColumnHandle == null) {\n-                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+            else {\n+                newAssignmentsBuilder.put(symbol, destinationColumnHandle);\n             }\n-            newAssignmentsBuilder.put(symbol, destinationColumnHandle);\n-            newOutputSymbolsBuilder.add(symbol);\n+\n             return symbol;\n         });\n \n-        List<Symbol> newOutputSymbols = newOutputSymbolsBuilder.build();\n+        Map<Symbol, ColumnHandle> newAssignments = newAssignmentsBuilder.build();\n         TableScanNode newScanNode = new TableScanNode(\n                 scanNode.getId(),\n                 destinationTableHandle.get(),\n-                newOutputSymbols,\n-                newAssignmentsBuilder.build(),\n+                ImmutableList.copyOf(newAssignments.keySet()),\n+                newAssignments,\n                 TupleDomain.all(),\n                 scanNode.isForDelete());\n \n         FilterNode filterNode = new FilterNode(\n                 context.getIdAllocator().getNextId(),\n-                newScanNode,\n+                applyProjection(\n+                        context.getIdAllocator(),\n+                        newAssignments.keySet(),\n+                        casts.build(),\n+                        newScanNode),\n                 domainTranslator.toPredicate(transformedConstraint));\n-        if (newOutputSymbols.size() == scanNode.getOutputSymbols().size()) {\n-            return Result.ofPlanNode(filterNode);\n+\n+        return Result.ofPlanNode(applyProjection(\n+                context.getIdAllocator(),\n+                ImmutableSet.copyOf(scanNode.getOutputSymbols()),\n+                ImmutableMap.of(),\n+                filterNode));\n+    }\n+\n+    private PlanNode applyProjection(\n+            PlanNodeIdAllocator idAllocator,\n+            Set<Symbol> requiredSymbols,\n+            Map<Symbol, Cast> casts,\n+            PlanNode source)\n+    {\n+        if (casts.isEmpty() && requiredSymbols.equals(ImmutableSet.copyOf(source.getOutputSymbols()))) {\n+            return source;\n         }\n \n-        return Result.ofPlanNode(\n-                new ProjectNode(\n-                        context.getIdAllocator().getNextId(),\n-                        filterNode,\n-                        Assignments.identity(scanNode.getOutputSymbols())));\n+        return new ProjectNode(\n+                idAllocator.getNextId(),\n+                source,\n+                Assignments.builder()\n+                        .putIdentities(Sets.difference(requiredSymbols, casts.keySet()))\n+                        .putAll(casts)\n+                        .build());\n     }\n \n-    private static void throwTypeMismatchException(\n+    private Cast getCast(\n+            boolean allowCoercions,\n             CatalogSchemaTableName destinationTable,\n             String destinationColumn,\n             Type destinationType,\n+            Symbol destinationSymbol,\n             TableHandle sourceTable,\n             ColumnHandle sourceColumnHandle,\n             Type sourceType)\n     {\n-        throw new PrestoException(TYPE_MISMATCH, format(\n-                \"Redirected column %s.%s has type %s, different from source column %s.%s type: %s\",\n-                destinationTable,\n-                destinationColumn,\n-                destinationType,\n-                // TODO report source table and column name instead of ConnectorTableHandle, ConnectorColumnHandle toString\n-                sourceTable,\n-                sourceColumnHandle,\n-                sourceType));\n+        if (!allowCoercions) {\n+            throw new PrestoException(TYPE_MISMATCH, format(\n+                    \"Redirected column %s.%s has type %s, different from source column %s.%s type: %s\",\n+                    destinationTable,\n+                    destinationColumn,\n+                    destinationType,\n+                    // TODO report source table and column name instead of ConnectorTableHandle, ConnectorColumnHandle toString\n+                    sourceTable,\n+                    sourceColumnHandle,\n+                    sourceType));\n+        }\n+\n+        try {\n+            metadata.getCoercion(destinationType, sourceType);\n+        }\n+        catch (PrestoException e) {\n+            throw new PrestoException(FUNCTION_NOT_FOUND, format(\n+                    \"Cast not possible from redirected column %s.%s with type %s to source column %s.%s with type: %s\",\n+                    destinationTable,\n+                    destinationColumn,\n+                    destinationType,\n+                    sourceTable,\n+                    sourceColumnHandle,\n+                    sourceType));\n+        }\n+\n+        return new Cast(destinationSymbol.toSymbolReference(), toSqlType(sourceType));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042"}, "originalPosition": 274}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54942cad9b6373d52b94b2ebf82fc4e4aea680b6", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/54942cad9b6373d52b94b2ebf82fc4e4aea680b6", "committedDate": "2021-05-27T13:04:49Z", "message": "Remove SPI support for UNION ALL types of redirections\n\nRedirections SPI will be deprecated and Trino engine won't be extended\nfor UNION ALL support in a foreseeable future."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/c8dcea9ff07cb83a68421ee32fb2e9d8c8102042", "committedDate": "2020-11-24T09:10:14Z", "message": "Add support for coercions in table scan redirections"}, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjcwMDQ1Mzgw", "url": "https://github.com/trinodb/trino/pull/6066#pullrequestreview-670045380", "createdAt": "2021-05-27T11:07:47Z", "commit": {"oid": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yN1QxMTowNzo0N1rOJi2X-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yN1QxMToxMDoxMFrOJi2eFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDUyMjIzMw==", "bodyText": "I was thinking this would be useful for connectors that want to match source with redirected table 1-1 (without mismatched type) and would prefer to throw exception when types mismatch", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640522233", "createdAt": "2021-05-27T11:07:47Z", "author": {"login": "sopel39"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/TableScanRedirectApplicationResult.java", "diffHunk": "@@ -26,12 +26,27 @@\n     private final Map<ColumnHandle, String> destinationColumns;\n     // filter that needs to be applied on top of table scan\n     private final TupleDomain<String> filter;\n+    // should coercions be used when source and redirected column types don't match\n+    private boolean allowCoercions;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxNDA0OQ=="}, "originalCommit": {"oid": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDUyMzc5Nw==", "bodyText": "It can't be type only coercion. E.g we can coerce from timestamp(9) -> timestamp(0)", "url": "https://github.com/trinodb/trino/pull/6066#discussion_r640523797", "createdAt": "2021-05-27T11:10:10Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -144,70 +157,118 @@ public Result apply(TableScanNode scanNode, Captures captures, Context context)\n                 return symbol;\n             }\n \n-            // validate that redirected types match source types\n+            // Column pruning after predicate is pushed into table scan can remove assignments for filter columns from the scan node\n             Type domainType = requiredFilter.getDomains().get().get(destinationColumn).getType();\n+            symbol = context.getSymbolAllocator().newSymbol(destinationColumn, domainType);\n+\n             ColumnHandle destinationColumnHandle = destinationColumnHandles.get(destinationColumn);\n+            if (destinationColumnHandle == null) {\n+                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+            }\n+\n+            // insert casts if redirected types don't match domain types\n             Type redirectedType = metadata.getColumnMetadata(context.getSession(), destinationTableHandle.get(), destinationColumnHandle).getType();\n             if (!domainType.equals(redirectedType)) {\n-                throwTypeMismatchException(\n+                Symbol redirectedSymbol = context.getSymbolAllocator().newSymbol(destinationColumn, redirectedType);\n+                Cast cast = getCast(\n+                        tableScanRedirectApplicationResult.get().isAllowCoercions(),\n                         destinationTable,\n                         destinationColumn,\n                         redirectedType,\n+                        redirectedSymbol,\n                         scanNode.getTable(),\n                         sourceColumnHandle,\n                         domainType);\n+                casts.put(symbol, cast);\n+                newAssignmentsBuilder.put(redirectedSymbol, destinationColumnHandle);\n             }\n-\n-            // Column pruning after predicate is pushed into table scan can remove assignments for filter columns from the scan node\n-            symbol = context.getSymbolAllocator().newSymbol(destinationColumn, domainType);\n-            if (destinationColumnHandle == null) {\n-                throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+            else {\n+                newAssignmentsBuilder.put(symbol, destinationColumnHandle);\n             }\n-            newAssignmentsBuilder.put(symbol, destinationColumnHandle);\n-            newOutputSymbolsBuilder.add(symbol);\n+\n             return symbol;\n         });\n \n-        List<Symbol> newOutputSymbols = newOutputSymbolsBuilder.build();\n+        Map<Symbol, ColumnHandle> newAssignments = newAssignmentsBuilder.build();\n         TableScanNode newScanNode = new TableScanNode(\n                 scanNode.getId(),\n                 destinationTableHandle.get(),\n-                newOutputSymbols,\n-                newAssignmentsBuilder.build(),\n+                ImmutableList.copyOf(newAssignments.keySet()),\n+                newAssignments,\n                 TupleDomain.all(),\n                 scanNode.isForDelete());\n \n         FilterNode filterNode = new FilterNode(\n                 context.getIdAllocator().getNextId(),\n-                newScanNode,\n+                applyProjection(\n+                        context.getIdAllocator(),\n+                        newAssignments.keySet(),\n+                        casts.build(),\n+                        newScanNode),\n                 domainTranslator.toPredicate(transformedConstraint));\n-        if (newOutputSymbols.size() == scanNode.getOutputSymbols().size()) {\n-            return Result.ofPlanNode(filterNode);\n+\n+        return Result.ofPlanNode(applyProjection(\n+                context.getIdAllocator(),\n+                ImmutableSet.copyOf(scanNode.getOutputSymbols()),\n+                ImmutableMap.of(),\n+                filterNode));\n+    }\n+\n+    private PlanNode applyProjection(\n+            PlanNodeIdAllocator idAllocator,\n+            Set<Symbol> requiredSymbols,\n+            Map<Symbol, Cast> casts,\n+            PlanNode source)\n+    {\n+        if (casts.isEmpty() && requiredSymbols.equals(ImmutableSet.copyOf(source.getOutputSymbols()))) {\n+            return source;\n         }\n \n-        return Result.ofPlanNode(\n-                new ProjectNode(\n-                        context.getIdAllocator().getNextId(),\n-                        filterNode,\n-                        Assignments.identity(scanNode.getOutputSymbols())));\n+        return new ProjectNode(\n+                idAllocator.getNextId(),\n+                source,\n+                Assignments.builder()\n+                        .putIdentities(Sets.difference(requiredSymbols, casts.keySet()))\n+                        .putAll(casts)\n+                        .build());\n     }\n \n-    private static void throwTypeMismatchException(\n+    private Cast getCast(\n+            boolean allowCoercions,\n             CatalogSchemaTableName destinationTable,\n             String destinationColumn,\n             Type destinationType,\n+            Symbol destinationSymbol,\n             TableHandle sourceTable,\n             ColumnHandle sourceColumnHandle,\n             Type sourceType)\n     {\n-        throw new PrestoException(TYPE_MISMATCH, format(\n-                \"Redirected column %s.%s has type %s, different from source column %s.%s type: %s\",\n-                destinationTable,\n-                destinationColumn,\n-                destinationType,\n-                // TODO report source table and column name instead of ConnectorTableHandle, ConnectorColumnHandle toString\n-                sourceTable,\n-                sourceColumnHandle,\n-                sourceType));\n+        if (!allowCoercions) {\n+            throw new PrestoException(TYPE_MISMATCH, format(\n+                    \"Redirected column %s.%s has type %s, different from source column %s.%s type: %s\",\n+                    destinationTable,\n+                    destinationColumn,\n+                    destinationType,\n+                    // TODO report source table and column name instead of ConnectorTableHandle, ConnectorColumnHandle toString\n+                    sourceTable,\n+                    sourceColumnHandle,\n+                    sourceType));\n+        }\n+\n+        try {\n+            metadata.getCoercion(destinationType, sourceType);\n+        }\n+        catch (PrestoException e) {\n+            throw new PrestoException(FUNCTION_NOT_FOUND, format(\n+                    \"Cast not possible from redirected column %s.%s with type %s to source column %s.%s with type: %s\",\n+                    destinationTable,\n+                    destinationColumn,\n+                    destinationType,\n+                    sourceTable,\n+                    sourceColumnHandle,\n+                    sourceType));\n+        }\n+\n+        return new Cast(destinationSymbol.toSymbolReference(), toSqlType(sourceType));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkxODY2NA=="}, "originalCommit": {"oid": "c8dcea9ff07cb83a68421ee32fb2e9d8c8102042"}, "originalPosition": 274}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c9b955c83ebbee54ca0c35069a0c43641ffad62", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/9c9b955c83ebbee54ca0c35069a0c43641ffad62", "committedDate": "2021-05-27T20:26:00Z", "message": "Add support for coercions in table scan redirections\n\nRedirected table can have different column types\nthan source table. In that case, an explicit cast\nwill be inserted by the engine."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "9c9b955c83ebbee54ca0c35069a0c43641ffad62", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/9c9b955c83ebbee54ca0c35069a0c43641ffad62", "committedDate": "2021-05-27T20:26:00Z", "message": "Add support for coercions in table scan redirections\n\nRedirected table can have different column types\nthan source table. In that case, an explicit cast\nwill be inserted by the engine."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjcwNjE0MDg5", "url": "https://github.com/trinodb/trino/pull/6066#pullrequestreview-670614089", "createdAt": "2021-05-27T20:31:35Z", "commit": {"oid": "9c9b955c83ebbee54ca0c35069a0c43641ffad62"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2276, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}