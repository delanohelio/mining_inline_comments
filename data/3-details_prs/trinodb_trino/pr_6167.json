{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwMjgxMTk5", "number": 6167, "title": "Make CachingJdbcClient caches session-aware and fix caches invalidation", "bodyText": "BaseJdbcClient.getColumns calls toPrestoType which can return different type mapping based on a session properties. Columns cache created in CachingJdbcClient can be broken due to not taking session properties into account.\nFixes #6106\nFixes #6166", "createdAt": "2020-12-01T12:52:39Z", "url": "https://github.com/trinodb/trino/pull/6167", "merged": true, "mergeCommit": {"oid": "b25c90b44fc47daa3522111ccce2c9f89d76ce4b"}, "closed": true, "closedAt": "2020-12-09T19:26:37Z", "author": {"login": "wendigo"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdh5qoCgFqTU0MTg3NTM3Ng==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdk2yHFgFqTU0OTQyNjUzMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxODc1Mzc2", "url": "https://github.com/trinodb/trino/pull/6167#pullrequestreview-541875376", "createdAt": "2020-12-01T13:07:25Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMzowNzoyNVrOH8rvYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMzowNzo0OVrOH8rwMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM5MzI1MQ==", "bodyText": "This is something we wanted to avoid, to modify SPI for this.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533393251", "createdAt": "2020-12-01T13:07:25Z", "author": {"login": "kokosing"}, "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorSession.java", "diffHunk": "@@ -51,4 +52,6 @@ default long getStartTime()\n     Instant getStart();\n \n     <T> T getProperty(String name, Class<T> type);\n+\n+    Set<String> getPropertiesNames();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM5MzQ1Ng==", "bodyText": "It has to be done for all caches, not only columns.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533393456", "createdAt": "2020-12-01T13:07:49Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -106,8 +108,8 @@ public boolean schemaExists(ConnectorSession session, String schema)\n         if (tableHandle.getColumns().isPresent()) {\n             return tableHandle.getColumns().get();\n         }\n-        ColumnsCacheKey key = new ColumnsCacheKey(JdbcIdentity.from(session), tableHandle.getSchemaTableName());\n-        return get(columnsCache, key, () -> delegate.getColumns(session, tableHandle));\n+\n+        return get(columnsCache, ColumnsCacheKey.forSessionAndTable(session, tableHandle.getSchemaTableName()), () -> delegate.getColumns(session, tableHandle));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 19}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMDU1ODY1", "url": "https://github.com/trinodb/trino/pull/6167#pullrequestreview-542055865", "createdAt": "2020-12-01T16:06:09Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNjowNjowOVrOH80MSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNjozMDo1MFrOH81WdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUzMTcyMA==", "bodyText": "Please do not inline key as this approach makes this line do one thing more (build key) in addition to 2 already existing: Get and Load, but which we cannot split.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533531720", "createdAt": "2020-12-01T16:06:09Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -106,8 +116,8 @@ public boolean schemaExists(ConnectorSession session, String schema)\n         if (tableHandle.getColumns().isPresent()) {\n             return tableHandle.getColumns().get();\n         }\n-        ColumnsCacheKey key = new ColumnsCacheKey(JdbcIdentity.from(session), tableHandle.getSchemaTableName());\n-        return get(columnsCache, key, () -> delegate.getColumns(session, tableHandle));\n+\n+        return get(columnsCache, buildColumnsCacheKey(session, tableHandle.getSchemaTableName()), () -> delegate.getColumns(session, tableHandle));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUzNDQyOQ==", "bodyText": "Why protected?\nWhat about other build...CacheKey?", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533534429", "createdAt": "2020-12-01T16:09:34Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,39 +357,77 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    protected ColumnsCacheKey buildColumnsCacheKey(ConnectorSession session, SchemaTableName tableName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUzNjMxMg==", "bodyText": "nit: cacheKey -> key", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533536312", "createdAt": "2020-12-01T16:11:59Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,39 +357,77 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    protected ColumnsCacheKey buildColumnsCacheKey(ConnectorSession session, SchemaTableName tableName)\n+    {\n+        return new ColumnsCacheKey(JdbcIdentity.from(session), getSessionProperties(session), tableName);\n+    }\n+\n+    private TableHandleCacheKey buildTableHandleCacheKey(ConnectorSession session, SchemaTableName schemaTableName)\n+    {\n+        return new TableHandleCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schemaTableName);\n+    }\n+\n+    private TableNamesCacheKey buildTableNamesCacheKey(ConnectorSession session, Optional<String> schema)\n+    {\n+        return new TableNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schema);\n+    }\n+\n     private void invalidateSchemasCache()\n     {\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(ConnectorSession session, SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateColumnsCache(session, table);\n+        invalidateTableCache(session, table);\n+    }\n+\n+    private void invalidateTableCache(ConnectorSession session, SchemaTableName table)\n+    {\n+        invalidateCache(tableNamesCache, cacheKey -> cacheKey.schemaName.equals(Optional.of(table.getSchemaName())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU0NjEyNw==", "bodyText": "maybe inline .map with next line?", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533546127", "createdAt": "2020-12-01T16:24:41Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,39 +357,77 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    protected ColumnsCacheKey buildColumnsCacheKey(ConnectorSession session, SchemaTableName tableName)\n+    {\n+        return new ColumnsCacheKey(JdbcIdentity.from(session), getSessionProperties(session), tableName);\n+    }\n+\n+    private TableHandleCacheKey buildTableHandleCacheKey(ConnectorSession session, SchemaTableName schemaTableName)\n+    {\n+        return new TableHandleCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schemaTableName);\n+    }\n+\n+    private TableNamesCacheKey buildTableNamesCacheKey(ConnectorSession session, Optional<String> schema)\n+    {\n+        return new TableNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schema);\n+    }\n+\n     private void invalidateSchemasCache()\n     {\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(ConnectorSession session, SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateColumnsCache(session, table);\n+        invalidateTableCache(session, table);\n+    }\n+\n+    private void invalidateTableCache(ConnectorSession session, SchemaTableName table)\n+    {\n+        invalidateCache(tableNamesCache, cacheKey -> cacheKey.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, cacheKey -> cacheKey.tableName.equals(table));\n     }\n \n     private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        invalidateCache(columnsCache, cacheKey -> cacheKey.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionPropertiesProviders.stream()\n+                .map(property -> Map.entry(property.getName(), session.getProperty(property.getName(), property.getJavaType())))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU1MDcwOA==", "bodyText": "do you really need copyOf?", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533550708", "createdAt": "2020-12-01T16:30:50Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,39 +357,77 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    protected ColumnsCacheKey buildColumnsCacheKey(ConnectorSession session, SchemaTableName tableName)\n+    {\n+        return new ColumnsCacheKey(JdbcIdentity.from(session), getSessionProperties(session), tableName);\n+    }\n+\n+    private TableHandleCacheKey buildTableHandleCacheKey(ConnectorSession session, SchemaTableName schemaTableName)\n+    {\n+        return new TableHandleCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schemaTableName);\n+    }\n+\n+    private TableNamesCacheKey buildTableNamesCacheKey(ConnectorSession session, Optional<String> schema)\n+    {\n+        return new TableNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schema);\n+    }\n+\n     private void invalidateSchemasCache()\n     {\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(ConnectorSession session, SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateColumnsCache(session, table);\n+        invalidateTableCache(session, table);\n+    }\n+\n+    private void invalidateTableCache(ConnectorSession session, SchemaTableName table)\n+    {\n+        invalidateCache(tableNamesCache, cacheKey -> cacheKey.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, cacheKey -> cacheKey.tableName.equals(table));\n     }\n \n     private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        invalidateCache(columnsCache, cacheKey -> cacheKey.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionPropertiesProviders.stream()\n+                .map(property -> Map.entry(property.getName(), session.getProperty(property.getName(), property.getJavaType())))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n     }\n \n-    private static final class ColumnsCacheKey\n+    private static <T, V> void invalidateCache(Cache<T, V> cache, Predicate<T> filterFunction)\n+    {\n+        Set<T> cacheKeys = ImmutableMap.copyOf(cache.asMap()).keySet().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 184}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMTEzMTY1", "url": "https://github.com/trinodb/trino/pull/6167#pullrequestreview-542113165", "createdAt": "2020-12-01T17:04:57Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNzowNDo1N1rOH824pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNzoxOTo0OVrOH83goQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU3NTg0NA==", "bodyText": "cachingJdbcClient could not be shared between tests. Please extract it to @BeforeMethod.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533575844", "createdAt": "2020-12-01T17:04:57Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -44,7 +47,7 @@\n     private JdbcClient jdbcClient;\n     private String schema;\n \n-    @BeforeMethod\n+    @BeforeClass", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU4NDU0Ng==", "bodyText": "containsExactlyInAnyOrder", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533584546", "createdAt": "2020-12-01T17:17:30Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -105,10 +108,85 @@ public void testTableHandleCached()\n         assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEqualTo(cachedTable);\n     }\n \n+    @Test\n+    public void shouldInvalidateTableCachesOnTableDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        cachingJdbcClient.dropTable(SESSION, tableHandle);\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+    }\n+\n+    @Test\n+    public void shouldInvalidateTableCachesOnColumnDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        JdbcColumnHandle otherColumn = addColumn(cachingJdbcClient, tableHandle, \"other_column\");\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn, otherColumn);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU4NTQ3Nw==", "bodyText": "dropTable(phantomTable);", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533585477", "createdAt": "2020-12-01T17:18:57Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -105,10 +108,85 @@ public void testTableHandleCached()\n         assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEqualTo(cachedTable);\n     }\n \n+    @Test\n+    public void shouldInvalidateTableCachesOnTableDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        cachingJdbcClient.dropTable(SESSION, tableHandle);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU4NTk2Mw==", "bodyText": "dropTable(phantomTable);", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533585963", "createdAt": "2020-12-01T17:19:38Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -105,10 +108,85 @@ public void testTableHandleCached()\n         assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEqualTo(cachedTable);\n     }\n \n+    @Test\n+    public void shouldInvalidateTableCachesOnTableDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        cachingJdbcClient.dropTable(SESSION, tableHandle);\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+    }\n+\n+    @Test\n+    public void shouldInvalidateTableCachesOnColumnDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        JdbcColumnHandle otherColumn = addColumn(cachingJdbcClient, tableHandle, \"other_column\");\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn, otherColumn);\n+\n+        cachingJdbcClient.dropColumn(SESSION, tableHandle, phantomColumn);\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(otherColumn);\n+\n+        cachingJdbcClient.dropTable(SESSION, tableHandle);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU4NjA4MQ==", "bodyText": "dropTable(phantomTable);", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533586081", "createdAt": "2020-12-01T17:19:49Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -105,10 +108,85 @@ public void testTableHandleCached()\n         assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEqualTo(cachedTable);\n     }\n \n+    @Test\n+    public void shouldInvalidateTableCachesOnTableDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        cachingJdbcClient.dropTable(SESSION, tableHandle);\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+    }\n+\n+    @Test\n+    public void shouldInvalidateTableCachesOnColumnDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        JdbcColumnHandle otherColumn = addColumn(cachingJdbcClient, tableHandle, \"other_column\");\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn, otherColumn);\n+\n+        cachingJdbcClient.dropColumn(SESSION, tableHandle, phantomColumn);\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(otherColumn);\n+\n+        cachingJdbcClient.dropTable(SESSION, tableHandle);\n+    }\n+\n+    @Test\n+    public void shouldInvalidateTableCachesOnColumnRename()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        cachingJdbcClient.renameColumn(SESSION, tableHandle, phantomColumn, \"new_column_name\");\n+\n+        JdbcColumnHandle newColumnHandle = JdbcColumnHandle.builderFrom(phantomColumn)\n+                .setColumnName(\"NEW_COLUMN_NAME\")\n+                .build();\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(newColumnHandle);\n+\n+        cachingJdbcClient.dropTable(SESSION, tableHandle);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 154}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMjExMjA0", "url": "https://github.com/trinodb/trino/pull/6167#pullrequestreview-542211204", "createdAt": "2020-12-01T19:07:30Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOTowNzozMFrOH87sAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOTozMzoxN1rOH88mvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NDUzMQ==", "bodyText": "I was thinking to avoid to even bind CachingJdbcClient in guice, so there would be no question about the way the cache is used in such case. However, I think that might be ok. All I would like to see to to write a unit test where two threads are using disabled CachingJdbcClient and none is waiting for the other.\nPlease either separate that to different commit or mention this in the commit message.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533654531", "createdAt": "2020-12-01T19:07:30Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -59,20 +66,31 @@\n     private final Cache<TableNamesCacheKey, List<SchemaTableName>> tableNamesCache;\n     private final Cache<TableHandleCacheKey, Optional<JdbcTableHandle>> tableHandleCache;\n     private final Cache<ColumnsCacheKey, List<JdbcColumnHandle>> columnsCache;\n+    private final List<PropertyMetadata> sessionPropertiesProviders;\n \n     @Inject\n-    public CachingJdbcClient(@StatsCollecting JdbcClient delegate, BaseJdbcConfig config)\n+    public CachingJdbcClient(@StatsCollecting JdbcClient delegate, BaseJdbcConfig config, Set<SessionPropertiesProvider> sessionPropertiesProviders)\n     {\n-        this(delegate, config.getMetadataCacheTtl(), config.isCacheMissing());\n+        this(delegate, sessionPropertiesProviders, config.getMetadataCacheTtl(), config.isCacheMissing());\n     }\n \n-    public CachingJdbcClient(JdbcClient delegate, Duration metadataCachingTtl, boolean cacheMissing)\n+    public CachingJdbcClient(JdbcClient delegate, Set<SessionPropertiesProvider> sessionPropertiesProviders, Duration metadataCachingTtl, boolean cacheMissing)\n     {\n         this.delegate = requireNonNull(delegate, \"delegate is null\");\n+        this.sessionPropertiesProviders = requireNonNull(sessionPropertiesProviders, \"sessionPropertiesProviders is null\").stream()\n+            .flatMap(provider -> provider.getSessionProperties().stream())\n+            .collect(toImmutableList());\n+\n         this.cacheMissing = cacheMissing;\n \n         CacheBuilder<Object, Object> cacheBuilder = CacheBuilder.newBuilder()\n                 .expireAfterWrite(metadataCachingTtl.toMillis(), TimeUnit.MILLISECONDS);\n+\n+        if (metadataCachingTtl.equals(succinctNanos(0L))) {\n+            // Disables the cache entirely\n+            cacheBuilder.maximumSize(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NjY4MA==", "bodyText": "new TableHandleCacheKey(session, schemaTableName)? Same for others. Or TableHandleCacheKey.create(session, schemaTableName)", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533656680", "createdAt": "2020-12-01T19:11:23Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -182,7 +201,7 @@ public boolean isLimitGuaranteed(ConnectorSession session)\n     @Override\n     public Optional<JdbcTableHandle> getTableHandle(ConnectorSession session, SchemaTableName schemaTableName)\n     {\n-        TableHandleCacheKey key = new TableHandleCacheKey(JdbcIdentity.from(session), schemaTableName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1Njk3Mw==", "bodyText": "undo rename?", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533656973", "createdAt": "2020-12-01T19:11:54Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -96,8 +114,8 @@ public boolean schemaExists(ConnectorSession session, String schema)\n     @Override\n     public List<SchemaTableName> getTableNames(ConnectorSession session, Optional<String> schema)\n     {\n-        TableNamesCacheKey key = new TableNamesCacheKey(JdbcIdentity.from(session), schema);\n-        return get(tableNamesCache, key, () -> delegate.getTableNames(session, schema));\n+        TableNamesCacheKey cacheKey = buildTableNamesCacheKey(session, schema);\n+        return get(tableNamesCache, cacheKey, () -> delegate.getTableNames(session, schema));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1ODMwMg==", "bodyText": "what when key.schemaName.isEmpty()? How that can happen?", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533658302", "createdAt": "2020-12-01T19:14:21Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,39 +366,82 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    private ColumnsCacheKey buildColumnsCacheKey(ConnectorSession session, SchemaTableName tableName)\n+    {\n+        return new ColumnsCacheKey(JdbcIdentity.from(session), getSessionProperties(session), tableName);\n+    }\n+\n+    private TableHandleCacheKey buildTableHandleCacheKey(ConnectorSession session, SchemaTableName schemaTableName)\n+    {\n+        return new TableHandleCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schemaTableName);\n+    }\n+\n+    private TableNamesCacheKey buildTableNamesCacheKey(ConnectorSession session, Optional<String> schema)\n+    {\n+        return new TableNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schema);\n+    }\n+\n     private void invalidateSchemasCache()\n     {\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(SchemaTableName table)\n+    {\n+        invalidateColumnsCache(table);\n+        invalidateTableCache(table);\n+    }\n+\n+    private void invalidateTableCache(SchemaTableName table)\n+    {\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(table.getSchemaName())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1OTY3Nw==", "bodyText": "use io.prestosql.testing.sql.TestTable#randomTableSuffix", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533659677", "createdAt": "2020-12-01T19:16:44Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -166,15 +262,25 @@ private JdbcTableHandle getAnyTable(String schema)\n \n     private JdbcColumnHandle addColumn(JdbcTableHandle tableHandle)\n     {\n-        ColumnMetadata columnMetadata = new ColumnMetadata(\"phantom_column\", INTEGER);\n-        jdbcClient.addColumn(SESSION, tableHandle, columnMetadata);\n+        return addColumn(jdbcClient, tableHandle, \"phantom_colum\");\n+    }\n+\n+    private JdbcColumnHandle addColumn(JdbcClient client, JdbcTableHandle tableHandle, String columnName)\n+    {\n+        ColumnMetadata columnMetadata = new ColumnMetadata(columnName, INTEGER);\n+        client.addColumn(SESSION, tableHandle, columnMetadata);\n         return jdbcClient.getColumns(SESSION, tableHandle)\n                 .stream()\n                 .filter(jdbcColumnHandle -> jdbcColumnHandle.getColumnMetadata().equals(columnMetadata))\n                 .findAny()\n                 .orElseThrow();\n     }\n \n+    private static String randomTableName()\n+    {\n+        return \"phantom_table_\" + UUID.randomUUID().toString().replace(\"-\", \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2MTcxNw==", "bodyText": "createCachingJdbcClient(CACHE_MISSING, CACHE_ENABLED)? Does it make sense to have cache with cache missing enabled and entire cache disabled? Maybe you could have 3 dedicated methods instead of true, true paremeters? Or instead of cachingEnabled you can pass FOREVER or NEVER. Also we are missing tests for refreshes (REFRESH_AFTER_100_MS).", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533661717", "createdAt": "2020-12-01T19:20:09Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -49,14 +53,18 @@ public void setUp()\n             throws Exception\n     {\n         database = new TestingDatabase();\n-        cachingJdbcClient = createCachingJdbcClient(true);\n+        cachingJdbcClient = createCachingJdbcClient(true, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2NDQ3MA==", "bodyText": "Can you please have two sessions (two users) cache table for both users and then when table is dropped in Presto both caches got invalidated. Also you can have third user to verify that other table do not get invalidated (optional).\nSame goes to other tests like that.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533664470", "createdAt": "2020-12-01T19:24:41Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -105,10 +127,84 @@ public void testTableHandleCached()\n         assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEqualTo(cachedTable);\n     }\n \n+    @Test\n+    public void shouldInvalidateTableCachesOnTableDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2NjM4OQ==", "bodyText": "Can you please add tests for drop and create for table and schema.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533666389", "createdAt": "2020-12-01T19:27:56Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -105,10 +127,84 @@ public void testTableHandleCached()\n         assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEqualTo(cachedTable);\n     }\n \n+    @Test\n+    public void shouldInvalidateTableCachesOnTableDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        cachingJdbcClient.dropTable(SESSION, tableHandle);\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+    }\n+\n+    @Test\n+    public void shouldInvalidateTableCachesOnColumnDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        JdbcColumnHandle otherColumn = addColumn(cachingJdbcClient, tableHandle, \"other_column\");\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactlyInAnyOrder(phantomColumn, otherColumn);\n+\n+        cachingJdbcClient.dropColumn(SESSION, tableHandle, phantomColumn);\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(otherColumn);\n+\n+        dropTable(phantomTable);\n+    }\n+\n+    @Test\n+    public void shouldInvalidateTableCachesOnColumnRename()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        cachingJdbcClient.renameColumn(SESSION, tableHandle, phantomColumn, \"new_column_name\");\n+\n+        JdbcColumnHandle newColumnHandle = JdbcColumnHandle.builderFrom(phantomColumn)\n+                .setColumnName(\"NEW_COLUMN_NAME\")\n+                .build();\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(newColumnHandle);\n+\n+        dropTable(phantomTable);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2Nzc0NQ==", "bodyText": "Actually, I don't know why why are invalidating here.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533667745", "createdAt": "2020-12-01T19:30:11Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -212,14 +231,14 @@ public JdbcOutputTableHandle beginInsertTable(ConnectorSession session, JdbcTabl\n     public void finishInsertTable(ConnectorSession session, JdbcOutputTableHandle handle)\n     {\n         delegate.finishInsertTable(session, handle);\n-        invalidateTablesCaches();\n+        invalidateTablesCaches(toTableHandle(handle));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2OTU2Nw==", "bodyText": "You also need to handle session properties for schemaNamesCache and tableNamesCache.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533669567", "createdAt": "2020-12-01T19:33:17Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -59,20 +66,31 @@\n     private final Cache<TableNamesCacheKey, List<SchemaTableName>> tableNamesCache;\n     private final Cache<TableHandleCacheKey, Optional<JdbcTableHandle>> tableHandleCache;\n     private final Cache<ColumnsCacheKey, List<JdbcColumnHandle>> columnsCache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMjY4MTcx", "url": "https://github.com/trinodb/trino/pull/6167#pullrequestreview-542268171", "createdAt": "2020-12-01T20:26:22Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMDoyNjoyMlrOH8-b8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMDoyOTo1NFrOH8-jkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5OTU3MQ==", "bodyText": "Can it be private?", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533699571", "createdAt": "2020-12-01T20:26:22Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,39 +366,82 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    private ColumnsCacheKey buildColumnsCacheKey(ConnectorSession session, SchemaTableName tableName)\n+    {\n+        return new ColumnsCacheKey(JdbcIdentity.from(session), getSessionProperties(session), tableName);\n+    }\n+\n+    private TableHandleCacheKey buildTableHandleCacheKey(ConnectorSession session, SchemaTableName schemaTableName)\n+    {\n+        return new TableHandleCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schemaTableName);\n+    }\n+\n+    private TableNamesCacheKey buildTableNamesCacheKey(ConnectorSession session, Optional<String> schema)\n+    {\n+        return new TableNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schema);\n+    }\n+\n     private void invalidateSchemasCache()\n     {\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(SchemaTableName table)\n+    {\n+        invalidateColumnsCache(table);\n+        invalidateTableCache(table);\n+    }\n+\n+    private void invalidateTableCache(SchemaTableName table)\n+    {\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, key -> key.tableName.equals(table));\n+    }\n+\n+    private void invalidateColumnsCache(SchemaTableName table)\n+    {\n+        invalidateCache(columnsCache, key -> key.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        return sessionPropertiesProviders.stream()\n+                .map(property -> getSessionProperty(session, property))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    private static Map.Entry<String, Object> getSessionProperty(ConnectorSession session, PropertyMetadata property)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        return Map.entry(property.getName(), session.getProperty(property.getName(), property.getJavaType()));\n     }\n \n-    private static final class ColumnsCacheKey\n+    private static <T, V> void invalidateCache(Cache<T, V> cache, Predicate<T> filterFunction)\n+    {\n+        Set<T> cacheKeys = ImmutableMap.copyOf(cache.asMap()).keySet().stream()\n+                .filter(filterFunction)\n+                .collect(toImmutableSet());\n+\n+        cache.invalidateAll(cacheKeys);\n+    }\n+\n+    private static SchemaTableName toTableHandle(JdbcOutputTableHandle handle)\n+    {\n+        return new SchemaTableName(handle.getSchemaName(), handle.getTableName());\n+    }\n+\n+    static final class ColumnsCacheKey", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcwMTUyMg==", "bodyText": "#6167 (comment)", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533701522", "createdAt": "2020-12-01T20:29:54Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,39 +366,82 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    private ColumnsCacheKey buildColumnsCacheKey(ConnectorSession session, SchemaTableName tableName)\n+    {\n+        return new ColumnsCacheKey(JdbcIdentity.from(session), getSessionProperties(session), tableName);\n+    }\n+\n+    private TableHandleCacheKey buildTableHandleCacheKey(ConnectorSession session, SchemaTableName schemaTableName)\n+    {\n+        return new TableHandleCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schemaTableName);\n+    }\n+\n+    private TableNamesCacheKey buildTableNamesCacheKey(ConnectorSession session, Optional<String> schema)\n+    {\n+        return new TableNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schema);\n+    }\n+\n     private void invalidateSchemasCache()\n     {\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(SchemaTableName table)\n+    {\n+        invalidateColumnsCache(table);\n+        invalidateTableCache(table);\n+    }\n+\n+    private void invalidateTableCache(SchemaTableName table)\n+    {\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, key -> key.tableName.equals(table));\n+    }\n+\n+    private void invalidateColumnsCache(SchemaTableName table)\n+    {\n+        invalidateCache(columnsCache, key -> key.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        return sessionPropertiesProviders.stream()\n+                .map(property -> getSessionProperty(session, property))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    private static Map.Entry<String, Object> getSessionProperty(ConnectorSession session, PropertyMetadata property)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        return Map.entry(property.getName(), session.getProperty(property.getName(), property.getJavaType()));\n     }\n \n-    private static final class ColumnsCacheKey\n+    private static <T, V> void invalidateCache(Cache<T, V> cache, Predicate<T> filterFunction)\n+    {\n+        Set<T> cacheKeys = ImmutableMap.copyOf(cache.asMap()).keySet().stream()\n+                .filter(filterFunction)\n+                .collect(toImmutableSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 237}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyNjA1NDEz", "url": "https://github.com/trinodb/trino/pull/6167#pullrequestreview-542605413", "createdAt": "2020-12-02T08:42:53Z", "commit": null, "state": "DISMISSED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwODo0Mjo1M1rOH9P-vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwODo1MjoxMlrOH9QVJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4NzAwNg==", "bodyText": "this should be metadataCachingTtl.toMillis() == 0, since cache is configured with 1 ms precision\nextract common variable to emphasize this must be the same thing", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533987006", "createdAt": "2020-12-02T08:42:53Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -55,24 +62,35 @@\n     private final JdbcClient delegate;\n     private final boolean cacheMissing;\n \n-    private final Cache<JdbcIdentity, Set<String>> schemaNamesCache;\n+    private final Cache<SchemaNamesCacheKey, Set<String>> schemaNamesCache;\n     private final Cache<TableNamesCacheKey, List<SchemaTableName>> tableNamesCache;\n     private final Cache<TableHandleCacheKey, Optional<JdbcTableHandle>> tableHandleCache;\n     private final Cache<ColumnsCacheKey, List<JdbcColumnHandle>> columnsCache;\n+    private final List<PropertyMetadata> sessionPropertiesProviders;\n \n     @Inject\n-    public CachingJdbcClient(@StatsCollecting JdbcClient delegate, BaseJdbcConfig config)\n+    public CachingJdbcClient(@StatsCollecting JdbcClient delegate, BaseJdbcConfig config, Set<SessionPropertiesProvider> sessionPropertiesProviders)\n     {\n-        this(delegate, config.getMetadataCacheTtl(), config.isCacheMissing());\n+        this(delegate, sessionPropertiesProviders, config.getMetadataCacheTtl(), config.isCacheMissing());\n     }\n \n-    public CachingJdbcClient(JdbcClient delegate, Duration metadataCachingTtl, boolean cacheMissing)\n+    public CachingJdbcClient(JdbcClient delegate, Set<SessionPropertiesProvider> sessionPropertiesProviders, Duration metadataCachingTtl, boolean cacheMissing)\n     {\n         this.delegate = requireNonNull(delegate, \"delegate is null\");\n+        this.sessionPropertiesProviders = requireNonNull(sessionPropertiesProviders, \"sessionPropertiesProviders is null\").stream()\n+            .flatMap(provider -> provider.getSessionProperties().stream())\n+            .collect(toImmutableList());\n+\n         this.cacheMissing = cacheMissing;\n \n         CacheBuilder<Object, Object> cacheBuilder = CacheBuilder.newBuilder()\n                 .expireAfterWrite(metadataCachingTtl.toMillis(), TimeUnit.MILLISECONDS);\n+\n+        if (metadataCachingTtl.equals(succinctNanos(0L))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4NzU5MQ==", "bodyText": "This seems redundant. I think we can skip session props here for now.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533987591", "createdAt": "2020-12-02T08:43:53Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -89,14 +107,14 @@ public boolean schemaExists(ConnectorSession session, String schema)\n     @Override\n     public Set<String> getSchemaNames(ConnectorSession session)\n     {\n-        JdbcIdentity key = JdbcIdentity.from(session);\n+        SchemaNamesCacheKey key = new SchemaNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session));\n         return get(schemaNamesCache, key, () -> delegate.getSchemaNames(session));\n     }\n \n     @Override\n     public List<SchemaTableName> getTableNames(ConnectorSession session, Optional<String> schema)\n     {\n-        TableNamesCacheKey key = new TableNamesCacheKey(JdbcIdentity.from(session), schema);\n+        TableNamesCacheKey key = new TableNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schema);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4NzY2NQ==", "bodyText": "This seems redundant. I think we can skip session props here for now.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533987665", "createdAt": "2020-12-02T08:44:01Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -89,14 +107,14 @@ public boolean schemaExists(ConnectorSession session, String schema)\n     @Override\n     public Set<String> getSchemaNames(ConnectorSession session)\n     {\n-        JdbcIdentity key = JdbcIdentity.from(session);\n+        SchemaNamesCacheKey key = new SchemaNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4ODI3OA==", "bodyText": "I believe this is redundant, but we should do 00d7b7b instead\n(\"Add safeguards in table handles cache in JDBC\")", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533988278", "createdAt": "2020-12-02T08:45:02Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -182,7 +201,7 @@ public boolean isLimitGuaranteed(ConnectorSession session)\n     @Override\n     public Optional<JdbcTableHandle> getTableHandle(ConnectorSession session, SchemaTableName schemaTableName)\n     {\n-        TableHandleCacheKey key = new TableHandleCacheKey(JdbcIdentity.from(session), schemaTableName);\n+        TableHandleCacheKey key = new TableHandleCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schemaTableName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4OTExMg==", "bodyText": "This should be separate commit, as this does not \"fix cache invalidation\" -- the invalidation here was correct.\nIn fact, I think this is an unnecessary complexity and i would rather not have this change.\n(same for other table/schema level invalidations)", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533989112", "createdAt": "2020-12-02T08:46:16Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -199,7 +218,7 @@ public boolean isLimitGuaranteed(ConnectorSession session)\n     public void commitCreateTable(ConnectorSession session, JdbcOutputTableHandle handle)\n     {\n         delegate.commitCreateTable(session, handle);\n-        invalidateTablesCaches();\n+        invalidateTablesCaches(toTableHandle(handle));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4OTc0MA==", "bodyText": "Can session property have a null value?", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533989740", "createdAt": "2020-12-02T08:47:20Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -351,34 +370,67 @@ private void invalidateSchemasCache()\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateColumnsCache(table);\n+        invalidateTableCache(table);\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    private void invalidateTableCache(SchemaTableName table)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, key -> key.tableName.equals(table));\n+    }\n+\n+    private void invalidateColumnsCache(SchemaTableName table)\n+    {\n+        invalidateCache(columnsCache, key -> key.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionPropertiesProviders.stream()\n+                .flatMap(property -> getSessionProperty(session, property))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4OTk0OA==", "bodyText": "Why?", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533989948", "createdAt": "2020-12-02T08:47:39Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -351,34 +370,67 @@ private void invalidateSchemasCache()\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateColumnsCache(table);\n+        invalidateTableCache(table);\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    private void invalidateTableCache(SchemaTableName table)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, key -> key.tableName.equals(table));\n+    }\n+\n+    private void invalidateColumnsCache(SchemaTableName table)\n+    {\n+        invalidateCache(columnsCache, key -> key.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionPropertiesProviders.stream()\n+                .flatMap(property -> getSessionProperty(session, property))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private static Stream<Map.Entry<String, Object>> getSessionProperty(ConnectorSession session, PropertyMetadata property)\n+    {\n+        try {\n+            return Stream.of(Map.entry(property.getName(), session.getProperty(property.getName(), property.getJavaType())));\n+        }\n+        catch (PrestoException ignored) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk5MDA0MA==", "bodyText": "Just make this return Object", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533990040", "createdAt": "2020-12-02T08:47:50Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -351,34 +370,67 @@ private void invalidateSchemasCache()\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateColumnsCache(table);\n+        invalidateTableCache(table);\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    private void invalidateTableCache(SchemaTableName table)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, key -> key.tableName.equals(table));\n+    }\n+\n+    private void invalidateColumnsCache(SchemaTableName table)\n+    {\n+        invalidateCache(columnsCache, key -> key.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionPropertiesProviders.stream()\n+                .flatMap(property -> getSessionProperty(session, property))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private static Stream<Map.Entry<String, Object>> getSessionProperty(ConnectorSession session, PropertyMetadata property)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk5MDY1OQ==", "bodyText": "revert \"protected\", the class is final", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533990659", "createdAt": "2020-12-02T08:48:50Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -351,34 +370,67 @@ private void invalidateSchemasCache()\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateColumnsCache(table);\n+        invalidateTableCache(table);\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    private void invalidateTableCache(SchemaTableName table)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, key -> key.tableName.equals(table));\n+    }\n+\n+    private void invalidateColumnsCache(SchemaTableName table)\n+    {\n+        invalidateCache(columnsCache, key -> key.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionPropertiesProviders.stream()\n+                .flatMap(property -> getSessionProperty(session, property))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private static Stream<Map.Entry<String, Object>> getSessionProperty(ConnectorSession session, PropertyMetadata property)\n+    {\n+        try {\n+            return Stream.of(Map.entry(property.getName(), session.getProperty(property.getName(), property.getJavaType())));\n+        }\n+        catch (PrestoException ignored) {\n+            return Stream.empty();\n+        }\n+    }\n+\n+    private static <T, V> void invalidateCache(Cache<T, V> cache, Predicate<T> filterFunction)\n+    {\n+        Set<T> cacheKeys = cache.asMap().keySet().stream()\n+                .filter(filterFunction)\n+                .collect(toImmutableSet());\n+\n+        cache.invalidateAll(cacheKeys);\n+    }\n+\n+    private static SchemaTableName toTableHandle(JdbcOutputTableHandle handle)\n+    {\n+        return new SchemaTableName(handle.getSchemaName(), handle.getTableName());\n     }\n \n     private static final class ColumnsCacheKey\n     {\n         private final JdbcIdentity identity;\n+        private final Map<String, Object> sessionProperties;\n         private final SchemaTableName table;\n \n-        private ColumnsCacheKey(JdbcIdentity identity, SchemaTableName table)\n+        protected ColumnsCacheKey(JdbcIdentity identity, Map<String, Object> sessionProperties, SchemaTableName table)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk5MDg2Mw==", "bodyText": "make defensive copy to ensure class immutability\n(same for others)", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533990863", "createdAt": "2020-12-02T08:49:08Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -351,34 +370,67 @@ private void invalidateSchemasCache()\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateColumnsCache(table);\n+        invalidateTableCache(table);\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    private void invalidateTableCache(SchemaTableName table)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, key -> key.tableName.equals(table));\n+    }\n+\n+    private void invalidateColumnsCache(SchemaTableName table)\n+    {\n+        invalidateCache(columnsCache, key -> key.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionPropertiesProviders.stream()\n+                .flatMap(property -> getSessionProperty(session, property))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private static Stream<Map.Entry<String, Object>> getSessionProperty(ConnectorSession session, PropertyMetadata property)\n+    {\n+        try {\n+            return Stream.of(Map.entry(property.getName(), session.getProperty(property.getName(), property.getJavaType())));\n+        }\n+        catch (PrestoException ignored) {\n+            return Stream.empty();\n+        }\n+    }\n+\n+    private static <T, V> void invalidateCache(Cache<T, V> cache, Predicate<T> filterFunction)\n+    {\n+        Set<T> cacheKeys = cache.asMap().keySet().stream()\n+                .filter(filterFunction)\n+                .collect(toImmutableSet());\n+\n+        cache.invalidateAll(cacheKeys);\n+    }\n+\n+    private static SchemaTableName toTableHandle(JdbcOutputTableHandle handle)\n+    {\n+        return new SchemaTableName(handle.getSchemaName(), handle.getTableName());\n     }\n \n     private static final class ColumnsCacheKey\n     {\n         private final JdbcIdentity identity;\n+        private final Map<String, Object> sessionProperties;\n         private final SchemaTableName table;\n \n-        private ColumnsCacheKey(JdbcIdentity identity, SchemaTableName table)\n+        protected ColumnsCacheKey(JdbcIdentity identity, Map<String, Object> sessionProperties, SchemaTableName table)\n         {\n             this.identity = requireNonNull(identity, \"identity is null\");\n+            this.sessionProperties = requireNonNull(sessionProperties, \"sessionProperties is null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk5MjI2NA==", "bodyText": "i believe JDBC connectors do not support transactions, so \"transaction\" is actually per query cache.\nAs such, there is no way to change session properties during a transaction, so you can avoid overheader and pass empty set here (with appropriate explanatory comment in the code)", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533992264", "createdAt": "2020-12-02T08:51:23Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/TransactionCachingJdbcClient.java", "diffHunk": "@@ -31,9 +32,9 @@\n {\n     private final Cache<TableStatisticsCacheKey, TableStatistics> statisticsCache;\n \n-    public TransactionCachingJdbcClient(JdbcClient delegate, Duration cachingTtl)\n+    public TransactionCachingJdbcClient(JdbcClient delegate, Set<SessionPropertiesProvider> sessionPropertiesProviders, Duration cachingTtl)\n     {\n-        super(delegate, cachingTtl, true);\n+        super(delegate, sessionPropertiesProviders, cachingTtl, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk5Mjc0Mg==", "bodyText": "ZERO", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533992742", "createdAt": "2020-12-02T08:52:12Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -15,48 +15,72 @@\n \n import com.google.common.collect.ImmutableSet;\n import io.airlift.units.Duration;\n+import io.prestosql.plugin.jdbc.jmx.JdbcApiStats;\n+import io.prestosql.plugin.jdbc.jmx.JdbcClientStats;\n+import io.prestosql.plugin.jdbc.jmx.StatisticsAwareJdbcClient;\n import io.prestosql.spi.connector.ColumnMetadata;\n import io.prestosql.spi.connector.ConnectorSession;\n import io.prestosql.spi.connector.ConnectorTableMetadata;\n import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableNotFoundException;\n import org.testng.annotations.AfterMethod;\n import org.testng.annotations.BeforeMethod;\n import org.testng.annotations.Test;\n \n import java.lang.reflect.Method;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n \n import static io.prestosql.spi.testing.InterfaceTestUtils.assertAllMethodsOverridden;\n import static io.prestosql.spi.type.IntegerType.INTEGER;\n import static io.prestosql.testing.TestingConnectorSession.SESSION;\n+import static io.prestosql.testing.sql.TestTable.randomTableSuffix;\n import static java.util.Collections.emptyList;\n import static java.util.concurrent.TimeUnit.DAYS;\n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n \n @Test(singleThreaded = true)\n public class TestCachingJdbcClient\n {\n     private static final Duration FOREVER = Duration.succinctDuration(1, DAYS);\n+    private static final Duration NEVER = Duration.succinctDuration(0, DAYS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NzkzMDM1", "url": "https://github.com/trinodb/trino/pull/6167#pullrequestreview-544793035", "createdAt": "2020-12-04T09:33:54Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOTozMzo1NFrOH_IeWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOTozNToyMFrOH_IiPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2MTE3Nw==", "bodyText": "I don't want to uncover this in few months, that this was implemented only for certain places.\nI don't want to remember about this corner case.\nI don't know all custom connectors that are out there.\n\nAssuming  eb3fc50#r534067384, we should not be worried. Notice that we cache only operations that could take much longer.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r535961177", "createdAt": "2020-12-04T09:33:54Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -89,14 +107,14 @@ public boolean schemaExists(ConnectorSession session, String schema)\n     @Override\n     public Set<String> getSchemaNames(ConnectorSession session)\n     {\n-        JdbcIdentity key = JdbcIdentity.from(session);\n+        SchemaNamesCacheKey key = new SchemaNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4NzY2NQ=="}, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2MjE3NQ==", "bodyText": "It is not only about overhead, but also about correctness. In case there is a bug in caching we don't have a kill switch as we always do \"caching\". However this could go as a separate PR (or postponed until the moment we learn it is an issue).", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r535962175", "createdAt": "2020-12-04T09:35:20Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -59,20 +66,31 @@\n     private final Cache<TableNamesCacheKey, List<SchemaTableName>> tableNamesCache;\n     private final Cache<TableHandleCacheKey, Optional<JdbcTableHandle>> tableHandleCache;\n     private final Cache<ColumnsCacheKey, List<JdbcColumnHandle>> columnsCache;\n+    private final List<PropertyMetadata> sessionPropertiesProviders;\n \n     @Inject\n-    public CachingJdbcClient(@StatsCollecting JdbcClient delegate, BaseJdbcConfig config)\n+    public CachingJdbcClient(@StatsCollecting JdbcClient delegate, BaseJdbcConfig config, Set<SessionPropertiesProvider> sessionPropertiesProviders)\n     {\n-        this(delegate, config.getMetadataCacheTtl(), config.isCacheMissing());\n+        this(delegate, sessionPropertiesProviders, config.getMetadataCacheTtl(), config.isCacheMissing());\n     }\n \n-    public CachingJdbcClient(JdbcClient delegate, Duration metadataCachingTtl, boolean cacheMissing)\n+    public CachingJdbcClient(JdbcClient delegate, Set<SessionPropertiesProvider> sessionPropertiesProviders, Duration metadataCachingTtl, boolean cacheMissing)\n     {\n         this.delegate = requireNonNull(delegate, \"delegate is null\");\n+        this.sessionPropertiesProviders = requireNonNull(sessionPropertiesProviders, \"sessionPropertiesProviders is null\").stream()\n+            .flatMap(provider -> provider.getSessionProperties().stream())\n+            .collect(toImmutableList());\n+\n         this.cacheMissing = cacheMissing;\n \n         CacheBuilder<Object, Object> cacheBuilder = CacheBuilder.newBuilder()\n                 .expireAfterWrite(metadataCachingTtl.toMillis(), TimeUnit.MILLISECONDS);\n+\n+        if (metadataCachingTtl.equals(succinctNanos(0L))) {\n+            // Disables the cache entirely\n+            cacheBuilder.maximumSize(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NDUzMQ=="}, "originalCommit": null, "originalPosition": 59}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0OTY1OTgw", "url": "https://github.com/trinodb/trino/pull/6167#pullrequestreview-544965980", "createdAt": "2020-12-04T13:40:00Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMzo0MDowMFrOH_RVFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMzo1MToyMFrOH_Rw1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEwNjI2Mg==", "bodyText": "This field is not used in this commit, so I would squash this commit with the commit that uses that.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536106262", "createdAt": "2020-12-04T13:40:00Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -59,16 +61,21 @@\n     private final Cache<TableNamesCacheKey, List<SchemaTableName>> tableNamesCache;\n     private final Cache<TableHandleCacheKey, Optional<JdbcTableHandle>> tableHandleCache;\n     private final Cache<ColumnsCacheKey, List<JdbcColumnHandle>> columnsCache;\n+    private final List<PropertyMetadata<?>> sessionProperties;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEwODEzNg==", "bodyText": "comment is not needed", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536108136", "createdAt": "2020-12-04T13:42:59Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -365,19 +390,30 @@ private void invalidateTablesCaches()\n         tableNamesCache.invalidateAll();\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    private void invalidateColumnsCache(SchemaTableName table)\n+    {\n+        // Invalidate all caches independently of session", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExMDI3OQ==", "bodyText": "Maybe you can add a method JdbcOutputTableHandle#getSchemaTableName()", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536110279", "createdAt": "2020-12-04T13:46:28Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -401,9 +402,15 @@ private void invalidateColumnsCache(SchemaTableName table)\n         Set<T> cacheKeys = cache.asMap().keySet().stream()\n                 .filter(filterFunction)\n                 .collect(toImmutableSet());\n+\n         cache.invalidateAll(cacheKeys);\n     }\n \n+    private static SchemaTableName toJdbcTableHandle(JdbcOutputTableHandle handle)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExMDg0NA==", "bodyText": "I would squash that with the commit that is using this.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536110844", "createdAt": "2020-12-04T13:47:21Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -397,6 +401,12 @@ private void invalidateColumnsCache(SchemaTableName table)\n         invalidateCache(columnsCache, key -> key.table.equals(table));\n     }\n \n+    @VisibleForTesting\n+    CacheStats getColumnsCacheStats()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExMTc5MQ==", "bodyText": "Is there a case where miss != load?", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536111791", "createdAt": "2020-12-04T13:48:54Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -150,8 +166,93 @@ public void testColumnsCached()\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n         jdbcClient.dropColumn(SESSION, table, phantomColumn);\n \n+        // Load column into cache\n         assertThat(jdbcClient.getColumns(SESSION, table)).doesNotContain(phantomColumn);\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 1, 1);\n+\n+        // Read column from cache\n+        assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 2, 1);\n+    }\n+\n+    @Test\n+    public void testColumnsCachedBySession()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle table = getAnyTable(schema);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(table);\n+\n+        // Load columns in first session scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 0, 1);\n+\n+        // Load columns in second session scope\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 2, 0, 2);\n+\n+        // Drop first column and invalidate cache for all sessions\n+        cachingJdbcClient.dropColumn(firstSession, table, phantomColumn);\n+        assertThat(jdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+\n+        // Load columns into cache in both sessions scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).doesNotContain(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 0, 4);\n+\n+        // Read columns from cache\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).doesNotContain(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 2, 4);\n+    }\n+\n+    @Test\n+    public void testColumnsCacheInvalidationOnTableDrop()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle firstTable = createTable(new SchemaTableName(schema, \"first_table\"));\n+        JdbcTableHandle secondTable = createTable(new SchemaTableName(schema, \"second_table\"));\n+\n+        JdbcColumnHandle firstColumn = addColumn(firstTable, \"first_column\");\n+        JdbcColumnHandle secondColumn = addColumn(secondTable, \"second_column\");\n+\n+        // Load columns for both tables into cache and assert cache loads (sessions x tables)\n+        assertThat(cachingJdbcClient.getColumns(firstSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(firstSession, secondTable)).contains(secondColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 0, 4);\n+\n+        // Load columns from cache\n+        assertThat(cachingJdbcClient.getColumns(firstSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 2, 4);\n+\n+        // Drop columns and caches for first table\n+        cachingJdbcClient.dropTable(secondSession, firstTable);\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(firstSession, firstTable)).isInstanceOf(TableNotFoundException.class);\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(secondSession, firstTable)).isInstanceOf(TableNotFoundException.class);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 6, 2, 6);\n+\n+        // Check if second table is still cached\n+        assertThat(cachingJdbcClient.getColumns(firstSession, secondTable)).contains(secondColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 6, 4, 6);\n+\n+        cachingJdbcClient.dropTable(secondSession, secondTable);\n+    }\n+\n+    private void assertCacheLoadsHitsAndMisses(CacheStats stats, int expectedLoad, int expectedHit, int expectedMiss)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExMjczMQ==", "bodyText": "test also rename and column add (it could be in the same test)", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536112731", "createdAt": "2020-12-04T13:50:21Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -150,8 +166,93 @@ public void testColumnsCached()\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n         jdbcClient.dropColumn(SESSION, table, phantomColumn);\n \n+        // Load column into cache\n         assertThat(jdbcClient.getColumns(SESSION, table)).doesNotContain(phantomColumn);\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 1, 1);\n+\n+        // Read column from cache\n+        assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 2, 1);\n+    }\n+\n+    @Test\n+    public void testColumnsCachedBySession()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle table = getAnyTable(schema);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(table);\n+\n+        // Load columns in first session scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 0, 1);\n+\n+        // Load columns in second session scope\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 2, 0, 2);\n+\n+        // Drop first column and invalidate cache for all sessions\n+        cachingJdbcClient.dropColumn(firstSession, table, phantomColumn);\n+        assertThat(jdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+\n+        // Load columns into cache in both sessions scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).doesNotContain(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 0, 4);\n+\n+        // Read columns from cache\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).doesNotContain(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 2, 4);\n+    }\n+\n+    @Test\n+    public void testColumnsCacheInvalidationOnTableDrop()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle firstTable = createTable(new SchemaTableName(schema, \"first_table\"));\n+        JdbcTableHandle secondTable = createTable(new SchemaTableName(schema, \"second_table\"));\n+\n+        JdbcColumnHandle firstColumn = addColumn(firstTable, \"first_column\");\n+        JdbcColumnHandle secondColumn = addColumn(secondTable, \"second_column\");\n+\n+        // Load columns for both tables into cache and assert cache loads (sessions x tables)\n+        assertThat(cachingJdbcClient.getColumns(firstSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(firstSession, secondTable)).contains(secondColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 0, 4);\n+\n+        // Load columns from cache\n+        assertThat(cachingJdbcClient.getColumns(firstSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 2, 4);\n+\n+        // Drop columns and caches for first table", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExMzM2NQ==", "bodyText": "What about two concurrent load for the same key? Is this synchronized?", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536113365", "createdAt": "2020-12-04T13:51:20Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -59,20 +66,31 @@\n     private final Cache<TableNamesCacheKey, List<SchemaTableName>> tableNamesCache;\n     private final Cache<TableHandleCacheKey, Optional<JdbcTableHandle>> tableHandleCache;\n     private final Cache<ColumnsCacheKey, List<JdbcColumnHandle>> columnsCache;\n+    private final List<PropertyMetadata> sessionPropertiesProviders;\n \n     @Inject\n-    public CachingJdbcClient(@StatsCollecting JdbcClient delegate, BaseJdbcConfig config)\n+    public CachingJdbcClient(@StatsCollecting JdbcClient delegate, BaseJdbcConfig config, Set<SessionPropertiesProvider> sessionPropertiesProviders)\n     {\n-        this(delegate, config.getMetadataCacheTtl(), config.isCacheMissing());\n+        this(delegate, sessionPropertiesProviders, config.getMetadataCacheTtl(), config.isCacheMissing());\n     }\n \n-    public CachingJdbcClient(JdbcClient delegate, Duration metadataCachingTtl, boolean cacheMissing)\n+    public CachingJdbcClient(JdbcClient delegate, Set<SessionPropertiesProvider> sessionPropertiesProviders, Duration metadataCachingTtl, boolean cacheMissing)\n     {\n         this.delegate = requireNonNull(delegate, \"delegate is null\");\n+        this.sessionPropertiesProviders = requireNonNull(sessionPropertiesProviders, \"sessionPropertiesProviders is null\").stream()\n+            .flatMap(provider -> provider.getSessionProperties().stream())\n+            .collect(toImmutableList());\n+\n         this.cacheMissing = cacheMissing;\n \n         CacheBuilder<Object, Object> cacheBuilder = CacheBuilder.newBuilder()\n                 .expireAfterWrite(metadataCachingTtl.toMillis(), TimeUnit.MILLISECONDS);\n+\n+        if (metadataCachingTtl.equals(succinctNanos(0L))) {\n+            // Disables the cache entirely\n+            cacheBuilder.maximumSize(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NDUzMQ=="}, "originalCommit": null, "originalPosition": 59}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MjE2Nzg2", "url": "https://github.com/trinodb/trino/pull/6167#pullrequestreview-545216786", "createdAt": "2020-12-04T18:55:07Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxODo1NTowN1rOH_dwyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOTowMDowN1rOH_d8Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMwOTk2Mg==", "bodyText": "It is fixed, already. See NULL_MARKER", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536309962", "createdAt": "2020-12-04T18:55:07Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -351,34 +370,67 @@ private void invalidateSchemasCache()\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateColumnsCache(table);\n+        invalidateTableCache(table);\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    private void invalidateTableCache(SchemaTableName table)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, key -> key.tableName.equals(table));\n+    }\n+\n+    private void invalidateColumnsCache(SchemaTableName table)\n+    {\n+        invalidateCache(columnsCache, key -> key.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionPropertiesProviders.stream()\n+                .flatMap(property -> getSessionProperty(session, property))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4OTc0MA=="}, "originalCommit": null, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMxMjE5MQ==", "bodyText": "no comment is needed", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536312191", "createdAt": "2020-12-04T18:58:55Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -212,7 +212,9 @@ public boolean isLimitGuaranteed(ConnectorSession session)\n     public void commitCreateTable(ConnectorSession session, JdbcOutputTableHandle handle)\n     {\n         delegate.commitCreateTable(session, handle);\n-        invalidateTablesCaches();\n+\n+        // Invalidate cache for table as it could be cached as missing", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMxMjQxMg==", "bodyText": "I don't see a value in these comments.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536312412", "createdAt": "2020-12-04T18:59:21Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -313,14 +314,19 @@ public void renameColumn(ConnectorSession session, JdbcTableHandle handle, JdbcC\n     public void renameTable(ConnectorSession session, JdbcTableHandle handle, SchemaTableName newTableName)\n     {\n         delegate.renameTable(session, handle, newTableName);\n-        invalidateTablesCaches();\n+\n+        // Remove cache for old table name\n+        invalidateTableCaches(handle.getSchemaTableName());\n+\n+        // We need to remove cache for newTableName as it could be cached as missing", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMxMjg1NQ==", "bodyText": "This one line could go as separate commit. It is easy to not notice this, in this commit. It is logically different change at least to me. WDYT?", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536312855", "createdAt": "2020-12-04T19:00:07Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -225,14 +227,13 @@ public JdbcOutputTableHandle beginInsertTable(ConnectorSession session, JdbcTabl\n     public void finishInsertTable(ConnectorSession session, JdbcOutputTableHandle handle)\n     {\n         delegate.finishInsertTable(session, handle);\n-        invalidateTablesCaches();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1OTQ3OTQz", "url": "https://github.com/trinodb/trino/pull/6167#pullrequestreview-545947943", "createdAt": "2020-12-07T09:05:37Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwOTowNTozN1rOIAchew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwOTo0MDozNlrOIAd9iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzMzODIzNQ==", "bodyText": "nit: maybe oneliner with Optional.of().orElse()?", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537338235", "createdAt": "2020-12-07T09:05:37Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,6 +359,25 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionProperties.stream()\n+                .map(property -> Map.entry(property.getName(), getSessionProperty(session, property)))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private static Object getSessionProperty(ConnectorSession session, PropertyMetadata property)\n+    {\n+        Object value = session.getProperty(property.getName(), property.getJavaType());\n+\n+        // Map.entry doesn't allow null keys and values\n+        if (value == null) {\n+            value = NULL_MARKER;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzMzOTQ4Nw==", "bodyText": "nit: it always used as NULL_PROPERTY", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537339487", "createdAt": "2020-12-07T09:07:36Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -47,28 +50,38 @@\n \n import static com.google.common.base.MoreObjects.toStringHelper;\n import static com.google.common.base.Throwables.throwIfInstanceOf;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n import static java.util.Objects.requireNonNull;\n \n public class CachingJdbcClient\n         implements JdbcClient\n {\n+    private static final Object NULL_MARKER = new Object();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM0NDA4NQ==", "bodyText": "nit: static import", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537344085", "createdAt": "2020-12-07T09:14:43Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -85,7 +87,9 @@ public CachingJdbcClient(JdbcClient delegate, Set<SessionPropertiesProvider> ses\n         this.cacheMissing = cacheMissing;\n \n         CacheBuilder<Object, Object> cacheBuilder = CacheBuilder.newBuilder()\n-                .expireAfterWrite(metadataCachingTtl.toMillis(), TimeUnit.MILLISECONDS);\n+                .expireAfterWrite(metadataCachingTtl.toMillis(), TimeUnit.MILLISECONDS)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM1NDUwMA==", "bodyText": "testColumnsCachedPerSession ?", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537354500", "createdAt": "2020-12-07T09:30:00Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -150,8 +170,100 @@ public void testColumnsCached()\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n         jdbcClient.dropColumn(SESSION, table, phantomColumn);\n \n+        // Load column into cache\n         assertThat(jdbcClient.getColumns(SESSION, table)).doesNotContain(phantomColumn);\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 1, 1);\n+\n+        // Read column from cache\n+        assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 2, 1);\n+    }\n+\n+    @Test\n+    public void testColumnsCachedBySession()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM1NTYzOA==", "bodyText": "maybe add check here that something is cached before invalidation?", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537355638", "createdAt": "2020-12-07T09:31:43Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -150,8 +170,100 @@ public void testColumnsCached()\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n         jdbcClient.dropColumn(SESSION, table, phantomColumn);\n \n+        // Load column into cache\n         assertThat(jdbcClient.getColumns(SESSION, table)).doesNotContain(phantomColumn);\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 1, 1);\n+\n+        // Read column from cache\n+        assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 2, 1);\n+    }\n+\n+    @Test\n+    public void testColumnsCachedBySession()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle table = getAnyTable(schema);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(table);\n+\n+        // Load columns in first session scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 0, 1);\n+\n+        // Load columns in second session scope\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 2, 0, 2);\n+\n+        // Drop first column and invalidate cache for all sessions", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM2MTgwMQ==", "bodyText": "please consider extracting variables Loads, Hits, Misses and only incrementing here\nassertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), loads, hits += 2, misses);\nso no need to search for previous state and one can concentrate only on state change.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537361801", "createdAt": "2020-12-07T09:40:36Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -150,8 +170,100 @@ public void testColumnsCached()\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n         jdbcClient.dropColumn(SESSION, table, phantomColumn);\n \n+        // Load column into cache\n         assertThat(jdbcClient.getColumns(SESSION, table)).doesNotContain(phantomColumn);\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 1, 1);\n+\n+        // Read column from cache\n+        assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 2, 1);\n+    }\n+\n+    @Test\n+    public void testColumnsCachedBySession()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle table = getAnyTable(schema);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(table);\n+\n+        // Load columns in first session scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 0, 1);\n+\n+        // Load columns in second session scope\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 2, 0, 2);\n+\n+        // Drop first column and invalidate cache for all sessions\n+        cachingJdbcClient.dropColumn(firstSession, table, phantomColumn);\n+        assertThat(jdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+\n+        // Load columns into cache in both sessions scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).doesNotContain(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 0, 4);\n+\n+        // Read columns from cache\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).doesNotContain(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 2, 4);\n+    }\n+\n+    @Test\n+    public void testColumnsCacheInvalidationOnTableDrop()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle firstTable = createTable(new SchemaTableName(schema, \"first_table\"));\n+        JdbcTableHandle secondTable = createTable(new SchemaTableName(schema, \"second_table\"));\n+\n+        JdbcColumnHandle firstColumn = addColumn(firstTable, \"first_column\");\n+        JdbcColumnHandle secondColumn = addColumn(secondTable, \"second_column\");\n+\n+        // Load columns for both tables into cache and assert cache loads (sessions x tables)\n+        assertThat(cachingJdbcClient.getColumns(firstSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(firstSession, secondTable)).contains(secondColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 0, 4);\n+\n+        // Load columns from cache\n+        assertThat(cachingJdbcClient.getColumns(firstSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 2, 4);\n+\n+        // Rename column\n+        cachingJdbcClient.renameColumn(firstSession, firstTable, firstColumn, \"another_column\");\n+        assertThat(cachingJdbcClient.getColumns(secondSession, firstTable))\n+                .doesNotContain(firstColumn)\n+                .containsAll(jdbcClient.getColumns(SESSION, firstTable));\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 5, 2, 5);\n+\n+        // Drop columns and caches for first table\n+        cachingJdbcClient.dropTable(secondSession, firstTable);\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(firstSession, firstTable)).isInstanceOf(TableNotFoundException.class);\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(secondSession, firstTable)).isInstanceOf(TableNotFoundException.class);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 7, 2, 7);\n+\n+        // Check if second table is still cached\n+        assertThat(cachingJdbcClient.getColumns(firstSession, secondTable)).contains(secondColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 7, 4, 7);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 158}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MDU5NTgw", "url": "https://github.com/trinodb/trino/pull/6167#pullrequestreview-546059580", "createdAt": "2020-12-07T11:28:25Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMToyODoyNVrOIAiSVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMToyODoyNVrOIAiSVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQzMjY2MA==", "bodyText": "0 -> expectedHit", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537432660", "createdAt": "2020-12-07T11:28:25Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -145,13 +174,149 @@ private void dropTable(SchemaTableName phantomTable)\n     public void testColumnsCached()\n     {\n         JdbcTableHandle table = getAnyTable(schema);\n-\n         JdbcColumnHandle phantomColumn = addColumn(table);\n+\n+        int expectedLoad = 0, expectedHit = 0, expectedMiss = 0;\n+\n+        // Read column into cache\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), expectedLoad += 1, expectedHit, expectedMiss += 1);\n+\n         jdbcClient.dropColumn(SESSION, table, phantomColumn);\n \n+        // Load column from cache\n         assertThat(jdbcClient.getColumns(SESSION, table)).doesNotContain(phantomColumn);\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), expectedLoad, expectedHit += 1, expectedMiss);\n+    }\n+\n+    @Test\n+    public void testColumnsCachedPerSession()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle table = getAnyTable(schema);\n+        JdbcColumnHandle phantomColumn = addColumn(table);\n+\n+        int expectedLoad = 0, expectedHit = 0, expectedMiss = 0;\n+\n+        // Load columns in first session scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), expectedLoad += 1, expectedHit, expectedMiss += 1);\n+\n+        // Load columns in second session scope\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), expectedLoad += 1, expectedHit, expectedMiss += 1);\n+\n+        // Check that columns are cached\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), expectedLoad, expectedHit += 1, expectedMiss);\n+\n+        // Drop first column and invalidate cache for all sessions\n+        cachingJdbcClient.dropColumn(firstSession, table, phantomColumn);\n+        assertThat(jdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+\n+        // Load columns into cache in both sessions scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).doesNotContain(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), expectedLoad += 2, expectedHit, expectedMiss += 2);\n+\n+        // Read columns from cache\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).doesNotContain(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), expectedLoad, expectedHit + 2, expectedMiss);\n+    }\n+\n+    @Test\n+    public void testColumnsCacheInvalidationOnTableDrop()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle firstTable = createTable(new SchemaTableName(schema, \"first_table\"));\n+        JdbcTableHandle secondTable = createTable(new SchemaTableName(schema, \"second_table\"));\n+\n+        JdbcColumnHandle firstColumn = addColumn(firstTable, \"first_column\");\n+        JdbcColumnHandle secondColumn = addColumn(secondTable, \"second_column\");\n+\n+        int expectedLoad = 0, expectedHit = 0, expectedMiss = 0;\n+\n+        // Load columns for both tables into cache and assert cache loads (sessions x tables)\n+        assertThat(cachingJdbcClient.getColumns(firstSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(firstSession, secondTable)).contains(secondColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), expectedLoad += 4, 0, expectedMiss += 4);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 160}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MDYyMDg0", "url": "https://github.com/trinodb/trino/pull/6167#pullrequestreview-546062084", "createdAt": "2020-12-07T11:31:59Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMTozMTo1OVrOIAibAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMTozNTowMFrOIAih_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQzNDg4Mg==", "bodyText": "com.google.common.base.MoreObjects#firstNonNull", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537434882", "createdAt": "2020-12-07T11:31:59Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,6 +359,19 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionProperties.stream()\n+                .map(property -> Map.entry(property.getName(), getSessionProperty(session, property)))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private static Object getSessionProperty(ConnectorSession session, PropertyMetadata property)\n+    {\n+        return Optional.ofNullable(session.getProperty(property.getName(), property.getJavaType()))\n+                .orElse(NULL_MARKER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQzNTIyNg==", "bodyText": "Document why in a code comment", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537435226", "createdAt": "2020-12-07T11:32:28Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/TransactionCachingJdbcClient.java", "diffHunk": "@@ -33,7 +34,7 @@\n \n     public TransactionCachingJdbcClient(JdbcClient delegate, Duration cachingTtl)\n     {\n-        super(delegate, cachingTtl, true);\n+        super(delegate, Set.of(), cachingTtl, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQzNjA2OA==", "bodyText": "Inline. or make helper method in the cache class.\nOnce this method is added here, it will be much more expensive to remove it from here.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537436068", "createdAt": "2020-12-07T11:33:59Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/JdbcOutputTableHandle.java", "diffHunk": "@@ -110,6 +111,11 @@ public String getTemporaryTableName()\n         return temporaryTableName;\n     }\n \n+    public SchemaTableName getSchemaTableName()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQzNjY3MA==", "bodyText": "Drop the change. The insert may change the state of the table, including its obvervable metadata.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537436670", "createdAt": "2020-12-07T11:35:00Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -225,7 +225,6 @@ public JdbcOutputTableHandle beginInsertTable(ConnectorSession session, JdbcTabl\n     public void finishInsertTable(ConnectorSession session, JdbcOutputTableHandle handle)\n     {\n         delegate.finishInsertTable(session, handle);\n-        invalidateTableCaches(handle.getSchemaTableName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4MTM2NzQ1", "url": "https://github.com/trinodb/trino/pull/6167#pullrequestreview-548136745", "createdAt": "2020-12-09T12:33:15Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjozMzoxNVrOICSWmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjozMzoxNVrOICSWmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI2ODc2MA==", "bodyText": "Please extract this to separate pull request, so we can discuss this independently.", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r539268760", "createdAt": "2020-12-09T12:33:15Z", "author": {"login": "kokosing"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -225,7 +225,6 @@ public JdbcOutputTableHandle beginInsertTable(ConnectorSession session, JdbcTabl\n     public void finishInsertTable(ConnectorSession session, JdbcOutputTableHandle handle)\n     {\n         delegate.finishInsertTable(session, handle);\n-        invalidateTableCaches(handle.getSchemaTableName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQzNjY3MA=="}, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f07289404d04132fb43da0af40087cf349e5f85", "author": {"user": {"login": "wendigo", "name": "Mateusz \"Serafin\" Gajewski"}}, "url": "https://github.com/trinodb/trino/commit/1f07289404d04132fb43da0af40087cf349e5f85", "committedDate": "2020-12-09T12:36:42Z", "message": "Make session properties part of ColumnsCacheKey"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "1076951f7fd5d632268ece0925e3a2449a30111d", "author": {"user": {"login": "wendigo", "name": "Mateusz \"Serafin\" Gajewski"}}, "url": "https://github.com/trinodb/trino/commit/1076951f7fd5d632268ece0925e3a2449a30111d", "committedDate": "2020-12-09T13:59:06Z", "message": "Invalidate caches for given SchemaTableName only"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efcacb03347deeb828cfc20ec429284f561eed24", "author": {"user": {"login": "wendigo", "name": "Mateusz \"Serafin\" Gajewski"}}, "url": "https://github.com/trinodb/trino/commit/efcacb03347deeb828cfc20ec429284f561eed24", "committedDate": "2020-12-09T13:59:06Z", "message": "Verify that columns are loaded and cached"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0dba7073e9ee6de27c62064e6f9e5306c641a99", "author": {"user": {"login": "wendigo", "name": "Mateusz \"Serafin\" Gajewski"}}, "url": "https://github.com/trinodb/trino/commit/e0dba7073e9ee6de27c62064e6f9e5306c641a99", "committedDate": "2020-12-09T13:59:07Z", "message": "Disable cache entirely when ttl is 0ms"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "e0dba7073e9ee6de27c62064e6f9e5306c641a99", "author": {"user": {"login": "wendigo", "name": "Mateusz \"Serafin\" Gajewski"}}, "url": "https://github.com/trinodb/trino/commit/e0dba7073e9ee6de27c62064e6f9e5306c641a99", "committedDate": "2020-12-09T13:59:07Z", "message": "Disable cache entirely when ttl is 0ms"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NDI2NTMw", "url": "https://github.com/trinodb/trino/pull/6167#pullrequestreview-549426530", "createdAt": "2020-12-10T17:18:25Z", "commit": {"oid": "e0dba7073e9ee6de27c62064e6f9e5306c641a99"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNzoxODoyNVrOIDUbjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNzoyNzoxOFrOIDU0dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1MTM3NA==", "bodyText": "PropertyMetadata<?>", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r540351374", "createdAt": "2020-12-10T17:18:25Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,31 +371,60 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionProperties.stream()\n+                .map(property -> Map.entry(property.getName(), getSessionProperty(session, property)))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private static Object getSessionProperty(ConnectorSession session, PropertyMetadata property)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0dba7073e9ee6de27c62064e6f9e5306c641a99"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1MTkxOQ==", "bodyText": "import java.util.function.Predicate;", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r540351919", "createdAt": "2020-12-10T17:19:13Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -13,8 +13,12 @@\n  */\n package io.prestosql.plugin.jdbc;\n \n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Predicate;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0dba7073e9ee6de27c62064e6f9e5306c641a99"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1NTQ1Ng==", "bodyText": "Key is not @nullable. Please change com.google.common.base.Predicate -> java.util.function.Predicate", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r540355456", "createdAt": "2020-12-10T17:24:03Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,31 +371,60 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionProperties.stream()\n+                .map(property -> Map.entry(property.getName(), getSessionProperty(session, property)))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private static Object getSessionProperty(ConnectorSession session, PropertyMetadata property)\n+    {\n+        return firstNonNull(session.getProperty(property.getName(), property.getJavaType()), NULL_MARKER);\n+    }\n+\n     private void invalidateSchemasCache()\n     {\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTableCaches(SchemaTableName schemaTableName)\n+    {\n+        invalidateColumnsCache(schemaTableName);\n+        invalidateCache(tableHandleCache, key -> key.tableName.equals(schemaTableName));\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(schemaTableName.getSchemaName())));\n+    }\n+\n+    private void invalidateColumnsCache(SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateCache(columnsCache, key -> key.table.equals(table));\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    @VisibleForTesting\n+    CacheStats getColumnsCacheStats()\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        return columnsCache.stats();\n+    }\n+\n+    private static <T, V> void invalidateCache(Cache<T, V> cache, Predicate<T> filterFunction)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0dba7073e9ee6de27c62064e6f9e5306c641a99"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1Nzc1MQ==", "bodyText": "@wendigo why didn't you want to remove one of those parameters?", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r540357751", "createdAt": "2020-12-10T17:27:18Z", "author": {"login": "ssheikin"}, "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -150,8 +166,93 @@ public void testColumnsCached()\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n         jdbcClient.dropColumn(SESSION, table, phantomColumn);\n \n+        // Load column into cache\n         assertThat(jdbcClient.getColumns(SESSION, table)).doesNotContain(phantomColumn);\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 1, 1);\n+\n+        // Read column from cache\n+        assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 2, 1);\n+    }\n+\n+    @Test\n+    public void testColumnsCachedBySession()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle table = getAnyTable(schema);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(table);\n+\n+        // Load columns in first session scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 0, 1);\n+\n+        // Load columns in second session scope\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 2, 0, 2);\n+\n+        // Drop first column and invalidate cache for all sessions\n+        cachingJdbcClient.dropColumn(firstSession, table, phantomColumn);\n+        assertThat(jdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+\n+        // Load columns into cache in both sessions scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).doesNotContain(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 0, 4);\n+\n+        // Read columns from cache\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).doesNotContain(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 2, 4);\n+    }\n+\n+    @Test\n+    public void testColumnsCacheInvalidationOnTableDrop()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle firstTable = createTable(new SchemaTableName(schema, \"first_table\"));\n+        JdbcTableHandle secondTable = createTable(new SchemaTableName(schema, \"second_table\"));\n+\n+        JdbcColumnHandle firstColumn = addColumn(firstTable, \"first_column\");\n+        JdbcColumnHandle secondColumn = addColumn(secondTable, \"second_column\");\n+\n+        // Load columns for both tables into cache and assert cache loads (sessions x tables)\n+        assertThat(cachingJdbcClient.getColumns(firstSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(firstSession, secondTable)).contains(secondColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 0, 4);\n+\n+        // Load columns from cache\n+        assertThat(cachingJdbcClient.getColumns(firstSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 2, 4);\n+\n+        // Drop columns and caches for first table\n+        cachingJdbcClient.dropTable(secondSession, firstTable);\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(firstSession, firstTable)).isInstanceOf(TableNotFoundException.class);\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(secondSession, firstTable)).isInstanceOf(TableNotFoundException.class);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 6, 2, 6);\n+\n+        // Check if second table is still cached\n+        assertThat(cachingJdbcClient.getColumns(firstSession, secondTable)).contains(secondColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 6, 4, 6);\n+\n+        cachingJdbcClient.dropTable(secondSession, secondTable);\n+    }\n+\n+    private void assertCacheLoadsHitsAndMisses(CacheStats stats, int expectedLoad, int expectedHit, int expectedMiss)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExMTc5MQ=="}, "originalCommit": null, "originalPosition": 151}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1973, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}