{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0NjQzMjg4", "number": 5792, "title": "Implement table scan redirection", "bodyText": "Allows connectors to offload table scans to any other connector during\nthe plan optimization phase. The connector may choose to delegate\nbased on criteria like selected columns and applied predicates.", "createdAt": "2020-11-03T10:42:36Z", "url": "https://github.com/trinodb/trino/pull/5792", "merged": true, "mergeCommit": {"oid": "235e42695ce3f5efc171a14ca0ab7988d5cbdf5c"}, "closed": true, "closedAt": "2020-11-18T10:48:10Z", "author": {"login": "raunaqmorarka"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdY3bGmAFqTUyMjQwMzEwMQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABeYXpHnAFqTY2MzU0MDYwMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNDAzMTAx", "url": "https://github.com/trinodb/trino/pull/5792#pullrequestreview-522403101", "createdAt": "2020-11-03T11:24:55Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMToyNDo1NVrOHsqiuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMToyNTo0MVrOHsqkRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5NjQwOA==", "bodyText": "passing of sourceColumns is redundant. getRedirectedTableScan can extract these itself.", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r516596408", "createdAt": "2020-11-03T11:24:55Z", "author": {"login": "sopel39"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/JdbcMetadata.java", "diffHunk": "@@ -302,6 +304,29 @@ public JdbcTableHandle getTableHandle(ConnectorSession session, SchemaTableName\n         return Optional.of(new LimitApplicationResult<>(handle, jdbcClient.isLimitGuaranteed(session)));\n     }\n \n+    @Override\n+    public Optional<TableScanRedirectApplicationResult> applyTableScanRedirect(ConnectorSession session, ConnectorTableHandle table)\n+    {\n+        JdbcTableHandle tableHandle = (JdbcTableHandle) table;\n+\n+        List<JdbcColumnHandle> sourceColumns = tableHandle.getColumns()\n+                .map(columnSet -> (List<JdbcColumnHandle>) columnSet.stream().map(JdbcColumnHandle.class::cast).collect(toImmutableList()))\n+                .orElseGet(() -> jdbcClient.getColumns(session, tableHandle));\n+\n+        Optional<JdbcTableScanRedirectionResult> result = jdbcClient.getRedirectedTableScan(session, tableHandle, sourceColumns);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5NjgwNg==", "bodyText": "@martint this is where filter in redirection is being used", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r516596806", "createdAt": "2020-11-03T11:25:41Z", "author": {"login": "sopel39"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/JdbcMetadata.java", "diffHunk": "@@ -302,6 +304,29 @@ public JdbcTableHandle getTableHandle(ConnectorSession session, SchemaTableName\n         return Optional.of(new LimitApplicationResult<>(handle, jdbcClient.isLimitGuaranteed(session)));\n     }\n \n+    @Override\n+    public Optional<TableScanRedirectApplicationResult> applyTableScanRedirect(ConnectorSession session, ConnectorTableHandle table)\n+    {\n+        JdbcTableHandle tableHandle = (JdbcTableHandle) table;\n+\n+        List<JdbcColumnHandle> sourceColumns = tableHandle.getColumns()\n+                .map(columnSet -> (List<JdbcColumnHandle>) columnSet.stream().map(JdbcColumnHandle.class::cast).collect(toImmutableList()))\n+                .orElseGet(() -> jdbcClient.getColumns(session, tableHandle));\n+\n+        Optional<JdbcTableScanRedirectionResult> result = jdbcClient.getRedirectedTableScan(session, tableHandle, sourceColumns);\n+        if (result.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnsMapping = result.get().getDestinationColumns();\n+        return Optional.of(\n+                new TableScanRedirectApplicationResult(\n+                        result.get().getDestinationTable(),\n+                        columnsMapping,\n+                        tableHandle.getConstraint()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMjA2MTQz", "url": "https://github.com/trinodb/trino/pull/5792#pullrequestreview-523206143", "createdAt": "2020-11-04T09:59:42Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo1OTo0MlrOHtQ81w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo1OTo0MlrOHtQ81w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIyNTY4Nw==", "bodyText": "we shouldn't output filter back here, because in the future (if we support redirection after aggregtation pushdown) filters might be on unaggregated columns (before aggregation happens)", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r517225687", "createdAt": "2020-11-04T09:59:42Z", "author": {"login": "sopel39"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/JdbcMetadata.java", "diffHunk": "@@ -302,6 +304,29 @@ public JdbcTableHandle getTableHandle(ConnectorSession session, SchemaTableName\n         return Optional.of(new LimitApplicationResult<>(handle, jdbcClient.isLimitGuaranteed(session)));\n     }\n \n+    @Override\n+    public Optional<TableScanRedirectApplicationResult> applyTableScanRedirect(ConnectorSession session, ConnectorTableHandle table)\n+    {\n+        JdbcTableHandle tableHandle = (JdbcTableHandle) table;\n+\n+        List<JdbcColumnHandle> sourceColumns = tableHandle.getColumns()\n+                .map(columnSet -> (List<JdbcColumnHandle>) columnSet.stream().map(JdbcColumnHandle.class::cast).collect(toImmutableList()))\n+                .orElseGet(() -> jdbcClient.getColumns(session, tableHandle));\n+\n+        Optional<JdbcTableScanRedirectionResult> result = jdbcClient.getRedirectedTableScan(session, tableHandle, sourceColumns);\n+        if (result.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnsMapping = result.get().getDestinationColumns();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0MjQyNzU4", "url": "https://github.com/trinodb/trino/pull/5792#pullrequestreview-524242758", "createdAt": "2020-11-05T13:09:58Z", "commit": {"oid": "f89a975f373ef9d4bac499ae771034783c42ecc0"}, "state": "APPROVED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMzowOTo1OFrOHuChLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMzo1ODozN1rOHuEflQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzNzgwNg==", "bodyText": "reverse the condition and add a comment:\nif (symbol != null) {\n  // symbol should be mapped in redirected table scan\n  return symbol;\n}", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518037806", "createdAt": "2020-11-05T13:09:58Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isTableScanRedirectionEnabled;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isTableScanRedirectionEnabled(session);\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(GENERIC_INTERNAL_ERROR, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = requireNonNull(\n+                            columnMapping.get(entry.getValue()),\n+                            format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    return requireNonNull(\n+                            destinationColumnHandles.get(destinationColumn),\n+                            format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                }));\n+\n+        TupleDomain<ColumnHandle> enforcedConstraint = scanNode.getEnforcedConstraint();\n+        if (enforcedConstraint.isAll()) {\n+            return Result.ofPlanNode(\n+                    new TableScanNode(\n+                            scanNode.getId(),\n+                            destinationTableHandle.get(),\n+                            scanNode.getOutputSymbols(),\n+                            newAssignments,\n+                            enforcedConstraint));\n+        }\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.<Symbol, ColumnHandle>builder()\n+                .putAll(newAssignments);\n+        ImmutableList.Builder<Symbol> newOutputSymbolsBuilder = ImmutableList.<Symbol>builder()\n+                .addAll(scanNode.getOutputSymbols());\n+        Map<ColumnHandle, Symbol> assignments = ImmutableBiMap.copyOf(scanNode.getAssignments()).inverse();\n+        TupleDomain<Symbol> transformedFilters = enforcedConstraint.transform(sourceColumnHandle -> {\n+            Symbol symbol = assignments.get(sourceColumnHandle);\n+            if (symbol == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89a975f373ef9d4bac499ae771034783c42ecc0"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA0MjgyOQ==", "bodyText": "extract enforcedConstraint.getDomains().get().get(sourceColumnHandle).getType() as Type domainType", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518042829", "createdAt": "2020-11-05T13:18:02Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isTableScanRedirectionEnabled;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isTableScanRedirectionEnabled(session);\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(GENERIC_INTERNAL_ERROR, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = requireNonNull(\n+                            columnMapping.get(entry.getValue()),\n+                            format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    return requireNonNull(\n+                            destinationColumnHandles.get(destinationColumn),\n+                            format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                }));\n+\n+        TupleDomain<ColumnHandle> enforcedConstraint = scanNode.getEnforcedConstraint();\n+        if (enforcedConstraint.isAll()) {\n+            return Result.ofPlanNode(\n+                    new TableScanNode(\n+                            scanNode.getId(),\n+                            destinationTableHandle.get(),\n+                            scanNode.getOutputSymbols(),\n+                            newAssignments,\n+                            enforcedConstraint));\n+        }\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.<Symbol, ColumnHandle>builder()\n+                .putAll(newAssignments);\n+        ImmutableList.Builder<Symbol> newOutputSymbolsBuilder = ImmutableList.<Symbol>builder()\n+                .addAll(scanNode.getOutputSymbols());\n+        Map<ColumnHandle, Symbol> assignments = ImmutableBiMap.copyOf(scanNode.getAssignments()).inverse();\n+        TupleDomain<Symbol> transformedFilters = enforcedConstraint.transform(sourceColumnHandle -> {\n+            Symbol symbol = assignments.get(sourceColumnHandle);\n+            if (symbol == null) {\n+                // Column pruning after PPD into table scan can remove assignments for filter columns from the scan node\n+                String destinationColumn = requireNonNull(\n+                        columnMapping.get(sourceColumnHandle),\n+                        format(\"Did not find mapping for source column %s in table scan redirection\", sourceColumnHandle));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89a975f373ef9d4bac499ae771034783c42ecc0"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA0NDE2NA==", "bodyText": "rename to transformedConstraint", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518044164", "createdAt": "2020-11-05T13:20:06Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isTableScanRedirectionEnabled;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isTableScanRedirectionEnabled(session);\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(GENERIC_INTERNAL_ERROR, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = requireNonNull(\n+                            columnMapping.get(entry.getValue()),\n+                            format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    return requireNonNull(\n+                            destinationColumnHandles.get(destinationColumn),\n+                            format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                }));\n+\n+        TupleDomain<ColumnHandle> enforcedConstraint = scanNode.getEnforcedConstraint();\n+        if (enforcedConstraint.isAll()) {\n+            return Result.ofPlanNode(\n+                    new TableScanNode(\n+                            scanNode.getId(),\n+                            destinationTableHandle.get(),\n+                            scanNode.getOutputSymbols(),\n+                            newAssignments,\n+                            enforcedConstraint));\n+        }\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.<Symbol, ColumnHandle>builder()\n+                .putAll(newAssignments);\n+        ImmutableList.Builder<Symbol> newOutputSymbolsBuilder = ImmutableList.<Symbol>builder()\n+                .addAll(scanNode.getOutputSymbols());\n+        Map<ColumnHandle, Symbol> assignments = ImmutableBiMap.copyOf(scanNode.getAssignments()).inverse();\n+        TupleDomain<Symbol> transformedFilters = enforcedConstraint.transform(sourceColumnHandle -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89a975f373ef9d4bac499ae771034783c42ecc0"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA1NDk5Mw==", "bodyText": "extract into separate method", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518054993", "createdAt": "2020-11-05T13:36:35Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.Constraint;\n+import io.prestosql.spi.connector.ConstraintApplicationResult;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.assertions.PlanAssert;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n+import io.prestosql.testing.LocalQueryRunner;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.expression;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestTableScanRedirectionWithPushdown\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n+            sourceColumnHandleA, destinationColumnNameA,\n+            sourceColumnHandleB, destinationColumnNameB);\n+\n+    @Test\n+    public void testRedirectionAfterProjectionPushdown()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect that source_col_a is projected\n+        ApplyTableScanRedirect tableScanRedirection =\n+                (session, handle) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89a975f373ef9d4bac499ae771034783c42ecc0"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA1NjUzOQ==", "bodyText": "redundant test? what does projection change here?", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518056539", "createdAt": "2020-11-05T13:39:02Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.Constraint;\n+import io.prestosql.spi.connector.ConstraintApplicationResult;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.assertions.PlanAssert;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n+import io.prestosql.testing.LocalQueryRunner;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.expression;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestTableScanRedirectionWithPushdown\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n+            sourceColumnHandleA, destinationColumnNameA,\n+            sourceColumnHandleB, destinationColumnNameB);\n+\n+    @Test\n+    public void testRedirectionAfterProjectionPushdown()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect that source_col_a is projected\n+        ApplyTableScanRedirect tableScanRedirection =\n+                (session, handle) -> {\n+                    MockConnectorTableHandle mockConnectorTable = (MockConnectorTableHandle) handle;\n+                    Optional<List<ColumnHandle>> projectedColumns = mockConnectorTable.getColumns();\n+                    if (projectedColumns.isEmpty()) {\n+                        return Optional.empty();\n+                    }\n+                    List<String> projectedColumnNames = projectedColumns.get().stream()\n+                            .map(MockConnectorColumnHandle.class::cast)\n+                            .map(MockConnectorColumnHandle::getName)\n+                            .collect(toImmutableList());\n+                    if (!projectedColumnNames.equals(ImmutableList.of(sourceColumnNameA))) {\n+                        return Optional.empty();\n+                    }\n+                    return Optional.of(\n+                            new TableScanRedirectApplicationResult(\n+                                    new CatalogSchemaTableName(MOCK_CATALOG, destinationTable),\n+                                    redirectionMappingA));\n+                };\n+\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(tableScanRedirection, Optional.of(this::mockApplyProjection), Optional.empty())) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\"target_table\", ImmutableMap.of(\"DEST_COL\", destinationColumnNameA))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COLA\", \"SOURCE_COLB\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COLA\", sourceColumnNameA, \"SOURCE_COLB\", sourceColumnNameB))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a > 0\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            filter(\n+                                    \"DEST_COL > 0\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.all(),\n+                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectionAfterPredicatePushdownIntoTableScan()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect a filter\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingA),\n+                Optional.empty(),\n+                Optional.of(this::mockApplyFilter))) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\n+                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                    TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                    ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA)))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COL\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COL\", sourceColumnNameA))));\n+\n+            assertPlan(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89a975f373ef9d4bac499ae771034783c42ecc0"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA1OTczNw==", "bodyText": "I think it should be:\nProject('dest_col_b') -> Filter('dest_col_a = 1') -> TableScan", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518059737", "createdAt": "2020-11-05T13:43:45Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.Constraint;\n+import io.prestosql.spi.connector.ConstraintApplicationResult;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.assertions.PlanAssert;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n+import io.prestosql.testing.LocalQueryRunner;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.expression;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestTableScanRedirectionWithPushdown\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n+            sourceColumnHandleA, destinationColumnNameA,\n+            sourceColumnHandleB, destinationColumnNameB);\n+\n+    @Test\n+    public void testRedirectionAfterProjectionPushdown()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect that source_col_a is projected\n+        ApplyTableScanRedirect tableScanRedirection =\n+                (session, handle) -> {\n+                    MockConnectorTableHandle mockConnectorTable = (MockConnectorTableHandle) handle;\n+                    Optional<List<ColumnHandle>> projectedColumns = mockConnectorTable.getColumns();\n+                    if (projectedColumns.isEmpty()) {\n+                        return Optional.empty();\n+                    }\n+                    List<String> projectedColumnNames = projectedColumns.get().stream()\n+                            .map(MockConnectorColumnHandle.class::cast)\n+                            .map(MockConnectorColumnHandle::getName)\n+                            .collect(toImmutableList());\n+                    if (!projectedColumnNames.equals(ImmutableList.of(sourceColumnNameA))) {\n+                        return Optional.empty();\n+                    }\n+                    return Optional.of(\n+                            new TableScanRedirectApplicationResult(\n+                                    new CatalogSchemaTableName(MOCK_CATALOG, destinationTable),\n+                                    redirectionMappingA));\n+                };\n+\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(tableScanRedirection, Optional.of(this::mockApplyProjection), Optional.empty())) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\"target_table\", ImmutableMap.of(\"DEST_COL\", destinationColumnNameA))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COLA\", \"SOURCE_COLB\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COLA\", sourceColumnNameA, \"SOURCE_COLB\", sourceColumnNameB))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a > 0\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            filter(\n+                                    \"DEST_COL > 0\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.all(),\n+                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectionAfterPredicatePushdownIntoTableScan()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect a filter\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingA),\n+                Optional.empty(),\n+                Optional.of(this::mockApplyFilter))) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\n+                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                    TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                    ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA)))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COL\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COL\", sourceColumnNameA))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT (2 * source_col_a) + 1 FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"expr\"),\n+                            project(\n+                                    ImmutableMap.of(\"expr\", expression(\"(DEST_COL * 2) + 1\")),\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testPredicatePushdownAfterRedirect()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB),\n+                Optional.empty(),\n+                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleA, destinationColumnHandleB))))) {\n+            // Only 'source_col_a = 1' will get pushed down into source table scan\n+            // Only 'source_col_b = 2' will get pushed down into destination table scan\n+            // This test verifies that the Filter('source_col_a = 1') produced by redirection\n+            // does not prevent pushdown of 'source_col_b = 2' into destination table scan\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table WHERE source_col_a = 1 AND source_col_b = 2\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL_A\", \"DEST_COL_B\"),\n+                            filter(\n+                                    \"DEST_COL_A = 1\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleB), singleValue(INTEGER, 2L))),\n+                                            ImmutableMap.of(\n+                                                    \"DEST_COL_A\", equalTo(destinationColumnHandleA),\n+                                                    \"DEST_COL_B\", equalTo(destinationColumnHandleB))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectAfterColumnPruningOnPushedDownPredicate()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB),\n+                Optional.of(this::mockApplyProjection),\n+                Optional.of(this::mockApplyFilter))) {\n+            // After 'source_col_a = 1' is pushed into source table scan, it's possible for 'source_col_a' table scan assignment to be pruned\n+            // Redirection results in Project('source_col_b') -> Filter('source_col_a = 1') -> TableScan for such case", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89a975f373ef9d4bac499ae771034783c42ecc0"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA3MDE2NQ==", "bodyText": "extract this into utility method if possible", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518070165", "createdAt": "2020-11-05T13:58:37Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.rule.test.RuleTester;\n+import io.prestosql.testing.TestingTransactionHandle;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static io.airlift.slice.Slices.utf8Slice;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.expression;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.sql.planner.iterative.rule.test.RuleTester.defaultRuleTester;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestApplyTableScanRedirection\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+    private static final TableHandle TEST_TABLE_HANDLE = createTableHandle(new MockConnectorTableHandle(sourceTable));\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static TableHandle createTableHandle(ConnectorTableHandle tableHandle)\n+    {\n+        return new TableHandle(\n+                new CatalogName(MOCK_CATALOG),\n+                tableHandle,\n+                TestingTransactionHandle.create(),\n+                Optional.empty());\n+    }\n+\n+    @Test\n+    public void testDoesNotFire()\n+    {\n+        try (RuleTester ruleTester = defaultRuleTester()) {\n+            MockConnectorFactory mockFactory = createMockFactory(Optional.empty());\n+            ruleTester.getQueryRunner().createCatalog(MOCK_CATALOG, mockFactory, ImmutableMap.of());\n+\n+            ruleTester.assertThat(new ApplyTableScanRedirection(ruleTester.getMetadata()))\n+                    .on(p -> {\n+                        Symbol column = p.symbol(sourceColumnNameA, VARCHAR);\n+                        return p.tableScan(TEST_TABLE_HANDLE,\n+                                        ImmutableList.of(column),\n+                                        ImmutableMap.of(column, sourceColumnHandleA));\n+                    })\n+                    .withSession(MOCK_SESSION)\n+                    .doesNotFire();\n+        }\n+    }\n+\n+    @Test\n+    public void doesNotFireIfNoTableScan()\n+    {\n+        try (RuleTester ruleTester = defaultRuleTester()) {\n+            ApplyTableScanRedirect applyTableScanRedirect =\n+                    (session, handle) -> Optional.of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89a975f373ef9d4bac499ae771034783c42ecc0"}, "originalPosition": 106}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0MjkyNDUx", "url": "https://github.com/trinodb/trino/pull/5792#pullrequestreview-524292451", "createdAt": "2020-11-05T14:05:53Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDowNTo1NFrOHuE0GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDowNTo1NFrOHuE0GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA3NTQxNg==", "bodyText": "let's remove:\n\nSet<JdbcColumnHandle> sourceColumns from this method.\npass JdbcTableHandle tableHandle instead.", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518075416", "createdAt": "2020-11-05T14:05:54Z", "author": {"login": "sopel39"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/JdbcClient.java", "diffHunk": "@@ -139,4 +140,9 @@ PreparedStatement getPreparedStatement(Connection connection, String sql)\n     String quoted(RemoteTableName remoteTableName);\n \n     Map<String, Object> getTableProperties(JdbcIdentity identity, JdbcTableHandle tableHandle);\n+\n+    default Optional<TableScanRedirectApplicationResult> getTableScanRedirection(ConnectorSession session, SchemaTableName tableName, Set<JdbcColumnHandle> sourceColumns)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4OTcwMzA3", "url": "https://github.com/trinodb/trino/pull/5792#pullrequestreview-528970307", "createdAt": "2020-11-12T10:55:10Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxMTYzMTEy", "url": "https://github.com/trinodb/trino/pull/5792#pullrequestreview-531163112", "createdAt": "2020-11-16T09:51:00Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo1NDo1OVrOHzxijA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMTo0Nzo1MFrOHz5JtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA1MTA4NA==", "bodyText": "just call it filter or destinationFilter. It's not enforced", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524051084", "createdAt": "2020-11-16T09:54:59Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isTableScanRedirectionEnabled;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isTableScanRedirectionEnabled(session);\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(GENERIC_INTERNAL_ERROR, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = requireNonNull(\n+                            columnMapping.get(entry.getValue()),\n+                            format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    return requireNonNull(\n+                            destinationColumnHandles.get(destinationColumn),\n+                            format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                }));\n+\n+        TupleDomain<String> enforcedConstraint = tableScanRedirectApplicationResult.get().getFilter();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE0MjEyMw==", "bodyText": "translate source io.prestosql.sql.planner.plan.TableScanNode#enforcedConstraint from source node, as it should still be valid (on translated column handles) when tableScanRedirectApplicationResult.get().getFilter() is all", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524142123", "createdAt": "2020-11-16T11:17:10Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isTableScanRedirectionEnabled;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isTableScanRedirectionEnabled(session);\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(GENERIC_INTERNAL_ERROR, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = requireNonNull(\n+                            columnMapping.get(entry.getValue()),\n+                            format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    return requireNonNull(\n+                            destinationColumnHandles.get(destinationColumn),\n+                            format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                }));\n+\n+        TupleDomain<String> enforcedConstraint = tableScanRedirectApplicationResult.get().getFilter();\n+        if (enforcedConstraint.isAll()) {\n+            return Result.ofPlanNode(\n+                    new TableScanNode(\n+                            scanNode.getId(),\n+                            destinationTableHandle.get(),\n+                            scanNode.getOutputSymbols(),\n+                            newAssignments,\n+                            TupleDomain.all(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE1NjE0OQ==", "bodyText": "Filter('source_col_a = 1') -> Filter('dest_col_a = 1')", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524156149", "createdAt": "2020-11-16T11:29:53Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.Constraint;\n+import io.prestosql.spi.connector.ConstraintApplicationResult;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.assertions.PlanAssert;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n+import io.prestosql.testing.LocalQueryRunner;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestTableScanRedirectionWithPushdown\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n+            sourceColumnHandleA, destinationColumnNameA,\n+            sourceColumnHandleB, destinationColumnNameB);\n+\n+    @Test\n+    public void testRedirectionAfterProjectionPushdown()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect that source_col_a is projected\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                this::mockApplyRedirectAfterProjectionPushdown,\n+                Optional.of(this::mockApplyProjection),\n+                Optional.empty())) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\"target_table\", ImmutableMap.of(\"DEST_COL\", destinationColumnNameA))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COLA\", \"SOURCE_COLB\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COLA\", sourceColumnNameA, \"SOURCE_COLB\", sourceColumnNameB))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a > 0\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            filter(\n+                                    \"DEST_COL > 0\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.all(),\n+                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectionAfterPredicatePushdownIntoTableScan()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect a filter\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingA),\n+                Optional.empty(),\n+                Optional.of(this::mockApplyFilter))) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\n+                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                    TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                    ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA)))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COL\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COL\", sourceColumnNameA))));\n+        }\n+    }\n+\n+    @Test\n+    public void testPredicatePushdownAfterRedirect()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB),\n+                Optional.empty(),\n+                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleA, destinationColumnHandleB))))) {\n+            // Only 'source_col_a = 1' will get pushed down into source table scan\n+            // Only 'source_col_b = 2' will get pushed down into destination table scan\n+            // This test verifies that the Filter('source_col_a = 1') produced by redirection", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE2NjQ0OA==", "bodyText": "remove? You can just use getMockApplyFilter(...) instead (it's almost identical)", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524166448", "createdAt": "2020-11-16T11:39:32Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.Constraint;\n+import io.prestosql.spi.connector.ConstraintApplicationResult;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.assertions.PlanAssert;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n+import io.prestosql.testing.LocalQueryRunner;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestTableScanRedirectionWithPushdown\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n+            sourceColumnHandleA, destinationColumnNameA,\n+            sourceColumnHandleB, destinationColumnNameB);\n+\n+    @Test\n+    public void testRedirectionAfterProjectionPushdown()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect that source_col_a is projected\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                this::mockApplyRedirectAfterProjectionPushdown,\n+                Optional.of(this::mockApplyProjection),\n+                Optional.empty())) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\"target_table\", ImmutableMap.of(\"DEST_COL\", destinationColumnNameA))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COLA\", \"SOURCE_COLB\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COLA\", sourceColumnNameA, \"SOURCE_COLB\", sourceColumnNameB))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a > 0\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            filter(\n+                                    \"DEST_COL > 0\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.all(),\n+                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectionAfterPredicatePushdownIntoTableScan()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect a filter\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingA),\n+                Optional.empty(),\n+                Optional.of(this::mockApplyFilter))) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\n+                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                    TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                    ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA)))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COL\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COL\", sourceColumnNameA))));\n+        }\n+    }\n+\n+    @Test\n+    public void testPredicatePushdownAfterRedirect()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB),\n+                Optional.empty(),\n+                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleA, destinationColumnHandleB))))) {\n+            // Only 'source_col_a = 1' will get pushed down into source table scan\n+            // Only 'source_col_b = 2' will get pushed down into destination table scan\n+            // This test verifies that the Filter('source_col_a = 1') produced by redirection\n+            // does not prevent pushdown of 'source_col_b = 2' into destination table scan\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table WHERE source_col_a = 1 AND source_col_b = 2\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL_A\", \"DEST_COL_B\"),\n+                            filter(\n+                                    \"DEST_COL_A = 1\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleB), singleValue(INTEGER, 2L))),\n+                                            ImmutableMap.of(\n+                                                    \"DEST_COL_A\", equalTo(destinationColumnHandleA),\n+                                                    \"DEST_COL_B\", equalTo(destinationColumnHandleB))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectAfterColumnPruningOnPushedDownPredicate()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB),\n+                Optional.of(this::mockApplyProjection),\n+                Optional.of(this::mockApplyFilter))) {\n+            // After 'source_col_a = 1' is pushed into source table scan, it's possible for 'source_col_a' table scan assignment to be pruned\n+            // Redirection results in Project('dest_col_b') -> Filter('dest_col_a = 1') -> TableScan for such case\n+            // Subsequent PPD and column pruning rules simplify the above as supported by the destination connector\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_b FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL_B\"),\n+                            tableScan(\n+                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                    TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                    ImmutableMap.of(\"DEST_COL_B\", equalTo(destinationColumnHandleB)))));\n+        }\n+    }\n+\n+    private LocalQueryRunner createLocalQueryRunner(\n+            ApplyTableScanRedirect applyTableScanRedirect,\n+            Optional<ApplyProjection> applyProjection,\n+            Optional<ApplyFilter> applyFilter)\n+    {\n+        LocalQueryRunner queryRunner = LocalQueryRunner.create(MOCK_SESSION);\n+        MockConnectorFactory.Builder builder = MockConnectorFactory.builder()\n+                .withGetTableHandle((session, schemaTableName) -> new MockConnectorTableHandle(schemaTableName))\n+                .withGetColumns(name -> {\n+                    if (name.equals(sourceTable)) {\n+                        return ImmutableList.of(\n+                                new ColumnMetadata(sourceColumnNameA, INTEGER),\n+                                new ColumnMetadata(sourceColumnNameB, INTEGER));\n+                    }\n+                    else if (name.equals(destinationTable)) {\n+                        return ImmutableList.of(\n+                                new ColumnMetadata(destinationColumnNameA, INTEGER),\n+                                new ColumnMetadata(destinationColumnNameB, INTEGER));\n+                    }\n+                    throw new IllegalArgumentException();\n+                })\n+                .withApplyTableScanRedirect(applyTableScanRedirect);\n+        applyProjection.ifPresent(builder::withApplyProjection);\n+        applyFilter.ifPresent(builder::withApplyFilter);\n+\n+        queryRunner.createCatalog(MOCK_CATALOG, builder.build(), ImmutableMap.of());\n+        return queryRunner;\n+    }\n+\n+    private Optional<ProjectionApplicationResult<ConnectorTableHandle>> mockApplyProjection(\n+            ConnectorSession session,\n+            ConnectorTableHandle tableHandle,\n+            List<ConnectorExpression> projections,\n+            Map<String, ColumnHandle> assignments)\n+    {\n+        MockConnectorTableHandle handle = (MockConnectorTableHandle) tableHandle;\n+\n+        List<ColumnHandle> newColumns = assignments.values().stream()\n+                .collect(toImmutableList());\n+        if (handle.getColumns().isPresent() && newColumns.equals(handle.getColumns().get())) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(\n+                new ProjectionApplicationResult<>(\n+                        new MockConnectorTableHandle(handle.getTableName(), handle.getConstraint(), Optional.of(newColumns)),\n+                        projections,\n+                        assignments.entrySet().stream()\n+                                .map(assignment -> new Assignment(\n+                                        assignment.getKey(),\n+                                        assignment.getValue(),\n+                                        ((MockConnectorColumnHandle) assignment.getValue()).getType()))\n+                                .collect(toImmutableList())));\n+    }\n+\n+    private Optional<ConstraintApplicationResult<ConnectorTableHandle>> mockApplyFilter(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE2NzQzNA==", "bodyText": "remove, unused. You can use getMockApplyRedirectAfterPredicatePushdown instead", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524167434", "createdAt": "2020-11-16T11:40:23Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.Constraint;\n+import io.prestosql.spi.connector.ConstraintApplicationResult;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.assertions.PlanAssert;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n+import io.prestosql.testing.LocalQueryRunner;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestTableScanRedirectionWithPushdown\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n+            sourceColumnHandleA, destinationColumnNameA,\n+            sourceColumnHandleB, destinationColumnNameB);\n+\n+    @Test\n+    public void testRedirectionAfterProjectionPushdown()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect that source_col_a is projected\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                this::mockApplyRedirectAfterProjectionPushdown,\n+                Optional.of(this::mockApplyProjection),\n+                Optional.empty())) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\"target_table\", ImmutableMap.of(\"DEST_COL\", destinationColumnNameA))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COLA\", \"SOURCE_COLB\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COLA\", sourceColumnNameA, \"SOURCE_COLB\", sourceColumnNameB))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a > 0\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            filter(\n+                                    \"DEST_COL > 0\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.all(),\n+                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectionAfterPredicatePushdownIntoTableScan()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect a filter\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingA),\n+                Optional.empty(),\n+                Optional.of(this::mockApplyFilter))) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\n+                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                    TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                    ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA)))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COL\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COL\", sourceColumnNameA))));\n+        }\n+    }\n+\n+    @Test\n+    public void testPredicatePushdownAfterRedirect()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB),\n+                Optional.empty(),\n+                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleA, destinationColumnHandleB))))) {\n+            // Only 'source_col_a = 1' will get pushed down into source table scan\n+            // Only 'source_col_b = 2' will get pushed down into destination table scan\n+            // This test verifies that the Filter('source_col_a = 1') produced by redirection\n+            // does not prevent pushdown of 'source_col_b = 2' into destination table scan\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table WHERE source_col_a = 1 AND source_col_b = 2\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL_A\", \"DEST_COL_B\"),\n+                            filter(\n+                                    \"DEST_COL_A = 1\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleB), singleValue(INTEGER, 2L))),\n+                                            ImmutableMap.of(\n+                                                    \"DEST_COL_A\", equalTo(destinationColumnHandleA),\n+                                                    \"DEST_COL_B\", equalTo(destinationColumnHandleB))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectAfterColumnPruningOnPushedDownPredicate()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB),\n+                Optional.of(this::mockApplyProjection),\n+                Optional.of(this::mockApplyFilter))) {\n+            // After 'source_col_a = 1' is pushed into source table scan, it's possible for 'source_col_a' table scan assignment to be pruned\n+            // Redirection results in Project('dest_col_b') -> Filter('dest_col_a = 1') -> TableScan for such case\n+            // Subsequent PPD and column pruning rules simplify the above as supported by the destination connector\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_b FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL_B\"),\n+                            tableScan(\n+                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                    TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                    ImmutableMap.of(\"DEST_COL_B\", equalTo(destinationColumnHandleB)))));\n+        }\n+    }\n+\n+    private LocalQueryRunner createLocalQueryRunner(\n+            ApplyTableScanRedirect applyTableScanRedirect,\n+            Optional<ApplyProjection> applyProjection,\n+            Optional<ApplyFilter> applyFilter)\n+    {\n+        LocalQueryRunner queryRunner = LocalQueryRunner.create(MOCK_SESSION);\n+        MockConnectorFactory.Builder builder = MockConnectorFactory.builder()\n+                .withGetTableHandle((session, schemaTableName) -> new MockConnectorTableHandle(schemaTableName))\n+                .withGetColumns(name -> {\n+                    if (name.equals(sourceTable)) {\n+                        return ImmutableList.of(\n+                                new ColumnMetadata(sourceColumnNameA, INTEGER),\n+                                new ColumnMetadata(sourceColumnNameB, INTEGER));\n+                    }\n+                    else if (name.equals(destinationTable)) {\n+                        return ImmutableList.of(\n+                                new ColumnMetadata(destinationColumnNameA, INTEGER),\n+                                new ColumnMetadata(destinationColumnNameB, INTEGER));\n+                    }\n+                    throw new IllegalArgumentException();\n+                })\n+                .withApplyTableScanRedirect(applyTableScanRedirect);\n+        applyProjection.ifPresent(builder::withApplyProjection);\n+        applyFilter.ifPresent(builder::withApplyFilter);\n+\n+        queryRunner.createCatalog(MOCK_CATALOG, builder.build(), ImmutableMap.of());\n+        return queryRunner;\n+    }\n+\n+    private Optional<ProjectionApplicationResult<ConnectorTableHandle>> mockApplyProjection(\n+            ConnectorSession session,\n+            ConnectorTableHandle tableHandle,\n+            List<ConnectorExpression> projections,\n+            Map<String, ColumnHandle> assignments)\n+    {\n+        MockConnectorTableHandle handle = (MockConnectorTableHandle) tableHandle;\n+\n+        List<ColumnHandle> newColumns = assignments.values().stream()\n+                .collect(toImmutableList());\n+        if (handle.getColumns().isPresent() && newColumns.equals(handle.getColumns().get())) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(\n+                new ProjectionApplicationResult<>(\n+                        new MockConnectorTableHandle(handle.getTableName(), handle.getConstraint(), Optional.of(newColumns)),\n+                        projections,\n+                        assignments.entrySet().stream()\n+                                .map(assignment -> new Assignment(\n+                                        assignment.getKey(),\n+                                        assignment.getValue(),\n+                                        ((MockConnectorColumnHandle) assignment.getValue()).getType()))\n+                                .collect(toImmutableList())));\n+    }\n+\n+    private Optional<ConstraintApplicationResult<ConnectorTableHandle>> mockApplyFilter(\n+            ConnectorSession session,\n+            ConnectorTableHandle table,\n+            Constraint constraint)\n+    {\n+        MockConnectorTableHandle handle = (MockConnectorTableHandle) table;\n+\n+        TupleDomain<ColumnHandle> oldDomain = handle.getConstraint();\n+        TupleDomain<ColumnHandle> newDomain = oldDomain.intersect(constraint.getSummary());\n+        if (oldDomain.equals(newDomain)) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(\n+                new ConstraintApplicationResult<>(\n+                        new MockConnectorTableHandle(handle.getTableName(), newDomain, Optional.empty()),\n+                        TupleDomain.all()));\n+    }\n+\n+    private Optional<TableScanRedirectApplicationResult> mockApplyRedirectAfterProjectionPushdown(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 276}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE3MjQxNg==", "bodyText": "could we add a case when filter is fully consumed and not rematerialized as part of redirection?", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524172416", "createdAt": "2020-11-16T11:44:55Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.Constraint;\n+import io.prestosql.spi.connector.ConstraintApplicationResult;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.assertions.PlanAssert;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n+import io.prestosql.testing.LocalQueryRunner;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestTableScanRedirectionWithPushdown\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n+            sourceColumnHandleA, destinationColumnNameA,\n+            sourceColumnHandleB, destinationColumnNameB);\n+\n+    @Test\n+    public void testRedirectionAfterProjectionPushdown()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect that source_col_a is projected\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                this::mockApplyRedirectAfterProjectionPushdown,\n+                Optional.of(this::mockApplyProjection),\n+                Optional.empty())) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\"target_table\", ImmutableMap.of(\"DEST_COL\", destinationColumnNameA))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COLA\", \"SOURCE_COLB\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COLA\", sourceColumnNameA, \"SOURCE_COLB\", sourceColumnNameB))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a > 0\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            filter(\n+                                    \"DEST_COL > 0\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.all(),\n+                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectionAfterPredicatePushdownIntoTableScan()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE3NTc5Ng==", "bodyText": "is orderkey > 0 pushed down? Can we make it actually filter anything (to test that TPCH correctly rematerialized predicate)?", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524175796", "createdAt": "2020-11-16T11:47:50Z", "author": {"login": "sopel39"}, "path": "presto-tests/src/test/java/io/prestosql/tests/TestTpchTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.tests;\n+\n+import io.prestosql.Session;\n+import io.prestosql.plugin.memory.MemoryPlugin;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.tests.tpch.TpchQueryRunnerBuilder;\n+import org.testng.annotations.Test;\n+\n+import static io.prestosql.SystemSessionProperties.TABLE_SCAN_REDIRECTION_ENABLED;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestTpchTableScanRedirection\n+        extends AbstractTestQueryFramework\n+{\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        DistributedQueryRunner queryRunner = TpchQueryRunnerBuilder.builder()\n+                .withTableScanRedirectionCatalog(\"memory\")\n+                .withTableScanRedirectionSchema(\"test\")\n+                .build();\n+        queryRunner.installPlugin(new MemoryPlugin());\n+        queryRunner.createCatalog(\"memory\", \"memory\");\n+        return queryRunner;\n+    }\n+\n+    @Test(timeOut = 20_000)\n+    public void testTableScanRedirection()\n+    {\n+        assertQuerySucceeds(\"CREATE SCHEMA memory.test\");\n+        assertUpdate(\n+                Session.builder(getSession())\n+                        .setSystemProperty(TABLE_SCAN_REDIRECTION_ENABLED, \"false\")\n+                        .build(),\n+                \"CREATE TABLE memory.test.orders AS SELECT * FROM tpch.tiny.orders LIMIT 100\", 100L);\n+        assertEquals(computeActual(\"SELECT * FROM tpch.tiny.orders WHERE orderkey > 0\").getRowCount(), 100L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNTAwMDAy", "url": "https://github.com/trinodb/trino/pull/5792#pullrequestreview-531500002", "createdAt": "2020-11-16T16:40:04Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxNjo0MDowNFrOH0HUdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQyMzo1MzoyNVrOH0dnRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQwNzkyNA==", "bodyText": "I don't think we need a global toggle for this. If a connector doesn't support this, it will be a no-op. If we need to disable it for a connector, then there should be a toggle (session property/config option) for that connector.", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524407924", "createdAt": "2020-11-16T16:40:04Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/FeaturesConfig.java", "diffHunk": "@@ -976,4 +977,16 @@ public FeaturesConfig setRewriteFilteringSemiJoinToInnerJoin(boolean rewriteFilt\n         this.rewriteFilteringSemiJoinToInnerJoin = rewriteFilteringSemiJoinToInnerJoin;\n         return this;\n     }\n+\n+    public boolean isRedirectTableScansEnabled()\n+    {\n+        return redirectTableScansEnabled;\n+    }\n+\n+    @Config(\"optimizer.redirect-table-scans\")\n+    public FeaturesConfig setRedirectTableScansEnabled(boolean redirectTableScansEnabled)\n+    {\n+        this.redirectTableScansEnabled = redirectTableScansEnabled;\n+        return this;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQxMTkzMg==", "bodyText": "or requiredFilter", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524411932", "createdAt": "2020-11-16T16:45:32Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isTableScanRedirectionEnabled;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isTableScanRedirectionEnabled(session);\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(GENERIC_INTERNAL_ERROR, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = requireNonNull(\n+                            columnMapping.get(entry.getValue()),\n+                            format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    return requireNonNull(\n+                            destinationColumnHandles.get(destinationColumn),\n+                            format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                }));\n+\n+        TupleDomain<String> enforcedConstraint = tableScanRedirectApplicationResult.get().getFilter();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA1MTA4NA=="}, "originalCommit": null, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc3MzE4OA==", "bodyText": "This should throw some kind of Presto exception. Otherwise, it will produce an INTERNAL_ERROR, when it's an issue with a missing or stale mapping within the connector.", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524773188", "createdAt": "2020-11-16T23:53:25Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isTableScanRedirectionEnabled;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isTableScanRedirectionEnabled(session);\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(GENERIC_INTERNAL_ERROR, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = requireNonNull(\n+                            columnMapping.get(entry.getValue()),\n+                            format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    return requireNonNull(\n+                            destinationColumnHandles.get(destinationColumn),\n+                            format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                }));\n+\n+        TupleDomain<String> enforcedConstraint = tableScanRedirectApplicationResult.get().getFilter();\n+        if (enforcedConstraint.isAll()) {\n+            return Result.ofPlanNode(\n+                    new TableScanNode(\n+                            scanNode.getId(),\n+                            destinationTableHandle.get(),\n+                            scanNode.getOutputSymbols(),\n+                            newAssignments,\n+                            TupleDomain.all(),\n+                            scanNode.isForDelete()));\n+        }\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.<Symbol, ColumnHandle>builder()\n+                .putAll(newAssignments);\n+        ImmutableList.Builder<Symbol> newOutputSymbolsBuilder = ImmutableList.<Symbol>builder()\n+                .addAll(scanNode.getOutputSymbols());\n+        Map<ColumnHandle, Symbol> inverseAssignments = ImmutableBiMap.copyOf(scanNode.getAssignments()).inverse();\n+        Map<String, ColumnHandle> inverseColumnsMapping = ImmutableBiMap.copyOf(columnMapping).inverse();\n+        TupleDomain<Symbol> transformedConstraint = enforcedConstraint.transform(destinationColumn -> {\n+            ColumnHandle sourceColumnHandle = requireNonNull(\n+                    inverseColumnsMapping.get(destinationColumn),\n+                    format(\"Did not find mapping for destination column %s in table scan redirection\", destinationColumn));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 128}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "7637be1d92ee009198f89680ef2b913b325bc9c1", "author": {"user": {"login": "raunaqmorarka", "name": "Raunaq Morarka"}}, "url": "https://github.com/trinodb/trino/commit/7637be1d92ee009198f89680ef2b913b325bc9c1", "committedDate": "2020-11-17T15:54:29Z", "message": "Add applyTableScanRedirect SPI and ApplyTableScanRedirection rule\n\nAllows connectors to offload table scans to any other connector during\nthe plan optimization phase. The connector may choose to delegate\nbased on criteria like selected columns and applied predicates."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTQ0MTE4", "url": "https://github.com/trinodb/trino/pull/5792#pullrequestreview-533144118", "createdAt": "2020-11-18T06:47:49Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwNjo0Nzo0OVrOH1fRdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwNjo0Nzo0OVrOH1fRdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg0ODk1MA==", "bodyText": "why difference between 7696L and 7333L?", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r525848950", "createdAt": "2020-11-18T06:47:49Z", "author": {"login": "sopel39"}, "path": "presto-tests/src/test/java/io/prestosql/tests/TestTpchTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.tests;\n+\n+import io.prestosql.plugin.memory.MemoryPlugin;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.tests.tpch.TpchQueryRunnerBuilder;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestTpchTableScanRedirection\n+        extends AbstractTestQueryFramework\n+{\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        DistributedQueryRunner queryRunner = TpchQueryRunnerBuilder.builder()\n+                .withTableScanRedirectionCatalog(\"memory\")\n+                .withTableScanRedirectionSchema(\"test\")\n+                .build();\n+        queryRunner.installPlugin(new MemoryPlugin());\n+        queryRunner.createCatalog(\"memory\", \"memory\");\n+        // Add another tpch catalog without redirection to aid in loading data into memory connector\n+        queryRunner.createCatalog(\"tpch_data_load\", \"tpch\");\n+        return queryRunner;\n+    }\n+\n+    @Test(timeOut = 20_000)\n+    public void testTableScanRedirection()\n+    {\n+        assertQuerySucceeds(\"CREATE SCHEMA memory.test\");\n+        assertUpdate(\"CREATE TABLE memory.test.orders AS SELECT * FROM tpch_data_load.tiny.orders WHERE orderstatus IN ('O', 'P')\", 7696L);\n+        assertEquals(computeActual(\"SELECT * FROM tpch.tiny.orders WHERE orderstatus IN ('O', 'F')\").getRowCount(), 7333L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMjczODk5", "url": "https://github.com/trinodb/trino/pull/5792#pullrequestreview-533273899", "createdAt": "2020-11-18T09:53:41Z", "commit": {"oid": "7637be1d92ee009198f89680ef2b913b325bc9c1"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTo1Mzo0MVrOH1ln6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDowMDozNlrOH1l7QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1MzAwMg==", "bodyText": "technically, there doesn't have to be an inverse mapping for destinationColumn here, e.g this could be predicate on some other, new column", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r525953002", "createdAt": "2020-11-18T09:53:41Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.COLUMN_NOT_FOUND;\n+import static io.prestosql.spi.StandardErrorCode.TABLE_NOT_FOUND;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(TABLE_NOT_FOUND, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = columnMapping.get(entry.getValue());\n+                    if (destinationColumn == null) {\n+                        throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    }\n+                    ColumnHandle destinationColumnHandle = destinationColumnHandles.get(destinationColumn);\n+                    if (destinationColumnHandle == null) {\n+                        throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                    }\n+                    return destinationColumnHandle;\n+                }));\n+\n+        TupleDomain<String> requiredFilter = tableScanRedirectApplicationResult.get().getFilter();\n+        if (requiredFilter.isAll()) {\n+            return Result.ofPlanNode(\n+                    new TableScanNode(\n+                            scanNode.getId(),\n+                            destinationTableHandle.get(),\n+                            scanNode.getOutputSymbols(),\n+                            newAssignments,\n+                            TupleDomain.all(),\n+                            scanNode.isForDelete()));\n+        }\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.<Symbol, ColumnHandle>builder()\n+                .putAll(newAssignments);\n+        ImmutableList.Builder<Symbol> newOutputSymbolsBuilder = ImmutableList.<Symbol>builder()\n+                .addAll(scanNode.getOutputSymbols());\n+        Map<ColumnHandle, Symbol> inverseAssignments = ImmutableBiMap.copyOf(scanNode.getAssignments()).inverse();\n+        Map<String, ColumnHandle> inverseColumnsMapping = ImmutableBiMap.copyOf(columnMapping).inverse();\n+        TupleDomain<Symbol> transformedConstraint = requiredFilter.transform(destinationColumn -> {\n+            ColumnHandle sourceColumnHandle = inverseColumnsMapping.get(destinationColumn);\n+            if (sourceColumnHandle == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7637be1d92ee009198f89680ef2b913b325bc9c1"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1Nzk1Mg==", "bodyText": "test out re-materialisation of filter after redirection to memory onnector while also having different result than if we had queried the original table.\n\nHow do you know it rematerialized (I suppose we only select data for O)? Please add a comment.", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r525957952", "createdAt": "2020-11-18T10:00:36Z", "author": {"login": "sopel39"}, "path": "presto-tests/src/test/java/io/prestosql/tests/TestTpchTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.tests;\n+\n+import io.prestosql.plugin.memory.MemoryPlugin;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.tests.tpch.TpchQueryRunnerBuilder;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestTpchTableScanRedirection\n+        extends AbstractTestQueryFramework\n+{\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        DistributedQueryRunner queryRunner = TpchQueryRunnerBuilder.builder()\n+                .withTableScanRedirectionCatalog(\"memory\")\n+                .withTableScanRedirectionSchema(\"test\")\n+                .build();\n+        queryRunner.installPlugin(new MemoryPlugin());\n+        queryRunner.createCatalog(\"memory\", \"memory\");\n+        // Add another tpch catalog without redirection to aid in loading data into memory connector\n+        queryRunner.createCatalog(\"tpch_data_load\", \"tpch\");\n+        return queryRunner;\n+    }\n+\n+    @Test(timeOut = 20_000)\n+    public void testTableScanRedirection()\n+    {\n+        assertQuerySucceeds(\"CREATE SCHEMA memory.test\");\n+        assertUpdate(\"CREATE TABLE memory.test.orders AS SELECT * FROM tpch_data_load.tiny.orders WHERE orderstatus IN ('O', 'P')\", 7696L);\n+        assertEquals(computeActual(\"SELECT * FROM tpch.tiny.orders WHERE orderstatus IN ('O', 'F')\").getRowCount(), 7333L);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg0ODk1MA=="}, "originalCommit": null, "originalPosition": 48}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0aca274b196608b223193e8636b4a0692acc2063", "author": {"user": {"login": "raunaqmorarka", "name": "Raunaq Morarka"}}, "url": "https://github.com/trinodb/trino/commit/0aca274b196608b223193e8636b4a0692acc2063", "committedDate": "2020-11-18T10:40:10Z", "message": "Implement table scan redirection in TPCH connector"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c76c2029805c734bfbf0e5c83c46d921c7c8df7", "author": {"user": {"login": "raunaqmorarka", "name": "Raunaq Morarka"}}, "url": "https://github.com/trinodb/trino/commit/3c76c2029805c734bfbf0e5c83c46d921c7c8df7", "committedDate": "2020-11-18T10:40:15Z", "message": "Implement applyTableScanRedirect API in JdbcMetadata"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "3c76c2029805c734bfbf0e5c83c46d921c7c8df7", "author": {"user": {"login": "raunaqmorarka", "name": "Raunaq Morarka"}}, "url": "https://github.com/trinodb/trino/commit/3c76c2029805c734bfbf0e5c83c46d921c7c8df7", "committedDate": "2020-11-18T10:40:15Z", "message": "Implement applyTableScanRedirect API in JdbcMetadata"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYzNTQwNjAy", "url": "https://github.com/trinodb/trino/pull/5792#pullrequestreview-663540602", "createdAt": "2021-05-19T18:35:18Z", "commit": {"oid": "3c76c2029805c734bfbf0e5c83c46d921c7c8df7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xOVQxODozNToxOFrOJeDWSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xOVQxODozNToxOFrOJeDWSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNTQ5MTkxNA==", "bodyText": "it's not guaranteed, since ApplyTableScanRedirection and PushPredicateIntoTableScan are part of one IterativeOptimizer. Did you intend to have them as two separate optimizers? if not, i don't know how to interpret this comment", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r635491914", "createdAt": "2021-05-19T18:35:18Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/PlanOptimizers.java", "diffHunk": "@@ -537,6 +538,21 @@ public PlanOptimizers(\n                         estimatedExchangesCostCalculator,\n                         ImmutableSet.of(new TransformFilteringSemiJoinToInnerJoin()))); // must run after PredicatePushDown\n \n+        // Perform redirection before CBO rules to ensure stats from destination connector are used\n+        // Perform redirection before agg, topN, limit, sample etc. push down into table scan as the destination connector may support a different set of push downs\n+        // Perform redirection after at least one PredicatePushDown and PushPredicateIntoTableScan to allow connector to use pushed down predicates in redirection decision\n+        // Perform redirection after at least table scan pruning rules because redirected table might have fewer columns\n+        // PushPredicateIntoTableScan must be run after redirection", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c76c2029805c734bfbf0e5c83c46d921c7c8df7"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2769, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}