{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5NzA3Nzkz", "number": 3559, "title": "Accumulo type mapping cleanup", "bodyText": "Removes some unnecessary flexibility in the code, making it easier to do\nthings like #3558 in the future.", "createdAt": "2020-04-27T19:44:36Z", "url": "https://github.com/trinodb/trino/pull/3559", "merged": true, "mergeCommit": {"oid": "ad48ae06bb0969ae147faca94c00f91df3da95ac"}, "closed": true, "closedAt": "2020-05-03T20:13:58Z", "author": {"login": "findepi"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcb2CsNgH2gAyNDA5NzA3NzkzOmYxODdhNWQxZTllZDlkOTkwMTY3NzQ0YmFlMDQ2OGZhM2M5YTkyYzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcdwMOegFqTQwNDY1MDQ1NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f187a5d1e9ed9d990167744bae0468fa3c9a92c6", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/f187a5d1e9ed9d990167744bae0468fa3c9a92c6", "committedDate": "2020-04-27T21:19:51Z", "message": "Remove unused method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1dc91cecb511333138d6d15e5c92a22b948dc2f", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/e1dc91cecb511333138d6d15e5c92a22b948dc2f", "committedDate": "2020-04-27T21:19:52Z", "message": "Simplify Field#toString\n\nThe `Field`'s `toString` is complex, as if it was playing some\nconversion role, but it does not. Simplify it and make more robust\n(avoid throwing exceptions), at the cost of not producing human-readable\nstring representation of collections."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7201342984fe51084b89991ce06a831bae25ce2e", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/7201342984fe51084b89991ce06a831bae25ce2e", "committedDate": "2020-04-27T21:19:54Z", "message": "Correct constant to represent TIME"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMzUxOTAx", "url": "https://github.com/trinodb/trino/pull/3559#pullrequestreview-401351901", "createdAt": "2020-04-27T21:48:13Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df2b33a72205e73169664ab15b4807b5f4673e40", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/df2b33a72205e73169664ab15b4807b5f4673e40", "committedDate": "2020-04-28T17:45:54Z", "message": "Simplify type conversion code\n\nThe conversion code was flexible, allowing different representations for\ngiven Presto Type. This is unnecessary, as the value passed is always a\nPresto Type's stack representation."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "df2b33a72205e73169664ab15b4807b5f4673e40", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/df2b33a72205e73169664ab15b4807b5f4673e40", "committedDate": "2020-04-28T17:45:54Z", "message": "Simplify type conversion code\n\nThe conversion code was flexible, allowing different representations for\ngiven Presto Type. This is unnecessary, as the value passed is always a\nPresto Type's stack representation."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjUwNDU1", "url": "https://github.com/trinodb/trino/pull/3559#pullrequestreview-404650455", "createdAt": "2020-05-03T19:36:44Z", "commit": {"oid": "df2b33a72205e73169664ab15b4807b5f4673e40"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QxOTozNjo0NFrOGPu1jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QxOTozNjo0NFrOGPu1jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE0OTE5OA==", "bodyText": "Should we enforce the types here?\nreturn (Block) value;", "url": "https://github.com/trinodb/trino/pull/3559#discussion_r419149198", "createdAt": "2020-05-03T19:36:44Z", "author": {"login": "electrum"}, "path": "presto-accumulo/src/main/java/io/prestosql/plugin/accumulo/model/Field.java", "diffHunk": "@@ -266,279 +266,92 @@ private static boolean equals(Block block1, Block block2)\n     @Override\n     public String toString()\n     {\n-        if (value == null) {\n-            return \"null\";\n-        }\n-\n-        if (Types.isArrayType(type)) {\n-            Type elementType = Types.getElementType(type);\n-            StringBuilder builder = new StringBuilder(\"ARRAY [\");\n-            for (Object element : AccumuloRowSerializer.getArrayFromBlock(elementType, this.getArray())) {\n-                if (Types.isArrayType(elementType)) {\n-                    Type elementElementType = Types.getElementType(elementType);\n-                    builder.append(\n-                            new Field(\n-                                    AccumuloRowSerializer.getBlockFromArray(elementElementType, (List<?>) element),\n-                                    elementType))\n-                            .append(',');\n-                }\n-                else if (Types.isMapType(elementType)) {\n-                    builder.append(\n-                            new Field(\n-                                    AccumuloRowSerializer.getBlockFromMap(elementType, (Map<?, ?>) element),\n-                                    elementType))\n-                            .append(',');\n-                }\n-                else {\n-                    builder.append(new Field(element, elementType))\n-                            .append(',');\n-                }\n-            }\n-\n-            return builder.deleteCharAt(builder.length() - 1).append(\"]\").toString();\n-        }\n-\n-        if (Types.isMapType(type)) {\n-            StringBuilder builder = new StringBuilder(\"MAP(\");\n-            StringBuilder keys = new StringBuilder(\"ARRAY [\");\n-            StringBuilder values = new StringBuilder(\"ARRAY [\");\n-            for (Entry<Object, Object> entry : AccumuloRowSerializer\n-                    .getMapFromBlock(type, this.getMap()).entrySet()) {\n-                Type keyType = Types.getKeyType(type);\n-                if (Types.isArrayType(keyType)) {\n-                    keys.append(\n-                            new Field(\n-                                    AccumuloRowSerializer.getBlockFromArray(Types.getElementType(keyType), (List<?>) entry.getKey()),\n-                                    keyType))\n-                            .append(',');\n-                }\n-                else if (Types.isMapType(keyType)) {\n-                    keys.append(\n-                            new Field(\n-                                    AccumuloRowSerializer.getBlockFromMap(keyType, (Map<?, ?>) entry.getKey()),\n-                                    keyType))\n-                            .append(',');\n-                }\n-                else {\n-                    keys.append(new Field(entry.getKey(), keyType))\n-                            .append(',');\n-                }\n-\n-                Type valueType = Types.getValueType(type);\n-                if (Types.isArrayType(valueType)) {\n-                    values.append(\n-                            new Field(AccumuloRowSerializer.getBlockFromArray(Types.getElementType(valueType),\n-                                    (List<?>) entry.getValue()), valueType))\n-                            .append(',');\n-                }\n-                else if (Types.isMapType(valueType)) {\n-                    values.append(\n-                            new Field(\n-                                    AccumuloRowSerializer.getBlockFromMap(valueType, (Map<?, ?>) entry.getValue()),\n-                                    valueType))\n-                            .append(',');\n-                }\n-                else {\n-                    values.append(new Field(entry.getValue(), valueType)).append(',');\n-                }\n-            }\n-\n-            keys.deleteCharAt(keys.length() - 1).append(']');\n-            values.deleteCharAt(values.length() - 1).append(']');\n-            return builder.append(keys).append(\", \").append(values).append(\")\").toString();\n-        }\n-\n-        // Validate the object is the given type\n-        if (type.equals(BIGINT) || type.equals(BOOLEAN) || type.equals(DOUBLE) || type.equals(INTEGER) || type.equals(REAL) || type.equals(TINYINT) || type.equals(SMALLINT)) {\n-            return value.toString();\n-        }\n-        if (type.equals(DATE)) {\n-            return \"DATE '\" + value.toString() + \"'\";\n-        }\n-        if (type.equals(TIME)) {\n-            return \"TIME '\" + value.toString() + \"'\";\n-        }\n-        if (type.equals(TIMESTAMP)) {\n-            return \"TIMESTAMP '\" + value.toString() + \"'\";\n-        }\n-        if (type.equals(VARBINARY)) {\n-            return \"CAST('\" + new String((byte[]) value, UTF_8).replaceAll(\"'\", \"''\") + \"' AS VARBINARY)\";\n-        }\n-        if (type instanceof VarcharType) {\n-            return \"'\" + value.toString().replaceAll(\"'\", \"''\") + \"'\";\n-        }\n-        throw new PrestoException(NOT_SUPPORTED, \"Unsupported PrestoType \" + type);\n+        return toStringHelper(this)\n+                .add(\"value\", value)\n+                .add(\"type\", type)\n+                .toString();\n     }\n \n     /**\n-     * Does it's damnedest job to convert the given object to the given type.\n+     * Convert Presto native value (stack representation) of given type to Accumulo equivalent.\n      *\n      * @param value Object to convert\n      * @param type Destination Presto type\n-     * @return Null if null, the converted type of it could convert it, or the same value if it is fine just the way it is :D\n-     * @throws PrestoException If the given object is not any flavor of the given type\n      */\n-    private static Object cleanObject(Object value, Type type)\n+    private static Object convert(Object value, Type type)\n     {\n         if (value == null) {\n             return null;\n         }\n \n+        checkArgument(Primitives.wrap(type.getJavaType()).isInstance(value), \"Invalid representation for %s: %s [%s]\", type, value, value.getClass().getName());\n+\n         // Array? Better be a block!\n         if (Types.isArrayType(type)) {\n-            if (!(value instanceof Block)) {\n-                throw new PrestoException(FUNCTION_IMPLEMENTATION_ERROR, \"Object is not a Block, but \" + value.getClass());\n-            }\n+            // Block", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2b33a72205e73169664ab15b4807b5f4673e40"}, "originalPosition": 197}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1295, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}