{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4ODAzNzkw", "number": 2674, "reviewThreads": {"totalCount": 78, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDoyNTo0MVrOEDIPKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNToxNToxM1rOE1RO6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzE2MTM2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDoyNTo0MVrOGgAcVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMDo0NTo0M1rOGgIqiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDg3MA==", "bodyText": "Avoid abbreviations.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436214870", "createdAt": "2020-06-06T00:25:41Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -97,12 +104,19 @@ public static boolean isDynamicFilter(Expression expression)\n         }\n \n         List<Expression> arguments = functionCall.getArguments();\n-        checkArgument(arguments.size() == 2, \"invalid arguments count: %s\", arguments.size());\n+        checkArgument(arguments.size() == 3, \"invalid arguments count: %s\", arguments.size());\n+\n+        Expression probeSymbol = arguments.get(0);\n+\n+        Expression opExpression = arguments.get(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM0OTU3Ng==", "bodyText": "Fixed.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436349576", "createdAt": "2020-06-07T10:45:43Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -97,12 +104,19 @@ public static boolean isDynamicFilter(Expression expression)\n         }\n \n         List<Expression> arguments = functionCall.getArguments();\n-        checkArgument(arguments.size() == 2, \"invalid arguments count: %s\", arguments.size());\n+        checkArgument(arguments.size() == 3, \"invalid arguments count: %s\", arguments.size());\n+\n+        Expression probeSymbol = arguments.get(0);\n+\n+        Expression opExpression = arguments.get(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDg3MA=="}, "originalCommit": null, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzE2MjA4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDoyNjoyNVrOGgAcuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMDo0NTo0OFrOGgIqjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDk2OQ==", "bodyText": "Avoid abbreviations: op -> operator", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436214969", "createdAt": "2020-06-06T00:26:25Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -187,35 +210,35 @@ private Function() {}\n \n         @TypeParameter(\"T\")\n         @SqlType(BOOLEAN)\n-        public static boolean dynamicFilter(@SqlType(VARCHAR) Slice id, @SqlType(\"T\") Block input)\n+        public static boolean dynamicFilter(@SqlType(\"T\") Block input, @SqlType(VARCHAR) Slice op, @SqlType(VARCHAR) Slice id)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM0OTU4MA==", "bodyText": "Fixed.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436349580", "createdAt": "2020-06-07T10:45:48Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -187,35 +210,35 @@ private Function() {}\n \n         @TypeParameter(\"T\")\n         @SqlType(BOOLEAN)\n-        public static boolean dynamicFilter(@SqlType(VARCHAR) Slice id, @SqlType(\"T\") Block input)\n+        public static boolean dynamicFilter(@SqlType(\"T\") Block input, @SqlType(VARCHAR) Slice op, @SqlType(VARCHAR) Slice id)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDk2OQ=="}, "originalCommit": null, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzE2NDQyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDoyOToxN1rOGgAeCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMDo0NTo1NVrOGgIqoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTMwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        createDynamicFilter(buildSource, node, context, partitionCount).ifPresent(\n          \n          \n            \n                                filter -> factoriesBuilder.add(createDynamicFilterSourceOperatorFactory(filter, node, buildSource, buildContext)));\n          \n          \n            \n                        createDynamicFilter(buildSource, node, context, partitionCount)\n          \n          \n            \n                            .ifPresent(filter -> factoriesBuilder.add(createDynamicFilterSourceOperatorFactory(filter, node, buildSource, buildContext)));", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436215306", "createdAt": "2020-06-06T00:29:17Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -1812,14 +1812,19 @@ private PhysicalOperation createNestedLoopJoin(JoinNode node, LocalExecutionPlan\n                     node.getId(),\n                     nestedLoopJoinBridgeManager);\n \n-            checkArgument(buildContext.getDriverInstanceCount().orElse(1) == 1, \"Expected local execution to not be parallel\");\n+            int partitionCount = buildContext.getDriverInstanceCount().orElse(1);\n+            checkArgument(partitionCount == 1, \"Expected local execution to not be parallel\");\n+\n+            ImmutableList.Builder<OperatorFactory> factoriesBuilder = ImmutableList.builder();\n+            factoriesBuilder.addAll(buildSource.getOperatorFactories());\n+            createDynamicFilter(buildSource, node, context, partitionCount).ifPresent(\n+                    filter -> factoriesBuilder.add(createDynamicFilterSourceOperatorFactory(filter, node, buildSource, buildContext)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM0OTYwMA==", "bodyText": "Fixed.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436349600", "createdAt": "2020-06-07T10:45:55Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -1812,14 +1812,19 @@ private PhysicalOperation createNestedLoopJoin(JoinNode node, LocalExecutionPlan\n                     node.getId(),\n                     nestedLoopJoinBridgeManager);\n \n-            checkArgument(buildContext.getDriverInstanceCount().orElse(1) == 1, \"Expected local execution to not be parallel\");\n+            int partitionCount = buildContext.getDriverInstanceCount().orElse(1);\n+            checkArgument(partitionCount == 1, \"Expected local execution to not be parallel\");\n+\n+            ImmutableList.Builder<OperatorFactory> factoriesBuilder = ImmutableList.builder();\n+            factoriesBuilder.addAll(buildSource.getOperatorFactories());\n+            createDynamicFilter(buildSource, node, context, partitionCount).ifPresent(\n+                    filter -> factoriesBuilder.add(createDynamicFilterSourceOperatorFactory(filter, node, buildSource, buildContext)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTMwNg=="}, "originalCommit": null, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzE2NTMzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDozMDoyMVrOGgAejQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMDo0NjowM1rOGgIqqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTQzNw==", "bodyText": "Remove final", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436215437", "createdAt": "2020-06-06T00:30:21Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -470,13 +480,20 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             // Create new projections for the new join clauses\n             List<JoinNode.EquiJoinClause> equiJoinClauses = new ArrayList<>();\n             ImmutableList.Builder<Expression> joinFilterBuilder = ImmutableList.builder();\n+            ImmutableList.Builder<ComparisonExpression> dynamicFilteringClauses = ImmutableList.builder();\n             for (Expression conjunct : extractConjuncts(newJoinPredicate)) {\n-                if (joinEqualityExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols())) {\n-                    ComparisonExpression equality = (ComparisonExpression) conjunct;\n-\n-                    boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(equality.getLeft()));\n-                    Expression leftExpression = (alignedComparison) ? equality.getLeft() : equality.getRight();\n-                    Expression rightExpression = (alignedComparison) ? equality.getRight() : equality.getLeft();\n+                final boolean isComparison = joinComparisonExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM0OTYwOQ==", "bodyText": "Fixed.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436349609", "createdAt": "2020-06-07T10:46:03Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -470,13 +480,20 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             // Create new projections for the new join clauses\n             List<JoinNode.EquiJoinClause> equiJoinClauses = new ArrayList<>();\n             ImmutableList.Builder<Expression> joinFilterBuilder = ImmutableList.builder();\n+            ImmutableList.Builder<ComparisonExpression> dynamicFilteringClauses = ImmutableList.builder();\n             for (Expression conjunct : extractConjuncts(newJoinPredicate)) {\n-                if (joinEqualityExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols())) {\n-                    ComparisonExpression equality = (ComparisonExpression) conjunct;\n-\n-                    boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(equality.getLeft()));\n-                    Expression leftExpression = (alignedComparison) ? equality.getLeft() : equality.getRight();\n-                    Expression rightExpression = (alignedComparison) ? equality.getRight() : equality.getLeft();\n+                final boolean isComparison = joinComparisonExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTQzNw=="}, "originalCommit": null, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzE2NzQzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDozMjozNlrOGgAfsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMDo0NjoxOFrOGgIquw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTcyOA==", "bodyText": "Remove final", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436215728", "createdAt": "2020-06-06T00:32:36Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -470,13 +480,20 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             // Create new projections for the new join clauses\n             List<JoinNode.EquiJoinClause> equiJoinClauses = new ArrayList<>();\n             ImmutableList.Builder<Expression> joinFilterBuilder = ImmutableList.builder();\n+            ImmutableList.Builder<ComparisonExpression> dynamicFilteringClauses = ImmutableList.builder();\n             for (Expression conjunct : extractConjuncts(newJoinPredicate)) {\n-                if (joinEqualityExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols())) {\n-                    ComparisonExpression equality = (ComparisonExpression) conjunct;\n-\n-                    boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(equality.getLeft()));\n-                    Expression leftExpression = (alignedComparison) ? equality.getLeft() : equality.getRight();\n-                    Expression rightExpression = (alignedComparison) ? equality.getRight() : equality.getLeft();\n+                final boolean isComparison = joinComparisonExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols());\n+                if (!isComparison) {\n+                    joinFilterBuilder.add(conjunct);\n+                    continue;\n+                }\n+                ComparisonExpression comparison = (ComparisonExpression) conjunct;\n+                final boolean isEquality = comparison.getOperator() == ComparisonExpression.Operator.EQUAL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM0OTYyNw==", "bodyText": "Fixed.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436349627", "createdAt": "2020-06-07T10:46:18Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -470,13 +480,20 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             // Create new projections for the new join clauses\n             List<JoinNode.EquiJoinClause> equiJoinClauses = new ArrayList<>();\n             ImmutableList.Builder<Expression> joinFilterBuilder = ImmutableList.builder();\n+            ImmutableList.Builder<ComparisonExpression> dynamicFilteringClauses = ImmutableList.builder();\n             for (Expression conjunct : extractConjuncts(newJoinPredicate)) {\n-                if (joinEqualityExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols())) {\n-                    ComparisonExpression equality = (ComparisonExpression) conjunct;\n-\n-                    boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(equality.getLeft()));\n-                    Expression leftExpression = (alignedComparison) ? equality.getLeft() : equality.getRight();\n-                    Expression rightExpression = (alignedComparison) ? equality.getRight() : equality.getLeft();\n+                final boolean isComparison = joinComparisonExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols());\n+                if (!isComparison) {\n+                    joinFilterBuilder.add(conjunct);\n+                    continue;\n+                }\n+                ComparisonExpression comparison = (ComparisonExpression) conjunct;\n+                final boolean isEquality = comparison.getOperator() == ComparisonExpression.Operator.EQUAL;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTcyOA=="}, "originalCommit": null, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzY4MzM4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzoyNjoyNlrOHV58dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzoyNjoyNlrOHV58dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjczMTUxMQ==", "bodyText": "nit: opString -> operatorExpressionString", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492731511", "createdAt": "2020-09-22T13:26:26Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -99,12 +107,19 @@ public static boolean isDynamicFilter(Expression expression)\n         }\n \n         List<Expression> arguments = functionCall.getArguments();\n-        checkArgument(arguments.size() == 2, \"invalid arguments count: %s\", arguments.size());\n+        checkArgument(arguments.size() == 3, \"invalid arguments count: %s\", arguments.size());\n+\n+        Expression probeSymbol = arguments.get(0);\n \n-        Expression firstArgument = arguments.get(0);\n-        checkArgument(firstArgument instanceof StringLiteral, \"firstArgument is expected to be an instance of StringLiteral: %s\", firstArgument.getClass().getSimpleName());\n-        String id = ((StringLiteral) firstArgument).getValue();\n-        return Optional.of(new Descriptor(new DynamicFilterId(id), arguments.get(1)));\n+        Expression operatorExpression = arguments.get(1);\n+        checkArgument(operatorExpression instanceof StringLiteral, \"op is expected to be an instance of StringLiteral: %s\", operatorExpression.getClass().getSimpleName());\n+        String opString = ((StringLiteral) operatorExpression).getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzY5MjIxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzoyODowOFrOHV6Bww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzoyODowOFrOHV6Bww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjczMjg2Nw==", "bodyText": "nit: op -> operatorExpression", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492732867", "createdAt": "2020-09-22T13:28:08Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -99,12 +107,19 @@ public static boolean isDynamicFilter(Expression expression)\n         }\n \n         List<Expression> arguments = functionCall.getArguments();\n-        checkArgument(arguments.size() == 2, \"invalid arguments count: %s\", arguments.size());\n+        checkArgument(arguments.size() == 3, \"invalid arguments count: %s\", arguments.size());\n+\n+        Expression probeSymbol = arguments.get(0);\n \n-        Expression firstArgument = arguments.get(0);\n-        checkArgument(firstArgument instanceof StringLiteral, \"firstArgument is expected to be an instance of StringLiteral: %s\", firstArgument.getClass().getSimpleName());\n-        String id = ((StringLiteral) firstArgument).getValue();\n-        return Optional.of(new Descriptor(new DynamicFilterId(id), arguments.get(1)));\n+        Expression operatorExpression = arguments.get(1);\n+        checkArgument(operatorExpression instanceof StringLiteral, \"op is expected to be an instance of StringLiteral: %s\", operatorExpression.getClass().getSimpleName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Mzc0OTM1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzo0MDoxMlrOHV6k0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMToyOToxNFrOHWnd4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc0MTg0MQ==", "bodyText": "Could this be toImmutableListMultimap  instead ? Are duplicate Descriptor possible here ?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492741841", "createdAt": "2020-09-22T13:40:12Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ3NzM0Ng==", "bodyText": "IIUC, it may only happen if the same DF function appears twice in the filter expression:\nhttps://github.com/prestosql/presto/blob/8c6901c0c94593c9e5f1d65ea471697248f44dc0/presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java#L1370\nI think that this should not happen - so I changed the code to use toImmutableListMultimap.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r493477346", "createdAt": "2020-09-23T11:29:14Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc0MTg0MQ=="}, "originalCommit": null, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzgwNDUwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzo1MToyMFrOHV7HOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMToxNTowM1rOHWmskA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1MDY1MA==", "bodyText": "Can we ever reach here for a non-orderable type or does the planner disallow queries which contain comparison operator on a non-orderable type ?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492750650", "createdAt": "2020-09-22T13:51:20Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2NDcyMA==", "bodyText": "IIUC, it should fail during the analysis phase - I tested the following:\nCREATE TABLE t0 (k0 color, v0 real);\nCREATE TABLE t1 (k1 color, v1 real);\nSELECT v0, v1 FROM t0, t1 WHERE k0 < k1;\nAnd it failed with:\nCaused by: io.prestosql.spi.PrestoException: line 1:37: Cannot apply operator: color < color\n\tat io.prestosql.sql.analyzer.SemanticExceptions.semanticException(SemanticExceptions.java:48)\n\tat io.prestosql.sql.analyzer.SemanticExceptions.semanticException(SemanticExceptions.java:43)\n\tat io.prestosql.sql.analyzer.ExpressionAnalyzer$Visitor.getOperator(ExpressionAnalyzer.java:1479)", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r493464720", "createdAt": "2020-09-23T11:15:03Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1MDY1MA=="}, "originalCommit": null, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzgyNzU0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzo1NTo0OVrOHV7VcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzo1NTo0OVrOHV7VcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1NDI4OQ==", "bodyText": "Do we need to get an ordered range here or can we use  domain.getValues().getRanges().getSpan() , then get low or high value from that ?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492754289", "createdAt": "2020-09-22T13:55:49Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Mzg0OTk2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDowMDowNVrOHV7jSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMTowMzo1OVrOHWmHKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1NzgzMw==", "bodyText": "I think these functions could be moved to Range.java", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492757833", "createdAt": "2020-09-22T14:00:05Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case LESS_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanOrEqualRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanOrEqualRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported dynamic filtering comparison operator: \" + operator);\n+        }\n+    }\n+\n+    private static Range lessThanRange(Marker high)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NTE0Ng==", "bodyText": "Refactored according to #2674 (comment).", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r493455146", "createdAt": "2020-09-23T11:03:59Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case LESS_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanOrEqualRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanOrEqualRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported dynamic filtering comparison operator: \" + operator);\n+        }\n+    }\n+\n+    private static Range lessThanRange(Marker high)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1NzgzMw=="}, "originalCommit": null, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Mzg1Mzk0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDowMDo0N1rOHV7ljg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMTo1NToxN1rOHjnz_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1ODQxNA==", "bodyText": "This could move to Domain.java", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492758414", "createdAt": "2020-09-22T14:00:47Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NDQ1Nw==", "bodyText": "I agree, but then ComparisonExpression.Operator needs to be exposed to presto-spi (which contains Domain.java) - so I will leave it here for now.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r493454457", "createdAt": "2020-09-23T11:03:03Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1ODQxNA=="}, "originalCommit": null, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxMjQ4Ng==", "bodyText": "Could we move it into ExpressionUtils then ? I think we'll want to use this function eventually from DynamicFilterService as well, so it'll be good to pull it out of this class.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495712486", "createdAt": "2020-09-28T06:24:14Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1ODQxNA=="}, "originalCommit": null, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzExNDQ5Mg==", "bodyText": "I moved it to DynamicFilters.Descriptor#applyComparison... is it OK?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507114492", "createdAt": "2020-10-18T11:55:17Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1ODQxNA=="}, "originalCommit": null, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Mzg4MzgxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDowNjo0NlrOHV73iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDowNjo0NlrOHV73iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc2MzAxNg==", "bodyText": "Could we simply return domain ?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492763016", "createdAt": "2020-09-22T14:06:46Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzkwNjk3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDoxMToxOVrOHV8FrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDoxMToxOVrOHV8FrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc2NjYzNw==", "bodyText": "Could use Marker.above", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492766637", "createdAt": "2020-09-22T14:11:19Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case LESS_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanOrEqualRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanOrEqualRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported dynamic filtering comparison operator: \" + operator);\n+        }\n+    }\n+\n+    private static Range lessThanRange(Marker high)\n+    {\n+        return new Range(\n+                Marker.lowerUnbounded(high.getType()),\n+                new Marker(high.getType(), high.getValueBlock(), Marker.Bound.BELOW));\n+    }\n+\n+    private static Range lessThanOrEqualRange(Marker high)\n+    {\n+        return new Range(Marker.lowerUnbounded(high.getType()), high);\n+    }\n+\n+    private static Range greaterThanRange(Marker low)\n+    {\n+        return new Range(\n+                new Marker(low.getType(), low.getValueBlock(), Marker.Bound.ABOVE),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzkwOTU1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDoxMTo1MFrOHV8HRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDoxMTo1MFrOHV8HRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc2NzA0Nw==", "bodyText": "Could use Marker.below", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492767047", "createdAt": "2020-09-22T14:11:50Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case LESS_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanOrEqualRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanOrEqualRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported dynamic filtering comparison operator: \" + operator);\n+        }\n+    }\n+\n+    private static Range lessThanRange(Marker high)\n+    {\n+        return new Range(\n+                Marker.lowerUnbounded(high.getType()),\n+                new Marker(high.getType(), high.getValueBlock(), Marker.Bound.BELOW));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzkxNzIwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDoxMzoxOVrOHV8L4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDoxMzoxOVrOHV8L4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc2ODIyNQ==", "bodyText": "Could we use Marker#getValue to get Object and then just reuse the existing functions in Range.java ?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492768225", "createdAt": "2020-09-22T14:13:19Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case LESS_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanOrEqualRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanOrEqualRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported dynamic filtering comparison operator: \" + operator);\n+        }\n+    }\n+\n+    private static Range lessThanRange(Marker high)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzE0MjU5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjoyNjozNFrOHYv8Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjoyNjozNFrOHYv8Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxMzMyNw==", "bodyText": "nit: rename to dynamicFilteringSupportedExpressions", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495713327", "createdAt": "2020-09-28T06:26:34Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -99,6 +103,13 @@\n public class PredicatePushDown\n         implements PlanOptimizer\n {\n+    private static final Set<ComparisonExpression.Operator> supportedComparisonOperators = ImmutableSet.of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzE0NzM1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/planprinter/PlanPrinter.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjoyODo0MVrOHYv_DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNTowNDo0OFrOHlBxow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNDA2MA==", "bodyText": "Could you paste an example of what the explain output looks like after this change ?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495714060", "createdAt": "2020-09-28T06:28:41Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/planprinter/PlanPrinter.java", "diffHunk": "@@ -820,14 +820,14 @@ private Void visitScanFilterAndProjectInfo(\n         private String printDynamicFilters(Collection<DynamicFilters.Descriptor> filters)\n         {\n             return filters.stream()\n-                    .map(filter -> filter.getId() + \" -> \" + filter.getInput())\n+                    .map(filter -> filter.getInput() + \" \" + filter.getOperator().getValue() + \" #\" + filter.getId())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUxNjY3NQ==", "bodyText": "EXPLAIN SELECT l.comment FROM  lineitem l, part p \n  WHERE p.partkey > l.partkey AND p.comment = 'onic deposits'\nresults in:\nFragment 0 [SINGLE]\n    Output layout: [comment]\n    Output partitioning: SINGLE []\n    Stage Execution Strategy: UNGROUPED_EXECUTION\n    Output[comment]\n    \u2502   Layout: [comment:varchar(44)]\n    \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n    \u2514\u2500 RemoteSource[1]\n           Layout: [comment:varchar(44)]\n\nFragment 1 [SOURCE]\n    Output layout: [comment]\n\n    Output partitioning: SINGLE []\n    Stage Execution Strategy: UNGROUPED_EXECUTION\n    FilterProject[filterPredicate = (\"partkey\" < \"partkey_0\")]\n    \u2502   Layout: [comment:varchar(44)]\n    \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}/{rows: ? (?), cpu: ?, memory: ?, network: ?}\n    \u2514\u2500 CrossJoin\n       \u2502   Layout: [partkey:bigint, comment:varchar(44), partkey_0:bigint]\n       \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n       \u2502   Distribution: REPLICATED\n       \u2502   dynamicFilterAssignments = {partkey_0 -> #df_350}\n       \u251c\u2500 ScanFilter[table = memory:2, grouped = false, filterPredicate = true, dynamicFilter = {\"partkey\" < #df_350}]\n       \u2502      Layout: [partkey:bigint, comment:varchar(44)]\n       \u2502      Estimates: {rows: ? (?), cpu: ?, memory: 0B, network: 0B}/{rows: ? (?), cpu: ?, memory: 0B, network: 0B}\n       \u2502      partkey := 1\n       \u2502      comment := 15\n       \u2514\u2500 LocalExchange[SINGLE] ()\n          \u2502   Layout: [partkey_0:bigint]\n          \u2502   Estimates: {rows: ? (?), cpu: ?, memory: 0B, network: ?}\n          \u2514\u2500 RemoteSource[2]\n                 Layout: [partkey_0:bigint]\n\nFragment 2 [SOURCE]\n    Output layout: [partkey_0]\n    Output partitioning: BROADCAST []\n    Stage Execution Strategy: UNGROUPED_EXECUTION\n    ScanFilterProject[table = memory:3, grouped = false, filterPredicate = (\"comment_1\" = CAST('onic deposits' AS varchar(23)))]\n        Layout: [partkey_0:bigint]\n        Estimates: {rows: ? (?), cpu: ?, memory: 0B, network: 0B}/{rows: ? (?), cpu: ?, memory: 0B, network: 0B}/{rows: ? (?), cpu: ?, memory: 0B, network: 0B}\n        comment_1 := 8\n        partkey_0 := 0", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r497516675", "createdAt": "2020-09-30T13:39:00Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/planprinter/PlanPrinter.java", "diffHunk": "@@ -820,14 +820,14 @@ private Void visitScanFilterAndProjectInfo(\n         private String printDynamicFilters(Collection<DynamicFilters.Descriptor> filters)\n         {\n             return filters.stream()\n-                    .map(filter -> filter.getId() + \" -> \" + filter.getInput())\n+                    .map(filter -> filter.getInput() + \" \" + filter.getOperator().getValue() + \" #\" + filter.getId())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNDA2MA=="}, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4MjIzMg==", "bodyText": "this requires doc update", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507682232", "createdAt": "2020-10-19T11:47:38Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/planprinter/PlanPrinter.java", "diffHunk": "@@ -820,14 +820,14 @@ private Void visitScanFilterAndProjectInfo(\n         private String printDynamicFilters(Collection<DynamicFilters.Descriptor> filters)\n         {\n             return filters.stream()\n-                    .map(filter -> filter.getId() + \" -> \" + filter.getInput())\n+                    .map(filter -> filter.getInput() + \" \" + filter.getOperator().getValue() + \" #\" + filter.getId())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNDA2MA=="}, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU4ODQ1MQ==", "bodyText": "Updated presto-docs/src/main/sphinx/admin/dynamic-filtering.rst.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r508588451", "createdAt": "2020-10-20T15:04:48Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/planprinter/PlanPrinter.java", "diffHunk": "@@ -820,14 +820,14 @@ private Void visitScanFilterAndProjectInfo(\n         private String printDynamicFilters(Collection<DynamicFilters.Descriptor> filters)\n         {\n             return filters.stream()\n-                    .map(filter -> filter.getId() + \" -> \" + filter.getInput())\n+                    .map(filter -> filter.getInput() + \" \" + filter.getOperator().getValue() + \" #\" + filter.getId())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNDA2MA=="}, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzE1Mzg5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozMToyNFrOHYwC3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozMToyNFrOHYwC3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNTAzNg==", "bodyText": "You should be able to match for dynamic filter as well using something like ImmutableMap.of(\"O_COMMENT\", \"L_COMMENT\")", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495715036", "createdAt": "2020-09-28T06:31:24Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -94,6 +94,37 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey < l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY < L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                node(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzE1ODk3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozMzozM1rOHYwFzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMzoyNzoyOVrOHade5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNTc5MA==", "bodyText": "Is CAST missing in the query ?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495715790", "createdAt": "2020-09-28T06:33:33Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -94,6 +94,37 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey < l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY < L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                node(\n+                                        FilterNode.class,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))),\n+                                exchange(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")))))));\n+    }\n+\n+    @Test\n+    public void testCrossJoinInequalityDFWithCast()\n+    {\n+        assertPlan(\"SELECT o.comment, l.comment FROM orders o, lineitem l WHERE o.comment < l.comment\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUwODA3MA==", "bodyText": "I think that it is added (implicitly) since l.comment and o.comment have different sizes.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r497508070", "createdAt": "2020-09-30T13:27:29Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -94,6 +94,37 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey < l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY < L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                node(\n+                                        FilterNode.class,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))),\n+                                exchange(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")))))));\n+    }\n+\n+    @Test\n+    public void testCrossJoinInequalityDFWithCast()\n+    {\n+        assertPlan(\"SELECT o.comment, l.comment FROM orders o, lineitem l WHERE o.comment < l.comment\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNTc5MA=="}, "originalCommit": null, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzE2MzgzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozNToyMVrOHYwIhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozNToyMVrOHYwIhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNjQ4NA==", "bodyText": "We could add the parameter to match dynamic filters as well here", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495716484", "createdAt": "2020-09-28T06:35:21Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -298,7 +298,9 @@ public void testDistinctLimitOverInequalityJoin()\n                                 anyTree(\n                                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n                                                 join(INNER, ImmutableList.of(), Optional.empty(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzE2NDc1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozNTo0N1rOHYwJDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozNTo0N1rOHYwJDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNjYyMQ==", "bodyText": "Same as above", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495716621", "createdAt": "2020-09-28T06:35:47Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -341,7 +343,9 @@ public void testInnerInequalityJoinNoEquiJoinConjuncts()\n                 anyTree(\n                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n                                 join(INNER, ImmutableList.of(), Optional.empty(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzE2NjA5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozNjoxOFrOHYwJ1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozNjoxOFrOHYwJ1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNjgyMg==", "bodyText": "Same as above", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495716822", "createdAt": "2020-09-28T06:36:18Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -369,7 +373,9 @@ public void testLeftConvertedToInnerInequalityJoinNoEquiJoinConjuncts()\n                 anyTree(\n                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n                                 join(INNER, ImmutableList.of(), Optional.empty(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzI0MTE4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNToyODoyN1rOHiNmpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMDo0ODo0MVrOHjmWVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNjUxNw==", "bodyText": "We should have support for ineq joins in DynamicFilterService too. If it's added in next commit, lets remove this one.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r505636517", "createdAt": "2020-10-15T15:28:27Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -420,7 +420,12 @@ private void collectDynamicFilters(StageId stageId, Optional<Set<DynamicFilterId\n     private static Set<DynamicFilterId> getDynamicFiltersProducedInPlanNode(PlanNode planNode)\n     {\n         if (planNode instanceof JoinNode) {\n-            return ((JoinNode) planNode).getDynamicFilters().keySet();\n+            JoinNode joinNode = (JoinNode) planNode;\n+            if (joinNode.isCrossJoin()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA5MDUxOQ==", "bodyText": "Added DynamicFilterService support.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507090519", "createdAt": "2020-10-18T10:48:41Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -420,7 +420,12 @@ private void collectDynamicFilters(StageId stageId, Optional<Set<DynamicFilterId\n     private static Set<DynamicFilterId> getDynamicFiltersProducedInPlanNode(PlanNode planNode)\n     {\n         if (planNode instanceof JoinNode) {\n-            return ((JoinNode) planNode).getDynamicFilters().keySet();\n+            JoinNode joinNode = (JoinNode) planNode;\n+            if (joinNode.isCrossJoin()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNjUxNw=="}, "originalCommit": null, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzI0OTYxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/server/TestDynamicFilterService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNTozMDowOVrOHiNrmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMDo0NjowNlrOHjmS8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNzc4Nw==", "bodyText": "why we need this?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r505637787", "createdAt": "2020-10-15T15:30:09Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/server/TestDynamicFilterService.java", "diffHunk": "@@ -594,7 +594,7 @@ private static PlanFragment createPlan(DynamicFilterId dynamicFilterId, Partitio\n                         INNER,\n                         filterNode,\n                         remote,\n-                        ImmutableList.of(),\n+                        ImmutableList.of(new JoinNode.EquiJoinClause(symbol, buildSymbol)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA4OTY1MA==", "bodyText": "Removed.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507089650", "createdAt": "2020-10-18T10:46:06Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/test/java/io/prestosql/server/TestDynamicFilterService.java", "diffHunk": "@@ -594,7 +594,7 @@ private static PlanFragment createPlan(DynamicFilterId dynamicFilterId, Partitio\n                         INNER,\n                         filterNode,\n                         remote,\n-                        ImmutableList.of(),\n+                        ImmutableList.of(new JoinNode.EquiJoinClause(symbol, buildSymbol)),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNzc4Nw=="}, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzI1MDM1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/execution/scheduler/TestSourcePartitionedScheduler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNTozMDoxOVrOHiNsEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMDo0NjowMlrOHjmS4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNzkwNw==", "bodyText": "why we need this?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r505637907", "createdAt": "2020-10-15T15:30:19Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/execution/scheduler/TestSourcePartitionedScheduler.java", "diffHunk": "@@ -571,7 +571,7 @@ private static StageExecutionPlan createPlan(ConnectorSplitSource splitSource)\n                         INNER,\n                         filterNode,\n                         remote,\n-                        ImmutableList.of(),\n+                        ImmutableList.of(new JoinNode.EquiJoinClause(symbol, buildSymbol)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA4OTYzMg==", "bodyText": "Removed.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507089632", "createdAt": "2020-10-18T10:46:02Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/test/java/io/prestosql/execution/scheduler/TestSourcePartitionedScheduler.java", "diffHunk": "@@ -571,7 +571,7 @@ private static StageExecutionPlan createPlan(ConnectorSplitSource splitSource)\n                         INNER,\n                         filterNode,\n                         remote,\n-                        ImmutableList.of(),\n+                        ImmutableList.of(new JoinNode.EquiJoinClause(symbol, buildSymbol)),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNzkwNw=="}, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzI2OTY1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNTozNDoyM1rOHiN34g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMTo1MjoxNlrOHjnvxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0MDkzMA==", "bodyText": "please add support to DynamicFilterService too", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r505640930", "createdAt": "2020-10-15T15:34:23Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -20,8 +20,11 @@\n import io.prestosql.spi.connector.ColumnHandle;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA5MDYxNw==", "bodyText": "Added DynamicFilterService support.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507090617", "createdAt": "2020-10-18T10:48:59Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -20,8 +20,11 @@\n import io.prestosql.spi.connector.ColumnHandle;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0MDkzMA=="}, "originalCommit": null, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzExMzQxMg==", "bodyText": "Just to be sure - I had to add the following line to support cross-joins:\nhttps://github.com/prestosql/presto/blob/6323d03a2ed123a77f5e62415f5d3b8a7c7c7552/presto-main/src/main/java/io/prestosql/operator/JoinUtils.java#L71\nIs it OK?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507113412", "createdAt": "2020-10-18T11:52:16Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -20,8 +20,11 @@\n import io.prestosql.spi.connector.ColumnHandle;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0MDkzMA=="}, "originalCommit": null, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzI3NTk2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNTozNTo0M1rOHiN7uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMDo0ODo0OVrOHjmWgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0MTkxNQ==", "bodyText": "static import EQUAL", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r505641915", "createdAt": "2020-10-15T15:35:43Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -46,21 +47,28 @@\n {\n     private DynamicFilters() {}\n \n-    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, SymbolReference input)\n+    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, SymbolReference input, ComparisonExpression.Operator operator)\n     {\n-        return createDynamicFilterExpression(metadata, id, inputType, (Expression) input);\n+        return createDynamicFilterExpression(metadata, id, inputType, (Expression) input, operator);\n     }\n \n     @VisibleForTesting\n-    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, Expression input)\n+    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, Expression input, ComparisonExpression.Operator operator)\n     {\n         return new FunctionCallBuilder(metadata)\n                 .setName(QualifiedName.of(Function.NAME))\n-                .addArgument(VarcharType.VARCHAR, new StringLiteral(id.toString()))\n                 .addArgument(inputType, input)\n+                .addArgument(VarcharType.VARCHAR, new StringLiteral(operator.toString()))\n+                .addArgument(VarcharType.VARCHAR, new StringLiteral(id.toString()))\n                 .build();\n     }\n \n+    @VisibleForTesting\n+    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, Expression input)\n+    {\n+        return createDynamicFilterExpression(metadata, id, inputType, input, ComparisonExpression.Operator.EQUAL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA5MDU2Mg==", "bodyText": "Fixed.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507090562", "createdAt": "2020-10-18T10:48:49Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -46,21 +47,28 @@\n {\n     private DynamicFilters() {}\n \n-    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, SymbolReference input)\n+    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, SymbolReference input, ComparisonExpression.Operator operator)\n     {\n-        return createDynamicFilterExpression(metadata, id, inputType, (Expression) input);\n+        return createDynamicFilterExpression(metadata, id, inputType, (Expression) input, operator);\n     }\n \n     @VisibleForTesting\n-    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, Expression input)\n+    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, Expression input, ComparisonExpression.Operator operator)\n     {\n         return new FunctionCallBuilder(metadata)\n                 .setName(QualifiedName.of(Function.NAME))\n-                .addArgument(VarcharType.VARCHAR, new StringLiteral(id.toString()))\n                 .addArgument(inputType, input)\n+                .addArgument(VarcharType.VARCHAR, new StringLiteral(operator.toString()))\n+                .addArgument(VarcharType.VARCHAR, new StringLiteral(id.toString()))\n                 .build();\n     }\n \n+    @VisibleForTesting\n+    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, Expression input)\n+    {\n+        return createDynamicFilterExpression(metadata, id, inputType, input, ComparisonExpression.Operator.EQUAL);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0MTkxNQ=="}, "originalCommit": null, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3OTU4NTg1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/JoinUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwOTozNjowN1rOHkF7Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwOTozNjowN1rOHkF7Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYwNzg5NA==", "bodyText": "Add a comment that it's used in cross join case", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507607894", "createdAt": "2020-10-19T09:36:07Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/JoinUtils.java", "diffHunk": "@@ -67,7 +67,8 @@ public static boolean isBuildSideReplicated(PlanNode node)\n             return PlanNodeSearcher.searchFrom(((JoinNode) node).getRight())\n                     .recurseOnlyWhen(\n                             MorePredicates.<PlanNode>isInstanceOfAny(ProjectNode.class)\n-                                    .or(JoinUtils::isLocalRepartitionExchange))\n+                                    .or(JoinUtils::isLocalRepartitionExchange)\n+                                    .or(JoinUtils::isLocalGatherExchange))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MDAzMTM3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMTozNzozMFrOHkKIyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMTozNzozMFrOHkKIyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3Njg3NA==", "bodyText": "static static import (if possible)", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507676874", "createdAt": "2020-10-19T11:37:30Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -100,6 +103,13 @@\n public class PredicatePushDown\n         implements PlanOptimizer\n {\n+    private static final Set<ComparisonExpression.Operator> dynamicFilteringSupportedExpressions = ImmutableSet.of(\n+            ComparisonExpression.Operator.EQUAL,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MDAzMjM2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMTozNzo0NlrOHkKJWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMTozNzo0NlrOHkKJWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3NzAxNw==", "bodyText": "rename to:\nDYNAMIC_FILTERING_SUPPORTED_EXPRESSIONS", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507677017", "createdAt": "2020-10-19T11:37:46Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -100,6 +103,13 @@\n public class PredicatePushDown\n         implements PlanOptimizer\n {\n+    private static final Set<ComparisonExpression.Operator> dynamicFilteringSupportedExpressions = ImmutableSet.of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MDA1NzM3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMTo0NTowOVrOHkKYig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwODo1MjozMFrOHlhRYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4MDkwNg==", "bodyText": "please pass newJoinFilter instead", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507680906", "createdAt": "2020-10-19T11:45:09Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -501,21 +518,30 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n                         rightProjections.put(rightSymbol, rightExpression);\n                     }\n \n-                    equiJoinClauses.add(new JoinNode.EquiJoinClause(leftSymbol, rightSymbol));\n+                    ComparisonExpression.Operator operator = alignedComparison ? comparison.getOperator() : comparison.getOperator().flip();\n+                    ComparisonExpression filter = new ComparisonExpression(operator, leftSymbol.toSymbolReference(), rightSymbol.toSymbolReference());\n+                    dynamicFilteringClauses.add(filter);\n+                    if (isEquality) {\n+                        equiJoinClauses.add(new JoinNode.EquiJoinClause(leftSymbol, rightSymbol));\n+                    }\n+                    else {\n+                        joinFilterBuilder.add(filter);\n+                    }\n                 }\n                 else {\n+                    // Inequality join predicate && dynamic filtering is disabled.\n                     joinFilterBuilder.add(conjunct);\n                 }\n             }\n \n-            DynamicFiltersResult dynamicFiltersResult = createDynamicFilters(node, equiJoinClauses, session, idAllocator);\n+            DynamicFiltersResult dynamicFiltersResult = createDynamicFilters(node, dynamicFilteringClauses.build(), session, idAllocator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU4NzIyMQ==", "bodyText": "I think that newJoinFilter would contain only the inequality predicates - but createDynamicFilters needs also the equi-join predicates. For example, consider the following query:\nSELECT * FROM L, R WHERE L.x = R.x AND L.y < R.y;\nIn this case, createDynamicFilters needs L.x = R.x AND L.y < R.y but newJoinFilter will contain only L.y < R.y, IIUC.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r508587221", "createdAt": "2020-10-20T15:03:11Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -501,21 +518,30 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n                         rightProjections.put(rightSymbol, rightExpression);\n                     }\n \n-                    equiJoinClauses.add(new JoinNode.EquiJoinClause(leftSymbol, rightSymbol));\n+                    ComparisonExpression.Operator operator = alignedComparison ? comparison.getOperator() : comparison.getOperator().flip();\n+                    ComparisonExpression filter = new ComparisonExpression(operator, leftSymbol.toSymbolReference(), rightSymbol.toSymbolReference());\n+                    dynamicFilteringClauses.add(filter);\n+                    if (isEquality) {\n+                        equiJoinClauses.add(new JoinNode.EquiJoinClause(leftSymbol, rightSymbol));\n+                    }\n+                    else {\n+                        joinFilterBuilder.add(filter);\n+                    }\n                 }\n                 else {\n+                    // Inequality join predicate && dynamic filtering is disabled.\n                     joinFilterBuilder.add(conjunct);\n                 }\n             }\n \n-            DynamicFiltersResult dynamicFiltersResult = createDynamicFilters(node, equiJoinClauses, session, idAllocator);\n+            DynamicFiltersResult dynamicFiltersResult = createDynamicFilters(node, dynamicFilteringClauses.build(), session, idAllocator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4MDkwNg=="}, "originalCommit": null, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEwNDQ4MA==", "bodyText": "Added both equiJoinClauses and newJoinFilter.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r509104480", "createdAt": "2020-10-21T08:52:30Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -501,21 +518,30 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n                         rightProjections.put(rightSymbol, rightExpression);\n                     }\n \n-                    equiJoinClauses.add(new JoinNode.EquiJoinClause(leftSymbol, rightSymbol));\n+                    ComparisonExpression.Operator operator = alignedComparison ? comparison.getOperator() : comparison.getOperator().flip();\n+                    ComparisonExpression filter = new ComparisonExpression(operator, leftSymbol.toSymbolReference(), rightSymbol.toSymbolReference());\n+                    dynamicFilteringClauses.add(filter);\n+                    if (isEquality) {\n+                        equiJoinClauses.add(new JoinNode.EquiJoinClause(leftSymbol, rightSymbol));\n+                    }\n+                    else {\n+                        joinFilterBuilder.add(filter);\n+                    }\n                 }\n                 else {\n+                    // Inequality join predicate && dynamic filtering is disabled.\n                     joinFilterBuilder.add(conjunct);\n                 }\n             }\n \n-            DynamicFiltersResult dynamicFiltersResult = createDynamicFilters(node, equiJoinClauses, session, idAllocator);\n+            DynamicFiltersResult dynamicFiltersResult = createDynamicFilters(node, dynamicFilteringClauses.build(), session, idAllocator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4MDkwNg=="}, "originalCommit": null, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MDA1OTA2OnYy", "diffSide": "LEFT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMTo0NTozOVrOHkKZjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwODo1MTo1NVrOHlhP7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4MTE2NA==", "bodyText": "let's encapsulate non-equi DF code in createDynamicFilters method. Then these code changes are not needed", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507681164", "createdAt": "2020-10-19T11:45:39Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -483,13 +493,20 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             // Create new projections for the new join clauses\n             List<JoinNode.EquiJoinClause> equiJoinClauses = new ArrayList<>();\n             ImmutableList.Builder<Expression> joinFilterBuilder = ImmutableList.builder();\n+            ImmutableList.Builder<ComparisonExpression> dynamicFilteringClauses = ImmutableList.builder();\n             for (Expression conjunct : extractConjuncts(newJoinPredicate)) {\n-                if (joinEqualityExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEwNDEwOQ==", "bodyText": "Sounds good - I've changed createDynamicFilters signature to accept both equiJoinClauses and joinFilterBuilder.build().", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r509104109", "createdAt": "2020-10-21T08:51:55Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -483,13 +493,20 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             // Create new projections for the new join clauses\n             List<JoinNode.EquiJoinClause> equiJoinClauses = new ArrayList<>();\n             ImmutableList.Builder<Expression> joinFilterBuilder = ImmutableList.builder();\n+            ImmutableList.Builder<ComparisonExpression> dynamicFilteringClauses = ImmutableList.builder();\n             for (Expression conjunct : extractConjuncts(newJoinPredicate)) {\n-                if (joinEqualityExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4MTE2NA=="}, "originalCommit": null, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MDA3MDA0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMTo0ODo0NVrOHkKf5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNTowMzo1OVrOHlBvPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4Mjc5MQ==", "bodyText": "Please extend matcher so that we can match ineq type too", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507682791", "createdAt": "2020-10-19T11:48:45Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -142,6 +142,38 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey < l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY < L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableMap.of(\"O_ORDERKEY\", \"L_ORDERKEY\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU4NzgzNw==", "bodyText": "Added DynamicFilterPattern to match inequality DFs.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r508587837", "createdAt": "2020-10-20T15:03:59Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -142,6 +142,38 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey < l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY < L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableMap.of(\"O_ORDERKEY\", \"L_ORDERKEY\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4Mjc5MQ=="}, "originalCommit": null, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MDA3Mjk0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMTo0OTozMlrOHkKhng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMTo0OTozMlrOHkKhng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4MzIzMA==", "bodyText": "add a test case with non cross join too", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507683230", "createdAt": "2020-10-19T11:49:32Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -142,6 +142,38 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNzg3NTgzOnYy", "diffSide": "RIGHT", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDoyODo0NlrOHoSKKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDoyODo0NlrOHoSKKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwMjYwMg==", "bodyText": "* Planner support for dynamic filtering for a given join operation in Presto.\n  Currently inner and right joins with equality join conditions and semi-joins with IN conditions are supported.\n\nthis section needs to be updated", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512002602", "createdAt": "2020-10-26T14:28:46Z", "author": {"login": "sopel39"}, "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -87,7 +87,7 @@ down to the connector in the query plan.\n            \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNzkwMDkxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDozMzozMVrOHoSZQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDozMzozMVrOHoSZQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwNjQ2Nw==", "bodyText": "please extract span to separate variable before switch", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512006467", "createdAt": "2020-10-26T14:33:31Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -197,8 +232,42 @@ public String toString()\n             return toStringHelper(this)\n                     .add(\"id\", id)\n                     .add(\"input\", input)\n+                    .add(\"operator\", operator)\n                     .toString();\n         }\n+\n+        public Domain applyComparison(Domain domain)\n+        {\n+            if (domain.isNone() || domain.isAll()) {\n+                return domain;\n+            }\n+            switch (operator) {\n+                case EQUAL:\n+                    return domain;\n+                case LESS_THAN: {\n+                    Range span = domain.getValues().getRanges().getSpan();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNzk5NzI3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDo1MTo0M1rOHoTSyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDo1MTo0M1rOHoTSyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyMTE5Mg==", "bodyText": "static import DynamicFilterPattern", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512021192", "createdAt": "2020-10-26T14:51:43Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -135,12 +143,66 @@ public void testEmptyJoinCriteria()\n                         join(\n                                 INNER,\n                                 ImmutableList.of(),\n-                                ImmutableMap.of(),\n+                                ImmutableList.of(),\n                                 tableScan(\"orders\"),\n                                 exchange(\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey > l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY > L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableList.of(new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", GREATER_THAN, \"L_ORDERKEY\")),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODAwOTUyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDo1NDoxMlrOHoTagA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDo1NDoxMlrOHoTagA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyMzE2OA==", "bodyText": "use that pattern in other added tests too", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512023168", "createdAt": "2020-10-26T14:54:12Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -135,12 +143,66 @@ public void testEmptyJoinCriteria()\n                         join(\n                                 INNER,\n                                 ImmutableList.of(),\n-                                ImmutableMap.of(),\n+                                ImmutableList.of(),\n                                 tableScan(\"orders\"),\n                                 exchange(\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey > l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY > L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableList.of(new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", GREATER_THAN, \"L_ORDERKEY\")),\n+                                node(\n+                                        FilterNode.class,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))),\n+                                exchange(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")))))));\n+    }\n+\n+    @Test\n+    public void testEquiJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey = l.orderkey AND o.totalprice < l.extendedprice\",\n+                anyTree(join(\n+                        INNER,\n+                        ImmutableList.of(equiJoinClause(\"O_ORDERKEY\", \"L_ORDERKEY\")),\n+                        Optional.of(\"O_TOTALPRICE < L_EXTENDEDPRICE\"),\n+                        Optional.of(ImmutableList.of(\n+                                new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", EQUAL, \"L_ORDERKEY\"),\n+                                new PlanMatchPattern.DynamicFilterPattern(\"O_TOTALPRICE\", LESS_THAN, \"L_EXTENDEDPRICE\"))),\n+                        Optional.empty(),\n+                        Optional.empty(),\n+                        project(\n+                                filter(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODAxNTEyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDo1NToyMlrOHoTeEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMTo1ODo1OVrOHpmm4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyNDA4Mw==", "bodyText": "this case is uniteresting. Cast on probe side (not build) is what we want to test", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512024083", "createdAt": "2020-10-26T14:55:22Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -135,12 +143,66 @@ public void testEmptyJoinCriteria()\n                         join(\n                                 INNER,\n                                 ImmutableList.of(),\n-                                ImmutableMap.of(),\n+                                ImmutableList.of(),\n                                 tableScan(\"orders\"),\n                                 exchange(\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey > l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY > L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableList.of(new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", GREATER_THAN, \"L_ORDERKEY\")),\n+                                node(\n+                                        FilterNode.class,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))),\n+                                exchange(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")))))));\n+    }\n+\n+    @Test\n+    public void testEquiJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey = l.orderkey AND o.totalprice < l.extendedprice\",\n+                anyTree(join(\n+                        INNER,\n+                        ImmutableList.of(equiJoinClause(\"O_ORDERKEY\", \"L_ORDERKEY\")),\n+                        Optional.of(\"O_TOTALPRICE < L_EXTENDEDPRICE\"),\n+                        Optional.of(ImmutableList.of(\n+                                new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", EQUAL, \"L_ORDERKEY\"),\n+                                new PlanMatchPattern.DynamicFilterPattern(\"O_TOTALPRICE\", LESS_THAN, \"L_EXTENDEDPRICE\"))),\n+                        Optional.empty(),\n+                        Optional.empty(),\n+                        project(\n+                                filter(\n+                                        TRUE_LITERAL,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\", \"O_TOTALPRICE\", \"totalprice\")))),\n+                        exchange(\n+                                project(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\", \"L_EXTENDEDPRICE\", \"extendedprice\")))))));\n+    }\n+\n+    @Test\n+    public void testCrossJoinInequalityDFWithCast()\n+    {\n+        assertPlan(\"SELECT o.comment, l.comment FROM orders o, lineitem l WHERE o.comment < l.comment\",\n+                anyTree(filter(\"O_COMMENT < EXPR\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                node(\n+                                        FilterNode.class,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_COMMENT\", \"comment\"))),\n+                                exchange(\n+                                        project(ImmutableMap.of(\"EXPR\", expression(\"CAST(L_COMMENT AS varchar(79))\")),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM4NjIwOA==", "bodyText": "This test can be useful to make sure we don't add projections to the plan, following #2674 (comment) and #2674 (comment). WDYT?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r513386208", "createdAt": "2020-10-28T11:58:59Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -135,12 +143,66 @@ public void testEmptyJoinCriteria()\n                         join(\n                                 INNER,\n                                 ImmutableList.of(),\n-                                ImmutableMap.of(),\n+                                ImmutableList.of(),\n                                 tableScan(\"orders\"),\n                                 exchange(\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey > l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY > L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableList.of(new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", GREATER_THAN, \"L_ORDERKEY\")),\n+                                node(\n+                                        FilterNode.class,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))),\n+                                exchange(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")))))));\n+    }\n+\n+    @Test\n+    public void testEquiJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey = l.orderkey AND o.totalprice < l.extendedprice\",\n+                anyTree(join(\n+                        INNER,\n+                        ImmutableList.of(equiJoinClause(\"O_ORDERKEY\", \"L_ORDERKEY\")),\n+                        Optional.of(\"O_TOTALPRICE < L_EXTENDEDPRICE\"),\n+                        Optional.of(ImmutableList.of(\n+                                new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", EQUAL, \"L_ORDERKEY\"),\n+                                new PlanMatchPattern.DynamicFilterPattern(\"O_TOTALPRICE\", LESS_THAN, \"L_EXTENDEDPRICE\"))),\n+                        Optional.empty(),\n+                        Optional.empty(),\n+                        project(\n+                                filter(\n+                                        TRUE_LITERAL,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\", \"O_TOTALPRICE\", \"totalprice\")))),\n+                        exchange(\n+                                project(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\", \"L_EXTENDEDPRICE\", \"extendedprice\")))))));\n+    }\n+\n+    @Test\n+    public void testCrossJoinInequalityDFWithCast()\n+    {\n+        assertPlan(\"SELECT o.comment, l.comment FROM orders o, lineitem l WHERE o.comment < l.comment\",\n+                anyTree(filter(\"O_COMMENT < EXPR\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                node(\n+                                        FilterNode.class,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_COMMENT\", \"comment\"))),\n+                                exchange(\n+                                        project(ImmutableMap.of(\"EXPR\", expression(\"CAST(L_COMMENT AS varchar(79))\")),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyNDA4Mw=="}, "originalCommit": null, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODAyMjMyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/PlanMatchPattern.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDo1Njo0NFrOHoTiiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDo1Njo0NFrOHoTiiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyNTIyNw==", "bodyText": "please keep previous simplified method too", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512025227", "createdAt": "2020-10-26T14:56:44Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/PlanMatchPattern.java", "diffHunk": "@@ -462,10 +463,37 @@ public static PlanMatchPattern join(\n         return join(joinType, expectedEquiCriteria, expectedFilter, Optional.empty(), expectedDistributionType, expectedSpillable, left, right);\n     }\n \n+    public static class DynamicFilterPattern\n+    {\n+        private final SymbolAlias probe;\n+        private final ComparisonExpression.Operator operator;\n+        private final SymbolAlias build;\n+\n+        public DynamicFilterPattern(String probeAlias, ComparisonExpression.Operator operator, String buildAlias)\n+        {\n+            this.probe = new SymbolAlias(requireNonNull(probeAlias, \"probeAlias is null\"));\n+            this.operator = requireNonNull(operator, \"operator is null\");\n+            this.build = new SymbolAlias(requireNonNull(buildAlias, \"buildAlias is null\"));\n+        }\n+\n+        public ComparisonExpression getComparisonExpression(SymbolAliases aliases)\n+        {\n+            return new ComparisonExpression(\n+                    operator,\n+                    probe.toSymbol(aliases).toSymbolReference(),\n+                    build.toSymbol(aliases).toSymbolReference());\n+        }\n+    }\n+\n+    public static DynamicFilterPattern equiDynamicFilter(String probeAlias, String buildAlias)\n+    {\n+        return new DynamicFilterPattern(probeAlias, ComparisonExpression.Operator.EQUAL, buildAlias);\n+    }\n+\n     public static PlanMatchPattern join(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODAyNjk4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/PlanMatchPattern.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDo1Nzo0MlrOHoTlZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDo1Nzo0MlrOHoTlZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyNTk1OA==", "bodyText": "move class below usage (above GroupingSetDescriptor)", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512025958", "createdAt": "2020-10-26T14:57:42Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/PlanMatchPattern.java", "diffHunk": "@@ -462,10 +463,37 @@ public static PlanMatchPattern join(\n         return join(joinType, expectedEquiCriteria, expectedFilter, Optional.empty(), expectedDistributionType, expectedSpillable, left, right);\n     }\n \n+    public static class DynamicFilterPattern", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODA3Mzg2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/PlanMatchPattern.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTowNjo0OVrOHoUCHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTowNjo0OVrOHoUCHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzMzMxMQ==", "bodyText": "make it package private", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512033311", "createdAt": "2020-10-26T15:06:49Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/PlanMatchPattern.java", "diffHunk": "@@ -462,10 +463,37 @@ public static PlanMatchPattern join(\n         return join(joinType, expectedEquiCriteria, expectedFilter, Optional.empty(), expectedDistributionType, expectedSpillable, left, right);\n     }\n \n+    public static class DynamicFilterPattern\n+    {\n+        private final SymbolAlias probe;\n+        private final ComparisonExpression.Operator operator;\n+        private final SymbolAlias build;\n+\n+        public DynamicFilterPattern(String probeAlias, ComparisonExpression.Operator operator, String buildAlias)\n+        {\n+            this.probe = new SymbolAlias(requireNonNull(probeAlias, \"probeAlias is null\"));\n+            this.operator = requireNonNull(operator, \"operator is null\");\n+            this.build = new SymbolAlias(requireNonNull(buildAlias, \"buildAlias is null\"));\n+        }\n+\n+        public ComparisonExpression getComparisonExpression(SymbolAliases aliases)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODA4Mjc1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTowODozN1rOHoUHrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTowODozN1rOHoUHrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzNDczMw==", "bodyText": "please keep previous join constructor too, this would prevent all these (unrelated) changes", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512034733", "createdAt": "2020-10-26T15:08:37Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -347,7 +415,7 @@ public void testNestedDynamicFiltersRemoval()\n                         join(\n                                 INNER,\n                                 ImmutableList.of(equiJoinClause(\"ORDERS_CK\", \"ORDERS_CK6\")),\n-                                ImmutableMap.of(\"ORDERS_CK\", \"ORDERS_CK6\"),\n+                                ImmutableList.of(equiDynamicFilter(\"ORDERS_CK\", \"ORDERS_CK6\")),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 242}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODA4NDYxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTowOTowMVrOHoUI1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTowOTowMVrOHoUI1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzNTAyOQ==", "bodyText": "static import GREATER_THAN and others", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512035029", "createdAt": "2020-10-26T15:09:01Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "diffHunk": "@@ -182,6 +185,44 @@ public void testMultipleProbeColumns()\n         assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(column1, domain, column2, domain)));\n     }\n \n+    @Test\n+    public void testMultipleComparisons()\n+    {\n+        LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector(metadata, typeOperators, session);\n+        DynamicFilterId filterId = new DynamicFilterId(\"filter\");\n+        collector.register(ImmutableSet.of(filterId));\n+        SymbolAllocator symbolAllocator = new SymbolAllocator();\n+\n+        // Same build-side column being compared to multiple probe-side columns.\n+        Symbol symbol1 = symbolAllocator.newSymbol(\"symbol1\", BIGINT);\n+        Symbol symbol2 = symbolAllocator.newSymbol(\"symbol2\", BIGINT);\n+        ColumnHandle column1 = new TestingColumnHandle(\"column1\");\n+        ColumnHandle column2 = new TestingColumnHandle(\"column2\");\n+        DynamicFilter filter = collector.createDynamicFilter(\n+                ImmutableList.of(\n+                        new DynamicFilters.Descriptor(filterId, symbol1.toSymbolReference(), Operator.GREATER_THAN),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODExNjA5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToxNToxMlrOHoUcJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToxNToxMlrOHoUcJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzOTk3NA==", "bodyText": "static import DynamicFilterPattern", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512039974", "createdAt": "2020-10-26T15:15:12Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -298,8 +300,16 @@ public void testDistinctLimitOverInequalityJoin()\n                         node(DistinctLimitNode.class,\n                                 anyTree(\n                                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n-                                                join(INNER, ImmutableList.of(), Optional.empty(),\n-                                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\")),\n+                                                join(INNER,\n+                                                        ImmutableList.of(),\n+                                                        Optional.empty(),\n+                                                        Optional.of(ImmutableList.of(\n+                                                                new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", LESS_THAN, \"L_ORDERKEY\"))),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODEyMzA3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/PlanMatchPattern.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToxNjozOVrOHoUgbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToxNjozOVrOHoUgbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0MTA2OA==", "bodyText": "nit: static import EQUAL", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512041068", "createdAt": "2020-10-26T15:16:39Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/PlanMatchPattern.java", "diffHunk": "@@ -462,10 +463,37 @@ public static PlanMatchPattern join(\n         return join(joinType, expectedEquiCriteria, expectedFilter, Optional.empty(), expectedDistributionType, expectedSpillable, left, right);\n     }\n \n+    public static class DynamicFilterPattern\n+    {\n+        private final SymbolAlias probe;\n+        private final ComparisonExpression.Operator operator;\n+        private final SymbolAlias build;\n+\n+        public DynamicFilterPattern(String probeAlias, ComparisonExpression.Operator operator, String buildAlias)\n+        {\n+            this.probe = new SymbolAlias(requireNonNull(probeAlias, \"probeAlias is null\"));\n+            this.operator = requireNonNull(operator, \"operator is null\");\n+            this.build = new SymbolAlias(requireNonNull(buildAlias, \"buildAlias is null\"));\n+        }\n+\n+        public ComparisonExpression getComparisonExpression(SymbolAliases aliases)\n+        {\n+            return new ComparisonExpression(\n+                    operator,\n+                    probe.toSymbol(aliases).toSymbolReference(),\n+                    build.toSymbol(aliases).toSymbolReference());\n+        }\n+    }\n+\n+    public static DynamicFilterPattern equiDynamicFilter(String probeAlias, String buildAlias)\n+    {\n+        return new DynamicFilterPattern(probeAlias, ComparisonExpression.Operator.EQUAL, buildAlias);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODEyNjI4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToxNzoyMlrOHoUieg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToxNzoyMlrOHoUieg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0MTU5NA==", "bodyText": "I think you can use join without these two Optional.empty() args", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512041594", "createdAt": "2020-10-26T15:17:22Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -298,8 +300,16 @@ public void testDistinctLimitOverInequalityJoin()\n                         node(DistinctLimitNode.class,\n                                 anyTree(\n                                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n-                                                join(INNER, ImmutableList.of(), Optional.empty(),\n-                                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\")),\n+                                                join(INNER,\n+                                                        ImmutableList.of(),\n+                                                        Optional.empty(),\n+                                                        Optional.of(ImmutableList.of(\n+                                                                new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", LESS_THAN, \"L_ORDERKEY\"))),\n+                                                        Optional.empty(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODEzMDYyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToxODoxNVrOHoUlQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToxODoxNVrOHoUlQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0MjMwNw==", "bodyText": "keep node(FilterNode.class, in same line, e.g:\nnode(FilterNode.class,\n  tableScal(\"orders\")\n...\n\nwe decided to use this schema for plan matching as it's easier to read.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512042307", "createdAt": "2020-10-26T15:18:15Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -370,7 +392,9 @@ public void testLeftConvertedToInnerInequalityJoinNoEquiJoinConjuncts()\n                 anyTree(\n                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n                                 join(INNER, ImmutableList.of(), Optional.empty(),\n-                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\")),\n+                                        node(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODE0MDU1OnYy", "diffSide": "LEFT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToyMDoxMVrOHoUrkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToyMDoxMVrOHoUrkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0MzkyMw==", "bodyText": "keep this simplified method too", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512043923", "createdAt": "2020-10-26T15:20:11Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -1133,12 +1218,12 @@ private Object nullInputEvaluator(Collection<Symbol> nullSymbols, Expression exp\n                     .optimize(symbol -> nullSymbols.contains(symbol) ? null : symbol.toSymbolReference());\n         }\n \n-        private boolean joinEqualityExpression(Expression expression, Collection<Symbol> leftSymbols, Collection<Symbol> rightSymbols)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODE1MTYyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToyMjoyNFrOHoUyPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToyMjoyNFrOHoUyPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0NTYzMA==", "bodyText": "getJoinFilterClauses is not needed. We should always add joinFilterBuilder.build() expressions (regardless of DF).", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512045630", "createdAt": "2020-10-26T15:22:24Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -524,7 +540,7 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n                 rightSource = context.rewrite(node.getRight(), rightPredicate);\n             }\n \n-            Optional<Expression> newJoinFilter = Optional.of(combineConjuncts(metadata, joinFilterBuilder.build()));\n+            Optional<Expression> newJoinFilter = Optional.of(combineConjuncts(metadata, dynamicFiltersResult.getJoinFilterClauses()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODE1NjE5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToyMzoyNFrOHoU1Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToyMzoyNFrOHoU1Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0NjM3OA==", "bodyText": "rename to DYNAMIC_FILTERING_SUPPORTED_COMPARISONS", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512046378", "createdAt": "2020-10-26T15:23:24Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -95,11 +99,23 @@\n import static io.prestosql.sql.planner.plan.JoinNode.Type.LEFT;\n import static io.prestosql.sql.planner.plan.JoinNode.Type.RIGHT;\n import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.EQUAL;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.GREATER_THAN;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.GREATER_THAN_OR_EQUAL;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.LESS_THAN;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.LESS_THAN_OR_EQUAL;\n import static java.util.Objects.requireNonNull;\n \n public class PredicatePushDown\n         implements PlanOptimizer\n {\n+    private static final Set<ComparisonExpression.Operator> DYNAMIC_FILTERING_SUPPORTED_OPERATORS = ImmutableSet.of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODE2MTQ3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToyNDoyOFrOHoU4lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToyNDoyOFrOHoU4lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0NzI1Mg==", "bodyText": "static import extractUnique", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512047252", "createdAt": "2020-10-26T15:24:28Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -579,42 +595,101 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Assignments.Builder leftProjections,\n+                Assignments.Builder rightProjections,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n-                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n-            }\n+                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of(), joinFilterClauses, false);\n+            }\n+\n+            AtomicBoolean newProjectionAdded = new AtomicBoolean(false);\n+            ImmutableList.Builder<ComparisonExpression> comparisonClausesBuilder = ImmutableList.builder();\n+            equiJoinClauses\n+                    .stream()\n+                    .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference()))\n+                    .forEach(comparisonClausesBuilder::add);\n+            joinFilterClauses = joinFilterClauses.stream()\n+                    .map(clause -> {\n+                        if (!isJoinComparison(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_OPERATORS)) {\n+                            return clause;\n+                        }\n+                        ComparisonExpression comparison = (ComparisonExpression) clause;\n+                        boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(comparison.getLeft()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODIwODQyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTozMzo0NlrOHoVV4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMTo1NjoyN1rOHpmhWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1NDc1NQ==", "bodyText": "ok, so this actually adds new symbols... but DF won't work for l1 + 10 anyway, so we can only support cases where left side consist of single symbol", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512054755", "createdAt": "2020-10-26T15:33:46Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -579,42 +595,101 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Assignments.Builder leftProjections,\n+                Assignments.Builder rightProjections,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n-                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n-            }\n+                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of(), joinFilterClauses, false);\n+            }\n+\n+            AtomicBoolean newProjectionAdded = new AtomicBoolean(false);\n+            ImmutableList.Builder<ComparisonExpression> comparisonClausesBuilder = ImmutableList.builder();\n+            equiJoinClauses\n+                    .stream()\n+                    .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference()))\n+                    .forEach(comparisonClausesBuilder::add);\n+            joinFilterClauses = joinFilterClauses.stream()\n+                    .map(clause -> {\n+                        if (!isJoinComparison(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_OPERATORS)) {\n+                            return clause;\n+                        }\n+                        ComparisonExpression comparison = (ComparisonExpression) clause;\n+                        boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(comparison.getLeft()));\n+                        Expression leftExpression = (alignedComparison) ? comparison.getLeft() : comparison.getRight();\n+                        Expression rightExpression = (alignedComparison) ? comparison.getRight() : comparison.getLeft();\n+                        ComparisonExpression.Operator operator = alignedComparison ? comparison.getOperator() : comparison.getOperator().flip();\n+\n+                        Symbol leftSymbol = symbolForExpression(leftExpression);\n+                        if (!node.getLeft().getOutputSymbols().contains(leftSymbol)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM4NDc5Mg==", "bodyText": "Sounds good, fixed the code to support only single symbol case.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r513384792", "createdAt": "2020-10-28T11:56:27Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -579,42 +595,101 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Assignments.Builder leftProjections,\n+                Assignments.Builder rightProjections,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n-                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n-            }\n+                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of(), joinFilterClauses, false);\n+            }\n+\n+            AtomicBoolean newProjectionAdded = new AtomicBoolean(false);\n+            ImmutableList.Builder<ComparisonExpression> comparisonClausesBuilder = ImmutableList.builder();\n+            equiJoinClauses\n+                    .stream()\n+                    .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference()))\n+                    .forEach(comparisonClausesBuilder::add);\n+            joinFilterClauses = joinFilterClauses.stream()\n+                    .map(clause -> {\n+                        if (!isJoinComparison(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_OPERATORS)) {\n+                            return clause;\n+                        }\n+                        ComparisonExpression comparison = (ComparisonExpression) clause;\n+                        boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(comparison.getLeft()));\n+                        Expression leftExpression = (alignedComparison) ? comparison.getLeft() : comparison.getRight();\n+                        Expression rightExpression = (alignedComparison) ? comparison.getRight() : comparison.getLeft();\n+                        ComparisonExpression.Operator operator = alignedComparison ? comparison.getOperator() : comparison.getOperator().flip();\n+\n+                        Symbol leftSymbol = symbolForExpression(leftExpression);\n+                        if (!node.getLeft().getOutputSymbols().contains(leftSymbol)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1NDc1NQ=="}, "originalCommit": null, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODI1NjA3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTo0MzoyOVrOHoVziQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMTo1Njo0OFrOHpmiAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA2MjM0NQ==", "bodyText": "so this actually can affect join performance when DF are not effective, e.g a new symbol l2=l1+10 might be send over the network and stored in build side (even though l1 is already send). I would rather avoid that. Let's assume that right side is single symbol. We could also add a support in DynamicFilterSourceOperator for basic expressions, e.g l1+10 later", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512062345", "createdAt": "2020-10-26T15:43:29Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -579,42 +595,101 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Assignments.Builder leftProjections,\n+                Assignments.Builder rightProjections,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n-                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n-            }\n+                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of(), joinFilterClauses, false);\n+            }\n+\n+            AtomicBoolean newProjectionAdded = new AtomicBoolean(false);\n+            ImmutableList.Builder<ComparisonExpression> comparisonClausesBuilder = ImmutableList.builder();\n+            equiJoinClauses\n+                    .stream()\n+                    .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference()))\n+                    .forEach(comparisonClausesBuilder::add);\n+            joinFilterClauses = joinFilterClauses.stream()\n+                    .map(clause -> {\n+                        if (!isJoinComparison(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_OPERATORS)) {\n+                            return clause;\n+                        }\n+                        ComparisonExpression comparison = (ComparisonExpression) clause;\n+                        boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(comparison.getLeft()));\n+                        Expression leftExpression = (alignedComparison) ? comparison.getLeft() : comparison.getRight();\n+                        Expression rightExpression = (alignedComparison) ? comparison.getRight() : comparison.getLeft();\n+                        ComparisonExpression.Operator operator = alignedComparison ? comparison.getOperator() : comparison.getOperator().flip();\n+\n+                        Symbol leftSymbol = symbolForExpression(leftExpression);\n+                        if (!node.getLeft().getOutputSymbols().contains(leftSymbol)) {\n+                            leftProjections.put(leftSymbol, leftExpression);\n+                            newProjectionAdded.set(true);\n+                        }\n+\n+                        Symbol rightSymbol = symbolForExpression(rightExpression);\n+                        if (!node.getRight().getOutputSymbols().contains(rightSymbol)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM4NDk2MQ==", "bodyText": "Sounds good, fixed the code to support only single symbol case.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r513384961", "createdAt": "2020-10-28T11:56:48Z", "author": {"login": "rzeyde-varada"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -579,42 +595,101 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Assignments.Builder leftProjections,\n+                Assignments.Builder rightProjections,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n-                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n-            }\n+                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of(), joinFilterClauses, false);\n+            }\n+\n+            AtomicBoolean newProjectionAdded = new AtomicBoolean(false);\n+            ImmutableList.Builder<ComparisonExpression> comparisonClausesBuilder = ImmutableList.builder();\n+            equiJoinClauses\n+                    .stream()\n+                    .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference()))\n+                    .forEach(comparisonClausesBuilder::add);\n+            joinFilterClauses = joinFilterClauses.stream()\n+                    .map(clause -> {\n+                        if (!isJoinComparison(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_OPERATORS)) {\n+                            return clause;\n+                        }\n+                        ComparisonExpression comparison = (ComparisonExpression) clause;\n+                        boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(comparison.getLeft()));\n+                        Expression leftExpression = (alignedComparison) ? comparison.getLeft() : comparison.getRight();\n+                        Expression rightExpression = (alignedComparison) ? comparison.getRight() : comparison.getLeft();\n+                        ComparisonExpression.Operator operator = alignedComparison ? comparison.getOperator() : comparison.getOperator().flip();\n+\n+                        Symbol leftSymbol = symbolForExpression(leftExpression);\n+                        if (!node.getLeft().getOutputSymbols().contains(leftSymbol)) {\n+                            leftProjections.put(leftSymbol, leftExpression);\n+                            newProjectionAdded.set(true);\n+                        }\n+\n+                        Symbol rightSymbol = symbolForExpression(rightExpression);\n+                        if (!node.getRight().getOutputSymbols().contains(rightSymbol)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA2MjM0NQ=="}, "originalCommit": null, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMjM2OTE0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMzo1NToyMVrOHqc9nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMzo1NToyMVrOHqc9nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI3Njc2NQ==", "bodyText": "use toImmutableSet", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r514276765", "createdAt": "2020-10-29T13:55:21Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -580,31 +597,67 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n                 return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n             }\n \n+            List<ComparisonExpression> clauses = Streams.concat(\n+                    equiJoinClauses\n+                            .stream()\n+                            .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference())),\n+                    joinFilterClauses.stream()\n+                            .filter(clause -> joinComparisonExpression(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_COMPARISONS))\n+                            .map(ComparisonExpression.class::cast)\n+                            .filter(comparison -> comparison.getLeft() instanceof SymbolReference && comparison.getRight() instanceof SymbolReference)\n+                            .map(comparison -> {\n+                                Symbol leftSymbol = Symbol.from(comparison.getLeft());\n+                                Symbol rightSymbol = Symbol.from(comparison.getRight());\n+                                boolean alignedComparison = node.getLeft().getOutputSymbols().contains(leftSymbol);\n+                                return new ComparisonExpression(\n+                                        alignedComparison ? comparison.getOperator() : comparison.getOperator().flip(),\n+                                        (alignedComparison ? leftSymbol : rightSymbol).toSymbolReference(),\n+                                        (alignedComparison ? rightSymbol : leftSymbol).toSymbolReference());\n+                            }))\n+                    .collect(toImmutableList());\n+\n             // New equiJoinClauses could potentially not contain symbols used in current dynamic filters.\n             // Since we use PredicatePushdown to push dynamic filters themselves,\n             // instead of separate ApplyDynamicFilters rule we derive dynamic filters within PredicatePushdown itself.\n             // Even if equiJoinClauses.equals(node.getCriteria), current dynamic filters may not match equiJoinClauses\n-            ImmutableMap.Builder<DynamicFilterId, Symbol> dynamicFiltersBuilder = ImmutableMap.builder();\n-            ImmutableList.Builder<Expression> predicatesBuilder = ImmutableList.builder();\n-            // reuse existing dynamic filters to make planning more stable\n-            Map<Symbol, DynamicFilterId> buildSymbolToDynamicFilter = new HashMap<>(node.getDynamicFilters().entrySet().stream()\n-                    .collect(toImmutableMap(Map.Entry::getValue, Map.Entry::getKey)));\n-            for (JoinNode.EquiJoinClause clause : equiJoinClauses) {\n-                Symbol probeSymbol = clause.getLeft();\n-                Symbol buildSymbol = clause.getRight();\n-                DynamicFilterId id = buildSymbolToDynamicFilter.computeIfAbsent(\n+\n+            // Collect build symbols:\n+            Set<Symbol> buildSymbols = clauses.stream()\n+                    .map(ComparisonExpression::getRight)\n+                    .map(Symbol::from)\n+                    .collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMjM5ODExOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNDowMTo0MVrOHqdP0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNDowMTo0MVrOHqdP0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI4MTQyNg==", "bodyText": "make a defensive copy of buildSymbolToDynamicFilter in DynamicFiltersResult", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r514281426", "createdAt": "2020-10-29T14:01:41Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -580,31 +597,67 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n                 return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n             }\n \n+            List<ComparisonExpression> clauses = Streams.concat(\n+                    equiJoinClauses\n+                            .stream()\n+                            .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference())),\n+                    joinFilterClauses.stream()\n+                            .filter(clause -> joinComparisonExpression(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_COMPARISONS))\n+                            .map(ComparisonExpression.class::cast)\n+                            .filter(comparison -> comparison.getLeft() instanceof SymbolReference && comparison.getRight() instanceof SymbolReference)\n+                            .map(comparison -> {\n+                                Symbol leftSymbol = Symbol.from(comparison.getLeft());\n+                                Symbol rightSymbol = Symbol.from(comparison.getRight());\n+                                boolean alignedComparison = node.getLeft().getOutputSymbols().contains(leftSymbol);\n+                                return new ComparisonExpression(\n+                                        alignedComparison ? comparison.getOperator() : comparison.getOperator().flip(),\n+                                        (alignedComparison ? leftSymbol : rightSymbol).toSymbolReference(),\n+                                        (alignedComparison ? rightSymbol : leftSymbol).toSymbolReference());\n+                            }))\n+                    .collect(toImmutableList());\n+\n             // New equiJoinClauses could potentially not contain symbols used in current dynamic filters.\n             // Since we use PredicatePushdown to push dynamic filters themselves,\n             // instead of separate ApplyDynamicFilters rule we derive dynamic filters within PredicatePushdown itself.\n             // Even if equiJoinClauses.equals(node.getCriteria), current dynamic filters may not match equiJoinClauses\n-            ImmutableMap.Builder<DynamicFilterId, Symbol> dynamicFiltersBuilder = ImmutableMap.builder();\n-            ImmutableList.Builder<Expression> predicatesBuilder = ImmutableList.builder();\n-            // reuse existing dynamic filters to make planning more stable\n-            Map<Symbol, DynamicFilterId> buildSymbolToDynamicFilter = new HashMap<>(node.getDynamicFilters().entrySet().stream()\n-                    .collect(toImmutableMap(Map.Entry::getValue, Map.Entry::getKey)));\n-            for (JoinNode.EquiJoinClause clause : equiJoinClauses) {\n-                Symbol probeSymbol = clause.getLeft();\n-                Symbol buildSymbol = clause.getRight();\n-                DynamicFilterId id = buildSymbolToDynamicFilter.computeIfAbsent(\n+\n+            // Collect build symbols:\n+            Set<Symbol> buildSymbols = clauses.stream()\n+                    .map(ComparisonExpression::getRight)\n+                    .map(Symbol::from)\n+                    .collect(Collectors.toSet());\n+\n+            // Allocate new dynamic filter IDs for for each build symbol:\n+            BiMap<Symbol, DynamicFilterId> buildSymbolToDynamicFilter = HashBiMap.create(node.getDynamicFilters()).inverse();\n+            for (Symbol buildSymbol : buildSymbols) {\n+                buildSymbolToDynamicFilter.computeIfAbsent(\n                         buildSymbol,\n                         key -> new DynamicFilterId(\"df_\" + idAllocator.getNextId().toString()));\n-                predicatesBuilder.add(createDynamicFilterExpression(metadata, id, symbolAllocator.getTypes().get(probeSymbol), probeSymbol.toSymbolReference()));\n-                dynamicFiltersBuilder.put(id, buildSymbol);\n             }\n-            return new DynamicFiltersResult(dynamicFiltersBuilder.build(), predicatesBuilder.build());\n+\n+            // Multiple probe symbols may depend on a single build symbol / dynamic filter ID:\n+            List<Expression> predicates = clauses\n+                    .stream()\n+                    .map(clause -> {\n+                        Symbol probeSymbol = Symbol.from(clause.getLeft());\n+                        Symbol buildSymbol = Symbol.from(clause.getRight());\n+                        Type type = symbolAllocator.getTypes().get(probeSymbol);\n+                        DynamicFilterId id = requireNonNull(buildSymbolToDynamicFilter.get(buildSymbol), () -> \"missing dynamic filter for symbol \" + buildSymbol);\n+                        return createDynamicFilterExpression(metadata, id, type, probeSymbol.toSymbolReference(), clause.getOperator());\n+                    })\n+                    .collect(toImmutableList());\n+            // Return a mapping from build symbols to corresponding dynamic filter IDs:\n+            return new DynamicFiltersResult(buildSymbolToDynamicFilter.inverse(), predicates);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDE3NzE0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMTowMzoxNlrOHqukHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMTowMzoxNlrOHqukHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU2NTE1MQ==", "bodyText": "please also add support for between predicate (+ tests), you can rewrite between into two comparisons", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r514565151", "createdAt": "2020-10-29T21:03:16Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -580,31 +598,67 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n                 return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n             }\n \n+            List<ComparisonExpression> clauses = Streams.concat(\n+                    equiJoinClauses\n+                            .stream()\n+                            .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference())),\n+                    joinFilterClauses.stream()\n+                            .filter(clause -> joinComparisonExpression(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_COMPARISONS))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjg1Nzc5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMDo0NDo1MVrOHrJrRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMTozNzoyMlrOHsA3pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAwOTM0OQ==", "bodyText": "please add two TODOs and corresponding issues in Prestosql:\n\ncollect min/max ranges for ineqaulity dynamic filters\nsupport for complex inequalities, e.g left < right + 10", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515009349", "createdAt": "2020-10-30T10:44:51Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -580,31 +598,67 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxMzYzOQ==", "bodyText": "add links to the issues in code", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515913639", "createdAt": "2020-11-02T11:37:22Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -580,31 +598,67 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAwOTM0OQ=="}, "originalCommit": null, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjg2NTg3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMDo0NzoxN1rOHrJv-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMDo0NzoxN1rOHrJv-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxMDU1Mw==", "bodyText": "actually, this seems redundant to testInnerInequalityJoinWithEquiJoinConjuncts. Please remove this one, sorry", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515010553", "createdAt": "2020-10-30T10:47:17Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -141,6 +148,66 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey > l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY > L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableList.of(new DynamicFilterPattern(\"O_ORDERKEY\", GREATER_THAN, \"L_ORDERKEY\")),\n+                                filter(\n+                                        TRUE_LITERAL,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))),\n+                                exchange(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")))))));\n+    }\n+\n+    @Test\n+    public void testEquiJoinInequalityDF()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjg4NTU1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMDo1MzozNlrOHrJ79A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMDo1MzozNlrOHrJ79A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxMzYyMA==", "bodyText": "please use just one column handle. Let's make sure that range gets clamped.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515013620", "createdAt": "2020-10-30T10:53:36Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "diffHunk": "@@ -182,6 +186,44 @@ public void testMultipleProbeColumns()\n         assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(column1, domain, column2, domain)));\n     }\n \n+    @Test\n+    public void testMultipleComparisons()\n+    {\n+        LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector(metadata, typeOperators, session);\n+        DynamicFilterId filterId = new DynamicFilterId(\"filter\");\n+        collector.register(ImmutableSet.of(filterId));\n+        SymbolAllocator symbolAllocator = new SymbolAllocator();\n+\n+        // Same build-side column being compared to multiple probe-side columns.\n+        Symbol symbol1 = symbolAllocator.newSymbol(\"symbol1\", BIGINT);\n+        Symbol symbol2 = symbolAllocator.newSymbol(\"symbol2\", BIGINT);\n+        ColumnHandle column1 = new TestingColumnHandle(\"column1\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjg4NjUxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMDo1Mzo1N1rOHrJ8kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMDo1Mzo1N1rOHrJ8kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxMzc3OQ==", "bodyText": "Please use filter(TRUE_PREDICATE here and in other cases.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515013779", "createdAt": "2020-10-30T10:53:57Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -298,8 +301,11 @@ public void testDistinctLimitOverInequalityJoin()\n                         node(DistinctLimitNode.class,\n                                 anyTree(\n                                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n-                                                join(INNER, ImmutableList.of(), Optional.empty(),\n-                                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\")),\n+                                                join(INNER,\n+                                                        ImmutableList.of(),\n+                                                        ImmutableList.of(new DynamicFilterPattern(\"O_ORDERKEY\", LESS_THAN, \"L_ORDERKEY\")),\n+                                                        node(FilterNode.class,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjg4OTM4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMDo1NDo0NVrOHrJ-Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMDo1NDo0NVrOHrJ-Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNDIxOA==", "bodyText": "can we use pattern without these two empty params?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515014218", "createdAt": "2020-10-30T10:54:45Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -341,8 +347,14 @@ public void testInnerInequalityJoinNoEquiJoinConjuncts()\n         assertPlan(\"SELECT 1 FROM orders o JOIN lineitem l ON o.orderkey < l.orderkey\",\n                 anyTree(\n                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n-                                join(INNER, ImmutableList.of(), Optional.empty(),\n-                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\")),\n+                                join(INNER,\n+                                        ImmutableList.of(),\n+                                        Optional.empty(),\n+                                        Optional.of(ImmutableList.of(new DynamicFilterPattern(\"O_ORDERKEY\", LESS_THAN, \"L_ORDERKEY\"))),\n+                                        Optional.empty(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjg5MTAyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMDo1NToxNVrOHrJ_Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMDo1NToxNVrOHrJ_Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNDQ3MQ==", "bodyText": "match filter here too", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515014471", "createdAt": "2020-10-30T10:55:15Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -355,6 +367,11 @@ public void testInnerInequalityJoinWithEquiJoinConjuncts()\n                                 join(INNER,\n                                         ImmutableList.of(equiJoinClause(\"O_SHIPPRIORITY\", \"L_LINENUMBER\")),\n                                         Optional.of(\"O_ORDERKEY < L_ORDERKEY\"),\n+                                        Optional.of(ImmutableList.of(\n+                                                new DynamicFilterPattern(\"O_SHIPPRIORITY\", EQUAL, \"L_LINENUMBER\"),\n+                                                new DynamicFilterPattern(\"O_ORDERKEY\", LESS_THAN, \"L_ORDERKEY\"))),\n+                                        Optional.empty(),\n+                                        Optional.empty(),\n                                         anyTree(tableScan(\"orders\", ImmutableMap.of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjg5NjU5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/JoinMatcher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMDo1Njo1OVrOHrKCrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMDo1Njo1OVrOHrKCrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNTM0MA==", "bodyText": "remove // FIXUP", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515015340", "createdAt": "2020-10-30T10:56:59Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/JoinMatcher.java", "diffHunk": "@@ -173,8 +178,7 @@ public String toString()\n                 .add(\"equiCriteria\", equiCriteria)\n                 .add(\"filter\", filter.orElse(null))\n                 .add(\"distributionType\", distributionType)\n-                .add(\"dynamicFilter\", expectedDynamicFilterAliases.map(aliases -> aliases.values().stream()\n-                        .collect(toImmutableMap(rightSymbol -> rightSymbol.toString() + \"_alias\", SymbolAlias::toString))))\n+                .add(\"dynamicFilter\", expectedDynamicFilter)  // FIXUP", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjkwNDk3OnYy", "diffSide": "RIGHT", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMDo1OTo0NVrOHrKHyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMjowNjo1N1rOHsBvzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNjY0OA==", "bodyText": "Why does orders.orderkey + 1 work? There is orderkey + 1 expression here, so it shouldn't work", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515016648", "createdAt": "2020-10-30T10:59:45Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +263,81 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        // \"<\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey < orders.orderkey + 1 AND \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIwODA4MA==", "bodyText": "IIUC, it worked since the optimizer replaced orderkey + 1 with an expr symbol by adding a projection.\nI will rewrite the tests to use single symbols in the comparison expressions.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515208080", "createdAt": "2020-10-30T16:04:12Z", "author": {"login": "rzeyde-varada"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +263,81 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        // \"<\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey < orders.orderkey + 1 AND \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNjY0OA=="}, "originalCommit": null, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIxMjMwMA==", "bodyText": "IIUC, it worked since the optimizer replaced orderkey + 1\n\nWhy it replaced it with expr?\n\nI will rewrite the tests to use single symbols in the comparison expressions.\n\nWe should test both types of comparisons to document current behavior.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515212300", "createdAt": "2020-10-30T16:10:45Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +263,81 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        // \"<\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey < orders.orderkey + 1 AND \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNjY0OA=="}, "originalCommit": null, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUyMzE5OQ==", "bodyText": "It seems that current master behaves this way (i.e. adds a projection for cross-join build-side expression) - reproduced with master...rzeyde-varada:repro-cross-join-projection:\n    @Test\n    public void testAddProjectForComplexBuildExpression()\n    {\n        assertPlan(\"SELECT 1 FROM lineitem JOIN orders ON lineitem.orderkey < orders.orderkey + 1\",\n                anyTree(\n                        filter(\"L_ORDERKEY < EXPR\",\n                                join(INNER, ImmutableList.of(), Optional.empty(),\n                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")),\n                                        exchange(project(\n                                                ImmutableMap.of(\"EXPR\", expression(\"O_ORDERKEY + BIGINT '1'\")),\n                                                tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))))))));\n    }", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515523199", "createdAt": "2020-10-31T18:07:36Z", "author": {"login": "rzeyde-varada"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +263,81 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        // \"<\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey < orders.orderkey + 1 AND \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNjY0OA=="}, "originalCommit": null, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU5NDU3NA==", "bodyText": "IIUC, the initial plan (before the optimization) seems to contain the projection - so it seems that running the optimizers doesn't remove it:\nOutput[_col0]\n\u2502   Layout: [expr_3:integer]\n\u2502   _col0 := expr_3\n\u2514\u2500 Project[]\n   \u2502   Layout: [orderkey:bigint, partkey:bigint, suppkey:bigint, linenumber:integer, quantity:double, extendedprice:double, discount:double, tax:double, returnflag:varchar(1), linestatus:varchar(1), shipdate:date, commitdate:date, receiptdate:date, shipinstruct:varchar(25), shipmode:varchar(10), comment:varchar(44), row_number:bigint, orderkey_0:bigint, custkey:bigint, orderstatus:varchar(1), totalprice:double, orderdate:date, orderpriority:varchar(15), clerk:varchar(15), shippriority:integer, comment_1:varchar(79), row_number_2:bigint, expr:bigint, expr_3:integer]\n   \u2514\u2500 Project[]\n      \u2502   Layout: [orderkey:bigint, partkey:bigint, suppkey:bigint, linenumber:integer, quantity:double, extendedprice:double, discount:double, tax:double, returnflag:varchar(1), linestatus:varchar(1), shipdate:date, commitdate:date, receiptdate:date, shipinstruct:varchar(25), shipmode:varchar(10), comment:varchar(44), row_number:bigint, orderkey_0:bigint, custkey:bigint, orderstatus:varchar(1), totalprice:double, orderdate:date, orderpriority:varchar(15), clerk:varchar(15), shippriority:integer, comment_1:varchar(79), row_number_2:bigint, expr:bigint, expr_3:integer]\n      \u2514\u2500 Project[]\n         \u2502   Layout: [orderkey:bigint, partkey:bigint, suppkey:bigint, linenumber:integer, quantity:double, extendedprice:double, discount:double, tax:double, returnflag:varchar(1), linestatus:varchar(1), shipdate:date, commitdate:date, receiptdate:date, shipinstruct:varchar(25), shipmode:varchar(10), comment:varchar(44), row_number:bigint, orderkey_0:bigint, custkey:bigint, orderstatus:varchar(1), totalprice:double, orderdate:date, orderpriority:varchar(15), clerk:varchar(15), shippriority:integer, comment_1:varchar(79), row_number_2:bigint, expr:bigint, expr_3:integer]\n         \u2514\u2500 FilterProject[filterPredicate = (\"orderkey\" < \"expr\")]\n            \u2502   Layout: [orderkey:bigint, partkey:bigint, suppkey:bigint, linenumber:integer, quantity:double, extendedprice:double, discount:double, tax:double, returnflag:varchar(1), linestatus:varchar(1), shipdate:date, commitdate:date, receiptdate:date, shipinstruct:varchar(25), shipmode:varchar(10), comment:varchar(44), row_number:bigint, orderkey_0:bigint, custkey:bigint, orderstatus:varchar(1), totalprice:double, orderdate:date, orderpriority:varchar(15), clerk:varchar(15), shippriority:integer, comment_1:varchar(79), row_number_2:bigint, expr:bigint, expr_3:integer]\n            \u2502   expr_3 := 1\n            \u2514\u2500 CrossJoin\n               \u2502   Layout: [orderkey:bigint, partkey:bigint, suppkey:bigint, linenumber:integer, quantity:double, extendedprice:double, discount:double, tax:double, returnflag:varchar(1), linestatus:varchar(1), shipdate:date, commitdate:date, receiptdate:date, shipinstruct:varchar(25), shipmode:varchar(10), comment:varchar(44), row_number:bigint, orderkey_0:bigint, custkey:bigint, orderstatus:varchar(1), totalprice:double, orderdate:date, orderpriority:varchar(15), clerk:varchar(15), shippriority:integer, comment_1:varchar(79), row_number_2:bigint, expr:bigint]\n               \u251c\u2500 Project[]\n               \u2502  \u2502   Layout: [orderkey:bigint, partkey:bigint, suppkey:bigint, linenumber:integer, quantity:double, extendedprice:double, discount:double, tax:double, returnflag:varchar(1), linestatus:varchar(1), shipdate:date, commitdate:date, receiptdate:date, shipinstruct:varchar(25), shipmode:varchar(10), comment:varchar(44), row_number:bigint]\n               \u2502  \u2514\u2500 ScanProject[table = local:lineitem:sf0.01]\n               \u2502         Layout: [orderkey:bigint, partkey:bigint, suppkey:bigint, linenumber:integer, quantity:double, extendedprice:double, discount:double, tax:double, returnflag:varchar(1), linestatus:varchar(1), shipdate:date, commitdate:date, receiptdate:date, shipinstruct:varchar(25), shipmode:varchar(10), comment:varchar(44), row_number:bigint]\n               \u2502         orderkey := tpch:orderkey\n               \u2502         partkey := tpch:partkey\n               \u2502         suppkey := tpch:suppkey\n               \u2502         linenumber := tpch:linenumber\n               \u2502         quantity := tpch:quantity\n               \u2502         extendedprice := tpch:extendedprice\n               \u2502         discount := tpch:discount\n               \u2502         tax := tpch:tax\n               \u2502         returnflag := tpch:returnflag\n               \u2502         linestatus := tpch:linestatus\n               \u2502         shipdate := tpch:shipdate\n               \u2502         commitdate := tpch:commitdate\n               \u2502         receiptdate := tpch:receiptdate\n               \u2502         shipinstruct := tpch:shipinstruct\n               \u2502         shipmode := tpch:shipmode\n               \u2502         comment := tpch:comment\n               \u2502         row_number := tpch:row_number\n               \u2514\u2500 Project[]\n                  \u2502   Layout: [orderkey_0:bigint, custkey:bigint, orderstatus:varchar(1), totalprice:double, orderdate:date, orderpriority:varchar(15), clerk:varchar(15), shippriority:integer, comment_1:varchar(79), row_number_2:bigint, expr:bigint]\n                  \u2514\u2500 ScanProject[table = local:orders:sf0.01]\n                         Layout: [orderkey_0:bigint, custkey:bigint, orderstatus:varchar(1), totalprice:double, orderdate:date, orderpriority:varchar(15), clerk:varchar(15), shippriority:integer, comment_1:varchar(79), row_number_2:bigint, expr:bigint]\n                         expr := (\"orderkey_0\" + CAST(1 AS bigint))\n                         orderkey_0 := tpch:orderkey\n                         custkey := tpch:custkey\n                         orderstatus := tpch:orderstatus\n                             :: [[F], [O], [P]]\n                         totalprice := tpch:totalprice\n                         orderdate := tpch:orderdate\n                         orderpriority := tpch:orderpriority\n                         clerk := tpch:clerk\n                         shippriority := tpch:shippriority\n                         comment_1 := tpch:comment\n                         row_number_2 := tpch:row_number\n\n(printed via bc72a40)", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515594574", "createdAt": "2020-11-01T09:51:17Z", "author": {"login": "rzeyde-varada"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +263,81 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        // \"<\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey < orders.orderkey + 1 AND \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNjY0OA=="}, "originalCommit": null, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU5NTAzOA==", "bodyText": "BTW, it seems that the same happens when the complex expression is on the probe-side of the join, i.e.:\nSELECT lineitem.orderkey, orders.orderkey \nFROM lineitem JOIN orders \nON lineitem.orderkey + 1 < orders.orderkey + 1\nThe resulting plan is:\nOutput[orderkey, orderkey]\n\u2502   Layout: [orderkey:bigint, orderkey_0:bigint]\n\u2502   orderkey := orderkey_0\n\u2514\u2500 FilterProject[filterPredicate = (\"expr\" < \"expr_3\")]\n   \u2502   Layout: [orderkey:bigint, orderkey_0:bigint]\n   \u2514\u2500 CrossJoin\n      \u2502   Layout: [orderkey:bigint, expr:bigint, orderkey_0:bigint, expr_3:bigint]\n      \u251c\u2500 ScanProject[table = local:lineitem:sf0.01]\n      \u2502      Layout: [orderkey:bigint, expr:bigint]\n      \u2502      expr := (\"orderkey\" + BIGINT '1')\n      \u2502      orderkey := tpch:orderkey\n      \u2514\u2500 LocalExchange[SINGLE] ()\n         \u2502   Layout: [orderkey_0:bigint, expr_3:bigint]\n         \u2514\u2500 ScanProject[table = local:orders:sf0.01]\n                Layout: [orderkey_0:bigint, expr_3:bigint]\n                expr_3 := (\"orderkey_0\" + BIGINT '1')\n                orderkey_0 := tpch:orderkey\n                tpch:orderstatus\n                    :: [[F], [O], [P]]", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515595038", "createdAt": "2020-11-01T09:56:23Z", "author": {"login": "rzeyde-varada"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +263,81 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        // \"<\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey < orders.orderkey + 1 AND \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNjY0OA=="}, "originalCommit": null, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkyODAxMg==", "bodyText": "I've created #5777", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515928012", "createdAt": "2020-11-02T12:06:57Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +263,81 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        // \"<\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey < orders.orderkey + 1 AND \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNjY0OA=="}, "originalCommit": null, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjkwNzkzOnYy", "diffSide": "RIGHT", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMTowMDo0M1rOHrKJsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNjowNDo0NlrOHrV1EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNzEzNg==", "bodyText": "Could we choose range (or remove comment predicate) so that number of results is less than 6 when clamped (too show that both comparisons are effective)\nlineitem.orderkey <= orders.orderkey alone ensures 6 rows", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515017136", "createdAt": "2020-10-30T11:00:43Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +263,81 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        // \"<\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey < orders.orderkey + 1 AND \" +\n+                            \"orders.comment = 'nstructions sleep furiously among '\",\n+                    withBroadcastJoin(),\n+                    6,\n+                    ImmutableSet.of(6, ORDERS_COUNT));\n+        }\n+        // \"<=\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey <= orders.orderkey AND \" +\n+                            \"orders.comment = 'nstructions sleep furiously among '\",\n+                    withBroadcastJoin(),\n+                    6,\n+                    ImmutableSet.of(6, ORDERS_COUNT));\n+        }\n+        // \"<=\" and \">\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey <= orders.orderkey AND \" +\n+                            \"lineitem.orderkey > orders.orderkey - 1 AND \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIwODQ2NQ==", "bodyText": "I will rewrite the tests to verify this scenario.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515208465", "createdAt": "2020-10-30T16:04:46Z", "author": {"login": "rzeyde-varada"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +263,81 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        // \"<\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey < orders.orderkey + 1 AND \" +\n+                            \"orders.comment = 'nstructions sleep furiously among '\",\n+                    withBroadcastJoin(),\n+                    6,\n+                    ImmutableSet.of(6, ORDERS_COUNT));\n+        }\n+        // \"<=\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey <= orders.orderkey AND \" +\n+                            \"orders.comment = 'nstructions sleep furiously among '\",\n+                    withBroadcastJoin(),\n+                    6,\n+                    ImmutableSet.of(6, ORDERS_COUNT));\n+        }\n+        // \"<=\" and \">\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey <= orders.orderkey AND \" +\n+                            \"lineitem.orderkey > orders.orderkey - 1 AND \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNzEzNg=="}, "originalCommit": null, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzIwNTU5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMTozOToxM1rOHsA6yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMTozOToxM1rOHsA6yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNDQ0Mw==", "bodyText": "nit: reverse sides in O_COMMENT < CAST(L_COMMENT AS varchar(79)) to match join order", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515914443", "createdAt": "2020-11-02T11:39:13Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -141,6 +148,44 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey > l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY > L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableList.of(new DynamicFilterPattern(\"O_ORDERKEY\", GREATER_THAN, \"L_ORDERKEY\")),\n+                                filter(\n+                                        TRUE_LITERAL,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))),\n+                                exchange(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")))))));\n+    }\n+\n+    @Test\n+    public void testCrossJoinInequalityNoDFWithCast()\n+    {\n+        assertPlan(\"SELECT o.comment, l.comment FROM lineitem l, orders o WHERE o.comment < l.comment\",\n+                anyTree(filter(\"O_COMMENT < CAST(L_COMMENT AS varchar(79))\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzIwOTc4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMTo0MDozNVrOHsA9YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMTo0MDozNVrOHsA9YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNTEwNA==", "bodyText": "let's use pattern with Optional.empty() here", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515915104", "createdAt": "2020-11-02T11:40:35Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -355,9 +365,16 @@ public void testInnerInequalityJoinWithEquiJoinConjuncts()\n                                 join(INNER,\n                                         ImmutableList.of(equiJoinClause(\"O_SHIPPRIORITY\", \"L_LINENUMBER\")),\n                                         Optional.of(\"O_ORDERKEY < L_ORDERKEY\"),\n-                                        anyTree(tableScan(\"orders\", ImmutableMap.of(\n-                                                \"O_SHIPPRIORITY\", \"shippriority\",\n-                                                \"O_ORDERKEY\", \"orderkey\"))),\n+                                        Optional.of(ImmutableList.of(\n+                                                new DynamicFilterPattern(\"O_SHIPPRIORITY\", EQUAL, \"L_LINENUMBER\"),\n+                                                new DynamicFilterPattern(\"O_ORDERKEY\", LESS_THAN, \"L_ORDERKEY\"))),\n+                                        Optional.empty(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzIxMjc2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMTo0MTozMFrOHsA_Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMTo0MTozMFrOHsA_Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNTU4Nw==", "bodyText": "add a test case for between here too", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515915587", "createdAt": "2020-11-02T11:41:30Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -141,6 +148,44 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzMwMzIyOnYy", "diffSide": "RIGHT", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMjowOTo1N1rOHsB1Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMjowOTo1N1rOHsB1Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkyOTM1MQ==", "bodyText": "please add a test cases:\nSELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax + 1\nSELECT * FROM probe JOIN build ON v >= vmin AND v <= vmax +1\nSELECT * FROM probe JOIN build WHERE >= vmin AND v <= vmax + 1\nSELECT * FROM probe WHERE v <= (SELECT max(vmax) FROM build)", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515929351", "createdAt": "2020-11-02T12:09:57Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +264,36 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        assertUpdate(\"CREATE TABLE probe (k VARCHAR, v INTEGER)\");\n+        assertUpdate(\"CREATE TABLE build (vmin INTEGER, vmax INTEGER)\");\n+        assertUpdate(\"INSERT INTO probe VALUES ('a', 0), ('b', 1), ('c', 2), ('d', 3)\", 4);\n+        assertUpdate(\"INSERT INTO build VALUES (1, 2)\", 1);\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v <= vmax\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v < vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v < vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v <= vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v < vmax\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND vmax < 0\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v <= vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNzI4NDczOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwOTo1NToxMFrOHsnTLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwOTo1NToxMFrOHsnTLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU0MzI3OA==", "bodyText": "static import", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516543278", "createdAt": "2020-11-03T09:55:10Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -154,11 +176,18 @@ public ExtractResult(List<Expression> staticConjuncts, List<Descriptor> dynamicC\n     {\n         private final DynamicFilterId id;\n         private final Expression input;\n+        private final ComparisonExpression.Operator operator;\n \n-        public Descriptor(DynamicFilterId id, Expression input)\n+        public Descriptor(DynamicFilterId id, Expression input, ComparisonExpression.Operator operator)\n         {\n             this.id = requireNonNull(id, \"id is null\");\n             this.input = requireNonNull(input, \"input is null\");\n+            this.operator = requireNonNull(operator, \"operator is null\");\n+        }\n+\n+        public Descriptor(DynamicFilterId id, Expression input)\n+        {\n+            this(id, input, ComparisonExpression.Operator.EQUAL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNzQ4MTc0OnYy", "diffSide": "RIGHT", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMDo0NDo0OFrOHspLIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMjoxNjo0OFrOHssN0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU3Mzk4NQ==", "bodyText": "From the test I don't know if vmax + 1 filtered anything or not (that's why I suggested vmin + 1). Please change the test so that upper boundary also filters data.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516573985", "createdAt": "2020-11-03T10:44:48Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +264,40 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        assertUpdate(\"CREATE TABLE probe (k VARCHAR, v INTEGER)\");\n+        assertUpdate(\"CREATE TABLE build (vmin INTEGER, vmax INTEGER)\");\n+        assertUpdate(\"INSERT INTO probe VALUES ('a', 0), ('b', 1), ('c', 2), ('d', 3)\", 4);\n+        assertUpdate(\"INSERT INTO build VALUES (1, 2)\", 1);\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v <= vmax\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v < vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v < vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v <= vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v < vmax\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND vmax < 0\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v <= vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax + 1\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYyMzgyNQ==", "bodyText": "Good catch, thanks!\nI've added more tests at testCrossJoinDynamicFiltering to reproduce #5777 and #5755 better.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516623825", "createdAt": "2020-11-03T12:16:48Z", "author": {"login": "rzeyde-varada"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +264,40 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        assertUpdate(\"CREATE TABLE probe (k VARCHAR, v INTEGER)\");\n+        assertUpdate(\"CREATE TABLE build (vmin INTEGER, vmax INTEGER)\");\n+        assertUpdate(\"INSERT INTO probe VALUES ('a', 0), ('b', 1), ('c', 2), ('d', 3)\", 4);\n+        assertUpdate(\"INSERT INTO build VALUES (1, 2)\", 1);\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v <= vmax\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v < vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v < vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v <= vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v < vmax\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND vmax < 0\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v <= vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax + 1\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU3Mzk4NQ=="}, "originalCommit": null, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzODczODU0OnYy", "diffSide": "RIGHT", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNTo1Mzo1NFrOHs1Q_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozNjo0MFrOHs9rmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3MjA5NQ==", "bodyText": "why ImmutableSet.of(1) has one element here?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516772095", "createdAt": "2020-11-03T15:53:54Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +264,61 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        assertUpdate(\"CREATE TABLE probe (k VARCHAR, v INTEGER)\");\n+        assertUpdate(\"CREATE TABLE build (vmin INTEGER, vmax INTEGER)\");\n+        assertUpdate(\"INSERT INTO probe VALUES ('a', 0), ('b', 1), ('c', 2), ('d', 3)\", 4);\n+        assertUpdate(\"INSERT INTO build VALUES (1, 2)\", 1);\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v <= vmax\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v < vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v < vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwOTk3OQ==", "bodyText": "You're right, it's better to use ImmutableList.of(1, 1) here.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516909979", "createdAt": "2020-11-03T19:36:40Z", "author": {"login": "rzeyde-varada"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +264,61 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        assertUpdate(\"CREATE TABLE probe (k VARCHAR, v INTEGER)\");\n+        assertUpdate(\"CREATE TABLE build (vmin INTEGER, vmax INTEGER)\");\n+        assertUpdate(\"INSERT INTO probe VALUES ('a', 0), ('b', 1), ('c', 2), ('d', 3)\", 4);\n+        assertUpdate(\"INSERT INTO build VALUES (1, 2)\", 1);\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v <= vmax\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v < vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v < vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3MjA5NQ=="}, "originalCommit": null, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzODc0MTIzOnYy", "diffSide": "RIGHT", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNTo1NDoyOFrOHs1SvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozNjoxOVrOHs9q5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3MjU0MQ==", "bodyText": "Make assertDynamicFiltering accept ImmutableList", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516772541", "createdAt": "2020-11-03T15:54:28Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -307,7 +363,7 @@ private Session withPartitionedJoin()\n         QueryStats stats = runner.getCoordinator().getQueryManager().getFullQueryInfo(queryId).getQueryStats();\n         return stats.getOperatorSummaries()\n                 .stream()\n-                .filter(summary -> summary.getOperatorType().equals(\"ScanFilterAndProjectOperator\"))\n+                .filter(summary -> summary.getOperatorType().contains(\"Scan\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwOTc5Nw==", "bodyText": "Sounds good, updated the code at 37bcdca.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516909797", "createdAt": "2020-11-03T19:36:19Z", "author": {"login": "rzeyde-varada"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -307,7 +363,7 @@ private Session withPartitionedJoin()\n         QueryStats stats = runner.getCoordinator().getQueryManager().getFullQueryInfo(queryId).getQueryStats();\n         return stats.getOperatorSummaries()\n                 .stream()\n-                .filter(summary -> summary.getOperatorType().equals(\"ScanFilterAndProjectOperator\"))\n+                .filter(summary -> summary.getOperatorType().contains(\"Scan\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3MjU0MQ=="}, "originalCommit": null, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzODc1Mjg5OnYy", "diffSide": "RIGHT", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNTo1Njo1OFrOHs1aPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozNjo0OFrOHs9r1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3NDQ2MA==", "bodyText": "why set has one element?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516774460", "createdAt": "2020-11-03T15:56:58Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +264,61 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        assertUpdate(\"CREATE TABLE probe (k VARCHAR, v INTEGER)\");\n+        assertUpdate(\"CREATE TABLE build (vmin INTEGER, vmax INTEGER)\");\n+        assertUpdate(\"INSERT INTO probe VALUES ('a', 0), ('b', 1), ('c', 2), ('d', 3)\", 4);\n+        assertUpdate(\"INSERT INTO build VALUES (1, 2)\", 1);\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v <= vmax\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v < vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v < vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v <= vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v < vmax\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND vmax < 0\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v <= vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v BETWEEN vmin AND vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v >= vmin AND v <= vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+\n+        // TODO: support complex inequality join clauses: https://github.com/prestosql/presto/issues/5755\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax - 1\", withBroadcastJoin(), 1, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin + 1 AND vmax\", withBroadcastJoin(), 1, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin + 1 AND vmax - 1\", withBroadcastJoin(), 0, ImmutableSet.of(4, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v BETWEEN vmin AND vmax - 1\", withBroadcastJoin(), 1, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v BETWEEN vmin + 1 AND vmax\", withBroadcastJoin(), 1, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v BETWEEN vmin + 1 AND vmax - 1\", withBroadcastJoin(), 0, ImmutableSet.of(4, 1));\n+\n+        // TODO: make sure it works after https://github.com/prestosql/presto/issues/5777 is fixed\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v <= vmax - 1\", withBroadcastJoin(), 1, ImmutableSet.of(1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMDAzNg==", "bodyText": "You're right, it's better to use ImmutableList.of(1, 1) here.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516910036", "createdAt": "2020-11-03T19:36:48Z", "author": {"login": "rzeyde-varada"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +264,61 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        assertUpdate(\"CREATE TABLE probe (k VARCHAR, v INTEGER)\");\n+        assertUpdate(\"CREATE TABLE build (vmin INTEGER, vmax INTEGER)\");\n+        assertUpdate(\"INSERT INTO probe VALUES ('a', 0), ('b', 1), ('c', 2), ('d', 3)\", 4);\n+        assertUpdate(\"INSERT INTO build VALUES (1, 2)\", 1);\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v <= vmax\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v < vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v < vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v <= vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v < vmax\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND vmax < 0\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v <= vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v BETWEEN vmin AND vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v >= vmin AND v <= vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+\n+        // TODO: support complex inequality join clauses: https://github.com/prestosql/presto/issues/5755\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax - 1\", withBroadcastJoin(), 1, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin + 1 AND vmax\", withBroadcastJoin(), 1, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin + 1 AND vmax - 1\", withBroadcastJoin(), 0, ImmutableSet.of(4, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v BETWEEN vmin AND vmax - 1\", withBroadcastJoin(), 1, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v BETWEEN vmin + 1 AND vmax\", withBroadcastJoin(), 1, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v BETWEEN vmin + 1 AND vmax - 1\", withBroadcastJoin(), 0, ImmutableSet.of(4, 1));\n+\n+        // TODO: make sure it works after https://github.com/prestosql/presto/issues/5777 is fixed\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v <= vmax - 1\", withBroadcastJoin(), 1, ImmutableSet.of(1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3NDQ2MA=="}, "originalCommit": null, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTgzNzExOnYy", "diffSide": "RIGHT", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMDozNToyMFrOHtSTGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoxNDoxNVrOHtZ7ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI0Nzc2OQ==", "bodyText": "why no order? Why not to compare lists directly?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r517247769", "createdAt": "2020-11-04T10:35:20Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -260,16 +260,16 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                         \"WHERE t.partkey IN (SELECT p.partkey FROM part p WHERE p.comment = 'onic deposits')\",\n                 withBroadcastJoinNonReordering(),\n                 1,\n-                ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n+                ImmutableList.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n-    private void assertDynamicFiltering(@Language(\"SQL\") String selectQuery, Session session, int expectedRowCount, Set<Integer> expectedOperatorRowsRead)\n+    private void assertDynamicFiltering(@Language(\"SQL\") String selectQuery, Session session, int expectedRowCount, List<Integer> expectedOperatorRowsRead)\n     {\n         DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n         ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(session, selectQuery);\n \n         assertEquals(result.getResult().getRowCount(), expectedRowCount);\n-        assertEquals(getOperatorRowsRead(runner, result.getQueryId()), expectedOperatorRowsRead);\n+        assertEqualsNoOrder(getOperatorRowsRead(runner, result.getQueryId()).toArray(), expectedOperatorRowsRead.toArray());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3Mjc3Mw==", "bodyText": "Sounds good - fixed in 83c7b70a85.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r517372773", "createdAt": "2020-11-04T14:14:15Z", "author": {"login": "rzeyde-varada"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -260,16 +260,16 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                         \"WHERE t.partkey IN (SELECT p.partkey FROM part p WHERE p.comment = 'onic deposits')\",\n                 withBroadcastJoinNonReordering(),\n                 1,\n-                ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n+                ImmutableList.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n-    private void assertDynamicFiltering(@Language(\"SQL\") String selectQuery, Session session, int expectedRowCount, Set<Integer> expectedOperatorRowsRead)\n+    private void assertDynamicFiltering(@Language(\"SQL\") String selectQuery, Session session, int expectedRowCount, List<Integer> expectedOperatorRowsRead)\n     {\n         DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n         ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(session, selectQuery);\n \n         assertEquals(result.getResult().getRowCount(), expectedRowCount);\n-        assertEquals(getOperatorRowsRead(runner, result.getQueryId()), expectedOperatorRowsRead);\n+        assertEqualsNoOrder(getOperatorRowsRead(runner, result.getQueryId()).toArray(), expectedOperatorRowsRead.toArray());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI0Nzc2OQ=="}, "originalCommit": null, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjkyMzMwOnYy", "diffSide": "RIGHT", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNToxNToxM1rOHtcrBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNjoxOTo1M1rOHtfj4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxNzczNA==", "bodyText": "nit: we probably could use vararg here", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r517417734", "createdAt": "2020-11-04T15:15:13Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -106,7 +105,7 @@ public void testJoinDynamicFilteringNone()\n                 \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n                 withBroadcastJoin(),\n                 0,\n-                ImmutableSet.of(0, ORDERS_COUNT));\n+                ImmutableList.of(0, ORDERS_COUNT));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ2NTA1OA==", "bodyText": "Sounds good, changed assertDynamicFiltering to accept int... expectedOperatorRowsRead.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r517465058", "createdAt": "2020-11-04T16:19:53Z", "author": {"login": "rzeyde-varada"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -106,7 +105,7 @@ public void testJoinDynamicFilteringNone()\n                 \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n                 withBroadcastJoin(),\n                 0,\n-                ImmutableSet.of(0, ORDERS_COUNT));\n+                ImmutableList.of(0, ORDERS_COUNT));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxNzczNA=="}, "originalCommit": null, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 983, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}