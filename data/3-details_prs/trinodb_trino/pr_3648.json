{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0MTQ4MTQx", "number": 3648, "title": "Optimize system.jdbc.columns metadata calls", "bodyText": "", "createdAt": "2020-05-06T14:53:06Z", "url": "https://github.com/trinodb/trino/pull/3648", "merged": true, "mergeCommit": {"oid": "fe8fcf0c12d7155291d9abdc0618abf992fc70c1"}, "closed": true, "closedAt": "2020-05-08T06:10:26Z", "author": {"login": "findepi"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcep5-3gFqTQwNjY5NDU1MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcfL1ZkgFqTQwODAyMzEwOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2Njk0NTUx", "url": "https://github.com/trinodb/trino/pull/3648#pullrequestreview-406694551", "createdAt": "2020-05-06T14:53:15Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNDo1MzoxNVrOGRW_hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNDo1MzoxNVrOGRW_hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg1NTY4Ng==", "bodyText": "#3647", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r420855686", "createdAt": "2020-05-06T14:53:15Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/connector/system/SystemTablesMetadata.java", "diffHunk": "@@ -156,12 +157,24 @@ public ConnectorTableProperties getTableProperties(ConnectorSession session, Con\n \n         TupleDomain<ColumnHandle> oldDomain = table.getConstraint();\n         TupleDomain<ColumnHandle> newDomain = oldDomain.intersect(constraint.getSummary());\n+        if (oldDomain.equals(newDomain) && !constraint.predicate().isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        SystemTable systemTable = checkAndGetTable(session, table);\n+        if (systemTable instanceof JdbcTable) {\n+            TupleDomain<ColumnHandle> filtered = ((JdbcTable) systemTable).applyFilter(session, new Constraint(newDomain, constraint.predicate(), constraint.getColumns()));\n+            newDomain = newDomain.intersect(filtered);\n+        }\n+\n         if (oldDomain.equals(newDomain)) {\n             return Optional.empty();\n         }\n \n+        if (newDomain.isNone()) {\n+            // TODO (https://github.com/prestosql/presto/issues/3647) indicate the table scan is empty", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53fcc625392eb2dfc494b9c1218ac31e3a7e13af", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/53fcc625392eb2dfc494b9c1218ac31e3a7e13af", "committedDate": "2020-05-06T15:37:14Z", "message": "Remove redundant condition\n\nThe method is used to get `varchar` `Domain`'s value, so we know the\nvalue is a `Slice`."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e881624eb3d998382a168104e7f1b7add2f2d3d0", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/e881624eb3d998382a168104e7f1b7add2f2d3d0", "committedDate": "2020-05-06T15:37:15Z", "message": "Rename method and make more flexible"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46b104c0f5faee70e62a985dee98ecb4cca746f7", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/46b104c0f5faee70e62a985dee98ecb4cca746f7", "committedDate": "2020-05-06T15:37:16Z", "message": "Replace FilterUtil.filter method\n\nReplace the method with better API."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e0a8ccf73b236910db1d89950a226351a98242f", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/0e0a8ccf73b236910db1d89950a226351a98242f", "committedDate": "2020-05-06T15:37:17Z", "message": "Simplify control flow"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MTMwNjU5", "url": "https://github.com/trinodb/trino/pull/3648#pullrequestreview-407130659", "createdAt": "2020-05-07T03:45:42Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMzo0NTo0M1rOGRtVdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNDowNDo1NFrOGRtn2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMTc0OQ==", "bodyText": "Why special-case JdbcTable? It'd be more naturally (and less code-smelly) to add applyFilter to SystemTable.", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421221749", "createdAt": "2020-05-07T03:45:43Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/connector/system/SystemTablesMetadata.java", "diffHunk": "@@ -156,12 +157,24 @@ public ConnectorTableProperties getTableProperties(ConnectorSession session, Con\n \n         TupleDomain<ColumnHandle> oldDomain = table.getConstraint();\n         TupleDomain<ColumnHandle> newDomain = oldDomain.intersect(constraint.getSummary());\n+        if (oldDomain.equals(newDomain) && !constraint.predicate().isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        SystemTable systemTable = checkAndGetTable(session, table);\n+        if (systemTable instanceof JdbcTable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMjM0MQ==", "bodyText": "In what scenarios would these be empty strings? If this is just an optimization, add a comment.", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421222341", "createdAt": "2020-05-07T03:48:11Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/connector/system/jdbc/ColumnJdbcTable.java", "diffHunk": "@@ -111,24 +139,155 @@ public ConnectorTableMetadata getTableMetadata()\n         return METADATA;\n     }\n \n+    @Override\n+    public TupleDomain<ColumnHandle> applyFilter(ConnectorSession connectorSession, Constraint constraint)\n+    {\n+        TupleDomain<ColumnHandle> tupleDomain = constraint.getSummary();\n+        if (tupleDomain.isNone() || !constraint.predicate().isPresent()) {\n+            return tupleDomain;\n+        }\n+        Predicate<Map<ColumnHandle, NullableValue>> predicate = constraint.predicate().get();\n+        Set<ColumnHandle> predicateColumns = constraint.getColumns().orElseThrow(() -> new VerifyException(\"columns not present for a predicate\"));\n+\n+        boolean hasSchemaPredicate = predicateColumns.contains(TABLE_SCHEMA_COLUMN);\n+        boolean hasTablePredicate = predicateColumns.contains(TABLE_NAME_COLUMN);\n+        if (!hasSchemaPredicate && !hasTablePredicate) {\n+            // No filter on schema name and table name at all.\n+            return tupleDomain;\n+        }\n+\n+        Session session = ((FullConnectorSession) connectorSession).getSession();\n+\n+        Optional<String> catalogFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_CATALOG_COLUMN);\n+        Optional<String> schemaFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_SCHEMA_COLUMN);\n+        Optional<String> tableFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_NAME_COLUMN);\n+\n+        if (catalogFilter.equals(Optional.of(\"\")) ||\n+                schemaFilter.equals(Optional.of(\"\")) ||\n+                tableFilter.equals(Optional.of(\"\"))) {\n+            return TupleDomain.none();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyNTkxOA==", "bodyText": "Using ImmutableMap.builder() is less sensitive to reformatting changes that may end up placing arguments in separate lines (and even if that happens, it's still clear which ones are keys and which ones are values). TLDR, when there are multiple entries, it's more robust to use the builder form than the multi-entry ImmutableMap.of().", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421225918", "createdAt": "2020-05-07T04:02:33Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/connector/system/jdbc/ColumnJdbcTable.java", "diffHunk": "@@ -111,24 +139,155 @@ public ConnectorTableMetadata getTableMetadata()\n         return METADATA;\n     }\n \n+    @Override\n+    public TupleDomain<ColumnHandle> applyFilter(ConnectorSession connectorSession, Constraint constraint)\n+    {\n+        TupleDomain<ColumnHandle> tupleDomain = constraint.getSummary();\n+        if (tupleDomain.isNone() || !constraint.predicate().isPresent()) {\n+            return tupleDomain;\n+        }\n+        Predicate<Map<ColumnHandle, NullableValue>> predicate = constraint.predicate().get();\n+        Set<ColumnHandle> predicateColumns = constraint.getColumns().orElseThrow(() -> new VerifyException(\"columns not present for a predicate\"));\n+\n+        boolean hasSchemaPredicate = predicateColumns.contains(TABLE_SCHEMA_COLUMN);\n+        boolean hasTablePredicate = predicateColumns.contains(TABLE_NAME_COLUMN);\n+        if (!hasSchemaPredicate && !hasTablePredicate) {\n+            // No filter on schema name and table name at all.\n+            return tupleDomain;\n+        }\n+\n+        Session session = ((FullConnectorSession) connectorSession).getSession();\n+\n+        Optional<String> catalogFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_CATALOG_COLUMN);\n+        Optional<String> schemaFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_SCHEMA_COLUMN);\n+        Optional<String> tableFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_NAME_COLUMN);\n+\n+        if (catalogFilter.equals(Optional.of(\"\")) ||\n+                schemaFilter.equals(Optional.of(\"\")) ||\n+                tableFilter.equals(Optional.of(\"\"))) {\n+            return TupleDomain.none();\n+        }\n+\n+        List<String> catalogs = listCatalogs(session, metadata, accessControl, catalogFilter).keySet().stream()\n+                .filter(catalogName -> predicate.test(ImmutableMap.of(TABLE_CATALOG_COLUMN, toNullableValue(catalogName))))\n+                .collect(toImmutableList());\n+\n+        List<CatalogSchemaName> schemas = catalogs.stream()\n+                .flatMap(catalogName ->\n+                        listSchemas(session, metadata, accessControl, catalogName, schemaFilter).stream()\n+                                .filter(schemaName -> !hasSchemaPredicate || predicate.test(ImmutableMap.of(\n+                                        TABLE_CATALOG_COLUMN, toNullableValue(catalogName),\n+                                        TABLE_SCHEMA_COLUMN, toNullableValue(schemaName))))\n+                                .map(schemaName -> new CatalogSchemaName(catalogName, schemaName)))\n+                .collect(toImmutableList());\n+\n+        if (!hasTablePredicate) {\n+            return TupleDomain.withColumnDomains(ImmutableMap.of(\n+                    TABLE_CATALOG_COLUMN, schemas.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyNjQ1OQ==", "bodyText": ".simplify(...) on the next line", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421226459", "createdAt": "2020-05-07T04:04:54Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/connector/system/jdbc/ColumnJdbcTable.java", "diffHunk": "@@ -111,24 +139,155 @@ public ConnectorTableMetadata getTableMetadata()\n         return METADATA;\n     }\n \n+    @Override\n+    public TupleDomain<ColumnHandle> applyFilter(ConnectorSession connectorSession, Constraint constraint)\n+    {\n+        TupleDomain<ColumnHandle> tupleDomain = constraint.getSummary();\n+        if (tupleDomain.isNone() || !constraint.predicate().isPresent()) {\n+            return tupleDomain;\n+        }\n+        Predicate<Map<ColumnHandle, NullableValue>> predicate = constraint.predicate().get();\n+        Set<ColumnHandle> predicateColumns = constraint.getColumns().orElseThrow(() -> new VerifyException(\"columns not present for a predicate\"));\n+\n+        boolean hasSchemaPredicate = predicateColumns.contains(TABLE_SCHEMA_COLUMN);\n+        boolean hasTablePredicate = predicateColumns.contains(TABLE_NAME_COLUMN);\n+        if (!hasSchemaPredicate && !hasTablePredicate) {\n+            // No filter on schema name and table name at all.\n+            return tupleDomain;\n+        }\n+\n+        Session session = ((FullConnectorSession) connectorSession).getSession();\n+\n+        Optional<String> catalogFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_CATALOG_COLUMN);\n+        Optional<String> schemaFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_SCHEMA_COLUMN);\n+        Optional<String> tableFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_NAME_COLUMN);\n+\n+        if (catalogFilter.equals(Optional.of(\"\")) ||\n+                schemaFilter.equals(Optional.of(\"\")) ||\n+                tableFilter.equals(Optional.of(\"\"))) {\n+            return TupleDomain.none();\n+        }\n+\n+        List<String> catalogs = listCatalogs(session, metadata, accessControl, catalogFilter).keySet().stream()\n+                .filter(catalogName -> predicate.test(ImmutableMap.of(TABLE_CATALOG_COLUMN, toNullableValue(catalogName))))\n+                .collect(toImmutableList());\n+\n+        List<CatalogSchemaName> schemas = catalogs.stream()\n+                .flatMap(catalogName ->\n+                        listSchemas(session, metadata, accessControl, catalogName, schemaFilter).stream()\n+                                .filter(schemaName -> !hasSchemaPredicate || predicate.test(ImmutableMap.of(\n+                                        TABLE_CATALOG_COLUMN, toNullableValue(catalogName),\n+                                        TABLE_SCHEMA_COLUMN, toNullableValue(schemaName))))\n+                                .map(schemaName -> new CatalogSchemaName(catalogName, schemaName)))\n+                .collect(toImmutableList());\n+\n+        if (!hasTablePredicate) {\n+            return TupleDomain.withColumnDomains(ImmutableMap.of(\n+                    TABLE_CATALOG_COLUMN, schemas.stream()\n+                            .map(CatalogSchemaName::getCatalogName)\n+                            .collect(toVarcharDomain())\n+                            .simplify(MAX_DOMAIN_SIZE),\n+                    TABLE_SCHEMA_COLUMN, schemas.stream()\n+                            .map(CatalogSchemaName::getSchemaName)\n+                            .collect(toVarcharDomain())\n+                            .simplify(MAX_DOMAIN_SIZE)));\n+        }\n+\n+        List<CatalogSchemaTableName> tables = schemas.stream()\n+                .flatMap(schema -> {\n+                    QualifiedTablePrefix tablePrefix = tableFilter.isPresent()\n+                            ? new QualifiedTablePrefix(schema.getCatalogName(), schema.getSchemaName(), tableFilter.get())\n+                            : new QualifiedTablePrefix(schema.getCatalogName(), schema.getSchemaName());\n+                    return listTables(session, metadata, accessControl, tablePrefix).stream()\n+                            .filter(schemaTableName -> predicate.test(ImmutableMap.of(\n+                                    TABLE_CATALOG_COLUMN, toNullableValue(schema.getCatalogName()),\n+                                    TABLE_SCHEMA_COLUMN, toNullableValue(schemaTableName.getSchemaName()),\n+                                    TABLE_NAME_COLUMN, toNullableValue(schemaTableName.getTableName()))))\n+                            .map(schemaTableName -> new CatalogSchemaTableName(schema.getCatalogName(), schemaTableName.getSchemaName(), schemaTableName.getTableName()));\n+                })\n+                .collect(toImmutableList());\n+\n+        return TupleDomain.withColumnDomains(ImmutableMap.of(\n+                TABLE_CATALOG_COLUMN, tables.stream()\n+                        .map(CatalogSchemaTableName::getCatalogName)\n+                        .collect(toVarcharDomain()).simplify(MAX_DOMAIN_SIZE),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 144}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "e13b802b1f8429471472711ce5551b24231ff45f", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/e13b802b1f8429471472711ce5551b24231ff45f", "committedDate": "2020-05-07T21:42:50Z", "message": "Move empty table name check to MetadataManager\n\n`MetadataManager` does not correctly behave when asked for `new\nQualifiedObjectName(\"\", \"\", \"\")` table or view.\n\nThis was previously worked around in the `information_schema`\nconnector, but since it applies to other metadata users, it should be\nfixed in `MetadataManager` directly."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b82112eb15004567793b2c72a115918c93283b6", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/2b82112eb15004567793b2c72a115918c93283b6", "committedDate": "2020-05-07T21:42:50Z", "message": "Optimize system.jdbc.columns metadata calls"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "2b82112eb15004567793b2c72a115918c93283b6", "author": {"user": {"login": "findepi", "name": "Piotr Findeisen"}}, "url": "https://github.com/trinodb/trino/commit/2b82112eb15004567793b2c72a115918c93283b6", "committedDate": "2020-05-07T21:42:50Z", "message": "Optimize system.jdbc.columns metadata calls"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MDEyNTUz", "url": "https://github.com/trinodb/trino/pull/3648#pullrequestreview-408012553", "createdAt": "2020-05-08T05:54:33Z", "commit": {"oid": "2b82112eb15004567793b2c72a115918c93283b6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MDIzMTA5", "url": "https://github.com/trinodb/trino/pull/3648#pullrequestreview-408023109", "createdAt": "2020-05-08T06:23:58Z", "commit": {"oid": "2b82112eb15004567793b2c72a115918c93283b6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNjoyMzo1OFrOGSak1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNjoyMzo1OFrOGSak1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk2Mjk2NA==", "bodyText": "Nice!", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421962964", "createdAt": "2020-05-08T06:23:58Z", "author": {"login": "kokosing"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestPrestoDatabaseMetaData.java", "diffHunk": "@@ -1169,22 +1169,52 @@ public void testGetColumnsMetadataCalls()\n                         list(\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"TYPE_NAME\")),\n                 list(list(COUNTING_CATALOG, \"test_schema1\", \"test_table1\", \"column_17\", \"varchar\")),\n                 new MetadataCallsCount()\n-                        .withListSchemasCount(1)\n-                        .withListTablesCount(2)\n-                        .withGetColumnsCount(3000));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b82112eb15004567793b2c72a115918c93283b6"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1413, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}