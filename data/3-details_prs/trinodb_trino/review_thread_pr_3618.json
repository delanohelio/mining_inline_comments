{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzMTU4Mzc5", "number": 3618, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMjo0MTo0MVrOD6EWxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMzoxMjoyMlrOD6ErwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjE1MzY0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/type/LikeFunctions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMjo0MTo0MVrOGRsW1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjoxMDo1NFrOGRvu7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwNTcxNw==", "bodyText": "Why not return true directly here? It's more explicit and doesn't require additional reasoning about what the condition in the return clause below says.", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421205717", "createdAt": "2020-05-07T02:41:41Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/type/LikeFunctions.java", "diffHunk": "@@ -133,11 +135,12 @@ else if (escaped) {\n                 escaped = false;\n             }\n             else if ((currentChar == '%') || (currentChar == '_')) {\n-                isLikePattern = true;\n+                break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2MTAzOQ==", "bodyText": "that function used to validate wellformedness, but yeah, i don't think it's necessary (nor preserved)", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421261039", "createdAt": "2020-05-07T06:10:54Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/type/LikeFunctions.java", "diffHunk": "@@ -133,11 +135,12 @@ else if (escaped) {\n                 escaped = false;\n             }\n             else if ((currentChar == '%') || (currentChar == '_')) {\n-                isLikePattern = true;\n+                break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwNTcxNw=="}, "originalCommit": null, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjE1NjA5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/type/LikeFunctions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMjo0MzoyNVrOGRsYTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMjo0MzoyNVrOGRsYTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwNjA5Mw==", "bodyText": "Extract lengthOfCodePoint(currentChar) above the if and reuse in the else branch.", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421206093", "createdAt": "2020-05-07T02:43:25Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/type/LikeFunctions.java", "diffHunk": "@@ -146,20 +149,27 @@ public static Slice unescapeLiteralLikePattern(Slice pattern, Optional<Slice> es\n             return pattern;\n         }\n \n-        char escapeChar = getEscapeCharacter(escape).get();\n-        String stringPattern = pattern.toStringUtf8();\n-        StringBuilder unescapedPattern = new StringBuilder(stringPattern.length());\n+        int escapeChar = getEscapeCharacter(escape)\n+                .map(c -> (int) c)\n+                .orElse(-1);\n+\n+        @SuppressWarnings(\"resource\")\n+        DynamicSliceOutput output = new DynamicSliceOutput(pattern.length());\n         boolean escaped = false;\n-        for (int currentChar : stringPattern.codePoints().toArray()) {\n+        int position = 0;\n+        while (position < pattern.length()) {\n+            int currentChar = getCodePointAt(pattern, position);\n             if (!escaped && (currentChar == escapeChar)) {\n                 escaped = true;\n             }\n             else {\n-                unescapedPattern.append(Character.toChars(currentChar));\n+                output.writeBytes(pattern, position, lengthOfCodePoint(currentChar));\n                 escaped = false;\n             }\n+            position += lengthOfCodePoint(currentChar);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjE3MzMwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMjo1Mjo1NFrOGRsiNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMjo1Mjo1NFrOGRsiNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwODYyOA==", "bodyText": "typo", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421208628", "createdAt": "2020-05-07T02:52:54Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "diffHunk": "@@ -857,6 +867,88 @@ protected ExtractionResult visitBetweenPredicate(BetweenPredicate node, Boolean\n                     new ComparisonExpression(LESS_THAN_OR_EQUAL, node.getValue(), node.getMax())), complement);\n         }\n \n+        @Override\n+        protected ExtractionResult visitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            Optional<ExtractionResult> result = tryVisitLikePredicate(node, complement);\n+            if (result.isPresent()) {\n+                return result.get();\n+            }\n+            return super.visitLikePredicate(node, complement);\n+        }\n+\n+        private Optional<ExtractionResult> tryVisitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            if (!(node.getValue() instanceof SymbolReference)) {\n+                // LIKE not on a symbol\n+                return Optional.empty();\n+            }\n+\n+            if (!(node.getPattern() instanceof StringLiteral)) {\n+                // dyamic pattern", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjE5MTA4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMzowMjo0MVrOGRssjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjoxMzo0MVrOGRvypg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMTI3Ng==", "bodyText": "This should never really happen. Like expressions with constant patterns are turned into comparison expressions when ExpressionInterpreter is used to optimize expressions.", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421211276", "createdAt": "2020-05-07T03:02:41Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "diffHunk": "@@ -857,6 +867,88 @@ protected ExtractionResult visitBetweenPredicate(BetweenPredicate node, Boolean\n                     new ComparisonExpression(LESS_THAN_OR_EQUAL, node.getValue(), node.getMax())), complement);\n         }\n \n+        @Override\n+        protected ExtractionResult visitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            Optional<ExtractionResult> result = tryVisitLikePredicate(node, complement);\n+            if (result.isPresent()) {\n+                return result.get();\n+            }\n+            return super.visitLikePredicate(node, complement);\n+        }\n+\n+        private Optional<ExtractionResult> tryVisitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            if (!(node.getValue() instanceof SymbolReference)) {\n+                // LIKE not on a symbol\n+                return Optional.empty();\n+            }\n+\n+            if (!(node.getPattern() instanceof StringLiteral)) {\n+                // dyamic pattern\n+                return Optional.empty();\n+            }\n+\n+            if (node.getEscape().isPresent() && !(node.getEscape().get() instanceof StringLiteral)) {\n+                // dynamic escape\n+                return Optional.empty();\n+            }\n+\n+            Type type = typeAnalyzer.getType(session, types, node.getValue());\n+            if (!(type instanceof VarcharType)) {\n+                // not varchar\n+                return Optional.empty();\n+            }\n+            VarcharType varcharType = (VarcharType) type;\n+\n+            Symbol symbol = Symbol.from(node.getValue());\n+            Slice pattern = ((StringLiteral) node.getPattern()).getSlice();\n+            Optional<Slice> escape = node.getEscape()\n+                    .map(StringLiteral.class::cast)\n+                    .map(StringLiteral::getSlice);\n+\n+            int patternConstantPrefixBytes = LikeFunctions.patternConstantPrefixBytes(pattern, escape);\n+            if (patternConstantPrefixBytes == pattern.length()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2MTk5MA==", "bodyText": "Yes, I know. At the same time, it didn't feel right to fail or give up here.\nI will add a comment.", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421261990", "createdAt": "2020-05-07T06:13:41Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "diffHunk": "@@ -857,6 +867,88 @@ protected ExtractionResult visitBetweenPredicate(BetweenPredicate node, Boolean\n                     new ComparisonExpression(LESS_THAN_OR_EQUAL, node.getValue(), node.getMax())), complement);\n         }\n \n+        @Override\n+        protected ExtractionResult visitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            Optional<ExtractionResult> result = tryVisitLikePredicate(node, complement);\n+            if (result.isPresent()) {\n+                return result.get();\n+            }\n+            return super.visitLikePredicate(node, complement);\n+        }\n+\n+        private Optional<ExtractionResult> tryVisitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            if (!(node.getValue() instanceof SymbolReference)) {\n+                // LIKE not on a symbol\n+                return Optional.empty();\n+            }\n+\n+            if (!(node.getPattern() instanceof StringLiteral)) {\n+                // dyamic pattern\n+                return Optional.empty();\n+            }\n+\n+            if (node.getEscape().isPresent() && !(node.getEscape().get() instanceof StringLiteral)) {\n+                // dynamic escape\n+                return Optional.empty();\n+            }\n+\n+            Type type = typeAnalyzer.getType(session, types, node.getValue());\n+            if (!(type instanceof VarcharType)) {\n+                // not varchar\n+                return Optional.empty();\n+            }\n+            VarcharType varcharType = (VarcharType) type;\n+\n+            Symbol symbol = Symbol.from(node.getValue());\n+            Slice pattern = ((StringLiteral) node.getPattern()).getSlice();\n+            Optional<Slice> escape = node.getEscape()\n+                    .map(StringLiteral.class::cast)\n+                    .map(StringLiteral::getSlice);\n+\n+            int patternConstantPrefixBytes = LikeFunctions.patternConstantPrefixBytes(pattern, escape);\n+            if (patternConstantPrefixBytes == pattern.length()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMTI3Ng=="}, "originalCommit": null, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjE5ODQzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMzowNzowOFrOGRsw7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMDoyMzoyNVrOGR4NCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMjM5OQ==", "bodyText": "This comment is redundant. It'd be useful to, instead, explain why only varchar is supported (the only other option is char)", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421212399", "createdAt": "2020-05-07T03:07:08Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "diffHunk": "@@ -857,6 +867,88 @@ protected ExtractionResult visitBetweenPredicate(BetweenPredicate node, Boolean\n                     new ComparisonExpression(LESS_THAN_OR_EQUAL, node.getValue(), node.getMax())), complement);\n         }\n \n+        @Override\n+        protected ExtractionResult visitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            Optional<ExtractionResult> result = tryVisitLikePredicate(node, complement);\n+            if (result.isPresent()) {\n+                return result.get();\n+            }\n+            return super.visitLikePredicate(node, complement);\n+        }\n+\n+        private Optional<ExtractionResult> tryVisitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            if (!(node.getValue() instanceof SymbolReference)) {\n+                // LIKE not on a symbol\n+                return Optional.empty();\n+            }\n+\n+            if (!(node.getPattern() instanceof StringLiteral)) {\n+                // dyamic pattern\n+                return Optional.empty();\n+            }\n+\n+            if (node.getEscape().isPresent() && !(node.getEscape().get() instanceof StringLiteral)) {\n+                // dynamic escape\n+                return Optional.empty();\n+            }\n+\n+            Type type = typeAnalyzer.getType(session, types, node.getValue());\n+            if (!(type instanceof VarcharType)) {\n+                // not varchar", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM5OTgxOQ==", "bodyText": "replaced with TODO support CharType", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421399819", "createdAt": "2020-05-07T10:23:25Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "diffHunk": "@@ -857,6 +867,88 @@ protected ExtractionResult visitBetweenPredicate(BetweenPredicate node, Boolean\n                     new ComparisonExpression(LESS_THAN_OR_EQUAL, node.getValue(), node.getMax())), complement);\n         }\n \n+        @Override\n+        protected ExtractionResult visitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            Optional<ExtractionResult> result = tryVisitLikePredicate(node, complement);\n+            if (result.isPresent()) {\n+                return result.get();\n+            }\n+            return super.visitLikePredicate(node, complement);\n+        }\n+\n+        private Optional<ExtractionResult> tryVisitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            if (!(node.getValue() instanceof SymbolReference)) {\n+                // LIKE not on a symbol\n+                return Optional.empty();\n+            }\n+\n+            if (!(node.getPattern() instanceof StringLiteral)) {\n+                // dyamic pattern\n+                return Optional.empty();\n+            }\n+\n+            if (node.getEscape().isPresent() && !(node.getEscape().get() instanceof StringLiteral)) {\n+                // dynamic escape\n+                return Optional.empty();\n+            }\n+\n+            Type type = typeAnalyzer.getType(session, types, node.getValue());\n+            if (!(type instanceof VarcharType)) {\n+                // not varchar", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMjM5OQ=="}, "originalCommit": null, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjIwNzM3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMzoxMjoyMlrOGRs2CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMDozMTowNFrOGR4dFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMzcwNQ==", "bodyText": "This comment confused me at first reading. I thought it meant that the prefix had to be all ASCII, but the code below says otherwise (i.e., find the last ASCII character).", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421213705", "createdAt": "2020-05-07T03:12:22Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "diffHunk": "@@ -857,6 +867,88 @@ protected ExtractionResult visitBetweenPredicate(BetweenPredicate node, Boolean\n                     new ComparisonExpression(LESS_THAN_OR_EQUAL, node.getValue(), node.getMax())), complement);\n         }\n \n+        @Override\n+        protected ExtractionResult visitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            Optional<ExtractionResult> result = tryVisitLikePredicate(node, complement);\n+            if (result.isPresent()) {\n+                return result.get();\n+            }\n+            return super.visitLikePredicate(node, complement);\n+        }\n+\n+        private Optional<ExtractionResult> tryVisitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            if (!(node.getValue() instanceof SymbolReference)) {\n+                // LIKE not on a symbol\n+                return Optional.empty();\n+            }\n+\n+            if (!(node.getPattern() instanceof StringLiteral)) {\n+                // dyamic pattern\n+                return Optional.empty();\n+            }\n+\n+            if (node.getEscape().isPresent() && !(node.getEscape().get() instanceof StringLiteral)) {\n+                // dynamic escape\n+                return Optional.empty();\n+            }\n+\n+            Type type = typeAnalyzer.getType(session, types, node.getValue());\n+            if (!(type instanceof VarcharType)) {\n+                // not varchar\n+                return Optional.empty();\n+            }\n+            VarcharType varcharType = (VarcharType) type;\n+\n+            Symbol symbol = Symbol.from(node.getValue());\n+            Slice pattern = ((StringLiteral) node.getPattern()).getSlice();\n+            Optional<Slice> escape = node.getEscape()\n+                    .map(StringLiteral.class::cast)\n+                    .map(StringLiteral::getSlice);\n+\n+            int patternConstantPrefixBytes = LikeFunctions.patternConstantPrefixBytes(pattern, escape);\n+            if (patternConstantPrefixBytes == pattern.length()) {\n+                Slice literal = LikeFunctions.unescapeLiteralLikePattern(pattern, escape);\n+                ValueSet valueSet;\n+                if (varcharType.isUnbounded() || countCodePoints(literal) <= varcharType.getBoundedLength()) {\n+                    valueSet = ValueSet.of(type, literal);\n+                }\n+                else {\n+                    // impossible to satisfy\n+                    valueSet = ValueSet.none(type);\n+                }\n+                Domain domain = Domain.create(complementIfNecessary(valueSet, complement), false);\n+                return Optional.of(new ExtractionResult(TupleDomain.withColumnDomains(ImmutableMap.of(symbol, domain)), TRUE_LITERAL));\n+            }\n+\n+            if (complement || patternConstantPrefixBytes == 0) {\n+                // TODO\n+                return Optional.empty();\n+            }\n+\n+            Slice constantPrefix = LikeFunctions.unescapeLiteralLikePattern(pattern.slice(0, patternConstantPrefixBytes), escape);\n+\n+            int lastIncrementable = -1;\n+            for (int position = 0; position < constantPrefix.length(); position += lengthOfCodePoint(constantPrefix, position)) {\n+                // stay within ASCII to be on the safe side with connectors TODO remove this limitation", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwMzkyNw==", "bodyText": "reworded", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421403927", "createdAt": "2020-05-07T10:31:04Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "diffHunk": "@@ -857,6 +867,88 @@ protected ExtractionResult visitBetweenPredicate(BetweenPredicate node, Boolean\n                     new ComparisonExpression(LESS_THAN_OR_EQUAL, node.getValue(), node.getMax())), complement);\n         }\n \n+        @Override\n+        protected ExtractionResult visitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            Optional<ExtractionResult> result = tryVisitLikePredicate(node, complement);\n+            if (result.isPresent()) {\n+                return result.get();\n+            }\n+            return super.visitLikePredicate(node, complement);\n+        }\n+\n+        private Optional<ExtractionResult> tryVisitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            if (!(node.getValue() instanceof SymbolReference)) {\n+                // LIKE not on a symbol\n+                return Optional.empty();\n+            }\n+\n+            if (!(node.getPattern() instanceof StringLiteral)) {\n+                // dyamic pattern\n+                return Optional.empty();\n+            }\n+\n+            if (node.getEscape().isPresent() && !(node.getEscape().get() instanceof StringLiteral)) {\n+                // dynamic escape\n+                return Optional.empty();\n+            }\n+\n+            Type type = typeAnalyzer.getType(session, types, node.getValue());\n+            if (!(type instanceof VarcharType)) {\n+                // not varchar\n+                return Optional.empty();\n+            }\n+            VarcharType varcharType = (VarcharType) type;\n+\n+            Symbol symbol = Symbol.from(node.getValue());\n+            Slice pattern = ((StringLiteral) node.getPattern()).getSlice();\n+            Optional<Slice> escape = node.getEscape()\n+                    .map(StringLiteral.class::cast)\n+                    .map(StringLiteral::getSlice);\n+\n+            int patternConstantPrefixBytes = LikeFunctions.patternConstantPrefixBytes(pattern, escape);\n+            if (patternConstantPrefixBytes == pattern.length()) {\n+                Slice literal = LikeFunctions.unescapeLiteralLikePattern(pattern, escape);\n+                ValueSet valueSet;\n+                if (varcharType.isUnbounded() || countCodePoints(literal) <= varcharType.getBoundedLength()) {\n+                    valueSet = ValueSet.of(type, literal);\n+                }\n+                else {\n+                    // impossible to satisfy\n+                    valueSet = ValueSet.none(type);\n+                }\n+                Domain domain = Domain.create(complementIfNecessary(valueSet, complement), false);\n+                return Optional.of(new ExtractionResult(TupleDomain.withColumnDomains(ImmutableMap.of(symbol, domain)), TRUE_LITERAL));\n+            }\n+\n+            if (complement || patternConstantPrefixBytes == 0) {\n+                // TODO\n+                return Optional.empty();\n+            }\n+\n+            Slice constantPrefix = LikeFunctions.unescapeLiteralLikePattern(pattern.slice(0, patternConstantPrefixBytes), escape);\n+\n+            int lastIncrementable = -1;\n+            for (int position = 0; position < constantPrefix.length(); position += lengthOfCodePoint(constantPrefix, position)) {\n+                // stay within ASCII to be on the safe side with connectors TODO remove this limitation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMzcwNQ=="}, "originalCommit": null, "originalPosition": 111}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 23, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}