{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcyNDA1MDgy", "number": 4946, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMDozODozNlrOEbgptQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNDozMDo1M1rOEcGPzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MjgxOTczOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFilterConsumer.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMDozODozNlrOHFe1VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMzo0NDozN1rOHGYx-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxMDEwMQ==", "bodyText": "If you want to assume each DynamicFilterId has an entry in the Map, you would need to change the return result.getDomains().get() below too. However, it seems to be like having inexplicit assumptions in the data model, which are not necessary. Can we handle this in eg in io.prestosql.operator.TaskContext#collectDynamicTupleDomain instead?", "url": "https://github.com/trinodb/trino/pull/4946#discussion_r475510101", "createdAt": "2020-08-24T10:38:36Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFilterConsumer.java", "diffHunk": "@@ -144,6 +144,11 @@ private void addPartition(TupleDomain<DynamicFilterId> tupleDomain)\n             return buildChannels.keySet().stream()\n                     .collect(toImmutableMap(identity(), filterId -> Domain.none(filterBuildTypes.get(filterId))));\n         }\n+        if (result.isAll()) {\n+            // Set `all` domain explicitly for dynamic filters so that it can be waited for\n+            return buildChannels.keySet().stream()\n+                    .collect(toImmutableMap(identity(), filterId -> Domain.all(filterBuildTypes.get(filterId))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxMjExOA==", "bodyText": "If you want to assume each DynamicFilterId has an entry in the Map, you would need to change the return result.getDomains().get() below too. However, it seems to be like having inexplicit assumptions in the data model, which are not necessary.\n\nWhat do you mean by you would need to change the return result.getDomains().get() below too. The only special cases for TupleDomain are all and none. For other cases there is an explicit mapping between filter id and domain.\n\nCan we handle this in eg in io.prestosql.operator.TaskContext#collectDynamicTupleDomain instead?\n\nTaskContext doesn't know what DFs there are.", "url": "https://github.com/trinodb/trino/pull/4946#discussion_r475512118", "createdAt": "2020-08-24T10:43:04Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFilterConsumer.java", "diffHunk": "@@ -144,6 +144,11 @@ private void addPartition(TupleDomain<DynamicFilterId> tupleDomain)\n             return buildChannels.keySet().stream()\n                     .collect(toImmutableMap(identity(), filterId -> Domain.none(filterBuildTypes.get(filterId))));\n         }\n+        if (result.isAll()) {\n+            // Set `all` domain explicitly for dynamic filters so that it can be waited for\n+            return buildChannels.keySet().stream()\n+                    .collect(toImmutableMap(identity(), filterId -> Domain.all(filterBuildTypes.get(filterId))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxMDEwMQ=="}, "originalCommit": null, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3OTUzMA==", "bodyText": "I've added assertion so that all expected DFs are present during result.getDomains().get() call", "url": "https://github.com/trinodb/trino/pull/4946#discussion_r475579530", "createdAt": "2020-08-24T12:55:12Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFilterConsumer.java", "diffHunk": "@@ -144,6 +144,11 @@ private void addPartition(TupleDomain<DynamicFilterId> tupleDomain)\n             return buildChannels.keySet().stream()\n                     .collect(toImmutableMap(identity(), filterId -> Domain.none(filterBuildTypes.get(filterId))));\n         }\n+        if (result.isAll()) {\n+            // Set `all` domain explicitly for dynamic filters so that it can be waited for\n+            return buildChannels.keySet().stream()\n+                    .collect(toImmutableMap(identity(), filterId -> Domain.all(filterBuildTypes.get(filterId))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxMDEwMQ=="}, "originalCommit": null, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4OTMwMw==", "bodyText": "The TupleDomain's map does not contain any Domain.all entries.\nSo TupleDomain.all (empty map) does not need to be treated as a special case.", "url": "https://github.com/trinodb/trino/pull/4946#discussion_r475589303", "createdAt": "2020-08-24T13:12:29Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFilterConsumer.java", "diffHunk": "@@ -144,6 +144,11 @@ private void addPartition(TupleDomain<DynamicFilterId> tupleDomain)\n             return buildChannels.keySet().stream()\n                     .collect(toImmutableMap(identity(), filterId -> Domain.none(filterBuildTypes.get(filterId))));\n         }\n+        if (result.isAll()) {\n+            // Set `all` domain explicitly for dynamic filters so that it can be waited for\n+            return buildChannels.keySet().stream()\n+                    .collect(toImmutableMap(identity(), filterId -> Domain.all(filterBuildTypes.get(filterId))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxMDEwMQ=="}, "originalCommit": null, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5OTAwNA==", "bodyText": "So TupleDomain.all (empty map) does not need to be treated as a special case.\n\nIt does. Let's suppose there is listener for DF1. It might happen that build side is too large and TupleDomain.all() is reported. In that case we need to explicitly set DF1 domain to all. Otherwise listener won't know that DF is available.", "url": "https://github.com/trinodb/trino/pull/4946#discussion_r475599004", "createdAt": "2020-08-24T13:28:19Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFilterConsumer.java", "diffHunk": "@@ -144,6 +144,11 @@ private void addPartition(TupleDomain<DynamicFilterId> tupleDomain)\n             return buildChannels.keySet().stream()\n                     .collect(toImmutableMap(identity(), filterId -> Domain.none(filterBuildTypes.get(filterId))));\n         }\n+        if (result.isAll()) {\n+            // Set `all` domain explicitly for dynamic filters so that it can be waited for\n+            return buildChannels.keySet().stream()\n+                    .collect(toImmutableMap(identity(), filterId -> Domain.all(filterBuildTypes.get(filterId))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxMDEwMQ=="}, "originalCommit": null, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ1OTUxMw==", "bodyText": "@findepi I've updated the code. Indeed, Domain.all would be removed from TupleDomain. I've added support for that case along with test. However, in practice this wasn't happening because DynamicFilterSourceOperator did not return partial result.", "url": "https://github.com/trinodb/trino/pull/4946#discussion_r476459513", "createdAt": "2020-08-25T13:44:37Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFilterConsumer.java", "diffHunk": "@@ -144,6 +144,11 @@ private void addPartition(TupleDomain<DynamicFilterId> tupleDomain)\n             return buildChannels.keySet().stream()\n                     .collect(toImmutableMap(identity(), filterId -> Domain.none(filterBuildTypes.get(filterId))));\n         }\n+        if (result.isAll()) {\n+            // Set `all` domain explicitly for dynamic filters so that it can be waited for\n+            return buildChannels.keySet().stream()\n+                    .collect(toImmutableMap(identity(), filterId -> Domain.all(filterBuildTypes.get(filterId))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxMDEwMQ=="}, "originalCommit": null, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3ODk3OTM1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFilterConsumer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNDozMDo1M1rOHGa8yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNDozMDo1M1rOHGa8yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5NTA1MQ==", "bodyText": "maybe isntead of Sets.difference, use .putIfAbsent?\ni think would be more readable", "url": "https://github.com/trinodb/trino/pull/4946#discussion_r476495051", "createdAt": "2020-08-25T14:30:53Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFilterConsumer.java", "diffHunk": "@@ -144,7 +145,13 @@ private void addPartition(TupleDomain<DynamicFilterId> tupleDomain)\n             return buildChannels.keySet().stream()\n                     .collect(toImmutableMap(identity(), filterId -> Domain.none(filterBuildTypes.get(filterId))));\n         }\n-        return result.getDomains().get();\n+\n+        ImmutableMap.Builder<DynamicFilterId, Domain> domains = ImmutableMap.builder();\n+        domains.putAll(result.getDomains().get());\n+        // Add `all` domain explicitly for dynamic filters to notify dynamic filter listeners\n+        Sets.difference(buildChannels.keySet(), result.getDomains().get().keySet())\n+                .forEach(filterId -> domains.put(filterId, Domain.all(filterBuildTypes.get(filterId))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 18}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3273, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}