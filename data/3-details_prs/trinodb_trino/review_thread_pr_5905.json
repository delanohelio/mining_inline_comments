{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4NjI0NTM4", "number": 5905, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNTo1NTo1N1rOE3kIDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMTozNjozOFrOE4XQ1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Njk5MDIyOnYy", "diffSide": "RIGHT", "path": "presto-spi/src/main/java/io/prestosql/spi/block/LongArrayBlockEncoding.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNTo1NTo1N1rOHw_MNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTo1MDoxNFrOHyBNFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyOTAxNA==", "bodyText": "Can we implement the same for other native array block ?", "url": "https://github.com/trinodb/trino/pull/5905#discussion_r521129014", "createdAt": "2020-11-11T05:55:57Z", "author": {"login": "Praveen2112"}, "path": "presto-spi/src/main/java/io/prestosql/spi/block/LongArrayBlockEncoding.java", "diffHunk": "@@ -53,9 +54,14 @@ public Block readBlock(BlockEncodingSerde blockEncodingSerde, SliceInput sliceIn\n         boolean[] valueIsNull = decodeNullBits(sliceInput, positionCount).orElse(null);\n \n         long[] values = new long[positionCount];\n-        for (int position = 0; position < positionCount; position++) {\n-            if (valueIsNull == null || !valueIsNull[position]) {\n-                values[position] = sliceInput.readLong();\n+        if (valueIsNull == null) {\n+            sliceInput.readBytes(Slices.wrappedLongArray(values), 0, Long.BYTES * positionCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxMDU4Mg==", "bodyText": "This will be part of follow up PRs", "url": "https://github.com/trinodb/trino/pull/5905#discussion_r522210582", "createdAt": "2020-11-12T15:50:14Z", "author": {"login": "sopel39"}, "path": "presto-spi/src/main/java/io/prestosql/spi/block/LongArrayBlockEncoding.java", "diffHunk": "@@ -53,9 +54,14 @@ public Block readBlock(BlockEncodingSerde blockEncodingSerde, SliceInput sliceIn\n         boolean[] valueIsNull = decodeNullBits(sliceInput, positionCount).orElse(null);\n \n         long[] values = new long[positionCount];\n-        for (int position = 0; position < positionCount; position++) {\n-            if (valueIsNull == null || !valueIsNull[position]) {\n-                values[position] = sliceInput.readLong();\n+        if (valueIsNull == null) {\n+            sliceInput.readBytes(Slices.wrappedLongArray(values), 0, Long.BYTES * positionCount);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyOTAxNA=="}, "originalCommit": null, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Njk5MDc4OnYy", "diffSide": "RIGHT", "path": "presto-spi/src/main/java/io/prestosql/spi/block/LongArrayBlockEncoding.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNTo1NjoxNVrOHw_MjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNTo1NjoxNVrOHw_MjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyOTEwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        sliceInput.readBytes(Slices.wrappedLongArray(values), 0, Long.BYTES * positionCount);\n          \n          \n            \n                        sliceInput.readBytes(Slices.wrappedLongArray(values), Long.BYTES * positionCount);", "url": "https://github.com/trinodb/trino/pull/5905#discussion_r521129100", "createdAt": "2020-11-11T05:56:15Z", "author": {"login": "Praveen2112"}, "path": "presto-spi/src/main/java/io/prestosql/spi/block/LongArrayBlockEncoding.java", "diffHunk": "@@ -53,9 +54,14 @@ public Block readBlock(BlockEncodingSerde blockEncodingSerde, SliceInput sliceIn\n         boolean[] valueIsNull = decodeNullBits(sliceInput, positionCount).orElse(null);\n \n         long[] values = new long[positionCount];\n-        for (int position = 0; position < positionCount; position++) {\n-            if (valueIsNull == null || !valueIsNull[position]) {\n-                values[position] = sliceInput.readLong();\n+        if (valueIsNull == null) {\n+            sliceInput.readBytes(Slices.wrappedLongArray(values), 0, Long.BYTES * positionCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzAwNDYwOnYy", "diffSide": "RIGHT", "path": "presto-tpch/src/main/java/io/prestosql/plugin/tpch/TpchTables.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNjowMzoyNFrOHw_U3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNjowMzoyNFrOHw_U3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEzMTIyOA==", "bodyText": "Can we use RecordPageSource ? But we might need to add it to pom I guess", "url": "https://github.com/trinodb/trino/pull/5905#discussion_r521131228", "createdAt": "2020-11-11T06:03:24Z", "author": {"login": "Praveen2112"}, "path": "presto-tpch/src/main/java/io/prestosql/plugin/tpch/TpchTables.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.tpch;\n+\n+import com.google.common.collect.AbstractIterator;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.connector.ConnectorPageSource;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.tpch.TpchTable;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.plugin.tpch.TpchRecordSet.createTpchRecordSet;\n+\n+public final class TpchTables\n+{\n+    private TpchTables()\n+    {\n+    }\n+\n+    public static List<Type> getTableColumns(String tableName)\n+    {\n+        TpchTable<?> table = TpchTable.getTable(tableName);\n+        return table.getColumns().stream()\n+                .map(TpchMetadata::getPrestoType)\n+                .collect(toImmutableList());\n+    }\n+\n+    public static Iterator<Page> getTablePages(\n+            String tableName,\n+            double scaleFactor,\n+            int maxRowsPerPage)\n+    {\n+        TpchTable table = TpchTable.getTable(tableName);\n+        ConnectorPageSource pageSource = new LazyRecordPageSource(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzQ5NTAxOnYy", "diffSide": "RIGHT", "path": "presto-orc/src/test/java/io/prestosql/orc/BenchmarkColumnReaders.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwODo1NDoxNlrOHxD8VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwODo1NDoxNlrOHxD8VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIwNjg2OQ==", "bodyText": "nit: static import", "url": "https://github.com/trinodb/trino/pull/5905#discussion_r521206869", "createdAt": "2020-11-11T08:54:16Z", "author": {"login": "skrzypo987"}, "path": "presto-orc/src/test/java/io/prestosql/orc/BenchmarkColumnReaders.java", "diffHunk": "@@ -1066,6 +1060,20 @@ public void setup()\n         }\n     }\n \n+    @State(Scope.Thread)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 440}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzUwMDA2OnYy", "diffSide": "RIGHT", "path": "presto-orc/src/test/java/io/prestosql/orc/OrcTester.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwODo1NTo0M1rOHxD_hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwODo1NTo0M1rOHxD_hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIwNzY4Ng==", "bodyText": "while(pages.hasNext()){", "url": "https://github.com/trinodb/trino/pull/5905#discussion_r521207686", "createdAt": "2020-11-11T08:55:43Z", "author": {"login": "skrzypo987"}, "path": "presto-orc/src/test/java/io/prestosql/orc/OrcTester.java", "diffHunk": "@@ -602,6 +604,34 @@ static OrcRecordReader createCustomOrcRecordReader(TempFile tempFile, OrcPredica\n                 RuntimeException::new);\n     }\n \n+    public static void writeOrcPages(File outputFile, CompressionKind compression, List<Type> types, Iterator<Page> pages, OrcWriterStats stats)\n+            throws Exception\n+    {\n+        List<String> columnNames = IntStream.range(0, types.size())\n+                .mapToObj(i -> \"test\" + i)\n+                .collect(toImmutableList());\n+\n+        OrcWriter writer = new OrcWriter(\n+                new OutputStreamOrcDataSink(new FileOutputStream(outputFile)),\n+                columnNames,\n+                types,\n+                OrcType.createRootOrcType(columnNames, types),\n+                compression,\n+                new OrcWriterOptions(),\n+                false,\n+                ImmutableMap.of(),\n+                true,\n+                BOTH,\n+                stats);\n+\n+        for (; pages.hasNext(); ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzU0OTY0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/execution/buffer/BenchmarkBlockSerde.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwOTowOTo0NlrOHxEedg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNjowMDowNVrOHyBrhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIxNTYwNg==", "bodyText": "What is the difference between this one and BigintWithNullBenchmarkDataNonOptimized?\nThey look the same", "url": "https://github.com/trinodb/trino/pull/5905#discussion_r521215606", "createdAt": "2020-11-11T09:09:46Z", "author": {"login": "skrzypo987"}, "path": "presto-main/src/test/java/io/prestosql/execution/buffer/BenchmarkBlockSerde.java", "diffHunk": "@@ -0,0 +1,448 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution.buffer;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.BasicSliceInput;\n+import io.airlift.slice.DynamicSliceOutput;\n+import io.airlift.slice.OutputStreamSliceOutput;\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PageBuilder;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.TestingBlockEncodingSerde;\n+import io.prestosql.spi.type.DecimalType;\n+import io.prestosql.spi.type.Decimals;\n+import io.prestosql.spi.type.SqlDecimal;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.VarcharType;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+import org.testng.annotations.Test;\n+\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+import static io.airlift.slice.Slices.utf8Slice;\n+import static io.prestosql.execution.buffer.PagesSerdeUtil.readPages;\n+import static io.prestosql.execution.buffer.PagesSerdeUtil.writePages;\n+import static io.prestosql.plugin.tpch.TpchTables.getTablePages;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.DecimalType.createDecimalType;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.spi.type.Varchars.truncateToLength;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(3)\n+@Warmup(iterations = 30, time = 500, timeUnit = MILLISECONDS)\n+@Measurement(iterations = 20, time = 500, timeUnit = MILLISECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@OperationsPerInvocation(BenchmarkBlockSerde.ROWS)\n+public class BenchmarkBlockSerde\n+{\n+    private static final DecimalType LONG_DECIMAL_TYPE = createDecimalType(30, 5);\n+\n+    public static final int ROWS = 10_000_000;\n+    private static final int MAX_STRING = 19;\n+\n+    @Benchmark\n+    public Object deserializeLongDecimalNoNull(LongDecimalNoNullBenchmarkData data)\n+    {\n+        return ImmutableList.copyOf(readPages(data.getPagesSerde(), new BasicSliceInput(data.getDataSource())));\n+    }\n+\n+    @Benchmark\n+    public Object deserializeLongDecimalWithNull(LongDecimalWithNullBenchmarkData data)\n+    {\n+        return ImmutableList.copyOf(readPages(data.getPagesSerde(), new BasicSliceInput(data.getDataSource())));\n+    }\n+\n+    @Benchmark\n+    public Object deserializeLongNonRandomNoNull(BigintNonRandomNoNullNullBenchmarkData data)\n+    {\n+        return ImmutableList.copyOf(readPages(data.getPagesSerde(), new BasicSliceInput(data.getDataSource())));\n+    }\n+\n+    @Benchmark\n+    public Object deserializeLongNoNull(BigintNoNullBenchmarkData data)\n+    {\n+        return ImmutableList.copyOf(readPages(data.getPagesSerde(), new BasicSliceInput(data.getDataSource())));\n+    }\n+\n+    @Benchmark\n+    public Object deserializeLongWithNull(BigintWithNullBenchmarkData data)\n+    {\n+        return ImmutableList.copyOf(readPages(data.getPagesSerde(), new BasicSliceInput(data.getDataSource())));\n+    }\n+\n+    @Benchmark\n+    public Object deserializeSliceDirectNoNull(VarcharDirectNoNullBenchmarkData data)\n+    {\n+        return ImmutableList.copyOf(readPages(data.getPagesSerde(), new BasicSliceInput(data.getDataSource())));\n+    }\n+\n+    @Benchmark\n+    public Object deserializeSliceDirectWithNull(VarcharDirectWithNullBenchmarkData data)\n+    {\n+        return ImmutableList.copyOf(readPages(data.getPagesSerde(), new BasicSliceInput(data.getDataSource())));\n+    }\n+\n+    @Benchmark\n+    public Object deserializeLineitem(LineitemBenchmarkData data)\n+    {\n+        return ImmutableList.copyOf(readPages(data.getPagesSerde(), new BasicSliceInput(data.getDataSource())));\n+    }\n+\n+    public abstract static class BenchmarkData\n+    {\n+        protected final Random random = new Random(0);\n+        private Slice dataSource;\n+        private PagesSerde pagesSerde;\n+\n+        public void setup(Iterator<Page> pages)\n+                throws Exception\n+        {\n+            pagesSerde = new TestingPagesSerdeFactory(new TestingBlockEncodingSerde(), false).createPagesSerde();\n+\n+            DynamicSliceOutput sliceOutput = new DynamicSliceOutput(0);\n+            writePages(pagesSerde, new OutputStreamSliceOutput(sliceOutput), pages);\n+            dataSource = sliceOutput.slice();\n+        }\n+\n+        public void setup(Type type, Iterator<?> values)\n+                throws Exception\n+        {\n+            pagesSerde = new TestingPagesSerdeFactory(new TestingBlockEncodingSerde(), false).createPagesSerde();\n+            PageBuilder pageBuilder = new PageBuilder(ImmutableList.of(type));\n+            BlockBuilder blockBuilder = pageBuilder.getBlockBuilder(0);\n+            ImmutableList.Builder<Page> pages = ImmutableList.builder();\n+            while (values.hasNext()) {\n+                Object value = values.next();\n+                if (value == null) {\n+                    blockBuilder.appendNull();\n+                }\n+                else if (BIGINT.equals(type)) {\n+                    BIGINT.writeLong(blockBuilder, ((Number) value).longValue());\n+                }\n+                else if (Decimals.isLongDecimal(type)) {\n+                    type.writeSlice(blockBuilder, Decimals.encodeUnscaledValue(((SqlDecimal) value).toBigDecimal().unscaledValue()));\n+                }\n+                else if (type instanceof VarcharType) {\n+                    Slice slice = truncateToLength(utf8Slice((String) value), type);\n+                    type.writeSlice(blockBuilder, slice);\n+                }\n+                else {\n+                    throw new IllegalArgumentException(\"Unsupported type \" + type);\n+                }\n+                pageBuilder.declarePosition();\n+                if (pageBuilder.isFull()) {\n+                    pages.add(pageBuilder.build());\n+                    pageBuilder.reset();\n+                    blockBuilder = pageBuilder.getBlockBuilder(0);\n+                }\n+            }\n+            if (pageBuilder.getPositionCount() > 0) {\n+                pages.add(pageBuilder.build());\n+            }\n+\n+            DynamicSliceOutput sliceOutput = new DynamicSliceOutput(0);\n+            writePages(pagesSerde, new OutputStreamSliceOutput(sliceOutput), pages.build().iterator());\n+            dataSource = sliceOutput.slice();\n+        }\n+\n+        public PagesSerde getPagesSerde()\n+        {\n+            return pagesSerde;\n+        }\n+\n+        public Slice getDataSource()\n+        {\n+            return dataSource;\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class LongDecimalNoNullBenchmarkData\n+            extends BenchmarkData\n+    {\n+        @Setup\n+        public void setup()\n+                throws Exception\n+        {\n+            setup(LONG_DECIMAL_TYPE, createValues());\n+        }\n+\n+        private Iterator<?> createValues()\n+        {\n+            List<SqlDecimal> values = new ArrayList<>();\n+            for (int i = 0; i < ROWS; ++i) {\n+                values.add(new SqlDecimal(new BigInteger(96, random), 30, 5));\n+            }\n+            return values.iterator();\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class LongDecimalWithNullBenchmarkData\n+            extends BenchmarkData\n+    {\n+        @Setup\n+        public void setup()\n+                throws Exception\n+        {\n+            setup(LONG_DECIMAL_TYPE, createValues());\n+        }\n+\n+        private Iterator<?> createValues()\n+        {\n+            List<SqlDecimal> values = new ArrayList<>();\n+            for (int i = 0; i < ROWS; ++i) {\n+                if (random.nextBoolean()) {\n+                    values.add(new SqlDecimal(new BigInteger(96, random), 30, 5));\n+                }\n+                else {\n+                    values.add(null);\n+                }\n+            }\n+            return values.iterator();\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class BigintNonRandomNoNullNullBenchmarkData\n+            extends BenchmarkData\n+    {\n+        @Setup\n+        public void setup()\n+                throws Exception\n+        {\n+            setup(BIGINT, createValues());\n+        }\n+\n+        private Iterator<?> createValues()\n+        {\n+            List<Long> values = new ArrayList<>();\n+            for (int i = 0; i < ROWS; ++i) {\n+                values.add((long) i);\n+            }\n+            return values.iterator();\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class BigintNoNullBenchmarkData\n+            extends BenchmarkData\n+    {\n+        @Setup\n+        public void setup()\n+                throws Exception\n+        {\n+            setup(BIGINT, createValues());\n+        }\n+\n+        private Iterator<?> createValues()\n+        {\n+            List<Long> values = new ArrayList<>();\n+            for (int i = 0; i < ROWS; ++i) {\n+                values.add(random.nextLong());\n+            }\n+            return values.iterator();\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class BigintWithNullBenchmarkData\n+            extends BenchmarkData\n+    {\n+        @Setup\n+        public void setup()\n+                throws Exception\n+        {\n+            setup(BIGINT, createValues());\n+        }\n+\n+        private Iterator<?> createValues()\n+        {\n+            List<Long> values = new ArrayList<>();\n+            for (int i = 0; i < ROWS; ++i) {\n+                if (random.nextBoolean()) {\n+                    values.add(random.nextLong());\n+                }\n+                else {\n+                    values.add(null);\n+                }\n+            }\n+            return values.iterator();\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class BigintWithNullBenchmarkDataNonOptimized\n+            extends BenchmarkData\n+    {\n+        @Setup\n+        public void setup()\n+                throws Exception\n+        {\n+            setup(BIGINT, createValues());\n+        }\n+\n+        private Iterator<?> createValues()\n+        {\n+            List<Long> values = new ArrayList<>();\n+            for (int i = 0; i < ROWS; ++i) {\n+                if (random.nextBoolean()) {\n+                    values.add(random.nextLong());\n+                }\n+                else {\n+                    values.add(null);\n+                }\n+            }\n+            return values.iterator();\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class BigintWithNullBenchmarkDataFixedWidthBlock", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxODM3NQ==", "bodyText": "That is leftover from previous experiments", "url": "https://github.com/trinodb/trino/pull/5905#discussion_r522218375", "createdAt": "2020-11-12T16:00:05Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/execution/buffer/BenchmarkBlockSerde.java", "diffHunk": "@@ -0,0 +1,448 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.execution.buffer;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.BasicSliceInput;\n+import io.airlift.slice.DynamicSliceOutput;\n+import io.airlift.slice.OutputStreamSliceOutput;\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PageBuilder;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.TestingBlockEncodingSerde;\n+import io.prestosql.spi.type.DecimalType;\n+import io.prestosql.spi.type.Decimals;\n+import io.prestosql.spi.type.SqlDecimal;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.VarcharType;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+import org.testng.annotations.Test;\n+\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+import static io.airlift.slice.Slices.utf8Slice;\n+import static io.prestosql.execution.buffer.PagesSerdeUtil.readPages;\n+import static io.prestosql.execution.buffer.PagesSerdeUtil.writePages;\n+import static io.prestosql.plugin.tpch.TpchTables.getTablePages;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.DecimalType.createDecimalType;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.spi.type.Varchars.truncateToLength;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(3)\n+@Warmup(iterations = 30, time = 500, timeUnit = MILLISECONDS)\n+@Measurement(iterations = 20, time = 500, timeUnit = MILLISECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@OperationsPerInvocation(BenchmarkBlockSerde.ROWS)\n+public class BenchmarkBlockSerde\n+{\n+    private static final DecimalType LONG_DECIMAL_TYPE = createDecimalType(30, 5);\n+\n+    public static final int ROWS = 10_000_000;\n+    private static final int MAX_STRING = 19;\n+\n+    @Benchmark\n+    public Object deserializeLongDecimalNoNull(LongDecimalNoNullBenchmarkData data)\n+    {\n+        return ImmutableList.copyOf(readPages(data.getPagesSerde(), new BasicSliceInput(data.getDataSource())));\n+    }\n+\n+    @Benchmark\n+    public Object deserializeLongDecimalWithNull(LongDecimalWithNullBenchmarkData data)\n+    {\n+        return ImmutableList.copyOf(readPages(data.getPagesSerde(), new BasicSliceInput(data.getDataSource())));\n+    }\n+\n+    @Benchmark\n+    public Object deserializeLongNonRandomNoNull(BigintNonRandomNoNullNullBenchmarkData data)\n+    {\n+        return ImmutableList.copyOf(readPages(data.getPagesSerde(), new BasicSliceInput(data.getDataSource())));\n+    }\n+\n+    @Benchmark\n+    public Object deserializeLongNoNull(BigintNoNullBenchmarkData data)\n+    {\n+        return ImmutableList.copyOf(readPages(data.getPagesSerde(), new BasicSliceInput(data.getDataSource())));\n+    }\n+\n+    @Benchmark\n+    public Object deserializeLongWithNull(BigintWithNullBenchmarkData data)\n+    {\n+        return ImmutableList.copyOf(readPages(data.getPagesSerde(), new BasicSliceInput(data.getDataSource())));\n+    }\n+\n+    @Benchmark\n+    public Object deserializeSliceDirectNoNull(VarcharDirectNoNullBenchmarkData data)\n+    {\n+        return ImmutableList.copyOf(readPages(data.getPagesSerde(), new BasicSliceInput(data.getDataSource())));\n+    }\n+\n+    @Benchmark\n+    public Object deserializeSliceDirectWithNull(VarcharDirectWithNullBenchmarkData data)\n+    {\n+        return ImmutableList.copyOf(readPages(data.getPagesSerde(), new BasicSliceInput(data.getDataSource())));\n+    }\n+\n+    @Benchmark\n+    public Object deserializeLineitem(LineitemBenchmarkData data)\n+    {\n+        return ImmutableList.copyOf(readPages(data.getPagesSerde(), new BasicSliceInput(data.getDataSource())));\n+    }\n+\n+    public abstract static class BenchmarkData\n+    {\n+        protected final Random random = new Random(0);\n+        private Slice dataSource;\n+        private PagesSerde pagesSerde;\n+\n+        public void setup(Iterator<Page> pages)\n+                throws Exception\n+        {\n+            pagesSerde = new TestingPagesSerdeFactory(new TestingBlockEncodingSerde(), false).createPagesSerde();\n+\n+            DynamicSliceOutput sliceOutput = new DynamicSliceOutput(0);\n+            writePages(pagesSerde, new OutputStreamSliceOutput(sliceOutput), pages);\n+            dataSource = sliceOutput.slice();\n+        }\n+\n+        public void setup(Type type, Iterator<?> values)\n+                throws Exception\n+        {\n+            pagesSerde = new TestingPagesSerdeFactory(new TestingBlockEncodingSerde(), false).createPagesSerde();\n+            PageBuilder pageBuilder = new PageBuilder(ImmutableList.of(type));\n+            BlockBuilder blockBuilder = pageBuilder.getBlockBuilder(0);\n+            ImmutableList.Builder<Page> pages = ImmutableList.builder();\n+            while (values.hasNext()) {\n+                Object value = values.next();\n+                if (value == null) {\n+                    blockBuilder.appendNull();\n+                }\n+                else if (BIGINT.equals(type)) {\n+                    BIGINT.writeLong(blockBuilder, ((Number) value).longValue());\n+                }\n+                else if (Decimals.isLongDecimal(type)) {\n+                    type.writeSlice(blockBuilder, Decimals.encodeUnscaledValue(((SqlDecimal) value).toBigDecimal().unscaledValue()));\n+                }\n+                else if (type instanceof VarcharType) {\n+                    Slice slice = truncateToLength(utf8Slice((String) value), type);\n+                    type.writeSlice(blockBuilder, slice);\n+                }\n+                else {\n+                    throw new IllegalArgumentException(\"Unsupported type \" + type);\n+                }\n+                pageBuilder.declarePosition();\n+                if (pageBuilder.isFull()) {\n+                    pages.add(pageBuilder.build());\n+                    pageBuilder.reset();\n+                    blockBuilder = pageBuilder.getBlockBuilder(0);\n+                }\n+            }\n+            if (pageBuilder.getPositionCount() > 0) {\n+                pages.add(pageBuilder.build());\n+            }\n+\n+            DynamicSliceOutput sliceOutput = new DynamicSliceOutput(0);\n+            writePages(pagesSerde, new OutputStreamSliceOutput(sliceOutput), pages.build().iterator());\n+            dataSource = sliceOutput.slice();\n+        }\n+\n+        public PagesSerde getPagesSerde()\n+        {\n+            return pagesSerde;\n+        }\n+\n+        public Slice getDataSource()\n+        {\n+            return dataSource;\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class LongDecimalNoNullBenchmarkData\n+            extends BenchmarkData\n+    {\n+        @Setup\n+        public void setup()\n+                throws Exception\n+        {\n+            setup(LONG_DECIMAL_TYPE, createValues());\n+        }\n+\n+        private Iterator<?> createValues()\n+        {\n+            List<SqlDecimal> values = new ArrayList<>();\n+            for (int i = 0; i < ROWS; ++i) {\n+                values.add(new SqlDecimal(new BigInteger(96, random), 30, 5));\n+            }\n+            return values.iterator();\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class LongDecimalWithNullBenchmarkData\n+            extends BenchmarkData\n+    {\n+        @Setup\n+        public void setup()\n+                throws Exception\n+        {\n+            setup(LONG_DECIMAL_TYPE, createValues());\n+        }\n+\n+        private Iterator<?> createValues()\n+        {\n+            List<SqlDecimal> values = new ArrayList<>();\n+            for (int i = 0; i < ROWS; ++i) {\n+                if (random.nextBoolean()) {\n+                    values.add(new SqlDecimal(new BigInteger(96, random), 30, 5));\n+                }\n+                else {\n+                    values.add(null);\n+                }\n+            }\n+            return values.iterator();\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class BigintNonRandomNoNullNullBenchmarkData\n+            extends BenchmarkData\n+    {\n+        @Setup\n+        public void setup()\n+                throws Exception\n+        {\n+            setup(BIGINT, createValues());\n+        }\n+\n+        private Iterator<?> createValues()\n+        {\n+            List<Long> values = new ArrayList<>();\n+            for (int i = 0; i < ROWS; ++i) {\n+                values.add((long) i);\n+            }\n+            return values.iterator();\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class BigintNoNullBenchmarkData\n+            extends BenchmarkData\n+    {\n+        @Setup\n+        public void setup()\n+                throws Exception\n+        {\n+            setup(BIGINT, createValues());\n+        }\n+\n+        private Iterator<?> createValues()\n+        {\n+            List<Long> values = new ArrayList<>();\n+            for (int i = 0; i < ROWS; ++i) {\n+                values.add(random.nextLong());\n+            }\n+            return values.iterator();\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class BigintWithNullBenchmarkData\n+            extends BenchmarkData\n+    {\n+        @Setup\n+        public void setup()\n+                throws Exception\n+        {\n+            setup(BIGINT, createValues());\n+        }\n+\n+        private Iterator<?> createValues()\n+        {\n+            List<Long> values = new ArrayList<>();\n+            for (int i = 0; i < ROWS; ++i) {\n+                if (random.nextBoolean()) {\n+                    values.add(random.nextLong());\n+                }\n+                else {\n+                    values.add(null);\n+                }\n+            }\n+            return values.iterator();\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class BigintWithNullBenchmarkDataNonOptimized\n+            extends BenchmarkData\n+    {\n+        @Setup\n+        public void setup()\n+                throws Exception\n+        {\n+            setup(BIGINT, createValues());\n+        }\n+\n+        private Iterator<?> createValues()\n+        {\n+            List<Long> values = new ArrayList<>();\n+            for (int i = 0; i < ROWS; ++i) {\n+                if (random.nextBoolean()) {\n+                    values.add(random.nextLong());\n+                }\n+                else {\n+                    values.add(null);\n+                }\n+            }\n+            return values.iterator();\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class BigintWithNullBenchmarkDataFixedWidthBlock", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIxNTYwNg=="}, "originalCommit": null, "originalPosition": 336}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2ODg2NTA2OnYy", "diffSide": "RIGHT", "path": "presto-spi/src/main/java/io/prestosql/spi/block/LongArrayBlockEncoding.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNTowNTowOVrOHxRBsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNTowNzowNVrOHxRGyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQyMTIzNA==", "bodyText": "You might need to handle the case when (positionCount * Long.BYTES) > Integer.MAX_VALUE", "url": "https://github.com/trinodb/trino/pull/5905#discussion_r521421234", "createdAt": "2020-11-11T15:05:09Z", "author": {"login": "pettyjamesm"}, "path": "presto-spi/src/main/java/io/prestosql/spi/block/LongArrayBlockEncoding.java", "diffHunk": "@@ -53,9 +54,14 @@ public Block readBlock(BlockEncodingSerde blockEncodingSerde, SliceInput sliceIn\n         boolean[] valueIsNull = decodeNullBits(sliceInput, positionCount).orElse(null);\n \n         long[] values = new long[positionCount];\n-        for (int position = 0; position < positionCount; position++) {\n-            if (valueIsNull == null || !valueIsNull[position]) {\n-                values[position] = sliceInput.readLong();\n+        if (valueIsNull == null) {\n+            sliceInput.readBytes(Slices.wrappedLongArray(values), 0, Long.BYTES * positionCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQyMjUzNw==", "bodyText": "As an aside, maybe we should consider implementingSliceInput#readLongs(long[], int, int) and similar methods for other primitive types?", "url": "https://github.com/trinodb/trino/pull/5905#discussion_r521422537", "createdAt": "2020-11-11T15:07:05Z", "author": {"login": "pettyjamesm"}, "path": "presto-spi/src/main/java/io/prestosql/spi/block/LongArrayBlockEncoding.java", "diffHunk": "@@ -53,9 +54,14 @@ public Block readBlock(BlockEncodingSerde blockEncodingSerde, SliceInput sliceIn\n         boolean[] valueIsNull = decodeNullBits(sliceInput, positionCount).orElse(null);\n \n         long[] values = new long[positionCount];\n-        for (int position = 0; position < positionCount; position++) {\n-            if (valueIsNull == null || !valueIsNull[position]) {\n-                values[position] = sliceInput.readLong();\n+        if (valueIsNull == null) {\n+            sliceInput.readBytes(Slices.wrappedLongArray(values), 0, Long.BYTES * positionCount);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQyMTIzNA=="}, "originalCommit": null, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTM2ODU0OnYy", "diffSide": "RIGHT", "path": "presto-spi/src/main/java/io/prestosql/spi/block/LongArrayBlockEncoding.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMTozNjozOFrOHyPSSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzo0Nzo1MVrOHyh2iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ0MTI5MQ==", "bodyText": "This extra allocation is going to be a bit of a bummer if you only have a few nulls since it effectively doubles the allocations involved with decoding.", "url": "https://github.com/trinodb/trino/pull/5905#discussion_r522441291", "createdAt": "2020-11-12T21:36:38Z", "author": {"login": "pettyjamesm"}, "path": "presto-spi/src/main/java/io/prestosql/spi/block/LongArrayBlockEncoding.java", "diffHunk": "@@ -53,9 +65,20 @@ public Block readBlock(BlockEncodingSerde blockEncodingSerde, SliceInput sliceIn\n         boolean[] valueIsNull = decodeNullBits(sliceInput, positionCount).orElse(null);\n \n         long[] values = new long[positionCount];\n-        for (int position = 0; position < positionCount; position++) {\n-            if (valueIsNull == null || !valueIsNull[position]) {\n-                values[position] = sliceInput.readLong();\n+        if (valueIsNull == null) {\n+            sliceInput.readBytes(Slices.wrappedLongArray(values));\n+        }\n+        else {\n+            int nonNullPositionCount = sliceInput.readInt();\n+            long[] valuesWithoutNull = new long[nonNullPositionCount + 1];", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ2ODU4OA==", "bodyText": "this is where we could use buffer cache potentially. Still, even now there is > 2x improvement here (and more then that for serialization)", "url": "https://github.com/trinodb/trino/pull/5905#discussion_r522468588", "createdAt": "2020-11-12T22:22:12Z", "author": {"login": "sopel39"}, "path": "presto-spi/src/main/java/io/prestosql/spi/block/LongArrayBlockEncoding.java", "diffHunk": "@@ -53,9 +65,20 @@ public Block readBlock(BlockEncodingSerde blockEncodingSerde, SliceInput sliceIn\n         boolean[] valueIsNull = decodeNullBits(sliceInput, positionCount).orElse(null);\n \n         long[] values = new long[positionCount];\n-        for (int position = 0; position < positionCount; position++) {\n-            if (valueIsNull == null || !valueIsNull[position]) {\n-                values[position] = sliceInput.readLong();\n+        if (valueIsNull == null) {\n+            sliceInput.readBytes(Slices.wrappedLongArray(values));\n+        }\n+        else {\n+            int nonNullPositionCount = sliceInput.readInt();\n+            long[] valuesWithoutNull = new long[nonNullPositionCount + 1];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ0MTI5MQ=="}, "originalCommit": null, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc0NTQ4MQ==", "bodyText": "Changed to\n            long[] valuesWithoutNull = new long[positionCount];\n            int nonNullPositionCount = 0;\n            for (int i = 0; i < positionCount; i++) {\n                valuesWithoutNull[nonNullPositionCount] = block.getLong(i, 0);\n                if (!block.isNull(i)) {\n                    nonNullPositionCount++;\n                }\n            }\n\nsince it yields slightly better results without extra allocation", "url": "https://github.com/trinodb/trino/pull/5905#discussion_r522745481", "createdAt": "2020-11-13T07:47:51Z", "author": {"login": "sopel39"}, "path": "presto-spi/src/main/java/io/prestosql/spi/block/LongArrayBlockEncoding.java", "diffHunk": "@@ -53,9 +65,20 @@ public Block readBlock(BlockEncodingSerde blockEncodingSerde, SliceInput sliceIn\n         boolean[] valueIsNull = decodeNullBits(sliceInput, positionCount).orElse(null);\n \n         long[] values = new long[positionCount];\n-        for (int position = 0; position < positionCount; position++) {\n-            if (valueIsNull == null || !valueIsNull[position]) {\n-                values[position] = sliceInput.readLong();\n+        if (valueIsNull == null) {\n+            sliceInput.readBytes(Slices.wrappedLongArray(values));\n+        }\n+        else {\n+            int nonNullPositionCount = sliceInput.readInt();\n+            long[] valuesWithoutNull = new long[nonNullPositionCount + 1];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ0MTI5MQ=="}, "originalCommit": null, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4733, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}