{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0NzE1MDcw", "number": 5794, "title": "Reuse immutable partition fields in Glue partition conversion", "bodyText": "When loading a large number of partitions from Glue (and especially when storing the loaded values into a cache), partition instances often share equivalent immutable field values (eg: columns) which can consume a large amount of coordinator heap space.\nThis change enables opportunistic reuse of partition fields by memoizing various partition related fields during transformation and opportunistically reusing equivalent immutable field values for consecutive converted partitions.", "createdAt": "2020-11-03T12:56:24Z", "url": "https://github.com/trinodb/trino/pull/5794", "merged": true, "mergeCommit": {"oid": "144ae4a3a2d3c473d50a6515eafab9d07498c5fa"}, "closed": true, "closedAt": "2020-11-12T19:01:52Z", "author": {"login": "pettyjamesm"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdY5axfgBqjM5NTI5MzY3Njk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdb3VxagFqTUyOTM5OTY3MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NTY1NzIx", "url": "https://github.com/trinodb/trino/pull/5794#pullrequestreview-525565721", "createdAt": "2020-11-07T00:14:29Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wN1QwMDoxNDoyOVrOHvBMTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wN1QwMDozOTo0OVrOHvBfTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2NDY1NQ==", "bodyText": "Nit: No need to wrap here", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r519064655", "createdAt": "2020-11-07T00:14:29Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/GlueHiveMetastore.java", "diffHunk": "@@ -728,7 +728,8 @@ public void dropColumn(HiveIdentity identity, String databaseName, String tableN\n                             .withDatabaseName(table.getDatabaseName())\n                             .withTableName(table.getTableName())\n                             .withPartitionValues(partitionValues)));\n-            return Optional.of(GlueToPrestoConverter.convertPartition(result.getPartition(), table.getParameters()));\n+            return Optional.of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2NTUzNA==", "bodyText": "We could keep this as toImmutableList(). Moving away from streams simply to pre-size the output list, in code that's already doing expensive RPC calls, is a hard sell from a code readability standpoint.", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r519065534", "createdAt": "2020-11-07T00:18:56Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/GlueHiveMetastore.java", "diffHunk": "@@ -822,9 +827,11 @@ public void dropColumn(HiveIdentity identity, String databaseName, String tableN\n \n     private static List<String> buildPartitionNames(List<Column> partitionColumns, List<Partition> partitions)\n     {\n-        return partitions.stream()\n-                .map(partition -> makePartitionName(partitionColumns, partition.getValues()))\n-                .collect(toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2Njg5Mg==", "bodyText": "Import GluePartitionConverter so that it doesn't need to be qualified", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r519066892", "createdAt": "2020-11-07T00:25:46Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/GlueHiveMetastore.java", "diffHunk": "@@ -797,6 +798,9 @@ public void dropColumn(HiveIdentity identity, String databaseName, String tableN\n                 List<Partition> partitions = new ArrayList<>();\n                 String nextToken = null;\n \n+                // Reuse immutable field instances opportunistically between partitions\n+                GlueToPrestoConverter.GluePartitionConverter converter = new GlueToPrestoConverter.GluePartitionConverter(table);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2ODMwNQ==", "bodyText": "You could use a stream here", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r519068305", "createdAt": "2020-11-07T00:33:12Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/converter/GlueToPrestoConverter.java", "diffHunk": "@@ -75,81 +76,166 @@ public static Table convertTable(com.amazonaws.services.glue.model.Table glueTab\n                 .setOwner(nullToEmpty(glueTable.getOwner()))\n                 // Athena treats missing table type as EXTERNAL_TABLE.\n                 .setTableType(firstNonNull(glueTable.getTableType(), EXTERNAL_TABLE.name()))\n-                .setDataColumns(sd.getColumns().stream()\n-                        .map(GlueToPrestoConverter::convertColumn)\n-                        .collect(toImmutableList()))\n+                .setDataColumns(convertColumns(sd.getColumns()))\n                 .setParameters(tableParameters)\n                 .setViewOriginalText(Optional.ofNullable(glueTable.getViewOriginalText()))\n                 .setViewExpandedText(Optional.ofNullable(glueTable.getViewExpandedText()));\n \n         if (glueTable.getPartitionKeys() != null) {\n-            tableBuilder.setPartitionColumns(glueTable.getPartitionKeys().stream()\n-                    .map(GlueToPrestoConverter::convertColumn)\n-                    .collect(toImmutableList()));\n+            tableBuilder.setPartitionColumns(convertColumns(glueTable.getPartitionKeys()));\n         }\n         else {\n-            tableBuilder.setPartitionColumns(new ArrayList<>());\n+            tableBuilder.setPartitionColumns(ImmutableList.of());\n         }\n-\n-        setStorageBuilder(sd, tableBuilder.getStorageBuilder(), tableParameters);\n+        // No benefit to memoizing here, just reusing the implementation\n+        new StorageConverter().setStorageBuilder(sd, tableBuilder.getStorageBuilder(), tableParameters);\n         return tableBuilder.build();\n     }\n \n-    private static void setStorageBuilder(StorageDescriptor sd, Storage.Builder storageBuilder, Map<String, String> tableParameters)\n+    private static Column convertColumn(com.amazonaws.services.glue.model.Column glueColumn)\n     {\n-        requireNonNull(sd.getSerdeInfo(), \"StorageDescriptor SerDeInfo is null\");\n-        SerDeInfo serdeInfo = sd.getSerdeInfo();\n+        return new Column(glueColumn.getName(), HiveType.valueOf(glueColumn.getType().toLowerCase(Locale.ENGLISH)), Optional.ofNullable(glueColumn.getComment()));\n+    }\n \n-        Optional<HiveBucketProperty> bucketProperty = Optional.empty();\n-        if (sd.getNumberOfBuckets() > 0) {\n-            if (isNullOrEmpty(sd.getBucketColumns())) {\n-                throw new PrestoException(HIVE_INVALID_METADATA, \"Table/partition metadata has 'numBuckets' set, but 'bucketCols' is not set\");\n-            }\n-            List<SortingColumn> sortedBy = ImmutableList.of();\n-            if (!isNullOrEmpty(sd.getSortColumns())) {\n-                sortedBy = sd.getSortColumns().stream()\n-                        .map(column -> new SortingColumn(\n-                                column.getColumn(),\n-                                Order.fromMetastoreApiOrder(column.getSortOrder(), \"unknown\")))\n-                        .collect(toImmutableList());\n-            }\n-            BucketingVersion bucketingVersion = HiveBucketing.getBucketingVersion(tableParameters);\n-            bucketProperty = Optional.of(new HiveBucketProperty(sd.getBucketColumns(), bucketingVersion, sd.getNumberOfBuckets(), sortedBy));\n+    private static List<Column> convertColumns(List<com.amazonaws.services.glue.model.Column> glueColumns)\n+    {\n+        ImmutableList.Builder<Column> builder = ImmutableList.builderWithExpectedSize(glueColumns.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2ODgzMw==", "bodyText": "Nit: format empty methods like\nprivate Memoizers() {}", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r519068833", "createdAt": "2020-11-07T00:36:09Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/util/Memoizers.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore.util;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public final class Memoizers\n+{\n+    private Memoizers()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2OTUxNw==", "bodyText": "I think it would be cleaner to make these methods that return standard functional types\npublic static Function<T, T> memoizeLast() ...\n\npublic static Function<I, O> memoizeLast(Function<I, O> transform) ...\nRather than exposing the implementation classes in the usages", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r519069517", "createdAt": "2020-11-07T00:39:49Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/util/Memoizers.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore.util;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public final class Memoizers\n+{\n+    private Memoizers()\n+    {\n+    }\n+\n+    public static final class Simple<T>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzkwNDE1", "url": "https://github.com/trinodb/trino/pull/5794#pullrequestreview-526790415", "createdAt": "2020-11-10T01:43:21Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwMTo0MzoyMVrOHwId1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwMTo0NDozOVrOHwIfeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIzMjQwNw==", "bodyText": "Make this private and put it at the end of the class (we put private methods at the end)", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r520232407", "createdAt": "2020-11-10T01:43:21Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/converter/GlueToPrestoConverter.java", "diffHunk": "@@ -51,6 +53,16 @@\n \n     private GlueToPrestoConverter() {}\n \n+    public static <T, R> List<R> mappedCopy(List<T> list, Function<T, R> mapper)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIzMjQ5Mw==", "bodyText": "I'd check this above, with the other check, since this line is already long", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r520232493", "createdAt": "2020-11-10T01:43:36Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/converter/GlueToPrestoConverter.java", "diffHunk": "@@ -51,6 +53,16 @@\n \n     private GlueToPrestoConverter() {}\n \n+    public static <T, R> List<R> mappedCopy(List<T> list, Function<T, R> mapper)\n+    {\n+        requireNonNull(mapper, \"mapper is null\");\n+        ImmutableList.Builder<R> builder = ImmutableList.builderWithExpectedSize(requireNonNull(list, \"list is null\").size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIzMjYyMg==", "bodyText": "Nit: no need to wrap here", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r520232622", "createdAt": "2020-11-10T01:44:02Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/converter/GlueToPrestoConverter.java", "diffHunk": "@@ -75,81 +87,162 @@ public static Table convertTable(com.amazonaws.services.glue.model.Table glueTab\n                 .setOwner(nullToEmpty(glueTable.getOwner()))\n                 // Athena treats missing table type as EXTERNAL_TABLE.\n                 .setTableType(firstNonNull(glueTable.getTableType(), EXTERNAL_TABLE.name()))\n-                .setDataColumns(sd.getColumns().stream()\n-                        .map(GlueToPrestoConverter::convertColumn)\n-                        .collect(toImmutableList()))\n+                .setDataColumns(convertColumns(sd.getColumns()))\n                 .setParameters(tableParameters)\n                 .setViewOriginalText(Optional.ofNullable(glueTable.getViewOriginalText()))\n                 .setViewExpandedText(Optional.ofNullable(glueTable.getViewExpandedText()));\n \n         if (glueTable.getPartitionKeys() != null) {\n-            tableBuilder.setPartitionColumns(glueTable.getPartitionKeys().stream()\n-                    .map(GlueToPrestoConverter::convertColumn)\n-                    .collect(toImmutableList()));\n+            tableBuilder.setPartitionColumns(convertColumns(glueTable.getPartitionKeys()));\n         }\n         else {\n-            tableBuilder.setPartitionColumns(new ArrayList<>());\n+            tableBuilder.setPartitionColumns(ImmutableList.of());\n         }\n-\n-        setStorageBuilder(sd, tableBuilder.getStorageBuilder(), tableParameters);\n+        // No benefit to memoizing here, just reusing the implementation\n+        new StorageConverter().setStorageBuilder(sd, tableBuilder.getStorageBuilder(), tableParameters);\n         return tableBuilder.build();\n     }\n \n-    private static void setStorageBuilder(StorageDescriptor sd, Storage.Builder storageBuilder, Map<String, String> tableParameters)\n+    private static Column convertColumn(com.amazonaws.services.glue.model.Column glueColumn)\n     {\n-        requireNonNull(sd.getSerdeInfo(), \"StorageDescriptor SerDeInfo is null\");\n-        SerDeInfo serdeInfo = sd.getSerdeInfo();\n-\n-        Optional<HiveBucketProperty> bucketProperty = Optional.empty();\n-        if (sd.getNumberOfBuckets() > 0) {\n-            if (isNullOrEmpty(sd.getBucketColumns())) {\n-                throw new PrestoException(HIVE_INVALID_METADATA, \"Table/partition metadata has 'numBuckets' set, but 'bucketCols' is not set\");\n-            }\n-            List<SortingColumn> sortedBy = ImmutableList.of();\n-            if (!isNullOrEmpty(sd.getSortColumns())) {\n-                sortedBy = sd.getSortColumns().stream()\n-                        .map(column -> new SortingColumn(\n-                                column.getColumn(),\n-                                Order.fromMetastoreApiOrder(column.getSortOrder(), \"unknown\")))\n-                        .collect(toImmutableList());\n-            }\n-            BucketingVersion bucketingVersion = HiveBucketing.getBucketingVersion(tableParameters);\n-            bucketProperty = Optional.of(new HiveBucketProperty(sd.getBucketColumns(), bucketingVersion, sd.getNumberOfBuckets(), sortedBy));\n-        }\n+        return new Column(glueColumn.getName(), HiveType.valueOf(glueColumn.getType().toLowerCase(Locale.ENGLISH)), Optional.ofNullable(glueColumn.getComment()));\n+    }\n \n-        storageBuilder.setStorageFormat(StorageFormat.createNullable(serdeInfo.getSerializationLibrary(), sd.getInputFormat(), sd.getOutputFormat()))\n-                .setLocation(nullToEmpty(sd.getLocation()))\n-                .setBucketProperty(bucketProperty)\n-                .setSkewed(sd.getSkewedInfo() != null && !isNullOrEmpty(sd.getSkewedInfo().getSkewedColumnNames()))\n-                .setSerdeParameters(firstNonNull(serdeInfo.getParameters(), ImmutableMap.of()))\n-                .build();\n+    private static List<Column> convertColumns(List<com.amazonaws.services.glue.model.Column> glueColumns)\n+    {\n+        return mappedCopy(glueColumns, GlueToPrestoConverter::convertColumn);\n     }\n \n-    private static Column convertColumn(com.amazonaws.services.glue.model.Column glueColumn)\n+    private static Map<String, String> convertParameters(Map<String, String> parameters)\n     {\n-        return new Column(glueColumn.getName(), HiveType.valueOf(glueColumn.getType().toLowerCase(Locale.ENGLISH)), Optional.ofNullable(glueColumn.getComment()));\n+        if (parameters == null || parameters.isEmpty()) {\n+            return ImmutableMap.of();\n+        }\n+        return ImmutableMap.copyOf(parameters);\n     }\n \n-    public static Partition convertPartition(com.amazonaws.services.glue.model.Partition gluePartition, Map<String, String> tableParameters)\n+    private static Function<Map<String, String>, Map<String, String>> parametersConverter()\n     {\n-        requireNonNull(gluePartition.getStorageDescriptor(), \"Partition StorageDescriptor is null\");\n-        StorageDescriptor sd = gluePartition.getStorageDescriptor();\n-\n-        Partition.Builder partitionBuilder = Partition.builder()\n-                .setDatabaseName(gluePartition.getDatabaseName())\n-                .setTableName(gluePartition.getTableName())\n-                .setValues(gluePartition.getValues())\n-                .setColumns(sd.getColumns().stream()\n-                        .map(GlueToPrestoConverter::convertColumn)\n-                        .collect(toImmutableList()))\n-                .setParameters(firstNonNull(gluePartition.getParameters(), ImmutableMap.of()));\n-\n-        setStorageBuilder(sd, partitionBuilder.getStorageBuilder(), tableParameters);\n-        return partitionBuilder.build();\n+        return Memoizers.memoizeLast(GlueToPrestoConverter::convertParameters);\n     }\n \n     private static boolean isNullOrEmpty(List<?> list)\n     {\n         return list == null || list.isEmpty();\n     }\n+\n+    public static final class GluePartitionConverter\n+            implements Function<com.amazonaws.services.glue.model.Partition, Partition>\n+    {\n+        private final Function<List<com.amazonaws.services.glue.model.Column>, List<Column>> columnsConverter = Memoizers.memoizeLast(\n+                GlueToPrestoConverter::convertColumns);\n+        private final Function<Map<String, String>, Map<String, String>> parametersConverter = parametersConverter();\n+        private final StorageConverter storageConverter = new StorageConverter();\n+        private final String databaseName;\n+        private final String tableName;\n+        private final Map<String, String> tableParameters;\n+\n+        public GluePartitionConverter(Table table)\n+        {\n+            requireNonNull(table, \"table is null\");\n+            this.databaseName = requireNonNull(table.getDatabaseName(), \"databaseName is null\");\n+            this.tableName = requireNonNull(table.getTableName(), \"tableName is null\");\n+            this.tableParameters = convertParameters(table.getParameters());\n+        }\n+\n+        @Override\n+        public Partition apply(com.amazonaws.services.glue.model.Partition gluePartition)\n+        {\n+            requireNonNull(gluePartition.getStorageDescriptor(), \"Partition StorageDescriptor is null\");\n+            StorageDescriptor sd = gluePartition.getStorageDescriptor();\n+\n+            if (!databaseName.equals(gluePartition.getDatabaseName())) {\n+                throw new IllegalArgumentException(format(\"Unexpected databaseName, expected: %s, but found: %s\", databaseName, gluePartition.getDatabaseName()));\n+            }\n+            if (!tableName.equals(gluePartition.getTableName())) {\n+                throw new IllegalArgumentException(format(\"Unexpected tableName, expected: %s, but found: %s\", tableName, gluePartition.getTableName()));\n+            }\n+\n+            Partition.Builder partitionBuilder = Partition.builder()\n+                    .setDatabaseName(databaseName)\n+                    .setTableName(tableName)\n+                    .setValues(gluePartition.getValues()) // No memoization benefit\n+                    .setColumns(columnsConverter.apply(sd.getColumns()))\n+                    .setParameters(parametersConverter.apply(gluePartition.getParameters()));\n+\n+            storageConverter.setStorageBuilder(sd, partitionBuilder.getStorageBuilder(), tableParameters);\n+\n+            return partitionBuilder.build();\n+        }\n+    }\n+\n+    private static final class StorageConverter\n+    {\n+        private final Function<List<String>, List<String>> bucketColumns = Memoizers.memoizeLast(ImmutableList::copyOf);\n+        private final Function<List<com.amazonaws.services.glue.model.Order>, List<SortingColumn>> sortColumns = Memoizers.memoizeLast(\n+                StorageConverter::createSortingColumns);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIzMjgyNg==", "bodyText": "Static import memoizeLast", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r520232826", "createdAt": "2020-11-10T01:44:39Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/converter/GlueToPrestoConverter.java", "diffHunk": "@@ -75,81 +87,162 @@ public static Table convertTable(com.amazonaws.services.glue.model.Table glueTab\n                 .setOwner(nullToEmpty(glueTable.getOwner()))\n                 // Athena treats missing table type as EXTERNAL_TABLE.\n                 .setTableType(firstNonNull(glueTable.getTableType(), EXTERNAL_TABLE.name()))\n-                .setDataColumns(sd.getColumns().stream()\n-                        .map(GlueToPrestoConverter::convertColumn)\n-                        .collect(toImmutableList()))\n+                .setDataColumns(convertColumns(sd.getColumns()))\n                 .setParameters(tableParameters)\n                 .setViewOriginalText(Optional.ofNullable(glueTable.getViewOriginalText()))\n                 .setViewExpandedText(Optional.ofNullable(glueTable.getViewExpandedText()));\n \n         if (glueTable.getPartitionKeys() != null) {\n-            tableBuilder.setPartitionColumns(glueTable.getPartitionKeys().stream()\n-                    .map(GlueToPrestoConverter::convertColumn)\n-                    .collect(toImmutableList()));\n+            tableBuilder.setPartitionColumns(convertColumns(glueTable.getPartitionKeys()));\n         }\n         else {\n-            tableBuilder.setPartitionColumns(new ArrayList<>());\n+            tableBuilder.setPartitionColumns(ImmutableList.of());\n         }\n-\n-        setStorageBuilder(sd, tableBuilder.getStorageBuilder(), tableParameters);\n+        // No benefit to memoizing here, just reusing the implementation\n+        new StorageConverter().setStorageBuilder(sd, tableBuilder.getStorageBuilder(), tableParameters);\n         return tableBuilder.build();\n     }\n \n-    private static void setStorageBuilder(StorageDescriptor sd, Storage.Builder storageBuilder, Map<String, String> tableParameters)\n+    private static Column convertColumn(com.amazonaws.services.glue.model.Column glueColumn)\n     {\n-        requireNonNull(sd.getSerdeInfo(), \"StorageDescriptor SerDeInfo is null\");\n-        SerDeInfo serdeInfo = sd.getSerdeInfo();\n-\n-        Optional<HiveBucketProperty> bucketProperty = Optional.empty();\n-        if (sd.getNumberOfBuckets() > 0) {\n-            if (isNullOrEmpty(sd.getBucketColumns())) {\n-                throw new PrestoException(HIVE_INVALID_METADATA, \"Table/partition metadata has 'numBuckets' set, but 'bucketCols' is not set\");\n-            }\n-            List<SortingColumn> sortedBy = ImmutableList.of();\n-            if (!isNullOrEmpty(sd.getSortColumns())) {\n-                sortedBy = sd.getSortColumns().stream()\n-                        .map(column -> new SortingColumn(\n-                                column.getColumn(),\n-                                Order.fromMetastoreApiOrder(column.getSortOrder(), \"unknown\")))\n-                        .collect(toImmutableList());\n-            }\n-            BucketingVersion bucketingVersion = HiveBucketing.getBucketingVersion(tableParameters);\n-            bucketProperty = Optional.of(new HiveBucketProperty(sd.getBucketColumns(), bucketingVersion, sd.getNumberOfBuckets(), sortedBy));\n-        }\n+        return new Column(glueColumn.getName(), HiveType.valueOf(glueColumn.getType().toLowerCase(Locale.ENGLISH)), Optional.ofNullable(glueColumn.getComment()));\n+    }\n \n-        storageBuilder.setStorageFormat(StorageFormat.createNullable(serdeInfo.getSerializationLibrary(), sd.getInputFormat(), sd.getOutputFormat()))\n-                .setLocation(nullToEmpty(sd.getLocation()))\n-                .setBucketProperty(bucketProperty)\n-                .setSkewed(sd.getSkewedInfo() != null && !isNullOrEmpty(sd.getSkewedInfo().getSkewedColumnNames()))\n-                .setSerdeParameters(firstNonNull(serdeInfo.getParameters(), ImmutableMap.of()))\n-                .build();\n+    private static List<Column> convertColumns(List<com.amazonaws.services.glue.model.Column> glueColumns)\n+    {\n+        return mappedCopy(glueColumns, GlueToPrestoConverter::convertColumn);\n     }\n \n-    private static Column convertColumn(com.amazonaws.services.glue.model.Column glueColumn)\n+    private static Map<String, String> convertParameters(Map<String, String> parameters)\n     {\n-        return new Column(glueColumn.getName(), HiveType.valueOf(glueColumn.getType().toLowerCase(Locale.ENGLISH)), Optional.ofNullable(glueColumn.getComment()));\n+        if (parameters == null || parameters.isEmpty()) {\n+            return ImmutableMap.of();\n+        }\n+        return ImmutableMap.copyOf(parameters);\n     }\n \n-    public static Partition convertPartition(com.amazonaws.services.glue.model.Partition gluePartition, Map<String, String> tableParameters)\n+    private static Function<Map<String, String>, Map<String, String>> parametersConverter()\n     {\n-        requireNonNull(gluePartition.getStorageDescriptor(), \"Partition StorageDescriptor is null\");\n-        StorageDescriptor sd = gluePartition.getStorageDescriptor();\n-\n-        Partition.Builder partitionBuilder = Partition.builder()\n-                .setDatabaseName(gluePartition.getDatabaseName())\n-                .setTableName(gluePartition.getTableName())\n-                .setValues(gluePartition.getValues())\n-                .setColumns(sd.getColumns().stream()\n-                        .map(GlueToPrestoConverter::convertColumn)\n-                        .collect(toImmutableList()))\n-                .setParameters(firstNonNull(gluePartition.getParameters(), ImmutableMap.of()));\n-\n-        setStorageBuilder(sd, partitionBuilder.getStorageBuilder(), tableParameters);\n-        return partitionBuilder.build();\n+        return Memoizers.memoizeLast(GlueToPrestoConverter::convertParameters);\n     }\n \n     private static boolean isNullOrEmpty(List<?> list)\n     {\n         return list == null || list.isEmpty();\n     }\n+\n+    public static final class GluePartitionConverter\n+            implements Function<com.amazonaws.services.glue.model.Partition, Partition>\n+    {\n+        private final Function<List<com.amazonaws.services.glue.model.Column>, List<Column>> columnsConverter = Memoizers.memoizeLast(\n+                GlueToPrestoConverter::convertColumns);\n+        private final Function<Map<String, String>, Map<String, String>> parametersConverter = parametersConverter();\n+        private final StorageConverter storageConverter = new StorageConverter();\n+        private final String databaseName;\n+        private final String tableName;\n+        private final Map<String, String> tableParameters;\n+\n+        public GluePartitionConverter(Table table)\n+        {\n+            requireNonNull(table, \"table is null\");\n+            this.databaseName = requireNonNull(table.getDatabaseName(), \"databaseName is null\");\n+            this.tableName = requireNonNull(table.getTableName(), \"tableName is null\");\n+            this.tableParameters = convertParameters(table.getParameters());\n+        }\n+\n+        @Override\n+        public Partition apply(com.amazonaws.services.glue.model.Partition gluePartition)\n+        {\n+            requireNonNull(gluePartition.getStorageDescriptor(), \"Partition StorageDescriptor is null\");\n+            StorageDescriptor sd = gluePartition.getStorageDescriptor();\n+\n+            if (!databaseName.equals(gluePartition.getDatabaseName())) {\n+                throw new IllegalArgumentException(format(\"Unexpected databaseName, expected: %s, but found: %s\", databaseName, gluePartition.getDatabaseName()));\n+            }\n+            if (!tableName.equals(gluePartition.getTableName())) {\n+                throw new IllegalArgumentException(format(\"Unexpected tableName, expected: %s, but found: %s\", tableName, gluePartition.getTableName()));\n+            }\n+\n+            Partition.Builder partitionBuilder = Partition.builder()\n+                    .setDatabaseName(databaseName)\n+                    .setTableName(tableName)\n+                    .setValues(gluePartition.getValues()) // No memoization benefit\n+                    .setColumns(columnsConverter.apply(sd.getColumns()))\n+                    .setParameters(parametersConverter.apply(gluePartition.getParameters()));\n+\n+            storageConverter.setStorageBuilder(sd, partitionBuilder.getStorageBuilder(), tableParameters);\n+\n+            return partitionBuilder.build();\n+        }\n+    }\n+\n+    private static final class StorageConverter\n+    {\n+        private final Function<List<String>, List<String>> bucketColumns = Memoizers.memoizeLast(ImmutableList::copyOf);\n+        private final Function<List<com.amazonaws.services.glue.model.Order>, List<SortingColumn>> sortColumns = Memoizers.memoizeLast(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 200}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "e64555d87950d72f2c50621f3a5cc4106fc5b56f", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/trinodb/trino/commit/e64555d87950d72f2c50621f3a5cc4106fc5b56f", "committedDate": "2020-11-10T13:41:18Z", "message": "Reuse immutable partition fields in Glue partition conversion\n\nWhen loading a large number of partitions from Glue (and\nespecially when storing the loaded values into a cache), partition\ninstances often share equivalent immutable field values (eg:\ntheir columns list) which can consume a large amount of\ncoordinator heap space.\n\nThis change enables opportunistic reuse of some partition fields\nby memoizing values during transformation and opportunistically\nreusing equivalent shared instances for consecutive converted\npartitions."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "e64555d87950d72f2c50621f3a5cc4106fc5b56f", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/trinodb/trino/commit/e64555d87950d72f2c50621f3a5cc4106fc5b56f", "committedDate": "2020-11-10T13:41:18Z", "message": "Reuse immutable partition fields in Glue partition conversion\n\nWhen loading a large number of partitions from Glue (and\nespecially when storing the loaded values into a cache), partition\ninstances often share equivalent immutable field values (eg:\ntheir columns list) which can consume a large amount of\ncoordinator heap space.\n\nThis change enables opportunistic reuse of some partition fields\nby memoizing values during transformation and opportunistically\nreusing equivalent shared instances for consecutive converted\npartitions."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5Mzk5Njcx", "url": "https://github.com/trinodb/trino/pull/5794#pullrequestreview-529399671", "createdAt": "2020-11-12T19:01:45Z", "commit": {"oid": "e64555d87950d72f2c50621f3a5cc4106fc5b56f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2773, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}