{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0NjY3NTY1", "number": 6260, "title": "More contention reductions", "bodyText": "Continuation of contention reducing changes in #6097 extracted from prestodb/presto#15509\nSeven commits:\n\nCache ListenableFuture<?> isBlocked in various operators to avoid repeatedly contending for locks and potentially registering new callbacks once those operators are blocked\nAdd unsynchronized fast-paths in ExchangeClient to avoid unnecessary contention\nRefactor ExchangeClient#pollPage to avoid redundant checks and synchronizations\nUse AtomicIntegerFieldUpdater for local exchange PageReference\nReduce synchronization in LocalExchangeMemoryManager by making unblocking an edge-triggered event that only a single caller initiates.\nAdd unsynchronized common-case fast paths in LocalExchangeSource\nRemove synchronized for final field read in MemoryPool#getMaxBytes()", "createdAt": "2020-12-08T19:18:15Z", "url": "https://github.com/trinodb/trino/pull/6260", "merged": true, "mergeCommit": {"oid": "9537b02998697a79146356f8ec3b421b44db1f89"}, "closed": true, "closedAt": "2021-01-11T21:22:36Z", "author": {"login": "pettyjamesm"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkPLUhgBqjQwODYzNjM0NTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdvLHKHgBqjQxOTIyNzYyODk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTkxODU1", "url": "https://github.com/trinodb/trino/pull/6260#pullrequestreview-549991855", "createdAt": "2020-12-11T10:49:33Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDo0OTozM1rOIDzaEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDo1MzoyNlrOIDzjSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1ODg5OQ==", "bodyText": "future for partitionFunction is already cached", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r540858899", "createdAt": "2020-12-11T10:49:33Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/PartitionedOutputOperator.java", "diffHunk": "@@ -261,8 +262,13 @@ public boolean isFinished()\n     @Override\n     public ListenableFuture<?> isBlocked()\n     {\n-        ListenableFuture<?> blocked = partitionFunction.isFull();\n-        return blocked.isDone() ? NOT_BLOCKED : blocked;\n+        if (isBlocked.isDone()) {\n+            isBlocked = partitionFunction.isFull();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1OTEzMg==", "bodyText": "future of output buffer is already cached", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r540859132", "createdAt": "2020-12-11T10:49:56Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/TaskOutputOperator.java", "diffHunk": "@@ -122,8 +123,13 @@ public boolean isFinished()\n     @Override\n     public ListenableFuture<?> isBlocked()\n     {\n-        ListenableFuture<?> blocked = outputBuffer.isFull();\n-        return blocked.isDone() ? NOT_BLOCKED : blocked;\n+        if (isBlocked.isDone()) {\n+            isBlocked = outputBuffer.isFull();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1OTcwOQ==", "bodyText": "future of sink is already cached", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r540859709", "createdAt": "2020-12-11T10:50:56Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeSinkOperator.java", "diffHunk": "@@ -128,7 +129,13 @@ public boolean isFinished()\n     @Override\n     public ListenableFuture<?> isBlocked()\n     {\n-        return sink.waitForWriting();\n+        if (isBlocked.isDone()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2MDAyMA==", "bodyText": "future of source is already cached", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r540860020", "createdAt": "2020-12-11T10:51:29Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeSourceOperator.java", "diffHunk": "@@ -103,7 +104,13 @@ public boolean isFinished()\n     @Override\n     public ListenableFuture<?> isBlocked()\n     {\n-        return source.waitForReading();\n+        if (isBlocked.isDone()) {\n+            isBlocked = source.waitForReading();\n+            if (isBlocked.isDone()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2MTI1Ng==", "bodyText": "Change commit name Cache ExchangeClient#isBlocked future. Add explanation why io.prestosql.operator.ExchangeClient#isBlocked creates a new future every time (because they can be cancelled in io.prestosql.server.protocol.Query#waitForResults)", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r540861256", "createdAt": "2020-12-11T10:53:26Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/ExchangeOperator.java", "diffHunk": "@@ -92,6 +92,7 @@ public void noMoreOperators()\n     private final PlanNodeId sourceId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNzA1MDI0", "url": "https://github.com/trinodb/trino/pull/6260#pullrequestreview-553705024", "createdAt": "2020-12-16T13:53:20Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMzo1MzoyMVrOIHGWHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNDo0NzoxOFrOIHI5TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMxNDkwOA==", "bodyText": "nit: double space after //", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544314908", "createdAt": "2020-12-16T13:53:21Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/ExchangeOperator.java", "diffHunk": "@@ -152,11 +153,14 @@ public boolean isFinished()\n     @Override\n     public ListenableFuture<?> isBlocked()\n     {\n-        ListenableFuture<?> blocked = exchangeClient.isBlocked();\n-        if (blocked.isDone()) {\n-            return NOT_BLOCKED;\n+        //  Avoid registering a new callback in the ExchangeClient when one is already pending", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMyODExOA==", "bodyText": "I don't think this buys anything. I would continue to use buffers.size()", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544328118", "createdAt": "2020-12-16T14:11:08Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/BroadcastExchanger.java", "diffHunk": "@@ -27,19 +28,23 @@\n {\n     private final List<Consumer<PageReference>> buffers;\n     private final LocalExchangeMemoryManager memoryManager;\n+    private final LongConsumer onPageReleased;\n+    private final int bufferCount;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMyODg5Mw==", "bodyText": "Changing from Runnable to LongConsumer doesn't improve anything. Undo. Alternatively make it Consumer<Page> as it's more explicit than generic long.", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544328893", "createdAt": "2020-12-16T14:12:09Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/PageReference.java", "diffHunk": "@@ -17,24 +17,28 @@\n \n import javax.annotation.concurrent.ThreadSafe;\n \n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.function.LongConsumer;\n \n+import static com.google.common.base.MoreObjects.toStringHelper;\n import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n-class PageReference\n+final class PageReference\n {\n+    private static final AtomicIntegerFieldUpdater<PageReference> REFERENCE_COUNT_UPDATER = AtomicIntegerFieldUpdater.newUpdater(PageReference.class, \"referenceCount\");\n+\n     private final Page page;\n-    private final Runnable onFree;\n-    private final AtomicInteger referenceCount;\n+    private final LongConsumer onPageReleased;\n+    private volatile int referenceCount;\n \n-    public PageReference(Page page, int referenceCount, Runnable onFree)\n+    public PageReference(Page page, int referenceCount, LongConsumer onPageReleased)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMyOTc3NA==", "bodyText": "unrelated change. Extract to separate commit", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544329774", "createdAt": "2020-12-16T14:13:20Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/PageReference.java", "diffHunk": "@@ -17,24 +17,28 @@\n \n import javax.annotation.concurrent.ThreadSafe;\n \n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.function.LongConsumer;\n \n+import static com.google.common.base.MoreObjects.toStringHelper;\n import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n-class PageReference\n+final class PageReference", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMDA0MQ==", "bodyText": "extract to separate commit", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544330041", "createdAt": "2020-12-16T14:13:44Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/PageReference.java", "diffHunk": "@@ -44,11 +48,26 @@ public long getRetainedSizeInBytes()\n \n     public Page removePage()\n     {\n-        int referenceCount = this.referenceCount.decrementAndGet();\n+        int referenceCount = REFERENCE_COUNT_UPDATER.decrementAndGet(this);\n         checkArgument(referenceCount >= 0, \"Page reference count is negative\");\n         if (referenceCount == 0) {\n-            onFree.run();\n+            onPageReleased.accept(page.getRetainedSizeInBytes());\n         }\n         return page;\n     }\n+\n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMTI4Mg==", "bodyText": "this is binding PageReference code with LocalExchangeMemoryManager unnecessarily.", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544331282", "createdAt": "2020-12-16T14:15:21Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/PageReference.java", "diffHunk": "@@ -44,11 +48,26 @@ public long getRetainedSizeInBytes()\n \n     public Page removePage()\n     {\n-        int referenceCount = this.referenceCount.decrementAndGet();\n+        int referenceCount = REFERENCE_COUNT_UPDATER.decrementAndGet(this);\n         checkArgument(referenceCount >= 0, \"Page reference count is negative\");\n         if (referenceCount == 0) {\n-            onFree.run();\n+            onPageReleased.accept(page.getRetainedSizeInBytes());\n         }\n         return page;\n     }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return toStringHelper(this)\n+                .add(\"size\", getRetainedSizeInBytes())\n+                .add(\"referenceCount\", referenceCount)\n+                .toString();\n+    }\n+\n+    public static LongConsumer releaseListenerForExchangeMemoryManager(LocalExchangeMemoryManager memoryManager)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMjAwMg==", "bodyText": "I don't think AtomicInteger is a problem. Page granularity is not such a big deal. If there was AtomicInteger per row that would be a problem", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544332002", "createdAt": "2020-12-16T14:16:11Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/PageReference.java", "diffHunk": "@@ -17,24 +17,28 @@\n \n import javax.annotation.concurrent.ThreadSafe;\n \n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.function.LongConsumer;\n \n+import static com.google.common.base.MoreObjects.toStringHelper;\n import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n-class PageReference\n+final class PageReference\n {\n+    private static final AtomicIntegerFieldUpdater<PageReference> REFERENCE_COUNT_UPDATER = AtomicIntegerFieldUpdater.newUpdater(PageReference.class, \"referenceCount\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0MDM5Mg==", "bodyText": "nit: extra space after //", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544340392", "createdAt": "2020-12-16T14:26:54Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeMemoryManager.java", "diffHunk": "@@ -47,31 +49,37 @@ public LocalExchangeMemoryManager(long maxBufferedBytes)\n \n     public void updateMemoryUsage(long bytesAdded)\n     {\n-        SettableFuture<?> future;\n-        synchronized (this) {\n-            bufferedBytes.addAndGet(bytesAdded);\n-\n-            // if we are full, then breakout\n-            if (bufferedBytes.get() > maxBufferedBytes || notFullFuture.isDone()) {\n-                return;\n+        long bufferedBytes = this.bufferedBytes.addAndGet(bytesAdded);\n+        // detect the transition from above to below the full boundary\n+        if (bufferedBytes <= maxBufferedBytes && (bufferedBytes - bytesAdded) > maxBufferedBytes) {\n+            SettableFuture<?> future;\n+            synchronized (this) {\n+                //  if we have no callback waiting, return early", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0MTA1OQ==", "bodyText": "use notFullFuture.isDone()", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544341059", "createdAt": "2020-12-16T14:27:42Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeMemoryManager.java", "diffHunk": "@@ -47,31 +49,37 @@ public LocalExchangeMemoryManager(long maxBufferedBytes)\n \n     public void updateMemoryUsage(long bytesAdded)\n     {\n-        SettableFuture<?> future;\n-        synchronized (this) {\n-            bufferedBytes.addAndGet(bytesAdded);\n-\n-            // if we are full, then breakout\n-            if (bufferedBytes.get() > maxBufferedBytes || notFullFuture.isDone()) {\n-                return;\n+        long bufferedBytes = this.bufferedBytes.addAndGet(bytesAdded);\n+        // detect the transition from above to below the full boundary\n+        if (bufferedBytes <= maxBufferedBytes && (bufferedBytes - bytesAdded) > maxBufferedBytes) {\n+            SettableFuture<?> future;\n+            synchronized (this) {\n+                //  if we have no callback waiting, return early\n+                if (notFullFuture == NOT_FULL) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0MjI3Mw==", "bodyText": "recheck if (bufferedBytes.get() > maxBufferedBytes || notFullFuture.isDone())", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544342273", "createdAt": "2020-12-16T14:29:17Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeMemoryManager.java", "diffHunk": "@@ -47,31 +49,37 @@ public LocalExchangeMemoryManager(long maxBufferedBytes)\n \n     public void updateMemoryUsage(long bytesAdded)\n     {\n-        SettableFuture<?> future;\n-        synchronized (this) {\n-            bufferedBytes.addAndGet(bytesAdded);\n-\n-            // if we are full, then breakout\n-            if (bufferedBytes.get() > maxBufferedBytes || notFullFuture.isDone()) {\n-                return;\n+        long bufferedBytes = this.bufferedBytes.addAndGet(bytesAdded);\n+        // detect the transition from above to below the full boundary\n+        if (bufferedBytes <= maxBufferedBytes && (bufferedBytes - bytesAdded) > maxBufferedBytes) {\n+            SettableFuture<?> future;\n+            synchronized (this) {\n+                //  if we have no callback waiting, return early\n+                if (notFullFuture == NOT_FULL) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0ODE3MQ==", "bodyText": "simplify:\n// optionally\nif (bufferedBytes.get() <= maxBufferedBytes) {\n  return NOT_BLOCKED;\n}\nif (notFullFuture.isDone()) {\n  notFullFuture = SettableFuture.create();\n}", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544348171", "createdAt": "2020-12-16T14:37:00Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeMemoryManager.java", "diffHunk": "@@ -47,31 +49,37 @@ public LocalExchangeMemoryManager(long maxBufferedBytes)\n \n     public void updateMemoryUsage(long bytesAdded)\n     {\n-        SettableFuture<?> future;\n-        synchronized (this) {\n-            bufferedBytes.addAndGet(bytesAdded);\n-\n-            // if we are full, then breakout\n-            if (bufferedBytes.get() > maxBufferedBytes || notFullFuture.isDone()) {\n-                return;\n+        long bufferedBytes = this.bufferedBytes.addAndGet(bytesAdded);\n+        // detect the transition from above to below the full boundary\n+        if (bufferedBytes <= maxBufferedBytes && (bufferedBytes - bytesAdded) > maxBufferedBytes) {\n+            SettableFuture<?> future;\n+            synchronized (this) {\n+                //  if we have no callback waiting, return early\n+                if (notFullFuture == NOT_FULL) {\n+                    return;\n+                }\n+                future = notFullFuture;\n+                notFullFuture = NOT_FULL;\n             }\n-\n-            // otherwise, we are not full, so complete the future\n-            future = notFullFuture;\n-            notFullFuture = NOT_FULL;\n+            // complete future outside of lock since this can invoke callbacks\n+            future.set(null);\n         }\n-\n-        // complete future outside of lock since this can invoke callbacks\n-        future.set(null);\n     }\n \n-    public synchronized ListenableFuture<?> getNotFullFuture()\n+    public ListenableFuture<?> getNotFullFuture()\n     {\n-        // if we are full and the current not full future is already complete, create a new one\n-        if (bufferedBytes.get() > maxBufferedBytes && notFullFuture.isDone()) {\n-            notFullFuture = SettableFuture.create();\n+        if (bufferedBytes.get() <= maxBufferedBytes) {\n+            return NOT_BLOCKED;\n+        }\n+        SettableFuture<?> future;\n+        synchronized (this) {\n+            // if we are full and the current not full future is already complete, create a new one\n+            if ((notFullFuture == NOT_FULL || notFullFuture.isDone()) && bufferedBytes.get() > maxBufferedBytes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM1NjY4NA==", "bodyText": "let's remove this. This makes he code unnecessarily complicated.", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544356684", "createdAt": "2020-12-16T14:47:18Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeMemoryManager.java", "diffHunk": "@@ -22,10 +22,12 @@\n import java.util.concurrent.atomic.AtomicLong;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n \n @ThreadSafe\n public class LocalExchangeMemoryManager\n {\n+    private static final ListenableFuture<?> NOT_BLOCKED = immediateFuture(null);\n     private static final SettableFuture<?> NOT_FULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 10}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2ODQ4MTgz", "url": "https://github.com/trinodb/trino/pull/6260#pullrequestreview-556848183", "createdAt": "2020-12-22T06:32:04Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNjozMjowNFrOIJv9sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNzo0OToyOFrOIJxnFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA5MzkzNg==", "bodyText": "The question I have here is why the ExchangeClient is in fact returning a different Future for each call to isBlocked()? The whole point of ListenableFutures is that a single instance is capable of delegating completion to multiple listeners already without creating a new instance each time. That might be something we should also fix in ExchangeClient.", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547093936", "createdAt": "2020-12-22T06:32:04Z", "author": {"login": "erichwang"}, "path": "presto-main/src/main/java/io/prestosql/operator/ExchangeOperator.java", "diffHunk": "@@ -152,11 +153,14 @@ public boolean isFinished()\n     @Override\n     public ListenableFuture<?> isBlocked()\n     {\n-        ListenableFuture<?> blocked = exchangeClient.isBlocked();\n-        if (blocked.isDone()) {\n-            return NOT_BLOCKED;\n+        //  Avoid registering a new callback in the ExchangeClient when one is already pending", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwMzQ5Mw==", "bodyText": "This is certainly an interesting idea, but does this actually make a difference? Presto is pretty much built around pushing megamorphic call sites to page-sized granularities. If this needs to be specialized like this, we probably have much bigger issues throughout the entire engine.", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547103493", "createdAt": "2020-12-22T07:02:06Z", "author": {"login": "erichwang"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/PageReference.java", "diffHunk": "@@ -44,11 +48,26 @@ public long getRetainedSizeInBytes()\n \n     public Page removePage()\n     {\n-        int referenceCount = this.referenceCount.decrementAndGet();\n+        int referenceCount = REFERENCE_COUNT_UPDATER.decrementAndGet(this);\n         checkArgument(referenceCount >= 0, \"Page reference count is negative\");\n         if (referenceCount == 0) {\n-            onFree.run();\n+            onPageReleased.accept(page.getRetainedSizeInBytes());\n         }\n         return page;\n     }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return toStringHelper(this)\n+                .add(\"size\", getRetainedSizeInBytes())\n+                .add(\"referenceCount\", referenceCount)\n+                .toString();\n+    }\n+\n+    public static LongConsumer releaseListenerForExchangeMemoryManager(LocalExchangeMemoryManager memoryManager)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMTI4Mg=="}, "originalCommit": null, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwODQxMA==", "bodyText": "the default constructor value for AtomicBoolean is already false.", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547108410", "createdAt": "2020-12-22T07:16:31Z", "author": {"login": "erichwang"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeSource.java", "diffHunk": "@@ -19,41 +19,37 @@\n import io.prestosql.operator.WorkProcessor.ProcessState;\n import io.prestosql.spi.Page;\n \n+import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.ArrayList;\n import java.util.List;\n-import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.function.Consumer;\n \n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n public class LocalExchangeSource\n {\n-    private static final SettableFuture<?> NOT_EMPTY;\n-\n-    static {\n-        NOT_EMPTY = SettableFuture.create();\n-        NOT_EMPTY.set(null);\n-    }\n+    private static final ListenableFuture<?> NOT_BLOCKED = immediateFuture(null);\n \n     private final Consumer<LocalExchangeSource> onFinish;\n \n-    private final BlockingQueue<PageReference> buffer = new LinkedBlockingDeque<>();\n+    private final LinkedBlockingDeque<PageReference> buffer = new LinkedBlockingDeque<>();\n     private final AtomicLong bufferedBytes = new AtomicLong();\n \n-    private final Object lock = new Object();\n-\n-    @GuardedBy(\"lock\")\n-    private SettableFuture<?> notEmptyFuture = NOT_EMPTY;\n+    @Nullable\n+    @GuardedBy(\"this\")\n+    private SettableFuture<?> notEmptyFuture; // null indicates no callback has been registered\n \n-    @GuardedBy(\"lock\")\n-    private boolean finishing;\n+    @GuardedBy(\"this\")\n+    private final AtomicBoolean finishing = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzExMDEzOA==", "bodyText": "Why do we need to change BlockingQueue to LinkedBlockingDeque?", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547110138", "createdAt": "2020-12-22T07:21:32Z", "author": {"login": "erichwang"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeSource.java", "diffHunk": "@@ -19,41 +19,37 @@\n import io.prestosql.operator.WorkProcessor.ProcessState;\n import io.prestosql.spi.Page;\n \n+import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.ArrayList;\n import java.util.List;\n-import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.function.Consumer;\n \n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n public class LocalExchangeSource\n {\n-    private static final SettableFuture<?> NOT_EMPTY;\n-\n-    static {\n-        NOT_EMPTY = SettableFuture.create();\n-        NOT_EMPTY.set(null);\n-    }\n+    private static final ListenableFuture<?> NOT_BLOCKED = immediateFuture(null);\n \n     private final Consumer<LocalExchangeSource> onFinish;\n \n-    private final BlockingQueue<PageReference> buffer = new LinkedBlockingDeque<>();\n+    private final LinkedBlockingDeque<PageReference> buffer = new LinkedBlockingDeque<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEyMDkxOA==", "bodyText": "Any reason making notEmptyFuture nullable is better than what we had before? This seems bulkier without notable benefit?", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547120918", "createdAt": "2020-12-22T07:49:28Z", "author": {"login": "erichwang"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeSource.java", "diffHunk": "@@ -164,18 +178,20 @@ public void finish()\n         checkNotHoldsLock();\n \n         SettableFuture<?> notEmptyFuture;\n-        synchronized (lock) {\n-            if (finishing) {\n+        synchronized (this) {\n+            if (!finishing.compareAndSet(false, true)) {\n                 return;\n             }\n-            finishing = true;\n \n+            //  Unblock any waiters\n             notEmptyFuture = this.notEmptyFuture;\n-            this.notEmptyFuture = NOT_EMPTY;\n+            this.notEmptyFuture = null;\n         }\n \n         // notify readers outside of lock since this may result in a callback\n-        notEmptyFuture.set(null);\n+        if (notEmptyFuture != null) {\n+            notEmptyFuture.set(null);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 152}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MDI0ODkw", "url": "https://github.com/trinodb/trino/pull/6260#pullrequestreview-557024890", "createdAt": "2020-12-22T11:54:12Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMTo1NDoxMlrOIJ4mxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjoyNDoxNVrOIJ5Yag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIzNTUyNg==", "bodyText": "isBlocked can be called from io.prestosql.server.protocol.Query#getFutureStateChange, which is called from io.prestosql.server.protocol.Query#waitForResults with future timeout. This means that returned future can be cancelled and we need to protect against that.\nSimilar concept is done in io.prestosql.execution.FutureStateChange which is used by long pooling from REST resources.", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547235526", "createdAt": "2020-12-22T11:54:12Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/ExchangeOperator.java", "diffHunk": "@@ -152,11 +153,14 @@ public boolean isFinished()\n     @Override\n     public ListenableFuture<?> isBlocked()\n     {\n-        ListenableFuture<?> blocked = exchangeClient.isBlocked();\n-        if (blocked.isDone()) {\n-            return NOT_BLOCKED;\n+        //  Avoid registering a new callback in the ExchangeClient when one is already pending", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA5MzkzNg=="}, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MDc0Mg==", "bodyText": "Runnable requires that each PageReference instance is initialized with a lambda that captures state from the creating context in order to perform cleanup. a single LongConsumer can be created per exchange sink and used for all created instances.\n\nYou could make it Consumer<PageReference>\nThen lambda can be:\nreference -> doSomething(reference.getRetainedSizeInBytes()\n\nIt's cleaner and more explicit than generic long.", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547240742", "createdAt": "2020-12-22T12:06:19Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/PageReference.java", "diffHunk": "@@ -17,24 +17,28 @@\n \n import javax.annotation.concurrent.ThreadSafe;\n \n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.function.LongConsumer;\n \n+import static com.google.common.base.MoreObjects.toStringHelper;\n import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n-class PageReference\n+final class PageReference\n {\n+    private static final AtomicIntegerFieldUpdater<PageReference> REFERENCE_COUNT_UPDATER = AtomicIntegerFieldUpdater.newUpdater(PageReference.class, \"referenceCount\");\n+\n     private final Page page;\n-    private final Runnable onFree;\n-    private final AtomicInteger referenceCount;\n+    private final LongConsumer onPageReleased;\n+    private volatile int referenceCount;\n \n-    public PageReference(Page page, int referenceCount, Runnable onFree)\n+    public PageReference(Page page, int referenceCount, LongConsumer onPageReleased)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMyODg5Mw=="}, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MTI5NA==", "bodyText": "You could add toString without referenceCount in previous commit and then add referenceCount to toString in this commit", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547241294", "createdAt": "2020-12-22T12:07:29Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/PageReference.java", "diffHunk": "@@ -44,11 +48,26 @@ public long getRetainedSizeInBytes()\n \n     public Page removePage()\n     {\n-        int referenceCount = this.referenceCount.decrementAndGet();\n+        int referenceCount = REFERENCE_COUNT_UPDATER.decrementAndGet(this);\n         checkArgument(referenceCount >= 0, \"Page reference count is negative\");\n         if (referenceCount == 0) {\n-            onFree.run();\n+            onPageReleased.accept(page.getRetainedSizeInBytes());\n         }\n         return page;\n     }\n+\n+    @Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMDA0MQ=="}, "originalCommit": null, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MzU5NQ==", "bodyText": "I agree with @erichwang . We should not obscure readability for negligible perf improvements", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547243595", "createdAt": "2020-12-22T12:13:14Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/PageReference.java", "diffHunk": "@@ -44,11 +48,26 @@ public long getRetainedSizeInBytes()\n \n     public Page removePage()\n     {\n-        int referenceCount = this.referenceCount.decrementAndGet();\n+        int referenceCount = REFERENCE_COUNT_UPDATER.decrementAndGet(this);\n         checkArgument(referenceCount >= 0, \"Page reference count is negative\");\n         if (referenceCount == 0) {\n-            onFree.run();\n+            onPageReleased.accept(page.getRetainedSizeInBytes());\n         }\n         return page;\n     }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return toStringHelper(this)\n+                .add(\"size\", getRetainedSizeInBytes())\n+                .add(\"referenceCount\", referenceCount)\n+                .toString();\n+    }\n+\n+    public static LongConsumer releaseListenerForExchangeMemoryManager(LocalExchangeMemoryManager memoryManager)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMTI4Mg=="}, "originalCommit": null, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NDkzNA==", "bodyText": "please initialize it with NOT_BLOCKED", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547244934", "createdAt": "2020-12-22T12:16:37Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeMemoryManager.java", "diffHunk": "@@ -16,28 +16,26 @@\n import com.google.common.util.concurrent.ListenableFuture;\n import com.google.common.util.concurrent.SettableFuture;\n \n+import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.concurrent.atomic.AtomicLong;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n \n @ThreadSafe\n public class LocalExchangeMemoryManager\n {\n-    private static final SettableFuture<?> NOT_FULL;\n-\n-    static {\n-        NOT_FULL = SettableFuture.create();\n-        NOT_FULL.set(null);\n-    }\n+    private static final ListenableFuture<?> NOT_BLOCKED = immediateFuture(null);\n \n     private final long maxBufferedBytes;\n     private final AtomicLong bufferedBytes = new AtomicLong();\n \n+    @Nullable\n     @GuardedBy(\"this\")\n-    private SettableFuture<?> notFullFuture = NOT_FULL;\n+    private SettableFuture<?> notFullFuture; // null represents \"no callback registered\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0ODIzNA==", "bodyText": "This optimization reduces readability of concurrent code for little benefit. In practice, we already synchronized on this, so doing extra checks like notFullFuture.isDone() is not a big issue. Also, we should recheck that buffer is still not full before triggering future. That check is cheap, but waking up drivers to do empty processing is not.\n\nThe effect was that previously the transition edge from above-full to below full always unblocked any waiters, and not doing so here (even if we've transitioned back up above the full boundary in the mean time) is a departure from that behavior.\n\nWe cold not transition back to above in the meantime because all methods in LocalExchangeMemoryManager are synchronized. We could transition to above immediately after future was set, but that's slightly different behavior.", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547248234", "createdAt": "2020-12-22T12:24:15Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeMemoryManager.java", "diffHunk": "@@ -47,31 +45,39 @@ public LocalExchangeMemoryManager(long maxBufferedBytes)\n \n     public void updateMemoryUsage(long bytesAdded)\n     {\n-        SettableFuture<?> future;\n-        synchronized (this) {\n-            bufferedBytes.addAndGet(bytesAdded);\n-\n-            // if we are full, then breakout\n-            if (bufferedBytes.get() > maxBufferedBytes || notFullFuture.isDone()) {\n-                return;\n+        long bufferedBytes = this.bufferedBytes.addAndGet(bytesAdded);\n+        // detect the transition from above to below the full boundary\n+        if (bufferedBytes <= maxBufferedBytes && (bufferedBytes - bytesAdded) > maxBufferedBytes) {\n+            SettableFuture<?> future;\n+            synchronized (this) {\n+                // if we have no callback waiting, return early", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 50}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NjA4MjE3", "url": "https://github.com/trinodb/trino/pull/6260#pullrequestreview-564608217", "createdAt": "2021-01-08T21:49:31Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQyMTo0OTozMlrOIQiO3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQyMjo0MjoxNlrOIQjpRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDIwODk4OA==", "bodyText": "In this case, why not exit early at the top of the method?", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r554208988", "createdAt": "2021-01-08T21:49:32Z", "author": {"login": "dain"}, "path": "core/trino-main/src/main/java/io/trino/operator/ExchangeClient.java", "diffHunk": "@@ -322,52 +323,73 @@ public synchronized void scheduleRequestIfNecessary()\n         }\n     }\n \n-    public synchronized ListenableFuture<?> isBlocked()\n+    public ListenableFuture<?> isBlocked()\n     {\n+        // Fast path pre-check\n         if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n-            return Futures.immediateFuture(true);\n+            return NOT_BLOCKED;\n+        }\n+        synchronized (this) {\n+            // Recheck after acquiring the lock\n+            if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n+                return NOT_BLOCKED;\n+            }\n+            SettableFuture<?> future = SettableFuture.create();\n+            blockedCallers.add(future);\n+            return future;\n         }\n-        SettableFuture<?> future = SettableFuture.create();\n-        blockedCallers.add(future);\n-        return future;\n     }\n \n-    private synchronized boolean addPages(List<SerializedPage> pages)\n+    private boolean addPages(List<SerializedPage> pages)\n     {\n-        if (isClosed() || isFailed()) {\n-            return false;\n+        // Compute stats before acquiring the lock\n+        long pagesRetainedSizeInBytes = 0;\n+        long responseSize = 0;\n+        for (SerializedPage page : pages) {\n+            pagesRetainedSizeInBytes += page.getRetainedSizeInBytes();\n+            responseSize += page.getSizeInBytes();\n         }\n \n-        pageBuffer.addAll(pages);\n+        List<SettableFuture<?>> notify = ImmutableList.of();\n+        synchronized (this) {\n+            if (isClosed() || isFailed()) {\n+                return false;\n+            }\n \n-        if (!pages.isEmpty()) {\n-            // notify all blocked callers\n-            notifyBlockedCallers();\n-        }\n+            pageBuffer.addAll(pages);\n \n-        long pagesRetainedSizeInBytes = pages.stream()\n-                .mapToLong(SerializedPage::getRetainedSizeInBytes)\n-                .sum();\n+            bufferRetainedSizeInBytes += pagesRetainedSizeInBytes;\n+            maxBufferRetainedSizeInBytes = Math.max(maxBufferRetainedSizeInBytes, bufferRetainedSizeInBytes);\n+            systemMemoryContext.setBytes(bufferRetainedSizeInBytes);\n+            successfulRequests++;\n+            // AVG_n = AVG_(n-1) * (n-1)/n + VALUE_n / n\n+            averageBytesPerRequest = (long) (1.0 * averageBytesPerRequest * (successfulRequests - 1) / successfulRequests + responseSize / successfulRequests);\n \n-        bufferRetainedSizeInBytes += pagesRetainedSizeInBytes;\n-        maxBufferRetainedSizeInBytes = Math.max(maxBufferRetainedSizeInBytes, bufferRetainedSizeInBytes);\n-        systemMemoryContext.setBytes(bufferRetainedSizeInBytes);\n-        successfulRequests++;\n+            if (!pages.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDIzMjEzMg==", "bodyText": "Don't we already have a constant for this?", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r554232132", "createdAt": "2021-01-08T22:42:16Z", "author": {"login": "dain"}, "path": "core/trino-main/src/main/java/io/trino/operator/exchange/LocalExchangeSource.java", "diffHunk": "@@ -30,30 +31,24 @@\n import java.util.function.Consumer;\n \n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n public class LocalExchangeSource\n {\n-    private static final SettableFuture<?> NOT_EMPTY;\n-\n-    static {\n-        NOT_EMPTY = SettableFuture.create();\n-        NOT_EMPTY.set(null);\n-    }\n+    private static final ListenableFuture<?> NOT_BLOCKED = immediateFuture(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 24}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "02e79f6964057b23f3e4483dac2701a7e84ce6a2", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/trinodb/trino/commit/02e79f6964057b23f3e4483dac2701a7e84ce6a2", "committedDate": "2021-01-11T18:47:58Z", "message": "Cache isBlocked in various operators\n\nAvoids re-checking the same isBlocked condition when the operator\nblocks which reduces contention for locks and registering duplicate\nisBlocked callback events."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b51b67b4c9e154be7e48515b7d6bbb6d5b52b06", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/trinodb/trino/commit/1b51b67b4c9e154be7e48515b7d6bbb6d5b52b06", "committedDate": "2021-01-11T18:47:58Z", "message": "Add unsynchronized fast paths to reduce contention in ExchangeClient"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8ebd11abad1bcfb2464ef72109e5ad13f17460f", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/trinodb/trino/commit/d8ebd11abad1bcfb2464ef72109e5ad13f17460f", "committedDate": "2021-01-11T18:47:58Z", "message": "Refactor ExchangeClient#pollPage\n\nMerges ExchangeClient#postProcessPage into ExchangeClient#pollPage\n(its only usage) to avoid a redundant lock holder check, removes\na redundant peek into the pagesBuffer for NO_MORE_PAGES, and coalesces\nthe synchronized section of scheduleRequestIfNecessary into the\nsynchronized block that immediately preceeded it anyway"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "826a58b7e30c9f7bef6024db48a491edad74ce3b", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/trinodb/trino/commit/826a58b7e30c9f7bef6024db48a491edad74ce3b", "committedDate": "2021-01-11T18:47:58Z", "message": "Use AtomicIntegerFieldUpdater for LocalExchange PageReference"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9670b2e74e5ad2391608b6b0081c50fd73984c50", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/trinodb/trino/commit/9670b2e74e5ad2391608b6b0081c50fd73984c50", "committedDate": "2021-01-11T18:47:58Z", "message": "Reduce synchronization in LocalExchangeMemoryManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2826474ef67b143f91c424d9b25db2dc3373e93", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/trinodb/trino/commit/e2826474ef67b143f91c424d9b25db2dc3373e93", "committedDate": "2021-01-11T18:47:58Z", "message": "Improve LocalExchangeSource locking behaviors\n\nAdds an unsynchronized fast path to LocalExchangeSource#waitForReading()\nand LocalExchangeSource#isFinished(). Also removes an unnecessary \"lock\"\nObject which was obscuring this particular contention point in profiling\noriginally."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "019802cb8bf96c707dbf1ac909cbbfc0c49e5eb8", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/trinodb/trino/commit/019802cb8bf96c707dbf1ac909cbbfc0c49e5eb8", "committedDate": "2021-01-11T18:47:58Z", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "019802cb8bf96c707dbf1ac909cbbfc0c49e5eb8", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/trinodb/trino/commit/019802cb8bf96c707dbf1ac909cbbfc0c49e5eb8", "committedDate": "2021-01-11T18:47:58Z", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2112, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}