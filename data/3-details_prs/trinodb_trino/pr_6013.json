{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzNzM1OTU0", "number": 6013, "title": "Improve handling of NaN in comparisons", "bodyText": "This replaces the comparison operator into two operator, one that places unordered values before all ordered values, and one that places them after ordered values.  This removes the special handling for double and real, and makes complex types containing double or real work as expected.  For example greatest(row(NaN()), row(1.0) now evaluates to row(1.0) which matches the behavior of the unboxed values.  This is also used for ORDER BY where the unordered elements are placed between the ordered values and nulls, so with NULLS LAST you get normal values, NaNs, and then nulls.\nAlso as part of this I converted the Min/Max N aggregations to us the MinMaxCompare helper, so I could remove the reversed function from BlockPositionComparison, as that is too difficult to reason about once you have unordered elements.  This also brings these functions in line with other min/max functions and makes them compliant with declaring function dependencies .", "createdAt": "2020-11-19T07:22:55Z", "url": "https://github.com/trinodb/trino/pull/6013", "merged": true, "mergeCommit": {"oid": "f382a176760975fec51e89f3dc62060e20420f82"}, "closed": true, "closedAt": "2021-10-09T04:43:13Z", "author": {"login": "dain"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdeIDbggBqjQwMTc1NzA5OTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABfGMcI6gBqjU0Mzc1Njk4Mzk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NzA4NDQx", "url": "https://github.com/trinodb/trino/pull/6013#pullrequestreview-544708441", "createdAt": "2020-12-04T07:22:04Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNzoyMjowNFrOH_D9Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwODoxMTozOFrOH_FaHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4NzE3NA==", "bodyText": "Since these are for the COMPARISON_UNORDERED_LAST operator, should we name the function name to match as well?", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r535887174", "createdAt": "2020-12-04T07:22:04Z", "author": {"login": "erichwang"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/VarcharType.java", "diffHunk": "@@ -255,13 +255,13 @@ private static long xxHash64Operator(@BlockPosition Block block, @BlockIndex int\n         return block.hash(position, 0, block.getSliceLength(position));\n     }\n \n-    @ScalarOperator(COMPARISON)\n+    @ScalarOperator(COMPARISON_UNORDERED_LAST)\n     private static long comparisonOperator(Slice left, Slice right)\n     {\n         return left.compareTo(right);\n     }\n \n-    @ScalarOperator(COMPARISON)\n+    @ScalarOperator(COMPARISON_UNORDERED_LAST)\n     private static long comparisonOperator(@BlockPosition Block leftBlock, @BlockIndex int leftPosition, @BlockPosition Block rightBlock, @BlockIndex int rightPosition)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4ODg2MQ==", "bodyText": "Are we sure that we want to provide the opposite unordered value ordering if we can't find the right one defined? That seems to suggest that a caller requesting COMPARISON_UNORDERED_FIRST for a specific type is an optional preference and not a requirement?", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r535888861", "createdAt": "2020-12-04T07:26:05Z", "author": {"login": "erichwang"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/TypeOperators.java", "diffHunk": "@@ -245,11 +255,24 @@ private OperatorMethodHandle selectOperatorMethodHandleToAdapt(OperatorConventio\n                         return List.of(defaultIndeterminateOperator(operatorConvention.getType().getJavaType()));\n                     }\n                     return indeterminateOperators;\n-                case COMPARISON:\n+                case COMPARISON_UNORDERED_LAST:\n                     if (operatorConvention.getSortOrder().isPresent()) {\n                         return List.of(generateOrderingOperator(operatorConvention));\n                     }\n-                    return typeOperatorDeclaration.getComparisonOperators();\n+                    Collection<OperatorMethodHandle> comparisonUnorderedLastOperators = typeOperatorDeclaration.getComparisonUnorderedLastOperators();\n+                    if (comparisonUnorderedLastOperators.isEmpty()) {\n+                        return typeOperatorDeclaration.getComparisonUnorderedFirstOperators();\n+                    }\n+                    return comparisonUnorderedLastOperators;\n+                case COMPARISON_UNORDERED_FIRST:\n+                    if (operatorConvention.getSortOrder().isPresent()) {\n+                        return List.of(generateOrderingOperator(operatorConvention));\n+                    }\n+                    Collection<OperatorMethodHandle> comparisonUnorderedFirstOperators = typeOperatorDeclaration.getComparisonUnorderedFirstOperators();\n+                    if (comparisonUnorderedFirstOperators.isEmpty()) {\n+                        return typeOperatorDeclaration.getComparisonUnorderedLastOperators();\n+                    }\n+                    return comparisonUnorderedFirstOperators;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg5MTc4Nw==", "bodyText": "You can flatten this into a 3 line ternary:\nMethodHandle handle = isMin\n  ? typeOperators.getComparisonUnorderedLastOperator(type, convention)\n  : typeOperators.getComparisonUnorderedFirstOperator(type, convention);\n\nAlso in this context, I have a slight preference for \"min\" to be called \"isMin\"", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r535891787", "createdAt": "2020-12-04T07:32:50Z", "author": {"login": "erichwang"}, "path": "presto-main/src/main/java/io/prestosql/util/MinMaxCompare.java", "diffHunk": "@@ -52,6 +53,18 @@ public static MethodHandle getMinMaxCompare(FunctionDependencies dependencies, T\n         return filterReturnValue(handle, min ? MIN_FUNCTION : MAX_FUNCTION);\n     }\n \n+    public static MethodHandle getMinMaxCompare(TypeOperators typeOperators, Type type, InvocationConvention convention, boolean min)\n+    {\n+        MethodHandle handle;\n+        if (min) {\n+            handle = typeOperators.getComparisonUnorderedLastOperator(type, convention);\n+        }\n+        else {\n+            handle = typeOperators.getComparisonUnorderedFirstOperator(type, convention);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg5OTgwMQ==", "bodyText": "this comment was a bit confusing to read, until i realized you meant: \"this is a greater than operator, so we swap the object order and negate the result\"\nI think using the word \"negate\" here might be a bit more clear.", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r535899801", "createdAt": "2020-12-04T07:49:47Z", "author": {"login": "erichwang"}, "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/TypedKeyValueHeap.java", "diffHunk": "@@ -218,4 +220,16 @@ private void compactIfNecessary()\n         keyBlockBuilder = newHeapKeyBlockBuilder;\n         valueBlockBuilder = newHeapValueBlockBuilder;\n     }\n+\n+    private boolean keyGreaterThanOrEqual(Block leftBlock, int leftPosition, Block rightBlock, int rightPosition)\n+    {\n+        try {\n+            // this is a greater than operator, so we swap the object order and not the result", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkwNTkzOQ==", "bodyText": "Rather than hard coding this directly here, it feels a bit better to pull it out directly from the MinMaxNStateSerializer which should be the one defining this intermediate type. Maybe add a static method to MinMaxNStateSerializer to fetch this?", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r535905939", "createdAt": "2020-12-04T08:02:04Z", "author": {"login": "erichwang"}, "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AbstractMinMaxNAggregationFunction.java", "diffHunk": "@@ -84,31 +89,36 @@ protected AbstractMinMaxNAggregationFunction(String name, Function<Type, BlockPo\n                         AGGREGATE),\n                 true,\n                 false);\n-        requireNonNull(typeToComparison);\n-        this.typeToComparator = typeToComparison;\n+        this.min = min;\n     }\n \n     @Override\n     public List<TypeSignature> getIntermediateTypes(FunctionBinding functionBinding)\n     {\n         Type type = functionBinding.getTypeVariable(\"E\");\n-        return ImmutableList.of(new MinMaxNStateSerializer(typeToComparator.apply(type), type).getSerializedType().getTypeSignature());\n+        return ImmutableList.of(RowType.anonymous(ImmutableList.of(BIGINT, type)).getTypeSignature());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkxMDk0MA==", "bodyText": "So it's interesting that the nulls ordering is handled through an operator adapter, rather than a separate operator. Would it make sense to have the unordered first/last also be an InvocationConvention as well rather than a separate operator? Not sure if that breaks anything we are trying to do here, but it seems to more closely fit the usage where we have some basic behavior for types that may need to be specialized in some cases.", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r535910940", "createdAt": "2020-12-04T08:11:38Z", "author": {"login": "erichwang"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/TypeOperators.java", "diffHunk": "@@ -116,20 +117,29 @@ public MethodHandle getIndeterminateOperator(Type type, InvocationConvention cal\n         return getOperatorAdaptor(type, callingConvention, OperatorType.INDETERMINATE).get();\n     }\n \n-    public MethodHandle getComparisonOperator(Type type, InvocationConvention callingConvention)\n+    public MethodHandle getComparisonUnorderedLastOperator(Type type, InvocationConvention callingConvention)\n     {\n         if (!type.isOrderable()) {\n             throw new UnsupportedOperationException(type + \" is not orderable\");\n         }\n-        return getOperatorAdaptor(type, callingConvention, COMPARISON).get();\n+        return getOperatorAdaptor(type, callingConvention, COMPARISON_UNORDERED_LAST).get();\n+    }\n+\n+    public MethodHandle getComparisonUnorderedFirstOperator(Type type, InvocationConvention callingConvention)\n+    {\n+        if (!type.isOrderable()) {\n+            throw new UnsupportedOperationException(type + \" is not orderable\");\n+        }\n+        return getOperatorAdaptor(type, callingConvention, COMPARISON_UNORDERED_FIRST).get();\n     }\n \n     public MethodHandle getOrderingOperator(Type type, SortOrder sortOrder, InvocationConvention callingConvention)\n     {\n         if (!type.isOrderable()) {\n             throw new UnsupportedOperationException(type + \" is not orderable\");\n         }\n-        return getOperatorAdaptor(type, Optional.of(sortOrder), callingConvention, COMPARISON).get();\n+        OperatorType comparisonType = sortOrder.isNullsFirst() ? COMPARISON_UNORDERED_LAST : COMPARISON_UNORDERED_FIRST;\n+        return getOperatorAdaptor(type, Optional.of(sortOrder), callingConvention, comparisonType).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "986dc7637cae318364f7f8a72afcf4f2c70b4ca7", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/986dc7637cae318364f7f8a72afcf4f2c70b4ca7", "committedDate": "2021-09-04T02:29:40Z", "message": "Remove unused BlockPositionComparison.reversed()"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ4Mzk2NTgy", "url": "https://github.com/trinodb/trino/pull/6013#pullrequestreview-748396582", "createdAt": "2021-09-07T20:52:28Z", "commit": {"oid": "e1c0fa6ce7cda8c5c4a12a8ef26a6c7a4035b00f"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0wN1QyMDo1MjoyOFrOKfN4Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOS0wN1QyMjozMDoyN1rOKfSaKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMzgyMTg5MA==", "bodyText": "Add a comment explaining why this is ok.", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r703821890", "createdAt": "2021-09-07T20:52:28Z", "author": {"login": "martint"}, "path": "core/trino-spi/src/main/java/io/trino/spi/type/TypeOperators.java", "diffHunk": "@@ -245,11 +255,24 @@ private OperatorMethodHandle selectOperatorMethodHandleToAdapt(OperatorConventio\n                         return List.of(defaultIndeterminateOperator(operatorConvention.getType().getJavaType()));\n                     }\n                     return indeterminateOperators;\n-                case COMPARISON:\n+                case COMPARISON_UNORDERED_LAST:\n                     if (operatorConvention.getSortOrder().isPresent()) {\n                         return List.of(generateOrderingOperator(operatorConvention));\n                     }\n-                    return typeOperatorDeclaration.getComparisonOperators();\n+                    Collection<OperatorMethodHandle> comparisonUnorderedLastOperators = typeOperatorDeclaration.getComparisonUnorderedLastOperators();\n+                    if (comparisonUnorderedLastOperators.isEmpty()) {\n+                        return typeOperatorDeclaration.getComparisonUnorderedFirstOperators();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c0fa6ce7cda8c5c4a12a8ef26a6c7a4035b00f"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMzgyNDEzMA==", "bodyText": "In every place where the choice is arbitrary, we should have a comment so that future readers can understand why a choice was made. Or introduce a constant or method that makes the choice of a comparison that doesn't care whether unorderable values go explicit.", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r703824130", "createdAt": "2021-09-07T20:56:21Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/operator/SimplePagesHashStrategy.java", "diffHunk": "@@ -60,7 +60,7 @@ public SimplePagesHashStrategy(\n     {\n         this.types = ImmutableList.copyOf(requireNonNull(types, \"types is null\"));\n         this.comparisonOperators = types.stream()\n-                .map(type -> type.isOrderable() ? Optional.of(blockTypeOperators.getComparisonOperator(type)) : Optional.<BlockPositionComparison>empty())\n+                .map(type -> type.isOrderable() ? Optional.of(blockTypeOperators.getComparisonUnorderedLastOperator(type)) : Optional.<BlockPositionComparison>empty())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c0fa6ce7cda8c5c4a12a8ef26a6c7a4035b00f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMzg5NTEzMA==", "bodyText": "Add some documentation about what \"unordered last/first\" means", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r703895130", "createdAt": "2021-09-07T22:28:03Z", "author": {"login": "martint"}, "path": "core/trino-spi/src/main/java/io/trino/spi/function/OperatorType.java", "diffHunk": "@@ -22,7 +22,8 @@\n     MODULUS(\"%\", 2),\n     NEGATION(\"-\", 1),\n     EQUAL(\"=\", 2),\n-    COMPARISON(\"COMPARISON\", 2),\n+    COMPARISON_UNORDERED_LAST(\"COMPARISON_UNORDERED_LAST\", 2),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c0fa6ce7cda8c5c4a12a8ef26a6c7a4035b00f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMzg5NjEwNg==", "bodyText": "This operator for the boolean type doesn't really deal with unordered values (since there's no such a thing for booleans), so the fact that it's being declared as \"unordered last\" is a bit misleading.", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r703896106", "createdAt": "2021-09-07T22:30:27Z", "author": {"login": "martint"}, "path": "core/trino-spi/src/main/java/io/trino/spi/type/BooleanType.java", "diffHunk": "@@ -154,7 +154,7 @@ private static long xxHash64Operator(boolean value)\n         return value ? TRUE_XX_HASH : FALSE_XX_HASH;\n     }\n \n-    @ScalarOperator(COMPARISON)\n+    @ScalarOperator(COMPARISON_UNORDERED_LAST)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c0fa6ce7cda8c5c4a12a8ef26a6c7a4035b00f"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07bc1ff5b67c13e6acc83def7200c9664c7cb394", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/07bc1ff5b67c13e6acc83def7200c9664c7cb394", "committedDate": "2021-10-09T03:32:15Z", "message": "Split comparison into unordered first and last"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf1a0c254eccb61099bcffa397c9b928c5f151a2", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/cf1a0c254eccb61099bcffa397c9b928c5f151a2", "committedDate": "2021-10-09T03:32:17Z", "message": "Convert min/max by N aggregation to MinMaxCompare helper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "381c5e351ec5dfbfae8cc58ab0cf14fce99f8c81", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/381c5e351ec5dfbfae8cc58ab0cf14fce99f8c81", "committedDate": "2021-10-09T03:32:30Z", "message": "Convert min/max N aggregation to MinMaxCompare helper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41a2620ddd7dbd0e558dc3324d6be54b4d07b30e", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/41a2620ddd7dbd0e558dc3324d6be54b4d07b30e", "committedDate": "2021-10-09T03:32:31Z", "message": "Remove unused BlockPositionComparison.reversed()"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "986dc7637cae318364f7f8a72afcf4f2c70b4ca7", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/986dc7637cae318364f7f8a72afcf4f2c70b4ca7", "committedDate": "2021-09-04T02:29:40Z", "message": "Remove unused BlockPositionComparison.reversed()"}, "afterCommit": {"oid": "41a2620ddd7dbd0e558dc3324d6be54b4d07b30e", "author": {"user": {"login": "dain", "name": "Dain Sundstrom"}}, "url": "https://github.com/trinodb/trino/commit/41a2620ddd7dbd0e558dc3324d6be54b4d07b30e", "committedDate": "2021-10-09T03:32:31Z", "message": "Remove unused BlockPositionComparison.reversed()"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2642, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}