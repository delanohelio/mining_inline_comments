{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5NDExMzEy", "number": 6149, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMzoyNzo1NFrOFAPeeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMzoyNzo1NFrOFAPeeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1Nzk3ODgyOnYy", "diffSide": "RIGHT", "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/AbstractPrestoResultSet.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMzoyNzo1NFrOH-bonw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwODo0MDo0NlrOH_GYpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTIyNjUyNw==", "bodyText": "what about the \"before-epoch\" values. Are those handled correctly. Do we have tests coverage?", "url": "https://github.com/trinodb/trino/pull/6149#discussion_r535226527", "createdAt": "2020-12-03T13:27:54Z", "author": {"login": "losipiuk"}, "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/AbstractPrestoResultSet.java", "diffHunk": "@@ -1931,19 +1931,23 @@ private static Timestamp parseTimestamp(String value, Function<String, ZoneId> t\n         long epochSecond = LocalDateTime.of(year, month, day, hour, minute, second, 0)\n                 .atZone(zoneId)\n                 .toEpochSecond();\n-        long epochMillis = SECONDS.toMillis(epochSecond);\n \n-        Timestamp timestamp;\n-        if (epochMillis >= START_OF_MODERN_ERA) {\n-            timestamp = new Timestamp(epochMillis);\n-        }\n-        else {\n+        if (epochSecond < START_OF_MODERN_ERA_SECONDS) {\n             // slower path, but accurate for historical dates\n             GregorianCalendar calendar = new GregorianCalendar(year, month - 1, day, hour, minute, second);\n             calendar.setTimeZone(TimeZone.getTimeZone(zoneId));\n-            timestamp = new Timestamp(calendar.getTimeInMillis());\n+            verify(calendar.getTimeInMillis() % MILLISECONDS_PER_SECOND == 0, \"Fractional second when recalculating epochSecond of a historical date: %s\", value);\n+            epochSecond = calendar.getTimeInMillis() / MILLISECONDS_PER_SECOND;\n         }\n-        timestamp.setNanos((int) rescale(fractionValue, precision, 9));\n+\n+        int nanoOfSecond = (int) rescale(fractionValue, precision, 9);\n+        if (nanoOfSecond == NANOSECONDS_PER_SECOND) {\n+            epochSecond++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTIzNzE5NA==", "bodyText": "The fractionValue is positive number, so this is correct for negative timestamp values as well.", "url": "https://github.com/trinodb/trino/pull/6149#discussion_r535237194", "createdAt": "2020-12-03T13:43:21Z", "author": {"login": "findepi"}, "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/AbstractPrestoResultSet.java", "diffHunk": "@@ -1931,19 +1931,23 @@ private static Timestamp parseTimestamp(String value, Function<String, ZoneId> t\n         long epochSecond = LocalDateTime.of(year, month, day, hour, minute, second, 0)\n                 .atZone(zoneId)\n                 .toEpochSecond();\n-        long epochMillis = SECONDS.toMillis(epochSecond);\n \n-        Timestamp timestamp;\n-        if (epochMillis >= START_OF_MODERN_ERA) {\n-            timestamp = new Timestamp(epochMillis);\n-        }\n-        else {\n+        if (epochSecond < START_OF_MODERN_ERA_SECONDS) {\n             // slower path, but accurate for historical dates\n             GregorianCalendar calendar = new GregorianCalendar(year, month - 1, day, hour, minute, second);\n             calendar.setTimeZone(TimeZone.getTimeZone(zoneId));\n-            timestamp = new Timestamp(calendar.getTimeInMillis());\n+            verify(calendar.getTimeInMillis() % MILLISECONDS_PER_SECOND == 0, \"Fractional second when recalculating epochSecond of a historical date: %s\", value);\n+            epochSecond = calendar.getTimeInMillis() / MILLISECONDS_PER_SECOND;\n         }\n-        timestamp.setNanos((int) rescale(fractionValue, precision, 9));\n+\n+        int nanoOfSecond = (int) rescale(fractionValue, precision, 9);\n+        if (nanoOfSecond == NANOSECONDS_PER_SECOND) {\n+            epochSecond++;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTIyNjUyNw=="}, "originalCommit": null, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ5Nzc5Mw==", "bodyText": "i do not feel a negative test is needed here, but added anyway", "url": "https://github.com/trinodb/trino/pull/6149#discussion_r535497793", "createdAt": "2020-12-03T18:56:51Z", "author": {"login": "findepi"}, "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/AbstractPrestoResultSet.java", "diffHunk": "@@ -1931,19 +1931,23 @@ private static Timestamp parseTimestamp(String value, Function<String, ZoneId> t\n         long epochSecond = LocalDateTime.of(year, month, day, hour, minute, second, 0)\n                 .atZone(zoneId)\n                 .toEpochSecond();\n-        long epochMillis = SECONDS.toMillis(epochSecond);\n \n-        Timestamp timestamp;\n-        if (epochMillis >= START_OF_MODERN_ERA) {\n-            timestamp = new Timestamp(epochMillis);\n-        }\n-        else {\n+        if (epochSecond < START_OF_MODERN_ERA_SECONDS) {\n             // slower path, but accurate for historical dates\n             GregorianCalendar calendar = new GregorianCalendar(year, month - 1, day, hour, minute, second);\n             calendar.setTimeZone(TimeZone.getTimeZone(zoneId));\n-            timestamp = new Timestamp(calendar.getTimeInMillis());\n+            verify(calendar.getTimeInMillis() % MILLISECONDS_PER_SECOND == 0, \"Fractional second when recalculating epochSecond of a historical date: %s\", value);\n+            epochSecond = calendar.getTimeInMillis() / MILLISECONDS_PER_SECOND;\n         }\n-        timestamp.setNanos((int) rescale(fractionValue, precision, 9));\n+\n+        int nanoOfSecond = (int) rescale(fractionValue, precision, 9);\n+        if (nanoOfSecond == NANOSECONDS_PER_SECOND) {\n+            epochSecond++;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTIyNjUyNw=="}, "originalCommit": null, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkyNjk1MA==", "bodyText": "Yeah - I had some mind twist and for a moment thought that maybe for before-epoch we should subtract a second. WHich does not make sense at all :)\nThanks for test anyway.", "url": "https://github.com/trinodb/trino/pull/6149#discussion_r535926950", "createdAt": "2020-12-04T08:40:46Z", "author": {"login": "losipiuk"}, "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/AbstractPrestoResultSet.java", "diffHunk": "@@ -1931,19 +1931,23 @@ private static Timestamp parseTimestamp(String value, Function<String, ZoneId> t\n         long epochSecond = LocalDateTime.of(year, month, day, hour, minute, second, 0)\n                 .atZone(zoneId)\n                 .toEpochSecond();\n-        long epochMillis = SECONDS.toMillis(epochSecond);\n \n-        Timestamp timestamp;\n-        if (epochMillis >= START_OF_MODERN_ERA) {\n-            timestamp = new Timestamp(epochMillis);\n-        }\n-        else {\n+        if (epochSecond < START_OF_MODERN_ERA_SECONDS) {\n             // slower path, but accurate for historical dates\n             GregorianCalendar calendar = new GregorianCalendar(year, month - 1, day, hour, minute, second);\n             calendar.setTimeZone(TimeZone.getTimeZone(zoneId));\n-            timestamp = new Timestamp(calendar.getTimeInMillis());\n+            verify(calendar.getTimeInMillis() % MILLISECONDS_PER_SECOND == 0, \"Fractional second when recalculating epochSecond of a historical date: %s\", value);\n+            epochSecond = calendar.getTimeInMillis() / MILLISECONDS_PER_SECOND;\n         }\n-        timestamp.setNanos((int) rescale(fractionValue, precision, 9));\n+\n+        int nanoOfSecond = (int) rescale(fractionValue, precision, 9);\n+        if (nanoOfSecond == NANOSECONDS_PER_SECOND) {\n+            epochSecond++;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTIyNjUyNw=="}, "originalCommit": null, "originalPosition": 60}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4715, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}