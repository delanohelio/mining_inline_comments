{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyNjYxNzk0", "number": 4296, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwOToxMjoxNlrOEK0FsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjo1NTozMFrOELPevw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Nzc0NjQwOnYy", "diffSide": "RIGHT", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwOToxMjoxNlrOGsEYqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMTo1NTo1NlrOGsJl4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg2MjM3Ng==", "bodyText": "should we take all and then assert that the size of list is either 0 or 1", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448862376", "createdAt": "2020-07-02T09:12:16Z", "author": {"login": "losipiuk"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +183,58 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(\"Could not compact table, retries \" + event.getAttemptCount(), event.getFailure());\n+                })\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, timeout));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        // Hive's unix_timestamp() returns millis\n+        long beforeCompactionStart = (Long) onHive().executeQuery(\"SELECT unix_timestamp()\").row(0).get(0) * 1000;\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            // Since we disabled auto compaction for uniquely named table and every compaction is triggered in this test\n+            // we can expect that single compaction in given mode should complete before proceeding.\n+            Optional<Map<String, String>> startedCompaction = getTableCompactions(compactMode, tableName)\n+                    .filter(row -> !row.get(\"state\").equals(\"initiated\"))\n+                    .filter(row -> Long.parseLong(row.get(\"start time\")) >= beforeCompactionStart)\n+                    .findFirst();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk0NTMxNA==", "bodyText": "We are filtering compaction that started after beforeCompactionStart so there should be exactly [0;1] compaction in state {running,failed,completed,cleaning up}.", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448945314", "createdAt": "2020-07-02T11:51:19Z", "author": {"login": "wendigo"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +183,58 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(\"Could not compact table, retries \" + event.getAttemptCount(), event.getFailure());\n+                })\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, timeout));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        // Hive's unix_timestamp() returns millis\n+        long beforeCompactionStart = (Long) onHive().executeQuery(\"SELECT unix_timestamp()\").row(0).get(0) * 1000;\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            // Since we disabled auto compaction for uniquely named table and every compaction is triggered in this test\n+            // we can expect that single compaction in given mode should complete before proceeding.\n+            Optional<Map<String, String>> startedCompaction = getTableCompactions(compactMode, tableName)\n+                    .filter(row -> !row.get(\"state\").equals(\"initiated\"))\n+                    .filter(row -> Long.parseLong(row.get(\"start time\")) >= beforeCompactionStart)\n+                    .findFirst();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg2MjM3Ng=="}, "originalCommit": null, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk0NzY4MA==", "bodyText": "Yeah - I know. Just it would be nice to assert that. Not blindly take first.", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448947680", "createdAt": "2020-07-02T11:55:56Z", "author": {"login": "losipiuk"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +183,58 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(\"Could not compact table, retries \" + event.getAttemptCount(), event.getFailure());\n+                })\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, timeout));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        // Hive's unix_timestamp() returns millis\n+        long beforeCompactionStart = (Long) onHive().executeQuery(\"SELECT unix_timestamp()\").row(0).get(0) * 1000;\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            // Since we disabled auto compaction for uniquely named table and every compaction is triggered in this test\n+            // we can expect that single compaction in given mode should complete before proceeding.\n+            Optional<Map<String, String>> startedCompaction = getTableCompactions(compactMode, tableName)\n+                    .filter(row -> !row.get(\"state\").equals(\"initiated\"))\n+                    .filter(row -> Long.parseLong(row.get(\"start time\")) >= beforeCompactionStart)\n+                    .findFirst();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg2MjM3Ng=="}, "originalCommit": null, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Nzg1NjIxOnYy", "diffSide": "RIGHT", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwOTo0MzowMVrOGsFfUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwOTo0MzowMVrOGsFfUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg4MDQ2NQ==", "bodyText": "move to Try compacting table multiple times if compaction has failed", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448880465", "createdAt": "2020-07-02T09:43:01Z", "author": {"login": "losipiuk"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -183,13 +187,16 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n         Failsafe.with(\n                 new RetryPolicy<>()\n                         .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n                         .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n                 .onFailure(event -> {\n-                    throw new IllegalStateException(\"Could not compact table, retries \" + event.getAttemptCount(), event.getFailure());\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Nzg2MDY5OnYy", "diffSide": "RIGHT", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwOTo0NDoyMFrOGsFiRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMjowMzo0M1rOGsJ10A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg4MTIyMw==", "bodyText": "nit: i think logging at INFO is enough for that to show in CI logs. Higher severity is kinda not in-line with what testng does as even test-failure is logged as INFO.", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448881223", "createdAt": "2020-07-02T09:44:20Z", "author": {"login": "losipiuk"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -218,11 +227,13 @@ private static void tryCompactingTable(CompactionMode compactMode, String tableN\n                     .findFirst();\n \n             if (startedCompaction.isEmpty()) {\n+                log.warn(\"Compaction has not started yet\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5NTUzOA==", "bodyText": "Also, how many log lines do we produce per test run?\nHow many log lines per this test class?\nis there a risk of bloating the test output?\n(this could make viewing test logs in the browser harder)", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448895538", "createdAt": "2020-07-02T10:09:35Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -218,11 +227,13 @@ private static void tryCompactingTable(CompactionMode compactMode, String tableN\n                     .findFirst();\n \n             if (startedCompaction.isEmpty()) {\n+                log.warn(\"Compaction has not started yet\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg4MTIyMw=="}, "originalCommit": null, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk0NTczMA==", "bodyText": "@findepi not much, couple of extra lines per test run", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448945730", "createdAt": "2020-07-02T11:52:10Z", "author": {"login": "wendigo"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -218,11 +227,13 @@ private static void tryCompactingTable(CompactionMode compactMode, String tableN\n                     .findFirst();\n \n             if (startedCompaction.isEmpty()) {\n+                log.warn(\"Compaction has not started yet\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg4MTIyMw=="}, "originalCommit": null, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk1MTc2MA==", "bodyText": "I'll remove that log line. Does not bring much of a value", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448951760", "createdAt": "2020-07-02T12:03:43Z", "author": {"login": "wendigo"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -218,11 +227,13 @@ private static void tryCompactingTable(CompactionMode compactMode, String tableN\n                     .findFirst();\n \n             if (startedCompaction.isEmpty()) {\n+                log.warn(\"Compaction has not started yet\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg4MTIyMw=="}, "originalCommit": null, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzkyNTUyOnYy", "diffSide": "RIGHT", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDowMjozNlrOGsGLTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMjowMzoyMVrOGsJ1Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MTcyNg==", "bodyText": "why reduce?", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448891726", "createdAt": "2020-07-02T10:02:36Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -80,7 +83,7 @@ public void testReadFullAcid(boolean isPartitioned, BucketingType bucketingType)\n \n             // test minor compacted data read\n             onHive().executeQuery(\"INSERT INTO TABLE \" + tableName + hivePartitionString + \" VALUES (20, 3)\");\n-            compactTableAndWait(MINOR, tableName, hivePartitionString, Duration.valueOf(\"5m\"));\n+            compactTableAndWait(MINOR, tableName, hivePartitionString, Duration.valueOf(\"3m\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk0NTkxOQ==", "bodyText": "compaction takes around 20-30 seconds", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448945919", "createdAt": "2020-07-02T11:52:33Z", "author": {"login": "wendigo"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -80,7 +83,7 @@ public void testReadFullAcid(boolean isPartitioned, BucketingType bucketingType)\n \n             // test minor compacted data read\n             onHive().executeQuery(\"INSERT INTO TABLE \" + tableName + hivePartitionString + \" VALUES (20, 3)\");\n-            compactTableAndWait(MINOR, tableName, hivePartitionString, Duration.valueOf(\"5m\"));\n+            compactTableAndWait(MINOR, tableName, hivePartitionString, Duration.valueOf(\"3m\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MTcyNg=="}, "originalCommit": null, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk1MTU1NA==", "bodyText": "I could bound that in 1m", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448951554", "createdAt": "2020-07-02T12:03:21Z", "author": {"login": "wendigo"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -80,7 +83,7 @@ public void testReadFullAcid(boolean isPartitioned, BucketingType bucketingType)\n \n             // test minor compacted data read\n             onHive().executeQuery(\"INSERT INTO TABLE \" + tableName + hivePartitionString + \" VALUES (20, 3)\");\n-            compactTableAndWait(MINOR, tableName, hivePartitionString, Duration.valueOf(\"5m\"));\n+            compactTableAndWait(MINOR, tableName, hivePartitionString, Duration.valueOf(\"3m\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MTcyNg=="}, "originalCommit": null, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzkyNjczOnYy", "diffSide": "RIGHT", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDowMjo1NFrOGsGMBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMTo1Mjo0NVrOGsJfZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MTkwOQ==", "bodyText": "why reduce?", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448891909", "createdAt": "2020-07-02T10:02:54Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -125,7 +128,7 @@ public void testReadInsertOnly(boolean isPartitioned, BucketingType bucketingTyp\n             assertThat(query(selectFromOnePartitionsSql)).containsExactly(row(1), row(2));\n \n             // test minor compacted data read\n-            compactTableAndWait(MINOR, tableName, hivePartitionString, Duration.valueOf(\"5m\"));\n+            compactTableAndWait(MINOR, tableName, hivePartitionString, Duration.valueOf(\"3m\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk0NjAyMw==", "bodyText": "compaction takes around 20-30 seconds tops", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448946023", "createdAt": "2020-07-02T11:52:45Z", "author": {"login": "wendigo"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -125,7 +128,7 @@ public void testReadInsertOnly(boolean isPartitioned, BucketingType bucketingTyp\n             assertThat(query(selectFromOnePartitionsSql)).containsExactly(row(1), row(2));\n \n             // test minor compacted data read\n-            compactTableAndWait(MINOR, tableName, hivePartitionString, Duration.valueOf(\"5m\"));\n+            compactTableAndWait(MINOR, tableName, hivePartitionString, Duration.valueOf(\"3m\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MTkwOQ=="}, "originalCommit": null, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzkyNjkyOnYy", "diffSide": "RIGHT", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDowMjo1OFrOGsGMIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMTo1Mjo1NFrOGsJfvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MTkzOQ==", "bodyText": "why reduce?", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448891939", "createdAt": "2020-07-02T10:02:58Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -137,7 +140,7 @@ public void testReadInsertOnly(boolean isPartitioned, BucketingType bucketingTyp\n \n                 // test major compaction\n                 onHive().executeQuery(\"INSERT INTO TABLE \" + tableName + hivePartitionString + \" SELECT 4\");\n-                compactTableAndWait(MAJOR, tableName, hivePartitionString, Duration.valueOf(\"5m\"));\n+                compactTableAndWait(MAJOR, tableName, hivePartitionString, Duration.valueOf(\"3m\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk0NjEwOQ==", "bodyText": "compaction takes around 60-90 seconds on my local machine. On GHA i can see times around 20-30 seconds.", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448946109", "createdAt": "2020-07-02T11:52:54Z", "author": {"login": "wendigo"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -137,7 +140,7 @@ public void testReadInsertOnly(boolean isPartitioned, BucketingType bucketingTyp\n \n                 // test major compaction\n                 onHive().executeQuery(\"INSERT INTO TABLE \" + tableName + hivePartitionString + \" SELECT 4\");\n-                compactTableAndWait(MAJOR, tableName, hivePartitionString, Duration.valueOf(\"5m\"));\n+                compactTableAndWait(MAJOR, tableName, hivePartitionString, Duration.valueOf(\"3m\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MTkzOQ=="}, "originalCommit": null, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzkzMjYxOnYy", "diffSide": "RIGHT", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDowNDo0MVrOGsGP8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMTo1OTo1MlrOGsJtuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MjkxMw==", "bodyText": "is 90s enough? what's typical time it takes on CI?", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448892913", "createdAt": "2020-07-02T10:04:41Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +187,66 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"90s\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk0OTY4OA==", "bodyText": "~20-30 seconds on GHA:\nMINOR:\nPT34.838358153S\nPT30.844574209S\nPT29.576314653S\nPT31.662333431S\nPT32.115200646S\nPT32.932911889S\nPT33.893968919S\nPT29.637382943S\nPT3.384991089S\nPT6.792642366S\nPT3.277330249S\nPT5.378576046S\nPT6.337980713S\nPT4.7940377S\nPT5.384031019S\nPT5.475184157S\nPT22.72873679S\nPT22.162208904S\nPT20.25416786S\nPT28.962255175S\nPT20.369906495S\nPT20.36921996S\nPT25.370782901S\nPT21.177042401S\nPT9.567928944S\nPT8.48389606S\nPT8.445362006S\nPT10.563044679S\nPT10.54838043S\nPT6.392878269S\nPT5.366843937S\nPT5.411921104S\nPT22.50301294S\nPT21.209129968S\nPT23.706054989S\nPT28.109694148S\nPT19.413351215S\nPT24.236665704S\nPT23.882030693S\nPT25.434501155S\nPT3.470249565S\nPT4.540120403S\nPT1.292804921S\nPT5.375794887S\nPT5.472470425S\nPT8.654503554S\nPT6.425966434S\nPT6.408570237S\nPT31.023044459S\nPT24.549324998S\nPT28.908349388S\nPT28.839517233S\nPT25.091203992S\nPT24.729353252S\nPT24.728750437S\nPT21.367408401S\nPT2.676350984S\nPT6.433613682S\nPT6.800652414S\nPT5.835448164S\nPT5.359681922S\nPT6.436965362S\nPT4.375353378S\nPT5.390717631S\nPT25.930694265S\nPT22.174943204S\nPT24.251963387S\nPT18.069997819S\nPT21.13523818S\nPT23.32611175S\nPT21.484904459S\nPT25.693757204S\nPT6.402732506S\nPT10.529744223S\nPT6.753379343S\nPT7.800682509S\nPT6.482521267S\nPT6.772835094S\nPT10.488767769S\nPT7.495694755S\nPT25.937212248S\nPT18.261208232S\nPT29.76267732S\nPT24.525648134S\nPT24.777551591S\nPT29.647508626S\nPT20.467010381S\nPT24.691764453S\nPT3.290379089S\nPT3.306461549S\nPT5.762540276S\nPT1.651054048S\nPT1.289065089S\nPT3.740514872S\nPT5.395394702S\nPT5.374730286S\nPT29.95287575S\nPT19.395009562S\nPT24.513842613S\nPT29.871213374S\nPT19.313993858S\nPT26.507932332S\nPT24.39135613S\nPT24.543590796S\nPT8.915620955S\nPT8.524092371S\nPT7.836225487S\nPT6.478680622S\nPT5.522861469S\nPT5.800177765S\nPT6.480432644S\nPT5.85404512S\nPT25.69831208S\nPT20.698268428S\nPT29.107473986S\nPT27.216014399S\nPT27.000289095S\nPT24.051333288S\nPT29.803226643S\nPT28.584425318S\nPT3.316932009S\nPT7.48672612S\nPT5.401890444S\nPT5.630835785S\nPT5.355070023S\nPT5.42534251S\nPT4.353071406S\nPT6.516268257S\n\nMAJOR:\nPT35.491362277S\nPT27.040763797S\nPT35.31016765S\nPT36.626785954S\nPT36.653313653S\nPT35.163148959S\nPT39.572599944S\nPT35.06559024S\nPT23.29204194S\nPT22.201155344S\nPT26.901805328S\nPT28.072207201S\nPT26.915338869S\nPT25.916837113S\nPT23.751669051S\nPT25.962492511S\nPT22.141980261S\nPT17.177667464S\nPT26.184159558S\nPT25.635737023S\nPT26.720874883S\nPT26.237793639S\nPT27.078842519S\nPT26.006621506S\nPT21.297192303S\nPT22.391867352S\nPT25.822026411S\nPT25.632236496S\nPT21.89423386S\nPT26.494759405S\nPT25.551515357S\nPT25.109847925S\nPT22.197301312S\nPT22.376736998S\nPT22.586709815S\nPT26.586578429S\nPT27.712236441S\nPT26.955078837S\nPT22.787868064S\nPT30.576637061S\nPT21.46546404S\nPT17.084862765S\nPT25.873188493S\nPT26.453920875S\nPT25.179263581S\nPT29.925661268S\nPT26.802172906S\nPT26.463805746S\nPT22.791848413S\nPT22.346346515S\nPT28.961529438S\nPT26.614371831S\nPT26.398776127S\nPT26.839003049S\nPT22.701335815S\nPT26.656246586S\nPT22.696022337S\nPT21.443843753S\nPT29.963166471S\nPT25.706105172S\nPT26.305594413S\nPT27.54011601S\nPT25.764195308S\nPT24.92160194S", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448949688", "createdAt": "2020-07-02T11:59:52Z", "author": {"login": "wendigo"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +187,66 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"90s\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MjkxMw=="}, "originalCommit": null, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzkzNTU2OnYy", "diffSide": "RIGHT", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDowNToyOVrOGsGRxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDowNToyOVrOGsGRxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MzM4MA==", "bodyText": "The clocks are in sync (single host), so you can use System.currentTimeMillis", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448893380", "createdAt": "2020-07-02T10:05:29Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +187,66 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"90s\")));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        // Hive's unix_timestamp() returns millis\n+        long beforeCompactionStart = (Long) onHive().executeQuery(\"SELECT unix_timestamp()\").row(0).get(0) * 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzkzNzUyOnYy", "diffSide": "RIGHT", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDowNjowNVrOGsGS_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDowNjowNVrOGsGS_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MzY5NQ==", "bodyText": "add Thread.currentThread().interrupt();", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448893695", "createdAt": "2020-07-02T10:06:05Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +187,66 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"90s\")));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        // Hive's unix_timestamp() returns millis\n+        long beforeCompactionStart = (Long) onHive().executeQuery(\"SELECT unix_timestamp()\").row(0).get(0) * 1000;\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        log.info(\"Started compactions: %s\", getTableCompactions(compactMode, tableName).collect(toImmutableList()));\n+\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Nzk0MzkzOnYy", "diffSide": "RIGHT", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDowNzo1OFrOGsGW9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMjowODowNVrOGsJ-yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5NDcxMA==", "bodyText": "I'd rather have this two-step\n\nfind ours compaction (getTableCompactions + filter by time)\n\nit must exists and must be exactly one\n\n\n(sep stmt) verify it's \"state\" (\"initiated\" or sth else)", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448894710", "createdAt": "2020-07-02T10:07:58Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +187,66 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"90s\")));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        // Hive's unix_timestamp() returns millis\n+        long beforeCompactionStart = (Long) onHive().executeQuery(\"SELECT unix_timestamp()\").row(0).get(0) * 1000;\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        log.info(\"Started compactions: %s\", getTableCompactions(compactMode, tableName).collect(toImmutableList()));\n+\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            // Since we disabled auto compaction for uniquely named table and every compaction is triggered in this test\n+            // we can expect that single compaction in given mode should complete before proceeding.\n+            Optional<Map<String, String>> startedCompaction = getTableCompactions(compactMode, tableName)\n+                    .filter(row -> !row.get(\"state\").equals(\"initiated\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk1NDA1Nw==", "bodyText": "I know why I've filtered out initiated compactions as the first step. They don't have start time (it's ---)", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448954057", "createdAt": "2020-07-02T12:08:05Z", "author": {"login": "wendigo"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +187,66 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"90s\")));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        // Hive's unix_timestamp() returns millis\n+        long beforeCompactionStart = (Long) onHive().executeQuery(\"SELECT unix_timestamp()\").row(0).get(0) * 1000;\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        log.info(\"Started compactions: %s\", getTableCompactions(compactMode, tableName).collect(toImmutableList()));\n+\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            // Since we disabled auto compaction for uniquely named table and every compaction is triggered in this test\n+            // we can expect that single compaction in given mode should complete before proceeding.\n+            Optional<Map<String, String>> startedCompaction = getTableCompactions(compactMode, tableName)\n+                    .filter(row -> !row.get(\"state\").equals(\"initiated\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5NDcxMA=="}, "originalCommit": null, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Nzk0NTk1OnYy", "diffSide": "RIGHT", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDowODo0MVrOGsGYVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDowODo0MVrOGsGYVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5NTA2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            log.error(\"Compaction has timed out: %s\", startedCompaction.get());\n          \n          \n            \n                            log.error(\"Waiting for compaction has timed out: %s\", startedCompaction.get());", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448895062", "createdAt": "2020-07-02T10:08:41Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +187,66 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"90s\")));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        // Hive's unix_timestamp() returns millis\n+        long beforeCompactionStart = (Long) onHive().executeQuery(\"SELECT unix_timestamp()\").row(0).get(0) * 1000;\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        log.info(\"Started compactions: %s\", getTableCompactions(compactMode, tableName).collect(toImmutableList()));\n+\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            // Since we disabled auto compaction for uniquely named table and every compaction is triggered in this test\n+            // we can expect that single compaction in given mode should complete before proceeding.\n+            Optional<Map<String, String>> startedCompaction = getTableCompactions(compactMode, tableName)\n+                    .filter(row -> !row.get(\"state\").equals(\"initiated\"))\n+                    .filter(row -> Long.parseLong(row.get(\"start time\")) >= beforeCompactionStart)\n+                    .findFirst();\n \n-            verify(!compaction.get(\"state\").equals(\"failed\"), \"compaction has failed\");\n-            assertEquals(compaction.get(\"state\"), \"succeeded\");\n-        });\n+            if (startedCompaction.isEmpty()) {\n+                log.warn(\"Compaction has not started yet\");\n+                continue;\n+            }\n+\n+            String compactionState = startedCompaction.get().get(\"state\");\n+            if (compactionState.equals(\"failed\")) {\n+                log.error(\"Compaction has failed: %s\", startedCompaction.get());\n+                // This will retry compacting table\n+                throw new IllegalStateException(\"Compaction has failed\");\n+            }\n+\n+            if (compactionState.equals(\"succeeded\")) {\n+                return;\n+            }\n+\n+            if (Duration.nanosSince(loopStart).compareTo(timeout) > 0) {\n+                log.error(\"Compaction has timed out: %s\", startedCompaction.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjIzNDIzOnYy", "diffSide": "RIGHT", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjo1NTozMFrOGsviYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjo1NTozMFrOGsviYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU2OTM3OQ==", "bodyText": "nit: getOnlyElement()", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r449569379", "createdAt": "2020-07-03T12:55:30Z", "author": {"login": "losipiuk"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,25 +189,82 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"60s\")));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        long beforeCompactionStart = Instant.now().getEpochSecond();\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        log.info(\"Started compactions: %s\", getTableCompactions(compactMode, tableName, OptionalLong.empty()));\n \n-            verify(!compaction.get(\"state\").equals(\"failed\"), \"compaction has failed\");\n-            assertEquals(compaction.get(\"state\"), \"succeeded\");\n-        });\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new RuntimeException(e);\n+            }\n+\n+            // Since we disabled auto compaction for uniquely named table and every compaction is triggered in this test\n+            // we can expect that single compaction in given mode should complete before proceeding.\n+            List<Map<String, String>> startedCompactions = getTableCompactions(compactMode, tableName, OptionalLong.of(beforeCompactionStart));\n+            verify(startedCompactions.size() < 2, \"Expected at most 1 compaction\");\n+\n+            if (startedCompactions.isEmpty()) {\n+                log.info(\"Compaction has not started yet\");\n+                continue;\n+            }\n+\n+            String compactionState = startedCompactions.get(0).get(\"state\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db95f5cc55cd8f78ecde3480f9d80d1c50ee7851"}, "originalPosition": 146}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4035, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}