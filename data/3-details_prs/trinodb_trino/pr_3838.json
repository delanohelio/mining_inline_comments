{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyMzM1Nzk5", "number": 3838, "title": "Fix Oracle connector data type mappings", "bodyText": "", "createdAt": "2020-05-23T22:38:48Z", "url": "https://github.com/trinodb/trino/pull/3838", "merged": true, "mergeCommit": {"oid": "2fad53f05f32707abc54b6b384921365f1e87966"}, "closed": true, "closedAt": "2020-05-28T17:12:50Z", "author": {"login": "losipiuk"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcksQTPgBqjMzNjk0NDMyNzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABclvRaLABqjMzODMyNTczNjk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4MjAyODI3", "url": "https://github.com/trinodb/trino/pull/3838#pullrequestreview-418202827", "createdAt": "2020-05-26T11:22:25Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMToyMjoyNVrOGaZ2fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMToyMjoyNVrOGaZ2fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDMzOTcxMA==", "bodyText": "why 3.. oracle default is 6.\nwe shouldn't carry a limitation of presto timestamp to oracle", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r430339710", "createdAt": "2020-05-26T11:22:25Z", "author": {"login": "eskabetxe"}, "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -215,10 +213,10 @@ public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n             return WriteMapping.longMapping(\"number(19,0)\", bigintWriteFunction());\n         }\n         if (type instanceof TimestampType) {\n-            return WriteMapping.longMapping(format(\"timestamp(%s)\", timestampDefaultPrecision), timestampWriteFunction(session));\n+            return WriteMapping.longMapping(\"timestamp(3)\", timestampWriteFunction(session));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4MjA2MzA3", "url": "https://github.com/trinodb/trino/pull/3838#pullrequestreview-418206307", "createdAt": "2020-05-26T11:27:51Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMToyNzo1MVrOGaaA_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMToyNzo1MVrOGaaA_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM0MjM5OA==", "bodyText": "the test of negative scale will be moved to another side?", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r430342398", "createdAt": "2020-05-26T11:27:51Z", "author": {"login": "eskabetxe"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -141,9 +141,9 @@ public void testBooleanType()\n     @Test\n     public void testSpecialNumberFormats()\n     {\n-        oracleServer.execute(\"CREATE TABLE test (num1 number, num2 number(*,-2))\");\n-        oracleServer.execute(\"INSERT INTO test VALUES (12345678901234567890.12345678901234567890123456789012345678, 1234567890.123)\");\n-        assertQuery(\"SELECT * FROM test\", \"VALUES (12345678901234567890.1234567890, 1234567900.0000000000)\");\n+        oracleServer.execute(\"CREATE TABLE test (num1 number)\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4MjEyNjkz", "url": "https://github.com/trinodb/trino/pull/3838#pullrequestreview-418212693", "createdAt": "2020-05-26T11:38:05Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMTozODowNVrOGaaUCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMTozODowNVrOGaaUCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM0NzI3NA==", "bodyText": "starting on oracle 12c varchar could be increased from 4000 to 32767 bytes (any value between) using Extended Data Types", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r430347274", "createdAt": "2020-05-26T11:38:05Z", "author": {"login": "eskabetxe"}, "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleConfig.java", "diffHunk": "@@ -68,17 +67,4 @@ public OracleConfig setNumberRoundingMode(RoundingMode numberRoundingMode)\n         this.numberRoundingMode = numberRoundingMode;\n         return this;\n     }\n-\n-    @Min(4000)\n-    public int getVarcharMaxSize()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NTgzMDgz", "url": "https://github.com/trinodb/trino/pull/3838#pullrequestreview-419583083", "createdAt": "2020-05-27T20:28:35Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMDoyODozNVrOGbb7ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwMDowNDoxMlrOGbhSvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQyMjM3MQ==", "bodyText": "This only leaves 36^5 = 60466176 maximum values. Also, the choice of this value seems arbitrary. We should probably have a maximum length and validate that the prefix+suffix is under the length. But we can follow up on that.", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431422371", "createdAt": "2020-05-27T20:28:35Z", "author": {"login": "electrum"}, "path": "presto-testing/src/main/java/io/prestosql/testing/sql/TestTable.java", "diffHunk": "@@ -27,7 +27,7 @@\n         implements AutoCloseable\n {\n     private static final SecureRandom random = new SecureRandom();\n-    private static final int RANDOM_SUFFIX_LENGTH = 12;\n+    private static final int RANDOM_SUFFIX_LENGTH = 5;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQyNDUyNw==", "bodyText": "Predicate pushdown seems like an unrelated issue. It should work correctly regardless of the precision in Presto vs Oracle. We can't depend on the types matching.\nBut removing precision here and using timestamp(3) is the right behavior as that will continue working after we support precision for timestamp in Presto (timestamp will likely mean timestamp(3) for compatibility reasons).", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431424527", "createdAt": "2020-05-27T20:32:50Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -215,10 +213,10 @@ public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n             return WriteMapping.longMapping(\"number(19,0)\", bigintWriteFunction());\n         }\n         if (type instanceof TimestampType) {\n-            return WriteMapping.longMapping(format(\"timestamp(%s)\", timestampDefaultPrecision), timestampWriteFunction(session));\n+            return WriteMapping.longMapping(\"timestamp(3)\", timestampWriteFunction(session));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDMzOTcxMA=="}, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQyNzA3OA==", "bodyText": "Use static import (that already exists)", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431427078", "createdAt": "2020-05-27T20:37:41Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleDistributedQueries.java", "diffHunk": "@@ -115,7 +116,7 @@ protected TestTable createTableWithDefaultColumns()\n     {\n         return new TestTable(\n                 oracleServer::execute,\n-                \"tpch.table\",\n+                String.format(\"%s.table\", TEST_SCHEMA),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4Nzc4Mw==", "bodyText": "Can we make this calendar instance a constant? They are mutable, but this should be read-only.", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431487783", "createdAt": "2020-05-27T22:54:29Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -190,10 +212,77 @@ public void createSchema(JdbcIdentity identity, String schemaName)\n                 return Optional.of(varcharColumnMapping(createVarcharType(columnSize)));\n             case Types.VARCHAR:\n                 return Optional.of(varcharColumnMapping(createVarcharType(columnSize)));\n+            // This mapping covers both DATE and TIMESTAMP, as Oracle's DATE has second precision.\n+            case OracleTypes.TIMESTAMP:\n+                return Optional.of(oracleTimestampColumnMapping(session));\n+            case OracleTypes.TIMESTAMPTZ:\n+                return Optional.of(oracleTimestampWithTimeZoneColumnMapping());\n         }\n         return super.toPrestoType(session, connection, typeHandle);\n     }\n \n+    public static LongWriteFunction oracleDateWriteFunction()\n+    {\n+        return (statement, index, value) -> {\n+            long utcMillis = DAYS.toMillis(value);\n+            ZonedDateTime date = Instant.ofEpochMilli(utcMillis).atZone(ZoneOffset.UTC);\n+            // because of how JDBC works with dates we need to use the ZonedDataTime object and not a LocalDateTime\n+            statement.setObject(index, date);\n+        };\n+    }\n+\n+    public static LongWriteFunction oracleTimestampWriteFunction(ConnectorSession session)\n+    {\n+        if (session.isLegacyTimestamp()) {\n+            return (statement, index, utcMillis) -> {\n+                long dateTimeAsUtcMillis = Instant.ofEpochMilli(utcMillis)\n+                        .atZone(ZoneId.of(session.getTimeZoneKey().getId()))\n+                        .withZoneSameLocal(ZoneOffset.UTC)\n+                        .toInstant().toEpochMilli();\n+                statement.setObject(index, new oracle.sql.TIMESTAMP(new Timestamp(dateTimeAsUtcMillis), Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODM3Ng==", "bodyText": "This seems repeated for no reason", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431488376", "createdAt": "2020-05-27T22:56:10Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/OracleDataTypes.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.oracle;\n+\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.testing.datatype.DataType;\n+\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE;\n+import static java.lang.String.format;\n+\n+public final class OracleDataTypes\n+{\n+    private OracleDataTypes() {}\n+\n+    /* Datetime types */\n+\n+    public static DataType<LocalDate> dateDataType()\n+    {\n+        return dataType(\"DATE\", TimestampType.TIMESTAMP,\n+                DateTimeFormatter.ofPattern(\"'DATE '''yyyy-MM-dd''\")::format,\n+                LocalDate::atStartOfDay);\n+    }\n+\n+    public static DataType<ZonedDateTime> prestoTimestampWithTimeZoneDataType()\n+    {\n+        return dataType(\n+                \"timestamp with time zone\",\n+                TIMESTAMP_WITH_TIME_ZONE,\n+                DateTimeFormatter.ofPattern(\"'TIMESTAMP '''yyyy-MM-dd HH:mm:ss.SSS VV''\")::format,\n+                OracleDataTypes::normalizeForOracleStorage);\n+    }\n+\n+    @SuppressWarnings(\"MisusedWeekYear\")\n+    public static DataType<ZonedDateTime> oracleTimestamp3TimeZoneDataType()\n+    {\n+        return dataType(\n+                \"TIMESTAMP(3) WITH TIME ZONE\",\n+                TIMESTAMP_WITH_TIME_ZONE,\n+                zonedDateTime -> {\n+                    String zoneId = zonedDateTime.getZone().getId();\n+                    if (zoneId.equals(\"Z\")) {\n+                        zoneId = \"UTC\";\n+                    }\n+                    return format(\n+                            \"from_tz(TIMESTAMP '%s', '%s')\",\n+                            DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss.SSSSSSSSS\").format(zonedDateTime.toLocalDateTime()),\n+                            zoneId);\n+                },\n+                OracleDataTypes::normalizeForOracleStorage);\n+    }\n+\n+    private static ZonedDateTime normalizeForOracleStorage(ZonedDateTime zonedDateTime)\n+    {\n+        // Oracle conflates UTC-equivalent zones to UTC.\n+        String zoneId = zonedDateTime.getZone().getId();\n+        if (zoneId.equals(\"Z\")) {\n+            // Oracle conflates UTC-equivalent zones to UTC.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODQ3OA==", "bodyText": "Wrap all arguments or none", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431488478", "createdAt": "2020-05-27T22:56:24Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/OracleDataTypes.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.oracle;\n+\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.testing.datatype.DataType;\n+\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE;\n+import static java.lang.String.format;\n+\n+public final class OracleDataTypes\n+{\n+    private OracleDataTypes() {}\n+\n+    /* Datetime types */\n+\n+    public static DataType<LocalDate> dateDataType()\n+    {\n+        return dataType(\"DATE\", TimestampType.TIMESTAMP,\n+                DateTimeFormatter.ofPattern(\"'DATE '''yyyy-MM-dd''\")::format,\n+                LocalDate::atStartOfDay);\n+    }\n+\n+    public static DataType<ZonedDateTime> prestoTimestampWithTimeZoneDataType()\n+    {\n+        return dataType(\n+                \"timestamp with time zone\",\n+                TIMESTAMP_WITH_TIME_ZONE,\n+                DateTimeFormatter.ofPattern(\"'TIMESTAMP '''yyyy-MM-dd HH:mm:ss.SSS VV''\")::format,\n+                OracleDataTypes::normalizeForOracleStorage);\n+    }\n+\n+    @SuppressWarnings(\"MisusedWeekYear\")\n+    public static DataType<ZonedDateTime> oracleTimestamp3TimeZoneDataType()\n+    {\n+        return dataType(\n+                \"TIMESTAMP(3) WITH TIME ZONE\",\n+                TIMESTAMP_WITH_TIME_ZONE,\n+                zonedDateTime -> {\n+                    String zoneId = zonedDateTime.getZone().getId();\n+                    if (zoneId.equals(\"Z\")) {\n+                        zoneId = \"UTC\";\n+                    }\n+                    return format(\n+                            \"from_tz(TIMESTAMP '%s', '%s')\",\n+                            DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss.SSSSSSSSS\").format(zonedDateTime.toLocalDateTime()),\n+                            zoneId);\n+                },\n+                OracleDataTypes::normalizeForOracleStorage);\n+    }\n+\n+    private static ZonedDateTime normalizeForOracleStorage(ZonedDateTime zonedDateTime)\n+    {\n+        // Oracle conflates UTC-equivalent zones to UTC.\n+        String zoneId = zonedDateTime.getZone().getId();\n+        if (zoneId.equals(\"Z\")) {\n+            // Oracle conflates UTC-equivalent zones to UTC.\n+            return zonedDateTime.withZoneSameInstant(ZoneId.of(\"UTC\"));\n+        }\n+        return zonedDateTime;\n+    }\n+\n+    /* Utility */\n+\n+    private static <T> DataType<T> dataType(String insertType, Type prestoResultType,\n+            Function<T, String> toLiteral, Function<T, ?> toPrestoQueryResult)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODc1OQ==", "bodyText": "Nit: s -> value", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431488759", "createdAt": "2020-05-27T22:57:15Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -153,12 +204,322 @@ public void testNumericTypes()\n                 queryResult);\n     }\n \n-    public static DataType<LocalDate> dateOracleType()\n+    /* Datetime tests */\n+\n+    @Test\n+    public void testLegacyDateMapping()\n     {\n-        return DataType.dataType(\n-                \"date\",\n-                TimestampType.TIMESTAMP,\n-                DateTimeFormatter.ofPattern(\"'DATE '''yyyy-MM-dd''\")::format,\n-                LocalDate::atStartOfDay);\n+        legacyDateTests(s -> prestoCreateAsSelect(\"l_date_\" + s));\n+    }\n+\n+    @Test\n+    public void testLegacyDateReadMapping()\n+    {\n+        legacyDateTests(s -> oracleCreateAndInsert(\"l_read_date_\" + s));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4OTAwMg==", "bodyText": "This is not a Javadoc comment, so don't use Javadoc tags", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431489002", "createdAt": "2020-05-27T22:57:50Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -153,12 +204,322 @@ public void testNumericTypes()\n                 queryResult);\n     }\n \n-    public static DataType<LocalDate> dateOracleType()\n+    /* Datetime tests */\n+\n+    @Test\n+    public void testLegacyDateMapping()\n     {\n-        return DataType.dataType(\n-                \"date\",\n-                TimestampType.TIMESTAMP,\n-                DateTimeFormatter.ofPattern(\"'DATE '''yyyy-MM-dd''\")::format,\n-                LocalDate::atStartOfDay);\n+        legacyDateTests(s -> prestoCreateAsSelect(\"l_date_\" + s));\n+    }\n+\n+    @Test\n+    public void testLegacyDateReadMapping()\n+    {\n+        legacyDateTests(s -> oracleCreateAndInsert(\"l_read_date_\" + s));\n+    }\n+\n+    private void legacyDateTests(Function<String, DataSetup> dataSetup)\n+    {\n+        Map<String, TimeZoneKey> zonesBySqlName = ImmutableMap.of(\n+                \"UTC\", UTC_KEY,\n+                \"JVM\", getTimeZoneKey(ZoneId.systemDefault().getId()),\n+                \"other\", getTimeZoneKey(ZoneId.of(\"Europe/Vilnius\").getId()));\n+\n+        for (Map.Entry<String, TimeZoneKey> zone : zonesBySqlName.entrySet()) {\n+            runLegacyTimestampTestInZone(\n+                    dataSetup.apply(zone.getKey()),\n+                    zone.getValue().getId(),\n+                    legacyDateTests());\n+        }\n+    }\n+\n+    /*\n+     * TODO These tests should be executed in {@link io.prestosql.Session Sessions}", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4OTA1OA==", "bodyText": "Same", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431489058", "createdAt": "2020-05-27T22:58:00Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -153,12 +204,322 @@ public void testNumericTypes()\n                 queryResult);\n     }\n \n-    public static DataType<LocalDate> dateOracleType()\n+    /* Datetime tests */\n+\n+    @Test\n+    public void testLegacyDateMapping()\n     {\n-        return DataType.dataType(\n-                \"date\",\n-                TimestampType.TIMESTAMP,\n-                DateTimeFormatter.ofPattern(\"'DATE '''yyyy-MM-dd''\")::format,\n-                LocalDate::atStartOfDay);\n+        legacyDateTests(s -> prestoCreateAsSelect(\"l_date_\" + s));\n+    }\n+\n+    @Test\n+    public void testLegacyDateReadMapping()\n+    {\n+        legacyDateTests(s -> oracleCreateAndInsert(\"l_read_date_\" + s));\n+    }\n+\n+    private void legacyDateTests(Function<String, DataSetup> dataSetup)\n+    {\n+        Map<String, TimeZoneKey> zonesBySqlName = ImmutableMap.of(\n+                \"UTC\", UTC_KEY,\n+                \"JVM\", getTimeZoneKey(ZoneId.systemDefault().getId()),\n+                \"other\", getTimeZoneKey(ZoneId.of(\"Europe/Vilnius\").getId()));\n+\n+        for (Map.Entry<String, TimeZoneKey> zone : zonesBySqlName.entrySet()) {\n+            runLegacyTimestampTestInZone(\n+                    dataSetup.apply(zone.getKey()),\n+                    zone.getValue().getId(),\n+                    legacyDateTests());\n+        }\n+    }\n+\n+    /*\n+     * TODO These tests should be executed in {@link io.prestosql.Session Sessions}\n+     * configured for the JVM time zone, Europe/Vilnius, and UTC.\n+     */\n+    private static DataTypeTest legacyDateTests()\n+    {\n+        ZoneId someZone = ZoneId.of(\"Europe/Vilnius\");\n+\n+        LocalDate dateOfLocalTimeChangeBackwardAtMidnightInSomeZone =\n+                LocalDate.of(1983, 10, 1);\n+\n+        verify(someZone.getRules().getValidOffsets(\n+                dateOfLocalTimeChangeBackwardAtMidnightInSomeZone\n+                        .atStartOfDay().minusMinutes(1)).size() == 2);\n+\n+        return DataTypeTest.create()\n+                // before epoch\n+                .addRoundTrip(dateDataType(), LocalDate.of(1952, 4, 3))\n+                .addRoundTrip(dateDataType(), LocalDate.of(1970, 2, 3))\n+                // summer on northern hemisphere (possible DST)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 7, 1))\n+                // winter on northern hemisphere\n+                // (possible DST on southern hemisphere)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 1, 1))\n+                .addRoundTrip(dateDataType(),\n+                        dateOfLocalTimeChangeBackwardAtMidnightInSomeZone);\n+    }\n+\n+    @Test\n+    public void testNonLegacyDateMapping()\n+    {\n+        nonLegacyDateTests(s -> prestoCreateAsSelect(\"nl_date_\" + s));\n+    }\n+\n+    @Test\n+    public void testNonLegacyDateReadMapping()\n+    {\n+        nonLegacyDateTests(s -> oracleCreateAndInsert(\"nl_read_date_\" + s));\n+    }\n+\n+    void nonLegacyDateTests(Function<String, DataSetup> dataSetup)\n+    {\n+        Map<String, TimeZoneKey> zonesBySqlName = ImmutableMap.of(\n+                \"UTC\", UTC_KEY,\n+                \"JVM\", getTimeZoneKey(ZoneId.systemDefault().getId()),\n+                \"other\", getTimeZoneKey(ZoneId.of(\"Europe/Vilnius\").getId()));\n+\n+        for (Map.Entry<String, TimeZoneKey> zone : zonesBySqlName.entrySet()) {\n+            runNonLegacyTimestampTestInZone(\n+                    dataSetup.apply(zone.getKey()),\n+                    zone.getValue().getId(),\n+                    nonLegacyDateTests());\n+        }\n+    }\n+\n+    /*\n+     * TODO These tests should be executed in {@link io.prestosql.Session Sessions}", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4OTM4MQ==", "bodyText": "Why? Add a TODO comment or remove these", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431489381", "createdAt": "2020-05-27T22:59:03Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -153,12 +204,322 @@ public void testNumericTypes()\n                 queryResult);\n     }\n \n-    public static DataType<LocalDate> dateOracleType()\n+    /* Datetime tests */\n+\n+    @Test\n+    public void testLegacyDateMapping()\n     {\n-        return DataType.dataType(\n-                \"date\",\n-                TimestampType.TIMESTAMP,\n-                DateTimeFormatter.ofPattern(\"'DATE '''yyyy-MM-dd''\")::format,\n-                LocalDate::atStartOfDay);\n+        legacyDateTests(s -> prestoCreateAsSelect(\"l_date_\" + s));\n+    }\n+\n+    @Test\n+    public void testLegacyDateReadMapping()\n+    {\n+        legacyDateTests(s -> oracleCreateAndInsert(\"l_read_date_\" + s));\n+    }\n+\n+    private void legacyDateTests(Function<String, DataSetup> dataSetup)\n+    {\n+        Map<String, TimeZoneKey> zonesBySqlName = ImmutableMap.of(\n+                \"UTC\", UTC_KEY,\n+                \"JVM\", getTimeZoneKey(ZoneId.systemDefault().getId()),\n+                \"other\", getTimeZoneKey(ZoneId.of(\"Europe/Vilnius\").getId()));\n+\n+        for (Map.Entry<String, TimeZoneKey> zone : zonesBySqlName.entrySet()) {\n+            runLegacyTimestampTestInZone(\n+                    dataSetup.apply(zone.getKey()),\n+                    zone.getValue().getId(),\n+                    legacyDateTests());\n+        }\n+    }\n+\n+    /*\n+     * TODO These tests should be executed in {@link io.prestosql.Session Sessions}\n+     * configured for the JVM time zone, Europe/Vilnius, and UTC.\n+     */\n+    private static DataTypeTest legacyDateTests()\n+    {\n+        ZoneId someZone = ZoneId.of(\"Europe/Vilnius\");\n+\n+        LocalDate dateOfLocalTimeChangeBackwardAtMidnightInSomeZone =\n+                LocalDate.of(1983, 10, 1);\n+\n+        verify(someZone.getRules().getValidOffsets(\n+                dateOfLocalTimeChangeBackwardAtMidnightInSomeZone\n+                        .atStartOfDay().minusMinutes(1)).size() == 2);\n+\n+        return DataTypeTest.create()\n+                // before epoch\n+                .addRoundTrip(dateDataType(), LocalDate.of(1952, 4, 3))\n+                .addRoundTrip(dateDataType(), LocalDate.of(1970, 2, 3))\n+                // summer on northern hemisphere (possible DST)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 7, 1))\n+                // winter on northern hemisphere\n+                // (possible DST on southern hemisphere)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 1, 1))\n+                .addRoundTrip(dateDataType(),\n+                        dateOfLocalTimeChangeBackwardAtMidnightInSomeZone);\n+    }\n+\n+    @Test\n+    public void testNonLegacyDateMapping()\n+    {\n+        nonLegacyDateTests(s -> prestoCreateAsSelect(\"nl_date_\" + s));\n+    }\n+\n+    @Test\n+    public void testNonLegacyDateReadMapping()\n+    {\n+        nonLegacyDateTests(s -> oracleCreateAndInsert(\"nl_read_date_\" + s));\n+    }\n+\n+    void nonLegacyDateTests(Function<String, DataSetup> dataSetup)\n+    {\n+        Map<String, TimeZoneKey> zonesBySqlName = ImmutableMap.of(\n+                \"UTC\", UTC_KEY,\n+                \"JVM\", getTimeZoneKey(ZoneId.systemDefault().getId()),\n+                \"other\", getTimeZoneKey(ZoneId.of(\"Europe/Vilnius\").getId()));\n+\n+        for (Map.Entry<String, TimeZoneKey> zone : zonesBySqlName.entrySet()) {\n+            runNonLegacyTimestampTestInZone(\n+                    dataSetup.apply(zone.getKey()),\n+                    zone.getValue().getId(),\n+                    nonLegacyDateTests());\n+        }\n+    }\n+\n+    /*\n+     * TODO These tests should be executed in {@link io.prestosql.Session Sessions}\n+     * configured for the JVM time zone, Europe/Vilnius, and UTC.\n+     */\n+    private DataTypeTest nonLegacyDateTests()\n+    {\n+        // Note: these test cases are duplicates of those for PostgreSQL and MySQL.\n+\n+        LocalDate dateOfLocalTimeChangeForwardAtMidnightInJvmZone =\n+                LocalDate.of(1970, 1, 1);\n+\n+        verify(jvmZone.getRules().getValidOffsets(\n+                dateOfLocalTimeChangeForwardAtMidnightInJvmZone\n+                        .atStartOfDay()).isEmpty());\n+\n+        ZoneId someZone = ZoneId.of(\"Europe/Vilnius\");\n+\n+        LocalDate dateOfLocalTimeChangeForwardAtMidnightInSomeZone =\n+                LocalDate.of(1983, 4, 1);\n+\n+        verify(someZone.getRules().getValidOffsets(\n+                dateOfLocalTimeChangeForwardAtMidnightInSomeZone\n+                        .atStartOfDay()).isEmpty());\n+\n+        LocalDate dateOfLocalTimeChangeBackwardAtMidnightInSomeZone =\n+                LocalDate.of(1983, 10, 1);\n+\n+        verify(someZone.getRules().getValidOffsets(\n+                dateOfLocalTimeChangeBackwardAtMidnightInSomeZone\n+                        .atStartOfDay().minusMinutes(1)).size() == 2);\n+\n+        return DataTypeTest.create()\n+                // before epoch\n+                .addRoundTrip(dateDataType(), LocalDate.of(1952, 4, 3))\n+                .addRoundTrip(dateDataType(), LocalDate.of(1970, 1, 1))\n+                .addRoundTrip(dateDataType(), LocalDate.of(1970, 2, 3))\n+                // summer on northern hemisphere (possible DST)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 7, 1))\n+                // winter on northern hemisphere\n+                // (possible DST on southern hemisphere)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 1, 1))\n+                .addRoundTrip(dateDataType(),\n+                        dateOfLocalTimeChangeForwardAtMidnightInJvmZone)\n+                .addRoundTrip(dateDataType(),\n+                        dateOfLocalTimeChangeForwardAtMidnightInSomeZone)\n+                .addRoundTrip(dateDataType(),\n+                        dateOfLocalTimeChangeBackwardAtMidnightInSomeZone);\n+    }\n+\n+    @Test(dataProvider = \"testTimestampDataProvider\")\n+    public void testTimestamp(boolean legacyTimestamp, boolean insertWithPresto, ZoneId sessionZone)\n+    {\n+        // using two non-JVM zones so that we don't need to worry what Oracle system zone is\n+        DataTypeTest tests = DataTypeTest.create()\n+                .addRoundTrip(timestampDataType(), beforeEpoch)\n+                .addRoundTrip(timestampDataType(), afterEpoch)\n+                .addRoundTrip(timestampDataType(), timeDoubledInJvmZone)\n+                .addRoundTrip(timestampDataType(), timeDoubledInVilnius);\n+\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, epoch); // epoch also is a gap in JVM zone\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, timeGapInJvmZone1);\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, timeGapInJvmZone2);\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, timeGapInVilnius);\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, timeGapInKathmandu);\n+\n+        Session session = Session.builder(getQueryRunner().getDefaultSession())\n+                .setTimeZoneKey(TimeZoneKey.getTimeZoneKey(sessionZone.getId()))\n+                .setSystemProperty(\"legacy_timestamp\", Boolean.toString(legacyTimestamp))\n+                .build();\n+\n+        if (insertWithPresto) {\n+            tests.execute(getQueryRunner(), session, prestoCreateAsSelect(session, \"test_timestamp\"));\n+        }\n+        else {\n+            tests.execute(getQueryRunner(), session, oracleCreateAndInsert(\"test_timestamp\"));\n+        }\n+    }\n+\n+    private void addTimestampTestIfSupported(DataTypeTest tests, boolean legacyTimestamp, ZoneId sessionZone, LocalDateTime dateTime)\n+    {\n+        if (legacyTimestamp && isGap(sessionZone, dateTime)) {\n+            // in legacy timestamp semantics we cannot represent this dateTime\n+            return;\n+        }\n+\n+        tests.addRoundTrip(timestampDataType(), dateTime);\n+    }\n+\n+    @DataProvider\n+    public Object[][] testTimestampDataProvider()\n+    {\n+        return new Object[][] {\n+                {true, true, ZoneOffset.UTC},\n+                {false, true, ZoneOffset.UTC},\n+                {true, false, ZoneOffset.UTC},\n+                {false, false, ZoneOffset.UTC},\n+\n+                {true, true, jvmZone},\n+                {false, true, jvmZone},\n+                {true, false, jvmZone},\n+                {false, false, jvmZone},\n+\n+                // using two non-JVM zones so that we don't need to worry what Oracle system zone is\n+                {true, true, vilnius},\n+                {false, true, vilnius},\n+                {true, false, vilnius},\n+                {false, false, vilnius},\n+\n+                {true, true, kathmandu},\n+                {false, true, kathmandu},\n+                {true, false, kathmandu},\n+                {false, false, kathmandu},\n+\n+                {true, true, ZoneId.of(TestingSession.DEFAULT_TIME_ZONE_KEY.getId())},\n+                {false, true, ZoneId.of(TestingSession.DEFAULT_TIME_ZONE_KEY.getId())},\n+                {true, false, ZoneId.of(TestingSession.DEFAULT_TIME_ZONE_KEY.getId())},\n+                {false, false, ZoneId.of(TestingSession.DEFAULT_TIME_ZONE_KEY.getId())},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"testTimestampWithTimeZoneDataProvider\")\n+    public void testTimestampWithTimeZone(boolean insertWithPresto)\n+    {\n+        DataType<ZonedDateTime> dataType;\n+        DataSetup dataSetup;\n+        if (insertWithPresto) {\n+            dataType = prestoTimestampWithTimeZoneDataType();\n+            dataSetup = prestoCreateAsSelect(\"timestamp_tz\");\n+        }\n+        else {\n+            dataType = oracleTimestamp3TimeZoneDataType();\n+            dataSetup = oracleCreateAndInsert(\"timestamp_tz\");\n+        }\n+\n+        DataTypeTest tests = DataTypeTest.create()\n+                .addRoundTrip(dataType, epoch.atZone(UTC))\n+                .addRoundTrip(dataType, epoch.atZone(kathmandu))\n+                .addRoundTrip(dataType, epoch.atZone(fixedOffsetEast))\n+                .addRoundTrip(dataType, epoch.atZone(fixedOffsetWest))\n+                .addRoundTrip(dataType, beforeEpoch.atZone(UTC))\n+                .addRoundTrip(dataType, beforeEpoch.atZone(kathmandu))\n+                .addRoundTrip(dataType, beforeEpoch.atZone(fixedOffsetEast))\n+                .addRoundTrip(dataType, beforeEpoch.atZone(fixedOffsetWest))\n+                .addRoundTrip(dataType, afterEpoch.atZone(UTC))\n+                .addRoundTrip(dataType, afterEpoch.atZone(kathmandu))\n+                .addRoundTrip(dataType, afterEpoch.atZone(fixedOffsetEast))\n+                .addRoundTrip(dataType, afterEpoch.atZone(fixedOffsetWest))\n+//                .addRoundTrip(dataType, afterEpoch.atZone(ZoneId.of(\"GMT\")))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 373}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4OTUzNg==", "bodyText": "Nit: no need to wrap here", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431489536", "createdAt": "2020-05-27T22:59:35Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -153,12 +204,322 @@ public void testNumericTypes()\n                 queryResult);\n     }\n \n-    public static DataType<LocalDate> dateOracleType()\n+    /* Datetime tests */\n+\n+    @Test\n+    public void testLegacyDateMapping()\n     {\n-        return DataType.dataType(\n-                \"date\",\n-                TimestampType.TIMESTAMP,\n-                DateTimeFormatter.ofPattern(\"'DATE '''yyyy-MM-dd''\")::format,\n-                LocalDate::atStartOfDay);\n+        legacyDateTests(s -> prestoCreateAsSelect(\"l_date_\" + s));\n+    }\n+\n+    @Test\n+    public void testLegacyDateReadMapping()\n+    {\n+        legacyDateTests(s -> oracleCreateAndInsert(\"l_read_date_\" + s));\n+    }\n+\n+    private void legacyDateTests(Function<String, DataSetup> dataSetup)\n+    {\n+        Map<String, TimeZoneKey> zonesBySqlName = ImmutableMap.of(\n+                \"UTC\", UTC_KEY,\n+                \"JVM\", getTimeZoneKey(ZoneId.systemDefault().getId()),\n+                \"other\", getTimeZoneKey(ZoneId.of(\"Europe/Vilnius\").getId()));\n+\n+        for (Map.Entry<String, TimeZoneKey> zone : zonesBySqlName.entrySet()) {\n+            runLegacyTimestampTestInZone(\n+                    dataSetup.apply(zone.getKey()),\n+                    zone.getValue().getId(),\n+                    legacyDateTests());\n+        }\n+    }\n+\n+    /*\n+     * TODO These tests should be executed in {@link io.prestosql.Session Sessions}\n+     * configured for the JVM time zone, Europe/Vilnius, and UTC.\n+     */\n+    private static DataTypeTest legacyDateTests()\n+    {\n+        ZoneId someZone = ZoneId.of(\"Europe/Vilnius\");\n+\n+        LocalDate dateOfLocalTimeChangeBackwardAtMidnightInSomeZone =\n+                LocalDate.of(1983, 10, 1);\n+\n+        verify(someZone.getRules().getValidOffsets(\n+                dateOfLocalTimeChangeBackwardAtMidnightInSomeZone\n+                        .atStartOfDay().minusMinutes(1)).size() == 2);\n+\n+        return DataTypeTest.create()\n+                // before epoch\n+                .addRoundTrip(dateDataType(), LocalDate.of(1952, 4, 3))\n+                .addRoundTrip(dateDataType(), LocalDate.of(1970, 2, 3))\n+                // summer on northern hemisphere (possible DST)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 7, 1))\n+                // winter on northern hemisphere\n+                // (possible DST on southern hemisphere)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 1, 1))\n+                .addRoundTrip(dateDataType(),\n+                        dateOfLocalTimeChangeBackwardAtMidnightInSomeZone);\n+    }\n+\n+    @Test\n+    public void testNonLegacyDateMapping()\n+    {\n+        nonLegacyDateTests(s -> prestoCreateAsSelect(\"nl_date_\" + s));\n+    }\n+\n+    @Test\n+    public void testNonLegacyDateReadMapping()\n+    {\n+        nonLegacyDateTests(s -> oracleCreateAndInsert(\"nl_read_date_\" + s));\n+    }\n+\n+    void nonLegacyDateTests(Function<String, DataSetup> dataSetup)\n+    {\n+        Map<String, TimeZoneKey> zonesBySqlName = ImmutableMap.of(\n+                \"UTC\", UTC_KEY,\n+                \"JVM\", getTimeZoneKey(ZoneId.systemDefault().getId()),\n+                \"other\", getTimeZoneKey(ZoneId.of(\"Europe/Vilnius\").getId()));\n+\n+        for (Map.Entry<String, TimeZoneKey> zone : zonesBySqlName.entrySet()) {\n+            runNonLegacyTimestampTestInZone(\n+                    dataSetup.apply(zone.getKey()),\n+                    zone.getValue().getId(),\n+                    nonLegacyDateTests());\n+        }\n+    }\n+\n+    /*\n+     * TODO These tests should be executed in {@link io.prestosql.Session Sessions}\n+     * configured for the JVM time zone, Europe/Vilnius, and UTC.\n+     */\n+    private DataTypeTest nonLegacyDateTests()\n+    {\n+        // Note: these test cases are duplicates of those for PostgreSQL and MySQL.\n+\n+        LocalDate dateOfLocalTimeChangeForwardAtMidnightInJvmZone =\n+                LocalDate.of(1970, 1, 1);\n+\n+        verify(jvmZone.getRules().getValidOffsets(\n+                dateOfLocalTimeChangeForwardAtMidnightInJvmZone\n+                        .atStartOfDay()).isEmpty());\n+\n+        ZoneId someZone = ZoneId.of(\"Europe/Vilnius\");\n+\n+        LocalDate dateOfLocalTimeChangeForwardAtMidnightInSomeZone =\n+                LocalDate.of(1983, 4, 1);\n+\n+        verify(someZone.getRules().getValidOffsets(\n+                dateOfLocalTimeChangeForwardAtMidnightInSomeZone\n+                        .atStartOfDay()).isEmpty());\n+\n+        LocalDate dateOfLocalTimeChangeBackwardAtMidnightInSomeZone =\n+                LocalDate.of(1983, 10, 1);\n+\n+        verify(someZone.getRules().getValidOffsets(\n+                dateOfLocalTimeChangeBackwardAtMidnightInSomeZone\n+                        .atStartOfDay().minusMinutes(1)).size() == 2);\n+\n+        return DataTypeTest.create()\n+                // before epoch\n+                .addRoundTrip(dateDataType(), LocalDate.of(1952, 4, 3))\n+                .addRoundTrip(dateDataType(), LocalDate.of(1970, 1, 1))\n+                .addRoundTrip(dateDataType(), LocalDate.of(1970, 2, 3))\n+                // summer on northern hemisphere (possible DST)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 7, 1))\n+                // winter on northern hemisphere\n+                // (possible DST on southern hemisphere)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 1, 1))\n+                .addRoundTrip(dateDataType(),\n+                        dateOfLocalTimeChangeForwardAtMidnightInJvmZone)\n+                .addRoundTrip(dateDataType(),\n+                        dateOfLocalTimeChangeForwardAtMidnightInSomeZone)\n+                .addRoundTrip(dateDataType(),\n+                        dateOfLocalTimeChangeBackwardAtMidnightInSomeZone);\n+    }\n+\n+    @Test(dataProvider = \"testTimestampDataProvider\")\n+    public void testTimestamp(boolean legacyTimestamp, boolean insertWithPresto, ZoneId sessionZone)\n+    {\n+        // using two non-JVM zones so that we don't need to worry what Oracle system zone is\n+        DataTypeTest tests = DataTypeTest.create()\n+                .addRoundTrip(timestampDataType(), beforeEpoch)\n+                .addRoundTrip(timestampDataType(), afterEpoch)\n+                .addRoundTrip(timestampDataType(), timeDoubledInJvmZone)\n+                .addRoundTrip(timestampDataType(), timeDoubledInVilnius);\n+\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, epoch); // epoch also is a gap in JVM zone\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, timeGapInJvmZone1);\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, timeGapInJvmZone2);\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, timeGapInVilnius);\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, timeGapInKathmandu);\n+\n+        Session session = Session.builder(getQueryRunner().getDefaultSession())\n+                .setTimeZoneKey(TimeZoneKey.getTimeZoneKey(sessionZone.getId()))\n+                .setSystemProperty(\"legacy_timestamp\", Boolean.toString(legacyTimestamp))\n+                .build();\n+\n+        if (insertWithPresto) {\n+            tests.execute(getQueryRunner(), session, prestoCreateAsSelect(session, \"test_timestamp\"));\n+        }\n+        else {\n+            tests.execute(getQueryRunner(), session, oracleCreateAndInsert(\"test_timestamp\"));\n+        }\n+    }\n+\n+    private void addTimestampTestIfSupported(DataTypeTest tests, boolean legacyTimestamp, ZoneId sessionZone, LocalDateTime dateTime)\n+    {\n+        if (legacyTimestamp && isGap(sessionZone, dateTime)) {\n+            // in legacy timestamp semantics we cannot represent this dateTime\n+            return;\n+        }\n+\n+        tests.addRoundTrip(timestampDataType(), dateTime);\n+    }\n+\n+    @DataProvider\n+    public Object[][] testTimestampDataProvider()\n+    {\n+        return new Object[][] {\n+                {true, true, ZoneOffset.UTC},\n+                {false, true, ZoneOffset.UTC},\n+                {true, false, ZoneOffset.UTC},\n+                {false, false, ZoneOffset.UTC},\n+\n+                {true, true, jvmZone},\n+                {false, true, jvmZone},\n+                {true, false, jvmZone},\n+                {false, false, jvmZone},\n+\n+                // using two non-JVM zones so that we don't need to worry what Oracle system zone is\n+                {true, true, vilnius},\n+                {false, true, vilnius},\n+                {true, false, vilnius},\n+                {false, false, vilnius},\n+\n+                {true, true, kathmandu},\n+                {false, true, kathmandu},\n+                {true, false, kathmandu},\n+                {false, false, kathmandu},\n+\n+                {true, true, ZoneId.of(TestingSession.DEFAULT_TIME_ZONE_KEY.getId())},\n+                {false, true, ZoneId.of(TestingSession.DEFAULT_TIME_ZONE_KEY.getId())},\n+                {true, false, ZoneId.of(TestingSession.DEFAULT_TIME_ZONE_KEY.getId())},\n+                {false, false, ZoneId.of(TestingSession.DEFAULT_TIME_ZONE_KEY.getId())},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"testTimestampWithTimeZoneDataProvider\")\n+    public void testTimestampWithTimeZone(boolean insertWithPresto)\n+    {\n+        DataType<ZonedDateTime> dataType;\n+        DataSetup dataSetup;\n+        if (insertWithPresto) {\n+            dataType = prestoTimestampWithTimeZoneDataType();\n+            dataSetup = prestoCreateAsSelect(\"timestamp_tz\");\n+        }\n+        else {\n+            dataType = oracleTimestamp3TimeZoneDataType();\n+            dataSetup = oracleCreateAndInsert(\"timestamp_tz\");\n+        }\n+\n+        DataTypeTest tests = DataTypeTest.create()\n+                .addRoundTrip(dataType, epoch.atZone(UTC))\n+                .addRoundTrip(dataType, epoch.atZone(kathmandu))\n+                .addRoundTrip(dataType, epoch.atZone(fixedOffsetEast))\n+                .addRoundTrip(dataType, epoch.atZone(fixedOffsetWest))\n+                .addRoundTrip(dataType, beforeEpoch.atZone(UTC))\n+                .addRoundTrip(dataType, beforeEpoch.atZone(kathmandu))\n+                .addRoundTrip(dataType, beforeEpoch.atZone(fixedOffsetEast))\n+                .addRoundTrip(dataType, beforeEpoch.atZone(fixedOffsetWest))\n+                .addRoundTrip(dataType, afterEpoch.atZone(UTC))\n+                .addRoundTrip(dataType, afterEpoch.atZone(kathmandu))\n+                .addRoundTrip(dataType, afterEpoch.atZone(fixedOffsetEast))\n+                .addRoundTrip(dataType, afterEpoch.atZone(fixedOffsetWest))\n+//                .addRoundTrip(dataType, afterEpoch.atZone(ZoneId.of(\"GMT\")))\n+//                .addRoundTrip(dataType, afterEpoch.atZone(ZoneId.of(\"UTC\")))\n+//                .addRoundTrip(dataType, afterEpoch.atZone(ZoneId.of(\"Z\")))\n+//                .addRoundTrip(dataType, afterEpoch.atZone(ZoneId.of(\"UTC+00:00\")))\n+                .addRoundTrip(dataType, timeDoubledInJvmZone.atZone(UTC))\n+                .addRoundTrip(dataType, timeDoubledInJvmZone.atZone(jvmZone))\n+                .addRoundTrip(dataType, timeDoubledInJvmZone.atZone(kathmandu))\n+                .addRoundTrip(dataType, timeDoubledInVilnius.atZone(UTC))\n+                .addRoundTrip(dataType, timeDoubledInVilnius.atZone(vilnius))\n+                .addRoundTrip(dataType, timeDoubledInVilnius.atZone(kathmandu))\n+                .addRoundTrip(dataType, timeGapInJvmZone1.atZone(UTC))\n+                .addRoundTrip(dataType, timeGapInJvmZone1.atZone(kathmandu))\n+                .addRoundTrip(dataType, timeGapInJvmZone2.atZone(UTC))\n+                .addRoundTrip(dataType, timeGapInJvmZone2.atZone(kathmandu))\n+                .addRoundTrip(dataType, timeGapInVilnius.atZone(kathmandu))\n+                .addRoundTrip(dataType, timeGapInKathmandu.atZone(vilnius));\n+\n+        tests.execute(getQueryRunner(), dataSetup);\n+    }\n+\n+    @DataProvider\n+    public Object[][] testTimestampWithTimeZoneDataProvider()\n+    {\n+        return new Object[][] {\n+                {true},\n+                {false},\n+        };\n+    }\n+\n+    private DataSetup oracleCreateAndInsert(String tableNamePrefix)\n+    {\n+        return new CreateAndInsertDataSetup(\n+                getSqlExecutor(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 405}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTAzNQ==", "bodyText": "This is confusing to read, add parens\nboolean precisionUnspecified = (columnSize + max(-typeHandle.getDecimalDigits(), 0)) == 127;", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431491035", "createdAt": "2020-05-27T23:03:52Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -202,7 +203,8 @@ public void createSchema(JdbcIdentity identity, String schemaName)\n                 if (scale == 0) {\n                     return Optional.of(bigintColumnMapping());\n                 }\n-                if (scale < 0 || scale > precision) {\n+                boolean precisionUnspecified = columnSize + max(-typeHandle.getDecimalDigits(), 0) == 127;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTYxNw==", "bodyText": "Actually, I think this separate boolean makes it harder to read. I'd inline this\nif ((columnSize + max(-typeHandle.getDecimalDigits(), 0)) == 127) {\nOr split it out like\nint digits = columnSize + max(-typeHandle.getDecimalDigits(), 0);\nif (digits == 127) {", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431491617", "createdAt": "2020-05-27T23:05:40Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -202,7 +203,8 @@ public void createSchema(JdbcIdentity identity, String schemaName)\n                 if (scale == 0) {\n                     return Optional.of(bigintColumnMapping());\n                 }\n-                if (scale < 0 || scale > precision) {\n+                boolean precisionUnspecified = columnSize + max(-typeHandle.getDecimalDigits(), 0) == 127;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTAzNQ=="}, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MjY3NA==", "bodyText": "Nit: redundant else", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431492674", "createdAt": "2020-05-27T23:08:32Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -205,7 +205,12 @@ public void createSchema(JdbcIdentity identity, String schemaName)\n                 }\n                 boolean precisionUnspecified = columnSize + max(-typeHandle.getDecimalDigits(), 0) == 127;\n                 if (precisionUnspecified) {\n-                    return Optional.of(decimalColumnMapping(createDecimalType(precision, numberDefaultScale), numberRoundingMode));\n+                    if (numberDefaultScale.isPresent()) {\n+                        return Optional.of(decimalColumnMapping(createDecimalType(precision, numberDefaultScale.get()), numberRoundingMode));\n+                    }\n+                    else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MzQ4Mw==", "bodyText": "This can be replaced with\nreturn numberDefaultScale.map(scale -> decimalColumnMapping(createDecimalType(precision, scale), numberRoundingMode));\nOr\nreturn numberDefaultScale\n        .map(scale -> createDecimalType(precision, scale))\n        .map(type -> decimalColumnMapping(type, numberRoundingMode));", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431493483", "createdAt": "2020-05-27T23:10:45Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -205,7 +205,12 @@ public void createSchema(JdbcIdentity identity, String schemaName)\n                 }\n                 boolean precisionUnspecified = columnSize + max(-typeHandle.getDecimalDigits(), 0) == 127;\n                 if (precisionUnspecified) {\n-                    return Optional.of(decimalColumnMapping(createDecimalType(precision, numberDefaultScale), numberRoundingMode));\n+                    if (numberDefaultScale.isPresent()) {\n+                        return Optional.of(decimalColumnMapping(createDecimalType(precision, numberDefaultScale.get()), numberRoundingMode));\n+                    }\n+                    else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MjY3NA=="}, "originalCommit": null, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NDEwNQ==", "bodyText": "Can you add a test using assertFailsValidation() to verify that this works?", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431494105", "createdAt": "2020-05-27T23:12:37Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleConfig.java", "diffHunk": "@@ -41,17 +43,16 @@ public OracleConfig setSynonymsEnabled(boolean enabled)\n         return this;\n     }\n \n-    @Min(0)\n-    @Max(38)\n-    public int getNumberDefaultScale()\n+    public Optional<@Min(0) @Max(38) Integer> getDefaultNumberScale()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NDM3Ng==", "bodyText": "date -> data", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431494376", "createdAt": "2020-05-27T23:13:27Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleConfig.java", "diffHunk": "@@ -41,17 +43,16 @@ public OracleConfig setSynonymsEnabled(boolean enabled)\n         return this;\n     }\n \n-    @Min(0)\n-    @Max(38)\n-    public int getNumberDefaultScale()\n+    public Optional<@Min(0) @Max(38) Integer> getDefaultNumberScale()\n     {\n-        return numberDefaultScale;\n+        return Optional.ofNullable(defaultNumberScale);\n     }\n \n     @Config(\"oracle.number.default-scale\")\n-    public OracleConfig setNumberDefaultScale(Integer numberDefaultScale)\n+    @ConfigDescription(\"Default Presto DECIMAL scale for Oracle NUMBER date type\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NDU4NQ==", "bodyText": "We usually static import the session property getters", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431494585", "createdAt": "2020-05-27T23:14:09Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -203,6 +199,8 @@ public void createSchema(JdbcIdentity identity, String schemaName)\n                 if (scale == 0) {\n                     return Optional.of(bigintColumnMapping());\n                 }\n+                RoundingMode numberRoundingMode = OracleSessionProperties.getNumberRoundingMode(session);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NDc5OA==", "bodyText": "Nit: could shorten parameter to config", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431494798", "createdAt": "2020-05-27T23:14:54Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleSessionProperties.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.oracle;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.plugin.jdbc.SessionPropertiesProvider;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.session.PropertyMetadata;\n+\n+import javax.inject.Inject;\n+\n+import java.math.RoundingMode;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.session.PropertyMetadata.enumProperty;\n+import static io.prestosql.spi.session.PropertyMetadata.integerProperty;\n+\n+public final class OracleSessionProperties\n+        implements SessionPropertiesProvider\n+{\n+    public static final String NUMBER_ROUNDING_MODE = \"number_rounding_mode\";\n+    public static final String NUMBER_DEFAULT_SCALE = \"number_default_scale\";\n+\n+    private final List<PropertyMetadata<?>> sessionProperties;\n+\n+    @Inject\n+    public OracleSessionProperties(OracleConfig oracleConfig)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5Njk4MQ==", "bodyText": "Wrap all arguments or none. (I wouldn't wrap here)", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431496981", "createdAt": "2020-05-27T23:21:30Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -319,6 +337,14 @@ public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n                 return WriteMapping.sliceMapping(\"clob\", varcharWriteFunction());\n             }\n         }\n+        if (type instanceof DecimalType) {\n+            String dataType = format(\"number(%s, %s)\",\n+                    ((DecimalType) type).getPrecision(), ((DecimalType) type).getScale());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NzQ0OA==", "bodyText": "Shouldn't this just be \"\\\\d\"? Or do \"[0-9]\"", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431497448", "createdAt": "2020-05-27T23:23:02Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/OracleDataTypes.java", "diffHunk": "@@ -17,19 +17,84 @@\n import io.prestosql.spi.type.Type;\n import io.prestosql.testing.datatype.DataType;\n \n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n import java.time.LocalDate;\n import java.time.ZoneId;\n import java.time.ZonedDateTime;\n import java.time.format.DateTimeFormatter;\n import java.util.function.Function;\n \n+import static io.prestosql.spi.type.DecimalType.createDecimalType;\n import static io.prestosql.spi.type.TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE;\n+import static java.lang.Math.max;\n import static java.lang.String.format;\n+import static java.math.RoundingMode.UNNECESSARY;\n \n public final class OracleDataTypes\n {\n     private OracleDataTypes() {}\n \n+    /* Fixed-point numeric types */\n+\n+    public static DataType<BigDecimal> unspecifiedNumberDataType(int expectedScaleInPresto)\n+    {\n+        return numberDataType(38, expectedScaleInPresto, \"number\");\n+    }\n+\n+    public static DataType<BigDecimal> numberDataType(int precision)\n+    {\n+        return numberDataType(precision, 0, format(\"number(%d)\", precision));\n+    }\n+\n+    /**\n+     * Create a number type using the same transformation as\n+     * OracleClient.toPrestoType to handle negative scale.\n+     */\n+    public static DataType<BigDecimal> numberDataType(int precision, int scale)\n+    {\n+        return numberDataType(precision, scale, format(\"number(%d, %d)\", precision, scale));\n+    }\n+\n+    private static DataType<BigDecimal> numberDataType(int precision, int scale, String oracleInsertType)\n+    {\n+        int prestoPrecision = precision + max(-scale, 0);\n+        int prestoScale = max(scale, 0);\n+        return dataType(\n+                oracleInsertType,\n+                createDecimalType(prestoPrecision, prestoScale),\n+                BigDecimal::toString,\n+                // Round to Oracle's scale if necessary, then return to the scale Presto will use.\n+                i -> i.setScale(scale, RoundingMode.HALF_UP).setScale(prestoScale));\n+    }\n+\n+    public static DataType<BigDecimal> oracleDecimalDataType(int precision, int scale)\n+    {\n+        String databaseType = format(\"decimal(%s, %s)\", precision, scale);\n+        return dataType(\n+                databaseType,\n+                createDecimalType(precision, scale),\n+                bigDecimal -> format(\"CAST(TO_NUMBER('%s', '%s') AS %s)\", bigDecimal.toPlainString(), toNumberFormatMask(bigDecimal), databaseType),\n+                bigDecimal -> bigDecimal.setScale(scale, UNNECESSARY));\n+    }\n+\n+    private static String toNumberFormatMask(BigDecimal bigDecimal)\n+    {\n+        return bigDecimal.toPlainString()\n+                .replace(\"-\", \"\")\n+                .replaceAll(\"[\\\\d]\", \"9\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMDI4Mw==", "bodyText": "Nit: capitalize last AND", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431500283", "createdAt": "2020-05-27T23:32:05Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleDistributedQueries.java", "diffHunk": "@@ -352,6 +352,17 @@ public void testShowColumns()\n                 format(\"%s does not matches %s\", actual, expectedParametrizedVarchar));\n     }\n \n+    @Override\n+    public void testInformationSchemaFiltering()\n+    {\n+        assertQuery(\n+                \"SELECT table_name FROM information_schema.tables WHERE table_name = 'orders' LIMIT 1\",\n+                \"SELECT 'orders' table_name\");\n+        assertQuery(\n+                \"SELECT table_name FROM information_schema.columns WHERE data_type = 'decimal(19,0)' AND table_name = 'customer' and column_name = 'custkey' LIMIT 1\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMDgyOA==", "bodyText": "Nit: d -> value", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431500828", "createdAt": "2020-05-27T23:33:39Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/OracleDataTypes.java", "diffHunk": "@@ -95,6 +99,85 @@ private static String toNumberFormatMask(BigDecimal bigDecimal)\n         return dataType(\"boolean\", createDecimalType(1), Object::toString, value -> value ? BigDecimal.ONE : BigDecimal.ZERO);\n     }\n \n+    /* Floating point numeric types */\n+\n+    public static DataType<Double> binaryDoubleDataType()\n+    {\n+        return dataType(\"binary_double\", DoubleType.DOUBLE,\n+                value -> {\n+                    if (Double.isFinite(value)) {\n+                        return value.toString();\n+                    }\n+                    if (Double.isNaN(value)) {\n+                        return \"binary_double_nan\";\n+                    }\n+                    return format(\"%sbinary_double_infinity\", value > 0 ? \"+\" : \"-\");\n+                });\n+    }\n+\n+    public static DataType<Float> binaryFloatDataType()\n+    {\n+        return dataType(\"binary_float\", RealType.REAL,\n+                value -> {\n+                    if (Float.isFinite(value)) {\n+                        return value.toString();\n+                    }\n+                    if (Float.isNaN(value)) {\n+                        return \"binary_float_nan\";\n+                    }\n+                    return format(\"%sbinary_float_infinity\", value > 0 ? \"+\" : \"-\");\n+                });\n+    }\n+\n+    public static DataType<Double> doubleDataType()\n+    {\n+        return dataType(\"double\", DoubleType.DOUBLE,\n+                value -> {\n+                    if (Double.isFinite(value)) {\n+                        return value.toString();\n+                    }\n+                    if (Double.isNaN(value)) {\n+                        return \"nan()\";\n+                    }\n+                    return format(\"%sinfinity()\", value > 0 ? \"+\" : \"-\");\n+                });\n+    }\n+\n+    public static DataType<Float> realDataType()\n+    {\n+        return dataType(\"real\", RealType.REAL,\n+                value -> {\n+                    if (Float.isFinite(value)) {\n+                        return value.toString();\n+                    }\n+                    if (Float.isNaN(value)) {\n+                        return \"nan()\";\n+                    }\n+                    return format(\"%sinfinity()\", value > 0 ? \"+\" : \"-\");\n+                });\n+    }\n+\n+    public static DataType<Double> oracleFloatDataType()\n+    {\n+        return oracleFloatDataType(Optional.empty());\n+    }\n+\n+    public static DataType<Double> oracleFloatDataType(int precision)\n+    {\n+        return oracleFloatDataType(Optional.of(precision));\n+    }\n+\n+    public static DataType<Double> oracleFloatDataType(Optional<Integer> precision)\n+    {\n+        String insertType = \"float\" + (precision.isPresent() ? format(\"(%s)\", precision.get()) : \"\");\n+        return dataType(insertType, DoubleType.DOUBLE,\n+                d -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMTA1MQ==", "bodyText": "precision.map(value -> format(\"(%s)\", value)).orElse(\"\")", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431501051", "createdAt": "2020-05-27T23:34:21Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/OracleDataTypes.java", "diffHunk": "@@ -95,6 +99,85 @@ private static String toNumberFormatMask(BigDecimal bigDecimal)\n         return dataType(\"boolean\", createDecimalType(1), Object::toString, value -> value ? BigDecimal.ONE : BigDecimal.ZERO);\n     }\n \n+    /* Floating point numeric types */\n+\n+    public static DataType<Double> binaryDoubleDataType()\n+    {\n+        return dataType(\"binary_double\", DoubleType.DOUBLE,\n+                value -> {\n+                    if (Double.isFinite(value)) {\n+                        return value.toString();\n+                    }\n+                    if (Double.isNaN(value)) {\n+                        return \"binary_double_nan\";\n+                    }\n+                    return format(\"%sbinary_double_infinity\", value > 0 ? \"+\" : \"-\");\n+                });\n+    }\n+\n+    public static DataType<Float> binaryFloatDataType()\n+    {\n+        return dataType(\"binary_float\", RealType.REAL,\n+                value -> {\n+                    if (Float.isFinite(value)) {\n+                        return value.toString();\n+                    }\n+                    if (Float.isNaN(value)) {\n+                        return \"binary_float_nan\";\n+                    }\n+                    return format(\"%sbinary_float_infinity\", value > 0 ? \"+\" : \"-\");\n+                });\n+    }\n+\n+    public static DataType<Double> doubleDataType()\n+    {\n+        return dataType(\"double\", DoubleType.DOUBLE,\n+                value -> {\n+                    if (Double.isFinite(value)) {\n+                        return value.toString();\n+                    }\n+                    if (Double.isNaN(value)) {\n+                        return \"nan()\";\n+                    }\n+                    return format(\"%sinfinity()\", value > 0 ? \"+\" : \"-\");\n+                });\n+    }\n+\n+    public static DataType<Float> realDataType()\n+    {\n+        return dataType(\"real\", RealType.REAL,\n+                value -> {\n+                    if (Float.isFinite(value)) {\n+                        return value.toString();\n+                    }\n+                    if (Float.isNaN(value)) {\n+                        return \"nan()\";\n+                    }\n+                    return format(\"%sinfinity()\", value > 0 ? \"+\" : \"-\");\n+                });\n+    }\n+\n+    public static DataType<Double> oracleFloatDataType()\n+    {\n+        return oracleFloatDataType(Optional.empty());\n+    }\n+\n+    public static DataType<Double> oracleFloatDataType(int precision)\n+    {\n+        return oracleFloatDataType(Optional.of(precision));\n+    }\n+\n+    public static DataType<Double> oracleFloatDataType(Optional<Integer> precision)\n+    {\n+        String insertType = \"float\" + (precision.isPresent() ? format(\"(%s)\", precision.get()) : \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMTYzMA==", "bodyText": "Fix wrapping", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431501630", "createdAt": "2020-05-27T23:36:04Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/OracleDataTypes.java", "diffHunk": "@@ -150,4 +233,10 @@ private static ZonedDateTime normalizeForOracleStorage(ZonedDateTime zonedDateTi\n     {\n         return DataType.dataType(insertType, prestoResultType, toLiteral, toPrestoQueryResult);\n     }\n+\n+    private static <T> DataType<T> dataType(String insertType, Type prestoResultType,\n+            Function<T, String> toLiteral)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMTcyMg==", "bodyText": "Fix wrapping", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431501722", "createdAt": "2020-05-27T23:36:20Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -376,6 +376,7 @@ public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n         if (writeMapping != null) {\n             return writeMapping;\n         }\n-        return super.toWriteMapping(session, type);\n+        throw new PrestoException(NOT_SUPPORTED,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMTk2Nw==", "bodyText": "This would read better as\n// single UTF char may require up to 4 bytes of storage", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431501967", "createdAt": "2020-05-27T23:37:09Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -101,11 +109,17 @@\n public class OracleClient\n         extends BaseJdbcClient\n {\n+    // single UTF char may require at most 4 bytes of storage", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMjM3OA==", "bodyText": "Nit: don't wrap here", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431502378", "createdAt": "2020-05-27T23:38:31Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -350,16 +379,37 @@ public static DoubleWriteFunction oracleDoubleWriteFunction()\n         return ((statement, index, value) -> ((OraclePreparedStatement) statement).setBinaryDouble(index, value));\n     }\n \n+    private SliceWriteFunction oracleCharWriteFunction(CharType charType)\n+    {\n+        return (statement, index, value) -> {\n+            statement.setString(index, Chars.padSpaces(value, charType).toStringUtf8());\n+        };\n+    }\n+\n     @Override\n     public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n     {\n         if (isVarcharType(type)) {\n-            if (((VarcharType) type).isUnbounded()) {\n-                return super.toWriteMapping(session, createVarcharType(varcharMaxSize));\n+            String dataType;\n+            VarcharType varcharType = (VarcharType) type;\n+            if (varcharType.isUnbounded() ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwOTU5Mw==", "bodyText": "The word \"converts\" here seems to be a mistake.", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431509593", "createdAt": "2020-05-28T00:02:13Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -347,6 +351,35 @@ private static DataTypeTest unicodeTests(IntFunction<DataType<String>> typeConst\n                 .addRoundTrip(typeConstructor.apply(nonBmpLength + 5), nonBmpCharacter);\n     }\n \n+    /* Varbinary tests */\n+\n+    @Test\n+    public void testVarbinaryMapping()\n+    {\n+        testTypeMapping(\"varbinary\", varbinaryTests(varbinaryDataType()));\n+    }\n+\n+    @Test\n+    public void testVarbinaryReadMapping()\n+    {\n+        testTypeReadMapping(\"read_varbinary\",\n+                varbinaryTests(blobDataType())\n+                        .addRoundTrip(blobDataType(), new byte[] {}),\n+                varbinaryTests(rawDataType(2000)));\n+        // The test with the empty array is read-only because Oracle converts treats", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxMDIwNg==", "bodyText": "What happens for CONVERT_TO_VARCHAR or jdbc-types-mapped-to-varchar?", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431510206", "createdAt": "2020-05-28T00:04:12Z", "author": {"login": "electrum"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -842,6 +842,36 @@ public void testTimestampWithTimeZone(boolean insertWithPresto)\n         };\n     }\n \n+    /* Unsupported type tests */\n+\n+    @Test\n+    public void testUnsupportedBasicType()\n+    {\n+        testUnsupportedOracleType(\"BFILE\"); // Never in mapping", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 9}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "090e188f2c1c7d1435164db16100f4ce1be9232b", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/090e188f2c1c7d1435164db16100f4ce1be9232b", "committedDate": "2020-05-28T12:08:52Z", "message": "Make random suffix for test tables shorter\n\nLong random suffix does not play well with limits on length of identifiers\npresent in some databases (e.g. Oracle 11)."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2baf62836b069862e494118fa49bb841f40f80c", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/f2baf62836b069862e494118fa49bb841f40f80c", "committedDate": "2020-05-28T12:08:53Z", "message": "Drop oracle.timestamp.precision configuration parameter\n\nTimestamp precision is currently a work in progress and soon will be\naddressed engine-wide."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79057b5a3bf451e694e76213cc92d191b4632a7e", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/79057b5a3bf451e694e76213cc92d191b4632a7e", "committedDate": "2020-05-28T12:08:54Z", "message": "Cleanup Oracle test user and schema setup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "712e26341f0775dbc0f656c4b62533e0192dacfc", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/712e26341f0775dbc0f656c4b62533e0192dacfc", "committedDate": "2020-05-28T12:08:55Z", "message": "Fix type mappings for temporal data types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4153f3ba4ade6c75fbb70b3658ce9d939b7d256", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/b4153f3ba4ade6c75fbb70b3658ce9d939b7d256", "committedDate": "2020-05-28T12:08:56Z", "message": "Do not fall through to BaseJDBC type mapping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30b5979043540fa38d77d81d4a10c5f0dcb9e360", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/30b5979043540fa38d77d81d4a10c5f0dcb9e360", "committedDate": "2020-05-28T12:08:57Z", "message": "Use default number scale only if unspecified in Oracle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a438ba5d2e114b54b4048c48cc620624c7bf849d", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/a438ba5d2e114b54b4048c48cc620624c7bf849d", "committedDate": "2020-05-28T12:08:58Z", "message": "Make oracle.number.default-scale optional"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e9d45db7e1901a980c0a3bdacc79c353b27d584", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/3e9d45db7e1901a980c0a3bdacc79c353b27d584", "committedDate": "2020-05-28T12:09:00Z", "message": "Expose rounding mode and default scale as session properties"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe3dd7c5693b534d5cbb9959eac027b003bb6d96", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/fe3dd7c5693b534d5cbb9959eac027b003bb6d96", "committedDate": "2020-05-28T12:09:01Z", "message": "Fix type mappings for numeric data types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6dad049892c45e497153af311f987a1601e6b38d", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/6dad049892c45e497153af311f987a1601e6b38d", "committedDate": "2020-05-28T12:09:02Z", "message": "Fix type mappings for floating point number types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7741ce44457dd5cb40f05930d1c03a6010576736", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/7741ce44457dd5cb40f05930d1c03a6010576736", "committedDate": "2020-05-28T12:09:03Z", "message": "Do not fall through to BaseJDBC write mappings"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5OTI5OTIx", "url": "https://github.com/trinodb/trino/pull/3838#pullrequestreview-419929921", "createdAt": "2020-05-28T09:23:00Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwOToyMzowMFrOGbs3pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMTozNjozNFrOGbxK8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY5OTg3Ng==", "bodyText": "I would rather leave it as is.\nUnder the hood getTimeZone() is called which looks like this:\n    public TimeZone getTimeZone() {\n        if (this.sharedZone) {\n            this.zone = (TimeZone)this.zone.clone();\n            this.sharedZone = false;\n        }\n\n        return this.zone;\n    }\n\nIt kinda can mutate calendar state, even if it does not do it in our case as sharedZone==false. Yet it still looks fragile.\nAlso new oracle.sql.TIMESTAMP(...) caretes yet another calendar instance internally, so we are not gaining much by avoiding creation of our own :)", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431699876", "createdAt": "2020-05-28T09:23:00Z", "author": {"login": "losipiuk"}, "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -190,10 +212,77 @@ public void createSchema(JdbcIdentity identity, String schemaName)\n                 return Optional.of(varcharColumnMapping(createVarcharType(columnSize)));\n             case Types.VARCHAR:\n                 return Optional.of(varcharColumnMapping(createVarcharType(columnSize)));\n+            // This mapping covers both DATE and TIMESTAMP, as Oracle's DATE has second precision.\n+            case OracleTypes.TIMESTAMP:\n+                return Optional.of(oracleTimestampColumnMapping(session));\n+            case OracleTypes.TIMESTAMPTZ:\n+                return Optional.of(oracleTimestampWithTimeZoneColumnMapping());\n         }\n         return super.toPrestoType(session, connection, typeHandle);\n     }\n \n+    public static LongWriteFunction oracleDateWriteFunction()\n+    {\n+        return (statement, index, value) -> {\n+            long utcMillis = DAYS.toMillis(value);\n+            ZonedDateTime date = Instant.ofEpochMilli(utcMillis).atZone(ZoneOffset.UTC);\n+            // because of how JDBC works with dates we need to use the ZonedDataTime object and not a LocalDateTime\n+            statement.setObject(index, date);\n+        };\n+    }\n+\n+    public static LongWriteFunction oracleTimestampWriteFunction(ConnectorSession session)\n+    {\n+        if (session.isLegacyTimestamp()) {\n+            return (statement, index, utcMillis) -> {\n+                long dateTimeAsUtcMillis = Instant.ofEpochMilli(utcMillis)\n+                        .atZone(ZoneId.of(session.getTimeZoneKey().getId()))\n+                        .withZoneSameLocal(ZoneOffset.UTC)\n+                        .toInstant().toEpochMilli();\n+                statement.setObject(index, new oracle.sql.TIMESTAMP(new Timestamp(dateTimeAsUtcMillis), Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4Nzc4Mw=="}, "originalCommit": null, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcwNjAwMQ==", "bodyText": "Changed to more appropriate zone", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431706001", "createdAt": "2020-05-28T09:33:33Z", "author": {"login": "losipiuk"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -153,12 +204,322 @@ public void testNumericTypes()\n                 queryResult);\n     }\n \n-    public static DataType<LocalDate> dateOracleType()\n+    /* Datetime tests */\n+\n+    @Test\n+    public void testLegacyDateMapping()\n     {\n-        return DataType.dataType(\n-                \"date\",\n-                TimestampType.TIMESTAMP,\n-                DateTimeFormatter.ofPattern(\"'DATE '''yyyy-MM-dd''\")::format,\n-                LocalDate::atStartOfDay);\n+        legacyDateTests(s -> prestoCreateAsSelect(\"l_date_\" + s));\n+    }\n+\n+    @Test\n+    public void testLegacyDateReadMapping()\n+    {\n+        legacyDateTests(s -> oracleCreateAndInsert(\"l_read_date_\" + s));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODc1OQ=="}, "originalCommit": null, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcwNzY5Nw==", "bodyText": "I dropped the comment. It was not valid any more.", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431707697", "createdAt": "2020-05-28T09:36:29Z", "author": {"login": "losipiuk"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -153,12 +204,322 @@ public void testNumericTypes()\n                 queryResult);\n     }\n \n-    public static DataType<LocalDate> dateOracleType()\n+    /* Datetime tests */\n+\n+    @Test\n+    public void testLegacyDateMapping()\n     {\n-        return DataType.dataType(\n-                \"date\",\n-                TimestampType.TIMESTAMP,\n-                DateTimeFormatter.ofPattern(\"'DATE '''yyyy-MM-dd''\")::format,\n-                LocalDate::atStartOfDay);\n+        legacyDateTests(s -> prestoCreateAsSelect(\"l_date_\" + s));\n+    }\n+\n+    @Test\n+    public void testLegacyDateReadMapping()\n+    {\n+        legacyDateTests(s -> oracleCreateAndInsert(\"l_read_date_\" + s));\n+    }\n+\n+    private void legacyDateTests(Function<String, DataSetup> dataSetup)\n+    {\n+        Map<String, TimeZoneKey> zonesBySqlName = ImmutableMap.of(\n+                \"UTC\", UTC_KEY,\n+                \"JVM\", getTimeZoneKey(ZoneId.systemDefault().getId()),\n+                \"other\", getTimeZoneKey(ZoneId.of(\"Europe/Vilnius\").getId()));\n+\n+        for (Map.Entry<String, TimeZoneKey> zone : zonesBySqlName.entrySet()) {\n+            runLegacyTimestampTestInZone(\n+                    dataSetup.apply(zone.getKey()),\n+                    zone.getValue().getId(),\n+                    legacyDateTests());\n+        }\n+    }\n+\n+    /*\n+     * TODO These tests should be executed in {@link io.prestosql.Session Sessions}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4OTAwMg=="}, "originalCommit": null, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc3MDM1Mw==", "bodyText": "It does not work with BFILE. Actually if one enables CONVERT_TO_VARCHAR and tries to read from table containing BFILE column, the query will fail because resultSet.getString(columnIndex) here would return null. And that is not supported.\nThe mapping of unsupported numbers to varchar is already tested in testHighNumberScale and others.\nIt could be improved but let's do that as a followup.", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431770353", "createdAt": "2020-05-28T11:36:34Z", "author": {"login": "losipiuk"}, "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -842,6 +842,36 @@ public void testTimestampWithTimeZone(boolean insertWithPresto)\n         };\n     }\n \n+    /* Unsupported type tests */\n+\n+    @Test\n+    public void testUnsupportedBasicType()\n+    {\n+        testUnsupportedOracleType(\"BFILE\"); // Never in mapping", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxMDIwNg=="}, "originalCommit": null, "originalPosition": 9}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "225e1af3ce6797996a42d30fe949ea6ca820078f", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/225e1af3ce6797996a42d30fe949ea6ca820078f", "committedDate": "2020-05-28T14:59:13Z", "message": "Fix type mappings for character types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b06e4dd7f410c14e7906de7323decd7044ee2317", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/b06e4dd7f410c14e7906de7323decd7044ee2317", "committedDate": "2020-05-28T14:59:13Z", "message": "Remove obsolete character type mapping test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3aeb7fb81e2dcdf0b8a3ed1125d87c32fba4436e", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/3aeb7fb81e2dcdf0b8a3ed1125d87c32fba4436e", "committedDate": "2020-05-28T14:59:13Z", "message": "Fix type mappings for binary types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe3106b179563ac524a8c2641f18001345b932f5", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/fe3106b179563ac524a8c2641f18001345b932f5", "committedDate": "2020-05-28T14:59:13Z", "message": "Add tests for unsupported Oracle types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "878a24649562e3fb01ab6b07da73f9bbc643c9f9", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/878a24649562e3fb01ab6b07da73f9bbc643c9f9", "committedDate": "2020-05-28T14:59:13Z", "message": "Use UNNECESSARY as default rounding mode\n\nMajor motivation for the change is fact that UNNECESSARY rounding mode\nis more conservative (safer) than HALF_UP."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "878a24649562e3fb01ab6b07da73f9bbc643c9f9", "author": {"user": {"login": "losipiuk", "name": "\u0141ukasz Osipiuk"}}, "url": "https://github.com/trinodb/trino/commit/878a24649562e3fb01ab6b07da73f9bbc643c9f9", "committedDate": "2020-05-28T14:59:13Z", "message": "Use UNNECESSARY as default rounding mode\n\nMajor motivation for the change is fact that UNNECESSARY rounding mode\nis more conservative (safer) than HALF_UP."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1258, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}