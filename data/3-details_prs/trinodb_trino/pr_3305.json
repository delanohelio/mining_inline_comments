{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3MTUwNzgy", "number": 3305, "title": "Call applyProjection during table scan column pruning", "bodyText": "The existing code was limiting the columns in the TableScan node\nbut wasn't providing this information to connectors. Some connectors\ncan leverage this information during split generation.", "createdAt": "2020-04-01T18:07:24Z", "url": "https://github.com/trinodb/trino/pull/3305", "merged": true, "mergeCommit": {"oid": "44438f2366ce20f39aa4c9d4a9cc5757eb40be34"}, "closed": true, "closedAt": "2020-04-05T03:16:53Z", "author": {"login": "martint"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcToDmtgFqTM4NjIxMDUyMA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcUHxMRABqjMxOTgwNjk2NTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MjEwNTIw", "url": "https://github.com/trinodb/trino/pull/3305#pullrequestreview-386210520", "createdAt": "2020-04-02T08:30:47Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODozMDo0N1rOF_gqZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODozMDo0N1rOF_gqZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTc1MQ==", "bodyText": "what's the relation between this rule and PushProjectionIntoTableScan?", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402139751", "createdAt": "2020-04-02T08:30:47Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -13,34 +13,109 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.TypeProvider;\n import io.prestosql.sql.planner.plan.PlanNode;\n import io.prestosql.sql.planner.plan.TableScanNode;\n \n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-import static com.google.common.collect.Maps.filterKeys;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n-import static io.prestosql.util.MoreLists.filteredCopy;\n+import static java.util.Objects.requireNonNull;\n \n public class PruneTableScanColumns\n         extends ProjectOffPushDownRule<TableScanNode>\n {\n-    public PruneTableScanColumns()\n+    private final Metadata metadata;\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MjA2MTEw", "url": "https://github.com/trinodb/trino/pull/3305#pullrequestreview-386206110", "createdAt": "2020-04-02T08:24:42Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODoyNDo0MlrOF_gclA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODozMTozMFrOF_gr5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzNjIxMg==", "bodyText": "`filteredCopy(tableScanNode.getOutputSymbols(), referencedOutputs::contains);", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402136212", "createdAt": "2020-04-02T08:24:42Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -13,34 +13,109 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.TypeProvider;\n import io.prestosql.sql.planner.plan.PlanNode;\n import io.prestosql.sql.planner.plan.TableScanNode;\n \n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-import static com.google.common.collect.Maps.filterKeys;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n-import static io.prestosql.util.MoreLists.filteredCopy;\n+import static java.util.Objects.requireNonNull;\n \n public class PruneTableScanColumns\n         extends ProjectOffPushDownRule<TableScanNode>\n {\n-    public PruneTableScanColumns()\n+    private final Metadata metadata;\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n     {\n         super(tableScan());\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n     }\n \n     @Override\n-    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode tableScanNode, Set<Symbol> referencedOutputs)\n+    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode node, Set<Symbol> referencedOutputs)\n     {\n-        return Optional.of(\n-                new TableScanNode(\n-                        tableScanNode.getId(),\n-                        tableScanNode.getTable(),\n-                        filteredCopy(tableScanNode.getOutputSymbols(), referencedOutputs::contains),\n-                        filterKeys(tableScanNode.getAssignments(), referencedOutputs::contains),\n-                        tableScanNode.getEnforcedConstraint()));\n+        Session session = context.getSession();\n+        TypeProvider types = context.getSymbolAllocator().getTypes();\n+\n+        return pruneColumns(metadata, typeAnalyzer, types, session, node, referencedOutputs);\n+    }\n+\n+    public static Optional<PlanNode> pruneColumns(Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, Session session, TableScanNode node, Set<Symbol> referencedOutputs)\n+    {\n+        List<Symbol> newOutputs = node.getOutputSymbols().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzNjcwNg==", "bodyText": "toImmutableMap", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402136706", "createdAt": "2020-04-02T08:25:30Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -13,34 +13,109 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.TypeProvider;\n import io.prestosql.sql.planner.plan.PlanNode;\n import io.prestosql.sql.planner.plan.TableScanNode;\n \n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-import static com.google.common.collect.Maps.filterKeys;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n-import static io.prestosql.util.MoreLists.filteredCopy;\n+import static java.util.Objects.requireNonNull;\n \n public class PruneTableScanColumns\n         extends ProjectOffPushDownRule<TableScanNode>\n {\n-    public PruneTableScanColumns()\n+    private final Metadata metadata;\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n     {\n         super(tableScan());\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n     }\n \n     @Override\n-    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode tableScanNode, Set<Symbol> referencedOutputs)\n+    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode node, Set<Symbol> referencedOutputs)\n     {\n-        return Optional.of(\n-                new TableScanNode(\n-                        tableScanNode.getId(),\n-                        tableScanNode.getTable(),\n-                        filteredCopy(tableScanNode.getOutputSymbols(), referencedOutputs::contains),\n-                        filterKeys(tableScanNode.getAssignments(), referencedOutputs::contains),\n-                        tableScanNode.getEnforcedConstraint()));\n+        Session session = context.getSession();\n+        TypeProvider types = context.getSymbolAllocator().getTypes();\n+\n+        return pruneColumns(metadata, typeAnalyzer, types, session, node, referencedOutputs);\n+    }\n+\n+    public static Optional<PlanNode> pruneColumns(Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, Session session, TableScanNode node, Set<Symbol> referencedOutputs)\n+    {\n+        List<Symbol> newOutputs = node.getOutputSymbols().stream()\n+                .filter(referencedOutputs::contains)\n+                .collect(toImmutableList());\n+\n+        if (newOutputs.size() == node.getOutputSymbols().size()) {\n+            return Optional.empty();\n+        }\n+\n+        List<ConnectorExpression> projections = newOutputs.stream()\n+                .map(Symbol::toSymbolReference)\n+                .map(expression -> ConnectorExpressionTranslator.translate(\n+                        session,\n+                        expression,\n+                        typeAnalyzer,\n+                        types))\n+                .map(Optional::get)\n+                .collect(toImmutableList());\n+\n+        TableHandle handle = node.getTable();\n+        Optional<ProjectionApplicationResult<TableHandle>> result = metadata.applyProjection(\n+                session,\n+                handle,\n+                projections,\n+                newOutputs.stream()\n+                        .collect(Collectors.toMap(Symbol::getName, node.getAssignments()::get)));\n+\n+        Map<Symbol, ColumnHandle> newAssignments;\n+        // Attempt to push down the constrained list of columns into the connector.\n+        // Bail out if the connector does anything other than limit the list of columns (e.g., if it synthesizes arbitrary expressions)\n+        if (result.isPresent() && result.get().getProjections().stream().allMatch(Variable.class::isInstance)) {\n+            handle = result.get().getHandle();\n+\n+            Map<String, ColumnHandle> assignments = result.get().getAssignments().stream()\n+                    .collect(Collectors.toMap(ProjectionApplicationResult.Assignment::getVariable, ProjectionApplicationResult.Assignment::getColumn));\n+\n+            ImmutableMap.Builder<Symbol, ColumnHandle> builder = ImmutableMap.builder();\n+            for (int i = 0; i < newOutputs.size(); i++) {\n+                Variable variable = (Variable) result.get().getProjections().get(i);\n+                builder.put(newOutputs.get(i), assignments.get(variable.getName()));\n+            }\n+\n+            newAssignments = builder.build();\n+        }\n+        else {\n+            newAssignments = newOutputs.stream()\n+                    .collect(Collectors.toMap(Function.identity(), node.getAssignments()::get));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzNjc3Ng==", "bodyText": "toImmutableMap", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402136776", "createdAt": "2020-04-02T08:25:38Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -13,34 +13,109 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.TypeProvider;\n import io.prestosql.sql.planner.plan.PlanNode;\n import io.prestosql.sql.planner.plan.TableScanNode;\n \n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-import static com.google.common.collect.Maps.filterKeys;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n-import static io.prestosql.util.MoreLists.filteredCopy;\n+import static java.util.Objects.requireNonNull;\n \n public class PruneTableScanColumns\n         extends ProjectOffPushDownRule<TableScanNode>\n {\n-    public PruneTableScanColumns()\n+    private final Metadata metadata;\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n     {\n         super(tableScan());\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n     }\n \n     @Override\n-    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode tableScanNode, Set<Symbol> referencedOutputs)\n+    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode node, Set<Symbol> referencedOutputs)\n     {\n-        return Optional.of(\n-                new TableScanNode(\n-                        tableScanNode.getId(),\n-                        tableScanNode.getTable(),\n-                        filteredCopy(tableScanNode.getOutputSymbols(), referencedOutputs::contains),\n-                        filterKeys(tableScanNode.getAssignments(), referencedOutputs::contains),\n-                        tableScanNode.getEnforcedConstraint()));\n+        Session session = context.getSession();\n+        TypeProvider types = context.getSymbolAllocator().getTypes();\n+\n+        return pruneColumns(metadata, typeAnalyzer, types, session, node, referencedOutputs);\n+    }\n+\n+    public static Optional<PlanNode> pruneColumns(Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, Session session, TableScanNode node, Set<Symbol> referencedOutputs)\n+    {\n+        List<Symbol> newOutputs = node.getOutputSymbols().stream()\n+                .filter(referencedOutputs::contains)\n+                .collect(toImmutableList());\n+\n+        if (newOutputs.size() == node.getOutputSymbols().size()) {\n+            return Optional.empty();\n+        }\n+\n+        List<ConnectorExpression> projections = newOutputs.stream()\n+                .map(Symbol::toSymbolReference)\n+                .map(expression -> ConnectorExpressionTranslator.translate(\n+                        session,\n+                        expression,\n+                        typeAnalyzer,\n+                        types))\n+                .map(Optional::get)\n+                .collect(toImmutableList());\n+\n+        TableHandle handle = node.getTable();\n+        Optional<ProjectionApplicationResult<TableHandle>> result = metadata.applyProjection(\n+                session,\n+                handle,\n+                projections,\n+                newOutputs.stream()\n+                        .collect(Collectors.toMap(Symbol::getName, node.getAssignments()::get)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTE2NQ==", "bodyText": "I think we should fail in case when connector returns something that engine does not support. Otherwise applyProjection is ineffective.\nIs it an actual case? Is there such connector that does something more than limit of columns?", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402139165", "createdAt": "2020-04-02T08:29:48Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -13,34 +13,109 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.TypeProvider;\n import io.prestosql.sql.planner.plan.PlanNode;\n import io.prestosql.sql.planner.plan.TableScanNode;\n \n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-import static com.google.common.collect.Maps.filterKeys;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n-import static io.prestosql.util.MoreLists.filteredCopy;\n+import static java.util.Objects.requireNonNull;\n \n public class PruneTableScanColumns\n         extends ProjectOffPushDownRule<TableScanNode>\n {\n-    public PruneTableScanColumns()\n+    private final Metadata metadata;\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n     {\n         super(tableScan());\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n     }\n \n     @Override\n-    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode tableScanNode, Set<Symbol> referencedOutputs)\n+    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode node, Set<Symbol> referencedOutputs)\n     {\n-        return Optional.of(\n-                new TableScanNode(\n-                        tableScanNode.getId(),\n-                        tableScanNode.getTable(),\n-                        filteredCopy(tableScanNode.getOutputSymbols(), referencedOutputs::contains),\n-                        filterKeys(tableScanNode.getAssignments(), referencedOutputs::contains),\n-                        tableScanNode.getEnforcedConstraint()));\n+        Session session = context.getSession();\n+        TypeProvider types = context.getSymbolAllocator().getTypes();\n+\n+        return pruneColumns(metadata, typeAnalyzer, types, session, node, referencedOutputs);\n+    }\n+\n+    public static Optional<PlanNode> pruneColumns(Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, Session session, TableScanNode node, Set<Symbol> referencedOutputs)\n+    {\n+        List<Symbol> newOutputs = node.getOutputSymbols().stream()\n+                .filter(referencedOutputs::contains)\n+                .collect(toImmutableList());\n+\n+        if (newOutputs.size() == node.getOutputSymbols().size()) {\n+            return Optional.empty();\n+        }\n+\n+        List<ConnectorExpression> projections = newOutputs.stream()\n+                .map(Symbol::toSymbolReference)\n+                .map(expression -> ConnectorExpressionTranslator.translate(\n+                        session,\n+                        expression,\n+                        typeAnalyzer,\n+                        types))\n+                .map(Optional::get)\n+                .collect(toImmutableList());\n+\n+        TableHandle handle = node.getTable();\n+        Optional<ProjectionApplicationResult<TableHandle>> result = metadata.applyProjection(\n+                session,\n+                handle,\n+                projections,\n+                newOutputs.stream()\n+                        .collect(Collectors.toMap(Symbol::getName, node.getAssignments()::get)));\n+\n+        Map<Symbol, ColumnHandle> newAssignments;\n+        // Attempt to push down the constrained list of columns into the connector.\n+        // Bail out if the connector does anything other than limit the list of columns (e.g., if it synthesizes arbitrary expressions)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTI4OQ==", "bodyText": "toImmutableMap", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402139289", "createdAt": "2020-04-02T08:29:59Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -13,34 +13,109 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.TypeProvider;\n import io.prestosql.sql.planner.plan.PlanNode;\n import io.prestosql.sql.planner.plan.TableScanNode;\n \n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-import static com.google.common.collect.Maps.filterKeys;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n-import static io.prestosql.util.MoreLists.filteredCopy;\n+import static java.util.Objects.requireNonNull;\n \n public class PruneTableScanColumns\n         extends ProjectOffPushDownRule<TableScanNode>\n {\n-    public PruneTableScanColumns()\n+    private final Metadata metadata;\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n     {\n         super(tableScan());\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n     }\n \n     @Override\n-    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode tableScanNode, Set<Symbol> referencedOutputs)\n+    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode node, Set<Symbol> referencedOutputs)\n     {\n-        return Optional.of(\n-                new TableScanNode(\n-                        tableScanNode.getId(),\n-                        tableScanNode.getTable(),\n-                        filteredCopy(tableScanNode.getOutputSymbols(), referencedOutputs::contains),\n-                        filterKeys(tableScanNode.getAssignments(), referencedOutputs::contains),\n-                        tableScanNode.getEnforcedConstraint()));\n+        Session session = context.getSession();\n+        TypeProvider types = context.getSymbolAllocator().getTypes();\n+\n+        return pruneColumns(metadata, typeAnalyzer, types, session, node, referencedOutputs);\n+    }\n+\n+    public static Optional<PlanNode> pruneColumns(Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, Session session, TableScanNode node, Set<Symbol> referencedOutputs)\n+    {\n+        List<Symbol> newOutputs = node.getOutputSymbols().stream()\n+                .filter(referencedOutputs::contains)\n+                .collect(toImmutableList());\n+\n+        if (newOutputs.size() == node.getOutputSymbols().size()) {\n+            return Optional.empty();\n+        }\n+\n+        List<ConnectorExpression> projections = newOutputs.stream()\n+                .map(Symbol::toSymbolReference)\n+                .map(expression -> ConnectorExpressionTranslator.translate(\n+                        session,\n+                        expression,\n+                        typeAnalyzer,\n+                        types))\n+                .map(Optional::get)\n+                .collect(toImmutableList());\n+\n+        TableHandle handle = node.getTable();\n+        Optional<ProjectionApplicationResult<TableHandle>> result = metadata.applyProjection(\n+                session,\n+                handle,\n+                projections,\n+                newOutputs.stream()\n+                        .collect(Collectors.toMap(Symbol::getName, node.getAssignments()::get)));\n+\n+        Map<Symbol, ColumnHandle> newAssignments;\n+        // Attempt to push down the constrained list of columns into the connector.\n+        // Bail out if the connector does anything other than limit the list of columns (e.g., if it synthesizes arbitrary expressions)\n+        if (result.isPresent() && result.get().getProjections().stream().allMatch(Variable.class::isInstance)) {\n+            handle = result.get().getHandle();\n+\n+            Map<String, ColumnHandle> assignments = result.get().getAssignments().stream()\n+                    .collect(Collectors.toMap(ProjectionApplicationResult.Assignment::getVariable, ProjectionApplicationResult.Assignment::getColumn));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0MDEzMg==", "bodyText": "private", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402140132", "createdAt": "2020-04-02T08:31:30Z", "author": {"login": "kokosing"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PruneUnreferencedOutputs.java", "diffHunk": "@@ -118,12 +130,27 @@ public PlanNode optimize(PlanNode plan, Session session, TypeProvider types, Sym\n         requireNonNull(symbolAllocator, \"symbolAllocator is null\");\n         requireNonNull(idAllocator, \"idAllocator is null\");\n \n-        return SimplePlanRewriter.rewriteWith(new Rewriter(), plan, ImmutableSet.of());\n+        return SimplePlanRewriter.rewriteWith(new Rewriter(metadata, types, typeAnalyzer, symbolAllocator, session), plan, ImmutableSet.of());\n     }\n \n     private static class Rewriter\n             extends SimplePlanRewriter<Set<Symbol>>\n     {\n+        private final Metadata metadata;\n+        private final TypeProvider types;\n+        private final TypeAnalyzer typeAnalyzer;\n+        private final SymbolAllocator symbolAllocator;\n+        private final Session session;\n+\n+        public Rewriter(Metadata metadata, TypeProvider types, TypeAnalyzer typeAnalyzer, SymbolAllocator symbolAllocator, Session session)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3MDcyMDcy", "url": "https://github.com/trinodb/trino/pull/3305#pullrequestreview-387072072", "createdAt": "2020-04-03T08:52:01Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1MjowMVrOGAMEPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1MjowMVrOGAMEPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1MDg3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .map(Symbol::toSymbolReference)\n          \n          \n            \n                            .map(expression -> ConnectorExpressionTranslator.translate(\n          \n          \n            \n                                    session,\n          \n          \n            \n                                    expression,\n          \n          \n            \n                                    typeAnalyzer,\n          \n          \n            \n                                    types))\n          \n          \n            \n                            .map(Optional::get)\n          \n          \n            \n                            .map(symbol -> new Variable(symbol.getName(), types.get(symbol)))\n          \n      \n    \n    \n  \n\nnot only simple, this has added benefit that i dont have to wonder whether Optional can be empty ie whether ::get is safe", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402850876", "createdAt": "2020-04-03T08:52:01Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -13,34 +13,108 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.TypeProvider;\n import io.prestosql.sql.planner.plan.PlanNode;\n import io.prestosql.sql.planner.plan.TableScanNode;\n \n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n \n-import static com.google.common.collect.Maps.filterKeys;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n import static io.prestosql.util.MoreLists.filteredCopy;\n+import static java.util.Objects.requireNonNull;\n \n public class PruneTableScanColumns\n         extends ProjectOffPushDownRule<TableScanNode>\n {\n-    public PruneTableScanColumns()\n+    private final Metadata metadata;\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n     {\n         super(tableScan());\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n     }\n \n     @Override\n-    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode tableScanNode, Set<Symbol> referencedOutputs)\n+    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode node, Set<Symbol> referencedOutputs)\n     {\n-        return Optional.of(\n-                new TableScanNode(\n-                        tableScanNode.getId(),\n-                        tableScanNode.getTable(),\n-                        filteredCopy(tableScanNode.getOutputSymbols(), referencedOutputs::contains),\n-                        filterKeys(tableScanNode.getAssignments(), referencedOutputs::contains),\n-                        tableScanNode.getEnforcedConstraint()));\n+        Session session = context.getSession();\n+        TypeProvider types = context.getSymbolAllocator().getTypes();\n+\n+        return pruneColumns(metadata, typeAnalyzer, types, session, node, referencedOutputs);\n+    }\n+\n+    public static Optional<PlanNode> pruneColumns(Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, Session session, TableScanNode node, Set<Symbol> referencedOutputs)\n+    {\n+        List<Symbol> newOutputs = filteredCopy(node.getOutputSymbols(), referencedOutputs::contains);\n+\n+        if (newOutputs.size() == node.getOutputSymbols().size()) {\n+            return Optional.empty();\n+        }\n+\n+        List<ConnectorExpression> projections = newOutputs.stream()\n+                .map(Symbol::toSymbolReference)\n+                .map(expression -> ConnectorExpressionTranslator.translate(\n+                        session,\n+                        expression,\n+                        typeAnalyzer,\n+                        types))\n+                .map(Optional::get)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3MTE3NDY4", "url": "https://github.com/trinodb/trino/pull/3305#pullrequestreview-387117468", "createdAt": "2020-04-03T09:57:43Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTo1Nzo0M1rOGAOtLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTo1Nzo0M1rOGAOtLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5NDEyNw==", "bodyText": "#3324 prevents NPE here.", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402894127", "createdAt": "2020-04-03T09:57:43Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -13,34 +13,108 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.TypeProvider;\n import io.prestosql.sql.planner.plan.PlanNode;\n import io.prestosql.sql.planner.plan.TableScanNode;\n \n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n \n-import static com.google.common.collect.Maps.filterKeys;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n import static io.prestosql.util.MoreLists.filteredCopy;\n+import static java.util.Objects.requireNonNull;\n \n public class PruneTableScanColumns\n         extends ProjectOffPushDownRule<TableScanNode>\n {\n-    public PruneTableScanColumns()\n+    private final Metadata metadata;\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n     {\n         super(tableScan());\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n     }\n \n     @Override\n-    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode tableScanNode, Set<Symbol> referencedOutputs)\n+    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode node, Set<Symbol> referencedOutputs)\n     {\n-        return Optional.of(\n-                new TableScanNode(\n-                        tableScanNode.getId(),\n-                        tableScanNode.getTable(),\n-                        filteredCopy(tableScanNode.getOutputSymbols(), referencedOutputs::contains),\n-                        filterKeys(tableScanNode.getAssignments(), referencedOutputs::contains),\n-                        tableScanNode.getEnforcedConstraint()));\n+        Session session = context.getSession();\n+        TypeProvider types = context.getSymbolAllocator().getTypes();\n+\n+        return pruneColumns(metadata, typeAnalyzer, types, session, node, referencedOutputs);\n+    }\n+\n+    public static Optional<PlanNode> pruneColumns(Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, Session session, TableScanNode node, Set<Symbol> referencedOutputs)\n+    {\n+        List<Symbol> newOutputs = filteredCopy(node.getOutputSymbols(), referencedOutputs::contains);\n+\n+        if (newOutputs.size() == node.getOutputSymbols().size()) {\n+            return Optional.empty();\n+        }\n+\n+        List<ConnectorExpression> projections = newOutputs.stream()\n+                .map(Symbol::toSymbolReference)\n+                .map(expression -> ConnectorExpressionTranslator.translate(\n+                        session,\n+                        expression,\n+                        typeAnalyzer,\n+                        types))\n+                .map(Optional::get)\n+                .collect(toImmutableList());\n+\n+        TableHandle handle = node.getTable();\n+        Optional<ProjectionApplicationResult<TableHandle>> result = metadata.applyProjection(\n+                session,\n+                handle,\n+                projections,\n+                newOutputs.stream()\n+                        .collect(toImmutableMap(Symbol::getName, node.getAssignments()::get)));\n+\n+        Map<Symbol, ColumnHandle> newAssignments;\n+        // Attempt to push down the constrained list of columns into the connector.\n+        // Bail out if the connector does anything other than limit the list of columns (e.g., if it synthesizes arbitrary expressions)\n+        if (result.isPresent() && result.get().getProjections().stream().allMatch(Variable.class::isInstance)) {\n+            handle = result.get().getHandle();\n+\n+            Map<String, ColumnHandle> assignments = result.get().getAssignments().stream()\n+                    .collect(toImmutableMap(ProjectionApplicationResult.Assignment::getVariable, ProjectionApplicationResult.Assignment::getColumn));\n+\n+            ImmutableMap.Builder<Symbol, ColumnHandle> builder = ImmutableMap.builder();\n+            for (int i = 0; i < newOutputs.size(); i++) {\n+                Variable variable = (Variable) result.get().getProjections().get(i);\n+                builder.put(newOutputs.get(i), assignments.get(variable.getName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 101}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NTc3MjU4", "url": "https://github.com/trinodb/trino/pull/3305#pullrequestreview-387577258", "createdAt": "2020-04-03T21:00:15Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79d2872545279db7ebae6aa2c8ef7b678c58ced5", "author": {"user": {"login": "martint", "name": "Martin Traverso"}}, "url": "https://github.com/trinodb/trino/commit/79d2872545279db7ebae6aa2c8ef7b678c58ced5", "committedDate": "2020-04-03T21:27:25Z", "message": "Call applyProjection during table scan column pruning\n\nThe existing code was limiting the columns in the TableScan node\nbut wasn't providing this information to connectors. Some connectors\ncan leverage this information during split generation."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "79d2872545279db7ebae6aa2c8ef7b678c58ced5", "author": {"user": {"login": "martint", "name": "Martin Traverso"}}, "url": "https://github.com/trinodb/trino/commit/79d2872545279db7ebae6aa2c8ef7b678c58ced5", "committedDate": "2020-04-03T21:27:25Z", "message": "Call applyProjection during table scan column pruning\n\nThe existing code was limiting the columns in the TableScan node\nbut wasn't providing this information to connectors. Some connectors\ncan leverage this information during split generation."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1701, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}