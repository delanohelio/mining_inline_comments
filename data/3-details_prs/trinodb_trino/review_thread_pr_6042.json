{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI1MTg5NDUy", "number": 6042, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMTowNDo0NVrOE_zxWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0xMC0wMVQwMDozMTo0MFrOG18BNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MzQzOTYyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AggregationFromAnnotationsParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMTowNDo0NVrOH9uF9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMTowNDo0NVrOH9uF9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ4MDM3NQ==", "bodyText": "for consistency, maybe call \"toParse\" => \"outputFunction\" or \"outputFunctionToParse? especially since you are calling getName and getAliases functions that require that input", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r534480375", "createdAt": "2020-12-02T21:04:45Z", "author": {"login": "erichwang"}, "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AggregationFromAnnotationsParser.java", "diffHunk": "@@ -70,89 +70,104 @@ public static ParametricAggregation parseFunctionDefinitionWithTypesConstraint(C\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        ImmutableList.Builder<ParametricAggregation> builder = ImmutableList.builder();\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n-                for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                    Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                    for (AggregationHeader header : parseHeaders(aggregationDefinition, outputFunction)) {\n-                        AggregationImplementation onlyImplementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                        ParametricImplementationsGroup<AggregationImplementation> implementations = ParametricImplementationsGroup.of(onlyImplementation);\n-                        builder.add(new ParametricAggregation(implementations.getSignature(), header, implementations, deprecated));\n-                    }\n+\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        Class<?> stateClass = getStateClass(aggregationDefinition);\n+        Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n+        for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n+            AggregationHeader header = parseHeader(aggregationDefinition, outputFunction);\n+\n+            List<AggregationImplementation> exactImplementations = new ArrayList<>();\n+            List<AggregationImplementation> nonExactImplementations = new ArrayList<>();\n+            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n+                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n+                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header.getName(), inputFunction, removeInputFunction, outputFunction, combineFunction);\n+                if (isExact(implementation.getSignature())) {\n+                    exactImplementations.add(implementation);\n+                }\n+                else {\n+                    nonExactImplementations.add(implementation);\n                 }\n             }\n+\n+            functions.addAll(buildFunctions(header.getName(), header, stateClass, exactImplementations, nonExactImplementations));\n+            for (String alias : getAliases(aggregationDefinition.getAnnotation(AggregationFunction.class), outputFunction)) {\n+                functions.addAll(buildFunctions(alias, header, stateClass, exactImplementations, nonExactImplementations));\n+            }\n         }\n \n-        return builder.build();\n+        return functions.build();\n     }\n \n-    public static ParametricAggregation parseFunctionDefinition(Class<?> aggregationDefinition)\n+    private static List<ParametricAggregation> buildFunctions(\n+            String name,\n+            AggregationHeader header,\n+            Class<?> stateClass,\n+            List<AggregationImplementation> exactImplementations,\n+            List<AggregationImplementation> nonExactImplementations)\n     {\n-        ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n-        AggregationHeader header = parseHeader(aggregationDefinition);\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            Method outputFunction = getOnlyElement(getOutputFunctions(aggregationDefinition, stateClass));\n-            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                implementationsBuilder.addImplementation(implementation);\n-            }\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // create a separate function for each exact implementation\n+        for (AggregationImplementation exactImplementation : exactImplementations) {\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, exactImplementation.getSignature()),\n+                    header,\n+                    stateClass,\n+                    ParametricImplementationsGroup.of(exactImplementation).withAlias(name)));\n         }\n+        // if there are non-exact functions, create a generic function\n+        if (!nonExactImplementations.isEmpty()) {\n+            ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n+            nonExactImplementations.forEach(implementationsBuilder::addImplementation);\n+            ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, implementations.getSignature()),\n+                    header,\n+                    stateClass,\n+                    implementations.withAlias(name)));\n+        }\n+        return functions.build();\n+    }\n \n-        ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n-        return new ParametricAggregation(implementations.getSignature(), header, implementations, deprecated);\n+    private static boolean isExact(Signature signature)\n+    {\n+        return signature.getTypeVariableConstraints().isEmpty()\n+                && signature.getArgumentTypes().stream().noneMatch(TypeSignature::isCalculated)\n+                && !signature.getReturnType().isCalculated();\n     }\n \n-    private static AggregationHeader parseHeader(AnnotatedElement aggregationDefinition)\n+    private static AggregationHeader parseHeader(AnnotatedElement aggregationDefinition, AnnotatedElement toParse)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NDE1Mzg5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AbstractMinMaxAggregationFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMTowMzoyM1rOH90rcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMTowMzoyM1rOH90rcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU4ODI3NA==", "bodyText": "Typo in commit message \"aggergation\" => \"aggregation\"", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r534588274", "createdAt": "2020-12-03T01:03:23Z", "author": {"login": "erichwang"}, "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AbstractMinMaxAggregationFunction.java", "diffHunk": "@@ -26,9 +26,12 @@\n import io.prestosql.operator.aggregation.AggregationMetadata.AccumulatorStateDescriptor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NDE1NTU4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/metadata/FunctionListBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMTowNDowNVrOH90sdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMTowNDowNVrOH90sdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU4ODUzNQ==", "bodyText": "Typo in commit message \"aggergation\" => \"aggregation\"", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r534588535", "createdAt": "2020-12-03T01:04:05Z", "author": {"login": "erichwang"}, "path": "presto-main/src/main/java/io/prestosql/metadata/FunctionListBuilder.java", "diffHunk": "@@ -33,12 +33,6 @@ public FunctionListBuilder window(Class<? extends WindowFunction> clazz)\n         return this;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NDE1NzA3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/metadata/AggregationFunctionMetadata.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMTowNDozNVrOH90tUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMTowNDozNVrOH90tUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU4ODc1Mg==", "bodyText": "Commit message type: \"genertic\" => \"generic\"", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r534588752", "createdAt": "2020-12-03T01:04:35Z", "author": {"login": "erichwang"}, "path": "presto-main/src/main/java/io/prestosql/metadata/AggregationFunctionMetadata.java", "diffHunk": "@@ -13,18 +13,39 @@\n  */", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MDIyNjQ4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/ParametricImplementationsGroup.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMDoyODoxMVrOH-wr5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMDoyODoxMVrOH-wr5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU3MTQzMQ==", "bodyText": "@SuppressWarnings(\"unchecked\")", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535571431", "createdAt": "2020-12-03T20:28:11Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/ParametricImplementationsGroup.java", "diffHunk": "@@ -114,6 +118,30 @@ public Signature getSignature()\n         return signature;\n     }\n \n+    public ParametricImplementationsGroup<T> withAlias(String alias)\n+    {\n+        if (alias.equals(signature.getName())) {\n+            return this;\n+        }\n+        return new ParametricImplementationsGroup<T>(\n+                exactImplementations.values().stream()\n+                        .map(implementation -> withAlias(alias, implementation))\n+                        .collect(toImmutableMap(T::getSignature, Function.identity())),\n+                specializedImplementations.stream()\n+                        .map(implementation1 -> withAlias(alias, implementation1))\n+                        .collect(toImmutableList()),\n+                genericImplementations.stream()\n+                        .map(implementation2 -> this.withAlias(alias, implementation2))\n+                        .collect(toImmutableList()),\n+                signatureWithName(alias, signature));\n+    }\n+\n+    private T withAlias(String name, T implementation)\n+    {\n+        //noinspection unchecked", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MDI4MTYzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/ParametricImplementationsGroup.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMDozNjozMVrOH-xPWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMDozNjozMVrOH-xPWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU4MDUwNA==", "bodyText": "This method can be static.\n(BTW, it's not clear to me why this class has to be generic, but I haven't looked at all the uses)", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535580504", "createdAt": "2020-12-03T20:36:31Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/ParametricImplementationsGroup.java", "diffHunk": "@@ -114,6 +118,30 @@ public Signature getSignature()\n         return signature;\n     }\n \n+    public ParametricImplementationsGroup<T> withAlias(String alias)\n+    {\n+        if (alias.equals(signature.getName())) {\n+            return this;\n+        }\n+        return new ParametricImplementationsGroup<T>(\n+                exactImplementations.values().stream()\n+                        .map(implementation -> withAlias(alias, implementation))\n+                        .collect(toImmutableMap(T::getSignature, Function.identity())),\n+                specializedImplementations.stream()\n+                        .map(implementation1 -> withAlias(alias, implementation1))\n+                        .collect(toImmutableList()),\n+                genericImplementations.stream()\n+                        .map(implementation2 -> this.withAlias(alias, implementation2))\n+                        .collect(toImmutableList()),\n+                signatureWithName(alias, signature));\n+    }\n+\n+    private T withAlias(String name, T implementation)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MDI4MzYyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/ParametricImplementationsGroup.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMDozNjo0OFrOH-xQtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMDozNjo0OFrOH-xQtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU4MDg1Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    .map(implementation1 -> withAlias(alias, implementation1))\n          \n          \n            \n                                    .map(implementation -> withAlias(alias, implementation))", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535580852", "createdAt": "2020-12-03T20:36:48Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/ParametricImplementationsGroup.java", "diffHunk": "@@ -114,6 +118,30 @@ public Signature getSignature()\n         return signature;\n     }\n \n+    public ParametricImplementationsGroup<T> withAlias(String alias)\n+    {\n+        if (alias.equals(signature.getName())) {\n+            return this;\n+        }\n+        return new ParametricImplementationsGroup<T>(\n+                exactImplementations.values().stream()\n+                        .map(implementation -> withAlias(alias, implementation))\n+                        .collect(toImmutableMap(T::getSignature, Function.identity())),\n+                specializedImplementations.stream()\n+                        .map(implementation1 -> withAlias(alias, implementation1))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MDI4Nzc2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/ParametricImplementationsGroup.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMDozNzoxOVrOH-xTMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMDozNzoxOVrOH-xTMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU4MTQ4OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    .map(implementation2 -> this.withAlias(alias, implementation2))\n          \n          \n            \n                                    .map(implementation -> withAlias(alias, implementation))", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535581489", "createdAt": "2020-12-03T20:37:19Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/ParametricImplementationsGroup.java", "diffHunk": "@@ -114,6 +118,30 @@ public Signature getSignature()\n         return signature;\n     }\n \n+    public ParametricImplementationsGroup<T> withAlias(String alias)\n+    {\n+        if (alias.equals(signature.getName())) {\n+            return this;\n+        }\n+        return new ParametricImplementationsGroup<T>(\n+                exactImplementations.values().stream()\n+                        .map(implementation -> withAlias(alias, implementation))\n+                        .collect(toImmutableMap(T::getSignature, Function.identity())),\n+                specializedImplementations.stream()\n+                        .map(implementation1 -> withAlias(alias, implementation1))\n+                        .collect(toImmutableList()),\n+                genericImplementations.stream()\n+                        .map(implementation2 -> this.withAlias(alias, implementation2))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MDY4NzMxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AggregationFromAnnotationsParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMTozNTowMlrOH-1TCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMDozMDowNVrOIBBNOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY0Njk4NQ==", "bodyText": "I'm not sure I understand what notion this method is trying to capture (and hence, whether isExact is a good name for it)", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535646985", "createdAt": "2020-12-03T21:35:02Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AggregationFromAnnotationsParser.java", "diffHunk": "@@ -70,89 +70,104 @@ public static ParametricAggregation parseFunctionDefinitionWithTypesConstraint(C\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        ImmutableList.Builder<ParametricAggregation> builder = ImmutableList.builder();\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n-                for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                    Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                    for (AggregationHeader header : parseHeaders(aggregationDefinition, outputFunction)) {\n-                        AggregationImplementation onlyImplementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                        ParametricImplementationsGroup<AggregationImplementation> implementations = ParametricImplementationsGroup.of(onlyImplementation);\n-                        builder.add(new ParametricAggregation(implementations.getSignature(), header, implementations, deprecated));\n-                    }\n+\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        Class<?> stateClass = getStateClass(aggregationDefinition);\n+        Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n+        for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n+            AggregationHeader header = parseHeader(aggregationDefinition, outputFunction);\n+\n+            List<AggregationImplementation> exactImplementations = new ArrayList<>();\n+            List<AggregationImplementation> nonExactImplementations = new ArrayList<>();\n+            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n+                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n+                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header.getName(), inputFunction, removeInputFunction, outputFunction, combineFunction);\n+                if (isExact(implementation.getSignature())) {\n+                    exactImplementations.add(implementation);\n+                }\n+                else {\n+                    nonExactImplementations.add(implementation);\n                 }\n             }\n+\n+            functions.addAll(buildFunctions(header.getName(), header, stateClass, exactImplementations, nonExactImplementations));\n+            for (String alias : getAliases(aggregationDefinition.getAnnotation(AggregationFunction.class), outputFunction)) {\n+                functions.addAll(buildFunctions(alias, header, stateClass, exactImplementations, nonExactImplementations));\n+            }\n         }\n \n-        return builder.build();\n+        return functions.build();\n     }\n \n-    public static ParametricAggregation parseFunctionDefinition(Class<?> aggregationDefinition)\n+    private static List<ParametricAggregation> buildFunctions(\n+            String name,\n+            AggregationHeader header,\n+            Class<?> stateClass,\n+            List<AggregationImplementation> exactImplementations,\n+            List<AggregationImplementation> nonExactImplementations)\n     {\n-        ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n-        AggregationHeader header = parseHeader(aggregationDefinition);\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            Method outputFunction = getOnlyElement(getOutputFunctions(aggregationDefinition, stateClass));\n-            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                implementationsBuilder.addImplementation(implementation);\n-            }\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // create a separate function for each exact implementation\n+        for (AggregationImplementation exactImplementation : exactImplementations) {\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, exactImplementation.getSignature()),\n+                    header,\n+                    stateClass,\n+                    ParametricImplementationsGroup.of(exactImplementation).withAlias(name)));\n         }\n+        // if there are non-exact functions, create a generic function\n+        if (!nonExactImplementations.isEmpty()) {\n+            ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n+            nonExactImplementations.forEach(implementationsBuilder::addImplementation);\n+            ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, implementations.getSignature()),\n+                    header,\n+                    stateClass,\n+                    implementations.withAlias(name)));\n+        }\n+        return functions.build();\n+    }\n \n-        ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n-        return new ParametricAggregation(implementations.getSignature(), header, implementations, deprecated);\n+    private static boolean isExact(Signature signature)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzOTI1Nw==", "bodyText": "The annotated function framework handles exact functions (by this definition) differently than generic functions, so we have to split them.", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r537939257", "createdAt": "2020-12-08T00:30:05Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AggregationFromAnnotationsParser.java", "diffHunk": "@@ -70,89 +70,104 @@ public static ParametricAggregation parseFunctionDefinitionWithTypesConstraint(C\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        ImmutableList.Builder<ParametricAggregation> builder = ImmutableList.builder();\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n-                for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                    Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                    for (AggregationHeader header : parseHeaders(aggregationDefinition, outputFunction)) {\n-                        AggregationImplementation onlyImplementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                        ParametricImplementationsGroup<AggregationImplementation> implementations = ParametricImplementationsGroup.of(onlyImplementation);\n-                        builder.add(new ParametricAggregation(implementations.getSignature(), header, implementations, deprecated));\n-                    }\n+\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        Class<?> stateClass = getStateClass(aggregationDefinition);\n+        Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n+        for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n+            AggregationHeader header = parseHeader(aggregationDefinition, outputFunction);\n+\n+            List<AggregationImplementation> exactImplementations = new ArrayList<>();\n+            List<AggregationImplementation> nonExactImplementations = new ArrayList<>();\n+            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n+                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n+                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header.getName(), inputFunction, removeInputFunction, outputFunction, combineFunction);\n+                if (isExact(implementation.getSignature())) {\n+                    exactImplementations.add(implementation);\n+                }\n+                else {\n+                    nonExactImplementations.add(implementation);\n                 }\n             }\n+\n+            functions.addAll(buildFunctions(header.getName(), header, stateClass, exactImplementations, nonExactImplementations));\n+            for (String alias : getAliases(aggregationDefinition.getAnnotation(AggregationFunction.class), outputFunction)) {\n+                functions.addAll(buildFunctions(alias, header, stateClass, exactImplementations, nonExactImplementations));\n+            }\n         }\n \n-        return builder.build();\n+        return functions.build();\n     }\n \n-    public static ParametricAggregation parseFunctionDefinition(Class<?> aggregationDefinition)\n+    private static List<ParametricAggregation> buildFunctions(\n+            String name,\n+            AggregationHeader header,\n+            Class<?> stateClass,\n+            List<AggregationImplementation> exactImplementations,\n+            List<AggregationImplementation> nonExactImplementations)\n     {\n-        ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n-        AggregationHeader header = parseHeader(aggregationDefinition);\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            Method outputFunction = getOnlyElement(getOutputFunctions(aggregationDefinition, stateClass));\n-            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                implementationsBuilder.addImplementation(implementation);\n-            }\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // create a separate function for each exact implementation\n+        for (AggregationImplementation exactImplementation : exactImplementations) {\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, exactImplementation.getSignature()),\n+                    header,\n+                    stateClass,\n+                    ParametricImplementationsGroup.of(exactImplementation).withAlias(name)));\n         }\n+        // if there are non-exact functions, create a generic function\n+        if (!nonExactImplementations.isEmpty()) {\n+            ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n+            nonExactImplementations.forEach(implementationsBuilder::addImplementation);\n+            ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, implementations.getSignature()),\n+                    header,\n+                    stateClass,\n+                    implementations.withAlias(name)));\n+        }\n+        return functions.build();\n+    }\n \n-        ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n-        return new ParametricAggregation(implementations.getSignature(), header, implementations, deprecated);\n+    private static boolean isExact(Signature signature)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY0Njk4NQ=="}, "originalCommit": null, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MDczMDkxOnYy", "diffSide": "LEFT", "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AbstractMinMaxAggregationFunction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMTo0MjoyMFrOH-1vKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMDoyOTowMFrOIBBLPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1NDE4NA==", "bodyText": "Should we get rid of these classes? There shouldn't be any reason to keep them around now that there's a replacement, no?", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535654184", "createdAt": "2020-12-03T21:42:20Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AbstractMinMaxAggregationFunction.java", "diffHunk": "@@ -26,9 +26,12 @@\n import io.prestosql.operator.aggregation.AggregationMetadata.AccumulatorStateDescriptor;\n import io.prestosql.operator.aggregation.state.BlockPositionState;\n import io.prestosql.operator.aggregation.state.BlockPositionStateSerializer;\n-import io.prestosql.operator.aggregation.state.NullableBooleanState;\n-import io.prestosql.operator.aggregation.state.NullableDoubleState;\n-import io.prestosql.operator.aggregation.state.NullableLongState;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzODc1MQ==", "bodyText": "They are used in other places where the new classes won't work", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r537938751", "createdAt": "2020-12-08T00:29:00Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AbstractMinMaxAggregationFunction.java", "diffHunk": "@@ -26,9 +26,12 @@\n import io.prestosql.operator.aggregation.AggregationMetadata.AccumulatorStateDescriptor;\n import io.prestosql.operator.aggregation.state.BlockPositionState;\n import io.prestosql.operator.aggregation.state.BlockPositionStateSerializer;\n-import io.prestosql.operator.aggregation.state.NullableBooleanState;\n-import io.prestosql.operator.aggregation.state.NullableDoubleState;\n-import io.prestosql.operator.aggregation.state.NullableLongState;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1NDE4NA=="}, "originalCommit": null, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MDc0Nzg5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/metadata/AggregationFunctionMetadata.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMTo0NToxM1rOH-16Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMDoyODoyMlrOIBBKNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1NzAyNw==", "bodyText": "How can an aggregation not have an intermediate type?", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535657027", "createdAt": "2020-12-03T21:45:13Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/AggregationFunctionMetadata.java", "diffHunk": "@@ -13,18 +13,39 @@\n  */\n package io.prestosql.metadata;\n \n+import io.prestosql.spi.type.StandardTypes;\n import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.TypeSignatureParameter;\n \n+import java.util.Arrays;\n import java.util.Optional;\n \n import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static java.util.Objects.requireNonNull;\n \n public class AggregationFunctionMetadata\n {\n     private final boolean orderSensitive;\n     private final Optional<TypeSignature> intermediateType;\n \n+    public AggregationFunctionMetadata(boolean orderSensitive, TypeSignature... intermediateTypes)\n+    {\n+        this.orderSensitive = orderSensitive;\n+\n+        if (intermediateTypes.length == 0) {\n+            intermediateType = Optional.empty();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzODQ4NQ==", "bodyText": "non-decomposable aggregations do not have intermediates", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r537938485", "createdAt": "2020-12-08T00:28:22Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/metadata/AggregationFunctionMetadata.java", "diffHunk": "@@ -13,18 +13,39 @@\n  */\n package io.prestosql.metadata;\n \n+import io.prestosql.spi.type.StandardTypes;\n import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.TypeSignatureParameter;\n \n+import java.util.Arrays;\n import java.util.Optional;\n \n import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static java.util.Objects.requireNonNull;\n \n public class AggregationFunctionMetadata\n {\n     private final boolean orderSensitive;\n     private final Optional<TypeSignature> intermediateType;\n \n+    public AggregationFunctionMetadata(boolean orderSensitive, TypeSignature... intermediateTypes)\n+    {\n+        this.orderSensitive = orderSensitive;\n+\n+        if (intermediateTypes.length == 0) {\n+            intermediateType = Optional.empty();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1NzAyNw=="}, "originalCommit": null, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MDc2NDc1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/metadata/AggregationFunctionMetadata.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMTo0NzozM1rOH-2FMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMDozMDoyN1rOIBBNzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1OTgyNw==", "bodyText": "I think it'd be cleaner, more explicit, and symmetric (what gets passed here would match what gets returned by getIntermediateType() below) to take a single type here and make the caller build a row type if necessary. That could be done with a helper function on the caller side.", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535659827", "createdAt": "2020-12-03T21:47:33Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/metadata/AggregationFunctionMetadata.java", "diffHunk": "@@ -13,18 +13,39 @@\n  */\n package io.prestosql.metadata;\n \n+import io.prestosql.spi.type.StandardTypes;\n import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.TypeSignatureParameter;\n \n+import java.util.Arrays;\n import java.util.Optional;\n \n import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static java.util.Objects.requireNonNull;\n \n public class AggregationFunctionMetadata\n {\n     private final boolean orderSensitive;\n     private final Optional<TypeSignature> intermediateType;\n \n+    public AggregationFunctionMetadata(boolean orderSensitive, TypeSignature... intermediateTypes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzOTQwNg==", "bodyText": "This is a setup for future work", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r537939406", "createdAt": "2020-12-08T00:30:27Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/metadata/AggregationFunctionMetadata.java", "diffHunk": "@@ -13,18 +13,39 @@\n  */\n package io.prestosql.metadata;\n \n+import io.prestosql.spi.type.StandardTypes;\n import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.TypeSignatureParameter;\n \n+import java.util.Arrays;\n import java.util.Optional;\n \n import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static java.util.Objects.requireNonNull;\n \n public class AggregationFunctionMetadata\n {\n     private final boolean orderSensitive;\n     private final Optional<TypeSignature> intermediateType;\n \n+    public AggregationFunctionMetadata(boolean orderSensitive, TypeSignature... intermediateTypes)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1OTgyNw=="}, "originalCommit": null, "originalPosition": 20}]}}, {"id": "PRRT_kwDOCezRTs4bXv9g", "diffSide": "RIGHT", "path": "core/trino-main/src/main/java/io/trino/operator/aggregation/AggregationFromAnnotationsParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0xMC0wMVQwMDoyOTozMVrOKugxow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0xMC0wMVQwMDoyOTozMVrOKugxow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "PRRC_kwDOCezRTs4q6DGj", "bodyText": "This needs a better name. If you can you describe what concept this represents I can help come up with another name.", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r719860131", "createdAt": "2021-10-01T00:29:31Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/operator/aggregation/AggregationFromAnnotationsParser.java", "diffHunk": "@@ -72,101 +70,112 @@ public static ParametricAggregation parseFunctionDefinitionWithTypesConstraint(C\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        ImmutableList.Builder<ParametricAggregation> builder = ImmutableList.builder();\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n-                for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                    Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                    for (AggregationHeader header : parseHeaders(aggregationDefinition, outputFunction)) {\n-                        AggregationImplementation onlyImplementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                        ParametricImplementationsGroup<AggregationImplementation> implementations = ParametricImplementationsGroup.of(onlyImplementation);\n-                        builder.add(new ParametricAggregation(signatureWithName(header.getName(), implementations.getSignature()), header, implementations, deprecated));\n-                    }\n+\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // There must be a single state class and combine function\n+        Class<?> stateClass = getStateClass(aggregationDefinition);\n+        Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n+\n+        // Each output function defines a new aggregation function\n+        for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n+            AggregationHeader header = parseHeader(aggregationDefinition, outputFunction);\n+\n+            // Input functions can have either an exact signature, or generic/calculate signature\n+            List<AggregationImplementation> exactImplementations = new ArrayList<>();\n+            List<AggregationImplementation> nonExactImplementations = new ArrayList<>();\n+            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n+                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n+                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header.getName(), inputFunction, removeInputFunction, outputFunction, combineFunction);\n+                if (isExact(implementation.getSignature())) {\n+                    exactImplementations.add(implementation);\n+                }\n+                else {\n+                    nonExactImplementations.add(implementation);\n                 }\n             }\n+\n+            // register a set functions for the canonical name, and each alias\n+            functions.addAll(buildFunctions(header.getName(), header, stateClass, exactImplementations, nonExactImplementations));\n+            for (String alias : getAliases(aggregationDefinition.getAnnotation(AggregationFunction.class), outputFunction)) {\n+                functions.addAll(buildFunctions(alias, header, stateClass, exactImplementations, nonExactImplementations));\n+            }\n         }\n \n-        return builder.build();\n+        return functions.build();\n     }\n \n-    public static ParametricAggregation parseFunctionDefinition(Class<?> aggregationDefinition)\n+    private static List<ParametricAggregation> buildFunctions(\n+            String name,\n+            AggregationHeader header,\n+            Class<?> stateClass,\n+            List<AggregationImplementation> exactImplementations,\n+            List<AggregationImplementation> nonExactImplementations)\n     {\n-        ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n-        AggregationHeader header = parseHeader(aggregationDefinition);\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // create a separate function for each exact implementation\n+        for (AggregationImplementation exactImplementation : exactImplementations) {\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, exactImplementation.getSignature()),\n+                    header,\n+                    stateClass,\n+                    ParametricImplementationsGroup.of(exactImplementation).withAlias(name)));\n+        }\n \n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            Method outputFunction = getOnlyElement(getOutputFunctions(aggregationDefinition, stateClass));\n-            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                implementationsBuilder.addImplementation(implementation);\n-            }\n+        // if there are non-exact functions, create a single generic/calculated function using these implementations\n+        if (!nonExactImplementations.isEmpty()) {\n+            ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n+            nonExactImplementations.forEach(implementationsBuilder::addImplementation);\n+            ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, implementations.getSignature()),\n+                    header,\n+                    stateClass,\n+                    implementations.withAlias(name)));\n         }\n \n-        ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n-        return new ParametricAggregation(signatureWithName(header.getName(), implementations.getSignature()), header, implementations, deprecated);\n+        return functions.build();\n+    }\n+\n+    private static boolean isExact(Signature signature)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8317c1c369ef96fce3ed80347f87aba5a8f08b9d"}, "originalPosition": 121}]}}, {"id": "PRRT_kwDOCezRTs4bXwE1", "diffSide": "RIGHT", "path": "core/trino-main/src/main/java/io/trino/operator/aggregation/AggregationFromAnnotationsParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0xMC0wMVQwMDozMTo0MFrOKug0LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0xMC0wMVQwMDozMTo0MFrOKug0LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "PRRC_kwDOCezRTs4q6DQs", "bodyText": "Move arguments to the same line", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r719860780", "createdAt": "2021-10-01T00:31:40Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/operator/aggregation/AggregationFromAnnotationsParser.java", "diffHunk": "@@ -72,101 +70,112 @@ public static ParametricAggregation parseFunctionDefinitionWithTypesConstraint(C\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        ImmutableList.Builder<ParametricAggregation> builder = ImmutableList.builder();\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n-                for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                    Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                    for (AggregationHeader header : parseHeaders(aggregationDefinition, outputFunction)) {\n-                        AggregationImplementation onlyImplementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                        ParametricImplementationsGroup<AggregationImplementation> implementations = ParametricImplementationsGroup.of(onlyImplementation);\n-                        builder.add(new ParametricAggregation(signatureWithName(header.getName(), implementations.getSignature()), header, implementations, deprecated));\n-                    }\n+\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // There must be a single state class and combine function\n+        Class<?> stateClass = getStateClass(aggregationDefinition);\n+        Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n+\n+        // Each output function defines a new aggregation function\n+        for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n+            AggregationHeader header = parseHeader(aggregationDefinition, outputFunction);\n+\n+            // Input functions can have either an exact signature, or generic/calculate signature\n+            List<AggregationImplementation> exactImplementations = new ArrayList<>();\n+            List<AggregationImplementation> nonExactImplementations = new ArrayList<>();\n+            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n+                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n+                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header.getName(), inputFunction, removeInputFunction, outputFunction, combineFunction);\n+                if (isExact(implementation.getSignature())) {\n+                    exactImplementations.add(implementation);\n+                }\n+                else {\n+                    nonExactImplementations.add(implementation);\n                 }\n             }\n+\n+            // register a set functions for the canonical name, and each alias\n+            functions.addAll(buildFunctions(header.getName(), header, stateClass, exactImplementations, nonExactImplementations));\n+            for (String alias : getAliases(aggregationDefinition.getAnnotation(AggregationFunction.class), outputFunction)) {\n+                functions.addAll(buildFunctions(alias, header, stateClass, exactImplementations, nonExactImplementations));\n+            }\n         }\n \n-        return builder.build();\n+        return functions.build();\n     }\n \n-    public static ParametricAggregation parseFunctionDefinition(Class<?> aggregationDefinition)\n+    private static List<ParametricAggregation> buildFunctions(\n+            String name,\n+            AggregationHeader header,\n+            Class<?> stateClass,\n+            List<AggregationImplementation> exactImplementations,\n+            List<AggregationImplementation> nonExactImplementations)\n     {\n-        ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n-        AggregationHeader header = parseHeader(aggregationDefinition);\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // create a separate function for each exact implementation\n+        for (AggregationImplementation exactImplementation : exactImplementations) {\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, exactImplementation.getSignature()),\n+                    header,\n+                    stateClass,\n+                    ParametricImplementationsGroup.of(exactImplementation).withAlias(name)));\n+        }\n \n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            Method outputFunction = getOnlyElement(getOutputFunctions(aggregationDefinition, stateClass));\n-            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                implementationsBuilder.addImplementation(implementation);\n-            }\n+        // if there are non-exact functions, create a single generic/calculated function using these implementations\n+        if (!nonExactImplementations.isEmpty()) {\n+            ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n+            nonExactImplementations.forEach(implementationsBuilder::addImplementation);\n+            ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, implementations.getSignature()),\n+                    header,\n+                    stateClass,\n+                    implementations.withAlias(name)));\n         }\n \n-        ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n-        return new ParametricAggregation(signatureWithName(header.getName(), implementations.getSignature()), header, implementations, deprecated);\n+        return functions.build();\n+    }\n+\n+    private static boolean isExact(Signature signature)\n+    {\n+        return signature.getTypeVariableConstraints().isEmpty()\n+                && signature.getArgumentTypes().stream().noneMatch(TypeSignature::isCalculated)\n+                && !signature.getReturnType().isCalculated();\n     }\n \n-    private static AggregationHeader parseHeader(AnnotatedElement aggregationDefinition)\n+    private static AggregationHeader parseHeader(AnnotatedElement aggregationDefinition, AnnotatedElement outputFunction)\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n+        String name = getName(aggregationAnnotation, outputFunction);\n         return new AggregationHeader(\n-                aggregationAnnotation.value(),\n-                aggregationAnnotation.value(),\n-                parseDescription(aggregationDefinition),\n+                name,\n+                parseDescription(aggregationDefinition, outputFunction),\n                 aggregationAnnotation.decomposable(),\n                 aggregationAnnotation.isOrderSensitive(),\n-                aggregationAnnotation.hidden());\n+                aggregationAnnotation.hidden(),\n+                aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0);\n     }\n \n-    private static List<AggregationHeader> parseHeaders(AnnotatedElement aggregationDefinition, AnnotatedElement toParse)\n+    private static String getName(AggregationFunction aggregationAnnotation, AnnotatedElement outputFunction)\n     {\n-        AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n-\n-        return getNames(toParse, aggregationAnnotation).stream()\n-                .map(aggregationFunctionName ->\n-                        new AggregationHeader(\n-                                aggregationFunctionName.getActualName(),\n-                                aggregationFunctionName.getCanonicalName(),\n-                                parseDescription(aggregationDefinition, toParse),\n-                                aggregationAnnotation.decomposable(),\n-                                aggregationAnnotation.isOrderSensitive(),\n-                                aggregationAnnotation.hidden()))\n-                .collect(toImmutableList());\n+        AggregationFunction annotation = outputFunction.getAnnotation(AggregationFunction.class);\n+        if (annotation != null && !annotation.value().isEmpty()) {\n+            return emptyToNull(annotation.value());\n+        }\n+        return emptyToNull(aggregationAnnotation.value());\n     }\n \n-    private static List<AggregationFunctionName> getNames(@Nullable AnnotatedElement outputFunction, AggregationFunction aggregationAnnotation)\n+    private static List<String> getAliases(AggregationFunction aggregationAnnotation,\n+            AnnotatedElement outputFunction)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8317c1c369ef96fce3ed80347f87aba5a8f08b9d"}, "originalPosition": 171}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4595, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}