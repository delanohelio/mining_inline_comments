{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0MTEyOTYz", "number": 4991, "title": "Support lazy dynamic filtering in hive connector", "bodyText": "", "createdAt": "2020-08-26T19:37:26Z", "url": "https://github.com/trinodb/trino/pull/4991", "merged": true, "mergeCommit": {"oid": "1feaa0f928a02f577c8ac9ef6cc0c8ec2008a46d"}, "closed": true, "closedAt": "2020-09-09T10:55:30Z", "author": {"login": "raunaqmorarka"}, "timelineItems": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdCyTjvABqjM2OTY2MDI0MDU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdG4D__AFqTQ4NDE2OTg5Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwODY4OTU0", "url": "https://github.com/trinodb/trino/pull/4991#pullrequestreview-480868954", "createdAt": "2020-09-02T14:19:43Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDoxOTo0M1rOHLxcQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDo0NDoxOFrOHLynYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEwNjQzNA==", "bodyText": "add long startTime and timeout after dynamicFilteringProbeBlockingTimeoutMillis - startTime?", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482106434", "createdAt": "2020-09-02T14:19:43Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/BackgroundHiveSplitLoader.java", "diffHunk": "@@ -227,6 +234,12 @@ public TaskStatus process()\n                     return TaskStatus.finished();\n                 }\n                 ListenableFuture<?> future;\n+                if (dynamicFilteringProbeBlockingTimeoutMillis.get() > 0 && !dynamicFilter.isComplete()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEwNjY5NA==", "bodyText": "I think this one can be removed", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482106694", "createdAt": "2020-09-02T14:20:01Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/BackgroundHiveSplitLoader.java", "diffHunk": "@@ -227,6 +234,12 @@ public TaskStatus process()\n                     return TaskStatus.finished();\n                 }\n                 ListenableFuture<?> future;\n+                if (dynamicFilteringProbeBlockingTimeoutMillis.get() > 0 && !dynamicFilter.isComplete()) {\n+                    future = toListenableFuture(dynamicFilter.isBlocked()\n+                            .orTimeout(dynamicFilteringProbeBlockingTimeoutMillis.get(), MILLISECONDS));\n+                    addExceptionCallback(future, () -> dynamicFilteringProbeBlockingTimeoutMillis.set(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEwODU1Mg==", "bodyText": "make this final long dynamicFilteringProbeBlockingTimeoutMillis", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482108552", "createdAt": "2020-09-02T14:22:31Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/BackgroundHiveSplitLoader.java", "diffHunk": "@@ -129,7 +133,8 @@\n \n     private final Table table;\n     private final TupleDomain<? extends ColumnHandle> compactEffectivePredicate;\n-    private final Supplier<TupleDomain<ColumnHandle>> dynamicFilterSupplier;\n+    private final DynamicFilter dynamicFilter;\n+    private final AtomicLong dynamicFilteringProbeBlockingTimeoutMillis;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEwOTc3OA==", "bodyText": "Add io.prestosql.plugin.hive.HiveQueryRunner.Builder#withTpchPartitionedTables()", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482109778", "createdAt": "2020-09-02T14:24:07Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/HiveQueryRunner.java", "diffHunk": "@@ -269,6 +281,60 @@ private static void copyTableBucketed(QueryRunner queryRunner, QualifiedObjectNa\n         log.info(\"Imported %s rows for %s in %s\", rows, table.getObjectName(), nanosSince(start).convertToMostSuccinctTimeUnit());\n     }\n \n+    public static Session createPartitionedSession(Optional<SelectedRole> role)\n+    {\n+        return testSessionBuilder()\n+                .setIdentity(Identity.forUser(\"hive\")\n+                        .withRoles(role.map(selectedRole -> ImmutableMap.of(\"hive\", selectedRole))\n+                                .orElse(ImmutableMap.of()))\n+                        .build())\n+                .setCatalog(HIVE_PARTITIONED_CATALOG)\n+                .setSchema(TPCH_PARTITIONED_SCHEMA)\n+                .build();\n+    }\n+\n+    public static void copyTpchTablesPartitioned(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyMDczOQ==", "bodyText": "please partition by shiptdate which is more natural", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482120739", "createdAt": "2020-09-02T14:37:45Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/HiveQueryRunner.java", "diffHunk": "@@ -269,6 +281,60 @@ private static void copyTableBucketed(QueryRunner queryRunner, QualifiedObjectNa\n         log.info(\"Imported %s rows for %s in %s\", rows, table.getObjectName(), nanosSince(start).convertToMostSuccinctTimeUnit());\n     }\n \n+    public static Session createPartitionedSession(Optional<SelectedRole> role)\n+    {\n+        return testSessionBuilder()\n+                .setIdentity(Identity.forUser(\"hive\")\n+                        .withRoles(role.map(selectedRole -> ImmutableMap.of(\"hive\", selectedRole))\n+                                .orElse(ImmutableMap.of()))\n+                        .build())\n+                .setCatalog(HIVE_PARTITIONED_CATALOG)\n+                .setSchema(TPCH_PARTITIONED_SCHEMA)\n+                .build();\n+    }\n+\n+    public static void copyTpchTablesPartitioned(\n+            QueryRunner queryRunner,\n+            String sourceCatalog,\n+            String sourceSchema,\n+            Session session,\n+            Iterable<TpchTable<?>> tables)\n+    {\n+        log.info(\"Loading data from %s.%s...\", sourceCatalog, sourceSchema);\n+        long startTime = System.nanoTime();\n+        for (TpchTable<?> table : tables) {\n+            copyTablePartitioned(queryRunner, new QualifiedObjectName(sourceCatalog, sourceSchema, table.getTableName().toLowerCase(ENGLISH)), session);\n+        }\n+        log.info(\"Loading from %s.%s complete in %s\", sourceCatalog, sourceSchema, nanosSince(startTime).toString(SECONDS));\n+    }\n+\n+    private static void copyTablePartitioned(QueryRunner queryRunner, QualifiedObjectName table, Session session)\n+    {\n+        long start = System.nanoTime();\n+        log.info(\"Running import for %s\", table.getObjectName());\n+        @Language(\"SQL\") String sql;\n+        switch (table.getObjectName()) {\n+            case \"orders\":\n+            case \"part\":\n+            case \"partsupp\":\n+            case \"supplier\":\n+            case \"nation\":\n+            case \"region\":\n+                sql = format(\"CREATE TABLE %s AS SELECT * FROM %s\", table.getObjectName(), table);\n+                break;\n+            case \"lineitem\":\n+                sql = format(\"CREATE TABLE %s WITH (partitioned_by=array['suppkey']) AS SELECT orderkey, partkey, linenumber, quantity, extendedprice, discount, tax, returnflag, linestatus, shipdate, commitdate, receiptdate, shipinstruct, shipmode, comment, suppkey FROM %s\", table.getObjectName(), table);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyNDc3Mw==", "bodyText": "let's avoid artificial partitioning.", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482124773", "createdAt": "2020-09-02T14:43:08Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/HiveQueryRunner.java", "diffHunk": "@@ -269,6 +281,60 @@ private static void copyTableBucketed(QueryRunner queryRunner, QualifiedObjectNa\n         log.info(\"Imported %s rows for %s in %s\", rows, table.getObjectName(), nanosSince(start).convertToMostSuccinctTimeUnit());\n     }\n \n+    public static Session createPartitionedSession(Optional<SelectedRole> role)\n+    {\n+        return testSessionBuilder()\n+                .setIdentity(Identity.forUser(\"hive\")\n+                        .withRoles(role.map(selectedRole -> ImmutableMap.of(\"hive\", selectedRole))\n+                                .orElse(ImmutableMap.of()))\n+                        .build())\n+                .setCatalog(HIVE_PARTITIONED_CATALOG)\n+                .setSchema(TPCH_PARTITIONED_SCHEMA)\n+                .build();\n+    }\n+\n+    public static void copyTpchTablesPartitioned(\n+            QueryRunner queryRunner,\n+            String sourceCatalog,\n+            String sourceSchema,\n+            Session session,\n+            Iterable<TpchTable<?>> tables)\n+    {\n+        log.info(\"Loading data from %s.%s...\", sourceCatalog, sourceSchema);\n+        long startTime = System.nanoTime();\n+        for (TpchTable<?> table : tables) {\n+            copyTablePartitioned(queryRunner, new QualifiedObjectName(sourceCatalog, sourceSchema, table.getTableName().toLowerCase(ENGLISH)), session);\n+        }\n+        log.info(\"Loading from %s.%s complete in %s\", sourceCatalog, sourceSchema, nanosSince(startTime).toString(SECONDS));\n+    }\n+\n+    private static void copyTablePartitioned(QueryRunner queryRunner, QualifiedObjectName table, Session session)\n+    {\n+        long start = System.nanoTime();\n+        log.info(\"Running import for %s\", table.getObjectName());\n+        @Language(\"SQL\") String sql;\n+        switch (table.getObjectName()) {\n+            case \"orders\":\n+            case \"part\":\n+            case \"partsupp\":\n+            case \"supplier\":\n+            case \"nation\":\n+            case \"region\":\n+                sql = format(\"CREATE TABLE %s AS SELECT * FROM %s\", table.getObjectName(), table);\n+                break;\n+            case \"lineitem\":\n+                sql = format(\"CREATE TABLE %s WITH (partitioned_by=array['suppkey']) AS SELECT orderkey, partkey, linenumber, quantity, extendedprice, discount, tax, returnflag, linestatus, shipdate, commitdate, receiptdate, shipinstruct, shipmode, comment, suppkey FROM %s\", table.getObjectName(), table);\n+                break;\n+            case \"customer\":\n+                sql = format(\"CREATE TABLE %s WITH (partitioned_by=array['nationkey', 'mktsegment']) AS SELECT custkey, name, address, phone, acctbal, comment, nationkey, mktsegment FROM %s\", table.getObjectName(), table);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyNTY2NA==", "bodyText": "could we add a test for getDiscreteValuesCount too? I think you can use row_type for this (I don't think row types are orderable).", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482125664", "createdAt": "2020-09-02T14:44:18Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDynamicPartitionPruning.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.testing.Assertions.assertGreaterThan;\n+import static io.airlift.testing.Assertions.assertGreaterThanOrEqual;\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.hive.HiveQueryRunner.HIVE_PARTITIONED_CATALOG;\n+import static io.prestosql.plugin.hive.HiveQueryRunner.TPCH_PARTITIONED_SCHEMA;\n+import static io.prestosql.plugin.hive.HiveQueryRunner.TPCH_SCHEMA;\n+import static io.prestosql.plugin.hive.HiveQueryRunner.copyTpchTablesPartitioned;\n+import static io.prestosql.plugin.hive.HiveQueryRunner.createPartitionedSession;\n+import static io.prestosql.plugin.tpch.TpchMetadata.TINY_SCHEMA_NAME;\n+import static io.prestosql.server.DynamicFilterService.DynamicFilterDomainStats;\n+import static io.prestosql.server.DynamicFilterService.DynamicFiltersStats;\n+import static io.prestosql.spi.predicate.Domain.none;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.tpch.TpchTable.getTables;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestHiveDynamicPartitionPruning\n+        extends AbstractTestQueryFramework\n+{\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        return HiveQueryRunner.builder()\n+                .setInitialTables(getTables())\n+                .setHiveProperties(ImmutableMap.of(\"hive.dynamic-filtering-probe-blocking-timeout\", \"10s\"))\n+                .build();\n+    }\n+\n+    @BeforeClass\n+    @Override\n+    public void init()\n+            throws Exception\n+    {\n+        super.init();\n+        copyTpchTablesPartitioned(getQueryRunner(), TPCH_SCHEMA, TINY_SCHEMA_NAME, createPartitionedSession(Optional.empty()), getTables());\n+    }\n+\n+    @Override\n+    protected Session getSession()\n+    {\n+        return Session.builder(super.getSession())\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name()) // Avoid node local DF\n+                .setCatalog(HIVE_PARTITIONED_CATALOG)\n+                .setSchema(TPCH_PARTITIONED_SCHEMA)\n+                .build();\n+    }\n+\n+    @Test\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM lineitem JOIN supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\");\n+        assertEquals(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), TPCH_PARTITIONED_SCHEMA + \":lineitem\");\n+        assertEquals(probeStats.getInputPositions(), 0L);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), none(INTEGER).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 0);\n+    }\n+\n+    @Test\n+    public void testJoinWithSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM lineitem JOIN supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'Supplier#000000001'\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), TPCH_PARTITIONED_SCHEMA + \":lineitem\");\n+        // Probe-side is partially scanned\n+        assertLessThan(probeStats.getInputPositions(), countRows(\"lineitem\"));\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), singleValue(INTEGER, 1L).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test\n+    public void testJoinWithNonSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM lineitem JOIN supplier ON lineitem.suppkey = supplier.suppkey\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), TPCH_PARTITIONED_SCHEMA + \":lineitem\");\n+        // Probe-side is fully scanned\n+        assertEquals(probeStats.getInputPositions(), countRows(\"lineitem\"));\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), Domain.create(ValueSet.ofRanges(\n+                range(INTEGER, 1L, true, 100L, true)), false)\n+                .toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test\n+    public void testJoinWithMultipleDynamicFiltersOnProbe()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        // supplier names Supplier#000000001 and Supplier#000000002 match suppkey 1 and 2\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM (\" +\n+                        \"SELECT supplier.suppkey FROM \" +\n+                        \"lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name IN ('Supplier#000000001', 'Supplier#000000002')\" +\n+                        \") t JOIN tpch.tiny.partsupp ON t.suppkey = partsupp.suppkey AND partsupp.suppkey IN (2, 3)\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), TPCH_PARTITIONED_SCHEMA + \":lineitem\");\n+        // Probe-side is partially scanned\n+        assertLessThan(probeStats.getInputPositions(), countRows(\"lineitem\"));\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 2L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 2L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 2L);\n+\n+        List<DynamicFilterDomainStats> domainStats = dynamicFiltersStats.getDynamicFilterDomainStats();\n+        assertEquals(domainStats.size(), 2L);\n+        domainStats.forEach(stats -> {\n+            assertGreaterThanOrEqual(stats.getRangeCount(), 1);\n+            assertEquals(stats.getDiscreteValuesCount(), 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 196}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxOTMwMDgy", "url": "https://github.com/trinodb/trino/pull/4991#pullrequestreview-481930082", "createdAt": "2020-09-03T15:01:06Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNTEwNTQx", "url": "https://github.com/trinodb/trino/pull/4991#pullrequestreview-482510541", "createdAt": "2020-09-04T09:40:13Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTo0MDoxM1rOHNG_YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTo1NDo1MVrOHNHc0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUwODA2NA==", "bodyText": "I don't think it's needed. We short-circut on all predicate.", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483508064", "createdAt": "2020-09-04T09:40:13Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/BackgroundHiveSplitLoader.java", "diffHunk": "@@ -227,6 +236,17 @@ public TaskStatus process()\n                     return TaskStatus.finished();\n                 }\n                 ListenableFuture<?> future;\n+                /*\n+                 * Block until one of below conditions is met:\n+                 * Arrival of first non \"all\" filter", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUwODIxNw==", "bodyText": "put each condition in bulletpoints", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483508217", "createdAt": "2020-09-04T09:40:33Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/BackgroundHiveSplitLoader.java", "diffHunk": "@@ -227,6 +236,17 @@ public TaskStatus process()\n                     return TaskStatus.finished();\n                 }\n                 ListenableFuture<?> future;\n+                /*\n+                 * Block until one of below conditions is met:\n+                 * Arrival of first non \"all\" filter", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMTE3OQ==", "bodyText": "does orTimeout(timeLeft, MILLISECONDS) cancel delegate future?\nThis is a bug in Presto. Futures returned in DynamicFilter are not resilient against cancellation. Could you fix it?\nWe probably should wrap these in MoreFutures#unmodifiableFuture(java.util.concurrent.CompletableFuture<V>, boolean) in Presto main", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483511179", "createdAt": "2020-09-04T09:46:17Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/BackgroundHiveSplitLoader.java", "diffHunk": "@@ -227,6 +236,17 @@ public TaskStatus process()\n                     return TaskStatus.finished();\n                 }\n                 ListenableFuture<?> future;\n+                /*\n+                 * Block until one of below conditions is met:\n+                 * Arrival of first non \"all\" filter\n+                 * Completion of DynamicFilter\n+                 * Timeout after waiting for the configured time\n+                 */\n+                long timeLeft = dynamicFilteringProbeBlockingTimeoutMillis - stopwatch.elapsed(MILLISECONDS);\n+                if (timeLeft > 0 && !dynamicFilter.isComplete() && dynamicFilter.getCurrentPredicate().isAll()) {\n+                    future = toListenableFuture(dynamicFilter.isBlocked().orTimeout(timeLeft, MILLISECONDS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMzQwMA==", "bodyText": "move .map to separate line", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483513400", "createdAt": "2020-09-04T09:50:34Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/HiveQueryRunner.java", "diffHunk": "@@ -269,6 +284,58 @@ private static void copyTableBucketed(QueryRunner queryRunner, QualifiedObjectNa\n         log.info(\"Imported %s rows for %s in %s\", rows, table.getObjectName(), nanosSince(start).convertToMostSuccinctTimeUnit());\n     }\n \n+    public static Session createPartitionedSession(Optional<SelectedRole> role)\n+    {\n+        return testSessionBuilder()\n+                .setIdentity(Identity.forUser(\"hive\")\n+                        .withRoles(role.map(selectedRole -> ImmutableMap.of(\"hive\", selectedRole))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxNDE5Mg==", "bodyText": "Ok. Since this is for just single test, Let's just create appropriate tables in test itself instead of using artificial keys", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483514192", "createdAt": "2020-09-04T09:52:06Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/HiveQueryRunner.java", "diffHunk": "@@ -269,6 +281,60 @@ private static void copyTableBucketed(QueryRunner queryRunner, QualifiedObjectNa\n         log.info(\"Imported %s rows for %s in %s\", rows, table.getObjectName(), nanosSince(start).convertToMostSuccinctTimeUnit());\n     }\n \n+    public static Session createPartitionedSession(Optional<SelectedRole> role)\n+    {\n+        return testSessionBuilder()\n+                .setIdentity(Identity.forUser(\"hive\")\n+                        .withRoles(role.map(selectedRole -> ImmutableMap.of(\"hive\", selectedRole))\n+                                .orElse(ImmutableMap.of()))\n+                        .build())\n+                .setCatalog(HIVE_PARTITIONED_CATALOG)\n+                .setSchema(TPCH_PARTITIONED_SCHEMA)\n+                .build();\n+    }\n+\n+    public static void copyTpchTablesPartitioned(\n+            QueryRunner queryRunner,\n+            String sourceCatalog,\n+            String sourceSchema,\n+            Session session,\n+            Iterable<TpchTable<?>> tables)\n+    {\n+        log.info(\"Loading data from %s.%s...\", sourceCatalog, sourceSchema);\n+        long startTime = System.nanoTime();\n+        for (TpchTable<?> table : tables) {\n+            copyTablePartitioned(queryRunner, new QualifiedObjectName(sourceCatalog, sourceSchema, table.getTableName().toLowerCase(ENGLISH)), session);\n+        }\n+        log.info(\"Loading from %s.%s complete in %s\", sourceCatalog, sourceSchema, nanosSince(startTime).toString(SECONDS));\n+    }\n+\n+    private static void copyTablePartitioned(QueryRunner queryRunner, QualifiedObjectName table, Session session)\n+    {\n+        long start = System.nanoTime();\n+        log.info(\"Running import for %s\", table.getObjectName());\n+        @Language(\"SQL\") String sql;\n+        switch (table.getObjectName()) {\n+            case \"orders\":\n+            case \"part\":\n+            case \"partsupp\":\n+            case \"supplier\":\n+            case \"nation\":\n+            case \"region\":\n+                sql = format(\"CREATE TABLE %s AS SELECT * FROM %s\", table.getObjectName(), table);\n+                break;\n+            case \"lineitem\":\n+                sql = format(\"CREATE TABLE %s WITH (partitioned_by=array['suppkey']) AS SELECT orderkey, partkey, linenumber, quantity, extendedprice, discount, tax, returnflag, linestatus, shipdate, commitdate, receiptdate, shipinstruct, shipmode, comment, suppkey FROM %s\", table.getObjectName(), table);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyMDczOQ=="}, "originalCommit": null, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxNTIxMA==", "bodyText": "nit: this should go to separate commit", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483515210", "createdAt": "2020-09-04T09:54:03Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDistributedJoinQueries.java", "diffHunk": "@@ -77,30 +69,4 @@ public void testJoinWithEmptyBuildSide()\n         assertEquals(probeStats.getInputPositions(), 0L);\n         assertEquals(probeStats.getDynamicFilterSplitsProcessed(), probeStats.getTotalDrivers());\n     }\n-\n-    private OperatorStats searchScanFilterAndProjectOperatorStats(QueryId queryId, String tableName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxNTYwMw==", "bodyText": "would it be ok we add a test in TestDynamicFilterService instead (maybe separate PR)\n\nYes, that works too", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483515603", "createdAt": "2020-09-04T09:54:51Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDynamicPartitionPruning.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.testing.Assertions.assertGreaterThan;\n+import static io.airlift.testing.Assertions.assertGreaterThanOrEqual;\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.hive.HiveQueryRunner.HIVE_PARTITIONED_CATALOG;\n+import static io.prestosql.plugin.hive.HiveQueryRunner.TPCH_PARTITIONED_SCHEMA;\n+import static io.prestosql.plugin.hive.HiveQueryRunner.TPCH_SCHEMA;\n+import static io.prestosql.plugin.hive.HiveQueryRunner.copyTpchTablesPartitioned;\n+import static io.prestosql.plugin.hive.HiveQueryRunner.createPartitionedSession;\n+import static io.prestosql.plugin.tpch.TpchMetadata.TINY_SCHEMA_NAME;\n+import static io.prestosql.server.DynamicFilterService.DynamicFilterDomainStats;\n+import static io.prestosql.server.DynamicFilterService.DynamicFiltersStats;\n+import static io.prestosql.spi.predicate.Domain.none;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.tpch.TpchTable.getTables;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestHiveDynamicPartitionPruning\n+        extends AbstractTestQueryFramework\n+{\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        return HiveQueryRunner.builder()\n+                .setInitialTables(getTables())\n+                .setHiveProperties(ImmutableMap.of(\"hive.dynamic-filtering-probe-blocking-timeout\", \"10s\"))\n+                .build();\n+    }\n+\n+    @BeforeClass\n+    @Override\n+    public void init()\n+            throws Exception\n+    {\n+        super.init();\n+        copyTpchTablesPartitioned(getQueryRunner(), TPCH_SCHEMA, TINY_SCHEMA_NAME, createPartitionedSession(Optional.empty()), getTables());\n+    }\n+\n+    @Override\n+    protected Session getSession()\n+    {\n+        return Session.builder(super.getSession())\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name()) // Avoid node local DF\n+                .setCatalog(HIVE_PARTITIONED_CATALOG)\n+                .setSchema(TPCH_PARTITIONED_SCHEMA)\n+                .build();\n+    }\n+\n+    @Test\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM lineitem JOIN supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\");\n+        assertEquals(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), TPCH_PARTITIONED_SCHEMA + \":lineitem\");\n+        assertEquals(probeStats.getInputPositions(), 0L);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), none(INTEGER).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 0);\n+    }\n+\n+    @Test\n+    public void testJoinWithSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM lineitem JOIN supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'Supplier#000000001'\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), TPCH_PARTITIONED_SCHEMA + \":lineitem\");\n+        // Probe-side is partially scanned\n+        assertLessThan(probeStats.getInputPositions(), countRows(\"lineitem\"));\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), singleValue(INTEGER, 1L).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test\n+    public void testJoinWithNonSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM lineitem JOIN supplier ON lineitem.suppkey = supplier.suppkey\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), TPCH_PARTITIONED_SCHEMA + \":lineitem\");\n+        // Probe-side is fully scanned\n+        assertEquals(probeStats.getInputPositions(), countRows(\"lineitem\"));\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), Domain.create(ValueSet.ofRanges(\n+                range(INTEGER, 1L, true, 100L, true)), false)\n+                .toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test\n+    public void testJoinWithMultipleDynamicFiltersOnProbe()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        // supplier names Supplier#000000001 and Supplier#000000002 match suppkey 1 and 2\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM (\" +\n+                        \"SELECT supplier.suppkey FROM \" +\n+                        \"lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name IN ('Supplier#000000001', 'Supplier#000000002')\" +\n+                        \") t JOIN tpch.tiny.partsupp ON t.suppkey = partsupp.suppkey AND partsupp.suppkey IN (2, 3)\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), TPCH_PARTITIONED_SCHEMA + \":lineitem\");\n+        // Probe-side is partially scanned\n+        assertLessThan(probeStats.getInputPositions(), countRows(\"lineitem\"));\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 2L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 2L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 2L);\n+\n+        List<DynamicFilterDomainStats> domainStats = dynamicFiltersStats.getDynamicFilterDomainStats();\n+        assertEquals(domainStats.size(), 2L);\n+        domainStats.forEach(stats -> {\n+            assertGreaterThanOrEqual(stats.getRangeCount(), 1);\n+            assertEquals(stats.getDiscreteValuesCount(), 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyNTY2NA=="}, "originalCommit": null, "originalPosition": 196}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNTg4MTc4", "url": "https://github.com/trinodb/trino/pull/4991#pullrequestreview-483588178", "createdAt": "2020-09-07T14:15:33Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNDoxNTozM1rOHOA_bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNDoyNTo0NVrOHOBUAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1ODM1MA==", "bodyText": "commit message is too long", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484458350", "createdAt": "2020-09-07T14:15:33Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDistributedJoinQueries.java", "diffHunk": "@@ -13,17 +13,9 @@\n  */", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1ODk0Ng==", "bodyText": "please add a test. Please also update io.prestosql.sql.planner.LocalDynamicFiltersCollector.TableSpecificDynamicFilter#isBlocked + test", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484458946", "createdAt": "2020-09-07T14:16:41Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -217,7 +218,7 @@ public DynamicFilter createDynamicFilter(QueryId queryId, List<DynamicFilters.De\n                     return NOT_BLOCKED;\n                 }\n \n-                return toCompletableFuture(whenAnyComplete(undoneFutures));\n+                return unmodifiableFuture(toCompletableFuture(whenAnyComplete(undoneFutures)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1OTAxMQ==", "bodyText": "you could make separate PR for this fix", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484459011", "createdAt": "2020-09-07T14:16:50Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -67,6 +67,7 @@\n import static com.google.common.collect.ImmutableSet.toImmutableSet;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1OTUzMA==", "bodyText": "all filter should trigger DF completion (and filter unblock). Remove this condition", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484459530", "createdAt": "2020-09-07T14:17:55Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/BackgroundHiveSplitLoader.java", "diffHunk": "@@ -227,6 +236,17 @@ public TaskStatus process()\n                     return TaskStatus.finished();\n                 }\n                 ListenableFuture<?> future;\n+                /*\n+                 * Block until one of below conditions is met:\n+                 *  1. Arrival of first non \"all\" filter", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ2MTAzNg==", "bodyText": "make it sleep for 1H", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484461036", "createdAt": "2020-09-07T14:20:42Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestBackgroundHiveSplitLoader.java", "diffHunk": "@@ -343,6 +346,45 @@ public void testNoHangIfPartitionIsOffline()\n         assertThrows(RuntimeException.class, hiveSplitSource::isFinished);\n     }\n \n+    @Test(timeOut = 6_000)\n+    public void testIncompleteDynamicFilterTimeout()\n+            throws Exception\n+    {\n+        BackgroundHiveSplitLoader backgroundHiveSplitLoader = backgroundHiveSplitLoader(\n+                new DynamicFilter() {\n+                    @Override\n+                    public CompletableFuture<?> isBlocked()\n+                    {\n+                        return CompletableFuture.runAsync(() -> {\n+                            try {\n+                                TimeUnit.SECONDS.sleep(30);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ2MTE3NA==", "bodyText": "increase timeout to 30s to reduce chance for flakyness", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484461174", "createdAt": "2020-09-07T14:20:57Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestBackgroundHiveSplitLoader.java", "diffHunk": "@@ -343,6 +346,45 @@ public void testNoHangIfPartitionIsOffline()\n         assertThrows(RuntimeException.class, hiveSplitSource::isFinished);\n     }\n \n+    @Test(timeOut = 6_000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ2MTg3MA==", "bodyText": "increase timeout for 1h to reduce risk of test flakyness", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484461870", "createdAt": "2020-09-07T14:22:18Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDynamicPartitionPruning.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logger;\n+import io.prestosql.Session;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.testing.Assertions.assertGreaterThan;\n+import static io.airlift.testing.Assertions.assertGreaterThanOrEqual;\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.airlift.units.Duration.nanosSince;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.server.DynamicFilterService.DynamicFilterDomainStats;\n+import static io.prestosql.server.DynamicFilterService.DynamicFiltersStats;\n+import static io.prestosql.spi.predicate.Domain.none;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.tpch.TpchTable.getTables;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestHiveDynamicPartitionPruning\n+        extends AbstractTestQueryFramework\n+{\n+    private static final Logger log = Logger.get(TestHiveDynamicPartitionPruning.class);\n+    private static final String PARTITIONED_LINEITEM = \"partitioned_lineitem\";\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        return HiveQueryRunner.builder()\n+                .setInitialTables(getTables())\n+                .setHiveProperties(ImmutableMap.of(\"hive.dynamic-filtering-probe-blocking-timeout\", \"10s\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ2MzM0Mw==", "bodyText": "question: is it a consistent same scanned row count every time?", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484463343", "createdAt": "2020-09-07T14:25:11Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDynamicPartitionPruning.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logger;\n+import io.prestosql.Session;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.testing.Assertions.assertGreaterThan;\n+import static io.airlift.testing.Assertions.assertGreaterThanOrEqual;\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.airlift.units.Duration.nanosSince;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.server.DynamicFilterService.DynamicFilterDomainStats;\n+import static io.prestosql.server.DynamicFilterService.DynamicFiltersStats;\n+import static io.prestosql.spi.predicate.Domain.none;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.tpch.TpchTable.getTables;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestHiveDynamicPartitionPruning\n+        extends AbstractTestQueryFramework\n+{\n+    private static final Logger log = Logger.get(TestHiveDynamicPartitionPruning.class);\n+    private static final String PARTITIONED_LINEITEM = \"partitioned_lineitem\";\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        return HiveQueryRunner.builder()\n+                .setInitialTables(getTables())\n+                .setHiveProperties(ImmutableMap.of(\"hive.dynamic-filtering-probe-blocking-timeout\", \"10s\"))\n+                .build();\n+    }\n+\n+    @BeforeClass\n+    @Override\n+    public void init()\n+            throws Exception\n+    {\n+        super.init();\n+        // setup partitioned fact table for dynamic partition pruning\n+        @Language(\"SQL\") String sql = format(\"CREATE TABLE %s WITH (partitioned_by=array['suppkey']) AS \" +\n+                \"SELECT orderkey, partkey, linenumber, suppkey FROM %s\", PARTITIONED_LINEITEM, \"tpch.tiny.lineitem\");\n+        long start = System.nanoTime();\n+        long rows = (Long) getQueryRunner().execute(sql).getMaterializedRows().get(0).getField(0);\n+        log.info(\"Imported %s rows for %s in %s\", rows, PARTITIONED_LINEITEM, nanosSince(start).convertToMostSuccinctTimeUnit());\n+    }\n+\n+    @Override\n+    protected Session getSession()\n+    {\n+        return Session.builder(super.getSession())\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name()) // Avoid node local DF\n+                .build();\n+    }\n+\n+    @Test\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\");\n+        assertEquals(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        assertEquals(probeStats.getInputPositions(), 0L);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), none(INTEGER).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 0);\n+    }\n+\n+    @Test\n+    public void testJoinWithSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey \" +\n+                        \"AND supplier.name = 'Supplier#000000001'\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is partially scanned\n+        assertLessThan(probeStats.getInputPositions(), countRows(\"lineitem\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ2MzYxOA==", "bodyText": "extract countRows(\"lineitem\") as static final to avoid extra queries in test", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484463618", "createdAt": "2020-09-07T14:25:45Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDynamicPartitionPruning.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logger;\n+import io.prestosql.Session;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.testing.Assertions.assertGreaterThan;\n+import static io.airlift.testing.Assertions.assertGreaterThanOrEqual;\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.airlift.units.Duration.nanosSince;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.server.DynamicFilterService.DynamicFilterDomainStats;\n+import static io.prestosql.server.DynamicFilterService.DynamicFiltersStats;\n+import static io.prestosql.spi.predicate.Domain.none;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.tpch.TpchTable.getTables;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestHiveDynamicPartitionPruning\n+        extends AbstractTestQueryFramework\n+{\n+    private static final Logger log = Logger.get(TestHiveDynamicPartitionPruning.class);\n+    private static final String PARTITIONED_LINEITEM = \"partitioned_lineitem\";\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        return HiveQueryRunner.builder()\n+                .setInitialTables(getTables())\n+                .setHiveProperties(ImmutableMap.of(\"hive.dynamic-filtering-probe-blocking-timeout\", \"10s\"))\n+                .build();\n+    }\n+\n+    @BeforeClass\n+    @Override\n+    public void init()\n+            throws Exception\n+    {\n+        super.init();\n+        // setup partitioned fact table for dynamic partition pruning\n+        @Language(\"SQL\") String sql = format(\"CREATE TABLE %s WITH (partitioned_by=array['suppkey']) AS \" +\n+                \"SELECT orderkey, partkey, linenumber, suppkey FROM %s\", PARTITIONED_LINEITEM, \"tpch.tiny.lineitem\");\n+        long start = System.nanoTime();\n+        long rows = (Long) getQueryRunner().execute(sql).getMaterializedRows().get(0).getField(0);\n+        log.info(\"Imported %s rows for %s in %s\", rows, PARTITIONED_LINEITEM, nanosSince(start).convertToMostSuccinctTimeUnit());\n+    }\n+\n+    @Override\n+    protected Session getSession()\n+    {\n+        return Session.builder(super.getSession())\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name()) // Avoid node local DF\n+                .build();\n+    }\n+\n+    @Test\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\");\n+        assertEquals(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        assertEquals(probeStats.getInputPositions(), 0L);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), none(INTEGER).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 0);\n+    }\n+\n+    @Test\n+    public void testJoinWithSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey \" +\n+                        \"AND supplier.name = 'Supplier#000000001'\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is partially scanned\n+        assertLessThan(probeStats.getInputPositions(), countRows(\"lineitem\"));\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), singleValue(INTEGER, 1L).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test\n+    public void testJoinWithNonSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is fully scanned\n+        assertEquals(probeStats.getInputPositions(), countRows(\"lineitem\"));\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), Domain.create(ValueSet.ofRanges(\n+                range(INTEGER, 1L, true, 100L, true)), false)\n+                .toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test\n+    public void testJoinWithMultipleDynamicFiltersOnProbe()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        // supplier names Supplier#000000001 and Supplier#000000002 match suppkey 1 and 2\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM (\" +\n+                        \"SELECT supplier.suppkey FROM \" +\n+                        \"partitioned_lineitem JOIN tpch.tiny.supplier ON partitioned_lineitem.suppkey = supplier.suppkey AND supplier.name IN ('Supplier#000000001', 'Supplier#000000002')\" +\n+                        \") t JOIN tpch.tiny.partsupp ON t.suppkey = partsupp.suppkey AND partsupp.suppkey IN (2, 3)\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is partially scanned\n+        assertLessThan(probeStats.getInputPositions(), countRows(\"lineitem\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 187}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9a67d14be9ee6faf3d5b475fd7e7027a987d5f5", "author": {"user": {"login": "raunaqmorarka", "name": "Raunaq Morarka"}}, "url": "https://github.com/trinodb/trino/commit/f9a67d14be9ee6faf3d5b475fd7e7027a987d5f5", "committedDate": "2020-09-08T07:55:51Z", "message": "Move searchScanFilterAndProjectOperatorStats"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzOTY5NDc4", "url": "https://github.com/trinodb/trino/pull/4991#pullrequestreview-483969478", "createdAt": "2020-09-08T09:44:09Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwOTo0NDowOVrOHOVO3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwOTo1MTowNFrOHOVfTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4OTk4Mg==", "bodyText": "nit: I think in methods we use:\n// comment\n//  second line\n\nstyle of comments.", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484789982", "createdAt": "2020-09-08T09:44:09Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/BackgroundHiveSplitLoader.java", "diffHunk": "@@ -227,6 +236,16 @@ public TaskStatus process()\n                     return TaskStatus.finished();\n                 }\n                 ListenableFuture<?> future;\n+                /*", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc5MTg3Mw==", "bodyText": "Could you extend io.prestosql.plugin.hive.TestBackgroundHiveSplitLoader#backgroundHiveSplitLoader(io.prestosql.plugin.hive.HdfsEnvironment, io.prestosql.spi.predicate.TupleDomain<io.prestosql.plugin.hive.HiveColumnHandle>, java.util.Optional<io.prestosql.plugin.hive.util.HiveBucketing.HiveBucketFilter>, io.prestosql.plugin.hive.metastore.Table, java.util.Optional<io.prestosql.plugin.hive.HiveBucketHandle>, java.util.Optional<org.apache.hadoop.hive.common.ValidWriteIdList>) version of backgroundHiveSplitLoader with dynamic filter parameters and add an override that does provide default values for these?", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484791873", "createdAt": "2020-09-08T09:47:08Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestBackgroundHiveSplitLoader.java", "diffHunk": "@@ -703,6 +746,36 @@ private static void createOrcAcidFile(File file)\n         return splits.build();\n     }\n \n+    private static BackgroundHiveSplitLoader backgroundHiveSplitLoader(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc5MzM0MA==", "bodyText": "please do something similar as io.prestosql.plugin.memory.TestMemorySmoke#LINEITEM_COUNT for total count of lineitem rows.", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484793340", "createdAt": "2020-09-08T09:49:38Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDynamicPartitionPruning.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logger;\n+import io.prestosql.Session;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.testing.Assertions.assertGreaterThan;\n+import static io.airlift.testing.Assertions.assertGreaterThanOrEqual;\n+import static io.airlift.testing.Assertions.assertLessThanOrEqual;\n+import static io.airlift.units.Duration.nanosSince;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.server.DynamicFilterService.DynamicFilterDomainStats;\n+import static io.prestosql.server.DynamicFilterService.DynamicFiltersStats;\n+import static io.prestosql.spi.predicate.Domain.none;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.tpch.TpchTable.getTables;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestHiveDynamicPartitionPruning\n+        extends AbstractTestQueryFramework\n+{\n+    private static final Logger log = Logger.get(TestHiveDynamicPartitionPruning.class);\n+    private static final String PARTITIONED_LINEITEM = \"partitioned_lineitem\";\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        return HiveQueryRunner.builder()\n+                .setInitialTables(getTables())\n+                .setHiveProperties(ImmutableMap.of(\"hive.dynamic-filtering-probe-blocking-timeout\", \"1h\"))\n+                .build();\n+    }\n+\n+    @BeforeClass\n+    @Override\n+    public void init()\n+            throws Exception\n+    {\n+        super.init();\n+        // setup partitioned fact table for dynamic partition pruning\n+        @Language(\"SQL\") String sql = format(\"CREATE TABLE %s WITH (format = 'TEXTFILE', partitioned_by=array['suppkey']) AS \" +\n+                \"SELECT orderkey, partkey, linenumber, suppkey FROM %s\", PARTITIONED_LINEITEM, \"tpch.tiny.lineitem\");\n+        long start = System.nanoTime();\n+        long rows = (Long) getQueryRunner().execute(sql).getMaterializedRows().get(0).getField(0);\n+        log.info(\"Imported %s rows for %s in %s\", rows, PARTITIONED_LINEITEM, nanosSince(start).convertToMostSuccinctTimeUnit());\n+    }\n+\n+    @Override\n+    protected Session getSession()\n+    {\n+        return Session.builder(super.getSession())\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name()) // Avoid node local DF\n+                .build();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\");\n+        assertEquals(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        assertEquals(probeStats.getInputPositions(), 0L);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), none(INTEGER).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 0);\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey \" +\n+                        \"AND supplier.name = 'Supplier#000000001'\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is partially scanned\n+        assertEquals(probeStats.getInputPositions(), 615);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), singleValue(INTEGER, 1L).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithNonSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is fully scanned\n+        assertEquals(probeStats.getInputPositions(), countRows(\"lineitem\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc5NDE4OQ==", "bodyText": "please add a test case where build side is too large, see: io.prestosql.plugin.memory.TestMemorySmoke#testJoinLargeBuildSideNoDynamicFiltering", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484794189", "createdAt": "2020-09-08T09:51:04Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDynamicPartitionPruning.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logger;\n+import io.prestosql.Session;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.testing.Assertions.assertGreaterThan;\n+import static io.airlift.testing.Assertions.assertGreaterThanOrEqual;\n+import static io.airlift.testing.Assertions.assertLessThanOrEqual;\n+import static io.airlift.units.Duration.nanosSince;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.server.DynamicFilterService.DynamicFilterDomainStats;\n+import static io.prestosql.server.DynamicFilterService.DynamicFiltersStats;\n+import static io.prestosql.spi.predicate.Domain.none;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.tpch.TpchTable.getTables;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestHiveDynamicPartitionPruning\n+        extends AbstractTestQueryFramework\n+{\n+    private static final Logger log = Logger.get(TestHiveDynamicPartitionPruning.class);\n+    private static final String PARTITIONED_LINEITEM = \"partitioned_lineitem\";\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        return HiveQueryRunner.builder()\n+                .setInitialTables(getTables())\n+                .setHiveProperties(ImmutableMap.of(\"hive.dynamic-filtering-probe-blocking-timeout\", \"1h\"))\n+                .build();\n+    }\n+\n+    @BeforeClass\n+    @Override\n+    public void init()\n+            throws Exception\n+    {\n+        super.init();\n+        // setup partitioned fact table for dynamic partition pruning\n+        @Language(\"SQL\") String sql = format(\"CREATE TABLE %s WITH (format = 'TEXTFILE', partitioned_by=array['suppkey']) AS \" +\n+                \"SELECT orderkey, partkey, linenumber, suppkey FROM %s\", PARTITIONED_LINEITEM, \"tpch.tiny.lineitem\");\n+        long start = System.nanoTime();\n+        long rows = (Long) getQueryRunner().execute(sql).getMaterializedRows().get(0).getField(0);\n+        log.info(\"Imported %s rows for %s in %s\", rows, PARTITIONED_LINEITEM, nanosSince(start).convertToMostSuccinctTimeUnit());\n+    }\n+\n+    @Override\n+    protected Session getSession()\n+    {\n+        return Session.builder(super.getSession())\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name()) // Avoid node local DF\n+                .build();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\");\n+        assertEquals(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        assertEquals(probeStats.getInputPositions(), 0L);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), none(INTEGER).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 0);\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey \" +\n+                        \"AND supplier.name = 'Supplier#000000001'\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is partially scanned\n+        assertEquals(probeStats.getInputPositions(), 615);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), singleValue(INTEGER, 1L).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithNonSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is fully scanned\n+        assertEquals(probeStats.getInputPositions(), countRows(\"lineitem\"));\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), Domain.create(ValueSet.ofRanges(\n+                range(INTEGER, 1L, true, 100L, true)), false)\n+                .toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithMultipleDynamicFiltersOnProbe()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        // supplier names Supplier#000000001 and Supplier#000000002 match suppkey 1 and 2\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM (\" +\n+                        \"SELECT supplier.suppkey FROM \" +\n+                        \"partitioned_lineitem JOIN tpch.tiny.supplier ON partitioned_lineitem.suppkey = supplier.suppkey AND supplier.name IN ('Supplier#000000001', 'Supplier#000000002')\" +\n+                        \") t JOIN tpch.tiny.partsupp ON t.suppkey = partsupp.suppkey AND partsupp.suppkey IN (2, 3)\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is partially scanned\n+        assertLessThanOrEqual(probeStats.getInputPositions(), 615L);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 2L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 2L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 2L);\n+\n+        List<DynamicFilterDomainStats> domainStats = dynamicFiltersStats.getDynamicFilterDomainStats();\n+        assertEquals(domainStats.size(), 2L);\n+        domainStats.forEach(stats -> {\n+            assertGreaterThanOrEqual(stats.getRangeCount(), 1);\n+            assertEquals(stats.getDiscreteValuesCount(), 0);\n+        });\n+    }\n+\n+    private DynamicFiltersStats getDynamicFilteringStats(QueryId queryId)\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        return runner.getCoordinator()\n+                .getQueryManager()\n+                .getFullQueryInfo(queryId)\n+                .getQueryStats()\n+                .getDynamicFiltersStats();\n+    }\n+\n+    private long countRows(String tableName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 214}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MDk3MDgw", "url": "https://github.com/trinodb/trino/pull/4991#pullrequestreview-484097080", "createdAt": "2020-09-08T12:48:32Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMjo0ODozM1rOHObPsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMjo0ODozM1rOHObPsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg4ODQ5Ng==", "bodyText": "@sopel39 FYI I tweaked this test a bit to assert on completion of only one filter. I was seeing some flakiness without this because the probe side gets unblocked after receiving one filter and the query can sometimes finish before DynamicFilterService is able to collect the 2nd filter. If I set experimental.dynamic-filtering-refresh-interval to a very low value like 20ms then the flakiness goes away.", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484888496", "createdAt": "2020-09-08T12:48:33Z", "author": {"login": "raunaqmorarka"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDynamicPartitionPruning.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logger;\n+import io.prestosql.Session;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.testing.Assertions.assertBetweenInclusive;\n+import static io.airlift.testing.Assertions.assertGreaterThan;\n+import static io.airlift.testing.Assertions.assertGreaterThanOrEqual;\n+import static io.airlift.units.Duration.nanosSince;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.server.DynamicFilterService.DynamicFilterDomainStats;\n+import static io.prestosql.server.DynamicFilterService.DynamicFiltersStats;\n+import static io.prestosql.spi.predicate.Domain.none;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.tpch.TpchTable.getTables;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestHiveDynamicPartitionPruning\n+        extends AbstractTestQueryFramework\n+{\n+    private static final Logger log = Logger.get(TestHiveDynamicPartitionPruning.class);\n+    private static final String PARTITIONED_LINEITEM = \"partitioned_lineitem\";\n+    private static final long LINEITEM_COUNT = 60175;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        return HiveQueryRunner.builder()\n+                .setInitialTables(getTables())\n+                .setHiveProperties(ImmutableMap.of(\"hive.dynamic-filtering-probe-blocking-timeout\", \"1h\"))\n+                .build();\n+    }\n+\n+    @BeforeClass\n+    @Override\n+    public void init()\n+            throws Exception\n+    {\n+        super.init();\n+        // setup partitioned fact table for dynamic partition pruning\n+        @Language(\"SQL\") String sql = format(\"CREATE TABLE %s WITH (format = 'TEXTFILE', partitioned_by=array['suppkey']) AS \" +\n+                \"SELECT orderkey, partkey, linenumber, suppkey FROM %s\", PARTITIONED_LINEITEM, \"tpch.tiny.lineitem\");\n+        long start = System.nanoTime();\n+        long rows = (Long) getQueryRunner().execute(sql).getMaterializedRows().get(0).getField(0);\n+        log.info(\"Imported %s rows for %s in %s\", rows, PARTITIONED_LINEITEM, nanosSince(start).convertToMostSuccinctTimeUnit());\n+    }\n+\n+    @Override\n+    protected Session getSession()\n+    {\n+        return Session.builder(super.getSession())\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name()) // Avoid node local DF\n+                .build();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\");\n+        assertEquals(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        assertEquals(probeStats.getInputPositions(), 0L);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), none(INTEGER).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 0);\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey \" +\n+                        \"AND supplier.name = 'Supplier#000000001'\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is partially scanned\n+        assertEquals(probeStats.getInputPositions(), 615);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), singleValue(INTEGER, 1L).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithNonSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey\");\n+        assertEquals(result.getResult().getRowCount(), LINEITEM_COUNT);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is fully scanned\n+        assertEquals(probeStats.getInputPositions(), LINEITEM_COUNT);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), Domain.create(ValueSet.ofRanges(\n+                range(INTEGER, 1L, true, 100L, true)), false)\n+                .toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinLargeBuildSideNoDynamicFiltering()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN orders ON partitioned_lineitem.orderkey = orders.orderkey\");\n+        assertEquals(result.getResult().getRowCount(), LINEITEM_COUNT);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        assertEquals(probeStats.getInputPositions(), LINEITEM_COUNT);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), Domain.all(INTEGER).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithMultipleDynamicFiltersOnProbe()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        // supplier names Supplier#000000001 and Supplier#000000002 match suppkey 1 and 2\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM (\" +\n+                        \"SELECT supplier.suppkey FROM \" +\n+                        \"partitioned_lineitem JOIN tpch.tiny.supplier ON partitioned_lineitem.suppkey = supplier.suppkey AND supplier.name IN ('Supplier#000000001', 'Supplier#000000002')\" +\n+                        \") t JOIN supplier ON t.suppkey = supplier.suppkey AND supplier.suppkey IN (2, 3)\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is partially scanned\n+        assertBetweenInclusive(probeStats.getInputPositions(), 558L, LINEITEM_COUNT - 1);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 2L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 2L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertBetweenInclusive(dynamicFiltersStats.getDynamicFiltersCompleted(), 1, 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 221}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MTAxNTUz", "url": "https://github.com/trinodb/trino/pull/4991#pullrequestreview-484101553", "createdAt": "2020-09-08T12:53:57Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMjo1Mzo1N1rOHObdBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMjo1Mzo1N1rOHObdBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg5MTkxMA==", "bodyText": "please remove dynamicFilter.getCurrentPredicate().isAll() predicate from if", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484891910", "createdAt": "2020-09-08T12:53:57Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/BackgroundHiveSplitLoader.java", "diffHunk": "@@ -227,6 +236,14 @@ public TaskStatus process()\n                     return TaskStatus.finished();\n                 }\n                 ListenableFuture<?> future;\n+                // Block until one of below conditions is met:\n+                // 1. Completion of DynamicFilter\n+                // 2. Timeout after waiting for the configured time\n+                long timeLeft = dynamicFilteringProbeBlockingTimeoutMillis - stopwatch.elapsed(MILLISECONDS);\n+                if (timeLeft > 0 && !dynamicFilter.isComplete() && dynamicFilter.getCurrentPredicate().isAll()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 101}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b001728df0e045fb18b4b877da9f184b875e3333", "author": {"user": {"login": "raunaqmorarka", "name": "Raunaq Morarka"}}, "url": "https://github.com/trinodb/trino/commit/b001728df0e045fb18b4b877da9f184b875e3333", "committedDate": "2020-09-08T13:23:51Z", "message": "Support lazy dynamic filtering in hive connector"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "b001728df0e045fb18b4b877da9f184b875e3333", "author": {"user": {"login": "raunaqmorarka", "name": "Raunaq Morarka"}}, "url": "https://github.com/trinodb/trino/commit/b001728df0e045fb18b4b877da9f184b875e3333", "committedDate": "2020-09-08T13:23:51Z", "message": "Support lazy dynamic filtering in hive connector"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MTY5ODkz", "url": "https://github.com/trinodb/trino/pull/4991#pullrequestreview-484169893", "createdAt": "2020-09-08T13:59:50Z", "commit": {"oid": "b001728df0e045fb18b4b877da9f184b875e3333"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4201, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}