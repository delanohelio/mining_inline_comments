{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0NzY3NzQx", "number": 4038, "title": "Refactor UnaliasSymbolReferences and SymbolMapper", "bodyText": "In UnaliasSymbolReferences:\nIntroduce context, including inherited mapping for correlation symbols.\nIntroduce return type for visit() methods, including:\n- rewritten plan,\n- symbol mappings (both inherited and derived).\nPreviously, there was global symbol mapping that changed each time\nwhen new symbol mapping was defined. Hence, once a mapping for a symbol\nwas defined, it was applied to all occurrences of the symbol that\nwere encountered later.\nThis approach caused errors in case of reused (duplicate) symbols\nin different branches of the plan.\nSymbol mapping is now performed only by SymbolMapper.\nPreviously, some mapping methods were defined in\nUnaliasSymbolReferences and some code was copied between\nUnalias and SymbolMapper.", "createdAt": "2020-06-15T20:25:53Z", "url": "https://github.com/trinodb/trino/pull/4038", "merged": true, "mergeCommit": {"oid": "ce941836e5db14421cda1f760eb45e2d02612886"}, "closed": true, "closedAt": "2020-06-30T17:35:51Z", "author": {"login": "kasiafi"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcvHx36ABqjM0ODc3MzE4NDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcwWblIgBqjM0OTgwMjM5ODM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MzYzNDM0", "url": "https://github.com/trinodb/trino/pull/4038#pullrequestreview-434363434", "createdAt": "2020-06-19T22:14:33Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQyMjoxNDozM1rOGmiZAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMDo0ODo0MFrOGqnmFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2MjUzMQ==", "bodyText": "mapping is an immutable map. No need to call ImmutableMap.copyOf()", "url": "https://github.com/trinodb/trino/pull/4038#discussion_r443062531", "createdAt": "2020-06-19T22:14:33Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/SymbolMapper.java", "diffHunk": "@@ -56,16 +59,37 @@ public SymbolMapper(Map<Symbol, Symbol> mapping)\n         this.mapping = ImmutableMap.copyOf(requireNonNull(mapping, \"mapping is null\"));\n     }\n \n+    public Map<Symbol, Symbol> getMapping()\n+    {\n+        return ImmutableMap.copyOf(mapping);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2MzA1NQ==", "bodyText": "Unrelated change. It can go in a separate commit", "url": "https://github.com/trinodb/trino/pull/4038#discussion_r443063055", "createdAt": "2020-06-19T22:16:48Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/SymbolMapper.java", "diffHunk": "@@ -56,16 +59,37 @@ public SymbolMapper(Map<Symbol, Symbol> mapping)\n         this.mapping = ImmutableMap.copyOf(requireNonNull(mapping, \"mapping is null\"));\n     }\n \n+    public Map<Symbol, Symbol> getMapping()\n+    {\n+        return ImmutableMap.copyOf(mapping);\n+    }\n+\n+    // Return the canonical mapping for the symbol.\n     public Symbol map(Symbol symbol)\n     {\n-        Symbol canonical = symbol;\n-        while (mapping.containsKey(canonical) && !mapping.get(canonical).equals(canonical)) {\n-            canonical = mapping.get(canonical);\n+        while (mapping.containsKey(symbol) && !mapping.get(symbol).equals(symbol)) {\n+            symbol = mapping.get(symbol);\n         }\n-        return canonical;\n+\n+        return symbol;\n+    }\n+\n+    public List<Symbol> map(List<Symbol> symbols)\n+    {\n+        return symbols.stream()\n+                .map(this::map)\n+                .collect(toImmutableList());\n+    }\n+\n+    public List<Symbol> mapAndDistinct(List<Symbol> symbols)\n+    {\n+        return symbols.stream()\n+                .map(this::map)\n+                .distinct()\n+                .collect(toImmutableList());\n     }\n \n-    public Expression map(Expression value)\n+    public Expression map(Expression expression)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2MzM1Nw==", "bodyText": "Is this simply a method being inlined into another? It can go into a separate commit, unless it's related to the main body of the change.", "url": "https://github.com/trinodb/trino/pull/4038#discussion_r443063357", "createdAt": "2020-06-19T22:18:06Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/SymbolMapper.java", "diffHunk": "@@ -75,30 +99,25 @@ public Expression rewriteSymbolReference(SymbolReference node, Void context, Exp\n                 Symbol canonical = map(Symbol.from(node));\n                 return canonical.toSymbolReference();\n             }\n-        }, value);\n+        }, expression);\n     }\n \n     public AggregationNode map(AggregationNode node, PlanNode source)\n     {\n         return map(node, source, node.getId());\n     }\n \n-    public AggregationNode map(AggregationNode node, PlanNode source, PlanNodeIdAllocator idAllocator)\n+    public AggregationNode map(AggregationNode node, PlanNode source, PlanNodeId newId)\n     {\n-        return map(node, source, idAllocator.getNextId());\n-    }\n-\n-    private AggregationNode map(AggregationNode node, PlanNode source, PlanNodeId newNodeId)\n-    {\n-        ImmutableMap.Builder<Symbol, Aggregation> aggregations = ImmutableMap.builder();\n-        for (Entry<Symbol, Aggregation> entry : node.getAggregations().entrySet()) {\n-            aggregations.put(map(entry.getKey()), map(entry.getValue()));\n+        ImmutableMap.Builder<Symbol, AggregationNode.Aggregation> newAggregations = ImmutableMap.builder();\n+        for (Map.Entry<Symbol, AggregationNode.Aggregation> entry : node.getAggregations().entrySet()) {\n+            newAggregations.put(map(entry.getKey()), map(entry.getValue()));\n         }\n \n         return new AggregationNode(\n-                newNodeId,\n+                newId,\n                 source,\n-                aggregations.build(),\n+                newAggregations.build(),\n                 groupingSets(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2MzYxMA==", "bodyText": "This is a minor restructuring of the method that seems unrelated to the main change. Put it in a separate commit.", "url": "https://github.com/trinodb/trino/pull/4038#discussion_r443063610", "createdAt": "2020-06-19T22:19:21Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/SymbolMapper.java", "diffHunk": "@@ -56,16 +59,37 @@ public SymbolMapper(Map<Symbol, Symbol> mapping)\n         this.mapping = ImmutableMap.copyOf(requireNonNull(mapping, \"mapping is null\"));\n     }\n \n+    public Map<Symbol, Symbol> getMapping()\n+    {\n+        return ImmutableMap.copyOf(mapping);\n+    }\n+\n+    // Return the canonical mapping for the symbol.\n     public Symbol map(Symbol symbol)\n     {\n-        Symbol canonical = symbol;\n-        while (mapping.containsKey(canonical) && !mapping.get(canonical).equals(canonical)) {\n-            canonical = mapping.get(canonical);\n+        while (mapping.containsKey(symbol) && !mapping.get(symbol).equals(symbol)) {\n+            symbol = mapping.get(symbol);\n         }\n-        return canonical;\n+\n+        return symbol;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2NDAzNA==", "bodyText": "What's \"TODO new\"?", "url": "https://github.com/trinodb/trino/pull/4038#discussion_r443064034", "createdAt": "2020-06-19T22:21:20Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/SymbolMapper.java", "diffHunk": "@@ -122,14 +141,73 @@ private Aggregation map(Aggregation aggregation)\n                 aggregation.getMask().map(this::map));\n     }\n \n-    public TopNNode map(TopNNode node, PlanNode source, PlanNodeId newNodeId)\n+    public GroupIdNode map(GroupIdNode node, PlanNode source) // TODO new", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA4Nzk0Mw==", "bodyText": "Unrelated change. Move to a separate commit", "url": "https://github.com/trinodb/trino/pull/4038#discussion_r443087943", "createdAt": "2020-06-20T01:06:38Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/SymbolMapper.java", "diffHunk": "@@ -255,14 +354,14 @@ private OrderingScheme map(OrderingScheme orderingScheme)\n     {\n         private final ImmutableMap.Builder<Symbol, Symbol> mappings = ImmutableMap.builder();\n \n-        public SymbolMapper build()\n+        public void put(Symbol from, Symbol to)\n         {\n-            return new SymbolMapper(mappings.build());\n+            mappings.put(from, to);\n         }\n \n-        public void put(Symbol from, Symbol to)\n+        public SymbolMapper build()\n         {\n-            mappings.put(from, to);\n+            return new SymbolMapper(mappings.build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 414}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA4ODQ4NQ==", "bodyText": "This can be called just mappings. It's self-evident that it's a mapping from symbol to symbol.", "url": "https://github.com/trinodb/trino/pull/4038#discussion_r443088485", "createdAt": "2020-06-20T01:13:20Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/UnaliasSymbolReferences.java", "diffHunk": "@@ -125,695 +121,988 @@ public PlanNode optimize(PlanNode plan, Session session, TypeProvider types, Sym\n         requireNonNull(symbolAllocator, \"symbolAllocator is null\");\n         requireNonNull(idAllocator, \"idAllocator is null\");\n \n-        return SimplePlanRewriter.rewriteWith(new Rewriter(metadata, types), plan);\n+        return plan.accept(new Visitor(metadata, symbolAllocator), UnaliasContext.empty()).getRoot();\n     }\n \n-    private static class Rewriter\n-            extends SimplePlanRewriter<Void>\n+    private static class Visitor\n+            extends PlanVisitor<PlanAndMappings, UnaliasContext>\n     {\n-        private final Map<Symbol, Symbol> mapping = new HashMap<>();\n         private final Metadata metadata;\n-        private final TypeProvider types;\n+        private final SymbolAllocator symbolAllocator;\n \n-        private Rewriter(Metadata metadata, TypeProvider types)\n+        public Visitor(Metadata metadata, SymbolAllocator symbolAllocator)\n         {\n-            this.metadata = metadata;\n-            this.types = types;\n+            this.metadata = requireNonNull(metadata, \"metadata is null\");\n+            this.symbolAllocator = requireNonNull(symbolAllocator, \"symbolAllocator is null\");\n         }\n \n         @Override\n-        public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> context)\n+        protected PlanAndMappings visitPlan(PlanNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            //TODO: use mapper in other methods\n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source);\n+            throw new UnsupportedOperationException(\"Unsupported plan node \" + node.getClass().getSimpleName());\n         }\n \n         @Override\n-        public PlanNode visitGroupId(GroupIdNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitAggregation(AggregationNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            Map<Symbol, Symbol> newGroupingMappings = new HashMap<>();\n-            ImmutableList.Builder<List<Symbol>> newGroupingSets = ImmutableList.builder();\n+            AggregationNode rewrittenAggregation = mapper.map(node, rewrittenSource.getRoot());\n \n-            for (List<Symbol> groupingSet : node.getGroupingSets()) {\n-                ImmutableList.Builder<Symbol> newGroupingSet = ImmutableList.builder();\n-                for (Symbol output : groupingSet) {\n-                    newGroupingMappings.putIfAbsent(canonicalize(output), canonicalize(node.getGroupingColumns().get(output)));\n-                    newGroupingSet.add(canonicalize(output));\n-                }\n-                newGroupingSets.add(newGroupingSet.build());\n-            }\n+            return new PlanAndMappings(rewrittenAggregation, mapper.getMapping());\n+        }\n+\n+        @Override\n+        public PlanAndMappings visitGroupId(GroupIdNode node, UnaliasContext context)\n+        {\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            return new GroupIdNode(node.getId(), source, newGroupingSets.build(), newGroupingMappings, canonicalizeAndDistinct(node.getAggregationArguments()), canonicalize(node.getGroupIdSymbol()));\n+            GroupIdNode rewrittenGroupId = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenGroupId, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitExplainAnalyze(ExplainAnalyzeNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitExplainAnalyze(ExplainAnalyzeNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            return new ExplainAnalyzeNode(node.getId(), source, canonicalize(node.getOutputSymbol()), node.isVerbose());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Symbol newOutputSymbol = mapper.map(node.getOutputSymbol());\n+\n+            return new PlanAndMappings(\n+                    new ExplainAnalyzeNode(node.getId(), rewrittenSource.getRoot(), newOutputSymbol, node.isVerbose()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitMarkDistinct(MarkDistinctNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitMarkDistinct(MarkDistinctNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            List<Symbol> symbols = canonicalizeAndDistinct(node.getDistinctSymbols());\n-            return new MarkDistinctNode(node.getId(), source, canonicalize(node.getMarkerSymbol()), symbols, canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Symbol newMarkerSymbol = mapper.map(node.getMarkerSymbol());\n+            List<Symbol> newDistinctSymbols = mapper.mapAndDistinct(node.getDistinctSymbols());\n+            Optional<Symbol> newHashSymbol = node.getHashSymbol().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new MarkDistinctNode(\n+                            node.getId(),\n+                            rewrittenSource.getRoot(),\n+                            newMarkerSymbol,\n+                            newDistinctSymbols,\n+                            newHashSymbol),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitUnnest(UnnestNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitUnnest(UnnestNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            ImmutableList.Builder<UnnestNode.Mapping> mappings = ImmutableList.builder();\n+            List<Symbol> newReplicateSymbols = mapper.mapAndDistinct(node.getReplicateSymbols());\n \n-            for (UnnestNode.Mapping mapping : node.getMappings()) {\n-                mappings.add(new UnnestNode.Mapping(canonicalize(mapping.getInput()), mapping.getOutputs()));\n+            ImmutableList.Builder<UnnestNode.Mapping> newMappings = ImmutableList.builder();\n+            for (UnnestNode.Mapping unnestMapping : node.getMappings()) {\n+                newMappings.add(new UnnestNode.Mapping(mapper.map(unnestMapping.getInput()), mapper.map(unnestMapping.getOutputs())));\n             }\n \n-            return new UnnestNode(\n-                    node.getId(),\n-                    source,\n-                    canonicalizeAndDistinct(node.getReplicateSymbols()),\n-                    mappings.build(),\n-                    node.getOrdinalitySymbol(),\n-                    node.getJoinType(),\n-                    node.getFilter().map(this::canonicalize));\n+            Optional<Symbol> newOrdinalitySymbol = node.getOrdinalitySymbol().map(mapper::map);\n+            Optional<Expression> newFilter = node.getFilter().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new UnnestNode(\n+                            node.getId(),\n+                            rewrittenSource.getRoot(),\n+                            newReplicateSymbols,\n+                            newMappings.build(),\n+                            newOrdinalitySymbol,\n+                            node.getJoinType(),\n+                            newFilter),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitWindow(WindowNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitWindow(WindowNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-\n-            ImmutableMap.Builder<Symbol, WindowNode.Function> functions = ImmutableMap.builder();\n-            node.getWindowFunctions().forEach((symbol, function) -> {\n-                ResolvedFunction resolvedFunction = function.getResolvedFunction();\n-                List<Expression> arguments = canonicalize(function.getArguments());\n-                WindowNode.Frame canonicalFrame = canonicalize(function.getFrame());\n-\n-                functions.put(canonicalize(symbol), new WindowNode.Function(resolvedFunction, arguments, canonicalFrame, function.isIgnoreNulls()));\n-            });\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            return new WindowNode(\n-                    node.getId(),\n-                    source,\n-                    canonicalizeAndDistinct(node.getSpecification()),\n-                    functions.build(),\n-                    canonicalize(node.getHashSymbol()),\n-                    canonicalize(node.getPrePartitionedInputs()),\n-                    node.getPreSortedOrderPrefix());\n-        }\n+            WindowNode rewrittenWindow = mapper.map(node, rewrittenSource.getRoot());\n \n-        private WindowNode.Frame canonicalize(WindowNode.Frame frame)\n-        {\n-            return new WindowNode.Frame(\n-                    frame.getType(),\n-                    frame.getStartType(),\n-                    canonicalize(frame.getStartValue()),\n-                    frame.getEndType(),\n-                    canonicalize(frame.getEndValue()),\n-                    frame.getOriginalStartValue(),\n-                    frame.getOriginalEndValue());\n+            return new PlanAndMappings(rewrittenWindow, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTableScan(TableScanNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableScan(TableScanNode node, UnaliasContext context)\n         {\n-            return node;\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            List<Symbol> newOutputs = mapper.map(node.getOutputSymbols());\n+\n+            Map<Symbol, ColumnHandle> newAssignments = new HashMap<>();\n+            node.getAssignments().forEach((symbol, handle) -> {\n+                newAssignments.put(mapper.map(symbol), handle);\n+            });\n+\n+            return new PlanAndMappings(\n+                    new TableScanNode(node.getId(), node.getTable(), newOutputs, newAssignments, node.getEnforcedConstraint()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitExchange(ExchangeNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitExchange(ExchangeNode node, UnaliasContext context)\n         {\n-            List<PlanNode> sources = node.getSources().stream()\n-                    .map(context::rewrite)\n-                    .collect(toImmutableList());\n-\n-            mapExchangeNodeSymbols(node);\n-\n-            List<List<Symbol>> inputs = new ArrayList<>();\n-            for (int i = 0; i < node.getInputs().size(); i++) {\n-                inputs.add(new ArrayList<>());\n+            ImmutableList.Builder<PlanNode> rewrittenChildren = ImmutableList.builder();\n+            ImmutableList.Builder<List<Symbol>> rewrittenInputsBuilder = ImmutableList.builder();\n+\n+            // rewrite child and map corresponding input list accordingly to the child's mapping\n+            for (int i = 0; i < node.getSources().size(); i++) {\n+                PlanAndMappings rewrittenChild = node.getSources().get(i).accept(this, context);\n+                rewrittenChildren.add(rewrittenChild.getRoot());\n+                SymbolMapper mapper = new SymbolMapper(rewrittenChild.getSymbolMappings());\n+                rewrittenInputsBuilder.add(mapper.map(node.getInputs().get(i)));\n             }\n-            Set<Symbol> addedOutputs = new HashSet<>();\n-            ImmutableList.Builder<Symbol> outputs = ImmutableList.builder();\n-            for (int symbolIndex = 0; symbolIndex < node.getOutputSymbols().size(); symbolIndex++) {\n-                Symbol canonicalOutput = canonicalize(node.getOutputSymbols().get(symbolIndex));\n-                if (addedOutputs.add(canonicalOutput)) {\n-                    outputs.add(canonicalOutput);\n-                    for (int i = 0; i < node.getInputs().size(); i++) {\n-                        List<Symbol> input = node.getInputs().get(i);\n-                        inputs.get(i).add(canonicalize(input.get(symbolIndex)));\n-                    }\n+            List<List<Symbol>> rewrittenInputs = rewrittenInputsBuilder.build();\n+\n+            // canonicalize ExchangeNode outputs\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+            List<Symbol> rewrittenOutputs = mapper.map(node.getOutputSymbols());\n+\n+            // sanity check: assert that duplicate outputs result from same inputs\n+            Map<Symbol, List<Symbol>> outputsToInputs = new HashMap<>();\n+            for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                ImmutableList.Builder<Symbol> inputsBuilder = ImmutableList.builder();\n+                for (List<Symbol> inputs : rewrittenInputs) {\n+                    inputsBuilder.add(inputs.get(i));\n                 }\n+                List<Symbol> inputs = inputsBuilder.build();\n+                List<Symbol> previous = outputsToInputs.put(rewrittenOutputs.get(i), inputs);\n+                checkState(previous == null || inputs.equals(previous), \"different inputs mapped to the same output symbol\");\n             }\n \n-            PartitioningScheme partitioningScheme = new PartitioningScheme(\n-                    node.getPartitioningScheme().getPartitioning().translate(this::canonicalize),\n-                    outputs.build(),\n-                    canonicalize(node.getPartitioningScheme().getHashColumn()),\n-                    node.getPartitioningScheme().isReplicateNullsAndAny(),\n-                    node.getPartitioningScheme().getBucketToPartition());\n-\n-            Optional<OrderingScheme> orderingScheme = node.getOrderingScheme().map(this::canonicalizeAndDistinct);\n+            // derive new mappings for ExchangeNode output symbols\n+            Map<Symbol, Symbol> newMapping = new HashMap<>();\n \n-            return new ExchangeNode(node.getId(), node.getType(), node.getScope(), partitioningScheme, sources, inputs, orderingScheme);\n-        }\n-\n-        private void mapExchangeNodeSymbols(ExchangeNode node)\n-        {\n-            if (node.getInputs().size() == 1) {\n-                mapExchangeNodeOutputToInputSymbols(node);\n-                return;\n+            // 1. for a single ExchangeNode source, map outputs to inputs\n+            if (rewrittenInputs.size() == 1) {\n+                for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                    Symbol output = rewrittenOutputs.get(i);\n+                    Symbol input = rewrittenInputs.get(0).get(i);\n+                    if (!output.equals(input)) {\n+                        newMapping.put(output, input);\n+                    }\n+                }\n             }\n \n-            // Mapping from list [node.getInput(0).get(symbolIndex), node.getInput(1).get(symbolIndex), ...] to node.getOutputSymbols(symbolIndex).\n-            // All symbols are canonical.\n+            // 2. for multiple ExchangeNode sources, if different output symbols result from the same lists of canonical input symbols, map all those outputs to the same symbol\n             Map<List<Symbol>, Symbol> inputsToOutputs = new HashMap<>();\n-            // Map each same list of input symbols [I1, I2, ..., In] to the same output symbol O\n-            for (int symbolIndex = 0; symbolIndex < node.getOutputSymbols().size(); symbolIndex++) {\n-                Symbol canonicalOutput = canonicalize(node.getOutputSymbols().get(symbolIndex));\n-                List<Symbol> canonicalInputs = canonicalizeExchangeNodeInputs(node, symbolIndex);\n-                Symbol output = inputsToOutputs.get(canonicalInputs);\n-\n-                if (output == null || canonicalOutput.equals(output)) {\n-                    inputsToOutputs.put(canonicalInputs, canonicalOutput);\n+            for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                ImmutableList.Builder<Symbol> inputsBuilder = ImmutableList.builder();\n+                for (List<Symbol> inputs : rewrittenInputs) {\n+                    inputsBuilder.add(inputs.get(i));\n+                }\n+                List<Symbol> inputs = inputsBuilder.build();\n+                Symbol previous = inputsToOutputs.get(inputs);\n+                if (previous == null || rewrittenOutputs.get(i).equals(previous)) {\n+                    inputsToOutputs.put(inputs, rewrittenOutputs.get(i));\n                 }\n                 else {\n-                    map(canonicalOutput, output);\n+                    newMapping.put(rewrittenOutputs.get(i), previous);\n                 }\n             }\n-        }\n \n-        private void mapExchangeNodeOutputToInputSymbols(ExchangeNode node)\n-        {\n-            checkState(node.getInputs().size() == 1);\n+            Map<Symbol, Symbol> outputMapping = new HashMap<>();\n+            outputMapping.putAll(mapper.getMapping());\n+            outputMapping.putAll(newMapping);\n \n-            for (int symbolIndex = 0; symbolIndex < node.getOutputSymbols().size(); symbolIndex++) {\n-                Symbol canonicalOutput = canonicalize(node.getOutputSymbols().get(symbolIndex));\n-                Symbol canonicalInput = canonicalize(node.getInputs().get(0).get(symbolIndex));\n+            mapper = new SymbolMapper(outputMapping);\n \n-                if (!canonicalOutput.equals(canonicalInput)) {\n-                    map(canonicalOutput, canonicalInput);\n+            // deduplicate outputs and prune input symbols lists accordingly\n+            List<List<Symbol>> newInputs = new ArrayList<>();\n+            for (int i = 0; i < node.getInputs().size(); i++) {\n+                newInputs.add(new ArrayList<>());\n+            }\n+            ImmutableList.Builder<Symbol> newOutputs = ImmutableList.builder();\n+            Set<Symbol> addedOutputs = new HashSet<>();\n+            for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                Symbol output = mapper.map(rewrittenOutputs.get(i));\n+                if (addedOutputs.add(output)) {\n+                    newOutputs.add(output);\n+                    for (int j = 0; j < rewrittenInputs.size(); j++) {\n+                        newInputs.get(j).add(rewrittenInputs.get(j).get(i));\n+                    }\n                 }\n             }\n-        }\n \n-        private List<Symbol> canonicalizeExchangeNodeInputs(ExchangeNode node, int symbolIndex)\n-        {\n-            return node.getInputs().stream()\n-                    .map(input -> canonicalize(input.get(symbolIndex)))\n-                    .collect(toImmutableList());\n+            // rewrite PartitioningScheme\n+            PartitioningScheme newPartitioningScheme = mapper.map(node.getPartitioningScheme(), newOutputs.build());\n+\n+            // rewrite OrderingScheme\n+            Optional<OrderingScheme> newOrderingScheme = node.getOrderingScheme().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new ExchangeNode(\n+                            node.getId(),\n+                            node.getType(),\n+                            node.getScope(),\n+                            newPartitioningScheme,\n+                            rewrittenChildren.build(),\n+                            newInputs,\n+                            newOrderingScheme),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitRemoteSource(RemoteSourceNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitRemoteSource(RemoteSourceNode node, UnaliasContext context)\n         {\n-            return new RemoteSourceNode(\n-                    node.getId(),\n-                    node.getSourceFragmentIds(),\n-                    canonicalizeAndDistinct(node.getOutputSymbols()),\n-                    node.getOrderingScheme().map(this::canonicalizeAndDistinct),\n-                    node.getExchangeType());\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            List<Symbol> newOutputs = mapper.mapAndDistinct(node.getOutputSymbols());\n+            Optional<OrderingScheme> newOrderingScheme = node.getOrderingScheme().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new RemoteSourceNode(\n+                            node.getId(),\n+                            node.getSourceFragmentIds(),\n+                            newOutputs,\n+                            newOrderingScheme,\n+                            node.getExchangeType()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitOffset(OffsetNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitOffset(OffsetNode node, UnaliasContext context)\n         {\n-            return context.defaultRewrite(node);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+\n+            return new PlanAndMappings(\n+                    node.replaceChildren(ImmutableList.of(rewrittenSource.getRoot())),\n+                    rewrittenSource.getSymbolMappings());\n         }\n \n         @Override\n-        public PlanNode visitLimit(LimitNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitLimit(LimitNode node, UnaliasContext context)\n         {\n-            if (node.isWithTies()) {\n-                PlanNode source = context.rewrite(node.getSource());\n-                return new LimitNode(node.getId(), source, node.getCount(), node.getTiesResolvingScheme().map(this::canonicalizeAndDistinct), node.isPartial());\n-            }\n-            return context.defaultRewrite(node);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            LimitNode rewrittenLimit = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenLimit, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitDistinctLimit(DistinctLimitNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitDistinctLimit(DistinctLimitNode node, UnaliasContext context)\n         {\n-            return new DistinctLimitNode(node.getId(), context.rewrite(node.getSource()), node.getLimit(), node.isPartial(), canonicalizeAndDistinct(node.getDistinctSymbols()), canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            DistinctLimitNode rewrittenDistinctLimit = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenDistinctLimit, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitSample(SampleNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitSample(SampleNode node, UnaliasContext context)\n         {\n-            return new SampleNode(node.getId(), context.rewrite(node.getSource()), node.getSampleRatio(), node.getSampleType());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+\n+            return new PlanAndMappings(\n+                    node.replaceChildren(ImmutableList.of(rewrittenSource.getRoot())),\n+                    rewrittenSource.getSymbolMappings());\n         }\n \n         @Override\n-        public PlanNode visitValues(ValuesNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitValues(ValuesNode node, UnaliasContext context)\n         {\n-            List<List<Expression>> canonicalizedRows = node.getRows().stream()\n-                    .map(this::canonicalize)\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            List<List<Expression>> newRows = node.getRows().stream()\n+                    .map(row -> row.stream()\n+                            .map(mapper::map)\n+                            .collect(toImmutableList()))\n                     .collect(toImmutableList());\n-            List<Symbol> canonicalizedOutputSymbols = canonicalizeAndDistinct(node.getOutputSymbols());\n-            checkState(node.getOutputSymbols().size() == canonicalizedOutputSymbols.size(), \"Values output symbols were pruned\");\n-            return new ValuesNode(\n-                    node.getId(),\n-                    canonicalizedOutputSymbols,\n-                    canonicalizedRows);\n+\n+            List<Symbol> newOutputSymbols = mapper.mapAndDistinct(node.getOutputSymbols());\n+            checkState(node.getOutputSymbols().size() == newOutputSymbols.size(), \"Values output symbols were pruned\");\n+\n+            return new PlanAndMappings(\n+                    new ValuesNode(node.getId(), newOutputSymbols, newRows),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTableDelete(TableDeleteNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableDelete(TableDeleteNode node, UnaliasContext context)\n         {\n-            return node;\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            Symbol newOutput = mapper.map(node.getOutput());\n+\n+            return new PlanAndMappings(\n+                    new TableDeleteNode(node.getId(), node.getTarget(), newOutput),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitDelete(DeleteNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitDelete(DeleteNode node, UnaliasContext context)\n         {\n-            return new DeleteNode(node.getId(), context.rewrite(node.getSource()), node.getTarget(), canonicalize(node.getRowId()), node.getOutputSymbols());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Symbol newRowId = mapper.map(node.getRowId());\n+            List<Symbol> newOutputs = mapper.map(node.getOutputSymbols());\n+\n+            return new PlanAndMappings(\n+                    new DeleteNode(\n+                            node.getId(),\n+                            rewrittenSource.getRoot(),\n+                            node.getTarget(),\n+                            newRowId,\n+                            newOutputs),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitStatisticsWriterNode(StatisticsWriterNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitStatisticsWriterNode(StatisticsWriterNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            StatisticsWriterNode rewrittenStatisticsWriter = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenStatisticsWriter, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTableFinish(TableFinishNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableWriter(TableWriterNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            TableWriterNode rewrittenTableWriter = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTableWriter, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitRowNumber(RowNumberNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableFinish(TableFinishNode node, UnaliasContext context)\n         {\n-            return new RowNumberNode(\n-                    node.getId(),\n-                    context.rewrite(node.getSource()),\n-                    canonicalizeAndDistinct(node.getPartitionBy()),\n-                    node.isOrderSensitive(),\n-                    canonicalize(node.getRowNumberSymbol()),\n-                    node.getMaxRowCountPerPartition(),\n-                    canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            TableFinishNode rewrittenTableFinish = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTableFinish, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTopNRowNumber(TopNRowNumberNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitRowNumber(RowNumberNode node, UnaliasContext context)\n         {\n-            return new TopNRowNumberNode(\n-                    node.getId(),\n-                    context.rewrite(node.getSource()),\n-                    canonicalizeAndDistinct(node.getSpecification()),\n-                    canonicalize(node.getRowNumberSymbol()),\n-                    node.getMaxRowCountPerPartition(),\n-                    node.isPartial(),\n-                    canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            RowNumberNode rewrittenRowNumber = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenRowNumber, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitFilter(FilterNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTopNRowNumber(TopNRowNumberNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            return new FilterNode(node.getId(), source, canonicalize(node.getPredicate()));\n+            TopNRowNumberNode rewrittenTopNRowNumber = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTopNRowNumber, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitProject(ProjectNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTopN(TopNNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            return new ProjectNode(node.getId(), source, canonicalize(node.getAssignments()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            TopNNode rewrittenTopN = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTopN, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitOutput(OutputNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitSort(SortNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            List<Symbol> canonical = Lists.transform(node.getOutputSymbols(), this::canonicalize);\n-            return new OutputNode(node.getId(), source, node.getColumnNames(), canonical);\n+            OrderingScheme newOrderingScheme = mapper.map(node.getOrderingScheme());\n+\n+            return new PlanAndMappings(\n+                    new SortNode(node.getId(), rewrittenSource.getRoot(), newOrderingScheme, node.isPartial()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitEnforceSingleRow(EnforceSingleRowNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitFilter(FilterNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Expression newPredicate = mapper.map(node.getPredicate());\n \n-            return new EnforceSingleRowNode(node.getId(), source);\n+            return new PlanAndMappings(\n+                    new FilterNode(node.getId(), rewrittenSource.getRoot(), newPredicate),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitAssignUniqueId(AssignUniqueId node, RewriteContext<Void> context)\n+        public PlanAndMappings visitProject(ProjectNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            // canonicalize ProjectNode assignments\n+            ImmutableList.Builder<Map.Entry<Symbol, Expression>> builder = ImmutableList.builder();\n+            for (Map.Entry<Symbol, Expression> assignment : node.getAssignments().entrySet()) {\n+                builder.add(new SimpleEntry<>(mapper.map(assignment.getKey()), mapper.map(assignment.getValue())));\n+            }\n+            List<Map.Entry<Symbol, Expression>> rewrittenAssignments = builder.build();\n \n-            return new AssignUniqueId(node.getId(), source, node.getIdColumn());\n+            // deduplicate assignments\n+            Map<Symbol, Expression> deduplicateAssignments = new HashMap<>();\n+            for (Map.Entry<Symbol, Expression> assignment : rewrittenAssignments) {\n+                Expression previous = deduplicateAssignments.put(assignment.getKey(), assignment.getValue());\n+                checkState(previous == null || assignment.getValue().equals(previous), \"different expressions projected to the same symbol\");\n+            }\n+\n+            // derive new mappings for ProjectNode output symbols\n+            Map<Symbol, Symbol> newMapping = new HashMap<>();\n+            Map<Expression, Symbol> inputsToOutputs = new HashMap<>();\n+            for (Map.Entry<Symbol, Expression> assignment : deduplicateAssignments.entrySet()) {\n+                Expression expression = assignment.getValue();\n+                // 1. for trivial symbol projection, map output symbol to input symbol\n+                if (expression instanceof SymbolReference) {\n+                    Symbol value = Symbol.from(expression);\n+                    if (!assignment.getKey().equals(value)) {\n+                        newMapping.put(assignment.getKey(), value);\n+                    }\n+                }\n+                // 2. map same deterministic expressions within a projection into the same symbol\n+                // omit NullLiterals since those have ambiguous types\n+                else if (DeterminismEvaluator.isDeterministic(expression, metadata) && !(expression instanceof NullLiteral)) {\n+                    Symbol previous = inputsToOutputs.get(expression);\n+                    if (previous == null || assignment.getKey().equals(previous)) {\n+                        inputsToOutputs.put(expression, assignment.getKey());\n+                    }\n+                    else {\n+                        newMapping.put(assignment.getKey(), previous);\n+                    }\n+                }\n+            }\n+\n+            Map<Symbol, Symbol> outputMapping = new HashMap<>();\n+            outputMapping.putAll(mapper.getMapping());\n+            outputMapping.putAll(newMapping);\n+\n+            mapper = new SymbolMapper(outputMapping);\n+\n+            // build new Assignments with canonical outputs\n+            // duplicate entries will be removed by the Builder\n+            Assignments.Builder newAssignments = Assignments.builder();\n+            for (Map.Entry<Symbol, Expression> assignment : deduplicateAssignments.entrySet()) {\n+                newAssignments.put(mapper.map(assignment.getKey()), assignment.getValue());\n+            }\n+\n+            return new PlanAndMappings(\n+                    new ProjectNode(node.getId(), rewrittenSource.getRoot(), newAssignments.build()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitApply(ApplyNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitOutput(OutputNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getInput());\n-            PlanNode subquery = context.rewrite(node.getSubquery());\n-            List<Symbol> canonicalCorrelation = Lists.transform(node.getCorrelation(), this::canonicalize);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            return new ApplyNode(node.getId(), source, subquery, canonicalize(node.getSubqueryAssignments()), canonicalCorrelation, node.getOriginSubquery());\n+            List<Symbol> newOutputs = mapper.map(node.getOutputSymbols());\n+\n+            return new PlanAndMappings(\n+                    new OutputNode(node.getId(), rewrittenSource.getRoot(), node.getColumnNames(), newOutputs),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitCorrelatedJoin(CorrelatedJoinNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitEnforceSingleRow(EnforceSingleRowNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getInput());\n-            PlanNode subquery = context.rewrite(node.getSubquery());\n-            List<Symbol> canonicalCorrelation = canonicalizeAndDistinct(node.getCorrelation());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n \n-            return new CorrelatedJoinNode(node.getId(), source, subquery, canonicalCorrelation, node.getType(), canonicalize(node.getFilter()), node.getOriginSubquery());\n+            return new PlanAndMappings(\n+                    node.replaceChildren(ImmutableList.of(rewrittenSource.getRoot())),\n+                    rewrittenSource.getSymbolMappings());\n         }\n \n         @Override\n-        public PlanNode visitTopN(TopNNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitAssignUniqueId(AssignUniqueId node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Symbol newUnique = mapper.map(node.getIdColumn());\n \n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source, node.getId());\n+            return new PlanAndMappings(\n+                    new AssignUniqueId(node.getId(), rewrittenSource.getRoot(), newUnique),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitSort(SortNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitApply(ApplyNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            // it is assumed that apart from correlation (and possibly outer correlation), symbols are distinct between Input and Subquery\n+            // rewrite Input\n+            PlanAndMappings rewrittenInput = node.getInput().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenInput.getSymbolMappings());\n+\n+            // rewrite correlation with mapping from Input\n+            List<Symbol> rewrittenCorrelation = mapper.mapAndDistinct(node.getCorrelation());\n+\n+            // extract new mappings for correlation symbols to apply in Subquery\n+            Set<Symbol> correlationSymbols = ImmutableSet.copyOf(node.getCorrelation());\n+            Map<Symbol, Symbol> correlationMapping = mapper.getMapping().entrySet().stream()\n+                    .filter(mapping -> correlationSymbols.contains(mapping.getKey()))\n+                    .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+            Map<Symbol, Symbol> mappingForSubquery = new HashMap<>();\n+            mappingForSubquery.putAll(context.getCorrelationMapping());\n+            mappingForSubquery.putAll(correlationMapping);\n+\n+            // rewrite Subquery\n+            PlanAndMappings rewrittenSubquery = node.getSubquery().accept(this, new UnaliasContext(mappingForSubquery));\n+\n+            // unify mappings from Input and Subquery to rewrite Subquery assignments\n+            Map<Symbol, Symbol> resultMapping = new HashMap<>();\n+            resultMapping.putAll(rewrittenInput.getSymbolMappings());\n+            resultMapping.putAll(rewrittenSubquery.getSymbolMappings());\n+            mapper = new SymbolMapper(resultMapping);\n+\n+            ImmutableList.Builder<Map.Entry<Symbol, Expression>> builder = ImmutableList.builder();\n+            for (Map.Entry<Symbol, Expression> assignment : node.getSubqueryAssignments().entrySet()) {\n+                builder.add(new SimpleEntry<>(mapper.map(assignment.getKey()), mapper.map(assignment.getValue())));\n+            }\n+            List<Map.Entry<Symbol, Expression>> rewrittenAssignments = builder.build();\n \n-            return new SortNode(node.getId(), source, canonicalizeAndDistinct(node.getOrderingScheme()), node.isPartial());\n+            // deduplicate assignments\n+            Map<Symbol, Expression> deduplicateAssignments = new HashMap<>();\n+            for (Map.Entry<Symbol, Expression> assignment : rewrittenAssignments) {\n+                Expression previous = deduplicateAssignments.put(assignment.getKey(), assignment.getValue());\n+                checkState(previous == null || assignment.getValue().equals(previous), \"different expressions assigned to the same symbol\");\n+            }\n+\n+            // derive new mappings for Subquery assignments outputs\n+            Map<Expression, Symbol> inputsToOutputs = new HashMap<>();\n+            Map<Symbol, Symbol> newMapping = new HashMap<>();\n+            for (Map.Entry<Symbol, Expression> assignment : deduplicateAssignments.entrySet()) {\n+                Expression expression = assignment.getValue();\n+                // 1. for trivial symbol projection, map output symbol to input symbol\n+                if (expression instanceof SymbolReference) {\n+                    Symbol value = Symbol.from(expression);\n+                    if (!assignment.getKey().equals(value)) {\n+                        newMapping.put(assignment.getKey(), value);\n+                    }\n+                }\n+                // 2. map same deterministic expressions within a projection into the same symbol\n+                // omit NullLiterals since those have ambiguous types\n+                else if (DeterminismEvaluator.isDeterministic(expression, metadata) && !(expression instanceof NullLiteral)) {\n+                    Symbol previous = inputsToOutputs.get(expression);\n+                    if (previous == null || assignment.getKey().equals(previous)) {\n+                        inputsToOutputs.put(expression, assignment.getKey());\n+                    }\n+                    else {\n+                        newMapping.put(assignment.getKey(), previous);\n+                    }\n+                }\n+            }\n+\n+            Map<Symbol, Symbol> assignmentsOutputMapping = new HashMap<>();\n+            assignmentsOutputMapping.putAll(mapper.getMapping());\n+            assignmentsOutputMapping.putAll(newMapping);\n+\n+            mapper = new SymbolMapper(assignmentsOutputMapping);\n+\n+            // build new Assignments with canonical outputs\n+            // duplicate entries will be removed by the Builder\n+            Assignments.Builder newAssignments = Assignments.builder();\n+            for (Map.Entry<Symbol, Expression> assignment : deduplicateAssignments.entrySet()) {\n+                newAssignments.put(mapper.map(assignment.getKey()), assignment.getValue());\n+            }\n+\n+            return new PlanAndMappings(\n+                    new ApplyNode(node.getId(), rewrittenInput.getRoot(), rewrittenSubquery.getRoot(), newAssignments.build(), rewrittenCorrelation, node.getOriginSubquery()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitJoin(JoinNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitCorrelatedJoin(CorrelatedJoinNode node, UnaliasContext context)\n         {\n-            PlanNode left = context.rewrite(node.getLeft());\n-            PlanNode right = context.rewrite(node.getRight());\n+            // it is assumed that apart from correlation (and possibly outer correlation), symbols are distinct between left and right CorrelatedJoin source\n+            // rewrite Input\n+            PlanAndMappings rewrittenInput = node.getInput().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenInput.getSymbolMappings());\n+\n+            // rewrite correlation with mapping from Input\n+            List<Symbol> rewrittenCorrelation = mapper.mapAndDistinct(node.getCorrelation());\n+\n+            // extract new mappings for correlation symbols to apply in Subquery\n+            Set<Symbol> correlationSymbols = ImmutableSet.copyOf(node.getCorrelation());\n+            Map<Symbol, Symbol> correlationMapping = mapper.getMapping().entrySet().stream()\n+                    .filter(mapping -> correlationSymbols.contains(mapping.getKey()))\n+                    .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+            Map<Symbol, Symbol> mappingForSubquery = new HashMap<>();\n+            mappingForSubquery.putAll(context.getCorrelationMapping());\n+            mappingForSubquery.putAll(correlationMapping);\n+\n+            // rewrite Subquery\n+            PlanAndMappings rewrittenSubquery = node.getSubquery().accept(this, new UnaliasContext(mappingForSubquery));\n+\n+            // unify mappings from Input and Subquery\n+            Map<Symbol, Symbol> resultMapping = new HashMap<>();\n+            resultMapping.putAll(rewrittenInput.getSymbolMappings());\n+            resultMapping.putAll(rewrittenSubquery.getSymbolMappings());\n+\n+            // rewrite filter with unified mapping\n+            mapper = new SymbolMapper(resultMapping);\n+            Expression newFilter = mapper.map(node.getFilter());\n+\n+            return new PlanAndMappings(\n+                    new CorrelatedJoinNode(node.getId(), rewrittenInput.getRoot(), rewrittenSubquery.getRoot(), rewrittenCorrelation, node.getType(), newFilter, node.getOriginSubquery()),\n+                    mapper.getMapping());\n+        }\n \n-            List<JoinNode.EquiJoinClause> canonicalCriteria = canonicalizeJoinCriteria(node.getCriteria());\n-            Optional<Expression> canonicalFilter = node.getFilter().map(this::canonicalize);\n-            Optional<Symbol> canonicalLeftHashSymbol = canonicalize(node.getLeftHashSymbol());\n-            Optional<Symbol> canonicalRightHashSymbol = canonicalize(node.getRightHashSymbol());\n+        @Override\n+        public PlanAndMappings visitJoin(JoinNode node, UnaliasContext context)\n+        {\n+            // it is assumed that symbols are distinct between left and right join source. Only symbols from outer correlation might be the exception\n+            PlanAndMappings rewrittenLeft = node.getLeft().accept(this, context);\n+            PlanAndMappings rewrittenRight = node.getRight().accept(this, context);\n \n-            Map<String, Symbol> canonicalDynamicFilters = canonicalizeAndDistinct(node.getDynamicFilters());\n+            // unify mappings from left and right join source\n+            Map<Symbol, Symbol> unifiedMapping = new HashMap<>();\n+            unifiedMapping.putAll(rewrittenLeft.getSymbolMappings());\n+            unifiedMapping.putAll(rewrittenRight.getSymbolMappings());\n+\n+            SymbolMapper mapper = new SymbolMapper(unifiedMapping);\n+\n+            ImmutableList.Builder<JoinNode.EquiJoinClause> builder = ImmutableList.builder();\n+            for (JoinNode.EquiJoinClause clause : node.getCriteria()) {\n+                builder.add(new JoinNode.EquiJoinClause(mapper.map(clause.getLeft()), mapper.map(clause.getRight())));\n+            }\n+            List<JoinNode.EquiJoinClause> newCriteria = builder.build();\n+\n+            Optional<Expression> newFilter = node.getFilter().map(mapper::map);\n+            Optional<Symbol> newLeftHashSymbol = node.getLeftHashSymbol().map(mapper::map);\n+            Optional<Symbol> newRightHashSymbol = node.getRightHashSymbol().map(mapper::map);\n+\n+            // rewrite dynamic filters\n+            Set<Symbol> added = new HashSet<>();\n+            ImmutableMap.Builder<String, Symbol> filtersBuilder = ImmutableMap.builder();\n+            for (Map.Entry<String, Symbol> entry : node.getDynamicFilters().entrySet()) {\n+                Symbol canonical = mapper.map(entry.getValue());\n+                if (added.add(canonical)) {\n+                    filtersBuilder.put(entry.getKey(), canonical);\n+                }\n+            }\n+            Map<String, Symbol> newDynamicFilters = filtersBuilder.build();\n \n+            // derive new mappings from inner join equi criteria\n+            Map<Symbol, Symbol> newMapping = new HashMap<>();\n             if (node.getType() == INNER) {\n-                canonicalCriteria.stream()\n+                newCriteria.stream()\n                         // Map right equi-condition symbol to left symbol. This helps to\n                         // reuse join node partitioning better as partitioning properties are\n                         // only derived from probe side symbols\n-                        .forEach(clause -> map(clause.getRight(), clause.getLeft()));\n+                        .forEach(clause -> newMapping.put(clause.getRight(), clause.getLeft()));\n             }\n \n-            List<Symbol> canonicalOutputs = canonicalizeAndDistinct(node.getOutputSymbols());\n-            List<Symbol> leftOutputSymbols = canonicalOutputs.stream()\n-                    .filter(left.getOutputSymbols()::contains)\n+            Map<Symbol, Symbol> outputMapping = new HashMap<>();\n+            outputMapping.putAll(mapper.getMapping());\n+            outputMapping.putAll(newMapping);\n+\n+            mapper = new SymbolMapper(outputMapping);\n+            List<Symbol> canonicalOutputs = mapper.mapAndDistinct(node.getOutputSymbols());\n+            List<Symbol> newLeftOutputSymbols = canonicalOutputs.stream()\n+                    .filter(rewrittenLeft.getRoot().getOutputSymbols()::contains)\n                     .collect(toImmutableList());\n-            List<Symbol> rightOutputSymbols = canonicalOutputs.stream()\n-                    .filter(right.getOutputSymbols()::contains)\n+            List<Symbol> newRightOutputSymbols = canonicalOutputs.stream()\n+                    .filter(rewrittenRight.getRoot().getOutputSymbols()::contains)\n                     .collect(toImmutableList());\n \n-            return new JoinNode(\n-                    node.getId(),\n-                    node.getType(),\n-                    left,\n-                    right,\n-                    canonicalCriteria,\n-                    leftOutputSymbols,\n-                    rightOutputSymbols,\n-                    canonicalFilter,\n-                    canonicalLeftHashSymbol,\n-                    canonicalRightHashSymbol,\n-                    node.getDistributionType(),\n-                    node.isSpillable(),\n-                    canonicalDynamicFilters,\n-                    node.getReorderJoinStatsAndCost());\n+            return new PlanAndMappings(\n+                    new JoinNode(\n+                            node.getId(),\n+                            node.getType(),\n+                            rewrittenLeft.getRoot(),\n+                            rewrittenRight.getRoot(),\n+                            newCriteria,\n+                            newLeftOutputSymbols,\n+                            newRightOutputSymbols,\n+                            newFilter,\n+                            newLeftHashSymbol,\n+                            newRightHashSymbol,\n+                            node.getDistributionType(),\n+                            node.isSpillable(),\n+                            newDynamicFilters,\n+                            node.getReorderJoinStatsAndCost()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitSemiJoin(SemiJoinNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitSemiJoin(SemiJoinNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            PlanNode filteringSource = context.rewrite(node.getFilteringSource());\n-\n-            return new SemiJoinNode(\n-                    node.getId(),\n-                    source,\n-                    filteringSource,\n-                    canonicalize(node.getSourceJoinSymbol()),\n-                    canonicalize(node.getFilteringSourceJoinSymbol()),\n-                    canonicalize(node.getSemiJoinOutput()),\n-                    canonicalize(node.getSourceHashSymbol()),\n-                    canonicalize(node.getFilteringSourceHashSymbol()),\n-                    node.getDistributionType());\n+            // it is assumed that symbols are distinct between SemiJoin source and filtering source. Only symbols from outer correlation might be the exception\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            PlanAndMappings rewrittenFilteringSource = node.getFilteringSource().accept(this, context);\n+\n+            Map<Symbol, Symbol> outputMapping = new HashMap<>();\n+            outputMapping.putAll(rewrittenSource.getSymbolMappings());\n+            outputMapping.putAll(rewrittenFilteringSource.getSymbolMappings());\n+\n+            SymbolMapper mapper = new SymbolMapper(outputMapping);\n+\n+            Symbol newSourceJoinSymbol = mapper.map(node.getSourceJoinSymbol());\n+            Symbol newFilteringSourceJoinSymbol = mapper.map(node.getFilteringSourceJoinSymbol());\n+            Symbol newSemiJoinOutput = mapper.map(node.getSemiJoinOutput());\n+            Optional<Symbol> newSourceHashSymbol = node.getSourceHashSymbol().map(mapper::map);\n+            Optional<Symbol> newFilteringSourceHashSymbol = node.getFilteringSourceHashSymbol().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new SemiJoinNode(\n+                            node.getId(),\n+                            rewrittenSource.getRoot(),\n+                            rewrittenFilteringSource.getRoot(),\n+                            newSourceJoinSymbol,\n+                            newFilteringSourceJoinSymbol,\n+                            newSemiJoinOutput,\n+                            newSourceHashSymbol,\n+                            newFilteringSourceHashSymbol,\n+                            node.getDistributionType()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitSpatialJoin(SpatialJoinNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitSpatialJoin(SpatialJoinNode node, UnaliasContext context)\n         {\n-            PlanNode left = context.rewrite(node.getLeft());\n-            PlanNode right = context.rewrite(node.getRight());\n+            // it is assumed that symbols are distinct between left and right SpatialJoin source. Only symbols from outer correlation might be the exception\n+            PlanAndMappings rewrittenLeft = node.getLeft().accept(this, context);\n+            PlanAndMappings rewrittenRight = node.getRight().accept(this, context);\n \n-            return new SpatialJoinNode(node.getId(), node.getType(), left, right, canonicalizeAndDistinct(node.getOutputSymbols()), canonicalize(node.getFilter()), canonicalize(node.getLeftPartitionSymbol()), canonicalize(node.getRightPartitionSymbol()), node.getKdbTree());\n-        }\n+            Map<Symbol, Symbol> outputMapping = new HashMap<>();\n+            outputMapping.putAll(rewrittenLeft.getSymbolMappings());\n+            outputMapping.putAll(rewrittenRight.getSymbolMappings());\n \n-        @Override\n-        public PlanNode visitIndexSource(IndexSourceNode node, RewriteContext<Void> context)\n-        {\n-            return new IndexSourceNode(node.getId(), node.getIndexHandle(), node.getTableHandle(), canonicalize(node.getLookupSymbols()), node.getOutputSymbols(), node.getAssignments());\n-        }\n+            SymbolMapper mapper = new SymbolMapper(outputMapping);\n \n-        @Override\n-        public PlanNode visitIndexJoin(IndexJoinNode node, RewriteContext<Void> context)\n-        {\n-            PlanNode probeSource = context.rewrite(node.getProbeSource());\n-            PlanNode indexSource = context.rewrite(node.getIndexSource());\n+            List<Symbol> newOutputSymbols = mapper.mapAndDistinct(node.getOutputSymbols());\n+            Expression newFilter = mapper.map(node.getFilter());\n+            Optional<Symbol> newLeftPartitionSymbol = node.getLeftPartitionSymbol().map(mapper::map);\n+            Optional<Symbol> newRightPartitionSymbol = node.getRightPartitionSymbol().map(mapper::map);\n \n-            return new IndexJoinNode(node.getId(), node.getType(), probeSource, indexSource, canonicalizeIndexJoinCriteria(node.getCriteria()), canonicalize(node.getProbeHashSymbol()), canonicalize(node.getIndexHashSymbol()));\n+            return new PlanAndMappings(\n+                    new SpatialJoinNode(node.getId(), node.getType(), rewrittenLeft.getRoot(), rewrittenRight.getRoot(), newOutputSymbols, newFilter, newLeftPartitionSymbol, newRightPartitionSymbol, node.getKdbTree()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitUnion(UnionNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitIndexJoin(IndexJoinNode node, UnaliasContext context)\n         {\n-            return new UnionNode(node.getId(), rewriteSources(node, context).build(), canonicalizeSetOperationSymbolMap(node.getSymbolMapping()), canonicalizeAndDistinct(node.getOutputSymbols()));\n-        }\n+            // it is assumed that symbols are distinct between probeSource and indexSource. Only symbols from outer correlation might be the exception\n+            PlanAndMappings rewrittenProbe = node.getProbeSource().accept(this, context);\n+            PlanAndMappings rewrittenIndex = node.getIndexSource().accept(this, context);\n \n-        @Override\n-        public PlanNode visitIntersect(IntersectNode node, RewriteContext<Void> context)\n-        {\n-            return new IntersectNode(node.getId(), rewriteSources(node, context).build(), canonicalizeSetOperationSymbolMap(node.getSymbolMapping()), canonicalizeAndDistinct(node.getOutputSymbols()));\n-        }\n+            Map<Symbol, Symbol> outputMapping = new HashMap<>();\n+            outputMapping.putAll(rewrittenProbe.getSymbolMappings());\n+            outputMapping.putAll(rewrittenIndex.getSymbolMappings());\n \n-        @Override\n-        public PlanNode visitExcept(ExceptNode node, RewriteContext<Void> context)\n-        {\n-            return new ExceptNode(node.getId(), rewriteSources(node, context).build(), canonicalizeSetOperationSymbolMap(node.getSymbolMapping()), canonicalizeAndDistinct(node.getOutputSymbols()));\n-        }\n+            SymbolMapper mapper = new SymbolMapper(outputMapping);\n \n-        private static ImmutableList.Builder<PlanNode> rewriteSources(SetOperationNode node, RewriteContext<Void> context)\n-        {\n-            ImmutableList.Builder<PlanNode> rewrittenSources = ImmutableList.builder();\n-            for (PlanNode source : node.getSources()) {\n-                rewrittenSources.add(context.rewrite(source));\n+            // canonicalize index join criteria\n+            ImmutableList.Builder<IndexJoinNode.EquiJoinClause> builder = ImmutableList.builder();\n+            for (IndexJoinNode.EquiJoinClause clause : node.getCriteria()) {\n+                builder.add(new IndexJoinNode.EquiJoinClause(mapper.map(clause.getProbe()), mapper.map(clause.getIndex())));\n             }\n-            return rewrittenSources;\n+            List<IndexJoinNode.EquiJoinClause> newEquiCriteria = builder.build();\n+\n+            Optional<Symbol> newProbeHashSymbol = node.getProbeHashSymbol().map(mapper::map);\n+            Optional<Symbol> newIndexHashSymbol = node.getIndexHashSymbol().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new IndexJoinNode(node.getId(), node.getType(), rewrittenProbe.getRoot(), rewrittenIndex.getRoot(), newEquiCriteria, newProbeHashSymbol, newIndexHashSymbol),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTableWriter(TableWriterNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitIndexSource(IndexSourceNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source);\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            Set<Symbol> newLookupSymbols = node.getLookupSymbols().stream()\n+                    .map(mapper::map)\n+                    .collect(toImmutableSet());\n+            List<Symbol> newOutputSymbols = mapper.mapAndDistinct(node.getOutputSymbols());\n+\n+            Map<Symbol, ColumnHandle> newAssignments = new HashMap<>();\n+            node.getAssignments().entrySet().stream()\n+                    .forEach(assignment -> newAssignments.put(mapper.map(assignment.getKey()), assignment.getValue()));\n+\n+            return new PlanAndMappings(\n+                    new IndexSourceNode(node.getId(), node.getIndexHandle(), node.getTableHandle(), newLookupSymbols, newOutputSymbols, newAssignments),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        protected PlanNode visitPlan(PlanNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitUnion(UnionNode node, UnaliasContext context)\n         {\n-            throw new UnsupportedOperationException(\"Unsupported plan node \" + node.getClass().getSimpleName());\n-        }\n+            List<PlanAndMappings> rewrittenSources = node.getSources().stream()\n+                    .map(source -> source.accept(this, context))\n+                    .collect(toImmutableList());\n \n-        private void map(Symbol symbol, Symbol canonical)\n-        {\n-            Preconditions.checkArgument(!symbol.equals(canonical), \"Can't map symbol to itself: %s\", symbol);\n-            mapping.put(symbol, canonical);\n-        }\n+            List<SymbolMapper> inputMappers = rewrittenSources.stream()\n+                    .map(source -> new SymbolMapper(source.getSymbolMappings()))\n+                    .collect(toImmutableList());\n \n-        private Assignments canonicalize(Assignments oldAssignments)\n-        {\n-            Map<Expression, Symbol> computedExpressions = new HashMap<>();\n-            Assignments.Builder assignments = Assignments.builder();\n-            for (Map.Entry<Symbol, Expression> entry : oldAssignments.getMap().entrySet()) {\n-                Expression expression = canonicalize(entry.getValue());\n+            SymbolMapper outputMapper = new SymbolMapper(context.getCorrelationMapping());\n \n-                if (expression instanceof SymbolReference) {\n-                    // Always map a trivial symbol projection\n-                    Symbol symbol = Symbol.from(expression);\n-                    if (!symbol.equals(entry.getKey())) {\n-                        map(entry.getKey(), symbol);\n-                    }\n-                }\n-                else if (DeterminismEvaluator.isDeterministic(expression, metadata) && !(expression instanceof NullLiteral)) {\n-                    // Try to map same deterministic expressions within a projection into the same symbol\n-                    // Omit NullLiterals since those have ambiguous types\n-                    Symbol computedSymbol = computedExpressions.get(expression);\n-                    if (computedSymbol == null) {\n-                        // If we haven't seen the expression before in this projection, record it\n-                        computedExpressions.put(expression, entry.getKey());\n-                    }\n-                    else {\n-                        // If we have seen the expression before and if it is deterministic\n-                        // then we can rewrite references to the current symbol in terms of the parallel computedSymbol in the projection\n-                        map(entry.getKey(), computedSymbol);\n-                    }\n-                }\n+            ListMultimap<Symbol, Symbol> newOutputToInputs = rewriteOutputToInputsMap(node.getSymbolMapping(), outputMapper, inputMappers);\n+            List<Symbol> newOutputs = outputMapper.mapAndDistinct(node.getOutputSymbols());\n \n-                Symbol canonical = canonicalize(entry.getKey());\n-                assignments.put(canonical, expression);\n-            }\n-            return assignments.build();\n+            return new PlanAndMappings(\n+                    new UnionNode(\n+                            node.getId(),\n+                            rewrittenSources.stream()\n+                                    .map(PlanAndMappings::getRoot)\n+                                    .collect(toImmutableList()),\n+                            newOutputToInputs,\n+                            newOutputs),\n+                    outputMapper.getMapping());\n         }\n \n-        private Optional<Symbol> canonicalize(Optional<Symbol> symbol)\n+        @Override\n+        public PlanAndMappings visitIntersect(IntersectNode node, UnaliasContext context)\n         {\n-            if (symbol.isPresent()) {\n-                return Optional.of(canonicalize(symbol.get()));\n-            }\n-            return Optional.empty();\n-        }\n+            List<PlanAndMappings> rewrittenSources = node.getSources().stream()\n+                    .map(source -> source.accept(this, context))\n+                    .collect(toImmutableList());\n \n-        private Symbol canonicalize(Symbol symbol)\n-        {\n-            Symbol canonical = symbol;\n-            while (mapping.containsKey(canonical)) {\n-                canonical = mapping.get(canonical);\n-            }\n-            return canonical;\n+            List<SymbolMapper> inputMappers = rewrittenSources.stream()\n+                    .map(source -> new SymbolMapper(source.getSymbolMappings()))\n+                    .collect(toImmutableList());\n+\n+            SymbolMapper outputMapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            ListMultimap<Symbol, Symbol> newOutputToInputs = rewriteOutputToInputsMap(node.getSymbolMapping(), outputMapper, inputMappers);\n+            List<Symbol> newOutputs = outputMapper.mapAndDistinct(node.getOutputSymbols());\n+\n+            return new PlanAndMappings(\n+                    new IntersectNode(\n+                            node.getId(),\n+                            rewrittenSources.stream()\n+                                    .map(PlanAndMappings::getRoot)\n+                                    .collect(toImmutableList()),\n+                            newOutputToInputs,\n+                            newOutputs),\n+                    outputMapper.getMapping());\n         }\n \n-        private List<Expression> canonicalize(List<Expression> values)\n+        @Override\n+        public PlanAndMappings visitExcept(ExceptNode node, UnaliasContext context)\n         {\n-            return values.stream()\n-                    .map(this::canonicalize)\n+            List<PlanAndMappings> rewrittenSources = node.getSources().stream()\n+                    .map(source -> source.accept(this, context))\n                     .collect(toImmutableList());\n-        }\n \n-        private Expression canonicalize(Expression value)\n-        {\n-            return ExpressionTreeRewriter.rewriteWith(new ExpressionRewriter<Void>()\n-            {\n-                @Override\n-                public Expression rewriteSymbolReference(SymbolReference node, Void context, ExpressionTreeRewriter<Void> treeRewriter)\n-                {\n-                    Symbol canonical = canonicalize(Symbol.from(node));\n-                    return canonical.toSymbolReference();\n-                }\n-            }, value);\n-        }\n+            List<SymbolMapper> inputMappers = rewrittenSources.stream()\n+                    .map(source -> new SymbolMapper(source.getSymbolMappings()))\n+                    .collect(toImmutableList());\n \n-        private List<Symbol> canonicalizeAndDistinct(List<Symbol> outputs)\n-        {\n-            Set<Symbol> added = new HashSet<>();\n-            ImmutableList.Builder<Symbol> builder = ImmutableList.builder();\n-            for (Symbol symbol : outputs) {\n-                Symbol canonical = canonicalize(symbol);\n-                if (added.add(canonical)) {\n-                    builder.add(canonical);\n-                }\n-            }\n-            return builder.build();\n+            SymbolMapper outputMapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            ListMultimap<Symbol, Symbol> newOutputToInputs = rewriteOutputToInputsMap(node.getSymbolMapping(), outputMapper, inputMappers);\n+            List<Symbol> newOutputs = outputMapper.mapAndDistinct(node.getOutputSymbols());\n+\n+            return new PlanAndMappings(\n+                    new ExceptNode(\n+                            node.getId(),\n+                            rewrittenSources.stream()\n+                                    .map(PlanAndMappings::getRoot)\n+                                    .collect(toImmutableList()),\n+                            newOutputToInputs,\n+                            newOutputs),\n+                    outputMapper.getMapping());\n         }\n \n-        private Map<String, Symbol> canonicalizeAndDistinct(Map<String, Symbol> dynamicFilters)\n+        private ListMultimap<Symbol, Symbol> rewriteOutputToInputsMap(ListMultimap<Symbol, Symbol> oldMapping, SymbolMapper outputMapper, List<SymbolMapper> inputMappers)\n         {\n-            Set<Symbol> added = new HashSet<>();\n-            ImmutableMap.Builder<String, Symbol> builder = ImmutableMap.builder();\n-            for (Map.Entry<String, Symbol> entry : dynamicFilters.entrySet()) {\n-                Symbol canonical = canonicalize(entry.getValue());\n-                if (added.add(canonical)) {\n-                    builder.put(entry.getKey(), canonical);\n+            ImmutableListMultimap.Builder<Symbol, Symbol> newMappingBuilder = ImmutableListMultimap.builder();\n+            Set<Symbol> addedSymbols = new HashSet<>();\n+            for (Map.Entry<Symbol, Collection<Symbol>> entry : oldMapping.asMap().entrySet()) {\n+                Symbol rewrittenOutput = outputMapper.map(entry.getKey());\n+                if (addedSymbols.add(rewrittenOutput)) {\n+                    List<Symbol> inputs = ImmutableList.copyOf(entry.getValue());\n+                    ImmutableList.Builder<Symbol> rewrittenInputs = ImmutableList.builder();\n+                    for (int i = 0; i < inputs.size(); i++) {\n+                        rewrittenInputs.add(inputMappers.get(i).map(inputs.get(i)));\n+                    }\n+                    newMappingBuilder.putAll(rewrittenOutput, rewrittenInputs.build());\n                 }\n             }\n-            return builder.build();\n+            return newMappingBuilder.build();\n         }\n+    }\n+\n+    private static class UnaliasContext\n+    {\n+        // Correlation mapping is a record of how correlation symbols have been mapped in the subplan which provides them.\n+        // All occurrences of correlation symbols within the correlated subquery must be remapped accordingly.\n+        // In case of nested correlation, correlationMappings has required mappings for correlation symbols from all levels of nesting.\n+        private final Map<Symbol, Symbol> correlationMapping;\n \n-        private WindowNode.Specification canonicalizeAndDistinct(WindowNode.Specification specification)\n+        public UnaliasContext(Map<Symbol, Symbol> correlationMapping)\n         {\n-            return new WindowNode.Specification(\n-                    canonicalizeAndDistinct(specification.getPartitionBy()),\n-                    specification.getOrderingScheme().map(this::canonicalizeAndDistinct));\n+            this.correlationMapping = requireNonNull(correlationMapping, \"correlationMapping is null\");\n         }\n \n-        private OrderingScheme canonicalizeAndDistinct(OrderingScheme orderingScheme)\n+        public static UnaliasContext empty()\n         {\n-            Set<Symbol> added = new HashSet<>();\n-            ImmutableList.Builder<Symbol> symbols = ImmutableList.builder();\n-            ImmutableMap.Builder<Symbol, SortOrder> orderings = ImmutableMap.builder();\n-            for (Symbol symbol : orderingScheme.getOrderBy()) {\n-                Symbol canonical = canonicalize(symbol);\n-                if (added.add(canonical)) {\n-                    symbols.add(canonical);\n-                    orderings.put(canonical, orderingScheme.getOrdering(symbol));\n-                }\n-            }\n-\n-            return new OrderingScheme(symbols.build(), orderings.build());\n+            return new UnaliasContext(ImmutableMap.of());\n         }\n \n-        private Set<Symbol> canonicalize(Set<Symbol> symbols)\n+        public Map<Symbol, Symbol> getCorrelationMapping()\n         {\n-            return symbols.stream()\n-                    .map(this::canonicalize)\n-                    .collect(toImmutableSet());\n+            return correlationMapping;\n         }\n+    }\n \n-        private List<JoinNode.EquiJoinClause> canonicalizeJoinCriteria(List<JoinNode.EquiJoinClause> criteria)\n-        {\n-            ImmutableList.Builder<JoinNode.EquiJoinClause> builder = ImmutableList.builder();\n-            for (JoinNode.EquiJoinClause clause : criteria) {\n-                builder.add(new JoinNode.EquiJoinClause(canonicalize(clause.getLeft()), canonicalize(clause.getRight())));\n-            }\n+    private static class PlanAndMappings\n+    {\n+        private final PlanNode root;\n+        private final Map<Symbol, Symbol> symbolMappings;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1458}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA4OTQ5Mg==", "bodyText": "This isn't used anywhere", "url": "https://github.com/trinodb/trino/pull/4038#discussion_r443089492", "createdAt": "2020-06-20T01:26:31Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/UnaliasSymbolReferences.java", "diffHunk": "@@ -125,695 +121,988 @@ public PlanNode optimize(PlanNode plan, Session session, TypeProvider types, Sym\n         requireNonNull(symbolAllocator, \"symbolAllocator is null\");\n         requireNonNull(idAllocator, \"idAllocator is null\");\n \n-        return SimplePlanRewriter.rewriteWith(new Rewriter(metadata, types), plan);\n+        return plan.accept(new Visitor(metadata, symbolAllocator), UnaliasContext.empty()).getRoot();\n     }\n \n-    private static class Rewriter\n-            extends SimplePlanRewriter<Void>\n+    private static class Visitor\n+            extends PlanVisitor<PlanAndMappings, UnaliasContext>\n     {\n-        private final Map<Symbol, Symbol> mapping = new HashMap<>();\n         private final Metadata metadata;\n-        private final TypeProvider types;\n+        private final SymbolAllocator symbolAllocator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIyMzIxNQ==", "bodyText": "This could be simplified to:\n            Map<Symbol, Expression> deduplicateAssignments = node.getAssignments().entrySet().stream()\n                    .map(assignment -> new SimpleEntry<>(mapper.map(assignment.getKey()), mapper.map(assignment.getValue())))\n                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (previous, current) -> {\n                        checkState(previous.equals(current), \"different expressions projected to the same symbol\");\n                        return previous;\n                    }));", "url": "https://github.com/trinodb/trino/pull/4038#discussion_r447223215", "createdAt": "2020-06-29T20:08:11Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/UnaliasSymbolReferences.java", "diffHunk": "@@ -126,695 +122,988 @@ public PlanNode optimize(PlanNode plan, Session session, TypeProvider types, Sym\n         requireNonNull(symbolAllocator, \"symbolAllocator is null\");\n         requireNonNull(idAllocator, \"idAllocator is null\");\n \n-        return SimplePlanRewriter.rewriteWith(new Rewriter(metadata, types), plan);\n+        return plan.accept(new Visitor(metadata, symbolAllocator), UnaliasContext.empty()).getRoot();\n     }\n \n-    private static class Rewriter\n-            extends SimplePlanRewriter<Void>\n+    private static class Visitor\n+            extends PlanVisitor<PlanAndMappings, UnaliasContext>\n     {\n-        private final Map<Symbol, Symbol> mapping = new HashMap<>();\n         private final Metadata metadata;\n-        private final TypeProvider types;\n+        private final SymbolAllocator symbolAllocator;\n \n-        private Rewriter(Metadata metadata, TypeProvider types)\n+        public Visitor(Metadata metadata, SymbolAllocator symbolAllocator)\n         {\n-            this.metadata = metadata;\n-            this.types = types;\n+            this.metadata = requireNonNull(metadata, \"metadata is null\");\n+            this.symbolAllocator = requireNonNull(symbolAllocator, \"symbolAllocator is null\");\n         }\n \n         @Override\n-        public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> context)\n+        protected PlanAndMappings visitPlan(PlanNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            //TODO: use mapper in other methods\n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source);\n+            throw new UnsupportedOperationException(\"Unsupported plan node \" + node.getClass().getSimpleName());\n         }\n \n         @Override\n-        public PlanNode visitGroupId(GroupIdNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitAggregation(AggregationNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            Map<Symbol, Symbol> newGroupingMappings = new HashMap<>();\n-            ImmutableList.Builder<List<Symbol>> newGroupingSets = ImmutableList.builder();\n+            AggregationNode rewrittenAggregation = mapper.map(node, rewrittenSource.getRoot());\n \n-            for (List<Symbol> groupingSet : node.getGroupingSets()) {\n-                ImmutableList.Builder<Symbol> newGroupingSet = ImmutableList.builder();\n-                for (Symbol output : groupingSet) {\n-                    newGroupingMappings.putIfAbsent(canonicalize(output), canonicalize(node.getGroupingColumns().get(output)));\n-                    newGroupingSet.add(canonicalize(output));\n-                }\n-                newGroupingSets.add(newGroupingSet.build());\n-            }\n+            return new PlanAndMappings(rewrittenAggregation, mapper.getMapping());\n+        }\n+\n+        @Override\n+        public PlanAndMappings visitGroupId(GroupIdNode node, UnaliasContext context)\n+        {\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            return new GroupIdNode(node.getId(), source, newGroupingSets.build(), newGroupingMappings, canonicalizeAndDistinct(node.getAggregationArguments()), canonicalize(node.getGroupIdSymbol()));\n+            GroupIdNode rewrittenGroupId = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenGroupId, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitExplainAnalyze(ExplainAnalyzeNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitExplainAnalyze(ExplainAnalyzeNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            return new ExplainAnalyzeNode(node.getId(), source, canonicalize(node.getOutputSymbol()), node.isVerbose());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Symbol newOutputSymbol = mapper.map(node.getOutputSymbol());\n+\n+            return new PlanAndMappings(\n+                    new ExplainAnalyzeNode(node.getId(), rewrittenSource.getRoot(), newOutputSymbol, node.isVerbose()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitMarkDistinct(MarkDistinctNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitMarkDistinct(MarkDistinctNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            List<Symbol> symbols = canonicalizeAndDistinct(node.getDistinctSymbols());\n-            return new MarkDistinctNode(node.getId(), source, canonicalize(node.getMarkerSymbol()), symbols, canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Symbol newMarkerSymbol = mapper.map(node.getMarkerSymbol());\n+            List<Symbol> newDistinctSymbols = mapper.mapAndDistinct(node.getDistinctSymbols());\n+            Optional<Symbol> newHashSymbol = node.getHashSymbol().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new MarkDistinctNode(\n+                            node.getId(),\n+                            rewrittenSource.getRoot(),\n+                            newMarkerSymbol,\n+                            newDistinctSymbols,\n+                            newHashSymbol),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitUnnest(UnnestNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitUnnest(UnnestNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            ImmutableList.Builder<UnnestNode.Mapping> mappings = ImmutableList.builder();\n+            List<Symbol> newReplicateSymbols = mapper.mapAndDistinct(node.getReplicateSymbols());\n \n-            for (UnnestNode.Mapping mapping : node.getMappings()) {\n-                mappings.add(new UnnestNode.Mapping(canonicalize(mapping.getInput()), mapping.getOutputs()));\n+            ImmutableList.Builder<UnnestNode.Mapping> newMappings = ImmutableList.builder();\n+            for (UnnestNode.Mapping unnestMapping : node.getMappings()) {\n+                newMappings.add(new UnnestNode.Mapping(mapper.map(unnestMapping.getInput()), mapper.map(unnestMapping.getOutputs())));\n             }\n \n-            return new UnnestNode(\n-                    node.getId(),\n-                    source,\n-                    canonicalizeAndDistinct(node.getReplicateSymbols()),\n-                    mappings.build(),\n-                    node.getOrdinalitySymbol(),\n-                    node.getJoinType(),\n-                    node.getFilter().map(this::canonicalize));\n+            Optional<Symbol> newOrdinalitySymbol = node.getOrdinalitySymbol().map(mapper::map);\n+            Optional<Expression> newFilter = node.getFilter().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new UnnestNode(\n+                            node.getId(),\n+                            rewrittenSource.getRoot(),\n+                            newReplicateSymbols,\n+                            newMappings.build(),\n+                            newOrdinalitySymbol,\n+                            node.getJoinType(),\n+                            newFilter),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitWindow(WindowNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitWindow(WindowNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-\n-            ImmutableMap.Builder<Symbol, WindowNode.Function> functions = ImmutableMap.builder();\n-            node.getWindowFunctions().forEach((symbol, function) -> {\n-                ResolvedFunction resolvedFunction = function.getResolvedFunction();\n-                List<Expression> arguments = canonicalize(function.getArguments());\n-                WindowNode.Frame canonicalFrame = canonicalize(function.getFrame());\n-\n-                functions.put(canonicalize(symbol), new WindowNode.Function(resolvedFunction, arguments, canonicalFrame, function.isIgnoreNulls()));\n-            });\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            return new WindowNode(\n-                    node.getId(),\n-                    source,\n-                    canonicalizeAndDistinct(node.getSpecification()),\n-                    functions.build(),\n-                    canonicalize(node.getHashSymbol()),\n-                    canonicalize(node.getPrePartitionedInputs()),\n-                    node.getPreSortedOrderPrefix());\n-        }\n+            WindowNode rewrittenWindow = mapper.map(node, rewrittenSource.getRoot());\n \n-        private WindowNode.Frame canonicalize(WindowNode.Frame frame)\n-        {\n-            return new WindowNode.Frame(\n-                    frame.getType(),\n-                    frame.getStartType(),\n-                    canonicalize(frame.getStartValue()),\n-                    frame.getEndType(),\n-                    canonicalize(frame.getEndValue()),\n-                    frame.getOriginalStartValue(),\n-                    frame.getOriginalEndValue());\n+            return new PlanAndMappings(rewrittenWindow, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTableScan(TableScanNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableScan(TableScanNode node, UnaliasContext context)\n         {\n-            return node;\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            List<Symbol> newOutputs = mapper.map(node.getOutputSymbols());\n+\n+            Map<Symbol, ColumnHandle> newAssignments = new HashMap<>();\n+            node.getAssignments().forEach((symbol, handle) -> {\n+                newAssignments.put(mapper.map(symbol), handle);\n+            });\n+\n+            return new PlanAndMappings(\n+                    new TableScanNode(node.getId(), node.getTable(), newOutputs, newAssignments, node.getEnforcedConstraint()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitExchange(ExchangeNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitExchange(ExchangeNode node, UnaliasContext context)\n         {\n-            List<PlanNode> sources = node.getSources().stream()\n-                    .map(context::rewrite)\n-                    .collect(toImmutableList());\n-\n-            mapExchangeNodeSymbols(node);\n-\n-            List<List<Symbol>> inputs = new ArrayList<>();\n-            for (int i = 0; i < node.getInputs().size(); i++) {\n-                inputs.add(new ArrayList<>());\n+            ImmutableList.Builder<PlanNode> rewrittenChildren = ImmutableList.builder();\n+            ImmutableList.Builder<List<Symbol>> rewrittenInputsBuilder = ImmutableList.builder();\n+\n+            // rewrite child and map corresponding input list accordingly to the child's mapping\n+            for (int i = 0; i < node.getSources().size(); i++) {\n+                PlanAndMappings rewrittenChild = node.getSources().get(i).accept(this, context);\n+                rewrittenChildren.add(rewrittenChild.getRoot());\n+                SymbolMapper mapper = new SymbolMapper(rewrittenChild.getSymbolMappings());\n+                rewrittenInputsBuilder.add(mapper.map(node.getInputs().get(i)));\n             }\n-            Set<Symbol> addedOutputs = new HashSet<>();\n-            ImmutableList.Builder<Symbol> outputs = ImmutableList.builder();\n-            for (int symbolIndex = 0; symbolIndex < node.getOutputSymbols().size(); symbolIndex++) {\n-                Symbol canonicalOutput = canonicalize(node.getOutputSymbols().get(symbolIndex));\n-                if (addedOutputs.add(canonicalOutput)) {\n-                    outputs.add(canonicalOutput);\n-                    for (int i = 0; i < node.getInputs().size(); i++) {\n-                        List<Symbol> input = node.getInputs().get(i);\n-                        inputs.get(i).add(canonicalize(input.get(symbolIndex)));\n-                    }\n+            List<List<Symbol>> rewrittenInputs = rewrittenInputsBuilder.build();\n+\n+            // canonicalize ExchangeNode outputs\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+            List<Symbol> rewrittenOutputs = mapper.map(node.getOutputSymbols());\n+\n+            // sanity check: assert that duplicate outputs result from same inputs\n+            Map<Symbol, List<Symbol>> outputsToInputs = new HashMap<>();\n+            for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                ImmutableList.Builder<Symbol> inputsBuilder = ImmutableList.builder();\n+                for (List<Symbol> inputs : rewrittenInputs) {\n+                    inputsBuilder.add(inputs.get(i));\n                 }\n+                List<Symbol> inputs = inputsBuilder.build();\n+                List<Symbol> previous = outputsToInputs.put(rewrittenOutputs.get(i), inputs);\n+                checkState(previous == null || inputs.equals(previous), \"different inputs mapped to the same output symbol\");\n             }\n \n-            PartitioningScheme partitioningScheme = new PartitioningScheme(\n-                    node.getPartitioningScheme().getPartitioning().translate(this::canonicalize),\n-                    outputs.build(),\n-                    canonicalize(node.getPartitioningScheme().getHashColumn()),\n-                    node.getPartitioningScheme().isReplicateNullsAndAny(),\n-                    node.getPartitioningScheme().getBucketToPartition());\n-\n-            Optional<OrderingScheme> orderingScheme = node.getOrderingScheme().map(this::canonicalizeAndDistinct);\n+            // derive new mappings for ExchangeNode output symbols\n+            Map<Symbol, Symbol> newMapping = new HashMap<>();\n \n-            return new ExchangeNode(node.getId(), node.getType(), node.getScope(), partitioningScheme, sources, inputs, orderingScheme);\n-        }\n-\n-        private void mapExchangeNodeSymbols(ExchangeNode node)\n-        {\n-            if (node.getInputs().size() == 1) {\n-                mapExchangeNodeOutputToInputSymbols(node);\n-                return;\n+            // 1. for a single ExchangeNode source, map outputs to inputs\n+            if (rewrittenInputs.size() == 1) {\n+                for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                    Symbol output = rewrittenOutputs.get(i);\n+                    Symbol input = rewrittenInputs.get(0).get(i);\n+                    if (!output.equals(input)) {\n+                        newMapping.put(output, input);\n+                    }\n+                }\n             }\n \n-            // Mapping from list [node.getInput(0).get(symbolIndex), node.getInput(1).get(symbolIndex), ...] to node.getOutputSymbols(symbolIndex).\n-            // All symbols are canonical.\n+            // 2. for multiple ExchangeNode sources, if different output symbols result from the same lists of canonical input symbols, map all those outputs to the same symbol\n             Map<List<Symbol>, Symbol> inputsToOutputs = new HashMap<>();\n-            // Map each same list of input symbols [I1, I2, ..., In] to the same output symbol O\n-            for (int symbolIndex = 0; symbolIndex < node.getOutputSymbols().size(); symbolIndex++) {\n-                Symbol canonicalOutput = canonicalize(node.getOutputSymbols().get(symbolIndex));\n-                List<Symbol> canonicalInputs = canonicalizeExchangeNodeInputs(node, symbolIndex);\n-                Symbol output = inputsToOutputs.get(canonicalInputs);\n-\n-                if (output == null || canonicalOutput.equals(output)) {\n-                    inputsToOutputs.put(canonicalInputs, canonicalOutput);\n+            for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                ImmutableList.Builder<Symbol> inputsBuilder = ImmutableList.builder();\n+                for (List<Symbol> inputs : rewrittenInputs) {\n+                    inputsBuilder.add(inputs.get(i));\n+                }\n+                List<Symbol> inputs = inputsBuilder.build();\n+                Symbol previous = inputsToOutputs.get(inputs);\n+                if (previous == null || rewrittenOutputs.get(i).equals(previous)) {\n+                    inputsToOutputs.put(inputs, rewrittenOutputs.get(i));\n                 }\n                 else {\n-                    map(canonicalOutput, output);\n+                    newMapping.put(rewrittenOutputs.get(i), previous);\n                 }\n             }\n-        }\n \n-        private void mapExchangeNodeOutputToInputSymbols(ExchangeNode node)\n-        {\n-            checkState(node.getInputs().size() == 1);\n+            Map<Symbol, Symbol> outputMapping = new HashMap<>();\n+            outputMapping.putAll(mapper.getMapping());\n+            outputMapping.putAll(newMapping);\n \n-            for (int symbolIndex = 0; symbolIndex < node.getOutputSymbols().size(); symbolIndex++) {\n-                Symbol canonicalOutput = canonicalize(node.getOutputSymbols().get(symbolIndex));\n-                Symbol canonicalInput = canonicalize(node.getInputs().get(0).get(symbolIndex));\n+            mapper = new SymbolMapper(outputMapping);\n \n-                if (!canonicalOutput.equals(canonicalInput)) {\n-                    map(canonicalOutput, canonicalInput);\n+            // deduplicate outputs and prune input symbols lists accordingly\n+            List<List<Symbol>> newInputs = new ArrayList<>();\n+            for (int i = 0; i < node.getInputs().size(); i++) {\n+                newInputs.add(new ArrayList<>());\n+            }\n+            ImmutableList.Builder<Symbol> newOutputs = ImmutableList.builder();\n+            Set<Symbol> addedOutputs = new HashSet<>();\n+            for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                Symbol output = mapper.map(rewrittenOutputs.get(i));\n+                if (addedOutputs.add(output)) {\n+                    newOutputs.add(output);\n+                    for (int j = 0; j < rewrittenInputs.size(); j++) {\n+                        newInputs.get(j).add(rewrittenInputs.get(j).get(i));\n+                    }\n                 }\n             }\n-        }\n \n-        private List<Symbol> canonicalizeExchangeNodeInputs(ExchangeNode node, int symbolIndex)\n-        {\n-            return node.getInputs().stream()\n-                    .map(input -> canonicalize(input.get(symbolIndex)))\n-                    .collect(toImmutableList());\n+            // rewrite PartitioningScheme\n+            PartitioningScheme newPartitioningScheme = mapper.map(node.getPartitioningScheme(), newOutputs.build());\n+\n+            // rewrite OrderingScheme\n+            Optional<OrderingScheme> newOrderingScheme = node.getOrderingScheme().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new ExchangeNode(\n+                            node.getId(),\n+                            node.getType(),\n+                            node.getScope(),\n+                            newPartitioningScheme,\n+                            rewrittenChildren.build(),\n+                            newInputs,\n+                            newOrderingScheme),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitRemoteSource(RemoteSourceNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitRemoteSource(RemoteSourceNode node, UnaliasContext context)\n         {\n-            return new RemoteSourceNode(\n-                    node.getId(),\n-                    node.getSourceFragmentIds(),\n-                    canonicalizeAndDistinct(node.getOutputSymbols()),\n-                    node.getOrderingScheme().map(this::canonicalizeAndDistinct),\n-                    node.getExchangeType());\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            List<Symbol> newOutputs = mapper.mapAndDistinct(node.getOutputSymbols());\n+            Optional<OrderingScheme> newOrderingScheme = node.getOrderingScheme().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new RemoteSourceNode(\n+                            node.getId(),\n+                            node.getSourceFragmentIds(),\n+                            newOutputs,\n+                            newOrderingScheme,\n+                            node.getExchangeType()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitOffset(OffsetNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitOffset(OffsetNode node, UnaliasContext context)\n         {\n-            return context.defaultRewrite(node);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+\n+            return new PlanAndMappings(\n+                    node.replaceChildren(ImmutableList.of(rewrittenSource.getRoot())),\n+                    rewrittenSource.getSymbolMappings());\n         }\n \n         @Override\n-        public PlanNode visitLimit(LimitNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitLimit(LimitNode node, UnaliasContext context)\n         {\n-            if (node.isWithTies()) {\n-                PlanNode source = context.rewrite(node.getSource());\n-                return new LimitNode(node.getId(), source, node.getCount(), node.getTiesResolvingScheme().map(this::canonicalizeAndDistinct), node.isPartial());\n-            }\n-            return context.defaultRewrite(node);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            LimitNode rewrittenLimit = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenLimit, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitDistinctLimit(DistinctLimitNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitDistinctLimit(DistinctLimitNode node, UnaliasContext context)\n         {\n-            return new DistinctLimitNode(node.getId(), context.rewrite(node.getSource()), node.getLimit(), node.isPartial(), canonicalizeAndDistinct(node.getDistinctSymbols()), canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            DistinctLimitNode rewrittenDistinctLimit = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenDistinctLimit, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitSample(SampleNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitSample(SampleNode node, UnaliasContext context)\n         {\n-            return new SampleNode(node.getId(), context.rewrite(node.getSource()), node.getSampleRatio(), node.getSampleType());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+\n+            return new PlanAndMappings(\n+                    node.replaceChildren(ImmutableList.of(rewrittenSource.getRoot())),\n+                    rewrittenSource.getSymbolMappings());\n         }\n \n         @Override\n-        public PlanNode visitValues(ValuesNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitValues(ValuesNode node, UnaliasContext context)\n         {\n-            List<List<Expression>> canonicalizedRows = node.getRows().stream()\n-                    .map(this::canonicalize)\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            List<List<Expression>> newRows = node.getRows().stream()\n+                    .map(row -> row.stream()\n+                            .map(mapper::map)\n+                            .collect(toImmutableList()))\n                     .collect(toImmutableList());\n-            List<Symbol> canonicalizedOutputSymbols = canonicalizeAndDistinct(node.getOutputSymbols());\n-            checkState(node.getOutputSymbols().size() == canonicalizedOutputSymbols.size(), \"Values output symbols were pruned\");\n-            return new ValuesNode(\n-                    node.getId(),\n-                    canonicalizedOutputSymbols,\n-                    canonicalizedRows);\n+\n+            List<Symbol> newOutputSymbols = mapper.mapAndDistinct(node.getOutputSymbols());\n+            checkState(node.getOutputSymbols().size() == newOutputSymbols.size(), \"Values output symbols were pruned\");\n+\n+            return new PlanAndMappings(\n+                    new ValuesNode(node.getId(), newOutputSymbols, newRows),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTableDelete(TableDeleteNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableDelete(TableDeleteNode node, UnaliasContext context)\n         {\n-            return node;\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            Symbol newOutput = mapper.map(node.getOutput());\n+\n+            return new PlanAndMappings(\n+                    new TableDeleteNode(node.getId(), node.getTarget(), newOutput),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitDelete(DeleteNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitDelete(DeleteNode node, UnaliasContext context)\n         {\n-            return new DeleteNode(node.getId(), context.rewrite(node.getSource()), node.getTarget(), canonicalize(node.getRowId()), node.getOutputSymbols());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Symbol newRowId = mapper.map(node.getRowId());\n+            List<Symbol> newOutputs = mapper.map(node.getOutputSymbols());\n+\n+            return new PlanAndMappings(\n+                    new DeleteNode(\n+                            node.getId(),\n+                            rewrittenSource.getRoot(),\n+                            node.getTarget(),\n+                            newRowId,\n+                            newOutputs),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitStatisticsWriterNode(StatisticsWriterNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitStatisticsWriterNode(StatisticsWriterNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            StatisticsWriterNode rewrittenStatisticsWriter = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenStatisticsWriter, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTableFinish(TableFinishNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableWriter(TableWriterNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            TableWriterNode rewrittenTableWriter = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTableWriter, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitRowNumber(RowNumberNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableFinish(TableFinishNode node, UnaliasContext context)\n         {\n-            return new RowNumberNode(\n-                    node.getId(),\n-                    context.rewrite(node.getSource()),\n-                    canonicalizeAndDistinct(node.getPartitionBy()),\n-                    node.isOrderSensitive(),\n-                    canonicalize(node.getRowNumberSymbol()),\n-                    node.getMaxRowCountPerPartition(),\n-                    canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            TableFinishNode rewrittenTableFinish = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTableFinish, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTopNRowNumber(TopNRowNumberNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitRowNumber(RowNumberNode node, UnaliasContext context)\n         {\n-            return new TopNRowNumberNode(\n-                    node.getId(),\n-                    context.rewrite(node.getSource()),\n-                    canonicalizeAndDistinct(node.getSpecification()),\n-                    canonicalize(node.getRowNumberSymbol()),\n-                    node.getMaxRowCountPerPartition(),\n-                    node.isPartial(),\n-                    canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            RowNumberNode rewrittenRowNumber = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenRowNumber, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitFilter(FilterNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTopNRowNumber(TopNRowNumberNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            return new FilterNode(node.getId(), source, canonicalize(node.getPredicate()));\n+            TopNRowNumberNode rewrittenTopNRowNumber = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTopNRowNumber, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitProject(ProjectNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTopN(TopNNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            return new ProjectNode(node.getId(), source, canonicalize(node.getAssignments()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            TopNNode rewrittenTopN = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTopN, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitOutput(OutputNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitSort(SortNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            List<Symbol> canonical = Lists.transform(node.getOutputSymbols(), this::canonicalize);\n-            return new OutputNode(node.getId(), source, node.getColumnNames(), canonical);\n+            OrderingScheme newOrderingScheme = mapper.map(node.getOrderingScheme());\n+\n+            return new PlanAndMappings(\n+                    new SortNode(node.getId(), rewrittenSource.getRoot(), newOrderingScheme, node.isPartial()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitEnforceSingleRow(EnforceSingleRowNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitFilter(FilterNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Expression newPredicate = mapper.map(node.getPredicate());\n \n-            return new EnforceSingleRowNode(node.getId(), source);\n+            return new PlanAndMappings(\n+                    new FilterNode(node.getId(), rewrittenSource.getRoot(), newPredicate),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitAssignUniqueId(AssignUniqueId node, RewriteContext<Void> context)\n+        public PlanAndMappings visitProject(ProjectNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            // canonicalize ProjectNode assignments\n+            ImmutableList.Builder<Map.Entry<Symbol, Expression>> builder = ImmutableList.builder();\n+            for (Map.Entry<Symbol, Expression> assignment : node.getAssignments().entrySet()) {\n+                builder.add(new SimpleEntry<>(mapper.map(assignment.getKey()), mapper.map(assignment.getValue())));\n+            }\n+            List<Map.Entry<Symbol, Expression>> rewrittenAssignments = builder.build();\n \n-            return new AssignUniqueId(node.getId(), source, node.getIdColumn());\n+            // deduplicate assignments\n+            Map<Symbol, Expression> deduplicateAssignments = new HashMap<>();\n+            for (Map.Entry<Symbol, Expression> assignment : rewrittenAssignments) {\n+                Expression previous = deduplicateAssignments.put(assignment.getKey(), assignment.getValue());\n+                checkState(previous == null || assignment.getValue().equals(previous), \"different expressions projected to the same symbol\");\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 733}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIyNzI2OA==", "bodyText": "assignment.getKey().equals(previous)\n\nThis should never be false based on the checkState above, right?", "url": "https://github.com/trinodb/trino/pull/4038#discussion_r447227268", "createdAt": "2020-06-29T20:15:57Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/UnaliasSymbolReferences.java", "diffHunk": "@@ -126,695 +122,988 @@ public PlanNode optimize(PlanNode plan, Session session, TypeProvider types, Sym\n         requireNonNull(symbolAllocator, \"symbolAllocator is null\");\n         requireNonNull(idAllocator, \"idAllocator is null\");\n \n-        return SimplePlanRewriter.rewriteWith(new Rewriter(metadata, types), plan);\n+        return plan.accept(new Visitor(metadata, symbolAllocator), UnaliasContext.empty()).getRoot();\n     }\n \n-    private static class Rewriter\n-            extends SimplePlanRewriter<Void>\n+    private static class Visitor\n+            extends PlanVisitor<PlanAndMappings, UnaliasContext>\n     {\n-        private final Map<Symbol, Symbol> mapping = new HashMap<>();\n         private final Metadata metadata;\n-        private final TypeProvider types;\n+        private final SymbolAllocator symbolAllocator;\n \n-        private Rewriter(Metadata metadata, TypeProvider types)\n+        public Visitor(Metadata metadata, SymbolAllocator symbolAllocator)\n         {\n-            this.metadata = metadata;\n-            this.types = types;\n+            this.metadata = requireNonNull(metadata, \"metadata is null\");\n+            this.symbolAllocator = requireNonNull(symbolAllocator, \"symbolAllocator is null\");\n         }\n \n         @Override\n-        public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> context)\n+        protected PlanAndMappings visitPlan(PlanNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            //TODO: use mapper in other methods\n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source);\n+            throw new UnsupportedOperationException(\"Unsupported plan node \" + node.getClass().getSimpleName());\n         }\n \n         @Override\n-        public PlanNode visitGroupId(GroupIdNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitAggregation(AggregationNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            Map<Symbol, Symbol> newGroupingMappings = new HashMap<>();\n-            ImmutableList.Builder<List<Symbol>> newGroupingSets = ImmutableList.builder();\n+            AggregationNode rewrittenAggregation = mapper.map(node, rewrittenSource.getRoot());\n \n-            for (List<Symbol> groupingSet : node.getGroupingSets()) {\n-                ImmutableList.Builder<Symbol> newGroupingSet = ImmutableList.builder();\n-                for (Symbol output : groupingSet) {\n-                    newGroupingMappings.putIfAbsent(canonicalize(output), canonicalize(node.getGroupingColumns().get(output)));\n-                    newGroupingSet.add(canonicalize(output));\n-                }\n-                newGroupingSets.add(newGroupingSet.build());\n-            }\n+            return new PlanAndMappings(rewrittenAggregation, mapper.getMapping());\n+        }\n+\n+        @Override\n+        public PlanAndMappings visitGroupId(GroupIdNode node, UnaliasContext context)\n+        {\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            return new GroupIdNode(node.getId(), source, newGroupingSets.build(), newGroupingMappings, canonicalizeAndDistinct(node.getAggregationArguments()), canonicalize(node.getGroupIdSymbol()));\n+            GroupIdNode rewrittenGroupId = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenGroupId, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitExplainAnalyze(ExplainAnalyzeNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitExplainAnalyze(ExplainAnalyzeNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            return new ExplainAnalyzeNode(node.getId(), source, canonicalize(node.getOutputSymbol()), node.isVerbose());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Symbol newOutputSymbol = mapper.map(node.getOutputSymbol());\n+\n+            return new PlanAndMappings(\n+                    new ExplainAnalyzeNode(node.getId(), rewrittenSource.getRoot(), newOutputSymbol, node.isVerbose()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitMarkDistinct(MarkDistinctNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitMarkDistinct(MarkDistinctNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            List<Symbol> symbols = canonicalizeAndDistinct(node.getDistinctSymbols());\n-            return new MarkDistinctNode(node.getId(), source, canonicalize(node.getMarkerSymbol()), symbols, canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Symbol newMarkerSymbol = mapper.map(node.getMarkerSymbol());\n+            List<Symbol> newDistinctSymbols = mapper.mapAndDistinct(node.getDistinctSymbols());\n+            Optional<Symbol> newHashSymbol = node.getHashSymbol().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new MarkDistinctNode(\n+                            node.getId(),\n+                            rewrittenSource.getRoot(),\n+                            newMarkerSymbol,\n+                            newDistinctSymbols,\n+                            newHashSymbol),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitUnnest(UnnestNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitUnnest(UnnestNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            ImmutableList.Builder<UnnestNode.Mapping> mappings = ImmutableList.builder();\n+            List<Symbol> newReplicateSymbols = mapper.mapAndDistinct(node.getReplicateSymbols());\n \n-            for (UnnestNode.Mapping mapping : node.getMappings()) {\n-                mappings.add(new UnnestNode.Mapping(canonicalize(mapping.getInput()), mapping.getOutputs()));\n+            ImmutableList.Builder<UnnestNode.Mapping> newMappings = ImmutableList.builder();\n+            for (UnnestNode.Mapping unnestMapping : node.getMappings()) {\n+                newMappings.add(new UnnestNode.Mapping(mapper.map(unnestMapping.getInput()), mapper.map(unnestMapping.getOutputs())));\n             }\n \n-            return new UnnestNode(\n-                    node.getId(),\n-                    source,\n-                    canonicalizeAndDistinct(node.getReplicateSymbols()),\n-                    mappings.build(),\n-                    node.getOrdinalitySymbol(),\n-                    node.getJoinType(),\n-                    node.getFilter().map(this::canonicalize));\n+            Optional<Symbol> newOrdinalitySymbol = node.getOrdinalitySymbol().map(mapper::map);\n+            Optional<Expression> newFilter = node.getFilter().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new UnnestNode(\n+                            node.getId(),\n+                            rewrittenSource.getRoot(),\n+                            newReplicateSymbols,\n+                            newMappings.build(),\n+                            newOrdinalitySymbol,\n+                            node.getJoinType(),\n+                            newFilter),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitWindow(WindowNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitWindow(WindowNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-\n-            ImmutableMap.Builder<Symbol, WindowNode.Function> functions = ImmutableMap.builder();\n-            node.getWindowFunctions().forEach((symbol, function) -> {\n-                ResolvedFunction resolvedFunction = function.getResolvedFunction();\n-                List<Expression> arguments = canonicalize(function.getArguments());\n-                WindowNode.Frame canonicalFrame = canonicalize(function.getFrame());\n-\n-                functions.put(canonicalize(symbol), new WindowNode.Function(resolvedFunction, arguments, canonicalFrame, function.isIgnoreNulls()));\n-            });\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            return new WindowNode(\n-                    node.getId(),\n-                    source,\n-                    canonicalizeAndDistinct(node.getSpecification()),\n-                    functions.build(),\n-                    canonicalize(node.getHashSymbol()),\n-                    canonicalize(node.getPrePartitionedInputs()),\n-                    node.getPreSortedOrderPrefix());\n-        }\n+            WindowNode rewrittenWindow = mapper.map(node, rewrittenSource.getRoot());\n \n-        private WindowNode.Frame canonicalize(WindowNode.Frame frame)\n-        {\n-            return new WindowNode.Frame(\n-                    frame.getType(),\n-                    frame.getStartType(),\n-                    canonicalize(frame.getStartValue()),\n-                    frame.getEndType(),\n-                    canonicalize(frame.getEndValue()),\n-                    frame.getOriginalStartValue(),\n-                    frame.getOriginalEndValue());\n+            return new PlanAndMappings(rewrittenWindow, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTableScan(TableScanNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableScan(TableScanNode node, UnaliasContext context)\n         {\n-            return node;\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            List<Symbol> newOutputs = mapper.map(node.getOutputSymbols());\n+\n+            Map<Symbol, ColumnHandle> newAssignments = new HashMap<>();\n+            node.getAssignments().forEach((symbol, handle) -> {\n+                newAssignments.put(mapper.map(symbol), handle);\n+            });\n+\n+            return new PlanAndMappings(\n+                    new TableScanNode(node.getId(), node.getTable(), newOutputs, newAssignments, node.getEnforcedConstraint()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitExchange(ExchangeNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitExchange(ExchangeNode node, UnaliasContext context)\n         {\n-            List<PlanNode> sources = node.getSources().stream()\n-                    .map(context::rewrite)\n-                    .collect(toImmutableList());\n-\n-            mapExchangeNodeSymbols(node);\n-\n-            List<List<Symbol>> inputs = new ArrayList<>();\n-            for (int i = 0; i < node.getInputs().size(); i++) {\n-                inputs.add(new ArrayList<>());\n+            ImmutableList.Builder<PlanNode> rewrittenChildren = ImmutableList.builder();\n+            ImmutableList.Builder<List<Symbol>> rewrittenInputsBuilder = ImmutableList.builder();\n+\n+            // rewrite child and map corresponding input list accordingly to the child's mapping\n+            for (int i = 0; i < node.getSources().size(); i++) {\n+                PlanAndMappings rewrittenChild = node.getSources().get(i).accept(this, context);\n+                rewrittenChildren.add(rewrittenChild.getRoot());\n+                SymbolMapper mapper = new SymbolMapper(rewrittenChild.getSymbolMappings());\n+                rewrittenInputsBuilder.add(mapper.map(node.getInputs().get(i)));\n             }\n-            Set<Symbol> addedOutputs = new HashSet<>();\n-            ImmutableList.Builder<Symbol> outputs = ImmutableList.builder();\n-            for (int symbolIndex = 0; symbolIndex < node.getOutputSymbols().size(); symbolIndex++) {\n-                Symbol canonicalOutput = canonicalize(node.getOutputSymbols().get(symbolIndex));\n-                if (addedOutputs.add(canonicalOutput)) {\n-                    outputs.add(canonicalOutput);\n-                    for (int i = 0; i < node.getInputs().size(); i++) {\n-                        List<Symbol> input = node.getInputs().get(i);\n-                        inputs.get(i).add(canonicalize(input.get(symbolIndex)));\n-                    }\n+            List<List<Symbol>> rewrittenInputs = rewrittenInputsBuilder.build();\n+\n+            // canonicalize ExchangeNode outputs\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+            List<Symbol> rewrittenOutputs = mapper.map(node.getOutputSymbols());\n+\n+            // sanity check: assert that duplicate outputs result from same inputs\n+            Map<Symbol, List<Symbol>> outputsToInputs = new HashMap<>();\n+            for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                ImmutableList.Builder<Symbol> inputsBuilder = ImmutableList.builder();\n+                for (List<Symbol> inputs : rewrittenInputs) {\n+                    inputsBuilder.add(inputs.get(i));\n                 }\n+                List<Symbol> inputs = inputsBuilder.build();\n+                List<Symbol> previous = outputsToInputs.put(rewrittenOutputs.get(i), inputs);\n+                checkState(previous == null || inputs.equals(previous), \"different inputs mapped to the same output symbol\");\n             }\n \n-            PartitioningScheme partitioningScheme = new PartitioningScheme(\n-                    node.getPartitioningScheme().getPartitioning().translate(this::canonicalize),\n-                    outputs.build(),\n-                    canonicalize(node.getPartitioningScheme().getHashColumn()),\n-                    node.getPartitioningScheme().isReplicateNullsAndAny(),\n-                    node.getPartitioningScheme().getBucketToPartition());\n-\n-            Optional<OrderingScheme> orderingScheme = node.getOrderingScheme().map(this::canonicalizeAndDistinct);\n+            // derive new mappings for ExchangeNode output symbols\n+            Map<Symbol, Symbol> newMapping = new HashMap<>();\n \n-            return new ExchangeNode(node.getId(), node.getType(), node.getScope(), partitioningScheme, sources, inputs, orderingScheme);\n-        }\n-\n-        private void mapExchangeNodeSymbols(ExchangeNode node)\n-        {\n-            if (node.getInputs().size() == 1) {\n-                mapExchangeNodeOutputToInputSymbols(node);\n-                return;\n+            // 1. for a single ExchangeNode source, map outputs to inputs\n+            if (rewrittenInputs.size() == 1) {\n+                for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                    Symbol output = rewrittenOutputs.get(i);\n+                    Symbol input = rewrittenInputs.get(0).get(i);\n+                    if (!output.equals(input)) {\n+                        newMapping.put(output, input);\n+                    }\n+                }\n             }\n \n-            // Mapping from list [node.getInput(0).get(symbolIndex), node.getInput(1).get(symbolIndex), ...] to node.getOutputSymbols(symbolIndex).\n-            // All symbols are canonical.\n+            // 2. for multiple ExchangeNode sources, if different output symbols result from the same lists of canonical input symbols, map all those outputs to the same symbol\n             Map<List<Symbol>, Symbol> inputsToOutputs = new HashMap<>();\n-            // Map each same list of input symbols [I1, I2, ..., In] to the same output symbol O\n-            for (int symbolIndex = 0; symbolIndex < node.getOutputSymbols().size(); symbolIndex++) {\n-                Symbol canonicalOutput = canonicalize(node.getOutputSymbols().get(symbolIndex));\n-                List<Symbol> canonicalInputs = canonicalizeExchangeNodeInputs(node, symbolIndex);\n-                Symbol output = inputsToOutputs.get(canonicalInputs);\n-\n-                if (output == null || canonicalOutput.equals(output)) {\n-                    inputsToOutputs.put(canonicalInputs, canonicalOutput);\n+            for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                ImmutableList.Builder<Symbol> inputsBuilder = ImmutableList.builder();\n+                for (List<Symbol> inputs : rewrittenInputs) {\n+                    inputsBuilder.add(inputs.get(i));\n+                }\n+                List<Symbol> inputs = inputsBuilder.build();\n+                Symbol previous = inputsToOutputs.get(inputs);\n+                if (previous == null || rewrittenOutputs.get(i).equals(previous)) {\n+                    inputsToOutputs.put(inputs, rewrittenOutputs.get(i));\n                 }\n                 else {\n-                    map(canonicalOutput, output);\n+                    newMapping.put(rewrittenOutputs.get(i), previous);\n                 }\n             }\n-        }\n \n-        private void mapExchangeNodeOutputToInputSymbols(ExchangeNode node)\n-        {\n-            checkState(node.getInputs().size() == 1);\n+            Map<Symbol, Symbol> outputMapping = new HashMap<>();\n+            outputMapping.putAll(mapper.getMapping());\n+            outputMapping.putAll(newMapping);\n \n-            for (int symbolIndex = 0; symbolIndex < node.getOutputSymbols().size(); symbolIndex++) {\n-                Symbol canonicalOutput = canonicalize(node.getOutputSymbols().get(symbolIndex));\n-                Symbol canonicalInput = canonicalize(node.getInputs().get(0).get(symbolIndex));\n+            mapper = new SymbolMapper(outputMapping);\n \n-                if (!canonicalOutput.equals(canonicalInput)) {\n-                    map(canonicalOutput, canonicalInput);\n+            // deduplicate outputs and prune input symbols lists accordingly\n+            List<List<Symbol>> newInputs = new ArrayList<>();\n+            for (int i = 0; i < node.getInputs().size(); i++) {\n+                newInputs.add(new ArrayList<>());\n+            }\n+            ImmutableList.Builder<Symbol> newOutputs = ImmutableList.builder();\n+            Set<Symbol> addedOutputs = new HashSet<>();\n+            for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                Symbol output = mapper.map(rewrittenOutputs.get(i));\n+                if (addedOutputs.add(output)) {\n+                    newOutputs.add(output);\n+                    for (int j = 0; j < rewrittenInputs.size(); j++) {\n+                        newInputs.get(j).add(rewrittenInputs.get(j).get(i));\n+                    }\n                 }\n             }\n-        }\n \n-        private List<Symbol> canonicalizeExchangeNodeInputs(ExchangeNode node, int symbolIndex)\n-        {\n-            return node.getInputs().stream()\n-                    .map(input -> canonicalize(input.get(symbolIndex)))\n-                    .collect(toImmutableList());\n+            // rewrite PartitioningScheme\n+            PartitioningScheme newPartitioningScheme = mapper.map(node.getPartitioningScheme(), newOutputs.build());\n+\n+            // rewrite OrderingScheme\n+            Optional<OrderingScheme> newOrderingScheme = node.getOrderingScheme().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new ExchangeNode(\n+                            node.getId(),\n+                            node.getType(),\n+                            node.getScope(),\n+                            newPartitioningScheme,\n+                            rewrittenChildren.build(),\n+                            newInputs,\n+                            newOrderingScheme),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitRemoteSource(RemoteSourceNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitRemoteSource(RemoteSourceNode node, UnaliasContext context)\n         {\n-            return new RemoteSourceNode(\n-                    node.getId(),\n-                    node.getSourceFragmentIds(),\n-                    canonicalizeAndDistinct(node.getOutputSymbols()),\n-                    node.getOrderingScheme().map(this::canonicalizeAndDistinct),\n-                    node.getExchangeType());\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            List<Symbol> newOutputs = mapper.mapAndDistinct(node.getOutputSymbols());\n+            Optional<OrderingScheme> newOrderingScheme = node.getOrderingScheme().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new RemoteSourceNode(\n+                            node.getId(),\n+                            node.getSourceFragmentIds(),\n+                            newOutputs,\n+                            newOrderingScheme,\n+                            node.getExchangeType()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitOffset(OffsetNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitOffset(OffsetNode node, UnaliasContext context)\n         {\n-            return context.defaultRewrite(node);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+\n+            return new PlanAndMappings(\n+                    node.replaceChildren(ImmutableList.of(rewrittenSource.getRoot())),\n+                    rewrittenSource.getSymbolMappings());\n         }\n \n         @Override\n-        public PlanNode visitLimit(LimitNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitLimit(LimitNode node, UnaliasContext context)\n         {\n-            if (node.isWithTies()) {\n-                PlanNode source = context.rewrite(node.getSource());\n-                return new LimitNode(node.getId(), source, node.getCount(), node.getTiesResolvingScheme().map(this::canonicalizeAndDistinct), node.isPartial());\n-            }\n-            return context.defaultRewrite(node);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            LimitNode rewrittenLimit = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenLimit, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitDistinctLimit(DistinctLimitNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitDistinctLimit(DistinctLimitNode node, UnaliasContext context)\n         {\n-            return new DistinctLimitNode(node.getId(), context.rewrite(node.getSource()), node.getLimit(), node.isPartial(), canonicalizeAndDistinct(node.getDistinctSymbols()), canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            DistinctLimitNode rewrittenDistinctLimit = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenDistinctLimit, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitSample(SampleNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitSample(SampleNode node, UnaliasContext context)\n         {\n-            return new SampleNode(node.getId(), context.rewrite(node.getSource()), node.getSampleRatio(), node.getSampleType());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+\n+            return new PlanAndMappings(\n+                    node.replaceChildren(ImmutableList.of(rewrittenSource.getRoot())),\n+                    rewrittenSource.getSymbolMappings());\n         }\n \n         @Override\n-        public PlanNode visitValues(ValuesNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitValues(ValuesNode node, UnaliasContext context)\n         {\n-            List<List<Expression>> canonicalizedRows = node.getRows().stream()\n-                    .map(this::canonicalize)\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            List<List<Expression>> newRows = node.getRows().stream()\n+                    .map(row -> row.stream()\n+                            .map(mapper::map)\n+                            .collect(toImmutableList()))\n                     .collect(toImmutableList());\n-            List<Symbol> canonicalizedOutputSymbols = canonicalizeAndDistinct(node.getOutputSymbols());\n-            checkState(node.getOutputSymbols().size() == canonicalizedOutputSymbols.size(), \"Values output symbols were pruned\");\n-            return new ValuesNode(\n-                    node.getId(),\n-                    canonicalizedOutputSymbols,\n-                    canonicalizedRows);\n+\n+            List<Symbol> newOutputSymbols = mapper.mapAndDistinct(node.getOutputSymbols());\n+            checkState(node.getOutputSymbols().size() == newOutputSymbols.size(), \"Values output symbols were pruned\");\n+\n+            return new PlanAndMappings(\n+                    new ValuesNode(node.getId(), newOutputSymbols, newRows),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTableDelete(TableDeleteNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableDelete(TableDeleteNode node, UnaliasContext context)\n         {\n-            return node;\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            Symbol newOutput = mapper.map(node.getOutput());\n+\n+            return new PlanAndMappings(\n+                    new TableDeleteNode(node.getId(), node.getTarget(), newOutput),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitDelete(DeleteNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitDelete(DeleteNode node, UnaliasContext context)\n         {\n-            return new DeleteNode(node.getId(), context.rewrite(node.getSource()), node.getTarget(), canonicalize(node.getRowId()), node.getOutputSymbols());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Symbol newRowId = mapper.map(node.getRowId());\n+            List<Symbol> newOutputs = mapper.map(node.getOutputSymbols());\n+\n+            return new PlanAndMappings(\n+                    new DeleteNode(\n+                            node.getId(),\n+                            rewrittenSource.getRoot(),\n+                            node.getTarget(),\n+                            newRowId,\n+                            newOutputs),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitStatisticsWriterNode(StatisticsWriterNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitStatisticsWriterNode(StatisticsWriterNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            StatisticsWriterNode rewrittenStatisticsWriter = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenStatisticsWriter, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTableFinish(TableFinishNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableWriter(TableWriterNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            TableWriterNode rewrittenTableWriter = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTableWriter, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitRowNumber(RowNumberNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableFinish(TableFinishNode node, UnaliasContext context)\n         {\n-            return new RowNumberNode(\n-                    node.getId(),\n-                    context.rewrite(node.getSource()),\n-                    canonicalizeAndDistinct(node.getPartitionBy()),\n-                    node.isOrderSensitive(),\n-                    canonicalize(node.getRowNumberSymbol()),\n-                    node.getMaxRowCountPerPartition(),\n-                    canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            TableFinishNode rewrittenTableFinish = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTableFinish, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTopNRowNumber(TopNRowNumberNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitRowNumber(RowNumberNode node, UnaliasContext context)\n         {\n-            return new TopNRowNumberNode(\n-                    node.getId(),\n-                    context.rewrite(node.getSource()),\n-                    canonicalizeAndDistinct(node.getSpecification()),\n-                    canonicalize(node.getRowNumberSymbol()),\n-                    node.getMaxRowCountPerPartition(),\n-                    node.isPartial(),\n-                    canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            RowNumberNode rewrittenRowNumber = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenRowNumber, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitFilter(FilterNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTopNRowNumber(TopNRowNumberNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            return new FilterNode(node.getId(), source, canonicalize(node.getPredicate()));\n+            TopNRowNumberNode rewrittenTopNRowNumber = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTopNRowNumber, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitProject(ProjectNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTopN(TopNNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            return new ProjectNode(node.getId(), source, canonicalize(node.getAssignments()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            TopNNode rewrittenTopN = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTopN, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitOutput(OutputNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitSort(SortNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            List<Symbol> canonical = Lists.transform(node.getOutputSymbols(), this::canonicalize);\n-            return new OutputNode(node.getId(), source, node.getColumnNames(), canonical);\n+            OrderingScheme newOrderingScheme = mapper.map(node.getOrderingScheme());\n+\n+            return new PlanAndMappings(\n+                    new SortNode(node.getId(), rewrittenSource.getRoot(), newOrderingScheme, node.isPartial()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitEnforceSingleRow(EnforceSingleRowNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitFilter(FilterNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Expression newPredicate = mapper.map(node.getPredicate());\n \n-            return new EnforceSingleRowNode(node.getId(), source);\n+            return new PlanAndMappings(\n+                    new FilterNode(node.getId(), rewrittenSource.getRoot(), newPredicate),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitAssignUniqueId(AssignUniqueId node, RewriteContext<Void> context)\n+        public PlanAndMappings visitProject(ProjectNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            // canonicalize ProjectNode assignments\n+            ImmutableList.Builder<Map.Entry<Symbol, Expression>> builder = ImmutableList.builder();\n+            for (Map.Entry<Symbol, Expression> assignment : node.getAssignments().entrySet()) {\n+                builder.add(new SimpleEntry<>(mapper.map(assignment.getKey()), mapper.map(assignment.getValue())));\n+            }\n+            List<Map.Entry<Symbol, Expression>> rewrittenAssignments = builder.build();\n \n-            return new AssignUniqueId(node.getId(), source, node.getIdColumn());\n+            // deduplicate assignments\n+            Map<Symbol, Expression> deduplicateAssignments = new HashMap<>();\n+            for (Map.Entry<Symbol, Expression> assignment : rewrittenAssignments) {\n+                Expression previous = deduplicateAssignments.put(assignment.getKey(), assignment.getValue());\n+                checkState(previous == null || assignment.getValue().equals(previous), \"different expressions projected to the same symbol\");\n+            }\n+\n+            // derive new mappings for ProjectNode output symbols\n+            Map<Symbol, Symbol> newMapping = new HashMap<>();\n+            Map<Expression, Symbol> inputsToOutputs = new HashMap<>();\n+            for (Map.Entry<Symbol, Expression> assignment : deduplicateAssignments.entrySet()) {\n+                Expression expression = assignment.getValue();\n+                // 1. for trivial symbol projection, map output symbol to input symbol\n+                if (expression instanceof SymbolReference) {\n+                    Symbol value = Symbol.from(expression);\n+                    if (!assignment.getKey().equals(value)) {\n+                        newMapping.put(assignment.getKey(), value);\n+                    }\n+                }\n+                // 2. map same deterministic expressions within a projection into the same symbol\n+                // omit NullLiterals since those have ambiguous types\n+                else if (DeterminismEvaluator.isDeterministic(expression, metadata) && !(expression instanceof NullLiteral)) {\n+                    Symbol previous = inputsToOutputs.get(expression);\n+                    if (previous == null || assignment.getKey().equals(previous)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 751}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM0MDkyNg==", "bodyText": "This could be simplified as I described elsewhere", "url": "https://github.com/trinodb/trino/pull/4038#discussion_r447340926", "createdAt": "2020-06-30T00:44:45Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/UnaliasSymbolReferences.java", "diffHunk": "@@ -126,695 +122,988 @@ public PlanNode optimize(PlanNode plan, Session session, TypeProvider types, Sym\n         requireNonNull(symbolAllocator, \"symbolAllocator is null\");\n         requireNonNull(idAllocator, \"idAllocator is null\");\n \n-        return SimplePlanRewriter.rewriteWith(new Rewriter(metadata, types), plan);\n+        return plan.accept(new Visitor(metadata, symbolAllocator), UnaliasContext.empty()).getRoot();\n     }\n \n-    private static class Rewriter\n-            extends SimplePlanRewriter<Void>\n+    private static class Visitor\n+            extends PlanVisitor<PlanAndMappings, UnaliasContext>\n     {\n-        private final Map<Symbol, Symbol> mapping = new HashMap<>();\n         private final Metadata metadata;\n-        private final TypeProvider types;\n+        private final SymbolAllocator symbolAllocator;\n \n-        private Rewriter(Metadata metadata, TypeProvider types)\n+        public Visitor(Metadata metadata, SymbolAllocator symbolAllocator)\n         {\n-            this.metadata = metadata;\n-            this.types = types;\n+            this.metadata = requireNonNull(metadata, \"metadata is null\");\n+            this.symbolAllocator = requireNonNull(symbolAllocator, \"symbolAllocator is null\");\n         }\n \n         @Override\n-        public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> context)\n+        protected PlanAndMappings visitPlan(PlanNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            //TODO: use mapper in other methods\n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source);\n+            throw new UnsupportedOperationException(\"Unsupported plan node \" + node.getClass().getSimpleName());\n         }\n \n         @Override\n-        public PlanNode visitGroupId(GroupIdNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitAggregation(AggregationNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            Map<Symbol, Symbol> newGroupingMappings = new HashMap<>();\n-            ImmutableList.Builder<List<Symbol>> newGroupingSets = ImmutableList.builder();\n+            AggregationNode rewrittenAggregation = mapper.map(node, rewrittenSource.getRoot());\n \n-            for (List<Symbol> groupingSet : node.getGroupingSets()) {\n-                ImmutableList.Builder<Symbol> newGroupingSet = ImmutableList.builder();\n-                for (Symbol output : groupingSet) {\n-                    newGroupingMappings.putIfAbsent(canonicalize(output), canonicalize(node.getGroupingColumns().get(output)));\n-                    newGroupingSet.add(canonicalize(output));\n-                }\n-                newGroupingSets.add(newGroupingSet.build());\n-            }\n+            return new PlanAndMappings(rewrittenAggregation, mapper.getMapping());\n+        }\n+\n+        @Override\n+        public PlanAndMappings visitGroupId(GroupIdNode node, UnaliasContext context)\n+        {\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            return new GroupIdNode(node.getId(), source, newGroupingSets.build(), newGroupingMappings, canonicalizeAndDistinct(node.getAggregationArguments()), canonicalize(node.getGroupIdSymbol()));\n+            GroupIdNode rewrittenGroupId = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenGroupId, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitExplainAnalyze(ExplainAnalyzeNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitExplainAnalyze(ExplainAnalyzeNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            return new ExplainAnalyzeNode(node.getId(), source, canonicalize(node.getOutputSymbol()), node.isVerbose());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Symbol newOutputSymbol = mapper.map(node.getOutputSymbol());\n+\n+            return new PlanAndMappings(\n+                    new ExplainAnalyzeNode(node.getId(), rewrittenSource.getRoot(), newOutputSymbol, node.isVerbose()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitMarkDistinct(MarkDistinctNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitMarkDistinct(MarkDistinctNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            List<Symbol> symbols = canonicalizeAndDistinct(node.getDistinctSymbols());\n-            return new MarkDistinctNode(node.getId(), source, canonicalize(node.getMarkerSymbol()), symbols, canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Symbol newMarkerSymbol = mapper.map(node.getMarkerSymbol());\n+            List<Symbol> newDistinctSymbols = mapper.mapAndDistinct(node.getDistinctSymbols());\n+            Optional<Symbol> newHashSymbol = node.getHashSymbol().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new MarkDistinctNode(\n+                            node.getId(),\n+                            rewrittenSource.getRoot(),\n+                            newMarkerSymbol,\n+                            newDistinctSymbols,\n+                            newHashSymbol),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitUnnest(UnnestNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitUnnest(UnnestNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            ImmutableList.Builder<UnnestNode.Mapping> mappings = ImmutableList.builder();\n+            List<Symbol> newReplicateSymbols = mapper.mapAndDistinct(node.getReplicateSymbols());\n \n-            for (UnnestNode.Mapping mapping : node.getMappings()) {\n-                mappings.add(new UnnestNode.Mapping(canonicalize(mapping.getInput()), mapping.getOutputs()));\n+            ImmutableList.Builder<UnnestNode.Mapping> newMappings = ImmutableList.builder();\n+            for (UnnestNode.Mapping unnestMapping : node.getMappings()) {\n+                newMappings.add(new UnnestNode.Mapping(mapper.map(unnestMapping.getInput()), mapper.map(unnestMapping.getOutputs())));\n             }\n \n-            return new UnnestNode(\n-                    node.getId(),\n-                    source,\n-                    canonicalizeAndDistinct(node.getReplicateSymbols()),\n-                    mappings.build(),\n-                    node.getOrdinalitySymbol(),\n-                    node.getJoinType(),\n-                    node.getFilter().map(this::canonicalize));\n+            Optional<Symbol> newOrdinalitySymbol = node.getOrdinalitySymbol().map(mapper::map);\n+            Optional<Expression> newFilter = node.getFilter().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new UnnestNode(\n+                            node.getId(),\n+                            rewrittenSource.getRoot(),\n+                            newReplicateSymbols,\n+                            newMappings.build(),\n+                            newOrdinalitySymbol,\n+                            node.getJoinType(),\n+                            newFilter),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitWindow(WindowNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitWindow(WindowNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-\n-            ImmutableMap.Builder<Symbol, WindowNode.Function> functions = ImmutableMap.builder();\n-            node.getWindowFunctions().forEach((symbol, function) -> {\n-                ResolvedFunction resolvedFunction = function.getResolvedFunction();\n-                List<Expression> arguments = canonicalize(function.getArguments());\n-                WindowNode.Frame canonicalFrame = canonicalize(function.getFrame());\n-\n-                functions.put(canonicalize(symbol), new WindowNode.Function(resolvedFunction, arguments, canonicalFrame, function.isIgnoreNulls()));\n-            });\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            return new WindowNode(\n-                    node.getId(),\n-                    source,\n-                    canonicalizeAndDistinct(node.getSpecification()),\n-                    functions.build(),\n-                    canonicalize(node.getHashSymbol()),\n-                    canonicalize(node.getPrePartitionedInputs()),\n-                    node.getPreSortedOrderPrefix());\n-        }\n+            WindowNode rewrittenWindow = mapper.map(node, rewrittenSource.getRoot());\n \n-        private WindowNode.Frame canonicalize(WindowNode.Frame frame)\n-        {\n-            return new WindowNode.Frame(\n-                    frame.getType(),\n-                    frame.getStartType(),\n-                    canonicalize(frame.getStartValue()),\n-                    frame.getEndType(),\n-                    canonicalize(frame.getEndValue()),\n-                    frame.getOriginalStartValue(),\n-                    frame.getOriginalEndValue());\n+            return new PlanAndMappings(rewrittenWindow, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTableScan(TableScanNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableScan(TableScanNode node, UnaliasContext context)\n         {\n-            return node;\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            List<Symbol> newOutputs = mapper.map(node.getOutputSymbols());\n+\n+            Map<Symbol, ColumnHandle> newAssignments = new HashMap<>();\n+            node.getAssignments().forEach((symbol, handle) -> {\n+                newAssignments.put(mapper.map(symbol), handle);\n+            });\n+\n+            return new PlanAndMappings(\n+                    new TableScanNode(node.getId(), node.getTable(), newOutputs, newAssignments, node.getEnforcedConstraint()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitExchange(ExchangeNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitExchange(ExchangeNode node, UnaliasContext context)\n         {\n-            List<PlanNode> sources = node.getSources().stream()\n-                    .map(context::rewrite)\n-                    .collect(toImmutableList());\n-\n-            mapExchangeNodeSymbols(node);\n-\n-            List<List<Symbol>> inputs = new ArrayList<>();\n-            for (int i = 0; i < node.getInputs().size(); i++) {\n-                inputs.add(new ArrayList<>());\n+            ImmutableList.Builder<PlanNode> rewrittenChildren = ImmutableList.builder();\n+            ImmutableList.Builder<List<Symbol>> rewrittenInputsBuilder = ImmutableList.builder();\n+\n+            // rewrite child and map corresponding input list accordingly to the child's mapping\n+            for (int i = 0; i < node.getSources().size(); i++) {\n+                PlanAndMappings rewrittenChild = node.getSources().get(i).accept(this, context);\n+                rewrittenChildren.add(rewrittenChild.getRoot());\n+                SymbolMapper mapper = new SymbolMapper(rewrittenChild.getSymbolMappings());\n+                rewrittenInputsBuilder.add(mapper.map(node.getInputs().get(i)));\n             }\n-            Set<Symbol> addedOutputs = new HashSet<>();\n-            ImmutableList.Builder<Symbol> outputs = ImmutableList.builder();\n-            for (int symbolIndex = 0; symbolIndex < node.getOutputSymbols().size(); symbolIndex++) {\n-                Symbol canonicalOutput = canonicalize(node.getOutputSymbols().get(symbolIndex));\n-                if (addedOutputs.add(canonicalOutput)) {\n-                    outputs.add(canonicalOutput);\n-                    for (int i = 0; i < node.getInputs().size(); i++) {\n-                        List<Symbol> input = node.getInputs().get(i);\n-                        inputs.get(i).add(canonicalize(input.get(symbolIndex)));\n-                    }\n+            List<List<Symbol>> rewrittenInputs = rewrittenInputsBuilder.build();\n+\n+            // canonicalize ExchangeNode outputs\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+            List<Symbol> rewrittenOutputs = mapper.map(node.getOutputSymbols());\n+\n+            // sanity check: assert that duplicate outputs result from same inputs\n+            Map<Symbol, List<Symbol>> outputsToInputs = new HashMap<>();\n+            for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                ImmutableList.Builder<Symbol> inputsBuilder = ImmutableList.builder();\n+                for (List<Symbol> inputs : rewrittenInputs) {\n+                    inputsBuilder.add(inputs.get(i));\n                 }\n+                List<Symbol> inputs = inputsBuilder.build();\n+                List<Symbol> previous = outputsToInputs.put(rewrittenOutputs.get(i), inputs);\n+                checkState(previous == null || inputs.equals(previous), \"different inputs mapped to the same output symbol\");\n             }\n \n-            PartitioningScheme partitioningScheme = new PartitioningScheme(\n-                    node.getPartitioningScheme().getPartitioning().translate(this::canonicalize),\n-                    outputs.build(),\n-                    canonicalize(node.getPartitioningScheme().getHashColumn()),\n-                    node.getPartitioningScheme().isReplicateNullsAndAny(),\n-                    node.getPartitioningScheme().getBucketToPartition());\n-\n-            Optional<OrderingScheme> orderingScheme = node.getOrderingScheme().map(this::canonicalizeAndDistinct);\n+            // derive new mappings for ExchangeNode output symbols\n+            Map<Symbol, Symbol> newMapping = new HashMap<>();\n \n-            return new ExchangeNode(node.getId(), node.getType(), node.getScope(), partitioningScheme, sources, inputs, orderingScheme);\n-        }\n-\n-        private void mapExchangeNodeSymbols(ExchangeNode node)\n-        {\n-            if (node.getInputs().size() == 1) {\n-                mapExchangeNodeOutputToInputSymbols(node);\n-                return;\n+            // 1. for a single ExchangeNode source, map outputs to inputs\n+            if (rewrittenInputs.size() == 1) {\n+                for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                    Symbol output = rewrittenOutputs.get(i);\n+                    Symbol input = rewrittenInputs.get(0).get(i);\n+                    if (!output.equals(input)) {\n+                        newMapping.put(output, input);\n+                    }\n+                }\n             }\n \n-            // Mapping from list [node.getInput(0).get(symbolIndex), node.getInput(1).get(symbolIndex), ...] to node.getOutputSymbols(symbolIndex).\n-            // All symbols are canonical.\n+            // 2. for multiple ExchangeNode sources, if different output symbols result from the same lists of canonical input symbols, map all those outputs to the same symbol\n             Map<List<Symbol>, Symbol> inputsToOutputs = new HashMap<>();\n-            // Map each same list of input symbols [I1, I2, ..., In] to the same output symbol O\n-            for (int symbolIndex = 0; symbolIndex < node.getOutputSymbols().size(); symbolIndex++) {\n-                Symbol canonicalOutput = canonicalize(node.getOutputSymbols().get(symbolIndex));\n-                List<Symbol> canonicalInputs = canonicalizeExchangeNodeInputs(node, symbolIndex);\n-                Symbol output = inputsToOutputs.get(canonicalInputs);\n-\n-                if (output == null || canonicalOutput.equals(output)) {\n-                    inputsToOutputs.put(canonicalInputs, canonicalOutput);\n+            for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                ImmutableList.Builder<Symbol> inputsBuilder = ImmutableList.builder();\n+                for (List<Symbol> inputs : rewrittenInputs) {\n+                    inputsBuilder.add(inputs.get(i));\n+                }\n+                List<Symbol> inputs = inputsBuilder.build();\n+                Symbol previous = inputsToOutputs.get(inputs);\n+                if (previous == null || rewrittenOutputs.get(i).equals(previous)) {\n+                    inputsToOutputs.put(inputs, rewrittenOutputs.get(i));\n                 }\n                 else {\n-                    map(canonicalOutput, output);\n+                    newMapping.put(rewrittenOutputs.get(i), previous);\n                 }\n             }\n-        }\n \n-        private void mapExchangeNodeOutputToInputSymbols(ExchangeNode node)\n-        {\n-            checkState(node.getInputs().size() == 1);\n+            Map<Symbol, Symbol> outputMapping = new HashMap<>();\n+            outputMapping.putAll(mapper.getMapping());\n+            outputMapping.putAll(newMapping);\n \n-            for (int symbolIndex = 0; symbolIndex < node.getOutputSymbols().size(); symbolIndex++) {\n-                Symbol canonicalOutput = canonicalize(node.getOutputSymbols().get(symbolIndex));\n-                Symbol canonicalInput = canonicalize(node.getInputs().get(0).get(symbolIndex));\n+            mapper = new SymbolMapper(outputMapping);\n \n-                if (!canonicalOutput.equals(canonicalInput)) {\n-                    map(canonicalOutput, canonicalInput);\n+            // deduplicate outputs and prune input symbols lists accordingly\n+            List<List<Symbol>> newInputs = new ArrayList<>();\n+            for (int i = 0; i < node.getInputs().size(); i++) {\n+                newInputs.add(new ArrayList<>());\n+            }\n+            ImmutableList.Builder<Symbol> newOutputs = ImmutableList.builder();\n+            Set<Symbol> addedOutputs = new HashSet<>();\n+            for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                Symbol output = mapper.map(rewrittenOutputs.get(i));\n+                if (addedOutputs.add(output)) {\n+                    newOutputs.add(output);\n+                    for (int j = 0; j < rewrittenInputs.size(); j++) {\n+                        newInputs.get(j).add(rewrittenInputs.get(j).get(i));\n+                    }\n                 }\n             }\n-        }\n \n-        private List<Symbol> canonicalizeExchangeNodeInputs(ExchangeNode node, int symbolIndex)\n-        {\n-            return node.getInputs().stream()\n-                    .map(input -> canonicalize(input.get(symbolIndex)))\n-                    .collect(toImmutableList());\n+            // rewrite PartitioningScheme\n+            PartitioningScheme newPartitioningScheme = mapper.map(node.getPartitioningScheme(), newOutputs.build());\n+\n+            // rewrite OrderingScheme\n+            Optional<OrderingScheme> newOrderingScheme = node.getOrderingScheme().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new ExchangeNode(\n+                            node.getId(),\n+                            node.getType(),\n+                            node.getScope(),\n+                            newPartitioningScheme,\n+                            rewrittenChildren.build(),\n+                            newInputs,\n+                            newOrderingScheme),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitRemoteSource(RemoteSourceNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitRemoteSource(RemoteSourceNode node, UnaliasContext context)\n         {\n-            return new RemoteSourceNode(\n-                    node.getId(),\n-                    node.getSourceFragmentIds(),\n-                    canonicalizeAndDistinct(node.getOutputSymbols()),\n-                    node.getOrderingScheme().map(this::canonicalizeAndDistinct),\n-                    node.getExchangeType());\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            List<Symbol> newOutputs = mapper.mapAndDistinct(node.getOutputSymbols());\n+            Optional<OrderingScheme> newOrderingScheme = node.getOrderingScheme().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new RemoteSourceNode(\n+                            node.getId(),\n+                            node.getSourceFragmentIds(),\n+                            newOutputs,\n+                            newOrderingScheme,\n+                            node.getExchangeType()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitOffset(OffsetNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitOffset(OffsetNode node, UnaliasContext context)\n         {\n-            return context.defaultRewrite(node);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+\n+            return new PlanAndMappings(\n+                    node.replaceChildren(ImmutableList.of(rewrittenSource.getRoot())),\n+                    rewrittenSource.getSymbolMappings());\n         }\n \n         @Override\n-        public PlanNode visitLimit(LimitNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitLimit(LimitNode node, UnaliasContext context)\n         {\n-            if (node.isWithTies()) {\n-                PlanNode source = context.rewrite(node.getSource());\n-                return new LimitNode(node.getId(), source, node.getCount(), node.getTiesResolvingScheme().map(this::canonicalizeAndDistinct), node.isPartial());\n-            }\n-            return context.defaultRewrite(node);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            LimitNode rewrittenLimit = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenLimit, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitDistinctLimit(DistinctLimitNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitDistinctLimit(DistinctLimitNode node, UnaliasContext context)\n         {\n-            return new DistinctLimitNode(node.getId(), context.rewrite(node.getSource()), node.getLimit(), node.isPartial(), canonicalizeAndDistinct(node.getDistinctSymbols()), canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            DistinctLimitNode rewrittenDistinctLimit = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenDistinctLimit, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitSample(SampleNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitSample(SampleNode node, UnaliasContext context)\n         {\n-            return new SampleNode(node.getId(), context.rewrite(node.getSource()), node.getSampleRatio(), node.getSampleType());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+\n+            return new PlanAndMappings(\n+                    node.replaceChildren(ImmutableList.of(rewrittenSource.getRoot())),\n+                    rewrittenSource.getSymbolMappings());\n         }\n \n         @Override\n-        public PlanNode visitValues(ValuesNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitValues(ValuesNode node, UnaliasContext context)\n         {\n-            List<List<Expression>> canonicalizedRows = node.getRows().stream()\n-                    .map(this::canonicalize)\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            List<List<Expression>> newRows = node.getRows().stream()\n+                    .map(row -> row.stream()\n+                            .map(mapper::map)\n+                            .collect(toImmutableList()))\n                     .collect(toImmutableList());\n-            List<Symbol> canonicalizedOutputSymbols = canonicalizeAndDistinct(node.getOutputSymbols());\n-            checkState(node.getOutputSymbols().size() == canonicalizedOutputSymbols.size(), \"Values output symbols were pruned\");\n-            return new ValuesNode(\n-                    node.getId(),\n-                    canonicalizedOutputSymbols,\n-                    canonicalizedRows);\n+\n+            List<Symbol> newOutputSymbols = mapper.mapAndDistinct(node.getOutputSymbols());\n+            checkState(node.getOutputSymbols().size() == newOutputSymbols.size(), \"Values output symbols were pruned\");\n+\n+            return new PlanAndMappings(\n+                    new ValuesNode(node.getId(), newOutputSymbols, newRows),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTableDelete(TableDeleteNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableDelete(TableDeleteNode node, UnaliasContext context)\n         {\n-            return node;\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            Symbol newOutput = mapper.map(node.getOutput());\n+\n+            return new PlanAndMappings(\n+                    new TableDeleteNode(node.getId(), node.getTarget(), newOutput),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitDelete(DeleteNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitDelete(DeleteNode node, UnaliasContext context)\n         {\n-            return new DeleteNode(node.getId(), context.rewrite(node.getSource()), node.getTarget(), canonicalize(node.getRowId()), node.getOutputSymbols());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Symbol newRowId = mapper.map(node.getRowId());\n+            List<Symbol> newOutputs = mapper.map(node.getOutputSymbols());\n+\n+            return new PlanAndMappings(\n+                    new DeleteNode(\n+                            node.getId(),\n+                            rewrittenSource.getRoot(),\n+                            node.getTarget(),\n+                            newRowId,\n+                            newOutputs),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitStatisticsWriterNode(StatisticsWriterNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitStatisticsWriterNode(StatisticsWriterNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            StatisticsWriterNode rewrittenStatisticsWriter = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenStatisticsWriter, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTableFinish(TableFinishNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableWriter(TableWriterNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            TableWriterNode rewrittenTableWriter = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTableWriter, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitRowNumber(RowNumberNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableFinish(TableFinishNode node, UnaliasContext context)\n         {\n-            return new RowNumberNode(\n-                    node.getId(),\n-                    context.rewrite(node.getSource()),\n-                    canonicalizeAndDistinct(node.getPartitionBy()),\n-                    node.isOrderSensitive(),\n-                    canonicalize(node.getRowNumberSymbol()),\n-                    node.getMaxRowCountPerPartition(),\n-                    canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            TableFinishNode rewrittenTableFinish = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTableFinish, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTopNRowNumber(TopNRowNumberNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitRowNumber(RowNumberNode node, UnaliasContext context)\n         {\n-            return new TopNRowNumberNode(\n-                    node.getId(),\n-                    context.rewrite(node.getSource()),\n-                    canonicalizeAndDistinct(node.getSpecification()),\n-                    canonicalize(node.getRowNumberSymbol()),\n-                    node.getMaxRowCountPerPartition(),\n-                    node.isPartial(),\n-                    canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            RowNumberNode rewrittenRowNumber = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenRowNumber, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitFilter(FilterNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTopNRowNumber(TopNRowNumberNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            return new FilterNode(node.getId(), source, canonicalize(node.getPredicate()));\n+            TopNRowNumberNode rewrittenTopNRowNumber = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTopNRowNumber, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitProject(ProjectNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTopN(TopNNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            return new ProjectNode(node.getId(), source, canonicalize(node.getAssignments()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            TopNNode rewrittenTopN = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTopN, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitOutput(OutputNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitSort(SortNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            List<Symbol> canonical = Lists.transform(node.getOutputSymbols(), this::canonicalize);\n-            return new OutputNode(node.getId(), source, node.getColumnNames(), canonical);\n+            OrderingScheme newOrderingScheme = mapper.map(node.getOrderingScheme());\n+\n+            return new PlanAndMappings(\n+                    new SortNode(node.getId(), rewrittenSource.getRoot(), newOrderingScheme, node.isPartial()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitEnforceSingleRow(EnforceSingleRowNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitFilter(FilterNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Expression newPredicate = mapper.map(node.getPredicate());\n \n-            return new EnforceSingleRowNode(node.getId(), source);\n+            return new PlanAndMappings(\n+                    new FilterNode(node.getId(), rewrittenSource.getRoot(), newPredicate),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitAssignUniqueId(AssignUniqueId node, RewriteContext<Void> context)\n+        public PlanAndMappings visitProject(ProjectNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            // canonicalize ProjectNode assignments\n+            ImmutableList.Builder<Map.Entry<Symbol, Expression>> builder = ImmutableList.builder();\n+            for (Map.Entry<Symbol, Expression> assignment : node.getAssignments().entrySet()) {\n+                builder.add(new SimpleEntry<>(mapper.map(assignment.getKey()), mapper.map(assignment.getValue())));\n+            }\n+            List<Map.Entry<Symbol, Expression>> rewrittenAssignments = builder.build();\n \n-            return new AssignUniqueId(node.getId(), source, node.getIdColumn());\n+            // deduplicate assignments\n+            Map<Symbol, Expression> deduplicateAssignments = new HashMap<>();\n+            for (Map.Entry<Symbol, Expression> assignment : rewrittenAssignments) {\n+                Expression previous = deduplicateAssignments.put(assignment.getKey(), assignment.getValue());\n+                checkState(previous == null || assignment.getValue().equals(previous), \"different expressions projected to the same symbol\");\n+            }\n+\n+            // derive new mappings for ProjectNode output symbols\n+            Map<Symbol, Symbol> newMapping = new HashMap<>();\n+            Map<Expression, Symbol> inputsToOutputs = new HashMap<>();\n+            for (Map.Entry<Symbol, Expression> assignment : deduplicateAssignments.entrySet()) {\n+                Expression expression = assignment.getValue();\n+                // 1. for trivial symbol projection, map output symbol to input symbol\n+                if (expression instanceof SymbolReference) {\n+                    Symbol value = Symbol.from(expression);\n+                    if (!assignment.getKey().equals(value)) {\n+                        newMapping.put(assignment.getKey(), value);\n+                    }\n+                }\n+                // 2. map same deterministic expressions within a projection into the same symbol\n+                // omit NullLiterals since those have ambiguous types\n+                else if (DeterminismEvaluator.isDeterministic(expression, metadata) && !(expression instanceof NullLiteral)) {\n+                    Symbol previous = inputsToOutputs.get(expression);\n+                    if (previous == null || assignment.getKey().equals(previous)) {\n+                        inputsToOutputs.put(expression, assignment.getKey());\n+                    }\n+                    else {\n+                        newMapping.put(assignment.getKey(), previous);\n+                    }\n+                }\n+            }\n+\n+            Map<Symbol, Symbol> outputMapping = new HashMap<>();\n+            outputMapping.putAll(mapper.getMapping());\n+            outputMapping.putAll(newMapping);\n+\n+            mapper = new SymbolMapper(outputMapping);\n+\n+            // build new Assignments with canonical outputs\n+            // duplicate entries will be removed by the Builder\n+            Assignments.Builder newAssignments = Assignments.builder();\n+            for (Map.Entry<Symbol, Expression> assignment : deduplicateAssignments.entrySet()) {\n+                newAssignments.put(mapper.map(assignment.getKey()), assignment.getValue());\n+            }\n+\n+            return new PlanAndMappings(\n+                    new ProjectNode(node.getId(), rewrittenSource.getRoot(), newAssignments.build()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitApply(ApplyNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitOutput(OutputNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getInput());\n-            PlanNode subquery = context.rewrite(node.getSubquery());\n-            List<Symbol> canonicalCorrelation = Lists.transform(node.getCorrelation(), this::canonicalize);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            return new ApplyNode(node.getId(), source, subquery, canonicalize(node.getSubqueryAssignments()), canonicalCorrelation, node.getOriginSubquery());\n+            List<Symbol> newOutputs = mapper.map(node.getOutputSymbols());\n+\n+            return new PlanAndMappings(\n+                    new OutputNode(node.getId(), rewrittenSource.getRoot(), node.getColumnNames(), newOutputs),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitCorrelatedJoin(CorrelatedJoinNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitEnforceSingleRow(EnforceSingleRowNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getInput());\n-            PlanNode subquery = context.rewrite(node.getSubquery());\n-            List<Symbol> canonicalCorrelation = canonicalizeAndDistinct(node.getCorrelation());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n \n-            return new CorrelatedJoinNode(node.getId(), source, subquery, canonicalCorrelation, node.getType(), canonicalize(node.getFilter()), node.getOriginSubquery());\n+            return new PlanAndMappings(\n+                    node.replaceChildren(ImmutableList.of(rewrittenSource.getRoot())),\n+                    rewrittenSource.getSymbolMappings());\n         }\n \n         @Override\n-        public PlanNode visitTopN(TopNNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitAssignUniqueId(AssignUniqueId node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Symbol newUnique = mapper.map(node.getIdColumn());\n \n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source, node.getId());\n+            return new PlanAndMappings(\n+                    new AssignUniqueId(node.getId(), rewrittenSource.getRoot(), newUnique),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitSort(SortNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitApply(ApplyNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            // it is assumed that apart from correlation (and possibly outer correlation), symbols are distinct between Input and Subquery\n+            // rewrite Input\n+            PlanAndMappings rewrittenInput = node.getInput().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenInput.getSymbolMappings());\n+\n+            // rewrite correlation with mapping from Input\n+            List<Symbol> rewrittenCorrelation = mapper.mapAndDistinct(node.getCorrelation());\n+\n+            // extract new mappings for correlation symbols to apply in Subquery\n+            Set<Symbol> correlationSymbols = ImmutableSet.copyOf(node.getCorrelation());\n+            Map<Symbol, Symbol> correlationMapping = mapper.getMapping().entrySet().stream()\n+                    .filter(mapping -> correlationSymbols.contains(mapping.getKey()))\n+                    .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+            Map<Symbol, Symbol> mappingForSubquery = new HashMap<>();\n+            mappingForSubquery.putAll(context.getCorrelationMapping());\n+            mappingForSubquery.putAll(correlationMapping);\n+\n+            // rewrite Subquery\n+            PlanAndMappings rewrittenSubquery = node.getSubquery().accept(this, new UnaliasContext(mappingForSubquery));\n+\n+            // unify mappings from Input and Subquery to rewrite Subquery assignments\n+            Map<Symbol, Symbol> resultMapping = new HashMap<>();\n+            resultMapping.putAll(rewrittenInput.getSymbolMappings());\n+            resultMapping.putAll(rewrittenSubquery.getSymbolMappings());\n+            mapper = new SymbolMapper(resultMapping);\n+\n+            ImmutableList.Builder<Map.Entry<Symbol, Expression>> builder = ImmutableList.builder();\n+            for (Map.Entry<Symbol, Expression> assignment : node.getSubqueryAssignments().entrySet()) {\n+                builder.add(new SimpleEntry<>(mapper.map(assignment.getKey()), mapper.map(assignment.getValue())));\n+            }\n+            List<Map.Entry<Symbol, Expression>> rewrittenAssignments = builder.build();\n \n-            return new SortNode(node.getId(), source, canonicalizeAndDistinct(node.getOrderingScheme()), node.isPartial());\n+            // deduplicate assignments\n+            Map<Symbol, Expression> deduplicateAssignments = new HashMap<>();\n+            for (Map.Entry<Symbol, Expression> assignment : rewrittenAssignments) {\n+                Expression previous = deduplicateAssignments.put(assignment.getKey(), assignment.getValue());\n+                checkState(previous == null || assignment.getValue().equals(previous), \"different expressions assigned to the same symbol\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 871}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM0MjEwMQ==", "bodyText": "This is duplicated in a couple of places. You could extract it to a separate method.", "url": "https://github.com/trinodb/trino/pull/4038#discussion_r447342101", "createdAt": "2020-06-30T00:48:40Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/UnaliasSymbolReferences.java", "diffHunk": "@@ -126,695 +122,988 @@ public PlanNode optimize(PlanNode plan, Session session, TypeProvider types, Sym\n         requireNonNull(symbolAllocator, \"symbolAllocator is null\");\n         requireNonNull(idAllocator, \"idAllocator is null\");\n \n-        return SimplePlanRewriter.rewriteWith(new Rewriter(metadata, types), plan);\n+        return plan.accept(new Visitor(metadata, symbolAllocator), UnaliasContext.empty()).getRoot();\n     }\n \n-    private static class Rewriter\n-            extends SimplePlanRewriter<Void>\n+    private static class Visitor\n+            extends PlanVisitor<PlanAndMappings, UnaliasContext>\n     {\n-        private final Map<Symbol, Symbol> mapping = new HashMap<>();\n         private final Metadata metadata;\n-        private final TypeProvider types;\n+        private final SymbolAllocator symbolAllocator;\n \n-        private Rewriter(Metadata metadata, TypeProvider types)\n+        public Visitor(Metadata metadata, SymbolAllocator symbolAllocator)\n         {\n-            this.metadata = metadata;\n-            this.types = types;\n+            this.metadata = requireNonNull(metadata, \"metadata is null\");\n+            this.symbolAllocator = requireNonNull(symbolAllocator, \"symbolAllocator is null\");\n         }\n \n         @Override\n-        public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> context)\n+        protected PlanAndMappings visitPlan(PlanNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            //TODO: use mapper in other methods\n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source);\n+            throw new UnsupportedOperationException(\"Unsupported plan node \" + node.getClass().getSimpleName());\n         }\n \n         @Override\n-        public PlanNode visitGroupId(GroupIdNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitAggregation(AggregationNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            Map<Symbol, Symbol> newGroupingMappings = new HashMap<>();\n-            ImmutableList.Builder<List<Symbol>> newGroupingSets = ImmutableList.builder();\n+            AggregationNode rewrittenAggregation = mapper.map(node, rewrittenSource.getRoot());\n \n-            for (List<Symbol> groupingSet : node.getGroupingSets()) {\n-                ImmutableList.Builder<Symbol> newGroupingSet = ImmutableList.builder();\n-                for (Symbol output : groupingSet) {\n-                    newGroupingMappings.putIfAbsent(canonicalize(output), canonicalize(node.getGroupingColumns().get(output)));\n-                    newGroupingSet.add(canonicalize(output));\n-                }\n-                newGroupingSets.add(newGroupingSet.build());\n-            }\n+            return new PlanAndMappings(rewrittenAggregation, mapper.getMapping());\n+        }\n+\n+        @Override\n+        public PlanAndMappings visitGroupId(GroupIdNode node, UnaliasContext context)\n+        {\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            return new GroupIdNode(node.getId(), source, newGroupingSets.build(), newGroupingMappings, canonicalizeAndDistinct(node.getAggregationArguments()), canonicalize(node.getGroupIdSymbol()));\n+            GroupIdNode rewrittenGroupId = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenGroupId, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitExplainAnalyze(ExplainAnalyzeNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitExplainAnalyze(ExplainAnalyzeNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            return new ExplainAnalyzeNode(node.getId(), source, canonicalize(node.getOutputSymbol()), node.isVerbose());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Symbol newOutputSymbol = mapper.map(node.getOutputSymbol());\n+\n+            return new PlanAndMappings(\n+                    new ExplainAnalyzeNode(node.getId(), rewrittenSource.getRoot(), newOutputSymbol, node.isVerbose()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitMarkDistinct(MarkDistinctNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitMarkDistinct(MarkDistinctNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            List<Symbol> symbols = canonicalizeAndDistinct(node.getDistinctSymbols());\n-            return new MarkDistinctNode(node.getId(), source, canonicalize(node.getMarkerSymbol()), symbols, canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Symbol newMarkerSymbol = mapper.map(node.getMarkerSymbol());\n+            List<Symbol> newDistinctSymbols = mapper.mapAndDistinct(node.getDistinctSymbols());\n+            Optional<Symbol> newHashSymbol = node.getHashSymbol().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new MarkDistinctNode(\n+                            node.getId(),\n+                            rewrittenSource.getRoot(),\n+                            newMarkerSymbol,\n+                            newDistinctSymbols,\n+                            newHashSymbol),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitUnnest(UnnestNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitUnnest(UnnestNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            ImmutableList.Builder<UnnestNode.Mapping> mappings = ImmutableList.builder();\n+            List<Symbol> newReplicateSymbols = mapper.mapAndDistinct(node.getReplicateSymbols());\n \n-            for (UnnestNode.Mapping mapping : node.getMappings()) {\n-                mappings.add(new UnnestNode.Mapping(canonicalize(mapping.getInput()), mapping.getOutputs()));\n+            ImmutableList.Builder<UnnestNode.Mapping> newMappings = ImmutableList.builder();\n+            for (UnnestNode.Mapping unnestMapping : node.getMappings()) {\n+                newMappings.add(new UnnestNode.Mapping(mapper.map(unnestMapping.getInput()), mapper.map(unnestMapping.getOutputs())));\n             }\n \n-            return new UnnestNode(\n-                    node.getId(),\n-                    source,\n-                    canonicalizeAndDistinct(node.getReplicateSymbols()),\n-                    mappings.build(),\n-                    node.getOrdinalitySymbol(),\n-                    node.getJoinType(),\n-                    node.getFilter().map(this::canonicalize));\n+            Optional<Symbol> newOrdinalitySymbol = node.getOrdinalitySymbol().map(mapper::map);\n+            Optional<Expression> newFilter = node.getFilter().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new UnnestNode(\n+                            node.getId(),\n+                            rewrittenSource.getRoot(),\n+                            newReplicateSymbols,\n+                            newMappings.build(),\n+                            newOrdinalitySymbol,\n+                            node.getJoinType(),\n+                            newFilter),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitWindow(WindowNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitWindow(WindowNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-\n-            ImmutableMap.Builder<Symbol, WindowNode.Function> functions = ImmutableMap.builder();\n-            node.getWindowFunctions().forEach((symbol, function) -> {\n-                ResolvedFunction resolvedFunction = function.getResolvedFunction();\n-                List<Expression> arguments = canonicalize(function.getArguments());\n-                WindowNode.Frame canonicalFrame = canonicalize(function.getFrame());\n-\n-                functions.put(canonicalize(symbol), new WindowNode.Function(resolvedFunction, arguments, canonicalFrame, function.isIgnoreNulls()));\n-            });\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            return new WindowNode(\n-                    node.getId(),\n-                    source,\n-                    canonicalizeAndDistinct(node.getSpecification()),\n-                    functions.build(),\n-                    canonicalize(node.getHashSymbol()),\n-                    canonicalize(node.getPrePartitionedInputs()),\n-                    node.getPreSortedOrderPrefix());\n-        }\n+            WindowNode rewrittenWindow = mapper.map(node, rewrittenSource.getRoot());\n \n-        private WindowNode.Frame canonicalize(WindowNode.Frame frame)\n-        {\n-            return new WindowNode.Frame(\n-                    frame.getType(),\n-                    frame.getStartType(),\n-                    canonicalize(frame.getStartValue()),\n-                    frame.getEndType(),\n-                    canonicalize(frame.getEndValue()),\n-                    frame.getOriginalStartValue(),\n-                    frame.getOriginalEndValue());\n+            return new PlanAndMappings(rewrittenWindow, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTableScan(TableScanNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableScan(TableScanNode node, UnaliasContext context)\n         {\n-            return node;\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            List<Symbol> newOutputs = mapper.map(node.getOutputSymbols());\n+\n+            Map<Symbol, ColumnHandle> newAssignments = new HashMap<>();\n+            node.getAssignments().forEach((symbol, handle) -> {\n+                newAssignments.put(mapper.map(symbol), handle);\n+            });\n+\n+            return new PlanAndMappings(\n+                    new TableScanNode(node.getId(), node.getTable(), newOutputs, newAssignments, node.getEnforcedConstraint()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitExchange(ExchangeNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitExchange(ExchangeNode node, UnaliasContext context)\n         {\n-            List<PlanNode> sources = node.getSources().stream()\n-                    .map(context::rewrite)\n-                    .collect(toImmutableList());\n-\n-            mapExchangeNodeSymbols(node);\n-\n-            List<List<Symbol>> inputs = new ArrayList<>();\n-            for (int i = 0; i < node.getInputs().size(); i++) {\n-                inputs.add(new ArrayList<>());\n+            ImmutableList.Builder<PlanNode> rewrittenChildren = ImmutableList.builder();\n+            ImmutableList.Builder<List<Symbol>> rewrittenInputsBuilder = ImmutableList.builder();\n+\n+            // rewrite child and map corresponding input list accordingly to the child's mapping\n+            for (int i = 0; i < node.getSources().size(); i++) {\n+                PlanAndMappings rewrittenChild = node.getSources().get(i).accept(this, context);\n+                rewrittenChildren.add(rewrittenChild.getRoot());\n+                SymbolMapper mapper = new SymbolMapper(rewrittenChild.getSymbolMappings());\n+                rewrittenInputsBuilder.add(mapper.map(node.getInputs().get(i)));\n             }\n-            Set<Symbol> addedOutputs = new HashSet<>();\n-            ImmutableList.Builder<Symbol> outputs = ImmutableList.builder();\n-            for (int symbolIndex = 0; symbolIndex < node.getOutputSymbols().size(); symbolIndex++) {\n-                Symbol canonicalOutput = canonicalize(node.getOutputSymbols().get(symbolIndex));\n-                if (addedOutputs.add(canonicalOutput)) {\n-                    outputs.add(canonicalOutput);\n-                    for (int i = 0; i < node.getInputs().size(); i++) {\n-                        List<Symbol> input = node.getInputs().get(i);\n-                        inputs.get(i).add(canonicalize(input.get(symbolIndex)));\n-                    }\n+            List<List<Symbol>> rewrittenInputs = rewrittenInputsBuilder.build();\n+\n+            // canonicalize ExchangeNode outputs\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+            List<Symbol> rewrittenOutputs = mapper.map(node.getOutputSymbols());\n+\n+            // sanity check: assert that duplicate outputs result from same inputs\n+            Map<Symbol, List<Symbol>> outputsToInputs = new HashMap<>();\n+            for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                ImmutableList.Builder<Symbol> inputsBuilder = ImmutableList.builder();\n+                for (List<Symbol> inputs : rewrittenInputs) {\n+                    inputsBuilder.add(inputs.get(i));\n                 }\n+                List<Symbol> inputs = inputsBuilder.build();\n+                List<Symbol> previous = outputsToInputs.put(rewrittenOutputs.get(i), inputs);\n+                checkState(previous == null || inputs.equals(previous), \"different inputs mapped to the same output symbol\");\n             }\n \n-            PartitioningScheme partitioningScheme = new PartitioningScheme(\n-                    node.getPartitioningScheme().getPartitioning().translate(this::canonicalize),\n-                    outputs.build(),\n-                    canonicalize(node.getPartitioningScheme().getHashColumn()),\n-                    node.getPartitioningScheme().isReplicateNullsAndAny(),\n-                    node.getPartitioningScheme().getBucketToPartition());\n-\n-            Optional<OrderingScheme> orderingScheme = node.getOrderingScheme().map(this::canonicalizeAndDistinct);\n+            // derive new mappings for ExchangeNode output symbols\n+            Map<Symbol, Symbol> newMapping = new HashMap<>();\n \n-            return new ExchangeNode(node.getId(), node.getType(), node.getScope(), partitioningScheme, sources, inputs, orderingScheme);\n-        }\n-\n-        private void mapExchangeNodeSymbols(ExchangeNode node)\n-        {\n-            if (node.getInputs().size() == 1) {\n-                mapExchangeNodeOutputToInputSymbols(node);\n-                return;\n+            // 1. for a single ExchangeNode source, map outputs to inputs\n+            if (rewrittenInputs.size() == 1) {\n+                for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                    Symbol output = rewrittenOutputs.get(i);\n+                    Symbol input = rewrittenInputs.get(0).get(i);\n+                    if (!output.equals(input)) {\n+                        newMapping.put(output, input);\n+                    }\n+                }\n             }\n \n-            // Mapping from list [node.getInput(0).get(symbolIndex), node.getInput(1).get(symbolIndex), ...] to node.getOutputSymbols(symbolIndex).\n-            // All symbols are canonical.\n+            // 2. for multiple ExchangeNode sources, if different output symbols result from the same lists of canonical input symbols, map all those outputs to the same symbol\n             Map<List<Symbol>, Symbol> inputsToOutputs = new HashMap<>();\n-            // Map each same list of input symbols [I1, I2, ..., In] to the same output symbol O\n-            for (int symbolIndex = 0; symbolIndex < node.getOutputSymbols().size(); symbolIndex++) {\n-                Symbol canonicalOutput = canonicalize(node.getOutputSymbols().get(symbolIndex));\n-                List<Symbol> canonicalInputs = canonicalizeExchangeNodeInputs(node, symbolIndex);\n-                Symbol output = inputsToOutputs.get(canonicalInputs);\n-\n-                if (output == null || canonicalOutput.equals(output)) {\n-                    inputsToOutputs.put(canonicalInputs, canonicalOutput);\n+            for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                ImmutableList.Builder<Symbol> inputsBuilder = ImmutableList.builder();\n+                for (List<Symbol> inputs : rewrittenInputs) {\n+                    inputsBuilder.add(inputs.get(i));\n+                }\n+                List<Symbol> inputs = inputsBuilder.build();\n+                Symbol previous = inputsToOutputs.get(inputs);\n+                if (previous == null || rewrittenOutputs.get(i).equals(previous)) {\n+                    inputsToOutputs.put(inputs, rewrittenOutputs.get(i));\n                 }\n                 else {\n-                    map(canonicalOutput, output);\n+                    newMapping.put(rewrittenOutputs.get(i), previous);\n                 }\n             }\n-        }\n \n-        private void mapExchangeNodeOutputToInputSymbols(ExchangeNode node)\n-        {\n-            checkState(node.getInputs().size() == 1);\n+            Map<Symbol, Symbol> outputMapping = new HashMap<>();\n+            outputMapping.putAll(mapper.getMapping());\n+            outputMapping.putAll(newMapping);\n \n-            for (int symbolIndex = 0; symbolIndex < node.getOutputSymbols().size(); symbolIndex++) {\n-                Symbol canonicalOutput = canonicalize(node.getOutputSymbols().get(symbolIndex));\n-                Symbol canonicalInput = canonicalize(node.getInputs().get(0).get(symbolIndex));\n+            mapper = new SymbolMapper(outputMapping);\n \n-                if (!canonicalOutput.equals(canonicalInput)) {\n-                    map(canonicalOutput, canonicalInput);\n+            // deduplicate outputs and prune input symbols lists accordingly\n+            List<List<Symbol>> newInputs = new ArrayList<>();\n+            for (int i = 0; i < node.getInputs().size(); i++) {\n+                newInputs.add(new ArrayList<>());\n+            }\n+            ImmutableList.Builder<Symbol> newOutputs = ImmutableList.builder();\n+            Set<Symbol> addedOutputs = new HashSet<>();\n+            for (int i = 0; i < rewrittenOutputs.size(); i++) {\n+                Symbol output = mapper.map(rewrittenOutputs.get(i));\n+                if (addedOutputs.add(output)) {\n+                    newOutputs.add(output);\n+                    for (int j = 0; j < rewrittenInputs.size(); j++) {\n+                        newInputs.get(j).add(rewrittenInputs.get(j).get(i));\n+                    }\n                 }\n             }\n-        }\n \n-        private List<Symbol> canonicalizeExchangeNodeInputs(ExchangeNode node, int symbolIndex)\n-        {\n-            return node.getInputs().stream()\n-                    .map(input -> canonicalize(input.get(symbolIndex)))\n-                    .collect(toImmutableList());\n+            // rewrite PartitioningScheme\n+            PartitioningScheme newPartitioningScheme = mapper.map(node.getPartitioningScheme(), newOutputs.build());\n+\n+            // rewrite OrderingScheme\n+            Optional<OrderingScheme> newOrderingScheme = node.getOrderingScheme().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new ExchangeNode(\n+                            node.getId(),\n+                            node.getType(),\n+                            node.getScope(),\n+                            newPartitioningScheme,\n+                            rewrittenChildren.build(),\n+                            newInputs,\n+                            newOrderingScheme),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitRemoteSource(RemoteSourceNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitRemoteSource(RemoteSourceNode node, UnaliasContext context)\n         {\n-            return new RemoteSourceNode(\n-                    node.getId(),\n-                    node.getSourceFragmentIds(),\n-                    canonicalizeAndDistinct(node.getOutputSymbols()),\n-                    node.getOrderingScheme().map(this::canonicalizeAndDistinct),\n-                    node.getExchangeType());\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            List<Symbol> newOutputs = mapper.mapAndDistinct(node.getOutputSymbols());\n+            Optional<OrderingScheme> newOrderingScheme = node.getOrderingScheme().map(mapper::map);\n+\n+            return new PlanAndMappings(\n+                    new RemoteSourceNode(\n+                            node.getId(),\n+                            node.getSourceFragmentIds(),\n+                            newOutputs,\n+                            newOrderingScheme,\n+                            node.getExchangeType()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitOffset(OffsetNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitOffset(OffsetNode node, UnaliasContext context)\n         {\n-            return context.defaultRewrite(node);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+\n+            return new PlanAndMappings(\n+                    node.replaceChildren(ImmutableList.of(rewrittenSource.getRoot())),\n+                    rewrittenSource.getSymbolMappings());\n         }\n \n         @Override\n-        public PlanNode visitLimit(LimitNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitLimit(LimitNode node, UnaliasContext context)\n         {\n-            if (node.isWithTies()) {\n-                PlanNode source = context.rewrite(node.getSource());\n-                return new LimitNode(node.getId(), source, node.getCount(), node.getTiesResolvingScheme().map(this::canonicalizeAndDistinct), node.isPartial());\n-            }\n-            return context.defaultRewrite(node);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            LimitNode rewrittenLimit = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenLimit, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitDistinctLimit(DistinctLimitNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitDistinctLimit(DistinctLimitNode node, UnaliasContext context)\n         {\n-            return new DistinctLimitNode(node.getId(), context.rewrite(node.getSource()), node.getLimit(), node.isPartial(), canonicalizeAndDistinct(node.getDistinctSymbols()), canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            DistinctLimitNode rewrittenDistinctLimit = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenDistinctLimit, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitSample(SampleNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitSample(SampleNode node, UnaliasContext context)\n         {\n-            return new SampleNode(node.getId(), context.rewrite(node.getSource()), node.getSampleRatio(), node.getSampleType());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+\n+            return new PlanAndMappings(\n+                    node.replaceChildren(ImmutableList.of(rewrittenSource.getRoot())),\n+                    rewrittenSource.getSymbolMappings());\n         }\n \n         @Override\n-        public PlanNode visitValues(ValuesNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitValues(ValuesNode node, UnaliasContext context)\n         {\n-            List<List<Expression>> canonicalizedRows = node.getRows().stream()\n-                    .map(this::canonicalize)\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            List<List<Expression>> newRows = node.getRows().stream()\n+                    .map(row -> row.stream()\n+                            .map(mapper::map)\n+                            .collect(toImmutableList()))\n                     .collect(toImmutableList());\n-            List<Symbol> canonicalizedOutputSymbols = canonicalizeAndDistinct(node.getOutputSymbols());\n-            checkState(node.getOutputSymbols().size() == canonicalizedOutputSymbols.size(), \"Values output symbols were pruned\");\n-            return new ValuesNode(\n-                    node.getId(),\n-                    canonicalizedOutputSymbols,\n-                    canonicalizedRows);\n+\n+            List<Symbol> newOutputSymbols = mapper.mapAndDistinct(node.getOutputSymbols());\n+            checkState(node.getOutputSymbols().size() == newOutputSymbols.size(), \"Values output symbols were pruned\");\n+\n+            return new PlanAndMappings(\n+                    new ValuesNode(node.getId(), newOutputSymbols, newRows),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTableDelete(TableDeleteNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableDelete(TableDeleteNode node, UnaliasContext context)\n         {\n-            return node;\n+            SymbolMapper mapper = new SymbolMapper(context.getCorrelationMapping());\n+\n+            Symbol newOutput = mapper.map(node.getOutput());\n+\n+            return new PlanAndMappings(\n+                    new TableDeleteNode(node.getId(), node.getTarget(), newOutput),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitDelete(DeleteNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitDelete(DeleteNode node, UnaliasContext context)\n         {\n-            return new DeleteNode(node.getId(), context.rewrite(node.getSource()), node.getTarget(), canonicalize(node.getRowId()), node.getOutputSymbols());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Symbol newRowId = mapper.map(node.getRowId());\n+            List<Symbol> newOutputs = mapper.map(node.getOutputSymbols());\n+\n+            return new PlanAndMappings(\n+                    new DeleteNode(\n+                            node.getId(),\n+                            rewrittenSource.getRoot(),\n+                            node.getTarget(),\n+                            newRowId,\n+                            newOutputs),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitStatisticsWriterNode(StatisticsWriterNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitStatisticsWriterNode(StatisticsWriterNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            StatisticsWriterNode rewrittenStatisticsWriter = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenStatisticsWriter, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTableFinish(TableFinishNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableWriter(TableWriterNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            TableWriterNode rewrittenTableWriter = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTableWriter, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitRowNumber(RowNumberNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTableFinish(TableFinishNode node, UnaliasContext context)\n         {\n-            return new RowNumberNode(\n-                    node.getId(),\n-                    context.rewrite(node.getSource()),\n-                    canonicalizeAndDistinct(node.getPartitionBy()),\n-                    node.isOrderSensitive(),\n-                    canonicalize(node.getRowNumberSymbol()),\n-                    node.getMaxRowCountPerPartition(),\n-                    canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            TableFinishNode rewrittenTableFinish = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTableFinish, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitTopNRowNumber(TopNRowNumberNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitRowNumber(RowNumberNode node, UnaliasContext context)\n         {\n-            return new TopNRowNumberNode(\n-                    node.getId(),\n-                    context.rewrite(node.getSource()),\n-                    canonicalizeAndDistinct(node.getSpecification()),\n-                    canonicalize(node.getRowNumberSymbol()),\n-                    node.getMaxRowCountPerPartition(),\n-                    node.isPartial(),\n-                    canonicalize(node.getHashSymbol()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            RowNumberNode rewrittenRowNumber = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenRowNumber, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitFilter(FilterNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTopNRowNumber(TopNRowNumberNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            return new FilterNode(node.getId(), source, canonicalize(node.getPredicate()));\n+            TopNRowNumberNode rewrittenTopNRowNumber = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTopNRowNumber, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitProject(ProjectNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitTopN(TopNNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n-            return new ProjectNode(node.getId(), source, canonicalize(node.getAssignments()));\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            TopNNode rewrittenTopN = mapper.map(node, rewrittenSource.getRoot());\n+\n+            return new PlanAndMappings(rewrittenTopN, mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitOutput(OutputNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitSort(SortNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            List<Symbol> canonical = Lists.transform(node.getOutputSymbols(), this::canonicalize);\n-            return new OutputNode(node.getId(), source, node.getColumnNames(), canonical);\n+            OrderingScheme newOrderingScheme = mapper.map(node.getOrderingScheme());\n+\n+            return new PlanAndMappings(\n+                    new SortNode(node.getId(), rewrittenSource.getRoot(), newOrderingScheme, node.isPartial()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitEnforceSingleRow(EnforceSingleRowNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitFilter(FilterNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Expression newPredicate = mapper.map(node.getPredicate());\n \n-            return new EnforceSingleRowNode(node.getId(), source);\n+            return new PlanAndMappings(\n+                    new FilterNode(node.getId(), rewrittenSource.getRoot(), newPredicate),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitAssignUniqueId(AssignUniqueId node, RewriteContext<Void> context)\n+        public PlanAndMappings visitProject(ProjectNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            // canonicalize ProjectNode assignments\n+            ImmutableList.Builder<Map.Entry<Symbol, Expression>> builder = ImmutableList.builder();\n+            for (Map.Entry<Symbol, Expression> assignment : node.getAssignments().entrySet()) {\n+                builder.add(new SimpleEntry<>(mapper.map(assignment.getKey()), mapper.map(assignment.getValue())));\n+            }\n+            List<Map.Entry<Symbol, Expression>> rewrittenAssignments = builder.build();\n \n-            return new AssignUniqueId(node.getId(), source, node.getIdColumn());\n+            // deduplicate assignments\n+            Map<Symbol, Expression> deduplicateAssignments = new HashMap<>();\n+            for (Map.Entry<Symbol, Expression> assignment : rewrittenAssignments) {\n+                Expression previous = deduplicateAssignments.put(assignment.getKey(), assignment.getValue());\n+                checkState(previous == null || assignment.getValue().equals(previous), \"different expressions projected to the same symbol\");\n+            }\n+\n+            // derive new mappings for ProjectNode output symbols\n+            Map<Symbol, Symbol> newMapping = new HashMap<>();\n+            Map<Expression, Symbol> inputsToOutputs = new HashMap<>();\n+            for (Map.Entry<Symbol, Expression> assignment : deduplicateAssignments.entrySet()) {\n+                Expression expression = assignment.getValue();\n+                // 1. for trivial symbol projection, map output symbol to input symbol\n+                if (expression instanceof SymbolReference) {\n+                    Symbol value = Symbol.from(expression);\n+                    if (!assignment.getKey().equals(value)) {\n+                        newMapping.put(assignment.getKey(), value);\n+                    }\n+                }\n+                // 2. map same deterministic expressions within a projection into the same symbol\n+                // omit NullLiterals since those have ambiguous types\n+                else if (DeterminismEvaluator.isDeterministic(expression, metadata) && !(expression instanceof NullLiteral)) {\n+                    Symbol previous = inputsToOutputs.get(expression);\n+                    if (previous == null || assignment.getKey().equals(previous)) {\n+                        inputsToOutputs.put(expression, assignment.getKey());\n+                    }\n+                    else {\n+                        newMapping.put(assignment.getKey(), previous);\n+                    }\n+                }\n+            }\n+\n+            Map<Symbol, Symbol> outputMapping = new HashMap<>();\n+            outputMapping.putAll(mapper.getMapping());\n+            outputMapping.putAll(newMapping);\n+\n+            mapper = new SymbolMapper(outputMapping);\n+\n+            // build new Assignments with canonical outputs\n+            // duplicate entries will be removed by the Builder\n+            Assignments.Builder newAssignments = Assignments.builder();\n+            for (Map.Entry<Symbol, Expression> assignment : deduplicateAssignments.entrySet()) {\n+                newAssignments.put(mapper.map(assignment.getKey()), assignment.getValue());\n+            }\n+\n+            return new PlanAndMappings(\n+                    new ProjectNode(node.getId(), rewrittenSource.getRoot(), newAssignments.build()),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitApply(ApplyNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitOutput(OutputNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getInput());\n-            PlanNode subquery = context.rewrite(node.getSubquery());\n-            List<Symbol> canonicalCorrelation = Lists.transform(node.getCorrelation(), this::canonicalize);\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n \n-            return new ApplyNode(node.getId(), source, subquery, canonicalize(node.getSubqueryAssignments()), canonicalCorrelation, node.getOriginSubquery());\n+            List<Symbol> newOutputs = mapper.map(node.getOutputSymbols());\n+\n+            return new PlanAndMappings(\n+                    new OutputNode(node.getId(), rewrittenSource.getRoot(), node.getColumnNames(), newOutputs),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitCorrelatedJoin(CorrelatedJoinNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitEnforceSingleRow(EnforceSingleRowNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getInput());\n-            PlanNode subquery = context.rewrite(node.getSubquery());\n-            List<Symbol> canonicalCorrelation = canonicalizeAndDistinct(node.getCorrelation());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n \n-            return new CorrelatedJoinNode(node.getId(), source, subquery, canonicalCorrelation, node.getType(), canonicalize(node.getFilter()), node.getOriginSubquery());\n+            return new PlanAndMappings(\n+                    node.replaceChildren(ImmutableList.of(rewrittenSource.getRoot())),\n+                    rewrittenSource.getSymbolMappings());\n         }\n \n         @Override\n-        public PlanNode visitTopN(TopNNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitAssignUniqueId(AssignUniqueId node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            PlanAndMappings rewrittenSource = node.getSource().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenSource.getSymbolMappings());\n+\n+            Symbol newUnique = mapper.map(node.getIdColumn());\n \n-            SymbolMapper mapper = new SymbolMapper(mapping);\n-            return mapper.map(node, source, node.getId());\n+            return new PlanAndMappings(\n+                    new AssignUniqueId(node.getId(), rewrittenSource.getRoot(), newUnique),\n+                    mapper.getMapping());\n         }\n \n         @Override\n-        public PlanNode visitSort(SortNode node, RewriteContext<Void> context)\n+        public PlanAndMappings visitApply(ApplyNode node, UnaliasContext context)\n         {\n-            PlanNode source = context.rewrite(node.getSource());\n+            // it is assumed that apart from correlation (and possibly outer correlation), symbols are distinct between Input and Subquery\n+            // rewrite Input\n+            PlanAndMappings rewrittenInput = node.getInput().accept(this, context);\n+            SymbolMapper mapper = new SymbolMapper(rewrittenInput.getSymbolMappings());\n+\n+            // rewrite correlation with mapping from Input\n+            List<Symbol> rewrittenCorrelation = mapper.mapAndDistinct(node.getCorrelation());\n+\n+            // extract new mappings for correlation symbols to apply in Subquery\n+            Set<Symbol> correlationSymbols = ImmutableSet.copyOf(node.getCorrelation());\n+            Map<Symbol, Symbol> correlationMapping = mapper.getMapping().entrySet().stream()\n+                    .filter(mapping -> correlationSymbols.contains(mapping.getKey()))\n+                    .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+            Map<Symbol, Symbol> mappingForSubquery = new HashMap<>();\n+            mappingForSubquery.putAll(context.getCorrelationMapping());\n+            mappingForSubquery.putAll(correlationMapping);\n+\n+            // rewrite Subquery\n+            PlanAndMappings rewrittenSubquery = node.getSubquery().accept(this, new UnaliasContext(mappingForSubquery));\n+\n+            // unify mappings from Input and Subquery to rewrite Subquery assignments\n+            Map<Symbol, Symbol> resultMapping = new HashMap<>();\n+            resultMapping.putAll(rewrittenInput.getSymbolMappings());\n+            resultMapping.putAll(rewrittenSubquery.getSymbolMappings());\n+            mapper = new SymbolMapper(resultMapping);\n+\n+            ImmutableList.Builder<Map.Entry<Symbol, Expression>> builder = ImmutableList.builder();\n+            for (Map.Entry<Symbol, Expression> assignment : node.getSubqueryAssignments().entrySet()) {\n+                builder.add(new SimpleEntry<>(mapper.map(assignment.getKey()), mapper.map(assignment.getValue())));\n+            }\n+            List<Map.Entry<Symbol, Expression>> rewrittenAssignments = builder.build();\n \n-            return new SortNode(node.getId(), source, canonicalizeAndDistinct(node.getOrderingScheme()), node.isPartial());\n+            // deduplicate assignments\n+            Map<Symbol, Expression> deduplicateAssignments = new HashMap<>();\n+            for (Map.Entry<Symbol, Expression> assignment : rewrittenAssignments) {\n+                Expression previous = deduplicateAssignments.put(assignment.getKey(), assignment.getValue());\n+                checkState(previous == null || assignment.getValue().equals(previous), \"different expressions assigned to the same symbol\");\n+            }\n+\n+            // derive new mappings for Subquery assignments outputs\n+            Map<Expression, Symbol> inputsToOutputs = new HashMap<>();\n+            Map<Symbol, Symbol> newMapping = new HashMap<>();\n+            for (Map.Entry<Symbol, Expression> assignment : deduplicateAssignments.entrySet()) {\n+                Expression expression = assignment.getValue();\n+                // 1. for trivial symbol projection, map output symbol to input symbol\n+                if (expression instanceof SymbolReference) {\n+                    Symbol value = Symbol.from(expression);\n+                    if (!assignment.getKey().equals(value)) {\n+                        newMapping.put(assignment.getKey(), value);\n+                    }\n+                }\n+                // 2. map same deterministic expressions within a projection into the same symbol\n+                // omit NullLiterals since those have ambiguous types\n+                else if (DeterminismEvaluator.isDeterministic(expression, metadata) && !(expression instanceof NullLiteral)) {\n+                    Symbol previous = inputsToOutputs.get(expression);\n+                    if (previous == null || assignment.getKey().equals(previous)) {\n+                        inputsToOutputs.put(expression, assignment.getKey());\n+                    }\n+                    else {\n+                        newMapping.put(assignment.getKey(), previous);\n+                    }\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 897}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd743d0f9c84c11996b31a5d100ff6f4bd74f5c0", "author": {"user": {"login": "kasiafi", "name": null}}, "url": "https://github.com/trinodb/trino/commit/bd743d0f9c84c11996b31a5d100ff6f4bd74f5c0", "committedDate": "2020-06-30T12:11:21Z", "message": "Rename parameter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7113a6bf55eedfb7ff0ad33cdf07ca604eb8844", "author": {"user": {"login": "kasiafi", "name": null}}, "url": "https://github.com/trinodb/trino/commit/d7113a6bf55eedfb7ff0ad33cdf07ca604eb8844", "committedDate": "2020-06-30T12:16:33Z", "message": "Restructure method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "222a8c8a248740787cafaf56be9a17f15f94adcd", "author": {"user": {"login": "kasiafi", "name": null}}, "url": "https://github.com/trinodb/trino/commit/222a8c8a248740787cafaf56be9a17f15f94adcd", "committedDate": "2020-06-30T12:20:14Z", "message": "Reorder Builder methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d496808ec08c5a4bb229a285d81a2a0db4a8e75c", "author": {"user": {"login": "kasiafi", "name": null}}, "url": "https://github.com/trinodb/trino/commit/d496808ec08c5a4bb229a285d81a2a0db4a8e75c", "committedDate": "2020-06-30T12:58:30Z", "message": "Pass PlanNodeId instead of IdAllocator when mapping AggregationNode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f9f7aa70fbbd23c8ce7256ccca676085dcb1c78", "author": {"user": {"login": "kasiafi", "name": null}}, "url": "https://github.com/trinodb/trino/commit/8f9f7aa70fbbd23c8ce7256ccca676085dcb1c78", "committedDate": "2020-06-30T14:17:05Z", "message": "Refactor UnaliasSymbolReferences and SymbolMapper\n\nIn UnaliasSymbolReferences:\nIntroduce context, including inherited mapping for correlation symbols.\nIntroduce return type for visit() methods, including:\n    - rewritten plan,\n    - symbol mappings (both inherited and derived).\n\nPreviously, there was global symbol mapping that changed each time\nwhen new symbol mapping was defined. Hence, once a mapping for a symbol\nwas defined, it was applied to all occurrences of the symbol that\nwere encountered later.\nThis approach caused errors in case of reused (duplicate) symbols\nin different branches of the plan.\n\nSymbol mapping is now performed only by SymbolMapper.\nPreviously, some mapping methods were defined in\nUnaliasSymbolReferences and some code was copied between\nUnalias and SymbolMapper."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "8f9f7aa70fbbd23c8ce7256ccca676085dcb1c78", "author": {"user": {"login": "kasiafi", "name": null}}, "url": "https://github.com/trinodb/trino/commit/8f9f7aa70fbbd23c8ce7256ccca676085dcb1c78", "committedDate": "2020-06-30T14:17:05Z", "message": "Refactor UnaliasSymbolReferences and SymbolMapper\n\nIn UnaliasSymbolReferences:\nIntroduce context, including inherited mapping for correlation symbols.\nIntroduce return type for visit() methods, including:\n    - rewritten plan,\n    - symbol mappings (both inherited and derived).\n\nPreviously, there was global symbol mapping that changed each time\nwhen new symbol mapping was defined. Hence, once a mapping for a symbol\nwas defined, it was applied to all occurrences of the symbol that\nwere encountered later.\nThis approach caused errors in case of reused (duplicate) symbols\nin different branches of the plan.\n\nSymbol mapping is now performed only by SymbolMapper.\nPreviously, some mapping methods were defined in\nUnaliasSymbolReferences and some code was copied between\nUnalias and SymbolMapper."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 378, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}