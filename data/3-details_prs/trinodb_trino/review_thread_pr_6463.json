{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ2NTM0NjM4", "number": 6463, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwMDo1OTo0M1rOFMWZFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQyMToxNjoxNVrOFMq7kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NDk0MTAxOnYy", "diffSide": "RIGHT", "path": "core/trino-main/src/main/java/io/trino/execution/SqlTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwMDo1OTo0M1rOIQB_FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQyMDo1MzozOFrOIQgzkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY4MDY2MA==", "bodyText": "Why \"snapshot\" in the name? TaskState is an enum with no mutable or complex state, so the notion of a snapshot is awkward. I would just rename it to getTaskState.", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r553680660", "createdAt": "2021-01-08T00:59:43Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/execution/SqlTask.java", "diffHunk": "@@ -203,6 +203,16 @@ public SqlTaskIoStats getIoStats()\n         return taskHolderReference.get().getIoStats();\n     }\n \n+    public TaskState getTaskStateSnapshot()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE4NTYxOQ==", "bodyText": "Since other places in the code were so careful about the progression of task status I thought it might be merited, but if you don't think so I'll just rename.", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r554185619", "createdAt": "2021-01-08T20:53:38Z", "author": {"login": "pettyjamesm"}, "path": "core/trino-main/src/main/java/io/trino/execution/SqlTask.java", "diffHunk": "@@ -203,6 +203,16 @@ public SqlTaskIoStats getIoStats()\n         return taskHolderReference.get().getIoStats();\n     }\n \n+    public TaskState getTaskStateSnapshot()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY4MDY2MA=="}, "originalCommit": null, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NDk0NTY3OnYy", "diffSide": "RIGHT", "path": "core/trino-main/src/main/java/io/trino/execution/MemoryRevokingScheduler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwMTowMjowN1rOIQCB7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQyMDo1NzoyOFrOIQg6sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY4MTM5MA==", "bodyText": "The renaming of this local variable seems unrelated to the main purpose of this commit. Pull it out into a separate commit.", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r553681390", "createdAt": "2021-01-08T01:02:07Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/execution/MemoryRevokingScheduler.java", "diffHunk": "@@ -187,26 +189,29 @@ private void scheduleRevoking()\n     private synchronized void runMemoryRevoking()\n     {\n         if (checkPending.getAndSet(false)) {\n-            Collection<SqlTask> sqlTasks = null;\n+            Collection<SqlTask> allTasks = null;\n             for (MemoryPool memoryPool : memoryPools) {\n                 if (!memoryRevokingNeeded(memoryPool)) {\n                     continue;\n                 }\n \n-                if (sqlTasks == null) {\n-                    sqlTasks = requireNonNull(currentTasksSupplier.get());\n+                if (allTasks == null) {\n+                    allTasks = requireNonNull(currentTasksSupplier.get());\n                 }\n \n-                requestMemoryRevoking(memoryPool, sqlTasks);\n+                requestMemoryRevoking(memoryPool, allTasks);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE4NzQ0MA==", "bodyText": "I thought it helped clarify the transformation state now that we don't re-traverse the tasks at once. allTasks has not been filtered until findRunningTasksInMemoryPool does the filter and sorting at which point you wouldn't want to accidentally traverse allTasks instead of runningTasksInMemoryPool. Granted, I also changed the type signatures to make that harder to do by accident but it did feel related to the refactor.", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r554187440", "createdAt": "2021-01-08T20:57:28Z", "author": {"login": "pettyjamesm"}, "path": "core/trino-main/src/main/java/io/trino/execution/MemoryRevokingScheduler.java", "diffHunk": "@@ -187,26 +189,29 @@ private void scheduleRevoking()\n     private synchronized void runMemoryRevoking()\n     {\n         if (checkPending.getAndSet(false)) {\n-            Collection<SqlTask> sqlTasks = null;\n+            Collection<SqlTask> allTasks = null;\n             for (MemoryPool memoryPool : memoryPools) {\n                 if (!memoryRevokingNeeded(memoryPool)) {\n                     continue;\n                 }\n \n-                if (sqlTasks == null) {\n-                    sqlTasks = requireNonNull(currentTasksSupplier.get());\n+                if (allTasks == null) {\n+                    allTasks = requireNonNull(currentTasksSupplier.get());\n                 }\n \n-                requestMemoryRevoking(memoryPool, sqlTasks);\n+                requestMemoryRevoking(memoryPool, allTasks);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY4MTM5MA=="}, "originalCommit": null, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4ODAzNDYyOnYy", "diffSide": "RIGHT", "path": "core/trino-main/src/main/java/io/trino/execution/SqlTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxOTo0MTozMFrOIQezsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQyMDo1Nzo0MlrOIQg7Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE1Mjg4Mg==", "bodyText": "Rename this to getTaskContext. The fact that it returns an Optional is indication enough that it will return one if present.", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r554152882", "createdAt": "2021-01-08T19:41:30Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/execution/SqlTask.java", "diffHunk": "@@ -578,4 +578,13 @@ public QueryContext getQueryContext()\n     {\n         return queryContext;\n     }\n+\n+    public Optional<TaskContext> getTaskContextIfPresent()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE4NzUyMg==", "bodyText": "Sure, works for me", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r554187522", "createdAt": "2021-01-08T20:57:42Z", "author": {"login": "pettyjamesm"}, "path": "core/trino-main/src/main/java/io/trino/execution/SqlTask.java", "diffHunk": "@@ -578,4 +578,13 @@ public QueryContext getQueryContext()\n     {\n         return queryContext;\n     }\n+\n+    public Optional<TaskContext> getTaskContextIfPresent()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE1Mjg4Mg=="}, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4ODA0MDM1OnYy", "diffSide": "RIGHT", "path": "core/trino-main/src/main/java/io/trino/execution/SqlTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxOTo0MzozMlrOIQe3Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQyMToxNzo0MlrOIQhawQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE1Mzc5MA==", "bodyText": "Alternatively,\n        return Optional.ofNullable(taskExecution)\n                .map(SqlTaskExecution::getTaskContext);", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r554153790", "createdAt": "2021-01-08T19:43:32Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/execution/SqlTask.java", "diffHunk": "@@ -578,4 +578,13 @@ public QueryContext getQueryContext()\n     {\n         return queryContext;\n     }\n+\n+    public Optional<TaskContext> getTaskContextIfPresent()\n+    {\n+        SqlTaskExecution taskExecution = taskHolderReference.get().getTaskExecution();\n+        if (taskExecution == null) {\n+            return Optional.empty();\n+        }\n+        return Optional.of(taskExecution.getTaskContext());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE5NTY0OQ==", "bodyText": "Could do and will do if you feel strongly. I'm a little uneasy with the contract that Optional#map uses in the presence of nulls so I typically avoid it when there are @Nullable annotations floating around in the vicinity. Also: micro-optimizations!", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r554195649", "createdAt": "2021-01-08T21:17:42Z", "author": {"login": "pettyjamesm"}, "path": "core/trino-main/src/main/java/io/trino/execution/SqlTask.java", "diffHunk": "@@ -578,4 +578,13 @@ public QueryContext getQueryContext()\n     {\n         return queryContext;\n     }\n+\n+    public Optional<TaskContext> getTaskContextIfPresent()\n+    {\n+        SqlTaskExecution taskExecution = taskHolderReference.get().getTaskExecution();\n+        if (taskExecution == null) {\n+            return Optional.empty();\n+        }\n+        return Optional.of(taskExecution.getTaskContext());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE1Mzc5MA=="}, "originalCommit": null, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4ODMwNjA5OnYy", "diffSide": "RIGHT", "path": "core/trino-main/src/main/java/io/trino/execution/MemoryRevokingScheduler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQyMToxNjoxNVrOIQhYYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQyMToyNzoyNlrOIQhqbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE5NTA0Mw==", "bodyText": "Just curious, is a negative value legitimate, or are you really protecting against calls when the value is zero?", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r554195043", "createdAt": "2021-01-08T21:16:15Z", "author": {"login": "dain"}, "path": "core/trino-main/src/main/java/io/trino/execution/MemoryRevokingScheduler.java", "diffHunk": "@@ -187,26 +189,29 @@ private void scheduleRevoking()\n     private synchronized void runMemoryRevoking()\n     {\n         if (checkPending.getAndSet(false)) {\n-            Collection<SqlTask> sqlTasks = null;\n+            Collection<SqlTask> allTasks = null;\n             for (MemoryPool memoryPool : memoryPools) {\n                 if (!memoryRevokingNeeded(memoryPool)) {\n                     continue;\n                 }\n \n-                if (sqlTasks == null) {\n-                    sqlTasks = requireNonNull(currentTasksSupplier.get());\n+                if (allTasks == null) {\n+                    allTasks = requireNonNull(currentTasksSupplier.get());\n                 }\n \n-                requestMemoryRevoking(memoryPool, sqlTasks);\n+                requestMemoryRevoking(memoryPool, allTasks);\n             }\n         }\n     }\n \n-    private void requestMemoryRevoking(MemoryPool memoryPool, Collection<SqlTask> sqlTasks)\n+    private void requestMemoryRevoking(MemoryPool memoryPool, Collection<SqlTask> allTasks)\n     {\n         long remainingBytesToRevoke = (long) (-memoryPool.getFreeBytes() + (memoryPool.getMaxBytes() * (1.0 - memoryRevokingTarget)));\n-        remainingBytesToRevoke -= getMemoryAlreadyBeingRevoked(sqlTasks, memoryPool);\n-        requestRevoking(memoryPool, sqlTasks, remainingBytesToRevoke);\n+        List<SqlTask> runningTasksInPool = findRunningTasksInMemoryPool(allTasks, memoryPool);\n+        remainingBytesToRevoke -= getMemoryAlreadyBeingRevoked(runningTasksInPool, remainingBytesToRevoke);\n+        if (remainingBytesToRevoke > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE5OTY2MQ==", "bodyText": "I think it's legitimate and it wouldn't necessarily cause problems to pass a negative here, this is just an early return without traversing the task tree if no revoking is going to occur. How this might happen:\n\nmemory revoking is triggered and initiates a bunch of memory revoking\nmore memory is allocated triggering another attempted revoking pass\nthe memory in the process of still being revoked is larger than the delta between the current pool's memory and the revoking target", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r554199661", "createdAt": "2021-01-08T21:27:26Z", "author": {"login": "pettyjamesm"}, "path": "core/trino-main/src/main/java/io/trino/execution/MemoryRevokingScheduler.java", "diffHunk": "@@ -187,26 +189,29 @@ private void scheduleRevoking()\n     private synchronized void runMemoryRevoking()\n     {\n         if (checkPending.getAndSet(false)) {\n-            Collection<SqlTask> sqlTasks = null;\n+            Collection<SqlTask> allTasks = null;\n             for (MemoryPool memoryPool : memoryPools) {\n                 if (!memoryRevokingNeeded(memoryPool)) {\n                     continue;\n                 }\n \n-                if (sqlTasks == null) {\n-                    sqlTasks = requireNonNull(currentTasksSupplier.get());\n+                if (allTasks == null) {\n+                    allTasks = requireNonNull(currentTasksSupplier.get());\n                 }\n \n-                requestMemoryRevoking(memoryPool, sqlTasks);\n+                requestMemoryRevoking(memoryPool, allTasks);\n             }\n         }\n     }\n \n-    private void requestMemoryRevoking(MemoryPool memoryPool, Collection<SqlTask> sqlTasks)\n+    private void requestMemoryRevoking(MemoryPool memoryPool, Collection<SqlTask> allTasks)\n     {\n         long remainingBytesToRevoke = (long) (-memoryPool.getFreeBytes() + (memoryPool.getMaxBytes() * (1.0 - memoryRevokingTarget)));\n-        remainingBytesToRevoke -= getMemoryAlreadyBeingRevoked(sqlTasks, memoryPool);\n-        requestRevoking(memoryPool, sqlTasks, remainingBytesToRevoke);\n+        List<SqlTask> runningTasksInPool = findRunningTasksInMemoryPool(allTasks, memoryPool);\n+        remainingBytesToRevoke -= getMemoryAlreadyBeingRevoked(runningTasksInPool, remainingBytesToRevoke);\n+        if (remainingBytesToRevoke > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE5NTA0Mw=="}, "originalCommit": null, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4445, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}