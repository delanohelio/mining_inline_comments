{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxODIyMzI1", "number": 5981, "title": "Optimize execution for output duplicates insensitive joins", "bodyText": "", "createdAt": "2020-11-16T17:38:19Z", "url": "https://github.com/trinodb/trino/pull/5981", "merged": true, "mergeCommit": {"oid": "4421ee68994e6c524882043b104ccb4d53e9312e"}, "closed": true, "closedAt": "2021-01-14T16:50:16Z", "author": {"login": "sopel39"}, "timelineItems": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABddIj_8ABqjQwMDE1MzMwMjE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdwG6jPgFqTU2ODQwNjUwOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxODQzMDk4", "url": "https://github.com/trinodb/trino/pull/5981#pullrequestreview-531843098", "createdAt": "2020-11-16T22:34:53Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQyMjozNDo1M1rOH0YYTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQyMjozNDo1M1rOH0YYTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDY4NzQzOQ==", "bodyText": "Would that allow us to remove special treatment of streaming aggregations now?", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r524687439", "createdAt": "2020-11-16T22:34:53Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/plan/JoinNode.java", "diffHunk": "@@ -52,6 +52,7 @@\n     private final List<EquiJoinClause> criteria;\n     private final List<Symbol> leftOutputSymbols;\n     private final List<Symbol> rightOutputSymbols;\n+    private final boolean cardinalityInsensitive;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNzgxOTAy", "url": "https://github.com/trinodb/trino/pull/5981#pullrequestreview-531781902", "createdAt": "2020-11-16T21:09:51Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQyMTowOTo1MVrOH0SDsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQyMjoyMTozN1rOH0XgxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDU4Mzg1OA==", "bodyText": "Not assuming any particular order of applying this rule and OptimizeCardinalityInsensitiveJoinRule, both might match the same plan. At a closer look, we always get a valid transformation, but depending on the order of the rules applied, the resulting plans differ in JoinNode having the \"cardinality insensitive\" flag or not.\nTo avoid this issue, I suggest that we add another rule to capture the common case (and exclude the case from other rules):\n- Aggregation (no aggregations; GROUP BY all left source symbols)\n      - LEFT join\n            - left source\n            - right source\n\nShould be transformed into:\n- Aggregation ((no aggregations; GROUP BY all left source symbols)\n      - left source", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r524583858", "createdAt": "2020-11-16T21:09:51Z", "author": {"login": "kasiafi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationThroughOuterJoin.java", "diffHunk": "@@ -153,6 +153,7 @@ public Result apply(AggregationNode aggregation, Captures captures, Context cont\n                     join.getCriteria(),\n                     join.getLeft().getOutputSymbols(),\n                     ImmutableList.copyOf(rewrittenAggregation.getAggregations().keySet()),\n+                    join.isCardinalityInsensitive(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDY3MzIyMA==", "bodyText": "I think we could try to find a different name for this property.\n\"cardinality insensitive\" suggests that the output of JoinNode is independent of cardinality of its inputs. This is true only for certain cases depending on implementation. Actually, this property captures a relation between the JoinNode and its parent.\nI would rename it to \"is in cardinality insensitive context\", or simply \"can skip duplicates\".", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r524673220", "createdAt": "2020-11-16T22:21:37Z", "author": {"login": "kasiafi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/plan/JoinNode.java", "diffHunk": "@@ -52,6 +52,7 @@\n     private final List<EquiJoinClause> criteria;\n     private final List<Symbol> leftOutputSymbols;\n     private final List<Symbol> rightOutputSymbols;\n+    private final boolean cardinalityInsensitive;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNTM0ODY3", "url": "https://github.com/trinodb/trino/pull/5981#pullrequestreview-532534867", "createdAt": "2020-11-17T16:10:23Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNjoxMDoyM1rOH087WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNjoxMDoyM1rOH087WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI4NjIzMw==", "bodyText": "Add tests with projections and filters between AggregationNode and JoinNode (both deterministic and non-deterministic), Also, for JoinNode nested in JoinNode with non-deterministic filter.", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r525286233", "createdAt": "2020-11-17T16:10:23Z", "author": {"login": "kasiafi"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestOptimizeCardinalityInsensitiveJoinRule.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.rule.test.BaseRuleTest;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import org.testng.annotations.Test;\n+\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.aggregation;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.join;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.values;\n+import static io.prestosql.sql.planner.iterative.rule.test.PlanBuilder.expression;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+\n+public class TestOptimizeCardinalityInsensitiveJoinRule", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNTQyMDQ0", "url": "https://github.com/trinodb/trino/pull/5981#pullrequestreview-532542044", "createdAt": "2020-11-17T16:17:27Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNjoxNzoyN1rOH09Qbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNjoxNzoyN1rOH09Qbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI5MTYzMQ==", "bodyText": "Should these be extracted to another commit?", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r525291631", "createdAt": "2020-11-17T16:17:27Z", "author": {"login": "kasiafi"}, "path": "presto-server-main/etc/config.properties", "diffHunk": "@@ -4,29 +4,23 @@\n # This configuration file is for development only and should NOT be used\n # in production. For example configuration, see the Presto documentation.\n #\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNTYyMjcw", "url": "https://github.com/trinodb/trino/pull/5981#pullrequestreview-532562270", "createdAt": "2020-11-17T16:36:49Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNjozNjo1MFrOH0-OEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNzowNjo1NFrOH0_xkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMwNzQwOA==", "bodyText": "unrelated", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r525307408", "createdAt": "2020-11-17T16:36:50Z", "author": {"login": "kasiafi"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -3109,7 +3162,7 @@ else if (target instanceof InsertTarget) {\n             else if (target instanceof TableWriterNode.RefreshMaterializedViewTarget) {\n                 TableWriterNode.RefreshMaterializedViewTarget refreshTarget = (TableWriterNode.RefreshMaterializedViewTarget) target;\n                 return metadata.finishRefreshMaterializedView(session, refreshTarget.getTableHandle(), refreshTarget.getInsertHandle(),\n-                    fragments, statistics, refreshTarget.getSourceTableHandles());\n+                        fragments, statistics, refreshTarget.getSourceTableHandles());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzMjg4MQ==", "bodyText": "Could you please add tests:\n\nwith FULL join,\nwith GROUP BY build symbols,\nwith multiple grouping sets?", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r525332881", "createdAt": "2020-11-17T17:06:54Z", "author": {"login": "kasiafi"}, "path": "presto-testing/src/main/java/io/prestosql/testing/AbstractTestJoinQueries.java", "diffHunk": "@@ -2279,4 +2282,42 @@ public void testMultiJoinWithEligibleForDynamicFiltering()\n                         \"AND customer.name >= 'Customer#000001463' \",\n                 \"VALUES 3\");\n     }\n+\n+    @Test\n+    public void testCardinalityInsensitiveJoin()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 19}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyODY4MjA0", "url": "https://github.com/trinodb/trino/pull/5981#pullrequestreview-532868204", "createdAt": "2020-11-17T22:32:35Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMjozMjozNVrOH1OMyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMjozMjozNVrOH1OMyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2OTIyNw==", "bodyText": "Since aggregation is pushed down and outer rows were guaranteed to be distinct we can just set cardinalityInsensitive to false here", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r525569227", "createdAt": "2020-11-17T22:32:35Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationThroughOuterJoin.java", "diffHunk": "@@ -153,6 +153,7 @@ public Result apply(AggregationNode aggregation, Captures captures, Context cont\n                     join.getCriteria(),\n                     join.getLeft().getOutputSymbols(),\n                     ImmutableList.copyOf(rewrittenAggregation.getAggregations().keySet()),\n+                    join.isCardinalityInsensitive(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDU4Mzg1OA=="}, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzNDQwMjcy", "url": "https://github.com/trinodb/trino/pull/5981#pullrequestreview-533440272", "createdAt": "2020-11-18T13:23:36Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMzoyMzozNlrOH1tm2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMzoyMzozNlrOH1tm2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA4MzgwMw==", "bodyText": "What if we could make pass this flag (matchSingleBuildRow) so when we build the hashTable we could make sure that only one element exists ? Or override getNextJoinPosition to return -1. Not sure if it would affect other places", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r526083803", "createdAt": "2020-11-18T13:23:36Z", "author": {"login": "Praveen2112"}, "path": "presto-main/src/main/java/io/prestosql/operator/LookupJoinOperator.java", "diffHunk": "@@ -336,8 +342,13 @@ private boolean joinCurrentPosition(LookupSource lookupSource, DriverYieldSignal\n                     joinSourcePositions++;\n                 }\n \n-                // get next position on lookup side for this probe row\n-                joinPosition = lookupSource.getNextJoinPosition(joinPosition, probe.getPosition(), probe.getPage());\n+                if (!matchSingleBuildRow || !currentProbePositionProducedRow) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzNzc0MTQ2", "url": "https://github.com/trinodb/trino/pull/5981#pullrequestreview-533774146", "createdAt": "2020-11-18T18:52:22Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODo1MjoyM1rOH19Qzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODo1NDo1NFrOH19W2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0MDMwMg==", "bodyText": "This will affect the computed estimates for the join, but I don't see anything in this PR that adjusts that logic. The resulting cardinality should be no larger than that of the left side of the join.", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r526340302", "createdAt": "2020-11-18T18:52:23Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/plan/JoinNode.java", "diffHunk": "@@ -302,6 +306,12 @@ public PlanNode getRight()\n         return spillable;\n     }\n \n+    @JsonProperty(\"canSkipOutputDuplicates\")\n+    public boolean isCanSkipOutputDuplicates()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0MTg1MA==", "bodyText": "canSkipOutputDuplicates = true only makes sense if the only columns being output come from the left side of the join (or are equi-join keys in the case of an inner join). Also, this doesn't work for RIGHT or FULL join, so we should validate we're not creating an inconsistent node.\nAlso, given the semantics of this property, I'm not sure canSkipOutputDuplicates is the best name. It'd be more accurate to call it \"outputsFirstMatchOnly\" or something similar.", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r526341850", "createdAt": "2020-11-18T18:54:54Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/plan/JoinNode.java", "diffHunk": "@@ -98,6 +100,7 @@ public JoinNode(\n         this.criteria = ImmutableList.copyOf(criteria);\n         this.leftOutputSymbols = ImmutableList.copyOf(leftOutputSymbols);\n         this.rightOutputSymbols = ImmutableList.copyOf(rightOutputSymbols);\n+        this.canSkipOutputDuplicates = canSkipOutputDuplicates;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NTYxNDQw", "url": "https://github.com/trinodb/trino/pull/5981#pullrequestreview-546561440", "createdAt": "2020-12-07T21:43:44Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMTo0Mzo0NFrOIA8DKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMTo1MDozM1rOIA8Syg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg1NDc2MA==", "bodyText": "Can we make this agnostic about where it runs relative to join reordering? What kind of issue does it cause for join reordering that forces this to run after?", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r537854760", "createdAt": "2020-12-07T21:43:44Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/PlanOptimizers.java", "diffHunk": "@@ -672,7 +673,11 @@ public PlanOptimizers(\n                 ruleStats,\n                 statsCalculator,\n                 costCalculator,\n-                ImmutableSet.of(new PushDeleteIntoConnector(metadata)))); // Must run before AddExchanges\n+                ImmutableSet.of(\n+                        // Must run before AddExchanges\n+                        new PushDeleteIntoConnector(metadata),\n+                        // Must run before AddExchanges and after join reordering\n+                        new OptimizeOutputDuplicatesInsensitiveJoinRule(metadata))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg1NjEzOA==", "bodyText": "This name is too generic. I can imagine many other places where an operation would be insensitive to duplicates, so the name should be more explicit about the fact that it's optimizing something involving aggregation and join.", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r537856138", "createdAt": "2020-12-07T21:46:05Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/OptimizeOutputDuplicatesInsensitiveJoinRule.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.iterative.GroupReference;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.PlanVisitor;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.SystemSessionProperties.isOptimizeOutputDuplicatesInsensitiveJoins;\n+import static io.prestosql.sql.planner.DeterminismEvaluator.isDeterministic;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizeOutputDuplicatesInsensitiveJoinRule", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg1ODc2Mg==", "bodyText": "We should avoid visitor-based rewrites as much as possible. We're trying to move away from them, as they make it hard to have a fully exploratory optimizer that considers multiple plans simultaneously.\nWhat we need to do this generically is a description of the properties (traits) of the data coming out of the source of the aggregation, possibly, involving functional dependencies to be able to infer whether certain columns are guaranteed to be unique based on whether they are derived from other unique columns.", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r537858762", "createdAt": "2020-12-07T21:50:33Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/OptimizeOutputDuplicatesInsensitiveJoinRule.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.iterative.GroupReference;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.PlanVisitor;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.SystemSessionProperties.isOptimizeOutputDuplicatesInsensitiveJoins;\n+import static io.prestosql.sql.planner.DeterminismEvaluator.isDeterministic;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizeOutputDuplicatesInsensitiveJoinRule\n+        implements Rule<AggregationNode>\n+{\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .matching(aggregation -> aggregation.getAggregations().isEmpty());\n+\n+    private final Metadata metadata;\n+\n+    public OptimizeOutputDuplicatesInsensitiveJoinRule(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isOptimizeOutputDuplicatesInsensitiveJoins(session);\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode aggregation, Captures captures, Context context)\n+    {\n+        return aggregation.getSource().accept(new Rewriter(metadata, context.getLookup()), null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 68}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b99e074537561c694fda2caa86a9020e772dfa6", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/8b99e074537561c694fda2caa86a9020e772dfa6", "committedDate": "2021-01-07T12:41:33Z", "message": "Fix formatting"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b31bd4164623a3ff6e46c852de5bf4ca64db539", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/3b31bd4164623a3ff6e46c852de5bf4ca64db539", "committedDate": "2021-01-07T14:45:32Z", "message": "Add JoinNode#maySkipOutputDuplicates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50d15f7822eddf91a81c9547fe1e607abed2c469", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/50d15f7822eddf91a81c9547fe1e607abed2c469", "committedDate": "2021-01-07T14:53:06Z", "message": "Add \"may skip output duplicates\" as part of tpcds/tpcds plans testing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3Njk0NzQw", "url": "https://github.com/trinodb/trino/pull/5981#pullrequestreview-567694740", "createdAt": "2021-01-13T22:04:51Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMjowNDo1MVrOITFkkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMjoyOTowOFrOITHJog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4NTEzNg==", "bodyText": "I don't think \"empty aggregation\" is the best name for this. It's an aggregation with no aggregate function calls.\nI would rename this to \"optimize duplicate-insensitive joins\"", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r556885136", "createdAt": "2021-01-13T22:04:51Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/SystemSessionProperties.java", "diffHunk": "@@ -548,6 +549,11 @@ public SystemSessionProperties(\n                         \"Rewrite semi join in filtering context to inner join\",\n                         featuresConfig.isRewriteFilteringSemiJoinToInnerJoin(),\n                         false),\n+                booleanProperty(\n+                        OPTIMIZE_JOINS_BELOW_EMPTY_AGGREGATION,\n+                        \"Optimize joins below empty aggregations\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4NTg0Mg==", "bodyText": "isOptimizeDuplicateInsensitiveJoins", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r556885842", "createdAt": "2021-01-13T22:05:39Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/SystemSessionProperties.java", "diffHunk": "@@ -1000,6 +1006,11 @@ public static boolean isRewriteFilteringSemiJoinToInnerJoin(Session session)\n         return session.getSystemProperty(FILTERING_SEMI_JOIN_TO_INNER, Boolean.class);\n     }\n \n+    public static boolean isOptimizeOutputDuplicatesInsensitiveJoins(Session session)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg5MDEzMQ==", "bodyText": "Maybe invert the condition for readability:\n                if (matchSingleBuildRow && currentProbePositionProducedRow) {\n                    joinPosition = -1;\n                }\n                else {\n                    // get next position on lookup side for this probe row\n                    joinPosition = lookupSource.getNextJoinPosition(joinPosition, probe.getPosition(), probe.getPage());\n                }", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r556890131", "createdAt": "2021-01-13T22:09:39Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/operator/LookupJoinOperator.java", "diffHunk": "@@ -337,8 +342,13 @@ private boolean joinCurrentPosition(LookupSource lookupSource, DriverYieldSignal\n                     joinSourcePositions++;\n                 }\n \n-                // get next position on lookup side for this probe row\n-                joinPosition = lookupSource.getNextJoinPosition(joinPosition, probe.getPosition(), probe.getPage());\n+                if (!matchSingleBuildRow || !currentProbePositionProducedRow) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg5MTIzMw==", "bodyText": "I'd call this \"outputSingleMatch\". It's not about matching a single row, but outputting a single row from all the ones that match.", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r556891233", "createdAt": "2021-01-13T22:10:38Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/operator/LookupJoinOperator.java", "diffHunk": "@@ -162,6 +164,7 @@ public void close()\n         private final LookupJoinPageBuilder pageBuilder;\n         private final Map<Integer, SavedRow> spilledRows = new HashMap<>();\n         private final boolean probeOnOuterSide;\n+        private final boolean matchSingleBuildRow;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg5NTM3OA==", "bodyText": "OptimizeDuplicateInsensitiveJoins", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r556895378", "createdAt": "2021-01-13T22:14:31Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/OptimizeJoinsBelowEmptyAggregationRule.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.trino.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.trino.Session;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.metadata.Metadata;\n+import io.trino.sql.planner.iterative.GroupReference;\n+import io.trino.sql.planner.iterative.Lookup;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.plan.AggregationNode;\n+import io.trino.sql.planner.plan.FilterNode;\n+import io.trino.sql.planner.plan.JoinNode;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.PlanVisitor;\n+import io.trino.sql.planner.plan.ProjectNode;\n+\n+import java.util.Optional;\n+\n+import static io.trino.SystemSessionProperties.isOptimizeOutputDuplicatesInsensitiveJoins;\n+import static io.trino.sql.planner.DeterminismEvaluator.isDeterministic;\n+import static io.trino.sql.planner.plan.Patterns.aggregation;\n+import static io.trino.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * For empty aggregations duplicate input rows can be skipped.\n+ * This rule takes advantage of this fact and sets\n+ * {@link JoinNode#withMaySkipOutputDuplicates()} for joins below\n+ * such aggregation.\n+ */\n+public class OptimizeJoinsBelowEmptyAggregationRule", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkwNjg4Mg==", "bodyText": "I'm not sure I understand this. If the join node is already marked with maySkipOutputDuplicates, why would we not preserve it regardless? If a join with a non-deterministic non equi condition is incompatible with isMaySkipOutputDuplicates, we would've never got in this state (and we should validate that somewhere else -- e.g., when pushing filters into join and/or when constructing a join node)", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r556906882", "createdAt": "2021-01-13T22:25:18Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/OptimizeJoinsBelowEmptyAggregationRule.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.trino.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.trino.Session;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.metadata.Metadata;\n+import io.trino.sql.planner.iterative.GroupReference;\n+import io.trino.sql.planner.iterative.Lookup;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.plan.AggregationNode;\n+import io.trino.sql.planner.plan.FilterNode;\n+import io.trino.sql.planner.plan.JoinNode;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.PlanVisitor;\n+import io.trino.sql.planner.plan.ProjectNode;\n+\n+import java.util.Optional;\n+\n+import static io.trino.SystemSessionProperties.isOptimizeOutputDuplicatesInsensitiveJoins;\n+import static io.trino.sql.planner.DeterminismEvaluator.isDeterministic;\n+import static io.trino.sql.planner.plan.Patterns.aggregation;\n+import static io.trino.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * For empty aggregations duplicate input rows can be skipped.\n+ * This rule takes advantage of this fact and sets\n+ * {@link JoinNode#withMaySkipOutputDuplicates()} for joins below\n+ * such aggregation.\n+ */\n+public class OptimizeJoinsBelowEmptyAggregationRule\n+        implements Rule<AggregationNode>\n+{\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .matching(aggregation -> aggregation.getAggregations().isEmpty());\n+\n+    private final Metadata metadata;\n+\n+    public OptimizeJoinsBelowEmptyAggregationRule(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isOptimizeOutputDuplicatesInsensitiveJoins(session);\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode aggregation, Captures captures, Context context)\n+    {\n+        return aggregation.getSource().accept(new Rewriter(metadata, context.getLookup()), null)\n+                .map(rewrittenSource -> Result.ofPlanNode(aggregation.replaceChildren(ImmutableList.of(rewrittenSource))))\n+                .orElse(Result.empty());\n+    }\n+\n+    private static class Rewriter\n+            extends PlanVisitor<Optional<PlanNode>, Void>\n+    {\n+        private final Metadata metadata;\n+        private final Lookup lookup;\n+\n+        private Rewriter(Metadata metadata, Lookup lookup)\n+        {\n+            this.metadata = requireNonNull(metadata, \"metadata is null\");\n+            this.lookup = requireNonNull(lookup, \"lookup is null\");\n+        }\n+\n+        @Override\n+        protected Optional<PlanNode> visitPlan(PlanNode node, Void context)\n+        {\n+            return Optional.empty();\n+        }\n+\n+        @Override\n+        public Optional<PlanNode> visitFilter(FilterNode node, Void context)\n+        {\n+            if (!isDeterministic(node.getPredicate(), metadata)) {\n+                // non-deterministic expressions could filter duplicate rows probabilistically\n+                return Optional.empty();\n+            }\n+\n+            return node.getSource().accept(this, null)\n+                    .map(source -> node.replaceChildren(ImmutableList.of(source)));\n+        }\n+\n+        @Override\n+        public Optional<PlanNode> visitProject(ProjectNode node, Void context)\n+        {\n+            boolean isDeterministic = node.getAssignments().getExpressions().stream()\n+                    .allMatch(expression -> isDeterministic(expression, metadata));\n+            if (!isDeterministic) {\n+                // non-deterministic projections could be used in downstream filters which could\n+                // filter duplicate rows probabilistically\n+                return Optional.empty();\n+            }\n+\n+            return node.getSource().accept(this, null)\n+                    .map(source -> node.replaceChildren(ImmutableList.of(source)));\n+        }\n+\n+        @Override\n+        public Optional<PlanNode> visitJoin(JoinNode node, Void context)\n+        {\n+            if (!isDeterministic(node.getFilter().orElse(TRUE_LITERAL), metadata)) {\n+                // LookupJoinOperator will evaluate non-deterministic condition on output rows until one of the\n+                // rows matches. Therefore it's safe to set maySkipOutputDuplicates for joins with non-deterministic\n+                // filters.\n+                if (node.isMaySkipOutputDuplicates()) {\n+                    return Optional.empty();\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkwODM3MQ==", "bodyText": "Why would we undo isMaySkipOutputDuplicates for a node that has already been determined as able to do it?", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r556908371", "createdAt": "2021-01-13T22:26:39Z", "author": {"login": "martint"}, "path": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/OptimizeJoinsBelowEmptyAggregationRule.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.trino.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.trino.Session;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.metadata.Metadata;\n+import io.trino.sql.planner.iterative.GroupReference;\n+import io.trino.sql.planner.iterative.Lookup;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.plan.AggregationNode;\n+import io.trino.sql.planner.plan.FilterNode;\n+import io.trino.sql.planner.plan.JoinNode;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.PlanVisitor;\n+import io.trino.sql.planner.plan.ProjectNode;\n+\n+import java.util.Optional;\n+\n+import static io.trino.SystemSessionProperties.isOptimizeOutputDuplicatesInsensitiveJoins;\n+import static io.trino.sql.planner.DeterminismEvaluator.isDeterministic;\n+import static io.trino.sql.planner.plan.Patterns.aggregation;\n+import static io.trino.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * For empty aggregations duplicate input rows can be skipped.\n+ * This rule takes advantage of this fact and sets\n+ * {@link JoinNode#withMaySkipOutputDuplicates()} for joins below\n+ * such aggregation.\n+ */\n+public class OptimizeJoinsBelowEmptyAggregationRule\n+        implements Rule<AggregationNode>\n+{\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .matching(aggregation -> aggregation.getAggregations().isEmpty());\n+\n+    private final Metadata metadata;\n+\n+    public OptimizeJoinsBelowEmptyAggregationRule(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isOptimizeOutputDuplicatesInsensitiveJoins(session);\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode aggregation, Captures captures, Context context)\n+    {\n+        return aggregation.getSource().accept(new Rewriter(metadata, context.getLookup()), null)\n+                .map(rewrittenSource -> Result.ofPlanNode(aggregation.replaceChildren(ImmutableList.of(rewrittenSource))))\n+                .orElse(Result.empty());\n+    }\n+\n+    private static class Rewriter\n+            extends PlanVisitor<Optional<PlanNode>, Void>\n+    {\n+        private final Metadata metadata;\n+        private final Lookup lookup;\n+\n+        private Rewriter(Metadata metadata, Lookup lookup)\n+        {\n+            this.metadata = requireNonNull(metadata, \"metadata is null\");\n+            this.lookup = requireNonNull(lookup, \"lookup is null\");\n+        }\n+\n+        @Override\n+        protected Optional<PlanNode> visitPlan(PlanNode node, Void context)\n+        {\n+            return Optional.empty();\n+        }\n+\n+        @Override\n+        public Optional<PlanNode> visitFilter(FilterNode node, Void context)\n+        {\n+            if (!isDeterministic(node.getPredicate(), metadata)) {\n+                // non-deterministic expressions could filter duplicate rows probabilistically\n+                return Optional.empty();\n+            }\n+\n+            return node.getSource().accept(this, null)\n+                    .map(source -> node.replaceChildren(ImmutableList.of(source)));\n+        }\n+\n+        @Override\n+        public Optional<PlanNode> visitProject(ProjectNode node, Void context)\n+        {\n+            boolean isDeterministic = node.getAssignments().getExpressions().stream()\n+                    .allMatch(expression -> isDeterministic(expression, metadata));\n+            if (!isDeterministic) {\n+                // non-deterministic projections could be used in downstream filters which could\n+                // filter duplicate rows probabilistically\n+                return Optional.empty();\n+            }\n+\n+            return node.getSource().accept(this, null)\n+                    .map(source -> node.replaceChildren(ImmutableList.of(source)));\n+        }\n+\n+        @Override\n+        public Optional<PlanNode> visitJoin(JoinNode node, Void context)\n+        {\n+            if (!isDeterministic(node.getFilter().orElse(TRUE_LITERAL), metadata)) {\n+                // LookupJoinOperator will evaluate non-deterministic condition on output rows until one of the\n+                // rows matches. Therefore it's safe to set maySkipOutputDuplicates for joins with non-deterministic\n+                // filters.\n+                if (node.isMaySkipOutputDuplicates()) {\n+                    return Optional.empty();\n+                }\n+\n+                return Optional.of(node.withMaySkipOutputDuplicates());\n+            }\n+\n+            Optional<PlanNode> rewrittenLeft = node.getLeft().accept(this, null);\n+            Optional<PlanNode> rewrittenRight = node.getRight().accept(this, null);\n+\n+            if (node.isMaySkipOutputDuplicates() && rewrittenLeft.isEmpty() && rewrittenRight.isEmpty()) {\n+                return Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkxMTAxMA==", "bodyText": "maybe call this matching?", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r556911010", "createdAt": "2021-01-13T22:29:08Z", "author": {"login": "martint"}, "path": "core/trino-main/src/test/java/io/trino/sql/planner/assertions/PlanMatchPattern.java", "diffHunk": "@@ -844,6 +844,28 @@ MatchResult detailMatches(PlanNode node, StatsProvider stats, Session session, M\n         return match(newAliases.build());\n     }\n \n+    public <T extends PlanNode> PlanMatchPattern with(Class<T> clazz, Predicate<T> predicate)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4MTE1MzAz", "url": "https://github.com/trinodb/trino/pull/5981#pullrequestreview-568115303", "createdAt": "2021-01-14T10:46:02Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxMDo0NjowMlrOITfHwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxMToxNDozNlrOITgIgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzMwMzc0NQ==", "bodyText": "I'm not sure I understand this. If the join node is already marked with maySkipOutputDuplicates, why would we not preserve it regardless?\n\nIt is preserved. If non empty Optional would be returned here, the rule would loop forever. Added comment", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r557303745", "createdAt": "2021-01-14T10:46:02Z", "author": {"login": "sopel39"}, "path": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/OptimizeJoinsBelowEmptyAggregationRule.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.trino.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.trino.Session;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.metadata.Metadata;\n+import io.trino.sql.planner.iterative.GroupReference;\n+import io.trino.sql.planner.iterative.Lookup;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.plan.AggregationNode;\n+import io.trino.sql.planner.plan.FilterNode;\n+import io.trino.sql.planner.plan.JoinNode;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.PlanVisitor;\n+import io.trino.sql.planner.plan.ProjectNode;\n+\n+import java.util.Optional;\n+\n+import static io.trino.SystemSessionProperties.isOptimizeOutputDuplicatesInsensitiveJoins;\n+import static io.trino.sql.planner.DeterminismEvaluator.isDeterministic;\n+import static io.trino.sql.planner.plan.Patterns.aggregation;\n+import static io.trino.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * For empty aggregations duplicate input rows can be skipped.\n+ * This rule takes advantage of this fact and sets\n+ * {@link JoinNode#withMaySkipOutputDuplicates()} for joins below\n+ * such aggregation.\n+ */\n+public class OptimizeJoinsBelowEmptyAggregationRule\n+        implements Rule<AggregationNode>\n+{\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .matching(aggregation -> aggregation.getAggregations().isEmpty());\n+\n+    private final Metadata metadata;\n+\n+    public OptimizeJoinsBelowEmptyAggregationRule(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isOptimizeOutputDuplicatesInsensitiveJoins(session);\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode aggregation, Captures captures, Context context)\n+    {\n+        return aggregation.getSource().accept(new Rewriter(metadata, context.getLookup()), null)\n+                .map(rewrittenSource -> Result.ofPlanNode(aggregation.replaceChildren(ImmutableList.of(rewrittenSource))))\n+                .orElse(Result.empty());\n+    }\n+\n+    private static class Rewriter\n+            extends PlanVisitor<Optional<PlanNode>, Void>\n+    {\n+        private final Metadata metadata;\n+        private final Lookup lookup;\n+\n+        private Rewriter(Metadata metadata, Lookup lookup)\n+        {\n+            this.metadata = requireNonNull(metadata, \"metadata is null\");\n+            this.lookup = requireNonNull(lookup, \"lookup is null\");\n+        }\n+\n+        @Override\n+        protected Optional<PlanNode> visitPlan(PlanNode node, Void context)\n+        {\n+            return Optional.empty();\n+        }\n+\n+        @Override\n+        public Optional<PlanNode> visitFilter(FilterNode node, Void context)\n+        {\n+            if (!isDeterministic(node.getPredicate(), metadata)) {\n+                // non-deterministic expressions could filter duplicate rows probabilistically\n+                return Optional.empty();\n+            }\n+\n+            return node.getSource().accept(this, null)\n+                    .map(source -> node.replaceChildren(ImmutableList.of(source)));\n+        }\n+\n+        @Override\n+        public Optional<PlanNode> visitProject(ProjectNode node, Void context)\n+        {\n+            boolean isDeterministic = node.getAssignments().getExpressions().stream()\n+                    .allMatch(expression -> isDeterministic(expression, metadata));\n+            if (!isDeterministic) {\n+                // non-deterministic projections could be used in downstream filters which could\n+                // filter duplicate rows probabilistically\n+                return Optional.empty();\n+            }\n+\n+            return node.getSource().accept(this, null)\n+                    .map(source -> node.replaceChildren(ImmutableList.of(source)));\n+        }\n+\n+        @Override\n+        public Optional<PlanNode> visitJoin(JoinNode node, Void context)\n+        {\n+            if (!isDeterministic(node.getFilter().orElse(TRUE_LITERAL), metadata)) {\n+                // LookupJoinOperator will evaluate non-deterministic condition on output rows until one of the\n+                // rows matches. Therefore it's safe to set maySkipOutputDuplicates for joins with non-deterministic\n+                // filters.\n+                if (node.isMaySkipOutputDuplicates()) {\n+                    return Optional.empty();\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkwNjg4Mg=="}, "originalCommit": null, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzMwNDMzNA==", "bodyText": "It is preserved. If it's already marked as maySkipOutputDuplicates and left and right children did not change, we need to return empty to prevent rule from looping forever. Added comment", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r557304334", "createdAt": "2021-01-14T10:47:05Z", "author": {"login": "sopel39"}, "path": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/OptimizeJoinsBelowEmptyAggregationRule.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.trino.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.trino.Session;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.metadata.Metadata;\n+import io.trino.sql.planner.iterative.GroupReference;\n+import io.trino.sql.planner.iterative.Lookup;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.plan.AggregationNode;\n+import io.trino.sql.planner.plan.FilterNode;\n+import io.trino.sql.planner.plan.JoinNode;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.PlanVisitor;\n+import io.trino.sql.planner.plan.ProjectNode;\n+\n+import java.util.Optional;\n+\n+import static io.trino.SystemSessionProperties.isOptimizeOutputDuplicatesInsensitiveJoins;\n+import static io.trino.sql.planner.DeterminismEvaluator.isDeterministic;\n+import static io.trino.sql.planner.plan.Patterns.aggregation;\n+import static io.trino.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * For empty aggregations duplicate input rows can be skipped.\n+ * This rule takes advantage of this fact and sets\n+ * {@link JoinNode#withMaySkipOutputDuplicates()} for joins below\n+ * such aggregation.\n+ */\n+public class OptimizeJoinsBelowEmptyAggregationRule\n+        implements Rule<AggregationNode>\n+{\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .matching(aggregation -> aggregation.getAggregations().isEmpty());\n+\n+    private final Metadata metadata;\n+\n+    public OptimizeJoinsBelowEmptyAggregationRule(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isOptimizeOutputDuplicatesInsensitiveJoins(session);\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode aggregation, Captures captures, Context context)\n+    {\n+        return aggregation.getSource().accept(new Rewriter(metadata, context.getLookup()), null)\n+                .map(rewrittenSource -> Result.ofPlanNode(aggregation.replaceChildren(ImmutableList.of(rewrittenSource))))\n+                .orElse(Result.empty());\n+    }\n+\n+    private static class Rewriter\n+            extends PlanVisitor<Optional<PlanNode>, Void>\n+    {\n+        private final Metadata metadata;\n+        private final Lookup lookup;\n+\n+        private Rewriter(Metadata metadata, Lookup lookup)\n+        {\n+            this.metadata = requireNonNull(metadata, \"metadata is null\");\n+            this.lookup = requireNonNull(lookup, \"lookup is null\");\n+        }\n+\n+        @Override\n+        protected Optional<PlanNode> visitPlan(PlanNode node, Void context)\n+        {\n+            return Optional.empty();\n+        }\n+\n+        @Override\n+        public Optional<PlanNode> visitFilter(FilterNode node, Void context)\n+        {\n+            if (!isDeterministic(node.getPredicate(), metadata)) {\n+                // non-deterministic expressions could filter duplicate rows probabilistically\n+                return Optional.empty();\n+            }\n+\n+            return node.getSource().accept(this, null)\n+                    .map(source -> node.replaceChildren(ImmutableList.of(source)));\n+        }\n+\n+        @Override\n+        public Optional<PlanNode> visitProject(ProjectNode node, Void context)\n+        {\n+            boolean isDeterministic = node.getAssignments().getExpressions().stream()\n+                    .allMatch(expression -> isDeterministic(expression, metadata));\n+            if (!isDeterministic) {\n+                // non-deterministic projections could be used in downstream filters which could\n+                // filter duplicate rows probabilistically\n+                return Optional.empty();\n+            }\n+\n+            return node.getSource().accept(this, null)\n+                    .map(source -> node.replaceChildren(ImmutableList.of(source)));\n+        }\n+\n+        @Override\n+        public Optional<PlanNode> visitJoin(JoinNode node, Void context)\n+        {\n+            if (!isDeterministic(node.getFilter().orElse(TRUE_LITERAL), metadata)) {\n+                // LookupJoinOperator will evaluate non-deterministic condition on output rows until one of the\n+                // rows matches. Therefore it's safe to set maySkipOutputDuplicates for joins with non-deterministic\n+                // filters.\n+                if (node.isMaySkipOutputDuplicates()) {\n+                    return Optional.empty();\n+                }\n+\n+                return Optional.of(node.withMaySkipOutputDuplicates());\n+            }\n+\n+            Optional<PlanNode> rewrittenLeft = node.getLeft().accept(this, null);\n+            Optional<PlanNode> rewrittenRight = node.getRight().accept(this, null);\n+\n+            if (node.isMaySkipOutputDuplicates() && rewrittenLeft.isEmpty() && rewrittenRight.isEmpty()) {\n+                return Optional.empty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkwODM3MQ=="}, "originalCommit": null, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzMyMDMyMw==", "bodyText": "It's simplification of with method below that accepts full Matcher. Also withXXX seems to be convention in this class.", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r557320323", "createdAt": "2021-01-14T11:14:36Z", "author": {"login": "sopel39"}, "path": "core/trino-main/src/test/java/io/trino/sql/planner/assertions/PlanMatchPattern.java", "diffHunk": "@@ -844,6 +844,28 @@ MatchResult detailMatches(PlanNode node, StatsProvider stats, Session session, M\n         return match(newAliases.build());\n     }\n \n+    public <T extends PlanNode> PlanMatchPattern with(Class<T> clazz, Predicate<T> predicate)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkxMTAxMA=="}, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da74bbe588ceaaf6ca2dcb2738ad2115c9038223", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/da74bbe588ceaaf6ca2dcb2738ad2115c9038223", "committedDate": "2021-01-14T12:24:27Z", "message": "Optimize execution for joins below empty aggregation\n\nFor empty aggregations duplicate input rows can be skipped.\nUpstream joins can take advantage of this fact and skip producing\nof duplicate output rows."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "da74bbe588ceaaf6ca2dcb2738ad2115c9038223", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/da74bbe588ceaaf6ca2dcb2738ad2115c9038223", "committedDate": "2021-01-14T12:24:27Z", "message": "Optimize execution for joins below empty aggregation\n\nFor empty aggregations duplicate input rows can be skipped.\nUpstream joins can take advantage of this fact and skip producing\nof duplicate output rows."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4NDA2NTA5", "url": "https://github.com/trinodb/trino/pull/5981#pullrequestreview-568406509", "createdAt": "2021-01-14T16:28:59Z", "commit": {"oid": "da74bbe588ceaaf6ca2dcb2738ad2115c9038223"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2599, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}