{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyNjYxNzk0", "number": 4296, "title": "Try compacting table multiple times if compaction has failed", "bodyText": "Sometimes compaction can fail due to yarn container being killed. This prevents test from failing by retrying table compaction.", "createdAt": "2020-07-01T12:18:42Z", "url": "https://github.com/trinodb/trino/pull/4296", "merged": true, "mergeCommit": {"oid": "4d98c971dd6ae5a64b62aa12a67db640a52fc0fa"}, "closed": true, "closedAt": "2020-07-03T12:57:27Z", "author": {"login": "wendigo"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwqGbigBqjM1MDI0MTQzMjk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcxTAXZAFqTQ0MjM5NDQzNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNDk1MTc4", "url": "https://github.com/trinodb/trino/pull/4296#pullrequestreview-441495178", "createdAt": "2020-07-02T09:12:15Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwOToxMjoxNlrOGsEYqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwOTo0NDoyMFrOGsFiRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg2MjM3Ng==", "bodyText": "should we take all and then assert that the size of list is either 0 or 1", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448862376", "createdAt": "2020-07-02T09:12:16Z", "author": {"login": "losipiuk"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +183,58 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(\"Could not compact table, retries \" + event.getAttemptCount(), event.getFailure());\n+                })\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, timeout));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        // Hive's unix_timestamp() returns millis\n+        long beforeCompactionStart = (Long) onHive().executeQuery(\"SELECT unix_timestamp()\").row(0).get(0) * 1000;\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            // Since we disabled auto compaction for uniquely named table and every compaction is triggered in this test\n+            // we can expect that single compaction in given mode should complete before proceeding.\n+            Optional<Map<String, String>> startedCompaction = getTableCompactions(compactMode, tableName)\n+                    .filter(row -> !row.get(\"state\").equals(\"initiated\"))\n+                    .filter(row -> Long.parseLong(row.get(\"start time\")) >= beforeCompactionStart)\n+                    .findFirst();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg4MDQ2NQ==", "bodyText": "move to Try compacting table multiple times if compaction has failed", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448880465", "createdAt": "2020-07-02T09:43:01Z", "author": {"login": "losipiuk"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -183,13 +187,16 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n         Failsafe.with(\n                 new RetryPolicy<>()\n                         .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n                         .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n                 .onFailure(event -> {\n-                    throw new IllegalStateException(\"Could not compact table, retries \" + event.getAttemptCount(), event.getFailure());\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg4MTIyMw==", "bodyText": "nit: i think logging at INFO is enough for that to show in CI logs. Higher severity is kinda not in-line with what testng does as even test-failure is logged as INFO.", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448881223", "createdAt": "2020-07-02T09:44:20Z", "author": {"login": "losipiuk"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -218,11 +227,13 @@ private static void tryCompactingTable(CompactionMode compactMode, String tableN\n                     .findFirst();\n \n             if (startedCompaction.isEmpty()) {\n+                log.warn(\"Compaction has not started yet\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNTMzMjk2", "url": "https://github.com/trinodb/trino/pull/4296#pullrequestreview-441533296", "createdAt": "2020-07-02T10:02:36Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDowMjozNlrOGsGLTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDowOTozNVrOGsGaMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MTcyNg==", "bodyText": "why reduce?", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448891726", "createdAt": "2020-07-02T10:02:36Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -80,7 +83,7 @@ public void testReadFullAcid(boolean isPartitioned, BucketingType bucketingType)\n \n             // test minor compacted data read\n             onHive().executeQuery(\"INSERT INTO TABLE \" + tableName + hivePartitionString + \" VALUES (20, 3)\");\n-            compactTableAndWait(MINOR, tableName, hivePartitionString, Duration.valueOf(\"5m\"));\n+            compactTableAndWait(MINOR, tableName, hivePartitionString, Duration.valueOf(\"3m\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MTkwOQ==", "bodyText": "why reduce?", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448891909", "createdAt": "2020-07-02T10:02:54Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -125,7 +128,7 @@ public void testReadInsertOnly(boolean isPartitioned, BucketingType bucketingTyp\n             assertThat(query(selectFromOnePartitionsSql)).containsExactly(row(1), row(2));\n \n             // test minor compacted data read\n-            compactTableAndWait(MINOR, tableName, hivePartitionString, Duration.valueOf(\"5m\"));\n+            compactTableAndWait(MINOR, tableName, hivePartitionString, Duration.valueOf(\"3m\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MTkzOQ==", "bodyText": "why reduce?", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448891939", "createdAt": "2020-07-02T10:02:58Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -137,7 +140,7 @@ public void testReadInsertOnly(boolean isPartitioned, BucketingType bucketingTyp\n \n                 // test major compaction\n                 onHive().executeQuery(\"INSERT INTO TABLE \" + tableName + hivePartitionString + \" SELECT 4\");\n-                compactTableAndWait(MAJOR, tableName, hivePartitionString, Duration.valueOf(\"5m\"));\n+                compactTableAndWait(MAJOR, tableName, hivePartitionString, Duration.valueOf(\"3m\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MjkxMw==", "bodyText": "is 90s enough? what's typical time it takes on CI?", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448892913", "createdAt": "2020-07-02T10:04:41Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +187,66 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"90s\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MzM4MA==", "bodyText": "The clocks are in sync (single host), so you can use System.currentTimeMillis", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448893380", "createdAt": "2020-07-02T10:05:29Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +187,66 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"90s\")));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        // Hive's unix_timestamp() returns millis\n+        long beforeCompactionStart = (Long) onHive().executeQuery(\"SELECT unix_timestamp()\").row(0).get(0) * 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MzY5NQ==", "bodyText": "add Thread.currentThread().interrupt();", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448893695", "createdAt": "2020-07-02T10:06:05Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +187,66 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"90s\")));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        // Hive's unix_timestamp() returns millis\n+        long beforeCompactionStart = (Long) onHive().executeQuery(\"SELECT unix_timestamp()\").row(0).get(0) * 1000;\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        log.info(\"Started compactions: %s\", getTableCompactions(compactMode, tableName).collect(toImmutableList()));\n+\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5NDcxMA==", "bodyText": "I'd rather have this two-step\n\nfind ours compaction (getTableCompactions + filter by time)\n\nit must exists and must be exactly one\n\n\n(sep stmt) verify it's \"state\" (\"initiated\" or sth else)", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448894710", "createdAt": "2020-07-02T10:07:58Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +187,66 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"90s\")));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        // Hive's unix_timestamp() returns millis\n+        long beforeCompactionStart = (Long) onHive().executeQuery(\"SELECT unix_timestamp()\").row(0).get(0) * 1000;\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        log.info(\"Started compactions: %s\", getTableCompactions(compactMode, tableName).collect(toImmutableList()));\n+\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            // Since we disabled auto compaction for uniquely named table and every compaction is triggered in this test\n+            // we can expect that single compaction in given mode should complete before proceeding.\n+            Optional<Map<String, String>> startedCompaction = getTableCompactions(compactMode, tableName)\n+                    .filter(row -> !row.get(\"state\").equals(\"initiated\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5NTA2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            log.error(\"Compaction has timed out: %s\", startedCompaction.get());\n          \n          \n            \n                            log.error(\"Waiting for compaction has timed out: %s\", startedCompaction.get());", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448895062", "createdAt": "2020-07-02T10:08:41Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +187,66 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"90s\")));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        // Hive's unix_timestamp() returns millis\n+        long beforeCompactionStart = (Long) onHive().executeQuery(\"SELECT unix_timestamp()\").row(0).get(0) * 1000;\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        log.info(\"Started compactions: %s\", getTableCompactions(compactMode, tableName).collect(toImmutableList()));\n+\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            // Since we disabled auto compaction for uniquely named table and every compaction is triggered in this test\n+            // we can expect that single compaction in given mode should complete before proceeding.\n+            Optional<Map<String, String>> startedCompaction = getTableCompactions(compactMode, tableName)\n+                    .filter(row -> !row.get(\"state\").equals(\"initiated\"))\n+                    .filter(row -> Long.parseLong(row.get(\"start time\")) >= beforeCompactionStart)\n+                    .findFirst();\n \n-            verify(!compaction.get(\"state\").equals(\"failed\"), \"compaction has failed\");\n-            assertEquals(compaction.get(\"state\"), \"succeeded\");\n-        });\n+            if (startedCompaction.isEmpty()) {\n+                log.warn(\"Compaction has not started yet\");\n+                continue;\n+            }\n+\n+            String compactionState = startedCompaction.get().get(\"state\");\n+            if (compactionState.equals(\"failed\")) {\n+                log.error(\"Compaction has failed: %s\", startedCompaction.get());\n+                // This will retry compacting table\n+                throw new IllegalStateException(\"Compaction has failed\");\n+            }\n+\n+            if (compactionState.equals(\"succeeded\")) {\n+                return;\n+            }\n+\n+            if (Duration.nanosSince(loopStart).compareTo(timeout) > 0) {\n+                log.error(\"Compaction has timed out: %s\", startedCompaction.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5NTUzOA==", "bodyText": "Also, how many log lines do we produce per test run?\nHow many log lines per this test class?\nis there a risk of bloating the test output?\n(this could make viewing test logs in the browser harder)", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448895538", "createdAt": "2020-07-02T10:09:35Z", "author": {"login": "findepi"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -218,11 +227,13 @@ private static void tryCompactingTable(CompactionMode compactMode, String tableN\n                     .findFirst();\n \n             if (startedCompaction.isEmpty()) {\n+                log.warn(\"Compaction has not started yet\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg4MTIyMw=="}, "originalCommit": null, "originalPosition": 56}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "db95f5cc55cd8f78ecde3480f9d80d1c50ee7851", "author": {"user": {"login": "wendigo", "name": "Mateusz \"Serafin\" Gajewski"}}, "url": "https://github.com/trinodb/trino/commit/db95f5cc55cd8f78ecde3480f9d80d1c50ee7851", "committedDate": "2020-07-03T11:04:00Z", "message": "Try compacting table multiple times if compaction has failed"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "db95f5cc55cd8f78ecde3480f9d80d1c50ee7851", "author": {"user": {"login": "wendigo", "name": "Mateusz \"Serafin\" Gajewski"}}, "url": "https://github.com/trinodb/trino/commit/db95f5cc55cd8f78ecde3480f9d80d1c50ee7851", "committedDate": "2020-07-03T11:04:00Z", "message": "Try compacting table multiple times if compaction has failed"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMzk0NDM3", "url": "https://github.com/trinodb/trino/pull/4296#pullrequestreview-442394437", "createdAt": "2020-07-03T12:55:30Z", "commit": {"oid": "db95f5cc55cd8f78ecde3480f9d80d1c50ee7851"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjo1NTozMFrOGsviYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjo1NTozMFrOGsviYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU2OTM3OQ==", "bodyText": "nit: getOnlyElement()", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r449569379", "createdAt": "2020-07-03T12:55:30Z", "author": {"login": "losipiuk"}, "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,25 +189,82 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"60s\")));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        long beforeCompactionStart = Instant.now().getEpochSecond();\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        log.info(\"Started compactions: %s\", getTableCompactions(compactMode, tableName, OptionalLong.empty()));\n \n-            verify(!compaction.get(\"state\").equals(\"failed\"), \"compaction has failed\");\n-            assertEquals(compaction.get(\"state\"), \"succeeded\");\n-        });\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new RuntimeException(e);\n+            }\n+\n+            // Since we disabled auto compaction for uniquely named table and every compaction is triggered in this test\n+            // we can expect that single compaction in given mode should complete before proceeding.\n+            List<Map<String, String>> startedCompactions = getTableCompactions(compactMode, tableName, OptionalLong.of(beforeCompactionStart));\n+            verify(startedCompactions.size() < 2, \"Expected at most 1 compaction\");\n+\n+            if (startedCompactions.isEmpty()) {\n+                log.info(\"Compaction has not started yet\");\n+                continue;\n+            }\n+\n+            String compactionState = startedCompactions.get(0).get(\"state\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db95f5cc55cd8f78ecde3480f9d80d1c50ee7851"}, "originalPosition": 146}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 317, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}