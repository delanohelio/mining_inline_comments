{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgzMTI1OTEx", "number": 5124, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODowMjoyNVrOEh_7Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOTozODoxOVrOEiCO5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MDg1ODUwOnYy", "diffSide": "RIGHT", "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/PostgreSqlQueryRunner.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODowMjoyNVrOHPn1Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODowMjoyNVrOHPn1Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0MzI5OQ==", "bodyText": "I would rather drop this commit.\nThe added burden of an overload is not justified for arguably small benefit this brings.", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486143299", "createdAt": "2020-09-10T08:02:25Z", "author": {"login": "findepi"}, "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/PostgreSqlQueryRunner.java", "diffHunk": "@@ -49,11 +49,23 @@ public static DistributedQueryRunner createPostgreSqlQueryRunner(\n             Map<String, String> connectorProperties,\n             Iterable<TpchTable<?>> tables)\n             throws Exception\n+    {\n+        return createPostgreSqlQueryRunner(server, extraProperties, connectorProperties, tables, 3);\n+    }\n+\n+    public static DistributedQueryRunner createPostgreSqlQueryRunner(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MDg2MjU1OnYy", "diffSide": "LEFT", "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODowMzozMVrOHPn31g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOToxNjo0N1rOHPqrug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0Mzk1OA==", "bodyText": "The cmt title is\n\nRename misleading testTimestampWithTimeZoneDataProvider\n\nit's removal not \"rename\"\n\"misleading\" is misleading. It was very nicely called \"DataProvider\", i do not find anything misleading in that and next time would call it the same.", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486143958", "createdAt": "2020-09-10T08:03:31Z", "author": {"login": "findepi"}, "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1199,15 +1200,6 @@ public void testArrayTimestampWithTimeZone(boolean insertWithPresto)\n         tests.execute(getQueryRunner(), sessionWithArrayAsArray(), dataSetup);\n     }\n \n-    @DataProvider\n-    public Object[][] testTimestampWithTimeZoneDataProvider()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5MDAxMA==", "bodyText": "Changed to \"Use generic trueFalse data provider for timestamp tests\"", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486190010", "createdAt": "2020-09-10T09:16:47Z", "author": {"login": "losipiuk"}, "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1199,15 +1200,6 @@ public void testArrayTimestampWithTimeZone(boolean insertWithPresto)\n         tests.execute(getQueryRunner(), sessionWithArrayAsArray(), dataSetup);\n     }\n \n-    @DataProvider\n-    public Object[][] testTimestampWithTimeZoneDataProvider()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0Mzk1OA=="}, "originalCommit": null, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MDg4ODkzOnYy", "diffSide": "RIGHT", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODowOTo1OVrOHPoIXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODowOTo1OVrOHPoIXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0ODE5MQ==", "bodyText": "if timestampType.precision < 6, you need to round/truncate here\n@martint what is the correct way to do this?\nthere are some utility methods in io.prestosql.spi.type.Timestamps, but I do not see something that's immediately applicable.", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486148191", "createdAt": "2020-09-10T08:09:59Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -382,24 +397,34 @@ public static LongReadFunction timestampReadFunction()\n      * {@link #timestampWriteFunction} instead.\n      */\n     @Deprecated\n-    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp()\n+    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(value)));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(timestampType, value)));\n     }\n \n-    public static LongWriteFunction timestampWriteFunction()\n+    public static LongWriteFunction timestampWriteFunction(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(value));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(timestampType, value));\n     }\n \n-    public static long toPrestoTimestamp(LocalDateTime localDateTime)\n+    public static long toPrestoTimestamp(TimestampType timestampType, LocalDateTime localDateTime)\n     {\n-        return localDateTime.atZone(UTC).toInstant().toEpochMilli() * MICROSECONDS_PER_MILLISECOND;\n+        long precision = timestampType.getPrecision();\n+        checkArgument(precision <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", precision);\n+        Instant instant = localDateTime.atZone(UTC).toInstant();\n+        return instant.getEpochSecond() * MICROSECONDS_PER_SECOND + roundDiv(instant.getNano(), NANOSECONDS_PER_MICROSECOND);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MDg5MjQ1OnYy", "diffSide": "RIGHT", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODoxMDo1NFrOHPoKjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODoxMDo1NFrOHPoKjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0ODc1MA==", "bodyText": "You do not really need to validate this here. If someone provided epochMicros, it;'s all you need.", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486148750", "createdAt": "2020-09-10T08:10:54Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -382,24 +397,34 @@ public static LongReadFunction timestampReadFunction()\n      * {@link #timestampWriteFunction} instead.\n      */\n     @Deprecated\n-    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp()\n+    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(value)));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(timestampType, value)));\n     }\n \n-    public static LongWriteFunction timestampWriteFunction()\n+    public static LongWriteFunction timestampWriteFunction(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(value));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(timestampType, value));\n     }\n \n-    public static long toPrestoTimestamp(LocalDateTime localDateTime)\n+    public static long toPrestoTimestamp(TimestampType timestampType, LocalDateTime localDateTime)\n     {\n-        return localDateTime.atZone(UTC).toInstant().toEpochMilli() * MICROSECONDS_PER_MILLISECOND;\n+        long precision = timestampType.getPrecision();\n+        checkArgument(precision <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", precision);\n+        Instant instant = localDateTime.atZone(UTC).toInstant();\n+        return instant.getEpochSecond() * MICROSECONDS_PER_SECOND + roundDiv(instant.getNano(), NANOSECONDS_PER_MICROSECOND);\n     }\n \n-    public static LocalDateTime fromPrestoTimestamp(long value)\n+    public static LocalDateTime fromPrestoTimestamp(TimestampType timestampType, long epochMicros)\n     {\n-        return Instant.ofEpochMilli(floorDiv(value, MICROSECONDS_PER_MILLISECOND)).atZone(UTC).toLocalDateTime();\n+        int precision = timestampType.getPrecision();\n+        checkArgument(precision <= MAX_SHORT_PRECISION && precision >= 0, \"Precision is out of range: %s\", precision);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MDkwMTUzOnYy", "diffSide": "RIGHT", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODoxMzoxNFrOHPoQLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOTozMjo1NlrOHPrS6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1MDE5MQ==", "bodyText": "we could unify & reuse with io.prestosql.spi.type.Timestamps#formatTimestamp(int precision, long epochMicros, int picosOfMicro)", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486150191", "createdAt": "2020-09-10T08:13:14Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -382,24 +397,34 @@ public static LongReadFunction timestampReadFunction()\n      * {@link #timestampWriteFunction} instead.\n      */\n     @Deprecated\n-    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp()\n+    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(value)));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(timestampType, value)));\n     }\n \n-    public static LongWriteFunction timestampWriteFunction()\n+    public static LongWriteFunction timestampWriteFunction(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(value));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(timestampType, value));\n     }\n \n-    public static long toPrestoTimestamp(LocalDateTime localDateTime)\n+    public static long toPrestoTimestamp(TimestampType timestampType, LocalDateTime localDateTime)\n     {\n-        return localDateTime.atZone(UTC).toInstant().toEpochMilli() * MICROSECONDS_PER_MILLISECOND;\n+        long precision = timestampType.getPrecision();\n+        checkArgument(precision <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", precision);\n+        Instant instant = localDateTime.atZone(UTC).toInstant();\n+        return instant.getEpochSecond() * MICROSECONDS_PER_SECOND + roundDiv(instant.getNano(), NANOSECONDS_PER_MICROSECOND);\n     }\n \n-    public static LocalDateTime fromPrestoTimestamp(long value)\n+    public static LocalDateTime fromPrestoTimestamp(TimestampType timestampType, long epochMicros)\n     {\n-        return Instant.ofEpochMilli(floorDiv(value, MICROSECONDS_PER_MILLISECOND)).atZone(UTC).toLocalDateTime();\n+        int precision = timestampType.getPrecision();\n+        checkArgument(precision <= MAX_SHORT_PRECISION && precision >= 0, \"Precision is out of range: %s\", precision);\n+        long epochSecond = floorDiv(epochMicros, MICROSECONDS_PER_SECOND);\n+        int nanoFraction = floorMod(epochMicros, MICROSECONDS_PER_SECOND) * NANOSECONDS_PER_MICROSECOND;\n+        Instant instant = Instant.ofEpochSecond(epochSecond, nanoFraction);\n+        return LocalDateTime.ofInstant(instant, UTC);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIwMDA0Mg==", "bodyText": "We could but I am not sure if we could extend spi with random methods. We should keep it fairly stable. Also the spi methods cares about picosOfMicro which we do not care about here. With picosOfMicro you cannot create a method which just returns LocalDateTime, which we need here. And have a specific method version which does not take picosOfSeconds and returns LocalDateTime seems to specific to me, to be put in spi.", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486200042", "createdAt": "2020-09-10T09:32:56Z", "author": {"login": "losipiuk"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -382,24 +397,34 @@ public static LongReadFunction timestampReadFunction()\n      * {@link #timestampWriteFunction} instead.\n      */\n     @Deprecated\n-    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp()\n+    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(value)));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(timestampType, value)));\n     }\n \n-    public static LongWriteFunction timestampWriteFunction()\n+    public static LongWriteFunction timestampWriteFunction(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(value));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(timestampType, value));\n     }\n \n-    public static long toPrestoTimestamp(LocalDateTime localDateTime)\n+    public static long toPrestoTimestamp(TimestampType timestampType, LocalDateTime localDateTime)\n     {\n-        return localDateTime.atZone(UTC).toInstant().toEpochMilli() * MICROSECONDS_PER_MILLISECOND;\n+        long precision = timestampType.getPrecision();\n+        checkArgument(precision <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", precision);\n+        Instant instant = localDateTime.atZone(UTC).toInstant();\n+        return instant.getEpochSecond() * MICROSECONDS_PER_SECOND + roundDiv(instant.getNano(), NANOSECONDS_PER_MICROSECOND);\n     }\n \n-    public static LocalDateTime fromPrestoTimestamp(long value)\n+    public static LocalDateTime fromPrestoTimestamp(TimestampType timestampType, long epochMicros)\n     {\n-        return Instant.ofEpochMilli(floorDiv(value, MICROSECONDS_PER_MILLISECOND)).atZone(UTC).toLocalDateTime();\n+        int precision = timestampType.getPrecision();\n+        checkArgument(precision <= MAX_SHORT_PRECISION && precision >= 0, \"Precision is out of range: %s\", precision);\n+        long epochSecond = floorDiv(epochMicros, MICROSECONDS_PER_SECOND);\n+        int nanoFraction = floorMod(epochMicros, MICROSECONDS_PER_SECOND) * NANOSECONDS_PER_MICROSECOND;\n+        Instant instant = Instant.ofEpochSecond(epochSecond, nanoFraction);\n+        return LocalDateTime.ofInstant(instant, UTC);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1MDE5MQ=="}, "originalCommit": null, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MDkwMzY1OnYy", "diffSide": "RIGHT", "path": "presto-mysql/src/main/java/io/prestosql/plugin/mysql/MySqlClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODoxMzo0OFrOHPoRkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODoxMzo0OFrOHPoRkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1MDU0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return WriteMapping.longMapping(\"datetime\", timestampWriteFunctionUsingSqlTimestamp(TIMESTAMP));\n          \n          \n            \n                        return WriteMapping.longMapping(\"datetime\", timestampWriteFunctionUsingSqlTimestamp(TIMESTAMP_MILLIS));", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486150544", "createdAt": "2020-09-10T08:13:48Z", "author": {"login": "findepi"}, "path": "presto-mysql/src/main/java/io/prestosql/plugin/mysql/MySqlClient.java", "diffHunk": "@@ -262,7 +262,7 @@ public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n         }\n         if (TIMESTAMP_MILLIS.equals(type)) {\n             // TODO use `timestampWriteFunction`\n-            return WriteMapping.longMapping(\"datetime\", timestampWriteFunctionUsingSqlTimestamp());\n+            return WriteMapping.longMapping(\"datetime\", timestampWriteFunctionUsingSqlTimestamp(TIMESTAMP));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MDkyMDEzOnYy", "diffSide": "RIGHT", "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODoxODoxNVrOHPocJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOTo0NjoxMFrOHPrypg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1MzI1Mg==", "bodyText": "\"TIMESTAMP WITH TIME ZONE\"\nalso, is 3 and 6 actually different cases?\ni think in timestamp case, we go with the same code path\n(ok to leave the test coverage, but if true, change the commnt)", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486153252", "createdAt": "2020-09-10T08:18:15Z", "author": {"login": "findepi"}, "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1005,24 +1005,38 @@ public void testTime(boolean insertWithPresto, ZoneId sessionZone)\n     @Test(dataProvider = \"testTimestampDataProvider\")\n     public void testTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     {\n-        // using two non-JVM zones so that we don't need to worry what Postgres system zone is\n-        DataTypeTest tests = DataTypeTest.create(true)\n-                .addRoundTrip(timestampDataType(), beforeEpoch)\n-                .addRoundTrip(timestampDataType(), afterEpoch)\n-                .addRoundTrip(timestampDataType(), timeDoubledInJvmZone)\n-                .addRoundTrip(timestampDataType(), timeDoubledInVilnius)\n-                .addRoundTrip(timestampDataType(), epoch) // epoch also is a gap in JVM zone\n-                .addRoundTrip(timestampDataType(), timeGapInJvmZone1)\n-                .addRoundTrip(timestampDataType(), timeGapInJvmZone2)\n-                .addRoundTrip(timestampDataType(), timeGapInVilnius)\n-                .addRoundTrip(timestampDataType(), timeGapInKathmandu);\n+        DataTypeTest tests = DataTypeTest.create(true);\n+        for (int precision : List.of(3, 6)) {\n+            // test all standard cases with precision 3 and 6 to make sure the long and short TIMESTAMP WITH TIME ZONE", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIwODE2Ng==", "bodyText": "Oh - you noticed it too - yeah - it same case. I dropped the coverage.", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486208166", "createdAt": "2020-09-10T09:46:10Z", "author": {"login": "losipiuk"}, "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1005,24 +1005,38 @@ public void testTime(boolean insertWithPresto, ZoneId sessionZone)\n     @Test(dataProvider = \"testTimestampDataProvider\")\n     public void testTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     {\n-        // using two non-JVM zones so that we don't need to worry what Postgres system zone is\n-        DataTypeTest tests = DataTypeTest.create(true)\n-                .addRoundTrip(timestampDataType(), beforeEpoch)\n-                .addRoundTrip(timestampDataType(), afterEpoch)\n-                .addRoundTrip(timestampDataType(), timeDoubledInJvmZone)\n-                .addRoundTrip(timestampDataType(), timeDoubledInVilnius)\n-                .addRoundTrip(timestampDataType(), epoch) // epoch also is a gap in JVM zone\n-                .addRoundTrip(timestampDataType(), timeGapInJvmZone1)\n-                .addRoundTrip(timestampDataType(), timeGapInJvmZone2)\n-                .addRoundTrip(timestampDataType(), timeGapInVilnius)\n-                .addRoundTrip(timestampDataType(), timeGapInKathmandu);\n+        DataTypeTest tests = DataTypeTest.create(true);\n+        for (int precision : List.of(3, 6)) {\n+            // test all standard cases with precision 3 and 6 to make sure the long and short TIMESTAMP WITH TIME ZONE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1MzI1Mg=="}, "originalCommit": null, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MDkyODEyOnYy", "diffSide": "RIGHT", "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODoyMDoyOFrOHPohbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOTozNzozOVrOHPreFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1NDYwNw==", "bodyText": "this belong to Simplify flow in timestamp with timezone mapping tests commit?", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486154607", "createdAt": "2020-09-10T08:20:28Z", "author": {"login": "findepi"}, "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1032,32 +1046,50 @@ public void testTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     @Test(dataProvider = \"testTimestampDataProvider\")\n     public void testArrayTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     {\n-        DataType<List<LocalDateTime>> dataType;\n-        DataSetup dataSetup;\n-        if (insertWithPresto) {\n-            dataType = arrayDataType(timestampDataType());\n-            dataSetup = prestoCreateAsSelect(sessionWithArrayAsArray(), \"test_array_timestamp\");\n-        }\n-        else {\n-            dataType = arrayDataType(timestampDataType(), \"timestamp[]\");\n-            dataSetup = postgresCreateAndInsert(\"tpch.test_array_timestamp\");\n+        DataTypeTest tests = DataTypeTest.create(true);\n+        for (int precision : List.of(3, 6)) {\n+            // test all standard cases with precision 3 and 6 to make sure the long and short TIMESTAMP WITH TIME ZONE\n+            // is gap friendly.\n+            DataType<List<LocalDateTime>> dataType = arrayOfTimestampDataType(precision, insertWithPresto);\n+            tests.addRoundTrip(dataType, asList(beforeEpoch));\n+            tests.addRoundTrip(dataType, asList(afterEpoch));\n+            tests.addRoundTrip(dataType, asList(timeDoubledInJvmZone));\n+            tests.addRoundTrip(dataType, asList(timeDoubledInVilnius));\n+            tests.addRoundTrip(dataType, asList(epoch));\n+            tests.addRoundTrip(dataType, asList(timeGapInJvmZone1));\n+            tests.addRoundTrip(dataType, asList(timeGapInJvmZone2));\n+            tests.addRoundTrip(dataType, asList(timeGapInVilnius));\n+            tests.addRoundTrip(dataType, asList(timeGapInKathmandu));\n         }\n-        DataTypeTest tests = DataTypeTest.create(true)\n-                .addRoundTrip(dataType, asList(beforeEpoch))\n-                .addRoundTrip(dataType, asList(afterEpoch))\n-                .addRoundTrip(dataType, asList(timeDoubledInJvmZone))\n-                .addRoundTrip(dataType, asList(timeDoubledInVilnius))\n-                .addRoundTrip(dataType, asList(epoch))\n-                .addRoundTrip(dataType, asList(timeGapInJvmZone1))\n-                .addRoundTrip(dataType, asList(timeGapInJvmZone2))\n-                .addRoundTrip(dataType, asList(timeGapInVilnius))\n-                .addRoundTrip(dataType, asList(timeGapInKathmandu));\n+\n+        // test arbitrary time for all supported precisions\n+        tests.addRoundTrip(arrayOfTimestampDataType(1, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 100_000_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(2, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 120_000_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(3, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_000_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(4, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_400_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(5, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_450_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(6, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_456_000)));\n \n         Session session = Session.builder(sessionWithArrayAsArray())\n                 .setTimeZoneKey(TimeZoneKey.getTimeZoneKey(sessionZone.getId()))\n                 .build();\n \n-        tests.execute(getQueryRunner(), session, dataSetup);\n+        if (insertWithPresto) {\n+            tests.execute(getQueryRunner(), session, prestoCreateAsSelect(sessionWithArrayAsArray(), \"test_array_timestamp\"));\n+        }\n+        else {\n+            tests.execute(getQueryRunner(), session, postgresCreateAndInsert(\"tpch.test_array_timestamp\"));\n+        }\n+    }\n+\n+    private DataType<List<LocalDateTime>> arrayOfTimestampDataType(int precision, boolean insertWithPresto)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIwMjkwMw==", "bodyText": "no. This is specific to TIMESTAMP not TIMESTAMP w/TZ. So it belongs to last commit.", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486202903", "createdAt": "2020-09-10T09:37:39Z", "author": {"login": "losipiuk"}, "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1032,32 +1046,50 @@ public void testTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     @Test(dataProvider = \"testTimestampDataProvider\")\n     public void testArrayTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     {\n-        DataType<List<LocalDateTime>> dataType;\n-        DataSetup dataSetup;\n-        if (insertWithPresto) {\n-            dataType = arrayDataType(timestampDataType());\n-            dataSetup = prestoCreateAsSelect(sessionWithArrayAsArray(), \"test_array_timestamp\");\n-        }\n-        else {\n-            dataType = arrayDataType(timestampDataType(), \"timestamp[]\");\n-            dataSetup = postgresCreateAndInsert(\"tpch.test_array_timestamp\");\n+        DataTypeTest tests = DataTypeTest.create(true);\n+        for (int precision : List.of(3, 6)) {\n+            // test all standard cases with precision 3 and 6 to make sure the long and short TIMESTAMP WITH TIME ZONE\n+            // is gap friendly.\n+            DataType<List<LocalDateTime>> dataType = arrayOfTimestampDataType(precision, insertWithPresto);\n+            tests.addRoundTrip(dataType, asList(beforeEpoch));\n+            tests.addRoundTrip(dataType, asList(afterEpoch));\n+            tests.addRoundTrip(dataType, asList(timeDoubledInJvmZone));\n+            tests.addRoundTrip(dataType, asList(timeDoubledInVilnius));\n+            tests.addRoundTrip(dataType, asList(epoch));\n+            tests.addRoundTrip(dataType, asList(timeGapInJvmZone1));\n+            tests.addRoundTrip(dataType, asList(timeGapInJvmZone2));\n+            tests.addRoundTrip(dataType, asList(timeGapInVilnius));\n+            tests.addRoundTrip(dataType, asList(timeGapInKathmandu));\n         }\n-        DataTypeTest tests = DataTypeTest.create(true)\n-                .addRoundTrip(dataType, asList(beforeEpoch))\n-                .addRoundTrip(dataType, asList(afterEpoch))\n-                .addRoundTrip(dataType, asList(timeDoubledInJvmZone))\n-                .addRoundTrip(dataType, asList(timeDoubledInVilnius))\n-                .addRoundTrip(dataType, asList(epoch))\n-                .addRoundTrip(dataType, asList(timeGapInJvmZone1))\n-                .addRoundTrip(dataType, asList(timeGapInJvmZone2))\n-                .addRoundTrip(dataType, asList(timeGapInVilnius))\n-                .addRoundTrip(dataType, asList(timeGapInKathmandu));\n+\n+        // test arbitrary time for all supported precisions\n+        tests.addRoundTrip(arrayOfTimestampDataType(1, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 100_000_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(2, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 120_000_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(3, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_000_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(4, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_400_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(5, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_450_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(6, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_456_000)));\n \n         Session session = Session.builder(sessionWithArrayAsArray())\n                 .setTimeZoneKey(TimeZoneKey.getTimeZoneKey(sessionZone.getId()))\n                 .build();\n \n-        tests.execute(getQueryRunner(), session, dataSetup);\n+        if (insertWithPresto) {\n+            tests.execute(getQueryRunner(), session, prestoCreateAsSelect(sessionWithArrayAsArray(), \"test_array_timestamp\"));\n+        }\n+        else {\n+            tests.execute(getQueryRunner(), session, postgresCreateAndInsert(\"tpch.test_array_timestamp\"));\n+        }\n+    }\n+\n+    private DataType<List<LocalDateTime>> arrayOfTimestampDataType(int precision, boolean insertWithPresto)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1NDYwNw=="}, "originalCommit": null, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MTIzNjIzOnYy", "diffSide": "RIGHT", "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOTozODoxOVrOHPrfcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOTozODoxOVrOHPrfcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIwMzI1MA==", "bodyText": "I will drop this for. As representation is same for 3 and 6 for TIMESTAMP", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486203250", "createdAt": "2020-09-10T09:38:19Z", "author": {"login": "losipiuk"}, "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1032,32 +1046,50 @@ public void testTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     @Test(dataProvider = \"testTimestampDataProvider\")\n     public void testArrayTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     {\n-        DataType<List<LocalDateTime>> dataType;\n-        DataSetup dataSetup;\n-        if (insertWithPresto) {\n-            dataType = arrayDataType(timestampDataType());\n-            dataSetup = prestoCreateAsSelect(sessionWithArrayAsArray(), \"test_array_timestamp\");\n-        }\n-        else {\n-            dataType = arrayDataType(timestampDataType(), \"timestamp[]\");\n-            dataSetup = postgresCreateAndInsert(\"tpch.test_array_timestamp\");\n+        DataTypeTest tests = DataTypeTest.create(true);\n+        for (int precision : List.of(3, 6)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 85}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3187, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}