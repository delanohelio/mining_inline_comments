{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM5MTI5NzMx", "number": 4194, "title": "Ensure that older JDBC clients are compatible with current Presto server", "bodyText": "Fixes #1787", "createdAt": "2020-06-24T10:58:11Z", "url": "https://github.com/trinodb/trino/pull/4194", "merged": true, "mergeCommit": {"oid": "b8c343f8b34fb277e79f6cf6f602b3dbd4e81370"}, "closed": true, "closedAt": "2020-07-31T13:06:06Z", "author": {"login": "wendigo"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcuX9HPABqjM0NzY5NjY3Njg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc6SPoJgBqjM2MDgwMzkzMzA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NTcwNjg2", "url": "https://github.com/trinodb/trino/pull/4194#pullrequestreview-436570686", "createdAt": "2020-06-24T11:48:25Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMTo0ODoyNVrOGoOr-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMTo1Mjo1MFrOGoO0nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDgzNjg1Nw==", "bodyText": "why SNAPSHOT?", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r444836857", "createdAt": "2020-06-24T11:48:25Z", "author": {"login": "kokosing"}, "path": "presto-test-jdbc-compatibility/pom.xml", "diffHunk": "@@ -0,0 +1,95 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>io.prestosql</groupId>\n+        <artifactId>presto-root</artifactId>\n+        <version>337-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>presto-test-jdbc-compatibility</artifactId>\n+    <description>Presto - Tests whether older Presto JDBC clients are compatible with current Presto server</description>\n+\n+    <properties>\n+        <air.main.basedir>${project.parent.basedir}</air.main.basedir>\n+        <dep.presto-jdbc-under-test>335-SNAPSHOT</dep.presto-jdbc-under-test>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDgzNzUyNg==", "bodyText": "please put dependencies in order, presto, airlift and rest. Order them then alphabetically when reasonable.", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r444837526", "createdAt": "2020-06-24T11:49:45Z", "author": {"login": "kokosing"}, "path": "presto-test-jdbc-compatibility/pom.xml", "diffHunk": "@@ -0,0 +1,95 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>io.prestosql</groupId>\n+        <artifactId>presto-root</artifactId>\n+        <version>337-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>presto-test-jdbc-compatibility</artifactId>\n+    <description>Presto - Tests whether older Presto JDBC clients are compatible with current Presto server</description>\n+\n+    <properties>\n+        <air.main.basedir>${project.parent.basedir}</air.main.basedir>\n+        <dep.presto-jdbc-under-test>335-SNAPSHOT</dep.presto-jdbc-under-test>\n+    </properties>\n+\n+    <dependencies>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDgzODQ2NQ==", "bodyText": "Can you add a test that verifies that Presto Server version is matching ${project.version} so we could be sure that we are not using Presto server that comes with presto-jdbc", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r444838465", "createdAt": "2020-06-24T11:51:36Z", "author": {"login": "kokosing"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.Timestamp;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDgzOTA2OQ==", "bodyText": "Can you run also unit tests from presto-jdbc but with different implementation of  io.prestosql.server.testing.TestingPrestoServer?", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r444839069", "createdAt": "2020-06-24T11:52:50Z", "author": {"login": "kokosing"}, "path": "presto-test-jdbc-compatibility/pom.xml", "diffHunk": "@@ -0,0 +1,95 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>io.prestosql</groupId>\n+        <artifactId>presto-root</artifactId>\n+        <version>337-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>presto-test-jdbc-compatibility</artifactId>\n+    <description>Presto - Tests whether older Presto JDBC clients are compatible with current Presto server</description>\n+\n+    <properties>\n+        <air.main.basedir>${project.parent.basedir}</air.main.basedir>\n+        <dep.presto-jdbc-under-test>335-SNAPSHOT</dep.presto-jdbc-under-test>\n+    </properties>\n+\n+    <dependencies>\n+        <!-- Testing -->\n+\n+        <dependency>\n+            <groupId>org.testng</groupId>\n+            <artifactId>testng</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>com.google.guava</groupId>\n+            <artifactId>guava</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>io.airlift</groupId>\n+            <artifactId>configuration</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>io.airlift</groupId>\n+            <artifactId>log-manager</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>io.prestosql</groupId>\n+            <artifactId>presto-main</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.assertj</groupId>\n+            <artifactId>assertj-core</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>io.prestosql</groupId>\n+            <artifactId>presto-jdbc</artifactId>\n+            <version>${dep.presto-jdbc-under-test}</version>\n+            <scope>test</scope>\n+        </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 63}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNDEwMzU1", "url": "https://github.com/trinodb/trino/pull/4194#pullrequestreview-451410355", "createdAt": "2020-07-20T08:44:56Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwODo0NDo1NlrOG0AX1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOToxNTo1MFrOG0BycA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE4NTIzNw==", "bodyText": "why to exclude presto-test-jdbc-compatibility?\nthe module should be compile-able by default", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457185237", "createdAt": "2020-07-20T08:44:56Z", "author": {"login": "findepi"}, "path": ".github/workflows/ci.yml", "diffHunk": "@@ -66,6 +66,20 @@ jobs:\n       - name: Web UI Checks\n         run: presto-main/bin/check_webui.sh\n \n+  test-jdbc-compatibility:\n+    runs-on: ubuntu-latest\n+    steps:\n+      - uses: actions/checkout@v2\n+      - uses: actions/setup-java@v1\n+        with:\n+          java-version: 11\n+      - name: Maven Install\n+        run: |\n+          export MAVEN_OPTS=\"${MAVEN_INSTALL_OPTS}\"\n+          ./bin/retry ./mvnw install ${MAVEN_FAST_INSTALL} -pl '!presto-test-jdbc-compatibility,!presto-docs,!presto-server,!presto-server-rpm'", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE4NjEzNg==", "bodyText": "what does it do?", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457186136", "createdAt": "2020-07-20T08:46:09Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/bin/run_tests.sh", "diffHunk": "@@ -0,0 +1,27 @@\n+#!/bin/bash\n+\n+set -xeuo pipefail\n+trap \"exit\" INT", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE4NzEwMQ==", "bodyText": "you use %/* and /.. to traverse to parent dir. Use one, not both", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457187101", "createdAt": "2020-07-20T08:47:25Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/bin/run_tests.sh", "diffHunk": "@@ -0,0 +1,27 @@\n+#!/bin/bash\n+\n+set -xeuo pipefail\n+trap \"exit\" INT\n+\n+maven=\"${BASH_SOURCE%/*/*}/../mvnw\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE4ODcwNw==", "bodyText": "quote your variables; prefer \"${var}\" over \"$var\".\n(i borrowed this from from https://google.github.io/styleguide/shellguide.html#s5.7-quoting)", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457188707", "createdAt": "2020-07-20T08:49:34Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/bin/run_tests.sh", "diffHunk": "@@ -0,0 +1,27 @@\n+#!/bin/bash\n+\n+set -xeuo pipefail\n+trap \"exit\" INT\n+\n+maven=\"${BASH_SOURCE%/*/*}/../mvnw\"\n+last_n_versions=20\n+\n+$maven -version", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5MjI4Mg==", "bodyText": "instead of skipping modernizer, use -Dair.check.skip-all=true\nperhaps -Dmaven.javadoc.skip=true -Dmaven.source.skip=true can speed things up a little bit", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457192282", "createdAt": "2020-07-20T08:54:14Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/bin/run_tests.sh", "diffHunk": "@@ -0,0 +1,27 @@\n+#!/bin/bash\n+\n+set -xeuo pipefail\n+trap \"exit\" INT\n+\n+maven=\"${BASH_SOURCE%/*/*}/../mvnw\"\n+last_n_versions=20\n+\n+$maven -version\n+\n+current_version=$($maven help:evaluate -Dexpression=project.version -q -DforceStdout)\n+previous_released_version=$((${current_version%-SNAPSHOT}-1))\n+first_tested_version=$((previous_released_version-last_n_versions))\n+\n+echo \"Current version: $current_version\"\n+echo \"Testing versions from $first_tested_version to $previous_released_version\"\n+\n+versions=$(seq \"$first_tested_version\" \"$previous_released_version\")\n+\n+exit_code=0\n+\n+for version in ${versions[*]}; do\n+    PRESTO_JDBC_VERSION=\"${version}\" time $maven -B -pl 'presto-test-jdbc-compatibility' -Ddep.presto-jdbc-under-test=\"${version}\" -Dmodernizer.skip=true clean test || exit_code=1", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5Mjg0Mw==", "bodyText": "Do we know which JDBC version failed the test?", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457192843", "createdAt": "2020-07-20T08:55:00Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/bin/run_tests.sh", "diffHunk": "@@ -0,0 +1,27 @@\n+#!/bin/bash\n+\n+set -xeuo pipefail\n+trap \"exit\" INT\n+\n+maven=\"${BASH_SOURCE%/*/*}/../mvnw\"\n+last_n_versions=20\n+\n+$maven -version\n+\n+current_version=$($maven help:evaluate -Dexpression=project.version -q -DforceStdout)\n+previous_released_version=$((${current_version%-SNAPSHOT}-1))\n+first_tested_version=$((previous_released_version-last_n_versions))\n+\n+echo \"Current version: $current_version\"\n+echo \"Testing versions from $first_tested_version to $previous_released_version\"\n+\n+versions=$(seq \"$first_tested_version\" \"$previous_released_version\")\n+\n+exit_code=0\n+\n+for version in ${versions[*]}; do\n+    PRESTO_JDBC_VERSION=\"${version}\" time $maven -B -pl 'presto-test-jdbc-compatibility' -Ddep.presto-jdbc-under-test=\"${version}\" -Dmodernizer.skip=true clean test || exit_code=1\n+done\n+\n+echo \"$0: exiting with ${exit_code}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5MzM2Mw==", "bodyText": "Why?\nJDBC is supposed to be self-contained, so should not conflict.", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457193363", "createdAt": "2020-07-20T08:55:37Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/pom.xml", "diffHunk": "@@ -0,0 +1,101 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>io.prestosql</groupId>\n+        <artifactId>presto-root</artifactId>\n+        <version>339-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>presto-test-jdbc-compatibility</artifactId>\n+    <description>Presto - Tests whether older Presto JDBC clients are compatible with current Presto server</description>\n+\n+    <properties>\n+        <air.main.basedir>${project.parent.basedir}</air.main.basedir>\n+        <dep.presto-jdbc-under-test>${project.version}</dep.presto-jdbc-under-test>\n+    </properties>\n+\n+    <dependencies>\n+        <!-- Testing -->\n+\n+        <dependency>\n+            <groupId>org.testng</groupId>\n+            <artifactId>testng</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>com.google.guava</groupId>\n+            <artifactId>guava</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>io.airlift</groupId>\n+            <artifactId>configuration</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>io.airlift</groupId>\n+            <artifactId>log</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>io.airlift</groupId>\n+            <artifactId>log-manager</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>io.prestosql</groupId>\n+            <artifactId>presto-main</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>io.prestosql</groupId>\n+            <artifactId>presto-jdbc</artifactId>\n+            <version>${dep.presto-jdbc-under-test}</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.assertj</groupId>\n+            <artifactId>assertj-core</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <pluginManagement>\n+            <plugins>\n+                <plugin>\n+                    <groupId>org.basepom.maven</groupId>\n+                    <artifactId>duplicate-finder-maven-plugin</artifactId>\n+                    <configuration>\n+                        <exceptions>\n+                            <exception>\n+                                <conflictingDependencies>\n+                                    <dependency>\n+                                        <groupId>io.airlift</groupId>\n+                                        <artifactId>units</artifactId>\n+                                    </dependency>\n+                                    <dependency>\n+                                        <groupId>io.prestosql</groupId>\n+                                        <artifactId>presto-jdbc</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5NDA4OQ==", "bodyText": "DEFAULT_PRECISION -> TIMESTAMP_DEFAULT_PRECISION (and an remove comment)", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457194089", "createdAt": "2020-07-20T08:56:34Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> DRIVER_VERSION_TESTED = Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+\n+    private static final int DEFAULT_PRECISION = 3; // milliseconds", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5NDI1NQ==", "bodyText": "TIMESTAMP_MAX_PRECISION", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457194255", "createdAt": "2020-07-20T08:56:47Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> DRIVER_VERSION_TESTED = Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+\n+    private static final int DEFAULT_PRECISION = 3; // milliseconds\n+    private static final int MAX_SQL_PRECISION = 9; // nanoseconds\n+    private static final int MAX_TIMESTAMP_PRECISION = 12; // picoseconds", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5NDc3NA==", "bodyText": "TIMESTAMP_JDBC_MAX_PRECISION ?", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457194774", "createdAt": "2020-07-20T08:57:30Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> DRIVER_VERSION_TESTED = Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+\n+    private static final int DEFAULT_PRECISION = 3; // milliseconds\n+    private static final int MAX_SQL_PRECISION = 9; // nanoseconds", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5NTEyOQ==", "bodyText": "Any particular reason to use this one?", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457195129", "createdAt": "2020-07-20T08:57:55Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> DRIVER_VERSION_TESTED = Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+\n+    private static final int DEFAULT_PRECISION = 3; // milliseconds\n+    private static final int MAX_SQL_PRECISION = 9; // nanoseconds\n+    private static final int MAX_TIMESTAMP_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5NzMxOQ==", "bodyText": "propagate or handle\nalso, java.sql.DatabaseMetaData#getDatabaseMajorVersion seems more appopriate than inspecting the classpath directly", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457197319", "createdAt": "2020-07-20T09:00:44Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> DRIVER_VERSION_TESTED = Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+\n+    private static final int DEFAULT_PRECISION = 3; // milliseconds\n+    private static final int MAX_SQL_PRECISION = 9; // nanoseconds\n+    private static final int MAX_TIMESTAMP_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(PrestoDriver.class.getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT timestamp '2012-10-31 01:00'\";\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testTimestampWithTzSelect()\n+    {\n+        if (driverVersion() == 335 || driverVersion() == 336) {\n+            throw new SkipException(\"Reading timestamp with time zone is broken in 335 and 336\");\n+        }\n+\n+        String query = format(\"SELECT timestamp '2012-10-31 01:00 %s'\", TESTED_TZ);\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-30 10:15:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampAsSqlTimestamp()\n+    {\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(timestamp, precision, MAX_SQL_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementAsTimestamp);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzAsSqlTimestamp()\n+    {\n+        if (driverVersion() == 335 || driverVersion() == 336) {\n+            throw new SkipException(\"Reading timestamp with time zone is broken in 335 and 336\");\n+        }\n+\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+        String localTimestamp = \"2421-01-19 01:10:23.393456298901\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(localTimestamp, precision, MAX_SQL_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementAsTimestamp);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInMap()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s' as TIMESTAMP(%d)))])\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromMap);\n+            assertDescribeType(query, \"map(varchar(9), %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTzTimestampInMap()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE))])\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromMap);\n+            assertDescribeType(query, \"map(varchar(9), %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInArray()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s' as TIMESTAMP(%d))]\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromArray);\n+            assertDescribeType(query, \"array(%s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzInArray()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)]\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromArray);\n+            assertDescribeType(query, \"array(%s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInRow()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s') AS ROW(timestamp TIMESTAMP(%d)))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromRow);\n+            assertDescribeType(query, \"row(timestamp %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTzTimestampInRow()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s %s') AS ROW(timestamp TIMESTAMP(%d) WITH TIME ZONE))\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromRow);\n+            assertDescribeType(query, \"row(timestamp %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampAsString()\n+    {\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getFirstString);\n+            assertDescribeType(query, \"%s\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzAsString()\n+    {\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getFirstString);\n+            assertDescribeType(query, \"%s\", precision, true);\n+        }\n+    }\n+\n+    public void assertQueryResultEquals(String query, Object expectedTimestamp, Function<ResultSet, Object> extractValue)\n+    {\n+        try (ResultSet rs = runQuery(query)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(extractValue.apply(rs)).isEqualTo(expectedTimestamp);\n+            assertThat(rs.next()).isFalse();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void assertDescribeType(String query, String expectedTypePattern, int precision, boolean withTimeZone)\n+    {\n+        assertDescribedInputType(query, format(expectedTypePattern, describeTimestampType(precision, true, withTimeZone)), true);\n+        assertDescribedInputType(query, format(expectedTypePattern, describeTimestampType(precision, false, withTimeZone)), false);\n+        assertDescribedOutputType(query, format(expectedTypePattern, describeTimestampType(precision, true, withTimeZone)), true);\n+        assertDescribedOutputType(query, format(expectedTypePattern, describeTimestampType(precision, false, withTimeZone)), false);\n+    }\n+\n+    private void assertDescribedInputType(String query, String expectedType, boolean ommitPrecision)\n+    {\n+        if (ommitPrecision && !supportsSessionProperties()) {\n+            // Driver does not support setting session properties\n+            return;\n+        }\n+\n+        runConnection(connection -> {\n+            try {\n+                connection.prepareStatement(format(\"SELECT 1 FROM (%s AS timestamp) WHERE timestamp = ?\", query));\n+\n+                try (ResultSet resultSet = connection.prepareStatement(\"DESCRIBE INPUT statement1\").executeQuery()) {\n+                    assertThat(resultSet.next()).isTrue();\n+                    assertThat(resultSet.getString(2)).isEqualTo(expectedType);\n+                }\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }, omitDateTimeTypePrecision(ommitPrecision));\n+    }\n+\n+    private void assertDescribedOutputType(String query, String expectedType, boolean ommitPrecision)\n+    {\n+        if (ommitPrecision && !supportsSessionProperties()) {\n+            // Driver does not support setting session properties\n+            return;\n+        }\n+\n+        runConnection(connection -> {\n+            try {\n+                connection.prepareStatement(query);\n+\n+                try (ResultSet resultSet = connection.prepareStatement(\"DESCRIBE OUTPUT statement1\").executeQuery()) {\n+                    assertThat(resultSet.next()).isTrue();\n+                    assertThat(resultSet.getString(5)).isEqualTo(expectedType);\n+                }\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }, omitDateTimeTypePrecision(ommitPrecision));\n+    }\n+\n+    private static String describeTimestampType(int precision, boolean ommitPrecision, boolean withTimezone)\n+    {\n+        if (ommitPrecision && precision == DEFAULT_PRECISION) {\n+            if (withTimezone) {\n+                return \"timestamp with time zone\";\n+            }\n+\n+            return \"timestamp\";\n+        }\n+\n+        if (withTimezone) {\n+            return format(\"timestamp(%d) with time zone\", precision);\n+        }\n+\n+        return format(\"timestamp(%d)\", precision);\n+    }\n+\n+    private static Timestamp roundedSqlTimestamp(String timestamp, int precision, int maxPrecision)\n+    {\n+        return Timestamp.valueOf(roundedTimestamp(timestamp, precision, maxPrecision));\n+    }\n+\n+    private static String getFirstString(ResultSet resultSet)\n+    {\n+        try {\n+            return resultSet.getString(1);\n+        }\n+        catch (SQLException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromArray(ResultSet resultSet)\n+    {\n+        try {\n+            Array array = resultSet.getArray(1);\n+            return ((Object[]) array.getArray(1, 1))[0];\n+        }\n+        catch (SQLException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromRow(ResultSet resultSet)\n+    {\n+        try {\n+            Map<String, Object> row = (Map<String, Object>) resultSet.getObject(1);\n+            return row.get(\"timestamp\");\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromMap(ResultSet resultSet)\n+    {\n+        try {\n+            Map map = (Map) resultSet.getObject(1);\n+            return map.get(\"timestamp\");\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Timestamp getSingleElementAsTimestamp(ResultSet resultSet)\n+    {\n+        try {\n+            return resultSet.getTimestamp(1);\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static String roundedTimestamp(String timestamp, int precision, int maxPrecision)\n+    {\n+        List<String> parts = Splitter.on('.').splitToList(timestamp);\n+        verify(parts.size() == 2);\n+\n+        BigDecimal fractional = new BigDecimal(format(\"0.%s\", parts.get(1)));\n+\n+        if (determineSupportedPrecision(precision, maxPrecision) == 0) {\n+            return parts.get(0);\n+        }\n+\n+        int timestampDisplayPrecision = determineSupportedPrecision(precision, maxPrecision);\n+        int timestampPrecision = min(precision, maxPrecision);\n+\n+        BigDecimal scaledFractional = fractional\n+                .setScale(timestampPrecision, RoundingMode.HALF_EVEN)\n+                .setScale(timestampDisplayPrecision, RoundingMode.HALF_EVEN);\n+\n+        return format(\"%s.%s\", parts.get(0), scaledFractional.toString().substring(2));\n+    }\n+\n+    private static int determineSupportedPrecision(int precision, int maxPrecision)\n+    {\n+        if (supportsParametricTimestamp()) {\n+            return min(precision, maxPrecision);\n+        }\n+\n+        // Before parametric timestamp was introduced, timestamp had precision = 3\n+        return DEFAULT_PRECISION;\n+    }\n+\n+    private static boolean supportsParametricTimestamp()\n+    {\n+        return driverVersion() == 0 || driverVersion() >= 335;\n+    }\n+\n+    private static int driverVersion()\n+    {\n+        try {\n+            return Integer.valueOf(PrestoDriver.class.getPackage().getImplementationVersion());\n+        }\n+        catch (NumberFormatException ignored) {\n+            return 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 457}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5ODYwOA==", "bodyText": "params -> parameters", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457198608", "createdAt": "2020-07-20T09:02:32Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> DRIVER_VERSION_TESTED = Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+\n+    private static final int DEFAULT_PRECISION = 3; // milliseconds\n+    private static final int MAX_SQL_PRECISION = 9; // nanoseconds\n+    private static final int MAX_TIMESTAMP_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(PrestoDriver.class.getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT timestamp '2012-10-31 01:00'\";\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testTimestampWithTzSelect()\n+    {\n+        if (driverVersion() == 335 || driverVersion() == 336) {\n+            throw new SkipException(\"Reading timestamp with time zone is broken in 335 and 336\");\n+        }\n+\n+        String query = format(\"SELECT timestamp '2012-10-31 01:00 %s'\", TESTED_TZ);\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-30 10:15:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampAsSqlTimestamp()\n+    {\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(timestamp, precision, MAX_SQL_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementAsTimestamp);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzAsSqlTimestamp()\n+    {\n+        if (driverVersion() == 335 || driverVersion() == 336) {\n+            throw new SkipException(\"Reading timestamp with time zone is broken in 335 and 336\");\n+        }\n+\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+        String localTimestamp = \"2421-01-19 01:10:23.393456298901\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(localTimestamp, precision, MAX_SQL_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementAsTimestamp);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInMap()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s' as TIMESTAMP(%d)))])\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromMap);\n+            assertDescribeType(query, \"map(varchar(9), %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTzTimestampInMap()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE))])\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromMap);\n+            assertDescribeType(query, \"map(varchar(9), %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInArray()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s' as TIMESTAMP(%d))]\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromArray);\n+            assertDescribeType(query, \"array(%s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzInArray()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)]\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromArray);\n+            assertDescribeType(query, \"array(%s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInRow()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s') AS ROW(timestamp TIMESTAMP(%d)))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromRow);\n+            assertDescribeType(query, \"row(timestamp %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTzTimestampInRow()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s %s') AS ROW(timestamp TIMESTAMP(%d) WITH TIME ZONE))\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromRow);\n+            assertDescribeType(query, \"row(timestamp %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampAsString()\n+    {\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getFirstString);\n+            assertDescribeType(query, \"%s\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzAsString()\n+    {\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getFirstString);\n+            assertDescribeType(query, \"%s\", precision, true);\n+        }\n+    }\n+\n+    public void assertQueryResultEquals(String query, Object expectedTimestamp, Function<ResultSet, Object> extractValue)\n+    {\n+        try (ResultSet rs = runQuery(query)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(extractValue.apply(rs)).isEqualTo(expectedTimestamp);\n+            assertThat(rs.next()).isFalse();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void assertDescribeType(String query, String expectedTypePattern, int precision, boolean withTimeZone)\n+    {\n+        assertDescribedInputType(query, format(expectedTypePattern, describeTimestampType(precision, true, withTimeZone)), true);\n+        assertDescribedInputType(query, format(expectedTypePattern, describeTimestampType(precision, false, withTimeZone)), false);\n+        assertDescribedOutputType(query, format(expectedTypePattern, describeTimestampType(precision, true, withTimeZone)), true);\n+        assertDescribedOutputType(query, format(expectedTypePattern, describeTimestampType(precision, false, withTimeZone)), false);\n+    }\n+\n+    private void assertDescribedInputType(String query, String expectedType, boolean ommitPrecision)\n+    {\n+        if (ommitPrecision && !supportsSessionProperties()) {\n+            // Driver does not support setting session properties\n+            return;\n+        }\n+\n+        runConnection(connection -> {\n+            try {\n+                connection.prepareStatement(format(\"SELECT 1 FROM (%s AS timestamp) WHERE timestamp = ?\", query));\n+\n+                try (ResultSet resultSet = connection.prepareStatement(\"DESCRIBE INPUT statement1\").executeQuery()) {\n+                    assertThat(resultSet.next()).isTrue();\n+                    assertThat(resultSet.getString(2)).isEqualTo(expectedType);\n+                }\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }, omitDateTimeTypePrecision(ommitPrecision));\n+    }\n+\n+    private void assertDescribedOutputType(String query, String expectedType, boolean ommitPrecision)\n+    {\n+        if (ommitPrecision && !supportsSessionProperties()) {\n+            // Driver does not support setting session properties\n+            return;\n+        }\n+\n+        runConnection(connection -> {\n+            try {\n+                connection.prepareStatement(query);\n+\n+                try (ResultSet resultSet = connection.prepareStatement(\"DESCRIBE OUTPUT statement1\").executeQuery()) {\n+                    assertThat(resultSet.next()).isTrue();\n+                    assertThat(resultSet.getString(5)).isEqualTo(expectedType);\n+                }\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }, omitDateTimeTypePrecision(ommitPrecision));\n+    }\n+\n+    private static String describeTimestampType(int precision, boolean ommitPrecision, boolean withTimezone)\n+    {\n+        if (ommitPrecision && precision == DEFAULT_PRECISION) {\n+            if (withTimezone) {\n+                return \"timestamp with time zone\";\n+            }\n+\n+            return \"timestamp\";\n+        }\n+\n+        if (withTimezone) {\n+            return format(\"timestamp(%d) with time zone\", precision);\n+        }\n+\n+        return format(\"timestamp(%d)\", precision);\n+    }\n+\n+    private static Timestamp roundedSqlTimestamp(String timestamp, int precision, int maxPrecision)\n+    {\n+        return Timestamp.valueOf(roundedTimestamp(timestamp, precision, maxPrecision));\n+    }\n+\n+    private static String getFirstString(ResultSet resultSet)\n+    {\n+        try {\n+            return resultSet.getString(1);\n+        }\n+        catch (SQLException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromArray(ResultSet resultSet)\n+    {\n+        try {\n+            Array array = resultSet.getArray(1);\n+            return ((Object[]) array.getArray(1, 1))[0];\n+        }\n+        catch (SQLException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromRow(ResultSet resultSet)\n+    {\n+        try {\n+            Map<String, Object> row = (Map<String, Object>) resultSet.getObject(1);\n+            return row.get(\"timestamp\");\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromMap(ResultSet resultSet)\n+    {\n+        try {\n+            Map map = (Map) resultSet.getObject(1);\n+            return map.get(\"timestamp\");\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Timestamp getSingleElementAsTimestamp(ResultSet resultSet)\n+    {\n+        try {\n+            return resultSet.getTimestamp(1);\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static String roundedTimestamp(String timestamp, int precision, int maxPrecision)\n+    {\n+        List<String> parts = Splitter.on('.').splitToList(timestamp);\n+        verify(parts.size() == 2);\n+\n+        BigDecimal fractional = new BigDecimal(format(\"0.%s\", parts.get(1)));\n+\n+        if (determineSupportedPrecision(precision, maxPrecision) == 0) {\n+            return parts.get(0);\n+        }\n+\n+        int timestampDisplayPrecision = determineSupportedPrecision(precision, maxPrecision);\n+        int timestampPrecision = min(precision, maxPrecision);\n+\n+        BigDecimal scaledFractional = fractional\n+                .setScale(timestampPrecision, RoundingMode.HALF_EVEN)\n+                .setScale(timestampDisplayPrecision, RoundingMode.HALF_EVEN);\n+\n+        return format(\"%s.%s\", parts.get(0), scaledFractional.toString().substring(2));\n+    }\n+\n+    private static int determineSupportedPrecision(int precision, int maxPrecision)\n+    {\n+        if (supportsParametricTimestamp()) {\n+            return min(precision, maxPrecision);\n+        }\n+\n+        // Before parametric timestamp was introduced, timestamp had precision = 3\n+        return DEFAULT_PRECISION;\n+    }\n+\n+    private static boolean supportsParametricTimestamp()\n+    {\n+        return driverVersion() == 0 || driverVersion() >= 335;\n+    }\n+\n+    private static int driverVersion()\n+    {\n+        try {\n+            return Integer.valueOf(PrestoDriver.class.getPackage().getImplementationVersion());\n+        }\n+        catch (NumberFormatException ignored) {\n+            return 0;\n+        }\n+    }\n+\n+    private ResultSet runQuery(String query)\n+    {\n+        return runQuery(query, ImmutableMap.of());\n+    }\n+\n+    private ResultSet runQuery(String query, Map<String, String> params)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 466}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwMDUzMw==", "bodyText": "introduce a new interface that throws SQLException and use it in assertQueryResultEquals instead of Function\nthis way TestJdbcCompatibility::getSingleElementAsTimestamp will be replaced with ResultSet::getTimestamp.\nLike io.prestosql.plugin.jdbc.ObjectReadFunction.ObjectReadFunctionImplementation", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457200533", "createdAt": "2020-07-20T09:05:03Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> DRIVER_VERSION_TESTED = Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+\n+    private static final int DEFAULT_PRECISION = 3; // milliseconds\n+    private static final int MAX_SQL_PRECISION = 9; // nanoseconds\n+    private static final int MAX_TIMESTAMP_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(PrestoDriver.class.getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT timestamp '2012-10-31 01:00'\";\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwMDcyNg==", "bodyText": "testSelectTimestamp", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457200726", "createdAt": "2020-07-20T09:05:16Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> DRIVER_VERSION_TESTED = Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+\n+    private static final int DEFAULT_PRECISION = 3; // milliseconds\n+    private static final int MAX_SQL_PRECISION = 9; // nanoseconds\n+    private static final int MAX_TIMESTAMP_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(PrestoDriver.class.getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwMDgyNg==", "bodyText": "testSelectTimestampWithTimeZone", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457200826", "createdAt": "2020-07-20T09:05:21Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> DRIVER_VERSION_TESTED = Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+\n+    private static final int DEFAULT_PRECISION = 3; // milliseconds\n+    private static final int MAX_SQL_PRECISION = 9; // nanoseconds\n+    private static final int MAX_TIMESTAMP_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(PrestoDriver.class.getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT timestamp '2012-10-31 01:00'\";\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testTimestampWithTzSelect()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwMTM2Nw==", "bodyText": "Also, besides ResultSet::getTimestamp we could also test ResultSet::getObject.\nSee io.prestosql.jdbc.TestJdbcResultSet#testObjectTypes how this can be structured.\nThis would remove need for *AsSqlTimestamp test methods and make all this a bit more concise.", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457201367", "createdAt": "2020-07-20T09:06:05Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> DRIVER_VERSION_TESTED = Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+\n+    private static final int DEFAULT_PRECISION = 3; // milliseconds\n+    private static final int MAX_SQL_PRECISION = 9; // nanoseconds\n+    private static final int MAX_TIMESTAMP_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(PrestoDriver.class.getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT timestamp '2012-10-31 01:00'\";\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwMzYzMw==", "bodyText": "Use timestamp in the past, unless you want to test handling of future datetimes.\nFuture things can change (subject to tz data changes in the future, eg politics).\nPast (but >=1970) dates are easier to reason about.", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457203633", "createdAt": "2020-07-20T09:09:12Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> DRIVER_VERSION_TESTED = Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+\n+    private static final int DEFAULT_PRECISION = 3; // milliseconds\n+    private static final int MAX_SQL_PRECISION = 9; // nanoseconds\n+    private static final int MAX_TIMESTAMP_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(PrestoDriver.class.getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT timestamp '2012-10-31 01:00'\";\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testTimestampWithTzSelect()\n+    {\n+        if (driverVersion() == 335 || driverVersion() == 336) {\n+            throw new SkipException(\"Reading timestamp with time zone is broken in 335 and 336\");\n+        }\n+\n+        String query = format(\"SELECT timestamp '2012-10-31 01:00 %s'\", TESTED_TZ);\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-30 10:15:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampAsSqlTimestamp()\n+    {\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(timestamp, precision, MAX_SQL_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementAsTimestamp);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzAsSqlTimestamp()\n+    {\n+        if (driverVersion() == 335 || driverVersion() == 336) {\n+            throw new SkipException(\"Reading timestamp with time zone is broken in 335 and 336\");\n+        }\n+\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+        String localTimestamp = \"2421-01-19 01:10:23.393456298901\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(localTimestamp, precision, MAX_SQL_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementAsTimestamp);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInMap()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwNDMwNg==", "bodyText": "All drivers allow setting session properties.\nDo you mean some particular properties here?", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457204306", "createdAt": "2020-07-20T09:10:14Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> DRIVER_VERSION_TESTED = Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+\n+    private static final int DEFAULT_PRECISION = 3; // milliseconds\n+    private static final int MAX_SQL_PRECISION = 9; // nanoseconds\n+    private static final int MAX_TIMESTAMP_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(PrestoDriver.class.getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT timestamp '2012-10-31 01:00'\";\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testTimestampWithTzSelect()\n+    {\n+        if (driverVersion() == 335 || driverVersion() == 336) {\n+            throw new SkipException(\"Reading timestamp with time zone is broken in 335 and 336\");\n+        }\n+\n+        String query = format(\"SELECT timestamp '2012-10-31 01:00 %s'\", TESTED_TZ);\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-30 10:15:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampAsSqlTimestamp()\n+    {\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(timestamp, precision, MAX_SQL_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementAsTimestamp);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzAsSqlTimestamp()\n+    {\n+        if (driverVersion() == 335 || driverVersion() == 336) {\n+            throw new SkipException(\"Reading timestamp with time zone is broken in 335 and 336\");\n+        }\n+\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+        String localTimestamp = \"2421-01-19 01:10:23.393456298901\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(localTimestamp, precision, MAX_SQL_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementAsTimestamp);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInMap()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s' as TIMESTAMP(%d)))])\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromMap);\n+            assertDescribeType(query, \"map(varchar(9), %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTzTimestampInMap()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE))])\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromMap);\n+            assertDescribeType(query, \"map(varchar(9), %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInArray()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s' as TIMESTAMP(%d))]\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromArray);\n+            assertDescribeType(query, \"array(%s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzInArray()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)]\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromArray);\n+            assertDescribeType(query, \"array(%s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInRow()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s') AS ROW(timestamp TIMESTAMP(%d)))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromRow);\n+            assertDescribeType(query, \"row(timestamp %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTzTimestampInRow()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s %s') AS ROW(timestamp TIMESTAMP(%d) WITH TIME ZONE))\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromRow);\n+            assertDescribeType(query, \"row(timestamp %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampAsString()\n+    {\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getFirstString);\n+            assertDescribeType(query, \"%s\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzAsString()\n+    {\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getFirstString);\n+            assertDescribeType(query, \"%s\", precision, true);\n+        }\n+    }\n+\n+    public void assertQueryResultEquals(String query, Object expectedTimestamp, Function<ResultSet, Object> extractValue)\n+    {\n+        try (ResultSet rs = runQuery(query)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(extractValue.apply(rs)).isEqualTo(expectedTimestamp);\n+            assertThat(rs.next()).isFalse();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void assertDescribeType(String query, String expectedTypePattern, int precision, boolean withTimeZone)\n+    {\n+        assertDescribedInputType(query, format(expectedTypePattern, describeTimestampType(precision, true, withTimeZone)), true);\n+        assertDescribedInputType(query, format(expectedTypePattern, describeTimestampType(precision, false, withTimeZone)), false);\n+        assertDescribedOutputType(query, format(expectedTypePattern, describeTimestampType(precision, true, withTimeZone)), true);\n+        assertDescribedOutputType(query, format(expectedTypePattern, describeTimestampType(precision, false, withTimeZone)), false);\n+    }\n+\n+    private void assertDescribedInputType(String query, String expectedType, boolean ommitPrecision)\n+    {\n+        if (ommitPrecision && !supportsSessionProperties()) {\n+            // Driver does not support setting session properties", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwNTA1NQ==", "bodyText": "runConnection -> useConnection (following JDBI naming here)\nparams -> connectionParameters\nmake consumer go after parameters (it's logically after)", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457205055", "createdAt": "2020-07-20T09:11:15Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> DRIVER_VERSION_TESTED = Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+\n+    private static final int DEFAULT_PRECISION = 3; // milliseconds\n+    private static final int MAX_SQL_PRECISION = 9; // nanoseconds\n+    private static final int MAX_TIMESTAMP_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(PrestoDriver.class.getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT timestamp '2012-10-31 01:00'\";\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testTimestampWithTzSelect()\n+    {\n+        if (driverVersion() == 335 || driverVersion() == 336) {\n+            throw new SkipException(\"Reading timestamp with time zone is broken in 335 and 336\");\n+        }\n+\n+        String query = format(\"SELECT timestamp '2012-10-31 01:00 %s'\", TESTED_TZ);\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-30 10:15:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampAsSqlTimestamp()\n+    {\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(timestamp, precision, MAX_SQL_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementAsTimestamp);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzAsSqlTimestamp()\n+    {\n+        if (driverVersion() == 335 || driverVersion() == 336) {\n+            throw new SkipException(\"Reading timestamp with time zone is broken in 335 and 336\");\n+        }\n+\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+        String localTimestamp = \"2421-01-19 01:10:23.393456298901\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(localTimestamp, precision, MAX_SQL_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementAsTimestamp);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInMap()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s' as TIMESTAMP(%d)))])\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromMap);\n+            assertDescribeType(query, \"map(varchar(9), %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTzTimestampInMap()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE))])\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromMap);\n+            assertDescribeType(query, \"map(varchar(9), %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInArray()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s' as TIMESTAMP(%d))]\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromArray);\n+            assertDescribeType(query, \"array(%s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzInArray()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)]\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromArray);\n+            assertDescribeType(query, \"array(%s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInRow()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s') AS ROW(timestamp TIMESTAMP(%d)))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromRow);\n+            assertDescribeType(query, \"row(timestamp %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTzTimestampInRow()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s %s') AS ROW(timestamp TIMESTAMP(%d) WITH TIME ZONE))\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromRow);\n+            assertDescribeType(query, \"row(timestamp %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampAsString()\n+    {\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getFirstString);\n+            assertDescribeType(query, \"%s\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzAsString()\n+    {\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getFirstString);\n+            assertDescribeType(query, \"%s\", precision, true);\n+        }\n+    }\n+\n+    public void assertQueryResultEquals(String query, Object expectedTimestamp, Function<ResultSet, Object> extractValue)\n+    {\n+        try (ResultSet rs = runQuery(query)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(extractValue.apply(rs)).isEqualTo(expectedTimestamp);\n+            assertThat(rs.next()).isFalse();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void assertDescribeType(String query, String expectedTypePattern, int precision, boolean withTimeZone)\n+    {\n+        assertDescribedInputType(query, format(expectedTypePattern, describeTimestampType(precision, true, withTimeZone)), true);\n+        assertDescribedInputType(query, format(expectedTypePattern, describeTimestampType(precision, false, withTimeZone)), false);\n+        assertDescribedOutputType(query, format(expectedTypePattern, describeTimestampType(precision, true, withTimeZone)), true);\n+        assertDescribedOutputType(query, format(expectedTypePattern, describeTimestampType(precision, false, withTimeZone)), false);\n+    }\n+\n+    private void assertDescribedInputType(String query, String expectedType, boolean ommitPrecision)\n+    {\n+        if (ommitPrecision && !supportsSessionProperties()) {\n+            // Driver does not support setting session properties\n+            return;\n+        }\n+\n+        runConnection(connection -> {\n+            try {\n+                connection.prepareStatement(format(\"SELECT 1 FROM (%s AS timestamp) WHERE timestamp = ?\", query));\n+\n+                try (ResultSet resultSet = connection.prepareStatement(\"DESCRIBE INPUT statement1\").executeQuery()) {\n+                    assertThat(resultSet.next()).isTrue();\n+                    assertThat(resultSet.getString(2)).isEqualTo(expectedType);\n+                }\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }, omitDateTimeTypePrecision(ommitPrecision));\n+    }\n+\n+    private void assertDescribedOutputType(String query, String expectedType, boolean ommitPrecision)\n+    {\n+        if (ommitPrecision && !supportsSessionProperties()) {\n+            // Driver does not support setting session properties\n+            return;\n+        }\n+\n+        runConnection(connection -> {\n+            try {\n+                connection.prepareStatement(query);\n+\n+                try (ResultSet resultSet = connection.prepareStatement(\"DESCRIBE OUTPUT statement1\").executeQuery()) {\n+                    assertThat(resultSet.next()).isTrue();\n+                    assertThat(resultSet.getString(5)).isEqualTo(expectedType);\n+                }\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }, omitDateTimeTypePrecision(ommitPrecision));\n+    }\n+\n+    private static String describeTimestampType(int precision, boolean ommitPrecision, boolean withTimezone)\n+    {\n+        if (ommitPrecision && precision == DEFAULT_PRECISION) {\n+            if (withTimezone) {\n+                return \"timestamp with time zone\";\n+            }\n+\n+            return \"timestamp\";\n+        }\n+\n+        if (withTimezone) {\n+            return format(\"timestamp(%d) with time zone\", precision);\n+        }\n+\n+        return format(\"timestamp(%d)\", precision);\n+    }\n+\n+    private static Timestamp roundedSqlTimestamp(String timestamp, int precision, int maxPrecision)\n+    {\n+        return Timestamp.valueOf(roundedTimestamp(timestamp, precision, maxPrecision));\n+    }\n+\n+    private static String getFirstString(ResultSet resultSet)\n+    {\n+        try {\n+            return resultSet.getString(1);\n+        }\n+        catch (SQLException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromArray(ResultSet resultSet)\n+    {\n+        try {\n+            Array array = resultSet.getArray(1);\n+            return ((Object[]) array.getArray(1, 1))[0];\n+        }\n+        catch (SQLException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromRow(ResultSet resultSet)\n+    {\n+        try {\n+            Map<String, Object> row = (Map<String, Object>) resultSet.getObject(1);\n+            return row.get(\"timestamp\");\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromMap(ResultSet resultSet)\n+    {\n+        try {\n+            Map map = (Map) resultSet.getObject(1);\n+            return map.get(\"timestamp\");\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Timestamp getSingleElementAsTimestamp(ResultSet resultSet)\n+    {\n+        try {\n+            return resultSet.getTimestamp(1);\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static String roundedTimestamp(String timestamp, int precision, int maxPrecision)\n+    {\n+        List<String> parts = Splitter.on('.').splitToList(timestamp);\n+        verify(parts.size() == 2);\n+\n+        BigDecimal fractional = new BigDecimal(format(\"0.%s\", parts.get(1)));\n+\n+        if (determineSupportedPrecision(precision, maxPrecision) == 0) {\n+            return parts.get(0);\n+        }\n+\n+        int timestampDisplayPrecision = determineSupportedPrecision(precision, maxPrecision);\n+        int timestampPrecision = min(precision, maxPrecision);\n+\n+        BigDecimal scaledFractional = fractional\n+                .setScale(timestampPrecision, RoundingMode.HALF_EVEN)\n+                .setScale(timestampDisplayPrecision, RoundingMode.HALF_EVEN);\n+\n+        return format(\"%s.%s\", parts.get(0), scaledFractional.toString().substring(2));\n+    }\n+\n+    private static int determineSupportedPrecision(int precision, int maxPrecision)\n+    {\n+        if (supportsParametricTimestamp()) {\n+            return min(precision, maxPrecision);\n+        }\n+\n+        // Before parametric timestamp was introduced, timestamp had precision = 3\n+        return DEFAULT_PRECISION;\n+    }\n+\n+    private static boolean supportsParametricTimestamp()\n+    {\n+        return driverVersion() == 0 || driverVersion() >= 335;\n+    }\n+\n+    private static int driverVersion()\n+    {\n+        try {\n+            return Integer.valueOf(PrestoDriver.class.getPackage().getImplementationVersion());\n+        }\n+        catch (NumberFormatException ignored) {\n+            return 0;\n+        }\n+    }\n+\n+    private ResultSet runQuery(String query)\n+    {\n+        return runQuery(query, ImmutableMap.of());\n+    }\n+\n+    private ResultSet runQuery(String query, Map<String, String> params)\n+    {\n+        Properties properties = new Properties();\n+        properties.putAll(params);\n+        properties.put(\"user\", \"test\");\n+        properties.put(\"password\", \"\");\n+\n+        try (Connection conn = DriverManager.getConnection(serverUrl, properties); PreparedStatement stmt = conn.prepareStatement(query)) {\n+            return stmt.executeQuery();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void runConnection(Consumer<Connection> consumer, Map<String, String> params)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 481}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwNjQ0Mw==", "bodyText": "conn -> connection", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457206443", "createdAt": "2020-07-20T09:13:12Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> DRIVER_VERSION_TESTED = Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+\n+    private static final int DEFAULT_PRECISION = 3; // milliseconds\n+    private static final int MAX_SQL_PRECISION = 9; // nanoseconds\n+    private static final int MAX_TIMESTAMP_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(PrestoDriver.class.getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT timestamp '2012-10-31 01:00'\";\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testTimestampWithTzSelect()\n+    {\n+        if (driverVersion() == 335 || driverVersion() == 336) {\n+            throw new SkipException(\"Reading timestamp with time zone is broken in 335 and 336\");\n+        }\n+\n+        String query = format(\"SELECT timestamp '2012-10-31 01:00 %s'\", TESTED_TZ);\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-30 10:15:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampAsSqlTimestamp()\n+    {\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(timestamp, precision, MAX_SQL_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementAsTimestamp);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzAsSqlTimestamp()\n+    {\n+        if (driverVersion() == 335 || driverVersion() == 336) {\n+            throw new SkipException(\"Reading timestamp with time zone is broken in 335 and 336\");\n+        }\n+\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+        String localTimestamp = \"2421-01-19 01:10:23.393456298901\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(localTimestamp, precision, MAX_SQL_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementAsTimestamp);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInMap()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s' as TIMESTAMP(%d)))])\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromMap);\n+            assertDescribeType(query, \"map(varchar(9), %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTzTimestampInMap()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE))])\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromMap);\n+            assertDescribeType(query, \"map(varchar(9), %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInArray()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s' as TIMESTAMP(%d))]\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromArray);\n+            assertDescribeType(query, \"array(%s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzInArray()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)]\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromArray);\n+            assertDescribeType(query, \"array(%s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInRow()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s') AS ROW(timestamp TIMESTAMP(%d)))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromRow);\n+            assertDescribeType(query, \"row(timestamp %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTzTimestampInRow()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s %s') AS ROW(timestamp TIMESTAMP(%d) WITH TIME ZONE))\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromRow);\n+            assertDescribeType(query, \"row(timestamp %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampAsString()\n+    {\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getFirstString);\n+            assertDescribeType(query, \"%s\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzAsString()\n+    {\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getFirstString);\n+            assertDescribeType(query, \"%s\", precision, true);\n+        }\n+    }\n+\n+    public void assertQueryResultEquals(String query, Object expectedTimestamp, Function<ResultSet, Object> extractValue)\n+    {\n+        try (ResultSet rs = runQuery(query)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(extractValue.apply(rs)).isEqualTo(expectedTimestamp);\n+            assertThat(rs.next()).isFalse();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void assertDescribeType(String query, String expectedTypePattern, int precision, boolean withTimeZone)\n+    {\n+        assertDescribedInputType(query, format(expectedTypePattern, describeTimestampType(precision, true, withTimeZone)), true);\n+        assertDescribedInputType(query, format(expectedTypePattern, describeTimestampType(precision, false, withTimeZone)), false);\n+        assertDescribedOutputType(query, format(expectedTypePattern, describeTimestampType(precision, true, withTimeZone)), true);\n+        assertDescribedOutputType(query, format(expectedTypePattern, describeTimestampType(precision, false, withTimeZone)), false);\n+    }\n+\n+    private void assertDescribedInputType(String query, String expectedType, boolean ommitPrecision)\n+    {\n+        if (ommitPrecision && !supportsSessionProperties()) {\n+            // Driver does not support setting session properties\n+            return;\n+        }\n+\n+        runConnection(connection -> {\n+            try {\n+                connection.prepareStatement(format(\"SELECT 1 FROM (%s AS timestamp) WHERE timestamp = ?\", query));\n+\n+                try (ResultSet resultSet = connection.prepareStatement(\"DESCRIBE INPUT statement1\").executeQuery()) {\n+                    assertThat(resultSet.next()).isTrue();\n+                    assertThat(resultSet.getString(2)).isEqualTo(expectedType);\n+                }\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }, omitDateTimeTypePrecision(ommitPrecision));\n+    }\n+\n+    private void assertDescribedOutputType(String query, String expectedType, boolean ommitPrecision)\n+    {\n+        if (ommitPrecision && !supportsSessionProperties()) {\n+            // Driver does not support setting session properties\n+            return;\n+        }\n+\n+        runConnection(connection -> {\n+            try {\n+                connection.prepareStatement(query);\n+\n+                try (ResultSet resultSet = connection.prepareStatement(\"DESCRIBE OUTPUT statement1\").executeQuery()) {\n+                    assertThat(resultSet.next()).isTrue();\n+                    assertThat(resultSet.getString(5)).isEqualTo(expectedType);\n+                }\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }, omitDateTimeTypePrecision(ommitPrecision));\n+    }\n+\n+    private static String describeTimestampType(int precision, boolean ommitPrecision, boolean withTimezone)\n+    {\n+        if (ommitPrecision && precision == DEFAULT_PRECISION) {\n+            if (withTimezone) {\n+                return \"timestamp with time zone\";\n+            }\n+\n+            return \"timestamp\";\n+        }\n+\n+        if (withTimezone) {\n+            return format(\"timestamp(%d) with time zone\", precision);\n+        }\n+\n+        return format(\"timestamp(%d)\", precision);\n+    }\n+\n+    private static Timestamp roundedSqlTimestamp(String timestamp, int precision, int maxPrecision)\n+    {\n+        return Timestamp.valueOf(roundedTimestamp(timestamp, precision, maxPrecision));\n+    }\n+\n+    private static String getFirstString(ResultSet resultSet)\n+    {\n+        try {\n+            return resultSet.getString(1);\n+        }\n+        catch (SQLException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromArray(ResultSet resultSet)\n+    {\n+        try {\n+            Array array = resultSet.getArray(1);\n+            return ((Object[]) array.getArray(1, 1))[0];\n+        }\n+        catch (SQLException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromRow(ResultSet resultSet)\n+    {\n+        try {\n+            Map<String, Object> row = (Map<String, Object>) resultSet.getObject(1);\n+            return row.get(\"timestamp\");\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromMap(ResultSet resultSet)\n+    {\n+        try {\n+            Map map = (Map) resultSet.getObject(1);\n+            return map.get(\"timestamp\");\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Timestamp getSingleElementAsTimestamp(ResultSet resultSet)\n+    {\n+        try {\n+            return resultSet.getTimestamp(1);\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static String roundedTimestamp(String timestamp, int precision, int maxPrecision)\n+    {\n+        List<String> parts = Splitter.on('.').splitToList(timestamp);\n+        verify(parts.size() == 2);\n+\n+        BigDecimal fractional = new BigDecimal(format(\"0.%s\", parts.get(1)));\n+\n+        if (determineSupportedPrecision(precision, maxPrecision) == 0) {\n+            return parts.get(0);\n+        }\n+\n+        int timestampDisplayPrecision = determineSupportedPrecision(precision, maxPrecision);\n+        int timestampPrecision = min(precision, maxPrecision);\n+\n+        BigDecimal scaledFractional = fractional\n+                .setScale(timestampPrecision, RoundingMode.HALF_EVEN)\n+                .setScale(timestampDisplayPrecision, RoundingMode.HALF_EVEN);\n+\n+        return format(\"%s.%s\", parts.get(0), scaledFractional.toString().substring(2));\n+    }\n+\n+    private static int determineSupportedPrecision(int precision, int maxPrecision)\n+    {\n+        if (supportsParametricTimestamp()) {\n+            return min(precision, maxPrecision);\n+        }\n+\n+        // Before parametric timestamp was introduced, timestamp had precision = 3\n+        return DEFAULT_PRECISION;\n+    }\n+\n+    private static boolean supportsParametricTimestamp()\n+    {\n+        return driverVersion() == 0 || driverVersion() >= 335;\n+    }\n+\n+    private static int driverVersion()\n+    {\n+        try {\n+            return Integer.valueOf(PrestoDriver.class.getPackage().getImplementationVersion());\n+        }\n+        catch (NumberFormatException ignored) {\n+            return 0;\n+        }\n+    }\n+\n+    private ResultSet runQuery(String query)\n+    {\n+        return runQuery(query, ImmutableMap.of());\n+    }\n+\n+    private ResultSet runQuery(String query, Map<String, String> params)\n+    {\n+        Properties properties = new Properties();\n+        properties.putAll(params);\n+        properties.put(\"user\", \"test\");\n+        properties.put(\"password\", \"\");\n+\n+        try (Connection conn = DriverManager.getConnection(serverUrl, properties); PreparedStatement stmt = conn.prepareStatement(query)) {\n+            return stmt.executeQuery();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void runConnection(Consumer<Connection> consumer, Map<String, String> params)\n+    {\n+        Properties properties = new Properties();\n+        properties.putAll(params);\n+        properties.put(\"user\", \"test\");\n+        properties.put(\"password\", \"\");\n+\n+        try (Connection conn = DriverManager.getConnection(serverUrl, properties)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 488}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwNjc5OQ==", "bodyText": "unused", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457206799", "createdAt": "2020-07-20T09:13:41Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> DRIVER_VERSION_TESTED = Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+\n+    private static final int DEFAULT_PRECISION = 3; // milliseconds\n+    private static final int MAX_SQL_PRECISION = 9; // nanoseconds\n+    private static final int MAX_TIMESTAMP_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(PrestoDriver.class.getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT timestamp '2012-10-31 01:00'\";\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testTimestampWithTzSelect()\n+    {\n+        if (driverVersion() == 335 || driverVersion() == 336) {\n+            throw new SkipException(\"Reading timestamp with time zone is broken in 335 and 336\");\n+        }\n+\n+        String query = format(\"SELECT timestamp '2012-10-31 01:00 %s'\", TESTED_TZ);\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-30 10:15:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampAsSqlTimestamp()\n+    {\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(timestamp, precision, MAX_SQL_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementAsTimestamp);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzAsSqlTimestamp()\n+    {\n+        if (driverVersion() == 335 || driverVersion() == 336) {\n+            throw new SkipException(\"Reading timestamp with time zone is broken in 335 and 336\");\n+        }\n+\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+        String localTimestamp = \"2421-01-19 01:10:23.393456298901\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(localTimestamp, precision, MAX_SQL_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementAsTimestamp);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInMap()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s' as TIMESTAMP(%d)))])\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromMap);\n+            assertDescribeType(query, \"map(varchar(9), %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTzTimestampInMap()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE))])\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromMap);\n+            assertDescribeType(query, \"map(varchar(9), %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInArray()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s' as TIMESTAMP(%d))]\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromArray);\n+            assertDescribeType(query, \"array(%s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzInArray()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)]\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromArray);\n+            assertDescribeType(query, \"array(%s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInRow()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s') AS ROW(timestamp TIMESTAMP(%d)))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromRow);\n+            assertDescribeType(query, \"row(timestamp %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTzTimestampInRow()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s %s') AS ROW(timestamp TIMESTAMP(%d) WITH TIME ZONE))\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromRow);\n+            assertDescribeType(query, \"row(timestamp %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampAsString()\n+    {\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getFirstString);\n+            assertDescribeType(query, \"%s\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzAsString()\n+    {\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getFirstString);\n+            assertDescribeType(query, \"%s\", precision, true);\n+        }\n+    }\n+\n+    public void assertQueryResultEquals(String query, Object expectedTimestamp, Function<ResultSet, Object> extractValue)\n+    {\n+        try (ResultSet rs = runQuery(query)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(extractValue.apply(rs)).isEqualTo(expectedTimestamp);\n+            assertThat(rs.next()).isFalse();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void assertDescribeType(String query, String expectedTypePattern, int precision, boolean withTimeZone)\n+    {\n+        assertDescribedInputType(query, format(expectedTypePattern, describeTimestampType(precision, true, withTimeZone)), true);\n+        assertDescribedInputType(query, format(expectedTypePattern, describeTimestampType(precision, false, withTimeZone)), false);\n+        assertDescribedOutputType(query, format(expectedTypePattern, describeTimestampType(precision, true, withTimeZone)), true);\n+        assertDescribedOutputType(query, format(expectedTypePattern, describeTimestampType(precision, false, withTimeZone)), false);\n+    }\n+\n+    private void assertDescribedInputType(String query, String expectedType, boolean ommitPrecision)\n+    {\n+        if (ommitPrecision && !supportsSessionProperties()) {\n+            // Driver does not support setting session properties\n+            return;\n+        }\n+\n+        runConnection(connection -> {\n+            try {\n+                connection.prepareStatement(format(\"SELECT 1 FROM (%s AS timestamp) WHERE timestamp = ?\", query));\n+\n+                try (ResultSet resultSet = connection.prepareStatement(\"DESCRIBE INPUT statement1\").executeQuery()) {\n+                    assertThat(resultSet.next()).isTrue();\n+                    assertThat(resultSet.getString(2)).isEqualTo(expectedType);\n+                }\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }, omitDateTimeTypePrecision(ommitPrecision));\n+    }\n+\n+    private void assertDescribedOutputType(String query, String expectedType, boolean ommitPrecision)\n+    {\n+        if (ommitPrecision && !supportsSessionProperties()) {\n+            // Driver does not support setting session properties\n+            return;\n+        }\n+\n+        runConnection(connection -> {\n+            try {\n+                connection.prepareStatement(query);\n+\n+                try (ResultSet resultSet = connection.prepareStatement(\"DESCRIBE OUTPUT statement1\").executeQuery()) {\n+                    assertThat(resultSet.next()).isTrue();\n+                    assertThat(resultSet.getString(5)).isEqualTo(expectedType);\n+                }\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }, omitDateTimeTypePrecision(ommitPrecision));\n+    }\n+\n+    private static String describeTimestampType(int precision, boolean ommitPrecision, boolean withTimezone)\n+    {\n+        if (ommitPrecision && precision == DEFAULT_PRECISION) {\n+            if (withTimezone) {\n+                return \"timestamp with time zone\";\n+            }\n+\n+            return \"timestamp\";\n+        }\n+\n+        if (withTimezone) {\n+            return format(\"timestamp(%d) with time zone\", precision);\n+        }\n+\n+        return format(\"timestamp(%d)\", precision);\n+    }\n+\n+    private static Timestamp roundedSqlTimestamp(String timestamp, int precision, int maxPrecision)\n+    {\n+        return Timestamp.valueOf(roundedTimestamp(timestamp, precision, maxPrecision));\n+    }\n+\n+    private static String getFirstString(ResultSet resultSet)\n+    {\n+        try {\n+            return resultSet.getString(1);\n+        }\n+        catch (SQLException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromArray(ResultSet resultSet)\n+    {\n+        try {\n+            Array array = resultSet.getArray(1);\n+            return ((Object[]) array.getArray(1, 1))[0];\n+        }\n+        catch (SQLException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromRow(ResultSet resultSet)\n+    {\n+        try {\n+            Map<String, Object> row = (Map<String, Object>) resultSet.getObject(1);\n+            return row.get(\"timestamp\");\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromMap(ResultSet resultSet)\n+    {\n+        try {\n+            Map map = (Map) resultSet.getObject(1);\n+            return map.get(\"timestamp\");\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Timestamp getSingleElementAsTimestamp(ResultSet resultSet)\n+    {\n+        try {\n+            return resultSet.getTimestamp(1);\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static String roundedTimestamp(String timestamp, int precision, int maxPrecision)\n+    {\n+        List<String> parts = Splitter.on('.').splitToList(timestamp);\n+        verify(parts.size() == 2);\n+\n+        BigDecimal fractional = new BigDecimal(format(\"0.%s\", parts.get(1)));\n+\n+        if (determineSupportedPrecision(precision, maxPrecision) == 0) {\n+            return parts.get(0);\n+        }\n+\n+        int timestampDisplayPrecision = determineSupportedPrecision(precision, maxPrecision);\n+        int timestampPrecision = min(precision, maxPrecision);\n+\n+        BigDecimal scaledFractional = fractional\n+                .setScale(timestampPrecision, RoundingMode.HALF_EVEN)\n+                .setScale(timestampDisplayPrecision, RoundingMode.HALF_EVEN);\n+\n+        return format(\"%s.%s\", parts.get(0), scaledFractional.toString().substring(2));\n+    }\n+\n+    private static int determineSupportedPrecision(int precision, int maxPrecision)\n+    {\n+        if (supportsParametricTimestamp()) {\n+            return min(precision, maxPrecision);\n+        }\n+\n+        // Before parametric timestamp was introduced, timestamp had precision = 3\n+        return DEFAULT_PRECISION;\n+    }\n+\n+    private static boolean supportsParametricTimestamp()\n+    {\n+        return driverVersion() == 0 || driverVersion() >= 335;\n+    }\n+\n+    private static int driverVersion()\n+    {\n+        try {\n+            return Integer.valueOf(PrestoDriver.class.getPackage().getImplementationVersion());\n+        }\n+        catch (NumberFormatException ignored) {\n+            return 0;\n+        }\n+    }\n+\n+    private ResultSet runQuery(String query)\n+    {\n+        return runQuery(query, ImmutableMap.of());\n+    }\n+\n+    private ResultSet runQuery(String query, Map<String, String> params)\n+    {\n+        Properties properties = new Properties();\n+        properties.putAll(params);\n+        properties.put(\"user\", \"test\");\n+        properties.put(\"password\", \"\");\n+\n+        try (Connection conn = DriverManager.getConnection(serverUrl, properties); PreparedStatement stmt = conn.prepareStatement(query)) {\n+            return stmt.executeQuery();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void runConnection(Consumer<Connection> consumer, Map<String, String> params)\n+    {\n+        Properties properties = new Properties();\n+        properties.putAll(params);\n+        properties.put(\"user\", \"test\");\n+        properties.put(\"password\", \"\");\n+\n+        try (Connection conn = DriverManager.getConnection(serverUrl, properties)) {\n+            consumer.accept(conn);\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Map<String, String> omitDateTimeTypePrecision(boolean ommit)\n+    {\n+        if (!ommit) {\n+            return ImmutableMap.of();\n+        }\n+\n+        return ImmutableMap.of(\"sessionProperties\", format(\"omit_datetime_type_precision:%b\", ommit));\n+    }\n+\n+    private boolean supportsSessionProperties()\n+    {\n+        try {\n+            runConnection(connection -> {\n+                try {\n+                    connection.prepareStatement(\"SELECT 1\").execute();\n+                }\n+                catch (SQLException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }, omitDateTimeTypePrecision(true));\n+        }\n+        catch (Exception ignored) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    private void runConnection(Consumer<Connection> consumer)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 524}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwNzQ3NA==", "bodyText": "rename to indicate which session properties? or is it any?", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457207474", "createdAt": "2020-07-20T09:14:35Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> DRIVER_VERSION_TESTED = Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+\n+    private static final int DEFAULT_PRECISION = 3; // milliseconds\n+    private static final int MAX_SQL_PRECISION = 9; // nanoseconds\n+    private static final int MAX_TIMESTAMP_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(PrestoDriver.class.getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT timestamp '2012-10-31 01:00'\";\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testTimestampWithTzSelect()\n+    {\n+        if (driverVersion() == 335 || driverVersion() == 336) {\n+            throw new SkipException(\"Reading timestamp with time zone is broken in 335 and 336\");\n+        }\n+\n+        String query = format(\"SELECT timestamp '2012-10-31 01:00 %s'\", TESTED_TZ);\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-30 10:15:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampAsSqlTimestamp()\n+    {\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(timestamp, precision, MAX_SQL_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementAsTimestamp);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzAsSqlTimestamp()\n+    {\n+        if (driverVersion() == 335 || driverVersion() == 336) {\n+            throw new SkipException(\"Reading timestamp with time zone is broken in 335 and 336\");\n+        }\n+\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+        String localTimestamp = \"2421-01-19 01:10:23.393456298901\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(localTimestamp, precision, MAX_SQL_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementAsTimestamp);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInMap()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s' as TIMESTAMP(%d)))])\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromMap);\n+            assertDescribeType(query, \"map(varchar(9), %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTzTimestampInMap()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE))])\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromMap);\n+            assertDescribeType(query, \"map(varchar(9), %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInArray()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s' as TIMESTAMP(%d))]\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromArray);\n+            assertDescribeType(query, \"array(%s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzInArray()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)]\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromArray);\n+            assertDescribeType(query, \"array(%s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInRow()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s') AS ROW(timestamp TIMESTAMP(%d)))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromRow);\n+            assertDescribeType(query, \"row(timestamp %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTzTimestampInRow()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s %s') AS ROW(timestamp TIMESTAMP(%d) WITH TIME ZONE))\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromRow);\n+            assertDescribeType(query, \"row(timestamp %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampAsString()\n+    {\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getFirstString);\n+            assertDescribeType(query, \"%s\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzAsString()\n+    {\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getFirstString);\n+            assertDescribeType(query, \"%s\", precision, true);\n+        }\n+    }\n+\n+    public void assertQueryResultEquals(String query, Object expectedTimestamp, Function<ResultSet, Object> extractValue)\n+    {\n+        try (ResultSet rs = runQuery(query)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(extractValue.apply(rs)).isEqualTo(expectedTimestamp);\n+            assertThat(rs.next()).isFalse();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void assertDescribeType(String query, String expectedTypePattern, int precision, boolean withTimeZone)\n+    {\n+        assertDescribedInputType(query, format(expectedTypePattern, describeTimestampType(precision, true, withTimeZone)), true);\n+        assertDescribedInputType(query, format(expectedTypePattern, describeTimestampType(precision, false, withTimeZone)), false);\n+        assertDescribedOutputType(query, format(expectedTypePattern, describeTimestampType(precision, true, withTimeZone)), true);\n+        assertDescribedOutputType(query, format(expectedTypePattern, describeTimestampType(precision, false, withTimeZone)), false);\n+    }\n+\n+    private void assertDescribedInputType(String query, String expectedType, boolean ommitPrecision)\n+    {\n+        if (ommitPrecision && !supportsSessionProperties()) {\n+            // Driver does not support setting session properties\n+            return;\n+        }\n+\n+        runConnection(connection -> {\n+            try {\n+                connection.prepareStatement(format(\"SELECT 1 FROM (%s AS timestamp) WHERE timestamp = ?\", query));\n+\n+                try (ResultSet resultSet = connection.prepareStatement(\"DESCRIBE INPUT statement1\").executeQuery()) {\n+                    assertThat(resultSet.next()).isTrue();\n+                    assertThat(resultSet.getString(2)).isEqualTo(expectedType);\n+                }\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }, omitDateTimeTypePrecision(ommitPrecision));\n+    }\n+\n+    private void assertDescribedOutputType(String query, String expectedType, boolean ommitPrecision)\n+    {\n+        if (ommitPrecision && !supportsSessionProperties()) {\n+            // Driver does not support setting session properties\n+            return;\n+        }\n+\n+        runConnection(connection -> {\n+            try {\n+                connection.prepareStatement(query);\n+\n+                try (ResultSet resultSet = connection.prepareStatement(\"DESCRIBE OUTPUT statement1\").executeQuery()) {\n+                    assertThat(resultSet.next()).isTrue();\n+                    assertThat(resultSet.getString(5)).isEqualTo(expectedType);\n+                }\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }, omitDateTimeTypePrecision(ommitPrecision));\n+    }\n+\n+    private static String describeTimestampType(int precision, boolean ommitPrecision, boolean withTimezone)\n+    {\n+        if (ommitPrecision && precision == DEFAULT_PRECISION) {\n+            if (withTimezone) {\n+                return \"timestamp with time zone\";\n+            }\n+\n+            return \"timestamp\";\n+        }\n+\n+        if (withTimezone) {\n+            return format(\"timestamp(%d) with time zone\", precision);\n+        }\n+\n+        return format(\"timestamp(%d)\", precision);\n+    }\n+\n+    private static Timestamp roundedSqlTimestamp(String timestamp, int precision, int maxPrecision)\n+    {\n+        return Timestamp.valueOf(roundedTimestamp(timestamp, precision, maxPrecision));\n+    }\n+\n+    private static String getFirstString(ResultSet resultSet)\n+    {\n+        try {\n+            return resultSet.getString(1);\n+        }\n+        catch (SQLException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromArray(ResultSet resultSet)\n+    {\n+        try {\n+            Array array = resultSet.getArray(1);\n+            return ((Object[]) array.getArray(1, 1))[0];\n+        }\n+        catch (SQLException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromRow(ResultSet resultSet)\n+    {\n+        try {\n+            Map<String, Object> row = (Map<String, Object>) resultSet.getObject(1);\n+            return row.get(\"timestamp\");\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromMap(ResultSet resultSet)\n+    {\n+        try {\n+            Map map = (Map) resultSet.getObject(1);\n+            return map.get(\"timestamp\");\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Timestamp getSingleElementAsTimestamp(ResultSet resultSet)\n+    {\n+        try {\n+            return resultSet.getTimestamp(1);\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static String roundedTimestamp(String timestamp, int precision, int maxPrecision)\n+    {\n+        List<String> parts = Splitter.on('.').splitToList(timestamp);\n+        verify(parts.size() == 2);\n+\n+        BigDecimal fractional = new BigDecimal(format(\"0.%s\", parts.get(1)));\n+\n+        if (determineSupportedPrecision(precision, maxPrecision) == 0) {\n+            return parts.get(0);\n+        }\n+\n+        int timestampDisplayPrecision = determineSupportedPrecision(precision, maxPrecision);\n+        int timestampPrecision = min(precision, maxPrecision);\n+\n+        BigDecimal scaledFractional = fractional\n+                .setScale(timestampPrecision, RoundingMode.HALF_EVEN)\n+                .setScale(timestampDisplayPrecision, RoundingMode.HALF_EVEN);\n+\n+        return format(\"%s.%s\", parts.get(0), scaledFractional.toString().substring(2));\n+    }\n+\n+    private static int determineSupportedPrecision(int precision, int maxPrecision)\n+    {\n+        if (supportsParametricTimestamp()) {\n+            return min(precision, maxPrecision);\n+        }\n+\n+        // Before parametric timestamp was introduced, timestamp had precision = 3\n+        return DEFAULT_PRECISION;\n+    }\n+\n+    private static boolean supportsParametricTimestamp()\n+    {\n+        return driverVersion() == 0 || driverVersion() >= 335;\n+    }\n+\n+    private static int driverVersion()\n+    {\n+        try {\n+            return Integer.valueOf(PrestoDriver.class.getPackage().getImplementationVersion());\n+        }\n+        catch (NumberFormatException ignored) {\n+            return 0;\n+        }\n+    }\n+\n+    private ResultSet runQuery(String query)\n+    {\n+        return runQuery(query, ImmutableMap.of());\n+    }\n+\n+    private ResultSet runQuery(String query, Map<String, String> params)\n+    {\n+        Properties properties = new Properties();\n+        properties.putAll(params);\n+        properties.put(\"user\", \"test\");\n+        properties.put(\"password\", \"\");\n+\n+        try (Connection conn = DriverManager.getConnection(serverUrl, properties); PreparedStatement stmt = conn.prepareStatement(query)) {\n+            return stmt.executeQuery();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void runConnection(Consumer<Connection> consumer, Map<String, String> params)\n+    {\n+        Properties properties = new Properties();\n+        properties.putAll(params);\n+        properties.put(\"user\", \"test\");\n+        properties.put(\"password\", \"\");\n+\n+        try (Connection conn = DriverManager.getConnection(serverUrl, properties)) {\n+            consumer.accept(conn);\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Map<String, String> omitDateTimeTypePrecision(boolean ommit)\n+    {\n+        if (!ommit) {\n+            return ImmutableMap.of();\n+        }\n+\n+        return ImmutableMap.of(\"sessionProperties\", format(\"omit_datetime_type_precision:%b\", ommit));\n+    }\n+\n+    private boolean supportsSessionProperties()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 505}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwNzk0Nw==", "bodyText": "maybe let's hardcode the version where this was added, instead of having this exception-driven\n(what if the code in the try clause, which does a bunch of different things, starts to fail for some reason?)", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457207947", "createdAt": "2020-07-20T09:15:12Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> DRIVER_VERSION_TESTED = Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+\n+    private static final int DEFAULT_PRECISION = 3; // milliseconds\n+    private static final int MAX_SQL_PRECISION = 9; // nanoseconds\n+    private static final int MAX_TIMESTAMP_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(PrestoDriver.class.getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT timestamp '2012-10-31 01:00'\";\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testTimestampWithTzSelect()\n+    {\n+        if (driverVersion() == 335 || driverVersion() == 336) {\n+            throw new SkipException(\"Reading timestamp with time zone is broken in 335 and 336\");\n+        }\n+\n+        String query = format(\"SELECT timestamp '2012-10-31 01:00 %s'\", TESTED_TZ);\n+        assertQueryResultEquals(query, Timestamp.valueOf(\"2012-10-30 10:15:00.000\"), TestJdbcCompatibility::getSingleElementAsTimestamp);\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampAsSqlTimestamp()\n+    {\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(timestamp, precision, MAX_SQL_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementAsTimestamp);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzAsSqlTimestamp()\n+    {\n+        if (driverVersion() == 335 || driverVersion() == 336) {\n+            throw new SkipException(\"Reading timestamp with time zone is broken in 335 and 336\");\n+        }\n+\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+        String localTimestamp = \"2421-01-19 01:10:23.393456298901\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(localTimestamp, precision, MAX_SQL_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementAsTimestamp);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInMap()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s' as TIMESTAMP(%d)))])\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromMap);\n+            assertDescribeType(query, \"map(varchar(9), %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTzTimestampInMap()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE))])\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromMap);\n+            assertDescribeType(query, \"map(varchar(9), %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInArray()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s' as TIMESTAMP(%d))]\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromArray);\n+            assertDescribeType(query, \"array(%s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzInArray()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)]\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromArray);\n+            assertDescribeType(query, \"array(%s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInRow()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s') AS ROW(timestamp TIMESTAMP(%d)))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromRow);\n+            assertDescribeType(query, \"row(timestamp %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTzTimestampInRow()\n+    {\n+        String timestamp = \"2304-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s %s') AS ROW(timestamp TIMESTAMP(%d) WITH TIME ZONE))\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromRow);\n+            assertDescribeType(query, \"row(timestamp %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampAsString()\n+    {\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp, TestJdbcCompatibility::getFirstString);\n+            assertDescribeType(query, \"%s\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampTzAsString()\n+    {\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= MAX_TIMESTAMP_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, MAX_TIMESTAMP_PRECISION);\n+\n+            assertQueryResultEquals(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getFirstString);\n+            assertDescribeType(query, \"%s\", precision, true);\n+        }\n+    }\n+\n+    public void assertQueryResultEquals(String query, Object expectedTimestamp, Function<ResultSet, Object> extractValue)\n+    {\n+        try (ResultSet rs = runQuery(query)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(extractValue.apply(rs)).isEqualTo(expectedTimestamp);\n+            assertThat(rs.next()).isFalse();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void assertDescribeType(String query, String expectedTypePattern, int precision, boolean withTimeZone)\n+    {\n+        assertDescribedInputType(query, format(expectedTypePattern, describeTimestampType(precision, true, withTimeZone)), true);\n+        assertDescribedInputType(query, format(expectedTypePattern, describeTimestampType(precision, false, withTimeZone)), false);\n+        assertDescribedOutputType(query, format(expectedTypePattern, describeTimestampType(precision, true, withTimeZone)), true);\n+        assertDescribedOutputType(query, format(expectedTypePattern, describeTimestampType(precision, false, withTimeZone)), false);\n+    }\n+\n+    private void assertDescribedInputType(String query, String expectedType, boolean ommitPrecision)\n+    {\n+        if (ommitPrecision && !supportsSessionProperties()) {\n+            // Driver does not support setting session properties\n+            return;\n+        }\n+\n+        runConnection(connection -> {\n+            try {\n+                connection.prepareStatement(format(\"SELECT 1 FROM (%s AS timestamp) WHERE timestamp = ?\", query));\n+\n+                try (ResultSet resultSet = connection.prepareStatement(\"DESCRIBE INPUT statement1\").executeQuery()) {\n+                    assertThat(resultSet.next()).isTrue();\n+                    assertThat(resultSet.getString(2)).isEqualTo(expectedType);\n+                }\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }, omitDateTimeTypePrecision(ommitPrecision));\n+    }\n+\n+    private void assertDescribedOutputType(String query, String expectedType, boolean ommitPrecision)\n+    {\n+        if (ommitPrecision && !supportsSessionProperties()) {\n+            // Driver does not support setting session properties\n+            return;\n+        }\n+\n+        runConnection(connection -> {\n+            try {\n+                connection.prepareStatement(query);\n+\n+                try (ResultSet resultSet = connection.prepareStatement(\"DESCRIBE OUTPUT statement1\").executeQuery()) {\n+                    assertThat(resultSet.next()).isTrue();\n+                    assertThat(resultSet.getString(5)).isEqualTo(expectedType);\n+                }\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }, omitDateTimeTypePrecision(ommitPrecision));\n+    }\n+\n+    private static String describeTimestampType(int precision, boolean ommitPrecision, boolean withTimezone)\n+    {\n+        if (ommitPrecision && precision == DEFAULT_PRECISION) {\n+            if (withTimezone) {\n+                return \"timestamp with time zone\";\n+            }\n+\n+            return \"timestamp\";\n+        }\n+\n+        if (withTimezone) {\n+            return format(\"timestamp(%d) with time zone\", precision);\n+        }\n+\n+        return format(\"timestamp(%d)\", precision);\n+    }\n+\n+    private static Timestamp roundedSqlTimestamp(String timestamp, int precision, int maxPrecision)\n+    {\n+        return Timestamp.valueOf(roundedTimestamp(timestamp, precision, maxPrecision));\n+    }\n+\n+    private static String getFirstString(ResultSet resultSet)\n+    {\n+        try {\n+            return resultSet.getString(1);\n+        }\n+        catch (SQLException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromArray(ResultSet resultSet)\n+    {\n+        try {\n+            Array array = resultSet.getArray(1);\n+            return ((Object[]) array.getArray(1, 1))[0];\n+        }\n+        catch (SQLException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromRow(ResultSet resultSet)\n+    {\n+        try {\n+            Map<String, Object> row = (Map<String, Object>) resultSet.getObject(1);\n+            return row.get(\"timestamp\");\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object getSingleElementFromMap(ResultSet resultSet)\n+    {\n+        try {\n+            Map map = (Map) resultSet.getObject(1);\n+            return map.get(\"timestamp\");\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Timestamp getSingleElementAsTimestamp(ResultSet resultSet)\n+    {\n+        try {\n+            return resultSet.getTimestamp(1);\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static String roundedTimestamp(String timestamp, int precision, int maxPrecision)\n+    {\n+        List<String> parts = Splitter.on('.').splitToList(timestamp);\n+        verify(parts.size() == 2);\n+\n+        BigDecimal fractional = new BigDecimal(format(\"0.%s\", parts.get(1)));\n+\n+        if (determineSupportedPrecision(precision, maxPrecision) == 0) {\n+            return parts.get(0);\n+        }\n+\n+        int timestampDisplayPrecision = determineSupportedPrecision(precision, maxPrecision);\n+        int timestampPrecision = min(precision, maxPrecision);\n+\n+        BigDecimal scaledFractional = fractional\n+                .setScale(timestampPrecision, RoundingMode.HALF_EVEN)\n+                .setScale(timestampDisplayPrecision, RoundingMode.HALF_EVEN);\n+\n+        return format(\"%s.%s\", parts.get(0), scaledFractional.toString().substring(2));\n+    }\n+\n+    private static int determineSupportedPrecision(int precision, int maxPrecision)\n+    {\n+        if (supportsParametricTimestamp()) {\n+            return min(precision, maxPrecision);\n+        }\n+\n+        // Before parametric timestamp was introduced, timestamp had precision = 3\n+        return DEFAULT_PRECISION;\n+    }\n+\n+    private static boolean supportsParametricTimestamp()\n+    {\n+        return driverVersion() == 0 || driverVersion() >= 335;\n+    }\n+\n+    private static int driverVersion()\n+    {\n+        try {\n+            return Integer.valueOf(PrestoDriver.class.getPackage().getImplementationVersion());\n+        }\n+        catch (NumberFormatException ignored) {\n+            return 0;\n+        }\n+    }\n+\n+    private ResultSet runQuery(String query)\n+    {\n+        return runQuery(query, ImmutableMap.of());\n+    }\n+\n+    private ResultSet runQuery(String query, Map<String, String> params)\n+    {\n+        Properties properties = new Properties();\n+        properties.putAll(params);\n+        properties.put(\"user\", \"test\");\n+        properties.put(\"password\", \"\");\n+\n+        try (Connection conn = DriverManager.getConnection(serverUrl, properties); PreparedStatement stmt = conn.prepareStatement(query)) {\n+            return stmt.executeQuery();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void runConnection(Consumer<Connection> consumer, Map<String, String> params)\n+    {\n+        Properties properties = new Properties();\n+        properties.putAll(params);\n+        properties.put(\"user\", \"test\");\n+        properties.put(\"password\", \"\");\n+\n+        try (Connection conn = DriverManager.getConnection(serverUrl, properties)) {\n+            consumer.accept(conn);\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Map<String, String> omitDateTimeTypePrecision(boolean ommit)\n+    {\n+        if (!ommit) {\n+            return ImmutableMap.of();\n+        }\n+\n+        return ImmutableMap.of(\"sessionProperties\", format(\"omit_datetime_type_precision:%b\", ommit));\n+    }\n+\n+    private boolean supportsSessionProperties()\n+    {\n+        try {\n+            runConnection(connection -> {\n+                try {\n+                    connection.prepareStatement(\"SELECT 1\").execute();\n+                }\n+                catch (SQLException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }, omitDateTimeTypePrecision(true));\n+        }\n+        catch (Exception ignored) {\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 518}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwODQzMg==", "bodyText": "I think we should pin the first tested version. I am aware this adds testing time as we do new releases, so we may want to make test matrix sparse.\nI propose we start testing at say 312, and test every third release.\nWhen this becomes too long, we will test old versions more sparsely / coarsely.\n@electrum @martint what would you think?", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r457208432", "createdAt": "2020-07-20T09:15:50Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/bin/run_tests.sh", "diffHunk": "@@ -0,0 +1,27 @@\n+#!/bin/bash\n+\n+set -xeuo pipefail\n+trap \"exit\" INT\n+\n+maven=\"${BASH_SOURCE%/*/*}/../mvnw\"\n+last_n_versions=20\n+\n+$maven -version\n+\n+current_version=$($maven help:evaluate -Dexpression=project.version -q -DforceStdout)\n+previous_released_version=$((${current_version%-SNAPSHOT}-1))\n+first_tested_version=$((previous_released_version-last_n_versions))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MzYxODUx", "url": "https://github.com/trinodb/trino/pull/4194#pullrequestreview-457361851", "createdAt": "2020-07-29T09:44:06Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwOTo0NDowNlrOG4w4BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDoyOToyOVrOG4ychQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NDIxMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            #!/bin/bash\n          \n          \n            \n            #!/usr/bin/env bash", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462174213", "createdAt": "2020-07-29T09:44:06Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/bin/run_tests.sh", "diffHunk": "@@ -0,0 +1,34 @@\n+#!/bin/bash", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NTAzOQ==", "bodyText": "lowercase MAVEN_RUN_TESTS, like you do with maven and other local variables", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462175039", "createdAt": "2020-07-29T09:45:28Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/bin/run_tests.sh", "diffHunk": "@@ -0,0 +1,34 @@\n+#!/bin/bash\n+\n+set -xeuo pipefail\n+trap \"exit\" INT # allows to terminate script on ctrl+c instead of terminating single mvnw execution\n+\n+maven=\"${BASH_SOURCE%/*}/../../mvnw\"\n+MAVEN_RUN_TESTS=\"${maven} clean test -Dair.check.skip-all=true -Dmaven.javadoc.skip=true -Dmaven.source.skip=true -B -pl presto-test-jdbc-compatibility\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NTc2Ng==", "bodyText": "i find it more readable to introduce env changes with env,\neven more so if this is inside if\nif ! time env PRESTO_JDBC_VERSION=\"${version}\" ${maven_run_tests} ...", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462175766", "createdAt": "2020-07-29T09:46:47Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/bin/run_tests.sh", "diffHunk": "@@ -0,0 +1,34 @@\n+#!/bin/bash\n+\n+set -xeuo pipefail\n+trap \"exit\" INT # allows to terminate script on ctrl+c instead of terminating single mvnw execution\n+\n+maven=\"${BASH_SOURCE%/*}/../../mvnw\"\n+MAVEN_RUN_TESTS=\"${maven} clean test -Dair.check.skip-all=true -Dmaven.javadoc.skip=true -Dmaven.source.skip=true -B -pl presto-test-jdbc-compatibility\"\n+\n+\"${maven}\" -version\n+\n+current_version=$(${maven} help:evaluate -Dexpression=project.version -q -DforceStdout)\n+previous_released_version=$((${current_version%-SNAPSHOT}-1))\n+first_tested_version=312\n+\n+echo \"Current version: ${current_version}\"\n+echo \"Testing every 3rd version between ${first_tested_version} and ${previous_released_version}\"\n+\n+versions=$(seq \"${first_tested_version}\" \"${previous_released_version}\")\n+\n+exit_code=0\n+failed_versions=()\n+\n+for version in ${versions[*]}; do\n+    # Test every third version\n+    if ! (( $version % 3 )); then\n+        if ! PRESTO_JDBC_VERSION=\"${version}\" time ${MAVEN_RUN_TESTS} -Ddep.presto-jdbc-under-test=\"${version}\"; then", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjM1Nw==", "bodyText": "Why not just?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            echo \"$0: exiting with ${exit_code}, failed versions: ${failed_versions[@]+\\\"${failed_versions[@]}\\\"}\"\n          \n          \n            \n            echo \"$0: exiting with ${exit_code}, failed versions: ${failed_versions[*]}\"", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462176357", "createdAt": "2020-07-29T09:47:50Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/bin/run_tests.sh", "diffHunk": "@@ -0,0 +1,34 @@\n+#!/bin/bash\n+\n+set -xeuo pipefail\n+trap \"exit\" INT # allows to terminate script on ctrl+c instead of terminating single mvnw execution\n+\n+maven=\"${BASH_SOURCE%/*}/../../mvnw\"\n+MAVEN_RUN_TESTS=\"${maven} clean test -Dair.check.skip-all=true -Dmaven.javadoc.skip=true -Dmaven.source.skip=true -B -pl presto-test-jdbc-compatibility\"\n+\n+\"${maven}\" -version\n+\n+current_version=$(${maven} help:evaluate -Dexpression=project.version -q -DforceStdout)\n+previous_released_version=$((${current_version%-SNAPSHOT}-1))\n+first_tested_version=312\n+\n+echo \"Current version: ${current_version}\"\n+echo \"Testing every 3rd version between ${first_tested_version} and ${previous_released_version}\"\n+\n+versions=$(seq \"${first_tested_version}\" \"${previous_released_version}\")\n+\n+exit_code=0\n+failed_versions=()\n+\n+for version in ${versions[*]}; do\n+    # Test every third version\n+    if ! (( $version % 3 )); then\n+        if ! PRESTO_JDBC_VERSION=\"${version}\" time ${MAVEN_RUN_TESTS} -Ddep.presto-jdbc-under-test=\"${version}\"; then\n+            exit_code=1\n+            failed_versions+=(\"${version}\")\n+        fi\n+    fi\n+done\n+\n+echo \"$0: exiting with ${exit_code}, failed versions: ${failed_versions[@]+\\\"${failed_versions[@]}\\\"}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3OTUxOA==", "bodyText": "Move this to initialization of the versions:\ntested_versions=$(seq \"${first_tested_version}\" 3 \"${previous_released_version}\")\n\nAlso, we should also test previous_released_version:\nif (( (previous_released_version - first_tested_version) % 3 != 0 )); then\n    tested_versions=\"${tested_versions}\" ${previous_released_version}\"\nfi \n\nAlso 3 could be a constant for readability (step?)", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462179518", "createdAt": "2020-07-29T09:52:56Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/bin/run_tests.sh", "diffHunk": "@@ -0,0 +1,34 @@\n+#!/bin/bash\n+\n+set -xeuo pipefail\n+trap \"exit\" INT # allows to terminate script on ctrl+c instead of terminating single mvnw execution\n+\n+maven=\"${BASH_SOURCE%/*}/../../mvnw\"\n+MAVEN_RUN_TESTS=\"${maven} clean test -Dair.check.skip-all=true -Dmaven.javadoc.skip=true -Dmaven.source.skip=true -B -pl presto-test-jdbc-compatibility\"\n+\n+\"${maven}\" -version\n+\n+current_version=$(${maven} help:evaluate -Dexpression=project.version -q -DforceStdout)\n+previous_released_version=$((${current_version%-SNAPSHOT}-1))\n+first_tested_version=312\n+\n+echo \"Current version: ${current_version}\"\n+echo \"Testing every 3rd version between ${first_tested_version} and ${previous_released_version}\"\n+\n+versions=$(seq \"${first_tested_version}\" \"${previous_released_version}\")\n+\n+exit_code=0\n+failed_versions=()\n+\n+for version in ${versions[*]}; do\n+    # Test every third version\n+    if ! (( $version % 3 )); then", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4MTMwOQ==", "bodyText": "call PRESTO_JDBC_VERSION similar to the sibling maven property:\nPRESTO_JDBC_VERSION_UNDER_TEST", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462181309", "createdAt": "2020-07-29T09:56:01Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/JdbcDriverCapabilities.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import io.prestosql.jdbc.PrestoDriver;\n+\n+import java.util.Optional;\n+\n+public class JdbcDriverCapabilities\n+{\n+    private JdbcDriverCapabilities() {}\n+\n+    public static final int VERSION_HEAD = 0;\n+\n+    public static final Optional<Integer> testedVersion()\n+    {\n+        return Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4MTYyOA==", "bodyText": "btw before the change my intellij shows an error on this line\nArgument mixes string and array. Use * or separate argument.\nSee SC2145.", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462181628", "createdAt": "2020-07-29T09:56:36Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/bin/run_tests.sh", "diffHunk": "@@ -0,0 +1,34 @@\n+#!/bin/bash\n+\n+set -xeuo pipefail\n+trap \"exit\" INT # allows to terminate script on ctrl+c instead of terminating single mvnw execution\n+\n+maven=\"${BASH_SOURCE%/*}/../../mvnw\"\n+MAVEN_RUN_TESTS=\"${maven} clean test -Dair.check.skip-all=true -Dmaven.javadoc.skip=true -Dmaven.source.skip=true -B -pl presto-test-jdbc-compatibility\"\n+\n+\"${maven}\" -version\n+\n+current_version=$(${maven} help:evaluate -Dexpression=project.version -q -DforceStdout)\n+previous_released_version=$((${current_version%-SNAPSHOT}-1))\n+first_tested_version=312\n+\n+echo \"Current version: ${current_version}\"\n+echo \"Testing every 3rd version between ${first_tested_version} and ${previous_released_version}\"\n+\n+versions=$(seq \"${first_tested_version}\" \"${previous_released_version}\")\n+\n+exit_code=0\n+failed_versions=()\n+\n+for version in ${versions[*]}; do\n+    # Test every third version\n+    if ! (( $version % 3 )); then\n+        if ! PRESTO_JDBC_VERSION=\"${version}\" time ${MAVEN_RUN_TESTS} -Ddep.presto-jdbc-under-test=\"${version}\"; then\n+            exit_code=1\n+            failed_versions+=(\"${version}\")\n+        fi\n+    fi\n+done\n+\n+echo \"$0: exiting with ${exit_code}, failed versions: ${failed_versions[@]+\\\"${failed_versions[@]}\\\"}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjM1Nw=="}, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4MjUwMw==", "bodyText": "or == VERSION_HEAD", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462182503", "createdAt": "2020-07-29T09:58:07Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/JdbcDriverCapabilities.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import io.prestosql.jdbc.PrestoDriver;\n+\n+import java.util.Optional;\n+\n+public class JdbcDriverCapabilities\n+{\n+    private JdbcDriverCapabilities() {}\n+\n+    public static final int VERSION_HEAD = 0;\n+\n+    public static final Optional<Integer> testedVersion()\n+    {\n+        return Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+    }\n+\n+    public static int driverVersion()\n+    {\n+        return new PrestoDriver().getMajorVersion();\n+    }\n+\n+    public static boolean supportsSessionPropertiesViaConnectionUri()\n+    {\n+        return driverVersion() >= 330;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4MzAwOQ==", "bodyText": "i have a warning here ('PrestoDriver' used without 'try'-with-resources statement )", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462183009", "createdAt": "2020-07-29T09:59:03Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/JdbcDriverCapabilities.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import io.prestosql.jdbc.PrestoDriver;\n+\n+import java.util.Optional;\n+\n+public class JdbcDriverCapabilities\n+{\n+    private JdbcDriverCapabilities() {}\n+\n+    public static final int VERSION_HEAD = 0;\n+\n+    public static final Optional<Integer> testedVersion()\n+    {\n+        return Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+    }\n+\n+    public static int driverVersion()\n+    {\n+        return new PrestoDriver().getMajorVersion();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4MzI2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class JdbcDriverCapabilities\n          \n          \n            \n            public final class JdbcDriverCapabilities", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462183262", "createdAt": "2020-07-29T09:59:25Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/JdbcDriverCapabilities.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import io.prestosql.jdbc.PrestoDriver;\n+\n+import java.util.Optional;\n+\n+public class JdbcDriverCapabilities", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4MzM2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final Optional<Integer> testedVersion()\n          \n          \n            \n                public static Optional<Integer> testedVersion()\n          \n      \n    \n    \n  \n\n(i have a warning here)", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462183368", "createdAt": "2020-07-29T09:59:38Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/JdbcDriverCapabilities.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import io.prestosql.jdbc.PrestoDriver;\n+\n+import java.util.Optional;\n+\n+public class JdbcDriverCapabilities\n+{\n+    private JdbcDriverCapabilities() {}\n+\n+    public static final int VERSION_HEAD = 0;\n+\n+    public static final Optional<Integer> testedVersion()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4NDUyOQ==", "bodyText": "make sure to update this if you rename the env variable\nmaybe\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n          \n          \n            \n                        throw new SkipException(\"Information about JDBC version under test is missing\");", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462184529", "createdAt": "2020-07-29T10:01:36Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.plugin.mongodb.MongoPlugin;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.JdbcDriverCapabilities.driverVersion;\n+import static io.prestosql.JdbcDriverCapabilities.hasBrokenParametricTimestampWithTimeZoneSupport;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestamp;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestampWithTimeZone;\n+import static io.prestosql.JdbcDriverCapabilities.supportsSessionPropertiesViaConnectionUri;\n+import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> VERSION_UNDER_TEST = testedVersion();\n+    private static final int TIMESTAMP_DEFAULT_PRECISION = 3;\n+    private static final int TIMESTAMP_JDBC_MAX_PRECISION = 9; // nanoseconds\n+    private static final int TIMESTAMP_MAX_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        server.installPlugin(new MongoPlugin());\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (VERSION_UNDER_TEST.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4NTUwNg==", "bodyText": "Cli -> Client\n(Cli would be read as \"CLI\")", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462185506", "createdAt": "2020-07-29T10:03:12Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.plugin.mongodb.MongoPlugin;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.JdbcDriverCapabilities.driverVersion;\n+import static io.prestosql.JdbcDriverCapabilities.hasBrokenParametricTimestampWithTimeZoneSupport;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestamp;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestampWithTimeZone;\n+import static io.prestosql.JdbcDriverCapabilities.supportsSessionPropertiesViaConnectionUri;\n+import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> VERSION_UNDER_TEST = testedVersion();\n+    private static final int TIMESTAMP_DEFAULT_PRECISION = 3;\n+    private static final int TIMESTAMP_JDBC_MAX_PRECISION = 9; // nanoseconds\n+    private static final int TIMESTAMP_MAX_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        server.installPlugin(new MongoPlugin());\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (VERSION_UNDER_TEST.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(driverVersion())\n+                .isEqualTo(VERSION_UNDER_TEST.get());\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4NjA5OA==", "bodyText": "bump;\nyou have this for testSelectParametricTimestamp, but not here\nalso, testTimestampWithTimeZoneSelect needs update as well", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462186098", "createdAt": "2020-07-29T10:04:14Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.PrestoDriver;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> DRIVER_VERSION_TESTED = Optional.ofNullable(System.getenv(\"PRESTO_JDBC_VERSION\")).map(Integer::valueOf);\n+\n+    private static final int DEFAULT_PRECISION = 3; // milliseconds\n+    private static final int MAX_SQL_PRECISION = 9; // nanoseconds\n+    private static final int MAX_TIMESTAMP_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(PrestoDriver.class.getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (DRIVER_VERSION_TESTED.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(DRIVER_VERSION_TESTED.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwMDcyNg=="}, "originalCommit": null, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4NjI2MA==", "bodyText": "raports -> reports", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462186260", "createdAt": "2020-07-29T10:04:32Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.plugin.mongodb.MongoPlugin;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.JdbcDriverCapabilities.driverVersion;\n+import static io.prestosql.JdbcDriverCapabilities.hasBrokenParametricTimestampWithTimeZoneSupport;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestamp;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestampWithTimeZone;\n+import static io.prestosql.JdbcDriverCapabilities.supportsSessionPropertiesViaConnectionUri;\n+import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> VERSION_UNDER_TEST = testedVersion();\n+    private static final int TIMESTAMP_DEFAULT_PRECISION = 3;\n+    private static final int TIMESTAMP_JDBC_MAX_PRECISION = 9; // nanoseconds\n+    private static final int TIMESTAMP_MAX_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        server.installPlugin(new MongoPlugin());\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (VERSION_UNDER_TEST.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(driverVersion())\n+                .isEqualTo(VERSION_UNDER_TEST.get());\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (VERSION_UNDER_TEST.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(VERSION_UNDER_TEST.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT TIMESTAMP '2012-10-31 01:00'\";\n+        checkRepresentation(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), ResultSet::getTimestamp);\n+    }\n+\n+    @Test\n+    public void testTimestampWithTimeZoneSelect()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4NjYxOA==", "bodyText": "raports -> reports", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462186618", "createdAt": "2020-07-29T10:05:10Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.plugin.mongodb.MongoPlugin;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.JdbcDriverCapabilities.driverVersion;\n+import static io.prestosql.JdbcDriverCapabilities.hasBrokenParametricTimestampWithTimeZoneSupport;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestamp;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestampWithTimeZone;\n+import static io.prestosql.JdbcDriverCapabilities.supportsSessionPropertiesViaConnectionUri;\n+import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> VERSION_UNDER_TEST = testedVersion();\n+    private static final int TIMESTAMP_DEFAULT_PRECISION = 3;\n+    private static final int TIMESTAMP_JDBC_MAX_PRECISION = 9; // nanoseconds\n+    private static final int TIMESTAMP_MAX_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        server.installPlugin(new MongoPlugin());\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (VERSION_UNDER_TEST.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(driverVersion())\n+                .isEqualTo(VERSION_UNDER_TEST.get());\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (VERSION_UNDER_TEST.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(VERSION_UNDER_TEST.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT TIMESTAMP '2012-10-31 01:00'\";\n+        checkRepresentation(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), ResultSet::getTimestamp);\n+    }\n+\n+    @Test\n+    public void testTimestampWithTimeZoneSelect()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String query = format(\"SELECT timestamp '2012-10-31 01:00 %s'\", TESTED_TZ);\n+        checkRepresentation(query, Timestamp.valueOf(\"2012-10-30 10:15:00.000\"), ResultSet::getTimestamp);\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestamp()\n+    {\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(timestamp, precision, TIMESTAMP_JDBC_MAX_PRECISION, false);\n+\n+            checkRepresentation(query, expectedTimestamp, ResultSet::getTimestamp);\n+            checkRepresentation(query, expectedTimestamp, ResultSet::getObject);\n+            checkRepresentation(query, roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, false), ResultSet::getString);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampWithTimeZone()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4ODIwMw==", "bodyText": "Let's fire the query once and check various representations in a single lambda:\n     checkRepresentation(\"cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", (resultSet, column) -> {\n                  assertThat(resultSet.getTimestamp(column)).isEqualTo(expectedTimestamp);\n                  assertThat(resultSet.getObject(column)).isEqualTo(expectedTimestamp);\n                  assertThat(resultSet.String(column)).isEqualTo(....);\n            });", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462188203", "createdAt": "2020-07-29T10:07:57Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.plugin.mongodb.MongoPlugin;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.JdbcDriverCapabilities.driverVersion;\n+import static io.prestosql.JdbcDriverCapabilities.hasBrokenParametricTimestampWithTimeZoneSupport;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestamp;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestampWithTimeZone;\n+import static io.prestosql.JdbcDriverCapabilities.supportsSessionPropertiesViaConnectionUri;\n+import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> VERSION_UNDER_TEST = testedVersion();\n+    private static final int TIMESTAMP_DEFAULT_PRECISION = 3;\n+    private static final int TIMESTAMP_JDBC_MAX_PRECISION = 9; // nanoseconds\n+    private static final int TIMESTAMP_MAX_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        server.installPlugin(new MongoPlugin());\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (VERSION_UNDER_TEST.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(driverVersion())\n+                .isEqualTo(VERSION_UNDER_TEST.get());\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (VERSION_UNDER_TEST.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(VERSION_UNDER_TEST.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT TIMESTAMP '2012-10-31 01:00'\";\n+        checkRepresentation(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), ResultSet::getTimestamp);\n+    }\n+\n+    @Test\n+    public void testTimestampWithTimeZoneSelect()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String query = format(\"SELECT timestamp '2012-10-31 01:00 %s'\", TESTED_TZ);\n+        checkRepresentation(query, Timestamp.valueOf(\"2012-10-30 10:15:00.000\"), ResultSet::getTimestamp);\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestamp()\n+    {\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(timestamp, precision, TIMESTAMP_JDBC_MAX_PRECISION, false);\n+\n+            checkRepresentation(query, expectedTimestamp, ResultSet::getTimestamp);\n+            checkRepresentation(query, expectedTimestamp, ResultSet::getObject);\n+            checkRepresentation(query, roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, false), ResultSet::getString);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4OTM2OA==", "bodyText": "Also we should add test for getTimestamp with Calendar", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462189368", "createdAt": "2020-07-29T10:10:10Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.plugin.mongodb.MongoPlugin;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.JdbcDriverCapabilities.driverVersion;\n+import static io.prestosql.JdbcDriverCapabilities.hasBrokenParametricTimestampWithTimeZoneSupport;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestamp;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestampWithTimeZone;\n+import static io.prestosql.JdbcDriverCapabilities.supportsSessionPropertiesViaConnectionUri;\n+import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> VERSION_UNDER_TEST = testedVersion();\n+    private static final int TIMESTAMP_DEFAULT_PRECISION = 3;\n+    private static final int TIMESTAMP_JDBC_MAX_PRECISION = 9; // nanoseconds\n+    private static final int TIMESTAMP_MAX_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        server.installPlugin(new MongoPlugin());\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (VERSION_UNDER_TEST.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(driverVersion())\n+                .isEqualTo(VERSION_UNDER_TEST.get());\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (VERSION_UNDER_TEST.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(VERSION_UNDER_TEST.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT TIMESTAMP '2012-10-31 01:00'\";\n+        checkRepresentation(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), ResultSet::getTimestamp);\n+    }\n+\n+    @Test\n+    public void testTimestampWithTimeZoneSelect()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String query = format(\"SELECT timestamp '2012-10-31 01:00 %s'\", TESTED_TZ);\n+        checkRepresentation(query, Timestamp.valueOf(\"2012-10-30 10:15:00.000\"), ResultSet::getTimestamp);\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestamp()\n+    {\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(timestamp, precision, TIMESTAMP_JDBC_MAX_PRECISION, false);\n+\n+            checkRepresentation(query, expectedTimestamp, ResultSet::getTimestamp);\n+            checkRepresentation(query, expectedTimestamp, ResultSet::getObject);\n+            checkRepresentation(query, roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, false), ResultSet::getString);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4ODIwMw=="}, "originalCommit": null, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5MjAyOQ==", "bodyText": "Having 2 different values like this looks like we have a bug (which we do not have).\nLet's derived one from the other\nTimestamp expected = new Timestamp(LocalDateTime.parse(timestamp)\n                .atZone(ZoneId.of(TESTED_TZ))\n                .toInstant().toEpochMilli());", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462192029", "createdAt": "2020-07-29T10:15:02Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.plugin.mongodb.MongoPlugin;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.JdbcDriverCapabilities.driverVersion;\n+import static io.prestosql.JdbcDriverCapabilities.hasBrokenParametricTimestampWithTimeZoneSupport;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestamp;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestampWithTimeZone;\n+import static io.prestosql.JdbcDriverCapabilities.supportsSessionPropertiesViaConnectionUri;\n+import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> VERSION_UNDER_TEST = testedVersion();\n+    private static final int TIMESTAMP_DEFAULT_PRECISION = 3;\n+    private static final int TIMESTAMP_JDBC_MAX_PRECISION = 9; // nanoseconds\n+    private static final int TIMESTAMP_MAX_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        server.installPlugin(new MongoPlugin());\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (VERSION_UNDER_TEST.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(driverVersion())\n+                .isEqualTo(VERSION_UNDER_TEST.get());\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (VERSION_UNDER_TEST.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(VERSION_UNDER_TEST.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT TIMESTAMP '2012-10-31 01:00'\";\n+        checkRepresentation(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), ResultSet::getTimestamp);\n+    }\n+\n+    @Test\n+    public void testTimestampWithTimeZoneSelect()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String query = format(\"SELECT timestamp '2012-10-31 01:00 %s'\", TESTED_TZ);\n+        checkRepresentation(query, Timestamp.valueOf(\"2012-10-30 10:15:00.000\"), ResultSet::getTimestamp);\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestamp()\n+    {\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(timestamp, precision, TIMESTAMP_JDBC_MAX_PRECISION, false);\n+\n+            checkRepresentation(query, expectedTimestamp, ResultSet::getTimestamp);\n+            checkRepresentation(query, expectedTimestamp, ResultSet::getObject);\n+            checkRepresentation(query, roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, false), ResultSet::getString);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampWithTimeZone()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+        String localTimestamp = \"2020-07-16 02:10:23.383345789012\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5Mjg3OQ==", "bodyText": "test getString as well\nalso, what does java.sql.ResultSetMetaData#getColumnType report for object id?", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462192879", "createdAt": "2020-07-29T10:16:45Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.plugin.mongodb.MongoPlugin;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.JdbcDriverCapabilities.driverVersion;\n+import static io.prestosql.JdbcDriverCapabilities.hasBrokenParametricTimestampWithTimeZoneSupport;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestamp;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestampWithTimeZone;\n+import static io.prestosql.JdbcDriverCapabilities.supportsSessionPropertiesViaConnectionUri;\n+import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> VERSION_UNDER_TEST = testedVersion();\n+    private static final int TIMESTAMP_DEFAULT_PRECISION = 3;\n+    private static final int TIMESTAMP_JDBC_MAX_PRECISION = 9; // nanoseconds\n+    private static final int TIMESTAMP_MAX_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        server.installPlugin(new MongoPlugin());\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (VERSION_UNDER_TEST.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(driverVersion())\n+                .isEqualTo(VERSION_UNDER_TEST.get());\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (VERSION_UNDER_TEST.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(VERSION_UNDER_TEST.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT TIMESTAMP '2012-10-31 01:00'\";\n+        checkRepresentation(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), ResultSet::getTimestamp);\n+    }\n+\n+    @Test\n+    public void testTimestampWithTimeZoneSelect()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String query = format(\"SELECT timestamp '2012-10-31 01:00 %s'\", TESTED_TZ);\n+        checkRepresentation(query, Timestamp.valueOf(\"2012-10-30 10:15:00.000\"), ResultSet::getTimestamp);\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestamp()\n+    {\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(timestamp, precision, TIMESTAMP_JDBC_MAX_PRECISION, false);\n+\n+            checkRepresentation(query, expectedTimestamp, ResultSet::getTimestamp);\n+            checkRepresentation(query, expectedTimestamp, ResultSet::getObject);\n+            checkRepresentation(query, roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, false), ResultSet::getString);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampWithTimeZone()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+        String localTimestamp = \"2020-07-16 02:10:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, true);\n+\n+            checkRepresentation(query, expectedTimestamp + \" \" + TESTED_TZ, ResultSet::getString);\n+            checkRepresentation(query, roundedSqlTimestamp(localTimestamp, precision, TIMESTAMP_JDBC_MAX_PRECISION, true), ResultSet::getTimestamp);\n+            checkRepresentation(query, roundedSqlTimestamp(localTimestamp, precision, TIMESTAMP_JDBC_MAX_PRECISION, true), ResultSet::getObject);\n+\n+            checkDescribeTimestampType(query, \"%s\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInMap()\n+    {\n+        String timestamp = \"2004-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s' as TIMESTAMP(%d)))])\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, false);\n+\n+            checkRepresentation(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromMap);\n+            checkDescribeTimestampType(query, \"map(varchar(9), %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampWithTimezoneInMap()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String timestamp = \"2004-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE))])\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, true);\n+\n+            checkRepresentation(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromMap);\n+            checkDescribeTimestampType(query, \"map(varchar(9), %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInArray()\n+    {\n+        String timestamp = \"2004-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s' as TIMESTAMP(%d))]\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, false);\n+\n+            checkRepresentation(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromArray);\n+            checkDescribeTimestampType(query, \"array(%s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampWithTimeZoneInArray()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String timestamp = \"1984-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)]\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, true);\n+\n+            checkRepresentation(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromArray);\n+            checkDescribeTimestampType(query, \"array(%s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInRow()\n+    {\n+        String timestamp = \"2014-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s') AS ROW(timestamp TIMESTAMP(%d)))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, false);\n+\n+            checkRepresentation(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromRow);\n+            checkDescribeTimestampType(query, \"row(timestamp %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampWithTimeZoneInRow()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String timestamp = \"2004-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s %s') AS ROW(timestamp TIMESTAMP(%d) WITH TIME ZONE))\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, true);\n+\n+            checkRepresentation(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromRow);\n+\n+            checkDescribeTimestampType(query, \"row(timestamp %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectMongoObjectId()\n+    {\n+        String query = \"SELECT ObjectId('55b151633864d6438c61a9ce') AS objectId\";\n+        checkRepresentation(query, new byte[]{85, -79, 81, 99, 56, 100, -42, 67, -116, 97, -87, -50}, ResultSet::getObject);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 277}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5MzE1NA==", "bodyText": "testSelectArray?", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462193154", "createdAt": "2020-07-29T10:17:20Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.plugin.mongodb.MongoPlugin;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.JdbcDriverCapabilities.driverVersion;\n+import static io.prestosql.JdbcDriverCapabilities.hasBrokenParametricTimestampWithTimeZoneSupport;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestamp;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestampWithTimeZone;\n+import static io.prestosql.JdbcDriverCapabilities.supportsSessionPropertiesViaConnectionUri;\n+import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> VERSION_UNDER_TEST = testedVersion();\n+    private static final int TIMESTAMP_DEFAULT_PRECISION = 3;\n+    private static final int TIMESTAMP_JDBC_MAX_PRECISION = 9; // nanoseconds\n+    private static final int TIMESTAMP_MAX_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        server.installPlugin(new MongoPlugin());\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (VERSION_UNDER_TEST.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(driverVersion())\n+                .isEqualTo(VERSION_UNDER_TEST.get());\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (VERSION_UNDER_TEST.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(VERSION_UNDER_TEST.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT TIMESTAMP '2012-10-31 01:00'\";\n+        checkRepresentation(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), ResultSet::getTimestamp);\n+    }\n+\n+    @Test\n+    public void testTimestampWithTimeZoneSelect()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String query = format(\"SELECT timestamp '2012-10-31 01:00 %s'\", TESTED_TZ);\n+        checkRepresentation(query, Timestamp.valueOf(\"2012-10-30 10:15:00.000\"), ResultSet::getTimestamp);\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestamp()\n+    {\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(timestamp, precision, TIMESTAMP_JDBC_MAX_PRECISION, false);\n+\n+            checkRepresentation(query, expectedTimestamp, ResultSet::getTimestamp);\n+            checkRepresentation(query, expectedTimestamp, ResultSet::getObject);\n+            checkRepresentation(query, roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, false), ResultSet::getString);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampWithTimeZone()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+        String localTimestamp = \"2020-07-16 02:10:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, true);\n+\n+            checkRepresentation(query, expectedTimestamp + \" \" + TESTED_TZ, ResultSet::getString);\n+            checkRepresentation(query, roundedSqlTimestamp(localTimestamp, precision, TIMESTAMP_JDBC_MAX_PRECISION, true), ResultSet::getTimestamp);\n+            checkRepresentation(query, roundedSqlTimestamp(localTimestamp, precision, TIMESTAMP_JDBC_MAX_PRECISION, true), ResultSet::getObject);\n+\n+            checkDescribeTimestampType(query, \"%s\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInMap()\n+    {\n+        String timestamp = \"2004-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s' as TIMESTAMP(%d)))])\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, false);\n+\n+            checkRepresentation(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromMap);\n+            checkDescribeTimestampType(query, \"map(varchar(9), %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampWithTimezoneInMap()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String timestamp = \"2004-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE))])\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, true);\n+\n+            checkRepresentation(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromMap);\n+            checkDescribeTimestampType(query, \"map(varchar(9), %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInArray()\n+    {\n+        String timestamp = \"2004-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s' as TIMESTAMP(%d))]\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, false);\n+\n+            checkRepresentation(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromArray);\n+            checkDescribeTimestampType(query, \"array(%s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampWithTimeZoneInArray()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String timestamp = \"1984-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)]\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, true);\n+\n+            checkRepresentation(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromArray);\n+            checkDescribeTimestampType(query, \"array(%s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInRow()\n+    {\n+        String timestamp = \"2014-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s') AS ROW(timestamp TIMESTAMP(%d)))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, false);\n+\n+            checkRepresentation(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromRow);\n+            checkDescribeTimestampType(query, \"row(timestamp %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampWithTimeZoneInRow()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String timestamp = \"2004-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s %s') AS ROW(timestamp TIMESTAMP(%d) WITH TIME ZONE))\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, true);\n+\n+            checkRepresentation(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromRow);\n+\n+            checkDescribeTimestampType(query, \"row(timestamp %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectMongoObjectId()\n+    {\n+        String query = \"SELECT ObjectId('55b151633864d6438c61a9ce') AS objectId\";\n+        checkRepresentation(query, new byte[]{85, -79, 81, 99, 56, 100, -42, 67, -116, 97, -87, -50}, ResultSet::getObject);\n+    }\n+\n+    @Test\n+    public void testJdbcRepresentations()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5MzQ3Mg==", "bodyText": "typo: omit", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462193472", "createdAt": "2020-07-29T10:18:01Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.plugin.mongodb.MongoPlugin;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.JdbcDriverCapabilities.driverVersion;\n+import static io.prestosql.JdbcDriverCapabilities.hasBrokenParametricTimestampWithTimeZoneSupport;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestamp;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestampWithTimeZone;\n+import static io.prestosql.JdbcDriverCapabilities.supportsSessionPropertiesViaConnectionUri;\n+import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility\n+{\n+    private static final Optional<Integer> VERSION_UNDER_TEST = testedVersion();\n+    private static final int TIMESTAMP_DEFAULT_PRECISION = 3;\n+    private static final int TIMESTAMP_JDBC_MAX_PRECISION = 9; // nanoseconds\n+    private static final int TIMESTAMP_MAX_PRECISION = 12; // picoseconds\n+    private static final String TESTED_TZ = \"Australia/Eucla\"; // GMT+8:45\n+\n+    private TestingPrestoServer server;\n+    private String serverUrl;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        Logging.initialize();\n+\n+        server = TestingPrestoServer.builder()\n+                .build();\n+\n+        server.installPlugin(new MongoPlugin());\n+\n+        serverUrl = format(\"jdbc:presto://%s\", server.getAddress());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        server.close();\n+    }\n+\n+    @Test\n+    public void ensureProperDriverVersionLoaded()\n+    {\n+        if (VERSION_UNDER_TEST.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(driverVersion())\n+                .isEqualTo(VERSION_UNDER_TEST.get());\n+    }\n+\n+    @Test\n+    public void ensureUsingProperCliVersion()\n+            throws ClassNotFoundException\n+    {\n+        if (VERSION_UNDER_TEST.isEmpty()) {\n+            throw new SkipException(\"PRESTO_JDBC_VERSION environment variable is missing\");\n+        }\n+\n+        assertThat(Class.forName(\"io.prestosql.jdbc.$internal.client.StatementClientFactory\").getPackage().getImplementationVersion())\n+                .isEqualTo(Integer.toString(VERSION_UNDER_TEST.get()));\n+    }\n+\n+    @Test\n+    public void testLongPreparedStatement()\n+            throws Exception\n+    {\n+        String sql = format(\"SELECT '%s' = '%s'\", repeat(\"x\", 100_000), repeat(\"y\", 100_000));\n+\n+        try (ResultSet rs = runQuery(sql)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(rs.getBoolean(1)).isFalse();\n+            assertThat(rs.next()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testTimestampSelect()\n+    {\n+        String query = \"SELECT TIMESTAMP '2012-10-31 01:00'\";\n+        checkRepresentation(query, Timestamp.valueOf(\"2012-10-31 01:00:00.000\"), ResultSet::getTimestamp);\n+    }\n+\n+    @Test\n+    public void testTimestampWithTimeZoneSelect()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String query = format(\"SELECT timestamp '2012-10-31 01:00 %s'\", TESTED_TZ);\n+        checkRepresentation(query, Timestamp.valueOf(\"2012-10-30 10:15:00.000\"), ResultSet::getTimestamp);\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestamp()\n+    {\n+        String timestamp = \"2421-01-19 15:55:23.393456298901\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s' as TIMESTAMP(%d))\", timestamp, precision);\n+            Timestamp expectedTimestamp = roundedSqlTimestamp(timestamp, precision, TIMESTAMP_JDBC_MAX_PRECISION, false);\n+\n+            checkRepresentation(query, expectedTimestamp, ResultSet::getTimestamp);\n+            checkRepresentation(query, expectedTimestamp, ResultSet::getObject);\n+            checkRepresentation(query, roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, false), ResultSet::getString);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampWithTimeZone()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String timestamp = \"2020-07-16 15:55:23.383345789012\";\n+        String localTimestamp = \"2020-07-16 02:10:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, true);\n+\n+            checkRepresentation(query, expectedTimestamp + \" \" + TESTED_TZ, ResultSet::getString);\n+            checkRepresentation(query, roundedSqlTimestamp(localTimestamp, precision, TIMESTAMP_JDBC_MAX_PRECISION, true), ResultSet::getTimestamp);\n+            checkRepresentation(query, roundedSqlTimestamp(localTimestamp, precision, TIMESTAMP_JDBC_MAX_PRECISION, true), ResultSet::getObject);\n+\n+            checkDescribeTimestampType(query, \"%s\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInMap()\n+    {\n+        String timestamp = \"2004-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s' as TIMESTAMP(%d)))])\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, false);\n+\n+            checkRepresentation(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromMap);\n+            checkDescribeTimestampType(query, \"map(varchar(9), %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampWithTimezoneInMap()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String timestamp = \"2004-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT map_from_entries(ARRAY[('timestamp', cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE))])\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, true);\n+\n+            checkRepresentation(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromMap);\n+            checkDescribeTimestampType(query, \"map(varchar(9), %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInArray()\n+    {\n+        String timestamp = \"2004-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s' as TIMESTAMP(%d))]\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, false);\n+\n+            checkRepresentation(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromArray);\n+            checkDescribeTimestampType(query, \"array(%s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampWithTimeZoneInArray()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String timestamp = \"1984-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT ARRAY[cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)]\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, true);\n+\n+            checkRepresentation(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromArray);\n+            checkDescribeTimestampType(query, \"array(%s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampInRow()\n+    {\n+        String timestamp = \"2014-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s') AS ROW(timestamp TIMESTAMP(%d)))\", timestamp, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, false);\n+\n+            checkRepresentation(query, expectedTimestamp, TestJdbcCompatibility::getSingleElementFromRow);\n+            checkDescribeTimestampType(query, \"row(timestamp %s)\", precision, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectParametricTimestampWithTimeZoneInRow()\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        String timestamp = \"2004-08-24 23:55:23.383345789012\";\n+\n+        for (int precision = 0; precision <= TIMESTAMP_MAX_PRECISION; precision++) {\n+            String query = format(\"SELECT CAST(ROW(TIMESTAMP '%s %s') AS ROW(timestamp TIMESTAMP(%d) WITH TIME ZONE))\", timestamp, TESTED_TZ, precision);\n+            String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, true);\n+\n+            checkRepresentation(query, expectedTimestamp + \" \" + TESTED_TZ, TestJdbcCompatibility::getSingleElementFromRow);\n+\n+            checkDescribeTimestampType(query, \"row(timestamp %s)\", precision, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectMongoObjectId()\n+    {\n+        String query = \"SELECT ObjectId('55b151633864d6438c61a9ce') AS objectId\";\n+        checkRepresentation(query, new byte[]{85, -79, 81, 99, 56, 100, -42, 67, -116, 97, -87, -50}, ResultSet::getObject);\n+    }\n+\n+    @Test\n+    public void testJdbcRepresentations()\n+    {\n+        String query = \"SELECT ARRAY['presto', 'is', 'awesome']\";\n+        checkRepresentation(query, new Object[]{\"presto\", \"is\", \"awesome\"}, (rs, column) -> rs.getArray(column).getArray());\n+    }\n+\n+    public void checkRepresentation(String query, Object expectedValue, ResultSetMapper extractValue)\n+    {\n+        try (ResultSet rs = runQuery(query)) {\n+            assertThat(rs.next()).isTrue();\n+            assertThat(extractValue.read(rs, 1)).isEqualTo(expectedValue);\n+            assertThat(rs.next()).isFalse();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void checkDescribeTimestampType(String query, String expectedTypePattern, int precision, boolean withTimeZone)\n+    {\n+        assertDescribeType(query, format(expectedTypePattern, describeTimestampType(precision, true, withTimeZone)), true);\n+        assertDescribeType(query, format(expectedTypePattern, describeTimestampType(precision, false, withTimeZone)), false);\n+        assertDescribeOutputType(query, format(expectedTypePattern, describeTimestampType(precision, true, withTimeZone)), true);\n+        assertDescribeOutputType(query, format(expectedTypePattern, describeTimestampType(precision, false, withTimeZone)), false);\n+    }\n+\n+    private void assertDescribeType(String query, String expectedType, boolean ommitPrecision)\n+    {\n+        if (ommitPrecision && !supportsSessionPropertiesViaConnectionUri()) {\n+            // Driver does not support setting session properties\n+            return;\n+        }\n+\n+        useConnection(omitDateTimeTypePrecision(ommitPrecision), connection -> {\n+            try {\n+                connection.prepareStatement(format(\"SELECT 1 FROM (%s AS timestamp) WHERE timestamp = ?\", query));\n+\n+                try (ResultSet resultSet = connection.prepareStatement(\"DESCRIBE INPUT statement1\").executeQuery()) {\n+                    assertThat(resultSet.next()).isTrue();\n+                    assertThat(resultSet.getString(2)).isEqualTo(expectedType);\n+                }\n+            }\n+            catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+    }\n+\n+    private void assertDescribeOutputType(String query, String expectedType, boolean ommitPrecision)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 329}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5NTk4NA==", "bodyText": "is this inheritable ?\n(ie it's not declsared as such, but maybe testng traverses the hierarchy)", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462195984", "createdAt": "2020-07-29T10:23:04Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcResultSetCompatibility.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.TestJdbcResultSet;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.JdbcDriverCapabilities.hasBrokenParametricTimestampWithTimeZoneSupport;\n+import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n+import static io.prestosql.TestingServerUtils.setTestingServer;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@Test(singleThreaded = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5NjQzMw==", "bodyText": "i don't understand this.\nIs it still applicable?", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462196433", "createdAt": "2020-07-29T10:23:57Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcResultSetCompatibility.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.TestJdbcResultSet;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.JdbcDriverCapabilities.hasBrokenParametricTimestampWithTimeZoneSupport;\n+import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n+import static io.prestosql.TestingServerUtils.setTestingServer;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetCompatibility\n+        extends TestJdbcResultSet\n+{\n+    private static final Optional<Integer> VERSION_UNDER_TEST = testedVersion();\n+\n+    @BeforeClass\n+    @Override\n+    public void setupServer()\n+    {\n+        Logging.initialize();\n+        setTestingServer(this, TestingPrestoServer\n+                .builder()\n+                .setProperties(ImmutableMap.of(\"deprecated.omit-datetime-type-precision\", \"true\"))\n+                .build());\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    @Override\n+    public void teardown()\n+    {\n+        // do not close connection and statement as this will fail", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5ODExNA==", "bodyText": "It doesn't compile, since i split the method.\nSince you need this for TIMESTAMP WITH TIME ZONE only, let's\nsplit the testTimestamp into testTimestamp and testTimestampWithTimeZone\n(it was my error that i didn't split it), and override just  testTimestampWithTimeZone\nhere.", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462198114", "createdAt": "2020-07-29T10:26:51Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcResultSetCompatibility.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.TestJdbcResultSet;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.JdbcDriverCapabilities.hasBrokenParametricTimestampWithTimeZoneSupport;\n+import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n+import static io.prestosql.TestingServerUtils.setTestingServer;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetCompatibility\n+        extends TestJdbcResultSet\n+{\n+    private static final Optional<Integer> VERSION_UNDER_TEST = testedVersion();\n+\n+    @BeforeClass\n+    @Override\n+    public void setupServer()\n+    {\n+        Logging.initialize();\n+        setTestingServer(this, TestingPrestoServer\n+                .builder()\n+                .setProperties(ImmutableMap.of(\"deprecated.omit-datetime-type-precision\", \"true\"))\n+                .build());\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    @Override\n+    public void teardown()\n+    {\n+        // do not close connection and statement as this will fail\n+    }\n+\n+    @Override\n+    public void testObjectTypes()\n+            throws Exception\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        super.testObjectTypes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5ODY3MQ==", "bodyText": "move this up\n(i like the fact it's first test in TestJdbcCompatibility -- it's verification of the setup)", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462198671", "createdAt": "2020-07-29T10:27:38Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcResultSetCompatibility.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.TestJdbcResultSet;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.JdbcDriverCapabilities.hasBrokenParametricTimestampWithTimeZoneSupport;\n+import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n+import static io.prestosql.TestingServerUtils.setTestingServer;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetCompatibility\n+        extends TestJdbcResultSet\n+{\n+    private static final Optional<Integer> VERSION_UNDER_TEST = testedVersion();\n+\n+    @BeforeClass\n+    @Override\n+    public void setupServer()\n+    {\n+        Logging.initialize();\n+        setTestingServer(this, TestingPrestoServer\n+                .builder()\n+                .setProperties(ImmutableMap.of(\"deprecated.omit-datetime-type-precision\", \"true\"))\n+                .build());\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    @Override\n+    public void teardown()\n+    {\n+        // do not close connection and statement as this will fail\n+    }\n+\n+    @Override\n+    public void testObjectTypes()\n+            throws Exception\n+    {\n+        if (hasBrokenParametricTimestampWithTimeZoneSupport()) {\n+            throw new SkipException(\"This version raports PARAMETRIC_DATETIME client capability but TIMESTAMP WITH TIME ZONE is not supported\");\n+        }\n+\n+        super.testObjectTypes();\n+    }\n+\n+    @Test\n+    public void ensureProperTestVersionLoaded()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5OTY2Mw==", "bodyText": "We should refactor TestJdbcResultSet into\nbase class and actual class and avoid reflection.", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462199663", "createdAt": "2020-07-29T10:29:06Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestingServerUtils.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import io.prestosql.server.testing.TestingPrestoServer;\n+\n+import java.lang.reflect.Field;\n+\n+public class TestingServerUtils\n+{\n+    private TestingServerUtils() {}\n+\n+    public static void setTestingServer(Object target, TestingPrestoServer server)\n+    {\n+        try {\n+            Field serverField = target.getClass().getSuperclass().getDeclaredField(\"server\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5OTg3MA==", "bodyText": "we should test in both modes: with precision omitted and not.", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462199870", "createdAt": "2020-07-29T10:29:23Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcResultSetCompatibility.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.TestJdbcResultSet;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.JdbcDriverCapabilities.hasBrokenParametricTimestampWithTimeZoneSupport;\n+import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n+import static io.prestosql.TestingServerUtils.setTestingServer;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetCompatibility\n+        extends TestJdbcResultSet\n+{\n+    private static final Optional<Integer> VERSION_UNDER_TEST = testedVersion();\n+\n+    @BeforeClass\n+    @Override\n+    public void setupServer()\n+    {\n+        Logging.initialize();\n+        setTestingServer(this, TestingPrestoServer\n+                .builder()\n+                .setProperties(ImmutableMap.of(\"deprecated.omit-datetime-type-precision\", \"true\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5OTk0MQ==", "bodyText": "redundant?", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462199941", "createdAt": "2020-07-29T10:29:29Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcResultSetCompatibility.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.jdbc.TestJdbcResultSet;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.JdbcDriverCapabilities.hasBrokenParametricTimestampWithTimeZoneSupport;\n+import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n+import static io.prestosql.TestingServerUtils.setTestingServer;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@Test(singleThreaded = true)\n+public class TestJdbcResultSetCompatibility\n+        extends TestJdbcResultSet\n+{\n+    private static final Optional<Integer> VERSION_UNDER_TEST = testedVersion();\n+\n+    @BeforeClass\n+    @Override\n+    public void setupServer()\n+    {\n+        Logging.initialize();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 42}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MTM3NDEz", "url": "https://github.com/trinodb/trino/pull/4194#pullrequestreview-458137413", "createdAt": "2020-07-30T07:09:29Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNzowOToyOVrOG5Wh-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNzoxNDo0NFrOG5Wzuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc5MTE2Mw==", "bodyText": "Let's add decimal tests, see #4626", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462791163", "createdAt": "2020-07-30T07:09:29Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.plugin.mongodb.MongoPlugin;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.JdbcDriverCapabilities.driverVersion;\n+import static io.prestosql.JdbcDriverCapabilities.hasBrokenParametricTimestampWithTimeZoneSupport;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestamp;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestampWithTimeZone;\n+import static io.prestosql.JdbcDriverCapabilities.supportsSessionPropertiesViaConnectionUri;\n+import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static java.sql.Types.JAVA_OBJECT;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc5MjA5Ng==", "bodyText": "TestJdbcResultSetCompatibility seems to cover more, so it seems TestJdbcCompatibility\nis redundant (but it isn't!).\nAdd javadoc explaining how this class is different from TestJdbcResultSetCompatibility", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462792096", "createdAt": "2020-07-30T07:10:32Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logging;\n+import io.prestosql.plugin.mongodb.MongoPlugin;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.sql.Array;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Strings.repeat;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.JdbcDriverCapabilities.driverVersion;\n+import static io.prestosql.JdbcDriverCapabilities.hasBrokenParametricTimestampWithTimeZoneSupport;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestamp;\n+import static io.prestosql.JdbcDriverCapabilities.supportsParametricTimestampWithTimeZone;\n+import static io.prestosql.JdbcDriverCapabilities.supportsSessionPropertiesViaConnectionUri;\n+import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n+import static java.lang.Integer.min;\n+import static java.lang.String.format;\n+import static java.sql.Types.JAVA_OBJECT;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestJdbcCompatibility", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc5MzMxMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            if (( (previous_released_version - first_tested_version) % 3 != 0 )); then\n          \n          \n            \n            if (( (previous_released_version - first_tested_version) % version_step != 0 )); then", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462793313", "createdAt": "2020-07-30T07:11:58Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/bin/run_tests.sh", "diffHunk": "@@ -1,29 +1,35 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n set -xeuo pipefail\n trap \"exit\" INT # allows to terminate script on ctrl+c instead of terminating single mvnw execution\n \n maven=\"${BASH_SOURCE%/*}/../../mvnw\"\n-MAVEN_RUN_TESTS=\"${maven} clean test -Dair.check.skip-all=true -Dmaven.javadoc.skip=true -Dmaven.source.skip=true -B -pl presto-test-jdbc-compatibility\"\n+maven_run_tests=\"${maven} clean test -Dair.check.skip-all=true -Dmaven.javadoc.skip=true -Dmaven.source.skip=true -B -pl presto-test-jdbc-compatibility\"\n \n \"${maven}\" -version\n \n current_version=$(${maven} help:evaluate -Dexpression=project.version -q -DforceStdout)\n previous_released_version=$((${current_version%-SNAPSHOT}-1))\n first_tested_version=312\n+# test n-th version only\n+version_step=3\n \n echo \"Current version: ${current_version}\"\n-echo \"Testing every 3rd version between ${first_tested_version} and ${previous_released_version}\"\n+echo \"Testing every ${version_step}. version between ${first_tested_version} and ${previous_released_version}\"\n \n-versions=$(seq \"${first_tested_version}\" \"${previous_released_version}\")\n+tested_versions=$(seq \"${first_tested_version}\" ${version_step} \"${previous_released_version}\")\n+\n+if (( (previous_released_version - first_tested_version) % 3 != 0 )); then", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc5NDAyMA==", "bodyText": "unnecessary brace", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462794020", "createdAt": "2020-07-30T07:12:50Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -165,9 +169,13 @@ public void testSelectParametricTimestampWithTimeZone()\n             String query = format(\"SELECT cast(TIMESTAMP '%s %s' as TIMESTAMP(%d) WITH TIME ZONE)\", timestamp, TESTED_TZ, precision);\n             String expectedTimestamp = roundedTimestamp(timestamp, precision, TIMESTAMP_MAX_PRECISION, true);\n \n-            checkRepresentation(query, expectedTimestamp + \" \" + TESTED_TZ, ResultSet::getString);\n-            checkRepresentation(query, roundedSqlTimestamp(localTimestamp, precision, TIMESTAMP_JDBC_MAX_PRECISION, true), ResultSet::getTimestamp);\n-            checkRepresentation(query, roundedSqlTimestamp(localTimestamp, precision, TIMESTAMP_JDBC_MAX_PRECISION, true), ResultSet::getObject);\n+            final int currentPrecision = precision;\n+\n+            checkRepresentation(query, ((resultSet, columnIndex) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc5NDQzMg==", "bodyText": "unnecessary brace", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462794432", "createdAt": "2020-07-30T07:13:17Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -274,14 +281,18 @@ public void testSelectParametricTimestampWithTimeZoneInRow()\n     public void testSelectMongoObjectId()\n     {\n         String query = \"SELECT ObjectId('55b151633864d6438c61a9ce') AS objectId\";\n-        checkRepresentation(query, new byte[]{85, -79, 81, 99, 56, 100, -42, 67, -116, 97, -87, -50}, ResultSet::getObject);\n+        checkRepresentation(query, ((resultSet, columnIndex) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc5NTcwNw==", "bodyText": "nit: JAVA_OBJECT could be a parameter to checkRepresentation and this be tested for all cases", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r462795707", "createdAt": "2020-07-30T07:14:44Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -283,8 +284,7 @@ public void testSelectMongoObjectId()\n         String query = \"SELECT ObjectId('55b151633864d6438c61a9ce') AS objectId\";\n         checkRepresentation(query, ((resultSet, columnIndex) -> {\n             assertThat(resultSet.getObject(columnIndex)).isEqualTo(new byte[]{85, -79, 81, 99, 56, 100, -42, 67, -116, 97, -87, -50});\n-            assertThat(resultSet.getString(columnIndex)).isEqualTo(\"\");\n-            assertThat(resultSet.getMetaData().getColumnType(columnIndex)).isEqualTo(\"\");\n+            assertThat(resultSet.getMetaData().getColumnType(columnIndex)).isEqualTo(JAVA_OBJECT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 41}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5MDU1NjI0", "url": "https://github.com/trinodb/trino/pull/4194#pullrequestreview-459055624", "createdAt": "2020-07-31T09:56:44Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwOTo1Njo0NFrOG6C9hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwOTo1OToxOFrOG6DCPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxOTEwOA==", "bodyText": "thanks\nmake TestJdbcResultSetCompatibility a {@link\nAdd a note that TestJdbcResultSetCompatibility uses the old test code from old presto version against new server and this class is a new test code that's used against old JDBC and the new server.\nAlso, maybe we can rename the classes to indicate that? Thoughts?", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r463519108", "createdAt": "2020-07-31T09:56:44Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestJdbcCompatibility.java", "diffHunk": "@@ -49,9 +51,17 @@\n import static io.prestosql.JdbcDriverCapabilities.testedVersion;\n import static java.lang.Integer.min;\n import static java.lang.String.format;\n+import static java.sql.Types.ARRAY;\n import static java.sql.Types.JAVA_OBJECT;\n+import static java.sql.Types.TIMESTAMP;\n import static org.assertj.core.api.Assertions.assertThat;\n \n+/**\n+ * Main purpose of this class is to test cases when current server implementation breaks older JDBC clients\n+ * to ensure that current implementation is backward-compatible.\n+ *\n+ * TestJdbcResultSetCompatibility in that regard is responsible for testing forward compatibility.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyMDMxOA==", "bodyText": "Add a short comment explaining why", "url": "https://github.com/trinodb/trino/pull/4194#discussion_r463520318", "createdAt": "2020-07-31T09:59:18Z", "author": {"login": "findepi"}, "path": "presto-test-jdbc-compatibility/src/test/java/io/prestosql/TestingServerUtils.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql;\n+\n+import io.prestosql.server.testing.TestingPrestoServer;\n+\n+import java.lang.reflect.Field;\n+\n+public class TestingServerUtils\n+{\n+    private TestingServerUtils() {}\n+\n+    public static void setTestingServer(Object target, TestingPrestoServer server)\n+    {\n+        try {\n+            Field serverField = target.getClass().getSuperclass().getDeclaredField(\"server\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5OTY2Mw=="}, "originalCommit": null, "originalPosition": 27}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7b1497410041b092cae19b647af1bd4e7cb7131", "author": {"user": {"login": "wendigo", "name": "Mateusz \"Serafin\" Gajewski"}}, "url": "https://github.com/trinodb/trino/commit/b7b1497410041b092cae19b647af1bd4e7cb7131", "committedDate": "2020-07-31T11:06:51Z", "message": "Test if older JDBC clients are compatible with current Presto server"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "b7b1497410041b092cae19b647af1bd4e7cb7131", "author": {"user": {"login": "wendigo", "name": "Mateusz \"Serafin\" Gajewski"}}, "url": "https://github.com/trinodb/trino/commit/b7b1497410041b092cae19b647af1bd4e7cb7131", "committedDate": "2020-07-31T11:06:51Z", "message": "Test if older JDBC clients are compatible with current Presto server"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 146, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}