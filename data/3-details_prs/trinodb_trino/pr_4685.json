{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyODc1MjEx", "number": 4685, "title": "Support for lazy dynamic filters for replicated joins", "bodyText": "Depends on: #4675", "createdAt": "2020-08-04T16:30:08Z", "url": "https://github.com/trinodb/trino/pull/4685", "merged": true, "mergeCommit": {"oid": "1e37382a08a4dc2090d97ba5b9c14865f070bb2d"}, "closed": true, "closedAt": "2020-09-15T12:43:26Z", "author": {"login": "sopel39"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc77Ub2ABqjM2MjQ3MDE3NDc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJHKdlgBqjM3NjgxMzk2ODE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MDMzNzg4", "url": "https://github.com/trinodb/trino/pull/4685#pullrequestreview-488033788", "createdAt": "2020-09-14T18:25:25Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxODoyNzoxN1rOHRhfgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxODo1MjozNFrOHRiVhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzNjU3Ng==", "bodyText": "I'd inline this", "url": "https://github.com/trinodb/trino/pull/4685#discussion_r488136576", "createdAt": "2020-09-14T18:27:17Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/execution/scheduler/SourcePartitionedScheduler.java", "diffHunk": "@@ -478,6 +501,16 @@ public void close()\n         return newTasks.build();\n     }\n \n+    private Set<RemoteTask> createTaskOnRandomNode()\n+    {\n+        List<InternalNode> allNodes = splitPlacementPolicy.allNodes();\n+        checkState(allNodes.size() > 0, \"No nodes available\");\n+        int position = ThreadLocalRandom.current().nextInt(0, allNodes.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzNjkzOA==", "bodyText": "Should stage.getScheduledNodes() be empty?  If so, I'd check it at the start of the method.", "url": "https://github.com/trinodb/trino/pull/4685#discussion_r488136938", "createdAt": "2020-09-14T18:27:59Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/execution/scheduler/SourcePartitionedScheduler.java", "diffHunk": "@@ -478,6 +501,16 @@ public void close()\n         return newTasks.build();\n     }\n \n+    private Set<RemoteTask> createTaskOnRandomNode()\n+    {\n+        List<InternalNode> allNodes = splitPlacementPolicy.allNodes();\n+        checkState(allNodes.size() > 0, \"No nodes available\");\n+        int position = ThreadLocalRandom.current().nextInt(0, allNodes.size());\n+        InternalNode node = allNodes.get(position);\n+        checkState(!stage.getScheduledNodes().contains(node), \"Stage task is already scheduled on node\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzOTUyNw==", "bodyText": "rename plan to fragment", "url": "https://github.com/trinodb/trino/pull/4685#discussion_r488139527", "createdAt": "2020-09-14T18:32:45Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -189,6 +192,41 @@ public void removeQuery(QueryId queryId)\n         dynamicFilterContexts.remove(queryId);\n     }\n \n+    /**\n+     * Dynamic filters are collected in same stage as the join operator. This can result in deadlock\n+     * for source stage joins and connectors that wait for dynamic filters before generating splits\n+     * (probe splits might be blocked on dynamic filters which require at least one probe task in order to be collected).\n+     * To overcome this issue an initial task is created for source stages running broadcast join operator.\n+     * This task allows for dynamic filters collection without any probe side splits being scheduled.\n+     */\n+    public boolean needsDynamicFiltersCollectingTask(QueryId queryId, PlanFragment plan)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0MDcwNg==", "bodyText": "I find the name needs... to be a bit strange.  It sounds like the command I need....  Consider renaming to isCollectingTaskNeeded.  Given this is the DynamicFilterService the DynamicFilter in the name seems redundant.", "url": "https://github.com/trinodb/trino/pull/4685#discussion_r488140706", "createdAt": "2020-09-14T18:34:55Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -189,6 +192,41 @@ public void removeQuery(QueryId queryId)\n         dynamicFilterContexts.remove(queryId);\n     }\n \n+    /**\n+     * Dynamic filters are collected in same stage as the join operator. This can result in deadlock\n+     * for source stage joins and connectors that wait for dynamic filters before generating splits\n+     * (probe splits might be blocked on dynamic filters which require at least one probe task in order to be collected).\n+     * To overcome this issue an initial task is created for source stages running broadcast join operator.\n+     * This task allows for dynamic filters collection without any probe side splits being scheduled.\n+     */\n+    public boolean needsDynamicFiltersCollectingTask(QueryId queryId, PlanFragment plan)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzOTUyNw=="}, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0MjQ3Nw==", "bodyText": "Sets.difference and Sets.union return a \"view\" which is computed for each iteration and will change when the underlying sets change.  I would make a defensive copy here using ImmutableSet.", "url": "https://github.com/trinodb/trino/pull/4685#discussion_r488142477", "createdAt": "2020-09-14T18:38:11Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -327,8 +365,28 @@ void collectDynamicFilters()\n \n     private static Set<DynamicFilterId> getLazyDynamicFilters(PlanFragment plan)\n     {\n-        // lazy dynamic filters cannot be consumed by the same stage where they are produced as it would result in query deadlock\n-        return difference(getProducedDynamicFilters(plan.getRoot()), getConsumedDynamicFilters(plan.getRoot()));\n+        // To prevent deadlock dynamic filter can be lazy only when:\n+        // 1. it's consumed by different stage from where it's produced\n+        // 2. or it's produced by replicated join in source stage. In such case an extra\n+        //    task is created that will collect dynamic filter and prevent deadlock.\n+        Set<DynamicFilterId> interStageDynamicFilters = difference(getProducedDynamicFilters(plan.getRoot()), getConsumedDynamicFilters(plan.getRoot()));\n+        return union(interStageDynamicFilters, getSourceStageInnerLazyDynamicFilters(plan));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0Njg3MQ==", "bodyText": "same comment about Sets returning views", "url": "https://github.com/trinodb/trino/pull/4685#discussion_r488146871", "createdAt": "2020-09-14T18:46:15Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -327,8 +365,28 @@ void collectDynamicFilters()\n \n     private static Set<DynamicFilterId> getLazyDynamicFilters(PlanFragment plan)\n     {\n-        // lazy dynamic filters cannot be consumed by the same stage where they are produced as it would result in query deadlock\n-        return difference(getProducedDynamicFilters(plan.getRoot()), getConsumedDynamicFilters(plan.getRoot()));\n+        // To prevent deadlock dynamic filter can be lazy only when:\n+        // 1. it's consumed by different stage from where it's produced\n+        // 2. or it's produced by replicated join in source stage. In such case an extra\n+        //    task is created that will collect dynamic filter and prevent deadlock.\n+        Set<DynamicFilterId> interStageDynamicFilters = difference(getProducedDynamicFilters(plan.getRoot()), getConsumedDynamicFilters(plan.getRoot()));\n+        return union(interStageDynamicFilters, getSourceStageInnerLazyDynamicFilters(plan));\n+    }\n+\n+    @VisibleForTesting\n+    static Set<DynamicFilterId> getSourceStageInnerLazyDynamicFilters(PlanFragment plan)\n+    {\n+        if (!plan.getPartitioning().equals(SOURCE_DISTRIBUTION)) {\n+            // Only non-fixed source stages can have (replicated) lazy dynamic filters that are\n+            // produced and consumed within stage. This is because for such stages an extra\n+            // dynamic filtering collecting task can be added.\n+            return ImmutableSet.of();\n+        }\n+\n+        PlanNode planNode = plan.getRoot();\n+        Set<DynamicFilterId> innerStageDynamicFilters = intersection(getProducedDynamicFilters(planNode), getConsumedDynamicFilters(planNode));\n+        Set<DynamicFilterId> replicatedDynamicFilters = getReplicatedDynamicFilters(planNode);\n+        return intersection(innerStageDynamicFilters, replicatedDynamicFilters);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE1MDA4Ng==", "bodyText": "I'm pretty sure this can just be new SymbolReference(\"DF_SYMBOL1\")", "url": "https://github.com/trinodb/trino/pull/4685#discussion_r488150086", "createdAt": "2020-09-14T18:52:00Z", "author": {"login": "dain"}, "path": "presto-main/src/test/java/io/prestosql/execution/scheduler/TestSourcePartitionedScheduler.java", "diffHunk": "@@ -446,6 +462,49 @@ public void testNoNewTaskScheduledWhenChildStageBufferIsOverutilized()\n         assertEquals(scheduleResult.getSplitsScheduled(), 0);\n     }\n \n+    @Test\n+    public void testDynamicFiltersUnblockedOnBlockedBuildSource()\n+    {\n+        StageExecutionPlan plan = createPlan(createBlockedSplitSource());\n+        NodeTaskMap nodeTaskMap = new NodeTaskMap(finalizerService);\n+        SqlStageExecution stage = createSqlStageExecution(plan, nodeTaskMap);\n+        NodeScheduler nodeScheduler = new NodeScheduler(new UniformNodeSelectorFactory(nodeManager, new NodeSchedulerConfig().setIncludeCoordinator(false), nodeTaskMap));\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(new FeaturesConfig());\n+        dynamicFilterService.registerQuery(\n+                QUERY_ID,\n+                ImmutableList::of,\n+                ImmutableSet.of(DYNAMIC_FILTER_ID),\n+                ImmutableSet.of(DYNAMIC_FILTER_ID),\n+                ImmutableSet.of(DYNAMIC_FILTER_ID));\n+        StageScheduler scheduler = newSourcePartitionedSchedulerAsStageScheduler(\n+                stage,\n+                Iterables.getOnlyElement(plan.getSplitSources().keySet()),\n+                Iterables.getOnlyElement(plan.getSplitSources().values()),\n+                new DynamicSplitPlacementPolicy(nodeScheduler.createNodeSelector(Optional.of(CONNECTOR_ID)), stage::getAllTasks),\n+                2,\n+                dynamicFilterService,\n+                () -> true);\n+\n+        Expression df1 = expression(\"DF_SYMBOL1\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE1MDQwNQ==", "bodyText": "no need for the line wrap here and the next one", "url": "https://github.com/trinodb/trino/pull/4685#discussion_r488150405", "createdAt": "2020-09-14T18:52:34Z", "author": {"login": "dain"}, "path": "presto-main/src/test/java/io/prestosql/execution/scheduler/TestSourcePartitionedScheduler.java", "diffHunk": "@@ -446,6 +462,49 @@ public void testNoNewTaskScheduledWhenChildStageBufferIsOverutilized()\n         assertEquals(scheduleResult.getSplitsScheduled(), 0);\n     }\n \n+    @Test\n+    public void testDynamicFiltersUnblockedOnBlockedBuildSource()\n+    {\n+        StageExecutionPlan plan = createPlan(createBlockedSplitSource());\n+        NodeTaskMap nodeTaskMap = new NodeTaskMap(finalizerService);\n+        SqlStageExecution stage = createSqlStageExecution(plan, nodeTaskMap);\n+        NodeScheduler nodeScheduler = new NodeScheduler(new UniformNodeSelectorFactory(nodeManager, new NodeSchedulerConfig().setIncludeCoordinator(false), nodeTaskMap));\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(new FeaturesConfig());\n+        dynamicFilterService.registerQuery(\n+                QUERY_ID,\n+                ImmutableList::of,\n+                ImmutableSet.of(DYNAMIC_FILTER_ID),\n+                ImmutableSet.of(DYNAMIC_FILTER_ID),\n+                ImmutableSet.of(DYNAMIC_FILTER_ID));\n+        StageScheduler scheduler = newSourcePartitionedSchedulerAsStageScheduler(\n+                stage,\n+                Iterables.getOnlyElement(plan.getSplitSources().keySet()),\n+                Iterables.getOnlyElement(plan.getSplitSources().values()),\n+                new DynamicSplitPlacementPolicy(nodeScheduler.createNodeSelector(Optional.of(CONNECTOR_ID)), stage::getAllTasks),\n+                2,\n+                dynamicFilterService,\n+                () -> true);\n+\n+        Expression df1 = expression(\"DF_SYMBOL1\");\n+        DynamicFilter dynamicFilter = dynamicFilterService.createDynamicFilter(\n+                QUERY_ID,\n+                ImmutableList.of(\n+                        new DynamicFilters.Descriptor(DYNAMIC_FILTER_ID, df1)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 122}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f8b4d50becd1961ff70535c16f27113aeee9874", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/5f8b4d50becd1961ff70535c16f27113aeee9874", "committedDate": "2020-09-15T12:33:04Z", "message": "Support for lazy dynamic filters for replicated joins"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b18e277e919f015a25c0c07c329f0c80567603c", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/5b18e277e919f015a25c0c07c329f0c80567603c", "committedDate": "2020-09-15T12:33:04Z", "message": "Simplify TestCoordinatorDynamicFiltering tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "5b18e277e919f015a25c0c07c329f0c80567603c", "author": {"user": {"login": "sopel39", "name": "Karol Sobczak"}}, "url": "https://github.com/trinodb/trino/commit/5b18e277e919f015a25c0c07c329f0c80567603c", "committedDate": "2020-09-15T12:33:04Z", "message": "Simplify TestCoordinatorDynamicFiltering tests"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4626, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}