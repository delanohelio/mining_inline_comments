{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0OTIxMjU5", "number": 4748, "title": "Refactor HiveMetastore API and Implementations", "bodyText": "This commit changes the HiveMetastore API to remove methods to methods\ngetPartionNames() and getPartitionNamesByParts() and replace with\ngetPartitionNamesByFilter(). Each implementation is updated as well as\nall callsites. The previous behavior is maintained as far as\ntranslation of any non-equal Domain values to the wildcard value.\nA subsequent commit will implement this for the GlueHiveMetastore and\npass the supported translation of the Domain per column using the\nGetPartitions API in the Glue Data Catalog.", "createdAt": "2020-08-08T01:27:16Z", "url": "https://github.com/trinodb/trino/pull/4748", "merged": true, "mergeCommit": {"oid": "975bd661afbed00898d44cff320837e921a6f62e"}, "closed": true, "closedAt": "2020-08-27T23:13:13Z", "author": {"login": "rash67"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc9pmrYgBqjM2NDA2NDg5MjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdUCoMbAFqTUxMTY3MDQ2Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NzExNDI2", "url": "https://github.com/trinodb/trino/pull/4748#pullrequestreview-469711426", "createdAt": "2020-08-18T18:19:08Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxODoxOTowOFrOHCgkCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyMjo0OFrOHClAxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5MjcxMg==", "bodyText": "Move to io.prestosql.plugin.hive.util package", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r472392712", "createdAt": "2020-08-18T18:19:08Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/spi/block/BlockJsonSerde.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.spi.block;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5NDY2Nw==", "bodyText": "We shouldn't bind RecordingHiveMetastore here unconditionally.\nThere are three duplicated bindings for RecordingHiveMetastore in ThriftMetastoreModule and GlueMetastoreModule. Existing duplicated code:\nbinder.bind(HiveMetastore.class)\n        .annotatedWith(ForCachingHiveMetastore.class)\n        .to(RecordingHiveMetastore.class)\n        .in(Scopes.SINGLETON);\nbinder.bind(RecordingHiveMetastore.class).in(Scopes.SINGLETON);\nnewExporter(binder).export(RecordingHiveMetastore.class).withGeneratedName();\nCreate a RecordingHiveMetastoreModule and move that plus this code into the new module. Then install the module in those metastore modules.", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r472394667", "createdAt": "2020-08-18T18:22:31Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveModule.java", "diffHunk": "@@ -124,6 +128,11 @@ public void configure(Binder binder)\n \n         jsonBinder(binder).addDeserializerBinding(Type.class).to(TypeDeserializer.class);\n \n+        binder.bind(HiveBlockEncodingSerde.class).in(Scopes.SINGLETON);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2NDYyNg==", "bodyText": "Nit: the \"else\" are redundant since the above \"if\" returns\nif (...) {\n    return ...;\n}\nif (...) {\n    return ...;\n}", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r472464626", "createdAt": "2020-08-18T20:21:44Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/MetastoreUtil.java", "diffHunk": "@@ -290,4 +321,118 @@ public static PrincipalPrivileges buildInitialPrivilegeSet(String tableOwner)\n                         .build(),\n                 ImmutableMultimap.of());\n     }\n+\n+    public static boolean isPartitionKeyFilterFalse(TupleDomain<String> partitionKeysFilter)\n+    {\n+        return partitionKeysFilter.isNone() || partitionKeysFilter.getDomains().get().values().stream().anyMatch(Domain::isNone);\n+    }\n+\n+    /**\n+     * @param columnNames\n+     * @param partitionKeysFilter\n+     * @param assumeCanonicalPartitionKeys allow conversion of\n+     * @return the Domain for each partition key to either the wildcard or an equals check.\n+     * TupleDomain.none() or any column's Domain.isNone() -> Optional.empty()\n+     */\n+    public static Optional<List<String>> partitionKeyFilterToStringList(List<String> columnNames, TupleDomain<String> partitionKeysFilter, boolean assumeCanonicalPartitionKeys)\n+    {\n+        if (isPartitionKeyFilterFalse(partitionKeysFilter)) {\n+            return Optional.empty();\n+        }\n+\n+        checkArgument(partitionKeysFilter.getDomains().isPresent());\n+\n+        Map<String, Domain> domainMap = partitionKeysFilter.getDomains().orElse(ImmutableMap.of());\n+        List<String> partitionList = columnNames.stream().map(cn -> domainToString(domainMap.get(cn), assumeCanonicalPartitionKeys, HIVE_PARTITION_VALUE_WILDCARD)).collect(toImmutableList());\n+        return Optional.of(partitionList);\n+    }\n+\n+    /**\n+     * @param domain - domain expression for the column. null => TupleDomain.all()\n+     * @param assumeCanonicalPartitionKeys\n+     * @param partitionWildcardString wildcard\n+     * @return string for scalar values\n+     */\n+    public static String domainToString(Domain domain, boolean assumeCanonicalPartitionKeys, String partitionWildcardString)\n+    {\n+        if (domain != null && domain.isNullableSingleValue()) {\n+            return sqlScalarToString(domain.getType(), domain.getNullableSingleValue(), assumeCanonicalPartitionKeys, partitionWildcardString);\n+        }\n+        else { // null or not a single value\n+            return partitionWildcardString;\n+        }\n+    }\n+\n+    /**\n+     * @param type\n+     * @param value\n+     * @param assumeCanonicalPartitionKeys\n+     * @param partitionWildcardString\n+     * @return value converted a string format. Returns\n+     */\n+    public static String sqlScalarToString(Type type, Object value, boolean assumeCanonicalPartitionKeys, String partitionWildcardString)\n+    {\n+        if (value == null) {\n+            return HIVE_DEFAULT_DYNAMIC_PARTITION;\n+        }\n+        else if (type instanceof CharType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2NTYwNQ==", "bodyText": "Make sure to remove later", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r472465605", "createdAt": "2020-08-18T20:22:48Z", "author": {"login": "electrum"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/HiveQueryRunner.java", "diffHunk": "@@ -297,5 +296,21 @@ public static void main(String[] args)\n         Thread.sleep(10);\n         log.info(\"======== SERVER STARTED ========\");\n         log.info(\"\\n====\\n%s\\n====\", queryRunner.getCoordinator().getBaseUrl());\n+\n+        Session session = createSession(Optional.empty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxODgxMTU0", "url": "https://github.com/trinodb/trino/pull/4748#pullrequestreview-471881154", "createdAt": "2020-08-20T18:34:56Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxODozNDo1NlrOHEOVqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwMTo1MToyM1rOHEY2yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5MTI3NA==", "bodyText": "It looks like this method signature didn't change, so keep the original formatting for the arguments.", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r474191274", "createdAt": "2020-08-20T18:34:56Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HivePartitionManager.java", "diffHunk": "@@ -266,70 +241,17 @@ public static boolean partitionMatches(List<HiveColumnHandle> partitionColumns,\n         return true;\n     }\n \n-    private List<String> getFilteredPartitionNames(SemiTransactionalHiveMetastore metastore, HiveIdentity identity, SchemaTableName tableName, List<HiveColumnHandle> partitionKeys, TupleDomain<ColumnHandle> effectivePredicate)\n+    private List<String> getFilteredPartitionNames(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5NTgyNQ==", "bodyText": "This seems to be missing something. Maybe remove all the @param and just explain what the method does.", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r474195825", "createdAt": "2020-08-20T18:43:01Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/MetastoreUtil.java", "diffHunk": "@@ -290,4 +321,118 @@ public static PrincipalPrivileges buildInitialPrivilegeSet(String tableOwner)\n                         .build(),\n                 ImmutableMultimap.of());\n     }\n+\n+    public static boolean isPartitionKeyFilterFalse(TupleDomain<String> partitionKeysFilter)\n+    {\n+        return partitionKeysFilter.isNone() || partitionKeysFilter.getDomains().get().values().stream().anyMatch(Domain::isNone);\n+    }\n+\n+    /**\n+     * @param columnNames\n+     * @param partitionKeysFilter\n+     * @param assumeCanonicalPartitionKeys allow conversion of", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5NTk3Mw==", "bodyText": "We avoid having empty/useless documentation for obvious parameters.", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r474195973", "createdAt": "2020-08-20T18:43:15Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/MetastoreUtil.java", "diffHunk": "@@ -290,4 +321,118 @@ public static PrincipalPrivileges buildInitialPrivilegeSet(String tableOwner)\n                         .build(),\n                 ImmutableMultimap.of());\n     }\n+\n+    public static boolean isPartitionKeyFilterFalse(TupleDomain<String> partitionKeysFilter)\n+    {\n+        return partitionKeysFilter.isNone() || partitionKeysFilter.getDomains().get().values().stream().anyMatch(Domain::isNone);\n+    }\n+\n+    /**\n+     * @param columnNames", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5NjQyMg==", "bodyText": "Nit: wrap stream operations\nList x = stream()\n        .map(...)\n        .collect(...);", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r474196422", "createdAt": "2020-08-20T18:44:06Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/MetastoreUtil.java", "diffHunk": "@@ -290,4 +321,118 @@ public static PrincipalPrivileges buildInitialPrivilegeSet(String tableOwner)\n                         .build(),\n                 ImmutableMultimap.of());\n     }\n+\n+    public static boolean isPartitionKeyFilterFalse(TupleDomain<String> partitionKeysFilter)\n+    {\n+        return partitionKeysFilter.isNone() || partitionKeysFilter.getDomains().get().values().stream().anyMatch(Domain::isNone);\n+    }\n+\n+    /**\n+     * @param columnNames\n+     * @param partitionKeysFilter\n+     * @param assumeCanonicalPartitionKeys allow conversion of\n+     * @return the Domain for each partition key to either the wildcard or an equals check.\n+     * TupleDomain.none() or any column's Domain.isNone() -> Optional.empty()\n+     */\n+    public static Optional<List<String>> partitionKeyFilterToStringList(List<String> columnNames, TupleDomain<String> partitionKeysFilter, boolean assumeCanonicalPartitionKeys)\n+    {\n+        if (isPartitionKeyFilterFalse(partitionKeysFilter)) {\n+            return Optional.empty();\n+        }\n+\n+        checkArgument(partitionKeysFilter.getDomains().isPresent());\n+\n+        Map<String, Domain> domainMap = partitionKeysFilter.getDomains().orElse(ImmutableMap.of());\n+        List<String> partitionList = columnNames.stream().map(cn -> domainToString(domainMap.get(cn), assumeCanonicalPartitionKeys, HIVE_PARTITION_VALUE_WILDCARD)).collect(toImmutableList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5NjkyNQ==", "bodyText": "Nit: else is redundant", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r474196925", "createdAt": "2020-08-20T18:44:58Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/MetastoreUtil.java", "diffHunk": "@@ -290,4 +321,118 @@ public static PrincipalPrivileges buildInitialPrivilegeSet(String tableOwner)\n                         .build(),\n                 ImmutableMultimap.of());\n     }\n+\n+    public static boolean isPartitionKeyFilterFalse(TupleDomain<String> partitionKeysFilter)\n+    {\n+        return partitionKeysFilter.isNone() || partitionKeysFilter.getDomains().get().values().stream().anyMatch(Domain::isNone);\n+    }\n+\n+    /**\n+     * @param columnNames\n+     * @param partitionKeysFilter\n+     * @param assumeCanonicalPartitionKeys allow conversion of\n+     * @return the Domain for each partition key to either the wildcard or an equals check.\n+     * TupleDomain.none() or any column's Domain.isNone() -> Optional.empty()\n+     */\n+    public static Optional<List<String>> partitionKeyFilterToStringList(List<String> columnNames, TupleDomain<String> partitionKeysFilter, boolean assumeCanonicalPartitionKeys)\n+    {\n+        if (isPartitionKeyFilterFalse(partitionKeysFilter)) {\n+            return Optional.empty();\n+        }\n+\n+        checkArgument(partitionKeysFilter.getDomains().isPresent());\n+\n+        Map<String, Domain> domainMap = partitionKeysFilter.getDomains().orElse(ImmutableMap.of());\n+        List<String> partitionList = columnNames.stream().map(cn -> domainToString(domainMap.get(cn), assumeCanonicalPartitionKeys, HIVE_PARTITION_VALUE_WILDCARD)).collect(toImmutableList());\n+        return Optional.of(partitionList);\n+    }\n+\n+    /**\n+     * @param domain - domain expression for the column. null => TupleDomain.all()\n+     * @param assumeCanonicalPartitionKeys\n+     * @param partitionWildcardString wildcard\n+     * @return string for scalar values\n+     */\n+    public static String domainToString(Domain domain, boolean assumeCanonicalPartitionKeys, String partitionWildcardString)\n+    {\n+        if (domain != null && domain.isNullableSingleValue()) {\n+            return sqlScalarToString(domain.getType(), domain.getNullableSingleValue(), assumeCanonicalPartitionKeys, partitionWildcardString);\n+        }\n+        else { // null or not a single value", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5OTQwNg==", "bodyText": "Are we trying to preserve order? Does that matter?", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r474199406", "createdAt": "2020-08-20T18:49:36Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/MetastoreUtil.java", "diffHunk": "@@ -290,4 +321,118 @@ public static PrincipalPrivileges buildInitialPrivilegeSet(String tableOwner)\n                         .build(),\n                 ImmutableMultimap.of());\n     }\n+\n+    public static boolean isPartitionKeyFilterFalse(TupleDomain<String> partitionKeysFilter)\n+    {\n+        return partitionKeysFilter.isNone() || partitionKeysFilter.getDomains().get().values().stream().anyMatch(Domain::isNone);\n+    }\n+\n+    /**\n+     * @param columnNames\n+     * @param partitionKeysFilter\n+     * @param assumeCanonicalPartitionKeys allow conversion of\n+     * @return the Domain for each partition key to either the wildcard or an equals check.\n+     * TupleDomain.none() or any column's Domain.isNone() -> Optional.empty()\n+     */\n+    public static Optional<List<String>> partitionKeyFilterToStringList(List<String> columnNames, TupleDomain<String> partitionKeysFilter, boolean assumeCanonicalPartitionKeys)\n+    {\n+        if (isPartitionKeyFilterFalse(partitionKeysFilter)) {\n+            return Optional.empty();\n+        }\n+\n+        checkArgument(partitionKeysFilter.getDomains().isPresent());\n+\n+        Map<String, Domain> domainMap = partitionKeysFilter.getDomains().orElse(ImmutableMap.of());\n+        List<String> partitionList = columnNames.stream().map(cn -> domainToString(domainMap.get(cn), assumeCanonicalPartitionKeys, HIVE_PARTITION_VALUE_WILDCARD)).collect(toImmutableList());\n+        return Optional.of(partitionList);\n+    }\n+\n+    /**\n+     * @param domain - domain expression for the column. null => TupleDomain.all()\n+     * @param assumeCanonicalPartitionKeys\n+     * @param partitionWildcardString wildcard\n+     * @return string for scalar values\n+     */\n+    public static String domainToString(Domain domain, boolean assumeCanonicalPartitionKeys, String partitionWildcardString)\n+    {\n+        if (domain != null && domain.isNullableSingleValue()) {\n+            return sqlScalarToString(domain.getType(), domain.getNullableSingleValue(), assumeCanonicalPartitionKeys, partitionWildcardString);\n+        }\n+        else { // null or not a single value\n+            return partitionWildcardString;\n+        }\n+    }\n+\n+    /**\n+     * @param type\n+     * @param value\n+     * @param assumeCanonicalPartitionKeys\n+     * @param partitionWildcardString\n+     * @return value converted a string format. Returns\n+     */\n+    public static String sqlScalarToString(Type type, Object value, boolean assumeCanonicalPartitionKeys, String partitionWildcardString)\n+    {\n+        if (value == null) {\n+            return HIVE_DEFAULT_DYNAMIC_PARTITION;\n+        }\n+        else if (type instanceof CharType) {\n+            Slice slice = (Slice) value;\n+            return padSpaces(slice, (CharType) type).toStringUtf8();\n+        }\n+        else if (type instanceof VarcharType) {\n+            Slice slice = (Slice) value;\n+            return slice.toStringUtf8();\n+        }\n+        else if (!assumeCanonicalPartitionKeys) {\n+            return partitionWildcardString;\n+        }\n+        else if (type instanceof DecimalType && !((DecimalType) type).isShort()) {\n+            Slice slice = (Slice) value;\n+            return Decimals.toString(slice, ((DecimalType) type).getScale());\n+        }\n+        else if (type instanceof DecimalType && ((DecimalType) type).isShort()) {\n+            return Decimals.toString((long) value, ((DecimalType) type).getScale());\n+        }\n+        else if (type instanceof DateType) {\n+            DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.date().withZoneUTC();\n+            return dateTimeFormatter.print(TimeUnit.DAYS.toMillis((long) value));\n+        }\n+        else if (type instanceof TimestampType) {\n+            // we don't have time zone info, so just add a wildcard\n+            return partitionWildcardString;\n+        }\n+        else if (type instanceof TinyintType\n+                || type instanceof SmallintType\n+                || type instanceof IntegerType\n+                || type instanceof BigintType\n+                || type instanceof DoubleType\n+                || type instanceof RealType\n+                || type instanceof BooleanType) {\n+            return value.toString();\n+        }\n+        else {\n+            throw new PrestoException(NOT_SUPPORTED, format(\"Unsupported partition key type: %s\", type.getDisplayName()));\n+        }\n+    }\n+\n+    /**\n+     * This method creates a TupleDomain for each partitionKey specified\n+     *\n+     * @return filtered version of relevant Domains in effectivePredicate.\n+     */\n+    public static TupleDomain<String> computePartitionKeyFilter(List<HiveColumnHandle> partitionKeys, TupleDomain<ColumnHandle> effectivePredicate)\n+    {\n+        checkArgument(effectivePredicate.getDomains().isPresent());\n+\n+        Map<String, Domain> domains = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIwMTAzNA==", "bodyText": "No need for requireNonNull since the . access will throw NPE anyway", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r474201034", "createdAt": "2020-08-20T18:52:42Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/alluxio/AlluxioHiveMetastore.java", "diffHunk": "@@ -66,12 +69,14 @@\n public class AlluxioHiveMetastore\n         implements HiveMetastore\n {\n+    private final boolean assumeCanonicalPartitionKeys;\n     private TableMasterClient client;\n \n     @Inject\n-    public AlluxioHiveMetastore(TableMasterClient client)\n+    public AlluxioHiveMetastore(TableMasterClient client, AlluxioHiveMetastoreConfig metastoreConfig)\n     {\n         this.client = requireNonNull(client);\n+        this.assumeCanonicalPartitionKeys = requireNonNull(metastoreConfig).isAssumeCanonicalPartitionKeys();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM2MjczMA==", "bodyText": "We shouldn't need the assumeCanonicalPartitionKeys config or filtering here at all, as filtering by the metastore is best effort. This isn't being pushed down, so we can let the caller do it.", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r474362730", "createdAt": "2020-08-21T01:47:56Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/file/FileHiveMetastore.java", "diffHunk": "@@ -990,11 +994,24 @@ private boolean isValidPartition(Table table, String partitionName)\n     }\n \n     @Override\n-    public synchronized Optional<List<String>> getPartitionNamesByParts(HiveIdentity identity, String databaseName, String tableName, List<String> parts)\n+    public Optional<List<String>> getPartitionNamesByFilter(\n+            HiveIdentity identity,\n+            String databaseName,\n+            String tableName,\n+            List<String> columnNames,\n+            TupleDomain<String> partitionKeysFilter)\n     {\n-        // todo this should be more efficient by selectively walking the directory tree\n-        return getPartitionNames(identity, databaseName, tableName).map(partitionNames -> partitionNames.stream()\n-                .filter(partitionName -> partitionMatches(partitionName, parts))\n+        if (partitionKeysFilter.isNone()) {\n+            return Optional.of(ImmutableList.of());\n+        }\n+        Optional<List<String>> parts = partitionKeyFilterToStringList(columnNames, partitionKeysFilter, assumeCanonicalPartitionKeys);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM2MzU5Mw==", "bodyText": "Should we drop the getPartitionNames() method from the ThriftMetastore interface? Then this can be a straight delegation.", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r474363593", "createdAt": "2020-08-21T01:51:23Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/thrift/BridgingHiveMetastore.java", "diffHunk": "@@ -319,15 +321,22 @@ private void alterTable(HiveIdentity identity, String databaseName, String table\n     }\n \n     @Override\n-    public Optional<List<String>> getPartitionNames(HiveIdentity identity, String databaseName, String tableName)\n+    public Optional<List<String>> getPartitionNamesByFilter(\n+            HiveIdentity identity,\n+            String databaseName,\n+            String tableName,\n+            List<String> columnNames,\n+            TupleDomain<String> partitionKeysFilter)\n     {\n-        return delegate.getPartitionNames(identity, databaseName, tableName);\n-    }\n+        if (partitionKeysFilter.isNone()) {\n+            return Optional.of(ImmutableList.of());\n+        }\n \n-    @Override\n-    public Optional<List<String>> getPartitionNamesByParts(HiveIdentity identity, String databaseName, String tableName, List<String> parts)\n-    {\n-        return delegate.getPartitionNamesByParts(identity, databaseName, tableName, parts);\n+        if (partitionKeysFilter.isAll()) {\n+            return delegate.getPartitionNames(identity, databaseName, tableName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNjE2NTYy", "url": "https://github.com/trinodb/trino/pull/4748#pullrequestreview-472616562", "createdAt": "2020-08-21T16:09:53Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjowOTo1NFrOHEzDTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjowOTo1NFrOHEzDTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5Mjc4Mw==", "bodyText": "\"this\" means what here?", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r474792783", "createdAt": "2020-08-21T16:09:54Z", "author": {"login": "findepi"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/SemiTransactionalHiveMetastore.java", "diffHunk": "@@ -635,34 +652,17 @@ public synchronized void truncateUnpartitionedTable(ConnectorSession session, St\n         }\n         // add newly-added partitions to the results from underlying metastore\n         if (!partitionActionsOfTable.isEmpty()) {\n-            List<String> columnNames = table.get().getPartitionColumns().stream().map(Column::getName).collect(Collectors.toList());\n+            // the top of the function guards against TupleDomain.none() so this cannot be empty", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 84}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2MTI1NzY4", "url": "https://github.com/trinodb/trino/pull/4748#pullrequestreview-476125768", "createdAt": "2020-08-26T23:39:35Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMzozOTozNVrOHHjycQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMzo0MzoxMlrOHHkHNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY4ODQzMw==", "bodyText": "Remove blank line before Javadoc", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r477688433", "createdAt": "2020-08-26T23:39:35Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/HiveMetastore.java", "diffHunk": "@@ -85,9 +86,18 @@\n \n     Optional<Partition> getPartition(HiveIdentity identity, Table table, List<String> partitionValues);\n \n-    Optional<List<String>> getPartitionNames(HiveIdentity identity, String databaseName, String tableName);\n+    /**\n+     * return a list of partition names where partitionKeysFilter is used as a hint to each implementation.\n+     *\n+     * @param databaseName the name of the database\n+     * @param tableName the name of the table\n+     * @param columnNames the list of partition column names\n+     * @param partitionKeysFilter map of filters (Domain) for each partition column\n+     * @return optionally, a list of strings where each entry is in the form of {key}={value}\n+     * @see TupleDomain\n+     */\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY4OTc0OA==", "bodyText": "We can remove all this client side filtering here since it's only a hint. So I think the whole method can be\nreturn ProtoUtils.toPartitionInfoList(\n        client.readTable(databaseName, tableName, Constraint.getDefaultInstance()));", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r477689748", "createdAt": "2020-08-26T23:40:25Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/alluxio/AlluxioHiveMetastore.java", "diffHunk": "@@ -335,23 +338,22 @@ public void dropColumn(HiveIdentity identity, String databaseName, String tableN\n     }\n \n     @Override\n-    public Optional<List<String>> getPartitionNames(HiveIdentity identity, String databaseName, String tableName)\n+    public Optional<List<String>> getPartitionNamesByFilter(\n+            HiveIdentity identity,\n+            String databaseName,\n+            String tableName,\n+            List<String> columnNames,\n+            TupleDomain<String> partitionKeysFilter)\n     {\n-        throw new PrestoException(NOT_SUPPORTED, \"getPartitionNames\");\n-    }\n+        if (partitionKeysFilter.isNone()) {\n+            return Optional.of(Collections.emptyList());\n+        }\n+        Optional<List<String>> optionalParts = partitionKeyFilterToStringList(columnNames, partitionKeysFilter, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5MTU1Nw==", "bodyText": "The config is not needed", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r477691557", "createdAt": "2020-08-26T23:41:39Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/alluxio/AlluxioHiveMetastore.java", "diffHunk": "@@ -69,7 +72,7 @@\n     private TableMasterClient client;\n \n     @Inject\n-    public AlluxioHiveMetastore(TableMasterClient client)\n+    public AlluxioHiveMetastore(TableMasterClient client, AlluxioHiveMetastoreConfig metastoreConfig)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5MjAwNg==", "bodyText": "Move to io.prestosql.plugin.hive.util package", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r477692006", "createdAt": "2020-08-26T23:41:57Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/spi/block/HiveBlockEncodingSerde.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.spi.block;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5MjQwMw==", "bodyText": "Remove the second sentence as it doesn't really fit here", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r477692403", "createdAt": "2020-08-26T23:42:15Z", "author": {"login": "electrum"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/spi/block/HiveBlockEncodingSerde.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.spi.block;\n+\n+import io.airlift.slice.SliceInput;\n+import io.airlift.slice.SliceOutput;\n+import io.prestosql.spi.block.ArrayBlockEncoding;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockEncoding;\n+import io.prestosql.spi.block.BlockEncodingSerde;\n+import io.prestosql.spi.block.ByteArrayBlockEncoding;\n+import io.prestosql.spi.block.DictionaryBlockEncoding;\n+import io.prestosql.spi.block.Int128ArrayBlockEncoding;\n+import io.prestosql.spi.block.IntArrayBlockEncoding;\n+import io.prestosql.spi.block.LazyBlockEncoding;\n+import io.prestosql.spi.block.LongArrayBlockEncoding;\n+import io.prestosql.spi.block.RowBlockEncoding;\n+import io.prestosql.spi.block.RunLengthBlockEncoding;\n+import io.prestosql.spi.block.ShortArrayBlockEncoding;\n+import io.prestosql.spi.block.SingleRowBlockEncoding;\n+import io.prestosql.spi.block.VariableWidthBlockEncoding;\n+\n+import javax.inject.Inject;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+// This class is exactly the same as BlockEncodingManager. They are in SPI and don't have access to InternalBlockEncodingSerde.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5Mzc0OQ==", "bodyText": "Remove the printing. Probably add an assertion or remove the entire test method.", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r477693749", "createdAt": "2020-08-26T23:43:12Z", "author": {"login": "electrum"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/metastore/TestMetastoreUtil.java", "diffHunk": "@@ -153,4 +156,12 @@ public void testHiveSchemaPartition()\n         Properties actual = MetastoreUtil.getHiveSchema(ThriftMetastoreUtil.fromMetastoreApiPartition(TEST_PARTITION_WITH_UNSUPPORTED_FIELDS), ThriftMetastoreUtil.fromMetastoreApiTable(TEST_TABLE_WITH_UNSUPPORTED_FIELDS, TEST_SCHEMA));\n         assertEquals(actual, expected);\n     }\n+\n+    @Test\n+    public void testTupleDomainToString()\n+            throws Exception\n+    {\n+        Optional<List<String>> ds = MetastoreUtil.partitionKeyFilterToStringList(Arrays.asList(\"ds1\", \"ds2\", \"ds3\"), TupleDomain.all(), false);\n+        System.err.println(ds.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "43843b2499bfe6d6245df51efd4bf82f54db424e", "author": {"user": {"login": "rash67", "name": "sr"}}, "url": "https://github.com/trinodb/trino/commit/43843b2499bfe6d6245df51efd4bf82f54db424e", "committedDate": "2020-08-27T01:22:21Z", "message": "Refactor HiveMetastore API and Implementations\n\nThis commit changes the HiveMetastore API to remove methods to methods\ngetPartionNames() and getPartitionNamesByParts() and replace with\ngetPartitionNamesByFilter(). Each implementation is updated as well as\nall callsites. The previous behavior is maintained as far as\ntranslation of any non-equal Domain values to the wildcard value.\nA subsequent commit will implement translation of a Domain into a\nproper Glue expression for the GlueHiveMetastore GetPartitions API in\nthe Glue Data Catalog."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "43843b2499bfe6d6245df51efd4bf82f54db424e", "author": {"user": {"login": "rash67", "name": "sr"}}, "url": "https://github.com/trinodb/trino/commit/43843b2499bfe6d6245df51efd4bf82f54db424e", "committedDate": "2020-08-27T01:22:21Z", "message": "Refactor HiveMetastore API and Implementations\n\nThis commit changes the HiveMetastore API to remove methods to methods\ngetPartionNames() and getPartitionNamesByParts() and replace with\ngetPartitionNamesByFilter(). Each implementation is updated as well as\nall callsites. The previous behavior is maintained as far as\ntranslation of any non-equal Domain values to the wildcard value.\nA subsequent commit will implement translation of a Domain into a\nproper Glue expression for the GlueHiveMetastore GetPartitions API in\nthe Glue Data Catalog."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNjcwNDY2", "url": "https://github.com/trinodb/trino/pull/4748#pullrequestreview-511670466", "createdAt": "2020-10-19T11:39:26Z", "commit": {"oid": "43843b2499bfe6d6245df51efd4bf82f54db424e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMTozOToyNlrOHkKMwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMTozOToyNlrOHkKMwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3Nzg4OA==", "bodyText": "the \"getPartitionNamesByParts\", stats.getGetPartitionNamesByParts()... above should be renamed too.", "url": "https://github.com/trinodb/trino/pull/4748#discussion_r507677888", "createdAt": "2020-10-19T11:39:26Z", "author": {"login": "findepi"}, "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/thrift/ThriftHiveMetastore.java", "diffHunk": "@@ -1141,39 +1146,31 @@ public void alterTable(HiveIdentity identity, String databaseName, String tableN\n     }\n \n     @Override\n-    public Optional<List<String>> getPartitionNames(HiveIdentity identity, String databaseName, String tableName)\n+    public Optional<List<String>> getPartitionNamesByFilter(HiveIdentity identity, String databaseName, String tableName, List<String> columnNames, TupleDomain<String> partitionKeysFilter)\n     {\n-        try {\n-            return retry()\n-                    .stopOn(NoSuchObjectException.class)\n-                    .stopOnIllegalExceptions()\n-                    .run(\"getPartitionNames\", stats.getGetPartitionNames().wrap(() -> {\n-                        try (ThriftMetastoreClient client = createMetastoreClient(identity)) {\n-                            return Optional.of(client.getPartitionNames(databaseName, tableName));\n-                        }\n-                    }));\n-        }\n-        catch (NoSuchObjectException e) {\n-            return Optional.empty();\n-        }\n-        catch (TException e) {\n-            throw new PrestoException(HIVE_METASTORE_ERROR, e);\n-        }\n-        catch (Exception e) {\n-            throw propagate(e);\n+        Optional<List<String>> parts = partitionKeyFilterToStringList(columnNames, partitionKeysFilter, assumeCanonicalPartitionKeys);\n+        Preconditions.checkArgument(!columnNames.isEmpty() || partitionKeysFilter.isAll(), \"must pass in all columnNames or the filter must be all\");\n+        if (parts.isEmpty()) {\n+            return Optional.of(ImmutableList.of());\n         }\n-    }\n \n-    @Override\n-    public Optional<List<String>> getPartitionNamesByParts(HiveIdentity identity, String databaseName, String tableName, List<String> parts)\n-    {\n         try {\n+            if (partitionKeysFilter.isAll()) {\n+                return retry()\n+                        .stopOn(NoSuchObjectException.class)\n+                        .stopOnIllegalExceptions()\n+                        .run(\"getPartitionNames\", stats.getGetPartitionNames().wrap(() -> {\n+                            try (ThriftMetastoreClient client = createMetastoreClient(identity)) {\n+                                return Optional.of(client.getPartitionNames(databaseName, tableName));\n+                            }\n+                        }));\n+            }\n             return retry()\n                     .stopOn(NoSuchObjectException.class)\n                     .stopOnIllegalExceptions()\n                     .run(\"getPartitionNamesByParts\", stats.getGetPartitionNamesByParts().wrap(() -> {\n                         try (ThriftMetastoreClient client = createMetastoreClient(identity)) {\n-                            return Optional.of(client.getPartitionNamesFiltered(databaseName, tableName, parts));\n+                            return Optional.of(client.getPartitionNamesFiltered(databaseName, tableName, parts.get()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43843b2499bfe6d6245df51efd4bf82f54db424e"}, "originalPosition": 92}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4306, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}