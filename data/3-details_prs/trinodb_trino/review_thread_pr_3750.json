{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4NjU4MTk0", "number": 3750, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozMzoyMFrOD861eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTo0MDo1MVrOD87AGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjA1MTE0OnYy", "diffSide": "RIGHT", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/rubix/TestRubixCaching.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozMzoyMFrOGWJy7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxODowMToyMlrOGWOt5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MjM1MA==", "bodyText": "Do we always have to wait 1s? Would polling for stats in shorter intervals (like 100ms) make sense?", "url": "https://github.com/trinodb/trino/pull/3750#discussion_r425882350", "createdAt": "2020-05-15T15:33:20Z", "author": {"login": "losipiuk"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/rubix/TestRubixCaching.java", "diffHunk": "@@ -196,6 +207,71 @@ public void testCacheRead()\n         assertEquals(getCacheStats().getRemoteReads(), intermittentRemoteReads);\n     }\n \n+    @Test\n+    public void testLargeFile()\n+            throws Exception\n+    {\n+        byte[] randomData = new byte[(int) LARGE_FILE_SIZE.toBytes()];\n+        new Random().nextBytes(randomData);\n+\n+        Path file = getStoragePath(\"large_file\");\n+        try (FSDataOutputStream outputStream = nonCachingFileSystem.create(file)) {\n+            outputStream.write(randomData);\n+        }\n+\n+        long beforeRemoteReads = getCacheStats().getRemoteReads();\n+        long beforeCachedReads = getCacheStats().getCachedReads();\n+\n+        assertTrue(Arrays.equals(randomData, readFileBytes(cachingFileSystem.open(file))));\n+\n+        // stats are propagated asynchronously, wait for them\n+        sleep(1000L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5ODcwNw==", "bodyText": "1s is on safe-side so that it \"should\" work when GC kicks-in for example", "url": "https://github.com/trinodb/trino/pull/3750#discussion_r425898707", "createdAt": "2020-05-15T16:00:57Z", "author": {"login": "sopel39"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/rubix/TestRubixCaching.java", "diffHunk": "@@ -196,6 +207,71 @@ public void testCacheRead()\n         assertEquals(getCacheStats().getRemoteReads(), intermittentRemoteReads);\n     }\n \n+    @Test\n+    public void testLargeFile()\n+            throws Exception\n+    {\n+        byte[] randomData = new byte[(int) LARGE_FILE_SIZE.toBytes()];\n+        new Random().nextBytes(randomData);\n+\n+        Path file = getStoragePath(\"large_file\");\n+        try (FSDataOutputStream outputStream = nonCachingFileSystem.create(file)) {\n+            outputStream.write(randomData);\n+        }\n+\n+        long beforeRemoteReads = getCacheStats().getRemoteReads();\n+        long beforeCachedReads = getCacheStats().getCachedReads();\n+\n+        assertTrue(Arrays.equals(randomData, readFileBytes(cachingFileSystem.open(file))));\n+\n+        // stats are propagated asynchronously, wait for them\n+        sleep(1000L);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MjM1MA=="}, "originalCommit": null, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2Mjk4Mg==", "bodyText": "With 100ms I meant polling in a loop. Not wait single interval.", "url": "https://github.com/trinodb/trino/pull/3750#discussion_r425962982", "createdAt": "2020-05-15T18:01:22Z", "author": {"login": "losipiuk"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/rubix/TestRubixCaching.java", "diffHunk": "@@ -196,6 +207,71 @@ public void testCacheRead()\n         assertEquals(getCacheStats().getRemoteReads(), intermittentRemoteReads);\n     }\n \n+    @Test\n+    public void testLargeFile()\n+            throws Exception\n+    {\n+        byte[] randomData = new byte[(int) LARGE_FILE_SIZE.toBytes()];\n+        new Random().nextBytes(randomData);\n+\n+        Path file = getStoragePath(\"large_file\");\n+        try (FSDataOutputStream outputStream = nonCachingFileSystem.create(file)) {\n+            outputStream.write(randomData);\n+        }\n+\n+        long beforeRemoteReads = getCacheStats().getRemoteReads();\n+        long beforeCachedReads = getCacheStats().getCachedReads();\n+\n+        assertTrue(Arrays.equals(randomData, readFileBytes(cachingFileSystem.open(file))));\n+\n+        // stats are propagated asynchronously, wait for them\n+        sleep(1000L);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MjM1MA=="}, "originalCommit": null, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjA2OTMzOnYy", "diffSide": "RIGHT", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/rubix/TestRubixCaching.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozODoyNlrOGWJ-yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozODoyNlrOGWJ-yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4NTM4Nw==", "bodyText": "intermittent and after name prefixes are poor. Use something more explicit. firstReadCachedRead, secondReadCachedReads?", "url": "https://github.com/trinodb/trino/pull/3750#discussion_r425885387", "createdAt": "2020-05-15T15:38:26Z", "author": {"login": "losipiuk"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/rubix/TestRubixCaching.java", "diffHunk": "@@ -196,6 +207,71 @@ public void testCacheRead()\n         assertEquals(getCacheStats().getRemoteReads(), intermittentRemoteReads);\n     }\n \n+    @Test\n+    public void testLargeFile()\n+            throws Exception\n+    {\n+        byte[] randomData = new byte[(int) LARGE_FILE_SIZE.toBytes()];\n+        new Random().nextBytes(randomData);\n+\n+        Path file = getStoragePath(\"large_file\");\n+        try (FSDataOutputStream outputStream = nonCachingFileSystem.create(file)) {\n+            outputStream.write(randomData);\n+        }\n+\n+        long beforeRemoteReads = getCacheStats().getRemoteReads();\n+        long beforeCachedReads = getCacheStats().getCachedReads();\n+\n+        assertTrue(Arrays.equals(randomData, readFileBytes(cachingFileSystem.open(file))));\n+\n+        // stats are propagated asynchronously, wait for them\n+        sleep(1000L);\n+        long intermittentRemoteReads = getCacheStats().getRemoteReads();\n+        assertGreaterThan(intermittentRemoteReads, beforeRemoteReads);\n+\n+        assertTrue(Arrays.equals(randomData, readFileBytes(cachingFileSystem.open(file))));\n+\n+        // stats are propagated asynchronously, wait for them\n+        sleep(1000L);\n+        long afterCachedReads = getCacheStats().getCachedReads();\n+        long afterRemoteReads = getCacheStats().getRemoteReads();\n+        assertGreaterThan(afterCachedReads, beforeCachedReads);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjA3MjAxOnYy", "diffSide": "RIGHT", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/rubix/TestRubixCaching.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozOToxM1rOGWKAig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTozOToxM1rOGWKAig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4NTgzNA==", "bodyText": "add comments to assertions so one does not have to reverse engineer the code.", "url": "https://github.com/trinodb/trino/pull/3750#discussion_r425885834", "createdAt": "2020-05-15T15:39:13Z", "author": {"login": "losipiuk"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/rubix/TestRubixCaching.java", "diffHunk": "@@ -196,6 +207,71 @@ public void testCacheRead()\n         assertEquals(getCacheStats().getRemoteReads(), intermittentRemoteReads);\n     }\n \n+    @Test\n+    public void testLargeFile()\n+            throws Exception\n+    {\n+        byte[] randomData = new byte[(int) LARGE_FILE_SIZE.toBytes()];\n+        new Random().nextBytes(randomData);\n+\n+        Path file = getStoragePath(\"large_file\");\n+        try (FSDataOutputStream outputStream = nonCachingFileSystem.create(file)) {\n+            outputStream.write(randomData);\n+        }\n+\n+        long beforeRemoteReads = getCacheStats().getRemoteReads();\n+        long beforeCachedReads = getCacheStats().getCachedReads();\n+\n+        assertTrue(Arrays.equals(randomData, readFileBytes(cachingFileSystem.open(file))));\n+\n+        // stats are propagated asynchronously, wait for them\n+        sleep(1000L);\n+        long intermittentRemoteReads = getCacheStats().getRemoteReads();\n+        assertGreaterThan(intermittentRemoteReads, beforeRemoteReads);\n+\n+        assertTrue(Arrays.equals(randomData, readFileBytes(cachingFileSystem.open(file))));\n+\n+        // stats are propagated asynchronously, wait for them\n+        sleep(1000L);\n+        long afterCachedReads = getCacheStats().getCachedReads();\n+        long afterRemoteReads = getCacheStats().getRemoteReads();\n+        assertGreaterThan(afterCachedReads, beforeCachedReads);\n+        assertEquals(afterRemoteReads, intermittentRemoteReads);\n+\n+        // make sure parallel reading of large file works\n+        ExecutorService executorService = newFixedThreadPool(10);\n+        try {\n+            List<Runnable> reads = nCopies(\n+                    10,\n+                    () -> {\n+                        try {\n+                            assertTrue(Arrays.equals(randomData, readFileBytes(cachingFileSystem.open(file))));\n+                        }\n+                        catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    });\n+            reads.stream()\n+                    .map(executorService::submit)\n+                    .forEach(future -> {\n+                        try {\n+                            future.get();\n+                        }\n+                        catch (Exception e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    });\n+        }\n+        finally {\n+            executorService.shutdownNow();\n+        }\n+\n+        // stats are propagated asynchronously, wait for them\n+        sleep(1000L);\n+        assertGreaterThan(getCacheStats().getCachedReads(), afterCachedReads);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjA3ODMyOnYy", "diffSide": "RIGHT", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/rubix/TestRubixCaching.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTo0MDo1MVrOGWKEeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNTo0MDo1MVrOGWKEeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4Njg0MQ==", "bodyText": "Callable? No need for exception handling.", "url": "https://github.com/trinodb/trino/pull/3750#discussion_r425886841", "createdAt": "2020-05-15T15:40:51Z", "author": {"login": "losipiuk"}, "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/rubix/TestRubixCaching.java", "diffHunk": "@@ -196,6 +207,71 @@ public void testCacheRead()\n         assertEquals(getCacheStats().getRemoteReads(), intermittentRemoteReads);\n     }\n \n+    @Test\n+    public void testLargeFile()\n+            throws Exception\n+    {\n+        byte[] randomData = new byte[(int) LARGE_FILE_SIZE.toBytes()];\n+        new Random().nextBytes(randomData);\n+\n+        Path file = getStoragePath(\"large_file\");\n+        try (FSDataOutputStream outputStream = nonCachingFileSystem.create(file)) {\n+            outputStream.write(randomData);\n+        }\n+\n+        long beforeRemoteReads = getCacheStats().getRemoteReads();\n+        long beforeCachedReads = getCacheStats().getCachedReads();\n+\n+        assertTrue(Arrays.equals(randomData, readFileBytes(cachingFileSystem.open(file))));\n+\n+        // stats are propagated asynchronously, wait for them\n+        sleep(1000L);\n+        long intermittentRemoteReads = getCacheStats().getRemoteReads();\n+        assertGreaterThan(intermittentRemoteReads, beforeRemoteReads);\n+\n+        assertTrue(Arrays.equals(randomData, readFileBytes(cachingFileSystem.open(file))));\n+\n+        // stats are propagated asynchronously, wait for them\n+        sleep(1000L);\n+        long afterCachedReads = getCacheStats().getCachedReads();\n+        long afterRemoteReads = getCacheStats().getRemoteReads();\n+        assertGreaterThan(afterCachedReads, beforeCachedReads);\n+        assertEquals(afterRemoteReads, intermittentRemoteReads);\n+\n+        // make sure parallel reading of large file works\n+        ExecutorService executorService = newFixedThreadPool(10);\n+        try {\n+            List<Runnable> reads = nCopies(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 88}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4829, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}