{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1ODY2NTE3", "number": 4381, "title": "Implement variable-precision time type", "bodyText": "Implements variable-precision time type, with max precision = 12.\nRemoves support for legacy semantics for time type.\nChanges the internal representation of time type to picoseconds since midnight. This is a backward\nincompatible change but since time type is broken in many ways today to the point of being almost\nunusable, this is not such a big problem.", "createdAt": "2020-07-08T02:33:38Z", "url": "https://github.com/trinodb/trino/pull/4381", "merged": true, "mergeCommit": {"oid": "19811d3d58e908d145639b1975ec111a0002e138"}, "closed": true, "closedAt": "2020-08-11T06:38:32Z", "author": {"login": "martint"}, "timelineItems": {"totalCount": 55, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcyxGYkgBqjM1MjMxMDEyODI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc9w9ywABqjM2NDE2Njc0Mzg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NjcwOTMx", "url": "https://github.com/trinodb/trino/pull/4381#pullrequestreview-458670931", "createdAt": "2020-07-30T18:54:21Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODo1NDoyMVrOG5vvuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMjoxODowMVrOG51vlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIwNDI4MA==", "bodyText": "Is there a helper to round and rescale in one shot?", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463204280", "createdAt": "2020-07-30T18:54:21Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeOperators.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.airlift.slice.DynamicSliceOutput;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.BlockIndex;\n+import io.prestosql.spi.function.BlockPosition;\n+import io.prestosql.spi.function.IsNull;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlNullable;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.AbstractLongType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.type.Constraint;\n+import org.joda.time.chrono.ISOChronology;\n+\n+import static io.prestosql.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static io.prestosql.spi.function.OperatorType.ADD;\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.function.OperatorType.EQUAL;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.HASH_CODE;\n+import static io.prestosql.spi.function.OperatorType.INDETERMINATE;\n+import static io.prestosql.spi.function.OperatorType.IS_DISTINCT_FROM;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.NOT_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.SUBTRACT;\n+import static io.prestosql.spi.function.OperatorType.XX_HASH_64;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.type.Timestamps.MINUTES_PER_HOUR;\n+import static io.prestosql.type.Timestamps.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.Timestamps.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.type.Timestamps.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.Timestamps.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.Timestamps.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.Timestamps.SECONDS_PER_MINUTE;\n+import static io.prestosql.type.Timestamps.parseTime;\n+import static io.prestosql.type.Timestamps.rescale;\n+import static io.prestosql.type.Timestamps.round;\n+import static io.prestosql.type.Timestamps.scaleFactor;\n+import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+import static java.lang.String.format;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public final class TimeOperators\n+{\n+    private TimeOperators() {}\n+\n+    @ScalarOperator(SUBTRACT)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND)\n+    public static long subtract(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        long interval = left - right;\n+\n+        interval = round(interval, MAX_PRECISION - 3);\n+        interval = rescale(interval, MAX_PRECISION, 3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIyOTkzOQ==", "bodyText": "milliis?", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463229939", "createdAt": "2020-07-30T19:44:16Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeToTimestampWithTimeZoneCast.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeType;\n+\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.type.Timestamps.MILLISECONDS_PER_SECOND;\n+import static io.prestosql.type.Timestamps.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.Timestamps.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.Timestamps.SECONDS_PER_DAY;\n+import static io.prestosql.type.Timestamps.rescale;\n+import static io.prestosql.type.Timestamps.round;\n+import static java.lang.Math.multiplyExact;\n+\n+@ScalarOperator(CAST)\n+public final class TimeToTimestampWithTimeZoneCast\n+{\n+    private TimeToTimestampWithTimeZoneCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision) with time zone\")\n+    public static long castToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        ZoneId zoneId = session.getTimeZoneKey().getZoneId();\n+        long epochSeconds = getEpochSeconds(session, time, zoneId);\n+        long picoFraction = getPicoFraction(sourcePrecision, targetPrecision, time);\n+        long epochMillis = computeEpochMilliis(session, zoneId, epochSeconds, picoFraction);\n+\n+        return packDateTimeWithZone(epochMillis, session.getTimeZoneKey());\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision) with time zone\")\n+    public static LongTimestampWithTimeZone castToLong(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        ZoneId zoneId = session.getTimeZoneKey().getZoneId();\n+        long epochSeconds = getEpochSeconds(session, time, zoneId);\n+        long picoFraction = getPicoFraction(sourcePrecision, targetPrecision, time);\n+        long epochMillis = computeEpochMilliis(session, zoneId, epochSeconds, picoFraction);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzOTQ4MA==", "bodyText": "Consider moving these inside of the try", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463239480", "createdAt": "2020-07-30T20:02:30Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -826,14 +839,24 @@ protected Type visitGenericLiteral(GenericLiteral node, StackableAstVisitorConte\n         @Override\n         protected Type visitTimeLiteral(TimeLiteral node, StackableAstVisitorContext<Context> context)\n         {\n-            boolean hasTimeZone;\n+            Type type;\n             try {\n-                hasTimeZone = timeHasTimeZone(node.getValue());\n+                if (timeHasTimeZone(node.getValue())) {\n+                    type = TIME_WITH_TIME_ZONE;\n+                }\n+                else {\n+                    int precision = extractTimePrecision(node.getValue());\n+                    type = createTimeType(precision);\n+                    parseTime(node.getValue());\n+                }\n+            }\n+            catch (PrestoException e) {\n+                throw new PrestoException(e::getErrorCode, extractLocation(node), e.getMessage(), e);\n             }\n             catch (IllegalArgumentException e) {\n                 throw semanticException(INVALID_LITERAL, node, \"'%s' is not a valid time literal\", node.getValue());\n             }\n-            Type type = hasTimeZone ? TIME_WITH_TIME_ZONE : TIME;\n+\n             return setExpressionType(node, type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI1MzE0MQ==", "bodyText": "maybe we should rename this DateTimes or such so it is clear that this isn't just timesamp utilities.", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463253141", "createdAt": "2020-07-30T20:30:09Z", "author": {"login": "dain"}, "path": "presto-main/src/main/java/io/prestosql/type/Timestamps.java", "diffHunk": "@@ -68,14 +72,23 @@\n     };\n \n     public static final int MILLISECONDS_PER_SECOND = 1000;\n+    public static final long MILLISECONDS_PER_DAY = 24 * 60 * 60 * MILLISECONDS_PER_SECOND;\n     public static final int MICROSECONDS_PER_SECOND = 1_000_000;\n     public static final int MICROSECONDS_PER_MILLISECOND = 1000;\n+    public static final long MICROSECONDS_PER_DAY = MILLISECONDS_PER_DAY * MICROSECONDS_PER_MILLISECOND;\n     public static final long PICOSECONDS_PER_SECOND = 1_000_000_000_000L;\n     public static final int NANOSECONDS_PER_MILLISECOND = 1_000_000;\n     public static final int NANOSECONDS_PER_MICROSECOND = 1_000;\n     public static final int PICOSECONDS_PER_MILLISECOND = 1_000_000_000;\n     public static final int PICOSECONDS_PER_MICROSECOND = 1_000_000;\n     public static final int PICOSECONDS_PER_NANOSECOND = 1000;\n+    public static final long SECONDS_PER_MINUTE = 60;\n+    public static final long MINUTES_PER_HOUR = 60;\n+    public static final long HOURS_PER_DAY = 24;\n+    public static final long PICOSECONDS_PER_MINUTE = PICOSECONDS_PER_SECOND * SECONDS_PER_MINUTE;\n+    public static final long PICOSECONDS_PER_HOUR = PICOSECONDS_PER_MINUTE * MINUTES_PER_HOUR;\n+    public static final long PICOSECONDS_PER_DAY = PICOSECONDS_PER_HOUR * HOURS_PER_DAY;\n+    public static final long SECONDS_PER_DAY = SECONDS_PER_MINUTE * MINUTES_PER_HOUR * HOURS_PER_DAY;\n \n     private Timestamps() {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwMjU1MA==", "bodyText": "I'm not sure about this TZ, but it would be good to test on a day with an extra hour or one fewer hour due to tz shifts", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463302550", "createdAt": "2020-07-30T22:18:01Z", "author": {"login": "dain"}, "path": "presto-main/src/test/java/io/prestosql/operator/scalar/timestamptz/TestTimestampWithTimeZone.java", "diffHunk": "@@ -352,39 +352,386 @@ public void testCastFromDate()\n     }\n \n     @Test\n-    public void testCastFromTime()\n+    public void testCastToTime()\n     {\n-        // TODO: date part should be 2020-05-01. See https://github.com/prestosql/presto/issues/3845\n-\n-        // round down\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(0) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(1) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.1 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(2) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.11 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(3) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.111 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(4) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.1110 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(5) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.11100 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(6) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.111000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(7) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.1110000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(8) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.11100000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(9) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.111000000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(10) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.1110000000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(11) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.11100000000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(12) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.111000000000 Pacific/Apia'\");\n-\n-        // round up\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(0) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:57 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(1) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.6 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(2) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.56 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(3) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.555 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(4) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.5550 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(5) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.55500 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(6) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.555000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(7) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.5550000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(8) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.55500000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(9) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.555000000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(10) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.5550000000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(11) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.55500000000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(12) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.555000000000 Pacific/Apia'\");\n+        // source = target\n+        assertThat(assertions.expression(\"CAST(TIMESTAMP '2020-05-01 12:34:56 Asia/Kathmandu' AS TIME(0))\")).matches(\"TIME '12:34:56'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4ODAyMDk2", "url": "https://github.com/trinodb/trino/pull/4381#pullrequestreview-458802096", "createdAt": "2020-07-30T22:25:33Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMjoyNTozM1rOG5160w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMzo1Mjo0M1rOG53mqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwNTQyNw==", "bodyText": "This could be simplified to time.getTime() * PICOSECONDS_PER_MILLISECOND % PICOSECONDS_PER_DAY (and toLocalTime could be removed).\nIf we want to guarantee an error for negative times (as currently occurs), we could check the value of time.getTime() explicitly.", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463305427", "createdAt": "2020-07-30T22:25:33Z", "author": {"login": "jirassimok"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -271,26 +276,15 @@ public static LongWriteFunction dateWriteFunction()\n      * {@link #timeColumnMapping} instead.\n      */\n     @Deprecated\n-    public static ColumnMapping timeColumnMappingUsingSqlTime(ConnectorSession session)\n+    public static ColumnMapping timeColumnMappingUsingSqlTime()\n     {\n-        if (session.isLegacyTimestamp()) {\n-            ZoneId sessionZone = ZoneId.of(session.getTimeZoneKey().getId());\n-            return ColumnMapping.longMapping(\n-                    TIME,\n-                    (resultSet, columnIndex) -> {\n-                        Time time = resultSet.getTime(columnIndex);\n-                        return toPrestoLegacyTimestamp(toLocalTime(time).atDate(LocalDate.ofEpochDay(0)), sessionZone);\n-                    },\n-                    timeWriteFunctionUsingSqlTime(session));\n-        }\n-\n         return ColumnMapping.longMapping(\n                 TIME,\n                 (resultSet, columnIndex) -> {\n                     Time time = resultSet.getTime(columnIndex);\n-                    return NANOSECONDS.toMillis(toLocalTime(time).toNanoOfDay());\n+                    return (roundDiv(toLocalTime(time).toNanoOfDay(), NANOSECONDS_PER_MILLISECOND) * PICOSECONDS_PER_MILLISECOND) % PICOSECONDS_PER_DAY;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwOTEzMg==", "bodyText": "Given that this expression shows up a few times, I think it should be extracted to a function.\nWe should at least have functions to convert the internal representation to and from nanoseconds (which lets us use TimeUnit for anything else). Functions for milliseconds could also be useful, but are less important, because we can always go through nanoseconds to get there.\n(I also think DateTimeUtils or DateTimes might be a better place for these functions, semantically speaking, but toPrestoTimestamp and the others are already here.)", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463309132", "createdAt": "2020-07-30T22:34:17Z", "author": {"login": "jirassimok"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -322,35 +312,31 @@ private static Time toSqlTime(LocalTime localTime)\n         return new Time(Time.valueOf(localTime).getTime() + NANOSECONDS.toMillis(localTime.getNano()));\n     }\n \n-    public static ColumnMapping timeColumnMapping(ConnectorSession session)\n+    public static ColumnMapping timeColumnMapping()\n     {\n-        if (session.isLegacyTimestamp()) {\n-            ZoneId sessionZone = ZoneId.of(session.getTimeZoneKey().getId());\n-            return ColumnMapping.longMapping(\n-                    TIME,\n-                    (resultSet, columnIndex) -> {\n-                        LocalTime time = resultSet.getObject(columnIndex, LocalTime.class);\n-                        return toPrestoLegacyTimestamp(time.atDate(LocalDate.ofEpochDay(0)), sessionZone);\n-                    },\n-                    timeWriteFunction(session));\n-        }\n+        return ColumnMapping.longMapping(\n+                TIME,\n+                (resultSet, columnIndex) -> {\n+                    LocalTime time = resultSet.getObject(columnIndex, LocalTime.class);\n+                    return (roundDiv(time.toNanoOfDay(), NANOSECONDS_PER_MILLISECOND) * PICOSECONDS_PER_MILLISECOND) % PICOSECONDS_PER_DAY;\n+                },", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMzAzNQ==", "bodyText": "Why did you keep the four functions following this one?\n(parseLegacyTime, printTimeWithTimeZone (\u00d72), and printTimeWithoutTimeZone)", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463333035", "createdAt": "2020-07-30T23:52:43Z", "author": {"login": "jirassimok"}, "path": "presto-main/src/main/java/io/prestosql/util/DateTimeUtils.java", "diffHunk": "@@ -176,19 +176,6 @@ public static long parseTimeWithTimeZone(String timeWithTimeZone)\n         return packDateTimeWithZone(dateTime);\n     }\n \n-    /**\n-     * Parse a string (without a zone) as a value of TIME type.\n-     * <p>\n-     * For example: {@code \"01:23:00\"} is parsed to TIME {@code 01:23:00}\n-     * and {@code \"01:23:00 +01:23\"} is rejected.\n-     *\n-     * @return stack representation of TIME type\n-     */\n-    public static long parseTimeWithoutTimeZone(String value)\n-    {\n-        return TIME_FORMATTER.parseMillis(value);\n-    }\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5MDQ3MjQ3", "url": "https://github.com/trinodb/trino/pull/4381#pullrequestreview-459047247", "createdAt": "2020-07-31T09:42:15Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwOTo0MjoxNVrOG6Ci0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwOTo0MjoxNVrOG6Ci0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxMjI3NA==", "bodyText": "time.getTime() is an instant that, if interpreted in JVM zone, refers to hour/minute/second represented.\nto obtain number of millis/nanos since midnight you need to  time.toLocalTime().toNanoOfDay()", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463512274", "createdAt": "2020-07-31T09:42:15Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -271,34 +276,15 @@ public static LongWriteFunction dateWriteFunction()\n      * {@link #timeColumnMapping} instead.\n      */\n     @Deprecated\n-    public static ColumnMapping timeColumnMappingUsingSqlTime(ConnectorSession session)\n+    public static ColumnMapping timeColumnMappingUsingSqlTime()\n     {\n-        if (session.isLegacyTimestamp()) {\n-            ZoneId sessionZone = ZoneId.of(session.getTimeZoneKey().getId());\n-            return ColumnMapping.longMapping(\n-                    TIME,\n-                    (resultSet, columnIndex) -> {\n-                        Time time = resultSet.getTime(columnIndex);\n-                        return toPrestoLegacyTimestamp(toLocalTime(time).atDate(LocalDate.ofEpochDay(0)), sessionZone);\n-                    },\n-                    timeWriteFunctionUsingSqlTime(session));\n-        }\n-\n         return ColumnMapping.longMapping(\n                 TIME,\n                 (resultSet, columnIndex) -> {\n                     Time time = resultSet.getTime(columnIndex);\n-                    return NANOSECONDS.toMillis(toLocalTime(time).toNanoOfDay());\n+                    return time.getTime() * PICOSECONDS_PER_MILLISECOND % PICOSECONDS_PER_DAY;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5MDQ5NTYw", "url": "https://github.com/trinodb/trino/pull/4381#pullrequestreview-459049560", "createdAt": "2020-07-31T09:46:14Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwOTo0NjoxNFrOG6CqSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxMDo1NzowNVrOG6EiNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxNDE4NQ==", "bodyText": "Add a javadoc what kind of truncation is expected.\nAlso, when there is truncation, you likely want to disable predicate pushdown (ColumnMapping.DISABLE_PUSHDOWN) as well", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463514185", "createdAt": "2020-07-31T09:46:14Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -322,35 +304,32 @@ private static Time toSqlTime(LocalTime localTime)\n         return new Time(Time.valueOf(localTime).getTime() + NANOSECONDS.toMillis(localTime.getNano()));\n     }\n \n-    public static ColumnMapping timeColumnMapping(ConnectorSession session)\n+    public static ColumnMapping timeColumnMapping()\n     {\n-        if (session.isLegacyTimestamp()) {\n-            ZoneId sessionZone = ZoneId.of(session.getTimeZoneKey().getId());\n-            return ColumnMapping.longMapping(\n-                    TIME,\n-                    (resultSet, columnIndex) -> {\n-                        LocalTime time = resultSet.getObject(columnIndex, LocalTime.class);\n-                        return toPrestoLegacyTimestamp(time.atDate(LocalDate.ofEpochDay(0)), sessionZone);\n-                    },\n-                    timeWriteFunction(session));\n-        }\n+        return ColumnMapping.longMapping(\n+                TIME,\n+                (resultSet, columnIndex) -> {\n+                    LocalTime time = resultSet.getObject(columnIndex, LocalTime.class);\n+                    long nanos = time.toNanoOfDay();\n+                    return (roundDiv(nanos, NANOSECONDS_PER_MILLISECOND) * PICOSECONDS_PER_MILLISECOND) % PICOSECONDS_PER_DAY;\n+                },\n+                timeWriteFunction());\n+    }\n \n+    public static ColumnMapping timeColumnMappingWithTruncation()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxNDk2NQ==", "bodyText": "% NANOSECONDS_PER_DAY looks redundant.\nit should matter only when the value is out of allowed range, which is a bad value anyway (eg TimeOperators#equal does not do %)\nif it's not redundant, add a comment", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463514965", "createdAt": "2020-07-31T09:48:02Z", "author": {"login": "findepi"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -454,6 +433,11 @@ public static LocalDateTime fromPrestoTimestamp(long value)\n         return Instant.ofEpochMilli(value).atZone(UTC).toLocalDateTime();\n     }\n \n+    public static LocalTime fromPrestoTime(long value)\n+    {\n+        return LocalTime.ofNanoOfDay(roundDiv(value, PICOSECONDS_PER_NANOSECOND) % NANOSECONDS_PER_DAY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxNjM0Mg==", "bodyText": "Rounding should not be necessary here, since Iceberg supports time(3)\nif it were to support time(>6), would the bucket function need to be changed?", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463516342", "createdAt": "2020-07-31T09:50:48Z", "author": {"login": "findepi"}, "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/PartitionTransforms.java", "diffHunk": "@@ -323,8 +325,9 @@ private static Block bucketDate(Block block, int count)\n     private static Block bucketTime(Block block, int count)\n     {\n         return bucketBlock(block, count, position -> {\n-            long value = TIME.getLong(block, position);\n-            return bucketHash(MILLISECONDS.toMicros(value));\n+            long picos = TIME.getLong(block, position);\n+            long micros = roundDiv(picos, PICOSECONDS_PER_MICROSECOND);\n+            return bucketHash(micros);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxNzU1Ng==", "bodyText": "Does the second part need to be optional?\nWill the server ever return 12:34 instead of 12:34:00?", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463517556", "createdAt": "2020-07-31T09:53:23Z", "author": {"login": "findepi"}, "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/AbstractPrestoResultSet.java", "diffHunk": "@@ -83,6 +84,10 @@\n             \"(?: (?<hour>\\\\d{1,2}):(?<minute>\\\\d{1,2})(?::(?<second>\\\\d{1,2})(?:\\\\.(?<fraction>\\\\d+))?)?)?\" +\n             \"\\\\s*(?<timezone>.+)?\");\n \n+    public static final Pattern TIME_PATTERN = Pattern.compile(\"\" +\n+            \"(?<hour>\\\\d{1,2}):(?<minute>\\\\d{1,2})(?::(?<second>\\\\d{1,2})(?:\\\\.(?<fraction>\\\\d+))?)?\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxNzY4OQ==", "bodyText": "What is timezone here for?\n(you discard it later btw)", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463517689", "createdAt": "2020-07-31T09:53:43Z", "author": {"login": "findepi"}, "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/AbstractPrestoResultSet.java", "diffHunk": "@@ -83,6 +84,10 @@\n             \"(?: (?<hour>\\\\d{1,2}):(?<minute>\\\\d{1,2})(?::(?<second>\\\\d{1,2})(?:\\\\.(?<fraction>\\\\d+))?)?)?\" +\n             \"\\\\s*(?<timezone>.+)?\");\n \n+    public static final Pattern TIME_PATTERN = Pattern.compile(\"\" +\n+            \"(?<hour>\\\\d{1,2}):(?<minute>\\\\d{1,2})(?::(?<second>\\\\d{1,2})(?:\\\\.(?<fraction>\\\\d+))?)?\" +\n+            \"\\\\s*(?<timezone>.+)?\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyMjM1Ng==", "bodyText": "roundDiv(value, PICOSECONDS_PER_NANOSECOND) ?", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463522356", "createdAt": "2020-07-31T10:03:38Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/FormatFunction.java", "diffHunk": "@@ -259,14 +257,10 @@ else if (type.getJavaType() == Slice.class) {\n         return (session, block) -> convertToString(handle, function.apply(session, block));\n     }\n \n-    private static LocalTime toLocalTime(ConnectorSession session, long value)\n+    private static LocalTime toLocalTime(long value)\n     {\n-        if (session.isLegacyTimestamp()) {\n-            Instant instant = Instant.ofEpochMilli(value);\n-            ZoneId zoneId = ZoneId.of(session.getTimeZoneKey().getId());\n-            return ZonedDateTime.ofInstant(instant, zoneId).toLocalTime();\n-        }\n-        return LocalTime.ofNanoOfDay(MILLISECONDS.toNanos(value));\n+        long nanoOfDay = roundToNearest(value, PICOSECONDS_PER_NANOSECOND) / PICOSECONDS_PER_NANOSECOND;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyNTEyMg==", "bodyText": "Check for overflows, the user provided value can be anything", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463525122", "createdAt": "2020-07-31T10:10:15Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeFunctions.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.function.Description;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.StandardTypes;\n+\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.type.DateTimes.MILLISECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.MINUTES_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.round;\n+import static java.util.Locale.ENGLISH;\n+\n+public class TimeFunctions\n+{\n+    private TimeFunctions() {}\n+\n+    @Description(\"Millisecond of the second of the given time\")\n+    @ScalarFunction(\"millisecond\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long millisecond(@SqlType(\"time(p)\") long time)\n+    {\n+        return (time / PICOSECONDS_PER_MILLISECOND) % MILLISECONDS_PER_SECOND;\n+    }\n+\n+    @Description(\"Second of the minute of the given time\")\n+    @ScalarFunction(\"second\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long second(@SqlType(\"time(p)\") long time)\n+    {\n+        return (time / PICOSECONDS_PER_SECOND) % SECONDS_PER_MINUTE;\n+    }\n+\n+    @Description(\"Minute of the hour of the given time\")\n+    @ScalarFunction(\"minute\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long minute(@SqlType(\"time(p)\") long time)\n+    {\n+        return (time / PICOSECONDS_PER_MINUTE) % MINUTES_PER_HOUR;\n+    }\n+\n+    @Description(\"Hour of the day of the given time\")\n+    @ScalarFunction(\"hour\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long hour(@SqlType(\"time(p)\") long time)\n+    {\n+        return time / PICOSECONDS_PER_HOUR;\n+    }\n+\n+    @Description(\"Truncate to the specified precision in the session timezone\")\n+    @ScalarFunction(\"date_trunc\")\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p)\")\n+    public static long truncate(@SqlType(\"varchar(x)\") Slice unit, @SqlType(\"time(p)\") long time)\n+    {\n+        String unitString = unit.toStringUtf8().toLowerCase(ENGLISH);\n+\n+        switch (unitString) {\n+            case \"millisecond\":\n+                return time / PICOSECONDS_PER_MILLISECOND * PICOSECONDS_PER_MILLISECOND;\n+            case \"second\":\n+                return time / PICOSECONDS_PER_SECOND * PICOSECONDS_PER_SECOND;\n+            case \"minute\":\n+                return time / PICOSECONDS_PER_MINUTE * PICOSECONDS_PER_MINUTE;\n+            case \"hour\":\n+                return time / PICOSECONDS_PER_HOUR * PICOSECONDS_PER_HOUR;\n+            default:\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"'\" + unitString + \"' is not a valid Time field\");\n+        }\n+    }\n+\n+    @Description(\"Add the specified amount of time to the given time\")\n+    @LiteralParameters({\"x\", \"p\"})\n+    @ScalarFunction(\"date_add\")\n+    @SqlType(\"time(p)\")\n+    public static long dateAdd(\n+            @LiteralParameter(\"p\") long precision,\n+            @SqlType(\"varchar(x)\") Slice unit,\n+            @SqlType(StandardTypes.BIGINT) long value,\n+            @SqlType(\"time(p)\") long time)\n+    {\n+        long delta = value;\n+        String unitString = unit.toStringUtf8().toLowerCase(ENGLISH);\n+        switch (unitString) {\n+            case \"millisecond\":\n+                delta *= PICOSECONDS_PER_MILLISECOND;\n+                break;\n+            case \"second\":\n+                delta *= PICOSECONDS_PER_SECOND;\n+                break;\n+            case \"minute\":\n+                delta *= PICOSECONDS_PER_MINUTE;\n+                break;\n+            case \"hour\":\n+                delta *= PICOSECONDS_PER_HOUR;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyNTk3Nw==", "bodyText": "Add a comment\n} else {\n // No rounding is needed, since the delta precision is 3\n}", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463525977", "createdAt": "2020-07-31T10:12:14Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeFunctions.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.function.Description;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.StandardTypes;\n+\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.type.DateTimes.MILLISECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.MINUTES_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.round;\n+import static java.util.Locale.ENGLISH;\n+\n+public class TimeFunctions\n+{\n+    private TimeFunctions() {}\n+\n+    @Description(\"Millisecond of the second of the given time\")\n+    @ScalarFunction(\"millisecond\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long millisecond(@SqlType(\"time(p)\") long time)\n+    {\n+        return (time / PICOSECONDS_PER_MILLISECOND) % MILLISECONDS_PER_SECOND;\n+    }\n+\n+    @Description(\"Second of the minute of the given time\")\n+    @ScalarFunction(\"second\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long second(@SqlType(\"time(p)\") long time)\n+    {\n+        return (time / PICOSECONDS_PER_SECOND) % SECONDS_PER_MINUTE;\n+    }\n+\n+    @Description(\"Minute of the hour of the given time\")\n+    @ScalarFunction(\"minute\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long minute(@SqlType(\"time(p)\") long time)\n+    {\n+        return (time / PICOSECONDS_PER_MINUTE) % MINUTES_PER_HOUR;\n+    }\n+\n+    @Description(\"Hour of the day of the given time\")\n+    @ScalarFunction(\"hour\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long hour(@SqlType(\"time(p)\") long time)\n+    {\n+        return time / PICOSECONDS_PER_HOUR;\n+    }\n+\n+    @Description(\"Truncate to the specified precision in the session timezone\")\n+    @ScalarFunction(\"date_trunc\")\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p)\")\n+    public static long truncate(@SqlType(\"varchar(x)\") Slice unit, @SqlType(\"time(p)\") long time)\n+    {\n+        String unitString = unit.toStringUtf8().toLowerCase(ENGLISH);\n+\n+        switch (unitString) {\n+            case \"millisecond\":\n+                return time / PICOSECONDS_PER_MILLISECOND * PICOSECONDS_PER_MILLISECOND;\n+            case \"second\":\n+                return time / PICOSECONDS_PER_SECOND * PICOSECONDS_PER_SECOND;\n+            case \"minute\":\n+                return time / PICOSECONDS_PER_MINUTE * PICOSECONDS_PER_MINUTE;\n+            case \"hour\":\n+                return time / PICOSECONDS_PER_HOUR * PICOSECONDS_PER_HOUR;\n+            default:\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"'\" + unitString + \"' is not a valid Time field\");\n+        }\n+    }\n+\n+    @Description(\"Add the specified amount of time to the given time\")\n+    @LiteralParameters({\"x\", \"p\"})\n+    @ScalarFunction(\"date_add\")\n+    @SqlType(\"time(p)\")\n+    public static long dateAdd(\n+            @LiteralParameter(\"p\") long precision,\n+            @SqlType(\"varchar(x)\") Slice unit,\n+            @SqlType(StandardTypes.BIGINT) long value,\n+            @SqlType(\"time(p)\") long time)\n+    {\n+        long delta = value;\n+        String unitString = unit.toStringUtf8().toLowerCase(ENGLISH);\n+        switch (unitString) {\n+            case \"millisecond\":\n+                delta *= PICOSECONDS_PER_MILLISECOND;\n+                break;\n+            case \"second\":\n+                delta *= PICOSECONDS_PER_SECOND;\n+                break;\n+            case \"minute\":\n+                delta *= PICOSECONDS_PER_MINUTE;\n+                break;\n+            case \"hour\":\n+                delta *= PICOSECONDS_PER_HOUR;\n+                break;\n+            default:\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"'\" + unitString + \"' is not a valid Time field\");\n+        }\n+\n+        long result = TimeOperators.add(time, delta);\n+\n+        if (precision <= 3) {\n+            return round(result, (int) (MAX_PRECISION - precision)) % PICOSECONDS_PER_DAY;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyNjcxMg==", "bodyText": "This will return negative result if  delta is \"very negative\", because TimeOperators.add has\nif (result < 0) {\n\nand not e.g.\nwhile (result < 0) {", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463526712", "createdAt": "2020-07-31T10:13:57Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeFunctions.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.function.Description;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.StandardTypes;\n+\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.type.DateTimes.MILLISECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.MINUTES_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.round;\n+import static java.util.Locale.ENGLISH;\n+\n+public class TimeFunctions\n+{\n+    private TimeFunctions() {}\n+\n+    @Description(\"Millisecond of the second of the given time\")\n+    @ScalarFunction(\"millisecond\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long millisecond(@SqlType(\"time(p)\") long time)\n+    {\n+        return (time / PICOSECONDS_PER_MILLISECOND) % MILLISECONDS_PER_SECOND;\n+    }\n+\n+    @Description(\"Second of the minute of the given time\")\n+    @ScalarFunction(\"second\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long second(@SqlType(\"time(p)\") long time)\n+    {\n+        return (time / PICOSECONDS_PER_SECOND) % SECONDS_PER_MINUTE;\n+    }\n+\n+    @Description(\"Minute of the hour of the given time\")\n+    @ScalarFunction(\"minute\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long minute(@SqlType(\"time(p)\") long time)\n+    {\n+        return (time / PICOSECONDS_PER_MINUTE) % MINUTES_PER_HOUR;\n+    }\n+\n+    @Description(\"Hour of the day of the given time\")\n+    @ScalarFunction(\"hour\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long hour(@SqlType(\"time(p)\") long time)\n+    {\n+        return time / PICOSECONDS_PER_HOUR;\n+    }\n+\n+    @Description(\"Truncate to the specified precision in the session timezone\")\n+    @ScalarFunction(\"date_trunc\")\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p)\")\n+    public static long truncate(@SqlType(\"varchar(x)\") Slice unit, @SqlType(\"time(p)\") long time)\n+    {\n+        String unitString = unit.toStringUtf8().toLowerCase(ENGLISH);\n+\n+        switch (unitString) {\n+            case \"millisecond\":\n+                return time / PICOSECONDS_PER_MILLISECOND * PICOSECONDS_PER_MILLISECOND;\n+            case \"second\":\n+                return time / PICOSECONDS_PER_SECOND * PICOSECONDS_PER_SECOND;\n+            case \"minute\":\n+                return time / PICOSECONDS_PER_MINUTE * PICOSECONDS_PER_MINUTE;\n+            case \"hour\":\n+                return time / PICOSECONDS_PER_HOUR * PICOSECONDS_PER_HOUR;\n+            default:\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"'\" + unitString + \"' is not a valid Time field\");\n+        }\n+    }\n+\n+    @Description(\"Add the specified amount of time to the given time\")\n+    @LiteralParameters({\"x\", \"p\"})\n+    @ScalarFunction(\"date_add\")\n+    @SqlType(\"time(p)\")\n+    public static long dateAdd(\n+            @LiteralParameter(\"p\") long precision,\n+            @SqlType(\"varchar(x)\") Slice unit,\n+            @SqlType(StandardTypes.BIGINT) long value,\n+            @SqlType(\"time(p)\") long time)\n+    {\n+        long delta = value;\n+        String unitString = unit.toStringUtf8().toLowerCase(ENGLISH);\n+        switch (unitString) {\n+            case \"millisecond\":\n+                delta *= PICOSECONDS_PER_MILLISECOND;\n+                break;\n+            case \"second\":\n+                delta *= PICOSECONDS_PER_SECOND;\n+                break;\n+            case \"minute\":\n+                delta *= PICOSECONDS_PER_MINUTE;\n+                break;\n+            case \"hour\":\n+                delta *= PICOSECONDS_PER_HOUR;\n+                break;\n+            default:\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"'\" + unitString + \"' is not a valid Time field\");\n+        }\n+\n+        long result = TimeOperators.add(time, delta);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyNzA2MA==", "bodyText": "I guess  this could be declared as returning boolean, not Boolean\n(same below)", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463527060", "createdAt": "2020-07-31T10:14:49Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeOperators.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.airlift.slice.DynamicSliceOutput;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.BlockIndex;\n+import io.prestosql.spi.function.BlockPosition;\n+import io.prestosql.spi.function.IsNull;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlNullable;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.AbstractLongType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.type.Constraint;\n+import org.joda.time.chrono.ISOChronology;\n+\n+import static io.prestosql.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static io.prestosql.spi.function.OperatorType.ADD;\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.function.OperatorType.EQUAL;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.HASH_CODE;\n+import static io.prestosql.spi.function.OperatorType.INDETERMINATE;\n+import static io.prestosql.spi.function.OperatorType.IS_DISTINCT_FROM;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.NOT_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.SUBTRACT;\n+import static io.prestosql.spi.function.OperatorType.XX_HASH_64;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.type.DateTimes.MINUTES_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.parseTime;\n+import static io.prestosql.type.DateTimes.rescaleWithRounding;\n+import static io.prestosql.type.DateTimes.round;\n+import static io.prestosql.type.DateTimes.scaleFactor;\n+import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+import static java.lang.String.format;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public final class TimeOperators\n+{\n+    private TimeOperators() {}\n+\n+    @ScalarOperator(SUBTRACT)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND)\n+    public static long subtract(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        long interval = left - right;\n+\n+        interval = rescaleWithRounding(interval, MAX_PRECISION, 3);\n+\n+        return interval;\n+    }\n+\n+    @ScalarOperator(EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    @SqlNullable\n+    public static Boolean equal(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyODgxNw==", "bodyText": "% PICOSECONDS_PER_DAY seems redundant\nadd a comment if it's not", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463528817", "createdAt": "2020-07-31T10:18:57Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeOperators.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.airlift.slice.DynamicSliceOutput;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.BlockIndex;\n+import io.prestosql.spi.function.BlockPosition;\n+import io.prestosql.spi.function.IsNull;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlNullable;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.AbstractLongType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.type.Constraint;\n+import org.joda.time.chrono.ISOChronology;\n+\n+import static io.prestosql.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static io.prestosql.spi.function.OperatorType.ADD;\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.function.OperatorType.EQUAL;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.HASH_CODE;\n+import static io.prestosql.spi.function.OperatorType.INDETERMINATE;\n+import static io.prestosql.spi.function.OperatorType.IS_DISTINCT_FROM;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.NOT_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.SUBTRACT;\n+import static io.prestosql.spi.function.OperatorType.XX_HASH_64;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.type.DateTimes.MINUTES_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.parseTime;\n+import static io.prestosql.type.DateTimes.rescaleWithRounding;\n+import static io.prestosql.type.DateTimes.round;\n+import static io.prestosql.type.DateTimes.scaleFactor;\n+import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+import static java.lang.String.format;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public final class TimeOperators\n+{\n+    private TimeOperators() {}\n+\n+    @ScalarOperator(SUBTRACT)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND)\n+    public static long subtract(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        long interval = left - right;\n+\n+        interval = rescaleWithRounding(interval, MAX_PRECISION, 3);\n+\n+        return interval;\n+    }\n+\n+    @ScalarOperator(EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    @SqlNullable\n+    public static Boolean equal(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left == right;\n+    }\n+\n+    @ScalarOperator(NOT_EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    @SqlNullable\n+    public static Boolean notEqual(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left != right;\n+    }\n+\n+    @ScalarOperator(LESS_THAN)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean lessThan(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left < right;\n+    }\n+\n+    @ScalarOperator(LESS_THAN_OR_EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean lessThanOrEqual(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left <= right;\n+    }\n+\n+    @ScalarOperator(GREATER_THAN)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean greaterThan(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left > right;\n+    }\n+\n+    @ScalarOperator(GREATER_THAN_OR_EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean greaterThanOrEqual(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left >= right;\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.TIME_WITH_TIME_ZONE)\n+    public static long castToTimeWithTimeZone(ConnectorSession session, @SqlType(\"time(p)\") long value)\n+    {\n+        long millis = rescaleWithRounding(value, MAX_PRECISION, 3);\n+\n+        ISOChronology localChronology = getChronology(session.getTimeZoneKey());\n+        millis = localChronology.getZone().convertLocalToUTC(millis, false);\n+        return packDateTimeWithZone(millis, session.getTimeZoneKey());\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p)\")\n+    public static long castFromVarchar(@LiteralParameter(\"p\") long precision, @SqlType(\"varchar(x)\") Slice value)\n+    {\n+        try {\n+            long picos = parseTime(value.toStringUtf8());\n+            return round(picos, (int) (MAX_PRECISION - precision)) % PICOSECONDS_PER_DAY;\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to time: \" + value.toStringUtf8(), e);\n+        }\n+    }\n+\n+    @ScalarOperator(HASH_CODE)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long hashCode(@SqlType(\"time(p)\") long value)\n+    {\n+        return AbstractLongType.hash(value);\n+    }\n+\n+    @ScalarOperator(XX_HASH_64)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long xxHash64(@SqlType(\"time(p)\") long value)\n+    {\n+        return XxHash64.hash(value);\n+    }\n+\n+    @ScalarOperator(IS_DISTINCT_FROM)\n+    public static final class TimeDistinctFromOperator\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean isDistinctFrom(\n+                @SqlType(\"time(p)\") long left,\n+                @IsNull boolean leftNull,\n+                @SqlType(\"time(p)\") long right,\n+                @IsNull boolean rightNull)\n+        {\n+            if (leftNull != rightNull) {\n+                return true;\n+            }\n+            if (leftNull) {\n+                return false;\n+            }\n+            return notEqual(left, right);\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean isDistinctFrom(\n+                @BlockPosition @SqlType(value = \"time(p)\", nativeContainerType = long.class) Block left,\n+                @BlockIndex int leftPosition,\n+                @BlockPosition @SqlType(value = \"time(p)\", nativeContainerType = long.class) Block right,\n+                @BlockIndex int rightPosition)\n+        {\n+            if (left.isNull(leftPosition) != right.isNull(rightPosition)) {\n+                return true;\n+            }\n+            if (left.isNull(leftPosition)) {\n+                return false;\n+            }\n+            return notEqual(TIME.getLong(left, leftPosition), TIME.getLong(right, rightPosition));\n+        }\n+    }\n+\n+    @ScalarOperator(INDETERMINATE)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean indeterminate(@SqlType(\"time(p)\") long value, @IsNull boolean isNull)\n+    {\n+        return isNull;\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision)\")\n+    public static long castToTime(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        if (sourcePrecision <= targetPrecision) {\n+            return time;\n+        }\n+\n+        return round(time, (int) (MAX_PRECISION - targetPrecision)) % PICOSECONDS_PER_DAY;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyOTIyMg==", "bodyText": "Seems like this can return invalid time value (negative), when interval is longer than a day (eg 3 days)", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463529222", "createdAt": "2020-07-31T10:19:58Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeOperators.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.airlift.slice.DynamicSliceOutput;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.BlockIndex;\n+import io.prestosql.spi.function.BlockPosition;\n+import io.prestosql.spi.function.IsNull;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlNullable;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.AbstractLongType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.type.Constraint;\n+import org.joda.time.chrono.ISOChronology;\n+\n+import static io.prestosql.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static io.prestosql.spi.function.OperatorType.ADD;\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.function.OperatorType.EQUAL;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.HASH_CODE;\n+import static io.prestosql.spi.function.OperatorType.INDETERMINATE;\n+import static io.prestosql.spi.function.OperatorType.IS_DISTINCT_FROM;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.NOT_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.SUBTRACT;\n+import static io.prestosql.spi.function.OperatorType.XX_HASH_64;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.type.DateTimes.MINUTES_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.parseTime;\n+import static io.prestosql.type.DateTimes.rescaleWithRounding;\n+import static io.prestosql.type.DateTimes.round;\n+import static io.prestosql.type.DateTimes.scaleFactor;\n+import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+import static java.lang.String.format;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public final class TimeOperators\n+{\n+    private TimeOperators() {}\n+\n+    @ScalarOperator(SUBTRACT)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND)\n+    public static long subtract(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        long interval = left - right;\n+\n+        interval = rescaleWithRounding(interval, MAX_PRECISION, 3);\n+\n+        return interval;\n+    }\n+\n+    @ScalarOperator(EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    @SqlNullable\n+    public static Boolean equal(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left == right;\n+    }\n+\n+    @ScalarOperator(NOT_EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    @SqlNullable\n+    public static Boolean notEqual(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left != right;\n+    }\n+\n+    @ScalarOperator(LESS_THAN)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean lessThan(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left < right;\n+    }\n+\n+    @ScalarOperator(LESS_THAN_OR_EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean lessThanOrEqual(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left <= right;\n+    }\n+\n+    @ScalarOperator(GREATER_THAN)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean greaterThan(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left > right;\n+    }\n+\n+    @ScalarOperator(GREATER_THAN_OR_EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean greaterThanOrEqual(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left >= right;\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.TIME_WITH_TIME_ZONE)\n+    public static long castToTimeWithTimeZone(ConnectorSession session, @SqlType(\"time(p)\") long value)\n+    {\n+        long millis = rescaleWithRounding(value, MAX_PRECISION, 3);\n+\n+        ISOChronology localChronology = getChronology(session.getTimeZoneKey());\n+        millis = localChronology.getZone().convertLocalToUTC(millis, false);\n+        return packDateTimeWithZone(millis, session.getTimeZoneKey());\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p)\")\n+    public static long castFromVarchar(@LiteralParameter(\"p\") long precision, @SqlType(\"varchar(x)\") Slice value)\n+    {\n+        try {\n+            long picos = parseTime(value.toStringUtf8());\n+            return round(picos, (int) (MAX_PRECISION - precision)) % PICOSECONDS_PER_DAY;\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to time: \" + value.toStringUtf8(), e);\n+        }\n+    }\n+\n+    @ScalarOperator(HASH_CODE)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long hashCode(@SqlType(\"time(p)\") long value)\n+    {\n+        return AbstractLongType.hash(value);\n+    }\n+\n+    @ScalarOperator(XX_HASH_64)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long xxHash64(@SqlType(\"time(p)\") long value)\n+    {\n+        return XxHash64.hash(value);\n+    }\n+\n+    @ScalarOperator(IS_DISTINCT_FROM)\n+    public static final class TimeDistinctFromOperator\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean isDistinctFrom(\n+                @SqlType(\"time(p)\") long left,\n+                @IsNull boolean leftNull,\n+                @SqlType(\"time(p)\") long right,\n+                @IsNull boolean rightNull)\n+        {\n+            if (leftNull != rightNull) {\n+                return true;\n+            }\n+            if (leftNull) {\n+                return false;\n+            }\n+            return notEqual(left, right);\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean isDistinctFrom(\n+                @BlockPosition @SqlType(value = \"time(p)\", nativeContainerType = long.class) Block left,\n+                @BlockIndex int leftPosition,\n+                @BlockPosition @SqlType(value = \"time(p)\", nativeContainerType = long.class) Block right,\n+                @BlockIndex int rightPosition)\n+        {\n+            if (left.isNull(leftPosition) != right.isNull(rightPosition)) {\n+                return true;\n+            }\n+            if (left.isNull(leftPosition)) {\n+                return false;\n+            }\n+            return notEqual(TIME.getLong(left, leftPosition), TIME.getLong(right, rightPosition));\n+        }\n+    }\n+\n+    @ScalarOperator(INDETERMINATE)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean indeterminate(@SqlType(\"time(p)\") long value, @IsNull boolean isNull)\n+    {\n+        return isNull;\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision)\")\n+    public static long castToTime(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        if (sourcePrecision <= targetPrecision) {\n+            return time;\n+        }\n+\n+        return round(time, (int) (MAX_PRECISION - targetPrecision)) % PICOSECONDS_PER_DAY;\n+    }\n+\n+    @ScalarOperator(ADD)\n+    @LiteralParameters({\"p\", \"u\"})\n+    @SqlType(\"time(u)\")\n+    @Constraint(variable = \"u\", expression = \"max(3, p)\") // interval is currently p = 3\n+    public static long timePlusIntervalDayToSecond(@SqlType(\"time(p)\") long time, @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval)\n+    {\n+        return add(time, interval * PICOSECONDS_PER_MILLISECOND);\n+    }\n+\n+    @ScalarOperator(ADD)\n+    @LiteralParameters({\"p\", \"u\"})\n+    @SqlType(\"time(u)\")\n+    @Constraint(variable = \"u\", expression = \"max(3, p)\") // interval is currently p = 3\n+    public static long intervalDayToSecondPlusTime(@SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval, @SqlType(\"time(p)\") long time)\n+    {\n+        return timePlusIntervalDayToSecond(time, interval);\n+    }\n+\n+    @ScalarOperator(SUBTRACT)\n+    @LiteralParameters({\"p\", \"u\"})\n+    @SqlType(\"time(u)\")\n+    @Constraint(variable = \"u\", expression = \"max(3, p)\") // interval is currently p = 3\n+    public static long timeMinusIntervalDayToSecond(@SqlType(\"time(p)\") long time, @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval)\n+    {\n+        return add(time, -interval * PICOSECONDS_PER_MILLISECOND);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyOTc2OQ==", "bodyText": "As commented earlier, the if here may be insufficient for large negative delta", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463529769", "createdAt": "2020-07-31T10:21:18Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeOperators.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.airlift.slice.DynamicSliceOutput;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.BlockIndex;\n+import io.prestosql.spi.function.BlockPosition;\n+import io.prestosql.spi.function.IsNull;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlNullable;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.AbstractLongType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.type.Constraint;\n+import org.joda.time.chrono.ISOChronology;\n+\n+import static io.prestosql.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static io.prestosql.spi.function.OperatorType.ADD;\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.function.OperatorType.EQUAL;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.HASH_CODE;\n+import static io.prestosql.spi.function.OperatorType.INDETERMINATE;\n+import static io.prestosql.spi.function.OperatorType.IS_DISTINCT_FROM;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.NOT_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.SUBTRACT;\n+import static io.prestosql.spi.function.OperatorType.XX_HASH_64;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.type.DateTimes.MINUTES_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.parseTime;\n+import static io.prestosql.type.DateTimes.rescaleWithRounding;\n+import static io.prestosql.type.DateTimes.round;\n+import static io.prestosql.type.DateTimes.scaleFactor;\n+import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+import static java.lang.String.format;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public final class TimeOperators\n+{\n+    private TimeOperators() {}\n+\n+    @ScalarOperator(SUBTRACT)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND)\n+    public static long subtract(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        long interval = left - right;\n+\n+        interval = rescaleWithRounding(interval, MAX_PRECISION, 3);\n+\n+        return interval;\n+    }\n+\n+    @ScalarOperator(EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    @SqlNullable\n+    public static Boolean equal(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left == right;\n+    }\n+\n+    @ScalarOperator(NOT_EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    @SqlNullable\n+    public static Boolean notEqual(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left != right;\n+    }\n+\n+    @ScalarOperator(LESS_THAN)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean lessThan(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left < right;\n+    }\n+\n+    @ScalarOperator(LESS_THAN_OR_EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean lessThanOrEqual(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left <= right;\n+    }\n+\n+    @ScalarOperator(GREATER_THAN)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean greaterThan(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left > right;\n+    }\n+\n+    @ScalarOperator(GREATER_THAN_OR_EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean greaterThanOrEqual(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left >= right;\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.TIME_WITH_TIME_ZONE)\n+    public static long castToTimeWithTimeZone(ConnectorSession session, @SqlType(\"time(p)\") long value)\n+    {\n+        long millis = rescaleWithRounding(value, MAX_PRECISION, 3);\n+\n+        ISOChronology localChronology = getChronology(session.getTimeZoneKey());\n+        millis = localChronology.getZone().convertLocalToUTC(millis, false);\n+        return packDateTimeWithZone(millis, session.getTimeZoneKey());\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p)\")\n+    public static long castFromVarchar(@LiteralParameter(\"p\") long precision, @SqlType(\"varchar(x)\") Slice value)\n+    {\n+        try {\n+            long picos = parseTime(value.toStringUtf8());\n+            return round(picos, (int) (MAX_PRECISION - precision)) % PICOSECONDS_PER_DAY;\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to time: \" + value.toStringUtf8(), e);\n+        }\n+    }\n+\n+    @ScalarOperator(HASH_CODE)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long hashCode(@SqlType(\"time(p)\") long value)\n+    {\n+        return AbstractLongType.hash(value);\n+    }\n+\n+    @ScalarOperator(XX_HASH_64)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long xxHash64(@SqlType(\"time(p)\") long value)\n+    {\n+        return XxHash64.hash(value);\n+    }\n+\n+    @ScalarOperator(IS_DISTINCT_FROM)\n+    public static final class TimeDistinctFromOperator\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean isDistinctFrom(\n+                @SqlType(\"time(p)\") long left,\n+                @IsNull boolean leftNull,\n+                @SqlType(\"time(p)\") long right,\n+                @IsNull boolean rightNull)\n+        {\n+            if (leftNull != rightNull) {\n+                return true;\n+            }\n+            if (leftNull) {\n+                return false;\n+            }\n+            return notEqual(left, right);\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean isDistinctFrom(\n+                @BlockPosition @SqlType(value = \"time(p)\", nativeContainerType = long.class) Block left,\n+                @BlockIndex int leftPosition,\n+                @BlockPosition @SqlType(value = \"time(p)\", nativeContainerType = long.class) Block right,\n+                @BlockIndex int rightPosition)\n+        {\n+            if (left.isNull(leftPosition) != right.isNull(rightPosition)) {\n+                return true;\n+            }\n+            if (left.isNull(leftPosition)) {\n+                return false;\n+            }\n+            return notEqual(TIME.getLong(left, leftPosition), TIME.getLong(right, rightPosition));\n+        }\n+    }\n+\n+    @ScalarOperator(INDETERMINATE)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean indeterminate(@SqlType(\"time(p)\") long value, @IsNull boolean isNull)\n+    {\n+        return isNull;\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision)\")\n+    public static long castToTime(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        if (sourcePrecision <= targetPrecision) {\n+            return time;\n+        }\n+\n+        return round(time, (int) (MAX_PRECISION - targetPrecision)) % PICOSECONDS_PER_DAY;\n+    }\n+\n+    @ScalarOperator(ADD)\n+    @LiteralParameters({\"p\", \"u\"})\n+    @SqlType(\"time(u)\")\n+    @Constraint(variable = \"u\", expression = \"max(3, p)\") // interval is currently p = 3\n+    public static long timePlusIntervalDayToSecond(@SqlType(\"time(p)\") long time, @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval)\n+    {\n+        return add(time, interval * PICOSECONDS_PER_MILLISECOND);\n+    }\n+\n+    @ScalarOperator(ADD)\n+    @LiteralParameters({\"p\", \"u\"})\n+    @SqlType(\"time(u)\")\n+    @Constraint(variable = \"u\", expression = \"max(3, p)\") // interval is currently p = 3\n+    public static long intervalDayToSecondPlusTime(@SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval, @SqlType(\"time(p)\") long time)\n+    {\n+        return timePlusIntervalDayToSecond(time, interval);\n+    }\n+\n+    @ScalarOperator(SUBTRACT)\n+    @LiteralParameters({\"p\", \"u\"})\n+    @SqlType(\"time(u)\")\n+    @Constraint(variable = \"u\", expression = \"max(3, p)\") // interval is currently p = 3\n+    public static long timeMinusIntervalDayToSecond(@SqlType(\"time(p)\") long time, @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval)\n+    {\n+        return add(time, -interval * PICOSECONDS_PER_MILLISECOND);\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"varchar(x)\")\n+    public static Slice castToVarchar(@LiteralParameter(\"p\") long precision, @SqlType(\"time(p)\") long value)\n+    {\n+        int size = (int) (8 + // hour:minute:second\n+                        (precision > 0 ? 1 : 0) + // period\n+                        precision); // fraction\n+\n+        DynamicSliceOutput output = new DynamicSliceOutput(size);\n+\n+        output.appendBytes(format(\"%02d\", value / PICOSECONDS_PER_HOUR).getBytes(UTF_8));\n+        output.appendByte(':');\n+        output.appendBytes(format(\"%02d\", (value / PICOSECONDS_PER_MINUTE) % MINUTES_PER_HOUR).getBytes(UTF_8));\n+        output.appendByte(':');\n+        output.appendBytes(format(\"%02d\", (value / PICOSECONDS_PER_SECOND) % SECONDS_PER_MINUTE).getBytes(UTF_8));\n+\n+        if (precision > 0) {\n+            long scaledFraction = (value % PICOSECONDS_PER_SECOND) / scaleFactor((int) precision, MAX_PRECISION);\n+            output.appendByte('.');\n+            output.appendBytes(format(\"%0\" + precision + \"d\", scaledFraction).getBytes(UTF_8));\n+        }\n+\n+        return output.slice();\n+    }\n+\n+    public static long add(long time, long delta)\n+    {\n+        long result = (time + delta) % PICOSECONDS_PER_DAY;\n+        if (result < 0) {\n+            result += PICOSECONDS_PER_DAY;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzMDM4Ng==", "bodyText": "\"compute\" doesn't add information and \"epochMicros\" alone is not fully meaningful either.\nCan we name the method more declaratively?\nAlso, remove annotations from args", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463530386", "createdAt": "2020-07-31T10:22:35Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeToTimestampCast.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.TimeType;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.util.List;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.type.DateTimes.MICROSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n+import static io.prestosql.type.DateTimes.scaleEpochMicrosToMillis;\n+import static java.lang.Math.multiplyExact;\n+\n+@ScalarOperator(CAST)\n+public final class TimeToTimestampCast\n+{\n+    private TimeToTimestampCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static long castToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        if (targetPrecision <= 3) {\n+            return scaleEpochMicrosToMillis(epochMicros);\n+        }\n+\n+        return epochMicros;\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static LongTimestamp castToLong(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        return new LongTimestamp(epochMicros, (int) (time % PICOSECONDS_PER_MICROSECOND));\n+    }\n+\n+    private static long computeEpochMicros(@LiteralParameter(\"sourcePrecision\") long sourcePrecision, @LiteralParameter(\"targetPrecision\") long targetPrecision, ConnectorSession session, @SqlType(\"time(sourcePrecision)\") long time)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzMTIzMw==", "bodyText": "Since this can be invoked per row, we should avoid java.time. here.\nI am OK with this as is, but a TODO/issue would be nice.", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463531233", "createdAt": "2020-07-31T10:24:36Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeToTimestampCast.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.TimeType;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.util.List;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.type.DateTimes.MICROSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n+import static io.prestosql.type.DateTimes.scaleEpochMicrosToMillis;\n+import static java.lang.Math.multiplyExact;\n+\n+@ScalarOperator(CAST)\n+public final class TimeToTimestampCast\n+{\n+    private TimeToTimestampCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static long castToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        if (targetPrecision <= 3) {\n+            return scaleEpochMicrosToMillis(epochMicros);\n+        }\n+\n+        return epochMicros;\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static LongTimestamp castToLong(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        return new LongTimestamp(epochMicros, (int) (time % PICOSECONDS_PER_MICROSECOND));\n+    }\n+\n+    private static long computeEpochMicros(@LiteralParameter(\"sourcePrecision\") long sourcePrecision, @LiteralParameter(\"targetPrecision\") long targetPrecision, ConnectorSession session, @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochDay = LocalDate.ofInstant(session.getStart(), session.getTimeZoneKey().getZoneId())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzMjgxOA==", "bodyText": "When there are 2 offsets the latter one usually wins (eg when parsing string), so Iterables.getLast(offsets).\nAlso, add a comment why we do not need to handle the case when offsets.isEmpty()\nPerhaps\nepochSeconds = ZonedDateTime.ofInstant(Instant.ofEpochSecond(epochSeconds), ZoneOffset.UTC)\n                    .withZoneSameLocal(session.getTimeZoneKey().getZoneId())\n                    .toInstant().getEpochSecond();\n\nwould avoid having a comment", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463532818", "createdAt": "2020-07-31T10:27:51Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeToTimestampCast.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.TimeType;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.util.List;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.type.DateTimes.MICROSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n+import static io.prestosql.type.DateTimes.scaleEpochMicrosToMillis;\n+import static java.lang.Math.multiplyExact;\n+\n+@ScalarOperator(CAST)\n+public final class TimeToTimestampCast\n+{\n+    private TimeToTimestampCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static long castToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        if (targetPrecision <= 3) {\n+            return scaleEpochMicrosToMillis(epochMicros);\n+        }\n+\n+        return epochMicros;\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static LongTimestamp castToLong(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        return new LongTimestamp(epochMicros, (int) (time % PICOSECONDS_PER_MICROSECOND));\n+    }\n+\n+    private static long computeEpochMicros(@LiteralParameter(\"sourcePrecision\") long sourcePrecision, @LiteralParameter(\"targetPrecision\") long targetPrecision, ConnectorSession session, @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochDay = LocalDate.ofInstant(session.getStart(), session.getTimeZoneKey().getZoneId())\n+                .toEpochDay();\n+\n+        long epochSeconds = multiplyExact(epochDay, SECONDS_PER_DAY) + time / PICOSECONDS_PER_SECOND;\n+\n+        if (session.isLegacyTimestamp()) {\n+            Instant instant = Instant.ofEpochSecond(epochSeconds);\n+            LocalDateTime dateTime = LocalDateTime.ofInstant(instant, session.getTimeZoneKey().getZoneId());\n+            List<ZoneOffset> offsets = session.getTimeZoneKey().getZoneId().getRules().getValidOffsets(dateTime);\n+            epochSeconds -= offsets.get(0).getTotalSeconds();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzNDQ3Nw==", "bodyText": "epochSeconds -> epochSecond", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463534477", "createdAt": "2020-07-31T10:31:32Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeToTimestampCast.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.TimeType;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.util.List;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.type.DateTimes.MICROSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n+import static io.prestosql.type.DateTimes.scaleEpochMicrosToMillis;\n+import static java.lang.Math.multiplyExact;\n+\n+@ScalarOperator(CAST)\n+public final class TimeToTimestampCast\n+{\n+    private TimeToTimestampCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static long castToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        if (targetPrecision <= 3) {\n+            return scaleEpochMicrosToMillis(epochMicros);\n+        }\n+\n+        return epochMicros;\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static LongTimestamp castToLong(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        return new LongTimestamp(epochMicros, (int) (time % PICOSECONDS_PER_MICROSECOND));\n+    }\n+\n+    private static long computeEpochMicros(@LiteralParameter(\"sourcePrecision\") long sourcePrecision, @LiteralParameter(\"targetPrecision\") long targetPrecision, ConnectorSession session, @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochDay = LocalDate.ofInstant(session.getStart(), session.getTimeZoneKey().getZoneId())\n+                .toEpochDay();\n+\n+        long epochSeconds = multiplyExact(epochDay, SECONDS_PER_DAY) + time / PICOSECONDS_PER_SECOND;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzNTAxMw==", "bodyText": "I don't understand the comment. Especially since this method is called in to-short and to-long cases", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463535013", "createdAt": "2020-07-31T10:32:52Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeToTimestampCast.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.TimeType;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.util.List;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.type.DateTimes.MICROSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n+import static io.prestosql.type.DateTimes.scaleEpochMicrosToMillis;\n+import static java.lang.Math.multiplyExact;\n+\n+@ScalarOperator(CAST)\n+public final class TimeToTimestampCast\n+{\n+    private TimeToTimestampCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static long castToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        if (targetPrecision <= 3) {\n+            return scaleEpochMicrosToMillis(epochMicros);\n+        }\n+\n+        return epochMicros;\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static LongTimestamp castToLong(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        return new LongTimestamp(epochMicros, (int) (time % PICOSECONDS_PER_MICROSECOND));\n+    }\n+\n+    private static long computeEpochMicros(@LiteralParameter(\"sourcePrecision\") long sourcePrecision, @LiteralParameter(\"targetPrecision\") long targetPrecision, ConnectorSession session, @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochDay = LocalDate.ofInstant(session.getStart(), session.getTimeZoneKey().getZoneId())\n+                .toEpochDay();\n+\n+        long epochSeconds = multiplyExact(epochDay, SECONDS_PER_DAY) + time / PICOSECONDS_PER_SECOND;\n+\n+        if (session.isLegacyTimestamp()) {\n+            Instant instant = Instant.ofEpochSecond(epochSeconds);\n+            LocalDateTime dateTime = LocalDateTime.ofInstant(instant, session.getTimeZoneKey().getZoneId());\n+            List<ZoneOffset> offsets = session.getTimeZoneKey().getZoneId().getRules().getValidOffsets(dateTime);\n+            epochSeconds -= offsets.get(0).getTotalSeconds();\n+        }\n+\n+        long picoFraction = time % PICOSECONDS_PER_SECOND;\n+        if (sourcePrecision > targetPrecision) {\n+            picoFraction = round(picoFraction, (int) (TimeType.MAX_PRECISION - targetPrecision));\n+        }\n+\n+        // target precision is > 6 for long timestamp\n+        long microFraction = rescale(picoFraction, TimeType.MAX_PRECISION, 6);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzNzExMg==", "bodyText": "JDBC 339 declares that is supportsParametricDateTime, but it was not updated.\nDoes it work with time(>3) as well?", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463537112", "createdAt": "2020-07-31T10:37:50Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -201,6 +203,10 @@ private Object getLegacyValue(Object value, Type type)\n             if (type instanceof TimestampWithTimeZoneType) {\n                 return ((SqlTimestampWithTimeZone) value).roundTo(3);\n             }\n+\n+            if (type instanceof TimeType) {\n+                value = ((SqlTime) value).roundTo(3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzODg4Ng==", "bodyText": "should we limit fraction value to 12 digits?", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463538886", "createdAt": "2020-07-31T10:42:15Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/type/DateTimes.java", "diffHunk": "@@ -474,6 +494,57 @@ private static long toEpochSecond(String year, String month, String day, String\n         return timestamp.toEpochSecond(offsets.get(0));\n     }\n \n+    public static boolean timeHasTimeZone(String value)\n+    {\n+        Matcher matcher = TIME_PATTERN.matcher(value);\n+        if (!matcher.matches()) {\n+            throw new IllegalArgumentException(format(\"Invalid time '%s'\", value));\n+        }\n+\n+        return matcher.group(\"timezone\") != null;\n+    }\n+\n+    public static int extractTimePrecision(String value)\n+    {\n+        Matcher matcher = TIME_PATTERN.matcher(value);\n+        if (!matcher.matches()) {\n+            throw new IllegalArgumentException(format(\"Invalid time '%s'\", value));\n+        }\n+\n+        String fraction = matcher.group(\"fraction\");\n+        if (fraction == null) {\n+            return 0;\n+        }\n+\n+        return fraction.length();\n+    }\n+\n+    public static long parseTime(String value)\n+    {\n+        Matcher matcher = TIME_PATTERN.matcher(value);\n+        if (!matcher.matches() || matcher.group(\"timezone\") != null) {\n+            throw new IllegalArgumentException(\"Invalid time: \" + value);\n+        }\n+\n+        int hour = Integer.parseInt(matcher.group(\"hour\"));\n+        int minute = Integer.parseInt(matcher.group(\"minute\"));\n+        int second = matcher.group(\"second\") == null ? 0 : Integer.parseInt(matcher.group(\"second\"));\n+\n+        if (hour > 23 || minute > 59 || second > 59) {\n+            throw new IllegalArgumentException(\"Invalid time: \" + value);\n+        }\n+\n+        int precision = 0;\n+        String fraction = matcher.group(\"fraction\");\n+        long fractionValue = 0;\n+        if (fraction != null) {\n+            precision = fraction.length();\n+            fractionValue = Long.parseLong(fraction);\n+        }\n+\n+        return (((hour * 60) + minute) * 60 + second) * PICOSECONDS_PER_SECOND + rescale(fractionValue, precision, 12);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0MDA2Ng==", "bodyText": "That looks wrong. The millis should be interpreted in the zone packed in value:\nLocalTime.ofInstant(Instant.ofEpochMilli(millis), unpackZoneKey(value).getZoneId())", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463540066", "createdAt": "2020-07-31T10:45:09Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/type/TimeWithTimeZoneOperators.java", "diffHunk": "@@ -106,12 +117,23 @@ public static boolean greaterThanOrEqual(@SqlType(StandardTypes.TIME_WITH_TIME_Z\n     }\n \n     @ScalarOperator(CAST)\n-    @SqlType(StandardTypes.TIME)\n-    public static long castToTime(ConnectorSession session, @SqlType(StandardTypes.TIME_WITH_TIME_ZONE) long value)\n+    @LiteralParameters(\"p\")\n+    @SqlType(\"time(p)\")\n+    public static long castToTime(@LiteralParameter(\"p\") long precision, @SqlType(StandardTypes.TIME_WITH_TIME_ZONE) long value)\n     {\n-        // This is exactly the same operation as for TIME WITH TIME ZONE -> TIMESTAMP, as the representations\n-        // of those types are aligned in range that is covered by TIME WITH TIME ZONE.\n-        return TimeWithTimezoneToTimestampCast.cast(3, session, value);\n+        long millis = unpackMillisUtc(value);\n+        if (millis < 0) {\n+            millis += MILLISECONDS_PER_DAY;\n+        }\n+        LocalDateTime localDateTime = LocalDateTime.of(LocalDate.ofEpochDay(0), LocalTime.ofNanoOfDay(millis / PICOSECONDS_PER_NANOSECOND));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0MDgzNQ==", "bodyText": "Why this moved in your PR?", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463540835", "createdAt": "2020-07-31T10:47:00Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/util/JsonUtil.java", "diffHunk": "@@ -91,9 +91,9 @@\n import static io.prestosql.spi.type.RealType.REAL;\n import static io.prestosql.spi.type.SmallintType.SMALLINT;\n import static io.prestosql.spi.type.TinyintType.TINYINT;\n-import static io.prestosql.type.JsonType.JSON;\n import static io.prestosql.type.DateTimes.formatTimestamp;\n import static io.prestosql.type.DateTimes.scaleEpochMillisToMicros;\n+import static io.prestosql.type.JsonType.JSON;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0MjY1MQ==", "bodyText": "add a case with as time(1) and as time(9) as well", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463542651", "createdAt": "2020-07-31T10:51:20Z", "author": {"login": "findepi"}, "path": "presto-main/src/test/java/io/prestosql/type/TestTimeWithTimeZoneBase.java", "diffHunk": "@@ -198,7 +200,12 @@ public void testBetween()\n     }\n \n     @Test\n-    public abstract void testCastToTime();\n+    public void testCastToTime()\n+    {\n+        assertFunction(\"cast(TIME '03:04:05.321 +07:09' as time)\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0MjczMQ==", "bodyText": "add a case with as time(1) and as time(9) as well", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463542731", "createdAt": "2020-07-31T10:51:34Z", "author": {"login": "findepi"}, "path": "presto-main/src/test/java/io/prestosql/type/TestTimestampWithTimeZoneBase.java", "diffHunk": "@@ -267,7 +269,16 @@ public void testCastToDate()\n     }\n \n     @Test\n-    public abstract void testCastToTime();\n+    public void testCastToTime()\n+    {\n+        assertFunction(\"cast(TIMESTAMP '2001-1-22 03:04:05.321 +07:09' as time)\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0MzQ3OA==", "bodyText": "this  should not need to round, it should just \"represent\"\nso maybe checkArgument instead?", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463543478", "createdAt": "2020-07-31T10:53:28Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/SqlTime.java", "diffHunk": "@@ -15,100 +15,80 @@\n \n import com.fasterxml.jackson.annotation.JsonValue;\n \n-import java.time.Instant;\n-import java.time.ZoneId;\n-import java.time.ZoneOffset;\n-import java.time.format.DateTimeFormatter;\n import java.util.Objects;\n-import java.util.Optional;\n+\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.spi.type.Timestamps.MINUTES_PER_HOUR;\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.spi.type.Timestamps.POWERS_OF_TEN;\n+import static io.prestosql.spi.type.Timestamps.SECONDS_PER_MINUTE;\n+import static io.prestosql.spi.type.Timestamps.round;\n+import static java.lang.String.format;\n \n public final class SqlTime\n {\n-    private static final DateTimeFormatter JSON_FORMATTER = DateTimeFormatter.ofPattern(\"HH:mm:ss.SSS\");\n-\n-    private final long millis;\n-    private final Optional<TimeZoneKey> sessionTimeZoneKey;\n-\n-    public SqlTime(long millis)\n-    {\n-        this.millis = millis;\n-        this.sessionTimeZoneKey = Optional.empty();\n-    }\n+    private final int precision;\n+    private final long picos;\n \n-    @Deprecated\n-    public SqlTime(long millisUtc, TimeZoneKey sessionTimeZoneKey)\n+    public static SqlTime newInstance(int precision, long picos)\n     {\n-        this.millis = millisUtc;\n-        this.sessionTimeZoneKey = Optional.of(sessionTimeZoneKey);\n+        return new SqlTime(precision, round(picos, 12 - precision));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0NDAyMw==", "bodyText": "can overflow?\nalso, depending on what getMillis() above does, this needs to round to [0, PICOS_PER_DAY)", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463544023", "createdAt": "2020-07-31T10:54:54Z", "author": {"login": "findepi"}, "path": "presto-record-decoder/src/main/java/io/prestosql/decoder/json/AbstractDateTimeJsonValueProvider.java", "diffHunk": "@@ -66,7 +67,10 @@ public final long getLong()\n         if (type.equals(DATE)) {\n             return TimeUnit.MILLISECONDS.toDays(millis);\n         }\n-        if (type.equals(TIMESTAMP) || type.equals(TIME)) {\n+        if (type.equals(TIME)) {\n+            return millis * PICOSECONDS_PER_MILLISECOND;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0NDg4Ng==", "bodyText": "this can overlfow, because millis and PICOSECONDS_PER_MILLISECOND are both ints\nalso, this needs to round to [0, PICOS_OF_DAY)", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463544886", "createdAt": "2020-07-31T10:57:05Z", "author": {"login": "findepi"}, "path": "presto-mongodb/src/main/java/io/prestosql/plugin/mongodb/MongoPageSource.java", "diffHunk": "@@ -183,7 +184,8 @@ else if (type.equals(DATE)) {\n                     type.writeLong(output, TimeUnit.MILLISECONDS.toDays(utcMillis));\n                 }\n                 else if (type.equals(TIME)) {\n-                    type.writeLong(output, UTC_CHRONOLOGY.millisOfDay().get(((Date) value).getTime()));\n+                    int millis = UTC_CHRONOLOGY.millisOfDay().get(((Date) value).getTime());\n+                    type.writeLong(output, millis * PICOSECONDS_PER_MILLISECOND);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NDQ1MDY3", "url": "https://github.com/trinodb/trino/pull/4381#pullrequestreview-459445067", "createdAt": "2020-07-31T20:17:24Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQyMDoxNzoyNFrOG6VDzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQyMDoxNzoyNFrOG6VDzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxNTYyOA==", "bodyText": "This class seems to nearly be a susbet of DateTimes. Could the rest of its functionality be moved here (and then this class could also be renamed DateTimes)?\nIf that's too much to move, the two classes should at least define the same set of conversion constants and functions, and have comments referring to each other (and a todo to merge them).\n(This class should probably be renamed to DateTimes either way, given that the conversion constants seem to be used at least as much for times as for timestamps.)\n\n(The constants' definitions could also be a bit nicer.)\nThis is the minimal definition for all of the constants currently in either class:\npublic static final int PICOSECONDS_PER_NANOSECOND = 1000;\npublic static final int NANOSECONDS_PER_MICROSECOND = 1000;\npublic static final int MICROSECONDS_PER_MILLISECOND = 1000;\npublic static final int MILLISECONDS_PER_SECOND = 1000;\npublic static final int SECONDS_PER_MINUTE = 60;\npublic static final int MINUTES_PER_HOUR = 60;\npublic static final int HOURS_PER_DAY = 24;\n\npublic static final int SECONDS_PER_DAY = SECONDS_PER_MINUTE * MINUTES_PER_HOUR * HOURS_PER_DAY;\n\npublic static final int MILLISECONDS_PER_DAY = MILLISECONDS_PER_SECOND * SECONDS_PER_DAY;\n\npublic static final int MICROSECONDS_PER_SECOND = MICROSECONDS_PER_MILLISECOND * MILLISECONDS_PER_SECOND;\npublic static final long MICROSECONDS_PER_DAY = (long) MICROSECONDS_PER_MILLISECOND * MILLISECONDS_PER_DAY;\n\npublic static final int NANOSECONDS_PER_MILLISECOND = NANOSECONDS_PER_MICROSECOND * MICROSECONDS_PER_MILLISECOND;\npublic static final long NANOSECONDS_PER_DAY = (long) NANOSECONDS_PER_MILLISECOND * MILLISECONDS_PER_DAY;\n\npublic static final int PICOSECONDS_PER_MICROSECOND = PICOSECONDS_PER_NANOSECOND * NANOSECONDS_PER_MICROSECOND;\npublic static final int PICOSECONDS_PER_MILLISECOND = PICOSECONDS_PER_MICROSECOND * MICROSECONDS_PER_MILLISECOND;\npublic static final long PICOSECONDS_PER_SECOND = (long) PICOSECONDS_PER_MILLISECOND * MILLISECONDS_PER_SECOND;\npublic static final long PICOSECONDS_PER_MINUTE = PICOSECONDS_PER_SECOND * SECONDS_PER_MINUTE;\npublic static final long PICOSECONDS_PER_HOUR = PICOSECONDS_PER_MINUTE * MINUTES_PER_HOUR;\npublic static final long PICOSECONDS_PER_DAY = PICOSECONDS_PER_HOUR * HOURS_PER_DAY;\n\n(There are 9 additional constants not specified in either class.)\nHere's the full set, if you want them:\npublic static final int PICOSECONDS_PER_NANOSECOND = 1000;\npublic static final int NANOSECONDS_PER_MICROSECOND = 1000;\npublic static final int MICROSECONDS_PER_MILLISECOND = 1000;\npublic static final int MILLISECONDS_PER_SECOND = 1000;\npublic static final int SECONDS_PER_MINUTE = 60;\npublic static final int MINUTES_PER_HOUR = 60;\npublic static final int HOURS_PER_DAY = 24;\n\npublic static final int MINUTES_PER_DAY = MINUTES_PER_HOUR * HOURS_PER_DAY;\n\npublic static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;\npublic static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;\n\npublic static final int MILLISECONDS_PER_MINUTE = MILLISECONDS_PER_SECOND * SECONDS_PER_MINUTE;\npublic static final int MILLISECONDS_PER_HOUR = MILLISECONDS_PER_MINUTE * MINUTES_PER_HOUR;\npublic static final int MILLISECONDS_PER_DAY = MILLISECONDS_PER_HOUR * HOURS_PER_DAY;\n\npublic static final int MICROSECONDS_PER_SECOND = MICROSECONDS_PER_MILLISECOND * MILLISECONDS_PER_SECOND;\npublic static final int MICROSECONDS_PER_MINUTE = MICROSECONDS_PER_SECOND * SECONDS_PER_MINUTE;\npublic static final long MICROSECONDS_PER_HOUR = (long) MICROSECONDS_PER_MINUTE * MINUTES_PER_HOUR;\npublic static final long MICROSECONDS_PER_DAY = MICROSECONDS_PER_HOUR * HOURS_PER_DAY;\n\npublic static final int NANOSECONDS_PER_MILLISECOND = NANOSECONDS_PER_MICROSECOND * MICROSECONDS_PER_MILLISECOND;\npublic static final int NANOSECONDS_PER_SECOND = NANOSECONDS_PER_MILLISECOND * MILLISECONDS_PER_SECOND;\npublic static final long NANOSECONDS_PER_MINUTE = (long) NANOSECONDS_PER_SECOND * SECONDS_PER_MINUTE;\npublic static final long NANOSECONDS_PER_HOUR = NANOSECONDS_PER_MINUTE * MINUTES_PER_HOUR;\npublic static final long NANOSECONDS_PER_DAY = NANOSECONDS_PER_HOUR * HOURS_PER_DAY;\n\npublic static final int PICOSECONDS_PER_MICROSECOND = PICOSECONDS_PER_NANOSECOND * NANOSECONDS_PER_MICROSECOND;\npublic static final int PICOSECONDS_PER_MILLISECOND = PICOSECONDS_PER_MICROSECOND * MICROSECONDS_PER_MILLISECOND;\npublic static final long PICOSECONDS_PER_SECOND = (long) PICOSECONDS_PER_MILLISECOND * MILLISECONDS_PER_SECOND;\npublic static final long PICOSECONDS_PER_MINUTE = PICOSECONDS_PER_SECOND * SECONDS_PER_MINUTE;\npublic static final long PICOSECONDS_PER_HOUR = PICOSECONDS_PER_MINUTE * MINUTES_PER_HOUR;\npublic static final long PICOSECONDS_PER_DAY = PICOSECONDS_PER_HOUR * HOURS_PER_DAY;", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463815628", "createdAt": "2020-07-31T20:17:24Z", "author": {"login": "jirassimok"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/Timestamps.java", "diffHunk": "@@ -22,10 +22,11 @@\n import static java.lang.Math.floorMod;\n import static java.lang.String.format;\n \n-class Timestamps\n+public class Timestamps", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjAyODY4", "url": "https://github.com/trinodb/trino/pull/4381#pullrequestreview-459602868", "createdAt": "2020-08-01T20:44:08Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQyMDo0NDowOFrOG6gOkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQyMDo0NTo0OFrOG6gPOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5ODYwOA==", "bodyText": "Can we also check that picos is within [0, 86,400,000,000,000)?", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463998608", "createdAt": "2020-08-01T20:44:08Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/SqlTime.java", "diffHunk": "@@ -15,100 +15,85 @@\n \n import com.fasterxml.jackson.annotation.JsonValue;\n \n-import java.time.Instant;\n-import java.time.ZoneId;\n-import java.time.ZoneOffset;\n-import java.time.format.DateTimeFormatter;\n import java.util.Objects;\n-import java.util.Optional;\n+\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.spi.type.Timestamps.MINUTES_PER_HOUR;\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.spi.type.Timestamps.POWERS_OF_TEN;\n+import static io.prestosql.spi.type.Timestamps.SECONDS_PER_MINUTE;\n+import static io.prestosql.spi.type.Timestamps.rescale;\n+import static io.prestosql.spi.type.Timestamps.round;\n+import static java.lang.String.format;\n \n public final class SqlTime\n {\n-    private static final DateTimeFormatter JSON_FORMATTER = DateTimeFormatter.ofPattern(\"HH:mm:ss.SSS\");\n-\n-    private final long millis;\n-    private final Optional<TimeZoneKey> sessionTimeZoneKey;\n-\n-    public SqlTime(long millis)\n-    {\n-        this.millis = millis;\n-        this.sessionTimeZoneKey = Optional.empty();\n-    }\n+    private final int precision;\n+    private final long picos;\n \n-    @Deprecated\n-    public SqlTime(long millisUtc, TimeZoneKey sessionTimeZoneKey)\n+    public static SqlTime newInstance(int precision, long picos)\n     {\n-        this.millis = millisUtc;\n-        this.sessionTimeZoneKey = Optional.of(sessionTimeZoneKey);\n-    }\n+        if (rescale(rescale(picos, 12, precision), precision, 12) != picos) {\n+            throw new IllegalArgumentException(\"picos contains data beyond specified precision: \" + precision);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5ODc3Nw==", "bodyText": "I think you can  skip this check. It's internal and ArrayIndexOutOfBoundsException below will be good enough", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463998777", "createdAt": "2020-08-01T20:45:48Z", "author": {"login": "findepi"}, "path": "presto-spi/src/main/java/io/prestosql/spi/type/Timestamps.java", "diffHunk": "@@ -43,16 +44,53 @@\n \n     public static final int MILLISECONDS_PER_SECOND = 1_000;\n     public static final int MICROSECONDS_PER_SECOND = 1_000_000;\n+    public static final int NANOSECONDS_PER_MILLISECOND = 1_000_000;\n+    public static final long NANOSECONDS_PER_DAY = 1_000_000_000L * 60 * 60 * 24;\n+    public static final int PICOSECONDS_PER_NANOSECOND = 1_000;\n     public static final int PICOSECONDS_PER_MICROSECOND = 1_000_000;\n     public static final int PICOSECONDS_PER_MILLISECOND = 1_000_000_000;\n+    public static final long PICOSECONDS_PER_SECOND = 1_000_000_000_000L;\n+    public static final long PICOSECONDS_PER_MINUTE = PICOSECONDS_PER_SECOND * 60;\n+    public static final long PICOSECONDS_PER_HOUR = PICOSECONDS_PER_MINUTE * 60;\n+    public static final long PICOSECONDS_PER_DAY = PICOSECONDS_PER_HOUR * 24;\n+    public static final long SECONDS_PER_MINUTE = 60;\n+    public static final long MINUTES_PER_HOUR = 60;\n \n     private Timestamps() {}\n \n-    public static long round(long value, int magnitude)\n+    static long round(long value, int magnitude)\n     {\n         return roundDiv(value, POWERS_OF_TEN[magnitude]) * POWERS_OF_TEN[magnitude];\n     }\n \n+    /**\n+     * Rescales a value of the given precision to another precision by adding 0s or truncating.\n+     */\n+    static long rescale(long value, int fromPrecision, int toPrecision)\n+    {\n+        if (value < 0) {\n+            throw new IllegalArgumentException(\"value must be >= 0\");\n+        }\n+\n+        if (fromPrecision <= toPrecision) {\n+            value *= scaleFactor(fromPrecision, toPrecision);\n+        }\n+        else {\n+            value /= scaleFactor(toPrecision, fromPrecision);\n+        }\n+\n+        return value;\n+    }\n+\n+    private static long scaleFactor(int fromPrecision, int toPrecision)\n+    {\n+        if (fromPrecision > toPrecision) {\n+            throw new IllegalArgumentException(\"fromPrecision must be <= toPrecision\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 60}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNjgyODkw", "url": "https://github.com/trinodb/trino/pull/4381#pullrequestreview-463682890", "createdAt": "2020-08-07T23:10:53Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMzoxMDo1M1rOG9rHOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMzoxMDo1M1rOG9rHOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMjY4MQ==", "bodyText": "Why does this translation go through milliseconds? Shouldn't this be the same?\ntoLocalTime(time).toNanoOfDay() * PICOSECONDS_PER_NANOSECOND\n\nThe millisecond conversion serves to truncate the time, but toLocalTime returns a value with nothing more precise than nanoseconds, so the truncation never does anything.", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r467322681", "createdAt": "2020-08-07T23:10:53Z", "author": {"login": "jirassimok"}, "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -282,11 +282,19 @@ public static ColumnMapping timeColumnMappingUsingSqlTime()\n                 TIME,\n                 (resultSet, columnIndex) -> {\n                     Time time = resultSet.getTime(columnIndex);\n-                    return time.getTime() * PICOSECONDS_PER_MILLISECOND % PICOSECONDS_PER_DAY;\n+                    return (roundDiv(toLocalTime(time).toNanoOfDay(), NANOSECONDS_PER_MILLISECOND) * PICOSECONDS_PER_MILLISECOND) % PICOSECONDS_PER_DAY;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b9938891d79fafc52d8cd92af332f593c01eb05", "author": {"user": {"login": "martint", "name": "Martin Traverso"}}, "url": "https://github.com/trinodb/trino/commit/1b9938891d79fafc52d8cd92af332f593c01eb05", "committedDate": "2020-08-11T06:38:17Z", "message": "Disable TIME type tests for older driver versions\n\nWe're intentionally breaking compatibility as part of fixing\nthe semantics of TIME type and adding variable-precision support."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31ba61d169474afc6fc4bd2cbe72f8110f66d8bd", "author": {"user": {"login": "martint", "name": "Martin Traverso"}}, "url": "https://github.com/trinodb/trino/commit/31ba61d169474afc6fc4bd2cbe72f8110f66d8bd", "committedDate": "2020-08-11T06:38:17Z", "message": "Rename Timestamps to DateTimes\n\nThis class will contain functions for dealing with TIME type, too."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19811d3d58e908d145639b1975ec111a0002e138", "author": {"user": {"login": "martint", "name": "Martin Traverso"}}, "url": "https://github.com/trinodb/trino/commit/19811d3d58e908d145639b1975ec111a0002e138", "committedDate": "2020-08-11T06:38:17Z", "message": "Implement variable-precision time type\n\n* Removes support for legacy semantics for time type.\n* Changes the internal representation of time type to picoseconds since midnight. This is a backward\n  incompatible change but since time type is broken in many ways today to the point of being almost\n  unusable, this is not such a big problem."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "19811d3d58e908d145639b1975ec111a0002e138", "author": {"user": {"login": "martint", "name": "Martin Traverso"}}, "url": "https://github.com/trinodb/trino/commit/19811d3d58e908d145639b1975ec111a0002e138", "committedDate": "2020-08-11T06:38:17Z", "message": "Implement variable-precision time type\n\n* Removes support for legacy semantics for time type.\n* Changes the internal representation of time type to picoseconds since midnight. This is a backward\n  incompatible change but since time type is broken in many ways today to the point of being almost\n  unusable, this is not such a big problem."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}