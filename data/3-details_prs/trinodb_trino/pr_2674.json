{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4ODAzNzkw", "number": 2674, "title": "Allow dynamic filtering with comparison operators", "bodyText": "Following #52, we would like to support dynamic filtering for cross joins (e.g. having inequality predicates in the join criteria). For example, the following query should benefit from this feature:\nSELECT\n\tcount() \nFROM\n\torders o, part p \nWHERE\n\tp.comment = \"Very expensive part\" AND \n\to.totalprice > p.retailprice \nThe following PR proposes a possible implementation - please let us know what do you think :)", "createdAt": "2020-01-29T22:43:08Z", "url": "https://github.com/trinodb/trino/pull/2674", "merged": true, "mergeCommit": {"oid": "609723a3eed065a8cdad2b4a3e2c92fff5623d0a"}, "closed": true, "closedAt": "2020-11-04T21:21:44Z", "author": {"login": "rzeyde-varada"}, "timelineItems": {"totalCount": 82, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb_VDRIABqjI5OTIxOTE0NjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZQN-KgBqjM5NTgzNzk1MDI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1Njg4ODYw", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-425688860", "createdAt": "2020-06-06T00:25:41Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDoyNTo0MVrOGgAcVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDozMjozNlrOGgAfsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDg3MA==", "bodyText": "Avoid abbreviations.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436214870", "createdAt": "2020-06-06T00:25:41Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -97,12 +104,19 @@ public static boolean isDynamicFilter(Expression expression)\n         }\n \n         List<Expression> arguments = functionCall.getArguments();\n-        checkArgument(arguments.size() == 2, \"invalid arguments count: %s\", arguments.size());\n+        checkArgument(arguments.size() == 3, \"invalid arguments count: %s\", arguments.size());\n+\n+        Expression probeSymbol = arguments.get(0);\n+\n+        Expression opExpression = arguments.get(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDk2OQ==", "bodyText": "Avoid abbreviations: op -> operator", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436214969", "createdAt": "2020-06-06T00:26:25Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -187,35 +210,35 @@ private Function() {}\n \n         @TypeParameter(\"T\")\n         @SqlType(BOOLEAN)\n-        public static boolean dynamicFilter(@SqlType(VARCHAR) Slice id, @SqlType(\"T\") Block input)\n+        public static boolean dynamicFilter(@SqlType(\"T\") Block input, @SqlType(VARCHAR) Slice op, @SqlType(VARCHAR) Slice id)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTMwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        createDynamicFilter(buildSource, node, context, partitionCount).ifPresent(\n          \n          \n            \n                                filter -> factoriesBuilder.add(createDynamicFilterSourceOperatorFactory(filter, node, buildSource, buildContext)));\n          \n          \n            \n                        createDynamicFilter(buildSource, node, context, partitionCount)\n          \n          \n            \n                            .ifPresent(filter -> factoriesBuilder.add(createDynamicFilterSourceOperatorFactory(filter, node, buildSource, buildContext)));", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436215306", "createdAt": "2020-06-06T00:29:17Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -1812,14 +1812,19 @@ private PhysicalOperation createNestedLoopJoin(JoinNode node, LocalExecutionPlan\n                     node.getId(),\n                     nestedLoopJoinBridgeManager);\n \n-            checkArgument(buildContext.getDriverInstanceCount().orElse(1) == 1, \"Expected local execution to not be parallel\");\n+            int partitionCount = buildContext.getDriverInstanceCount().orElse(1);\n+            checkArgument(partitionCount == 1, \"Expected local execution to not be parallel\");\n+\n+            ImmutableList.Builder<OperatorFactory> factoriesBuilder = ImmutableList.builder();\n+            factoriesBuilder.addAll(buildSource.getOperatorFactories());\n+            createDynamicFilter(buildSource, node, context, partitionCount).ifPresent(\n+                    filter -> factoriesBuilder.add(createDynamicFilterSourceOperatorFactory(filter, node, buildSource, buildContext)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTQzNw==", "bodyText": "Remove final", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436215437", "createdAt": "2020-06-06T00:30:21Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -470,13 +480,20 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             // Create new projections for the new join clauses\n             List<JoinNode.EquiJoinClause> equiJoinClauses = new ArrayList<>();\n             ImmutableList.Builder<Expression> joinFilterBuilder = ImmutableList.builder();\n+            ImmutableList.Builder<ComparisonExpression> dynamicFilteringClauses = ImmutableList.builder();\n             for (Expression conjunct : extractConjuncts(newJoinPredicate)) {\n-                if (joinEqualityExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols())) {\n-                    ComparisonExpression equality = (ComparisonExpression) conjunct;\n-\n-                    boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(equality.getLeft()));\n-                    Expression leftExpression = (alignedComparison) ? equality.getLeft() : equality.getRight();\n-                    Expression rightExpression = (alignedComparison) ? equality.getRight() : equality.getLeft();\n+                final boolean isComparison = joinComparisonExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTcyOA==", "bodyText": "Remove final", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436215728", "createdAt": "2020-06-06T00:32:36Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -470,13 +480,20 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             // Create new projections for the new join clauses\n             List<JoinNode.EquiJoinClause> equiJoinClauses = new ArrayList<>();\n             ImmutableList.Builder<Expression> joinFilterBuilder = ImmutableList.builder();\n+            ImmutableList.Builder<ComparisonExpression> dynamicFilteringClauses = ImmutableList.builder();\n             for (Expression conjunct : extractConjuncts(newJoinPredicate)) {\n-                if (joinEqualityExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols())) {\n-                    ComparisonExpression equality = (ComparisonExpression) conjunct;\n-\n-                    boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(equality.getLeft()));\n-                    Expression leftExpression = (alignedComparison) ? equality.getLeft() : equality.getRight();\n-                    Expression rightExpression = (alignedComparison) ? equality.getRight() : equality.getLeft();\n+                final boolean isComparison = joinComparisonExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols());\n+                if (!isComparison) {\n+                    joinFilterBuilder.add(conjunct);\n+                    continue;\n+                }\n+                ComparisonExpression comparison = (ComparisonExpression) conjunct;\n+                final boolean isEquality = comparison.getOperator() == ComparisonExpression.Operator.EQUAL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 49}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNDU2NjU5", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-493456659", "createdAt": "2020-09-22T13:26:26Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzoyNjoyNlrOHV58dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzoyNjoyNlrOHV58dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjczMTUxMQ==", "bodyText": "nit: opString -> operatorExpressionString", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492731511", "createdAt": "2020-09-22T13:26:26Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -99,12 +107,19 @@ public static boolean isDynamicFilter(Expression expression)\n         }\n \n         List<Expression> arguments = functionCall.getArguments();\n-        checkArgument(arguments.size() == 2, \"invalid arguments count: %s\", arguments.size());\n+        checkArgument(arguments.size() == 3, \"invalid arguments count: %s\", arguments.size());\n+\n+        Expression probeSymbol = arguments.get(0);\n \n-        Expression firstArgument = arguments.get(0);\n-        checkArgument(firstArgument instanceof StringLiteral, \"firstArgument is expected to be an instance of StringLiteral: %s\", firstArgument.getClass().getSimpleName());\n-        String id = ((StringLiteral) firstArgument).getValue();\n-        return Optional.of(new Descriptor(new DynamicFilterId(id), arguments.get(1)));\n+        Expression operatorExpression = arguments.get(1);\n+        checkArgument(operatorExpression instanceof StringLiteral, \"op is expected to be an instance of StringLiteral: %s\", operatorExpression.getClass().getSimpleName());\n+        String opString = ((StringLiteral) operatorExpression).getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNDU4NDIz", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-493458423", "createdAt": "2020-09-22T13:28:08Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzoyODowOFrOHV6Bww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzoyODowOFrOHV6Bww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjczMjg2Nw==", "bodyText": "nit: op -> operatorExpression", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492732867", "createdAt": "2020-09-22T13:28:08Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -99,12 +107,19 @@ public static boolean isDynamicFilter(Expression expression)\n         }\n \n         List<Expression> arguments = functionCall.getArguments();\n-        checkArgument(arguments.size() == 2, \"invalid arguments count: %s\", arguments.size());\n+        checkArgument(arguments.size() == 3, \"invalid arguments count: %s\", arguments.size());\n+\n+        Expression probeSymbol = arguments.get(0);\n \n-        Expression firstArgument = arguments.get(0);\n-        checkArgument(firstArgument instanceof StringLiteral, \"firstArgument is expected to be an instance of StringLiteral: %s\", firstArgument.getClass().getSimpleName());\n-        String id = ((StringLiteral) firstArgument).getValue();\n-        return Optional.of(new Descriptor(new DynamicFilterId(id), arguments.get(1)));\n+        Expression operatorExpression = arguments.get(1);\n+        checkArgument(operatorExpression instanceof StringLiteral, \"op is expected to be an instance of StringLiteral: %s\", operatorExpression.getClass().getSimpleName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNDcwMzE5", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-493470319", "createdAt": "2020-09-22T13:40:12Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzo0MDoxMlrOHV6k0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzo0MDoxMlrOHV6k0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc0MTg0MQ==", "bodyText": "Could this be toImmutableListMultimap  instead ? Are duplicate Descriptor possible here ?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492741841", "createdAt": "2020-09-22T13:40:12Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNDgxNzQ4", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-493481748", "createdAt": "2020-09-22T13:51:20Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzo1MToyMFrOHV7HOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzo1MToyMFrOHV7HOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1MDY1MA==", "bodyText": "Can we ever reach here for a non-orderable type or does the planner disallow queries which contain comparison operator on a non-orderable type ?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492750650", "createdAt": "2020-09-22T13:51:20Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNDg2NDg3", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-493486487", "createdAt": "2020-09-22T13:55:49Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzo1NTo0OVrOHV7VcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMzo1NTo0OVrOHV7VcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1NDI4OQ==", "bodyText": "Do we need to get an ordered range here or can we use  domain.getValues().getRanges().getSpan() , then get low or high value from that ?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492754289", "createdAt": "2020-09-22T13:55:49Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNDkxMTkw", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-493491190", "createdAt": "2020-09-22T14:00:05Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDowMDowNVrOHV7jSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDowMDowNVrOHV7jSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1NzgzMw==", "bodyText": "I think these functions could be moved to Range.java", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492757833", "createdAt": "2020-09-22T14:00:05Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case LESS_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanOrEqualRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanOrEqualRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported dynamic filtering comparison operator: \" + operator);\n+        }\n+    }\n+\n+    private static Range lessThanRange(Marker high)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNDkxOTQy", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-493491942", "createdAt": "2020-09-22T14:00:47Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDowMDo0N1rOHV7ljg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDowMDo0N1rOHV7ljg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1ODQxNA==", "bodyText": "This could move to Domain.java", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492758414", "createdAt": "2020-09-22T14:00:47Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNDk4MDg4", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-493498088", "createdAt": "2020-09-22T14:06:46Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDowNjo0NlrOHV73iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDowNjo0NlrOHV73iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc2MzAxNg==", "bodyText": "Could we simply return domain ?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492763016", "createdAt": "2020-09-22T14:06:46Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTAyOTk4", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-493502998", "createdAt": "2020-09-22T14:11:19Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDoxMToxOVrOHV8FrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDoxMToxOVrOHV8FrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc2NjYzNw==", "bodyText": "Could use Marker.above", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492766637", "createdAt": "2020-09-22T14:11:19Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case LESS_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanOrEqualRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanOrEqualRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported dynamic filtering comparison operator: \" + operator);\n+        }\n+    }\n+\n+    private static Range lessThanRange(Marker high)\n+    {\n+        return new Range(\n+                Marker.lowerUnbounded(high.getType()),\n+                new Marker(high.getType(), high.getValueBlock(), Marker.Bound.BELOW));\n+    }\n+\n+    private static Range lessThanOrEqualRange(Marker high)\n+    {\n+        return new Range(Marker.lowerUnbounded(high.getType()), high);\n+    }\n+\n+    private static Range greaterThanRange(Marker low)\n+    {\n+        return new Range(\n+                new Marker(low.getType(), low.getValueBlock(), Marker.Bound.ABOVE),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 110}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTAzNTQw", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-493503540", "createdAt": "2020-09-22T14:11:50Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDoxMTo1MFrOHV8HRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDoxMTo1MFrOHV8HRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc2NzA0Nw==", "bodyText": "Could use Marker.below", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492767047", "createdAt": "2020-09-22T14:11:50Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case LESS_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanOrEqualRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanOrEqualRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported dynamic filtering comparison operator: \" + operator);\n+        }\n+    }\n+\n+    private static Range lessThanRange(Marker high)\n+    {\n+        return new Range(\n+                Marker.lowerUnbounded(high.getType()),\n+                new Marker(high.getType(), high.getValueBlock(), Marker.Bound.BELOW));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 99}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTA1MTg5", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-493505189", "createdAt": "2020-09-22T14:13:19Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDoxMzoxOVrOHV8L4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNDoxMzoxOVrOHV8L4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc2ODIyNQ==", "bodyText": "Could we use Marker#getValue to get Object and then just reuse the existing functions in Range.java ?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492768225", "createdAt": "2020-09-22T14:13:19Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case LESS_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanOrEqualRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanOrEqualRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported dynamic filtering comparison operator: \" + operator);\n+        }\n+    }\n+\n+    private static Range lessThanRange(Marker high)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 95}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MjE2MTkz", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-497216193", "createdAt": "2020-09-28T06:26:34Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjoyNjozNFrOHYv8Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjoyNjozNFrOHYv8Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxMzMyNw==", "bodyText": "nit: rename to dynamicFilteringSupportedExpressions", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495713327", "createdAt": "2020-09-28T06:26:34Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -99,6 +103,13 @@\n public class PredicatePushDown\n         implements PlanOptimizer\n {\n+    private static final Set<ComparisonExpression.Operator> supportedComparisonOperators = ImmutableSet.of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MjE3MTYw", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-497217160", "createdAt": "2020-09-28T06:28:40Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjoyODo0MVrOHYv_DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjoyODo0MVrOHYv_DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNDA2MA==", "bodyText": "Could you paste an example of what the explain output looks like after this change ?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495714060", "createdAt": "2020-09-28T06:28:41Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/planprinter/PlanPrinter.java", "diffHunk": "@@ -820,14 +820,14 @@ private Void visitScanFilterAndProjectInfo(\n         private String printDynamicFilters(Collection<DynamicFilters.Descriptor> filters)\n         {\n             return filters.stream()\n-                    .map(filter -> filter.getId() + \" -> \" + filter.getInput())\n+                    .map(filter -> filter.getInput() + \" \" + filter.getOperator().getValue() + \" #\" + filter.getId())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MjE4NDgx", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-497218481", "createdAt": "2020-09-28T06:31:24Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozMToyNFrOHYwC3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozMToyNFrOHYwC3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNTAzNg==", "bodyText": "You should be able to match for dynamic filter as well using something like ImmutableMap.of(\"O_COMMENT\", \"L_COMMENT\")", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495715036", "createdAt": "2020-09-28T06:31:24Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -94,6 +94,37 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey < l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY < L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                node(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MjE5NDYz", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-497219463", "createdAt": "2020-09-28T06:33:33Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozMzozM1rOHYwFzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozMzozM1rOHYwFzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNTc5MA==", "bodyText": "Is CAST missing in the query ?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495715790", "createdAt": "2020-09-28T06:33:33Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -94,6 +94,37 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey < l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY < L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                node(\n+                                        FilterNode.class,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))),\n+                                exchange(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")))))));\n+    }\n+\n+    @Test\n+    public void testCrossJoinInequalityDFWithCast()\n+    {\n+        assertPlan(\"SELECT o.comment, l.comment FROM orders o, lineitem l WHERE o.comment < l.comment\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MjIwMzMw", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-497220330", "createdAt": "2020-09-28T06:35:21Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozNToyMVrOHYwIhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozNToyMVrOHYwIhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNjQ4NA==", "bodyText": "We could add the parameter to match dynamic filters as well here", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495716484", "createdAt": "2020-09-28T06:35:21Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -298,7 +298,9 @@ public void testDistinctLimitOverInequalityJoin()\n                                 anyTree(\n                                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n                                                 join(INNER, ImmutableList.of(), Optional.empty(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 3}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MjIwNTIx", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-497220521", "createdAt": "2020-09-28T06:35:47Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozNTo0N1rOHYwJDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozNTo0N1rOHYwJDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNjYyMQ==", "bodyText": "Same as above", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495716621", "createdAt": "2020-09-28T06:35:47Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -341,7 +343,9 @@ public void testInnerInequalityJoinNoEquiJoinConjuncts()\n                 anyTree(\n                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n                                 join(INNER, ImmutableList.of(), Optional.empty(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MjIwNzg0", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-497220784", "createdAt": "2020-09-28T06:36:18Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozNjoxOFrOHYwJ1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNjozNjoxOFrOHYwJ1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNjgyMg==", "bodyText": "Same as above", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495716822", "createdAt": "2020-09-28T06:36:18Z", "author": {"login": "raunaqmorarka"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -369,7 +373,9 @@ public void testLeftConvertedToInnerInequalityJoinNoEquiJoinConjuncts()\n                 anyTree(\n                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n                                 join(INNER, ImmutableList.of(), Optional.empty(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NTA1NzQ4", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-509505748", "createdAt": "2020-10-15T15:28:27Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNToyODoyN1rOHiNmpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNTozNTo0M1rOHiN7uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNjUxNw==", "bodyText": "We should have support for ineq joins in DynamicFilterService too. If it's added in next commit, lets remove this one.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r505636517", "createdAt": "2020-10-15T15:28:27Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -420,7 +420,12 @@ private void collectDynamicFilters(StageId stageId, Optional<Set<DynamicFilterId\n     private static Set<DynamicFilterId> getDynamicFiltersProducedInPlanNode(PlanNode planNode)\n     {\n         if (planNode instanceof JoinNode) {\n-            return ((JoinNode) planNode).getDynamicFilters().keySet();\n+            JoinNode joinNode = (JoinNode) planNode;\n+            if (joinNode.isCrossJoin()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNzc4Nw==", "bodyText": "why we need this?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r505637787", "createdAt": "2020-10-15T15:30:09Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/server/TestDynamicFilterService.java", "diffHunk": "@@ -594,7 +594,7 @@ private static PlanFragment createPlan(DynamicFilterId dynamicFilterId, Partitio\n                         INNER,\n                         filterNode,\n                         remote,\n-                        ImmutableList.of(),\n+                        ImmutableList.of(new JoinNode.EquiJoinClause(symbol, buildSymbol)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNzkwNw==", "bodyText": "why we need this?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r505637907", "createdAt": "2020-10-15T15:30:19Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/execution/scheduler/TestSourcePartitionedScheduler.java", "diffHunk": "@@ -571,7 +571,7 @@ private static StageExecutionPlan createPlan(ConnectorSplitSource splitSource)\n                         INNER,\n                         filterNode,\n                         remote,\n-                        ImmutableList.of(),\n+                        ImmutableList.of(new JoinNode.EquiJoinClause(symbol, buildSymbol)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0MDkzMA==", "bodyText": "please add support to DynamicFilterService too", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r505640930", "createdAt": "2020-10-15T15:34:23Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -20,8 +20,11 @@\n import io.prestosql.spi.connector.ColumnHandle;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0MTkxNQ==", "bodyText": "static import EQUAL", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r505641915", "createdAt": "2020-10-15T15:35:43Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -46,21 +47,28 @@\n {\n     private DynamicFilters() {}\n \n-    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, SymbolReference input)\n+    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, SymbolReference input, ComparisonExpression.Operator operator)\n     {\n-        return createDynamicFilterExpression(metadata, id, inputType, (Expression) input);\n+        return createDynamicFilterExpression(metadata, id, inputType, (Expression) input, operator);\n     }\n \n     @VisibleForTesting\n-    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, Expression input)\n+    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, Expression input, ComparisonExpression.Operator operator)\n     {\n         return new FunctionCallBuilder(metadata)\n                 .setName(QualifiedName.of(Function.NAME))\n-                .addArgument(VarcharType.VARCHAR, new StringLiteral(id.toString()))\n                 .addArgument(inputType, input)\n+                .addArgument(VarcharType.VARCHAR, new StringLiteral(operator.toString()))\n+                .addArgument(VarcharType.VARCHAR, new StringLiteral(id.toString()))\n                 .build();\n     }\n \n+    @VisibleForTesting\n+    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, Expression input)\n+    {\n+        return createDynamicFilterExpression(metadata, id, inputType, input, ComparisonExpression.Operator.EQUAL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNTgxMzE5", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-511581319", "createdAt": "2020-10-19T09:36:07Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwOTozNjowN1rOHkF7Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMTo0OTozMlrOHkKhng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYwNzg5NA==", "bodyText": "Add a comment that it's used in cross join case", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507607894", "createdAt": "2020-10-19T09:36:07Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/operator/JoinUtils.java", "diffHunk": "@@ -67,7 +67,8 @@ public static boolean isBuildSideReplicated(PlanNode node)\n             return PlanNodeSearcher.searchFrom(((JoinNode) node).getRight())\n                     .recurseOnlyWhen(\n                             MorePredicates.<PlanNode>isInstanceOfAny(ProjectNode.class)\n-                                    .or(JoinUtils::isLocalRepartitionExchange))\n+                                    .or(JoinUtils::isLocalRepartitionExchange)\n+                                    .or(JoinUtils::isLocalGatherExchange))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3Njg3NA==", "bodyText": "static static import (if possible)", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507676874", "createdAt": "2020-10-19T11:37:30Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -100,6 +103,13 @@\n public class PredicatePushDown\n         implements PlanOptimizer\n {\n+    private static final Set<ComparisonExpression.Operator> dynamicFilteringSupportedExpressions = ImmutableSet.of(\n+            ComparisonExpression.Operator.EQUAL,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3NzAxNw==", "bodyText": "rename to:\nDYNAMIC_FILTERING_SUPPORTED_EXPRESSIONS", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507677017", "createdAt": "2020-10-19T11:37:46Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -100,6 +103,13 @@\n public class PredicatePushDown\n         implements PlanOptimizer\n {\n+    private static final Set<ComparisonExpression.Operator> dynamicFilteringSupportedExpressions = ImmutableSet.of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4MDkwNg==", "bodyText": "please pass newJoinFilter instead", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507680906", "createdAt": "2020-10-19T11:45:09Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -501,21 +518,30 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n                         rightProjections.put(rightSymbol, rightExpression);\n                     }\n \n-                    equiJoinClauses.add(new JoinNode.EquiJoinClause(leftSymbol, rightSymbol));\n+                    ComparisonExpression.Operator operator = alignedComparison ? comparison.getOperator() : comparison.getOperator().flip();\n+                    ComparisonExpression filter = new ComparisonExpression(operator, leftSymbol.toSymbolReference(), rightSymbol.toSymbolReference());\n+                    dynamicFilteringClauses.add(filter);\n+                    if (isEquality) {\n+                        equiJoinClauses.add(new JoinNode.EquiJoinClause(leftSymbol, rightSymbol));\n+                    }\n+                    else {\n+                        joinFilterBuilder.add(filter);\n+                    }\n                 }\n                 else {\n+                    // Inequality join predicate && dynamic filtering is disabled.\n                     joinFilterBuilder.add(conjunct);\n                 }\n             }\n \n-            DynamicFiltersResult dynamicFiltersResult = createDynamicFilters(node, equiJoinClauses, session, idAllocator);\n+            DynamicFiltersResult dynamicFiltersResult = createDynamicFilters(node, dynamicFilteringClauses.build(), session, idAllocator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4MTE2NA==", "bodyText": "let's encapsulate non-equi DF code in createDynamicFilters method. Then these code changes are not needed", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507681164", "createdAt": "2020-10-19T11:45:39Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -483,13 +493,20 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             // Create new projections for the new join clauses\n             List<JoinNode.EquiJoinClause> equiJoinClauses = new ArrayList<>();\n             ImmutableList.Builder<Expression> joinFilterBuilder = ImmutableList.builder();\n+            ImmutableList.Builder<ComparisonExpression> dynamicFilteringClauses = ImmutableList.builder();\n             for (Expression conjunct : extractConjuncts(newJoinPredicate)) {\n-                if (joinEqualityExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4MjIzMg==", "bodyText": "this requires doc update", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507682232", "createdAt": "2020-10-19T11:47:38Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/planprinter/PlanPrinter.java", "diffHunk": "@@ -820,14 +820,14 @@ private Void visitScanFilterAndProjectInfo(\n         private String printDynamicFilters(Collection<DynamicFilters.Descriptor> filters)\n         {\n             return filters.stream()\n-                    .map(filter -> filter.getId() + \" -> \" + filter.getInput())\n+                    .map(filter -> filter.getInput() + \" \" + filter.getOperator().getValue() + \" #\" + filter.getId())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNDA2MA=="}, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4Mjc5MQ==", "bodyText": "Please extend matcher so that we can match ineq type too", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507682791", "createdAt": "2020-10-19T11:48:45Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -142,6 +142,38 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey < l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY < L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableMap.of(\"O_ORDERKEY\", \"L_ORDERKEY\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4MzIzMA==", "bodyText": "add a test case with non cross join too", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507683230", "createdAt": "2020-10-19T11:49:32Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -142,6 +142,38 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2ODMzNzgz", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-516833783", "createdAt": "2020-10-26T14:28:46Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDoyODo0NlrOHoSKKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTo0MzoyOVrOHoVziQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwMjYwMg==", "bodyText": "* Planner support for dynamic filtering for a given join operation in Presto.\n  Currently inner and right joins with equality join conditions and semi-joins with IN conditions are supported.\n\nthis section needs to be updated", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512002602", "createdAt": "2020-10-26T14:28:46Z", "author": {"login": "sopel39"}, "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -87,7 +87,7 @@ down to the connector in the query plan.\n            \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwNjQ2Nw==", "bodyText": "please extract span to separate variable before switch", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512006467", "createdAt": "2020-10-26T14:33:31Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -197,8 +232,42 @@ public String toString()\n             return toStringHelper(this)\n                     .add(\"id\", id)\n                     .add(\"input\", input)\n+                    .add(\"operator\", operator)\n                     .toString();\n         }\n+\n+        public Domain applyComparison(Domain domain)\n+        {\n+            if (domain.isNone() || domain.isAll()) {\n+                return domain;\n+            }\n+            switch (operator) {\n+                case EQUAL:\n+                    return domain;\n+                case LESS_THAN: {\n+                    Range span = domain.getValues().getRanges().getSpan();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyMTE5Mg==", "bodyText": "static import DynamicFilterPattern", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512021192", "createdAt": "2020-10-26T14:51:43Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -135,12 +143,66 @@ public void testEmptyJoinCriteria()\n                         join(\n                                 INNER,\n                                 ImmutableList.of(),\n-                                ImmutableMap.of(),\n+                                ImmutableList.of(),\n                                 tableScan(\"orders\"),\n                                 exchange(\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey > l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY > L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableList.of(new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", GREATER_THAN, \"L_ORDERKEY\")),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyMzE2OA==", "bodyText": "use that pattern in other added tests too", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512023168", "createdAt": "2020-10-26T14:54:12Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -135,12 +143,66 @@ public void testEmptyJoinCriteria()\n                         join(\n                                 INNER,\n                                 ImmutableList.of(),\n-                                ImmutableMap.of(),\n+                                ImmutableList.of(),\n                                 tableScan(\"orders\"),\n                                 exchange(\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey > l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY > L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableList.of(new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", GREATER_THAN, \"L_ORDERKEY\")),\n+                                node(\n+                                        FilterNode.class,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))),\n+                                exchange(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")))))));\n+    }\n+\n+    @Test\n+    public void testEquiJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey = l.orderkey AND o.totalprice < l.extendedprice\",\n+                anyTree(join(\n+                        INNER,\n+                        ImmutableList.of(equiJoinClause(\"O_ORDERKEY\", \"L_ORDERKEY\")),\n+                        Optional.of(\"O_TOTALPRICE < L_EXTENDEDPRICE\"),\n+                        Optional.of(ImmutableList.of(\n+                                new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", EQUAL, \"L_ORDERKEY\"),\n+                                new PlanMatchPattern.DynamicFilterPattern(\"O_TOTALPRICE\", LESS_THAN, \"L_EXTENDEDPRICE\"))),\n+                        Optional.empty(),\n+                        Optional.empty(),\n+                        project(\n+                                filter(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyNDA4Mw==", "bodyText": "this case is uniteresting. Cast on probe side (not build) is what we want to test", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512024083", "createdAt": "2020-10-26T14:55:22Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -135,12 +143,66 @@ public void testEmptyJoinCriteria()\n                         join(\n                                 INNER,\n                                 ImmutableList.of(),\n-                                ImmutableMap.of(),\n+                                ImmutableList.of(),\n                                 tableScan(\"orders\"),\n                                 exchange(\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey > l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY > L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableList.of(new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", GREATER_THAN, \"L_ORDERKEY\")),\n+                                node(\n+                                        FilterNode.class,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))),\n+                                exchange(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")))))));\n+    }\n+\n+    @Test\n+    public void testEquiJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey = l.orderkey AND o.totalprice < l.extendedprice\",\n+                anyTree(join(\n+                        INNER,\n+                        ImmutableList.of(equiJoinClause(\"O_ORDERKEY\", \"L_ORDERKEY\")),\n+                        Optional.of(\"O_TOTALPRICE < L_EXTENDEDPRICE\"),\n+                        Optional.of(ImmutableList.of(\n+                                new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", EQUAL, \"L_ORDERKEY\"),\n+                                new PlanMatchPattern.DynamicFilterPattern(\"O_TOTALPRICE\", LESS_THAN, \"L_EXTENDEDPRICE\"))),\n+                        Optional.empty(),\n+                        Optional.empty(),\n+                        project(\n+                                filter(\n+                                        TRUE_LITERAL,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\", \"O_TOTALPRICE\", \"totalprice\")))),\n+                        exchange(\n+                                project(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\", \"L_EXTENDEDPRICE\", \"extendedprice\")))))));\n+    }\n+\n+    @Test\n+    public void testCrossJoinInequalityDFWithCast()\n+    {\n+        assertPlan(\"SELECT o.comment, l.comment FROM orders o, lineitem l WHERE o.comment < l.comment\",\n+                anyTree(filter(\"O_COMMENT < EXPR\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                node(\n+                                        FilterNode.class,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_COMMENT\", \"comment\"))),\n+                                exchange(\n+                                        project(ImmutableMap.of(\"EXPR\", expression(\"CAST(L_COMMENT AS varchar(79))\")),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyNTIyNw==", "bodyText": "please keep previous simplified method too", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512025227", "createdAt": "2020-10-26T14:56:44Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/PlanMatchPattern.java", "diffHunk": "@@ -462,10 +463,37 @@ public static PlanMatchPattern join(\n         return join(joinType, expectedEquiCriteria, expectedFilter, Optional.empty(), expectedDistributionType, expectedSpillable, left, right);\n     }\n \n+    public static class DynamicFilterPattern\n+    {\n+        private final SymbolAlias probe;\n+        private final ComparisonExpression.Operator operator;\n+        private final SymbolAlias build;\n+\n+        public DynamicFilterPattern(String probeAlias, ComparisonExpression.Operator operator, String buildAlias)\n+        {\n+            this.probe = new SymbolAlias(requireNonNull(probeAlias, \"probeAlias is null\"));\n+            this.operator = requireNonNull(operator, \"operator is null\");\n+            this.build = new SymbolAlias(requireNonNull(buildAlias, \"buildAlias is null\"));\n+        }\n+\n+        public ComparisonExpression getComparisonExpression(SymbolAliases aliases)\n+        {\n+            return new ComparisonExpression(\n+                    operator,\n+                    probe.toSymbol(aliases).toSymbolReference(),\n+                    build.toSymbol(aliases).toSymbolReference());\n+        }\n+    }\n+\n+    public static DynamicFilterPattern equiDynamicFilter(String probeAlias, String buildAlias)\n+    {\n+        return new DynamicFilterPattern(probeAlias, ComparisonExpression.Operator.EQUAL, buildAlias);\n+    }\n+\n     public static PlanMatchPattern join(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyNTk1OA==", "bodyText": "move class below usage (above GroupingSetDescriptor)", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512025958", "createdAt": "2020-10-26T14:57:42Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/PlanMatchPattern.java", "diffHunk": "@@ -462,10 +463,37 @@ public static PlanMatchPattern join(\n         return join(joinType, expectedEquiCriteria, expectedFilter, Optional.empty(), expectedDistributionType, expectedSpillable, left, right);\n     }\n \n+    public static class DynamicFilterPattern", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzMzMxMQ==", "bodyText": "make it package private", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512033311", "createdAt": "2020-10-26T15:06:49Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/PlanMatchPattern.java", "diffHunk": "@@ -462,10 +463,37 @@ public static PlanMatchPattern join(\n         return join(joinType, expectedEquiCriteria, expectedFilter, Optional.empty(), expectedDistributionType, expectedSpillable, left, right);\n     }\n \n+    public static class DynamicFilterPattern\n+    {\n+        private final SymbolAlias probe;\n+        private final ComparisonExpression.Operator operator;\n+        private final SymbolAlias build;\n+\n+        public DynamicFilterPattern(String probeAlias, ComparisonExpression.Operator operator, String buildAlias)\n+        {\n+            this.probe = new SymbolAlias(requireNonNull(probeAlias, \"probeAlias is null\"));\n+            this.operator = requireNonNull(operator, \"operator is null\");\n+            this.build = new SymbolAlias(requireNonNull(buildAlias, \"buildAlias is null\"));\n+        }\n+\n+        public ComparisonExpression getComparisonExpression(SymbolAliases aliases)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzNDczMw==", "bodyText": "please keep previous join constructor too, this would prevent all these (unrelated) changes", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512034733", "createdAt": "2020-10-26T15:08:37Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -347,7 +415,7 @@ public void testNestedDynamicFiltersRemoval()\n                         join(\n                                 INNER,\n                                 ImmutableList.of(equiJoinClause(\"ORDERS_CK\", \"ORDERS_CK6\")),\n-                                ImmutableMap.of(\"ORDERS_CK\", \"ORDERS_CK6\"),\n+                                ImmutableList.of(equiDynamicFilter(\"ORDERS_CK\", \"ORDERS_CK6\")),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzNTAyOQ==", "bodyText": "static import GREATER_THAN and others", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512035029", "createdAt": "2020-10-26T15:09:01Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "diffHunk": "@@ -182,6 +185,44 @@ public void testMultipleProbeColumns()\n         assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(column1, domain, column2, domain)));\n     }\n \n+    @Test\n+    public void testMultipleComparisons()\n+    {\n+        LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector(metadata, typeOperators, session);\n+        DynamicFilterId filterId = new DynamicFilterId(\"filter\");\n+        collector.register(ImmutableSet.of(filterId));\n+        SymbolAllocator symbolAllocator = new SymbolAllocator();\n+\n+        // Same build-side column being compared to multiple probe-side columns.\n+        Symbol symbol1 = symbolAllocator.newSymbol(\"symbol1\", BIGINT);\n+        Symbol symbol2 = symbolAllocator.newSymbol(\"symbol2\", BIGINT);\n+        ColumnHandle column1 = new TestingColumnHandle(\"column1\");\n+        ColumnHandle column2 = new TestingColumnHandle(\"column2\");\n+        DynamicFilter filter = collector.createDynamicFilter(\n+                ImmutableList.of(\n+                        new DynamicFilters.Descriptor(filterId, symbol1.toSymbolReference(), Operator.GREATER_THAN),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzOTk3NA==", "bodyText": "static import DynamicFilterPattern", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512039974", "createdAt": "2020-10-26T15:15:12Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -298,8 +300,16 @@ public void testDistinctLimitOverInequalityJoin()\n                         node(DistinctLimitNode.class,\n                                 anyTree(\n                                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n-                                                join(INNER, ImmutableList.of(), Optional.empty(),\n-                                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\")),\n+                                                join(INNER,\n+                                                        ImmutableList.of(),\n+                                                        Optional.empty(),\n+                                                        Optional.of(ImmutableList.of(\n+                                                                new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", LESS_THAN, \"L_ORDERKEY\"))),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0MTA2OA==", "bodyText": "nit: static import EQUAL", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512041068", "createdAt": "2020-10-26T15:16:39Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/PlanMatchPattern.java", "diffHunk": "@@ -462,10 +463,37 @@ public static PlanMatchPattern join(\n         return join(joinType, expectedEquiCriteria, expectedFilter, Optional.empty(), expectedDistributionType, expectedSpillable, left, right);\n     }\n \n+    public static class DynamicFilterPattern\n+    {\n+        private final SymbolAlias probe;\n+        private final ComparisonExpression.Operator operator;\n+        private final SymbolAlias build;\n+\n+        public DynamicFilterPattern(String probeAlias, ComparisonExpression.Operator operator, String buildAlias)\n+        {\n+            this.probe = new SymbolAlias(requireNonNull(probeAlias, \"probeAlias is null\"));\n+            this.operator = requireNonNull(operator, \"operator is null\");\n+            this.build = new SymbolAlias(requireNonNull(buildAlias, \"buildAlias is null\"));\n+        }\n+\n+        public ComparisonExpression getComparisonExpression(SymbolAliases aliases)\n+        {\n+            return new ComparisonExpression(\n+                    operator,\n+                    probe.toSymbol(aliases).toSymbolReference(),\n+                    build.toSymbol(aliases).toSymbolReference());\n+        }\n+    }\n+\n+    public static DynamicFilterPattern equiDynamicFilter(String probeAlias, String buildAlias)\n+    {\n+        return new DynamicFilterPattern(probeAlias, ComparisonExpression.Operator.EQUAL, buildAlias);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0MTU5NA==", "bodyText": "I think you can use join without these two Optional.empty() args", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512041594", "createdAt": "2020-10-26T15:17:22Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -298,8 +300,16 @@ public void testDistinctLimitOverInequalityJoin()\n                         node(DistinctLimitNode.class,\n                                 anyTree(\n                                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n-                                                join(INNER, ImmutableList.of(), Optional.empty(),\n-                                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\")),\n+                                                join(INNER,\n+                                                        ImmutableList.of(),\n+                                                        Optional.empty(),\n+                                                        Optional.of(ImmutableList.of(\n+                                                                new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", LESS_THAN, \"L_ORDERKEY\"))),\n+                                                        Optional.empty(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0MjMwNw==", "bodyText": "keep node(FilterNode.class, in same line, e.g:\nnode(FilterNode.class,\n  tableScal(\"orders\")\n...\n\nwe decided to use this schema for plan matching as it's easier to read.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512042307", "createdAt": "2020-10-26T15:18:15Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -370,7 +392,9 @@ public void testLeftConvertedToInnerInequalityJoinNoEquiJoinConjuncts()\n                 anyTree(\n                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n                                 join(INNER, ImmutableList.of(), Optional.empty(),\n-                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\")),\n+                                        node(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0MzkyMw==", "bodyText": "keep this simplified method too", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512043923", "createdAt": "2020-10-26T15:20:11Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -1133,12 +1218,12 @@ private Object nullInputEvaluator(Collection<Symbol> nullSymbols, Expression exp\n                     .optimize(symbol -> nullSymbols.contains(symbol) ? null : symbol.toSymbolReference());\n         }\n \n-        private boolean joinEqualityExpression(Expression expression, Collection<Symbol> leftSymbols, Collection<Symbol> rightSymbols)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0NTYzMA==", "bodyText": "getJoinFilterClauses is not needed. We should always add joinFilterBuilder.build() expressions (regardless of DF).", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512045630", "createdAt": "2020-10-26T15:22:24Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -524,7 +540,7 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n                 rightSource = context.rewrite(node.getRight(), rightPredicate);\n             }\n \n-            Optional<Expression> newJoinFilter = Optional.of(combineConjuncts(metadata, joinFilterBuilder.build()));\n+            Optional<Expression> newJoinFilter = Optional.of(combineConjuncts(metadata, dynamicFiltersResult.getJoinFilterClauses()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0NjM3OA==", "bodyText": "rename to DYNAMIC_FILTERING_SUPPORTED_COMPARISONS", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512046378", "createdAt": "2020-10-26T15:23:24Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -95,11 +99,23 @@\n import static io.prestosql.sql.planner.plan.JoinNode.Type.LEFT;\n import static io.prestosql.sql.planner.plan.JoinNode.Type.RIGHT;\n import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.EQUAL;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.GREATER_THAN;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.GREATER_THAN_OR_EQUAL;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.LESS_THAN;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.LESS_THAN_OR_EQUAL;\n import static java.util.Objects.requireNonNull;\n \n public class PredicatePushDown\n         implements PlanOptimizer\n {\n+    private static final Set<ComparisonExpression.Operator> DYNAMIC_FILTERING_SUPPORTED_OPERATORS = ImmutableSet.of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0NzI1Mg==", "bodyText": "static import extractUnique", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512047252", "createdAt": "2020-10-26T15:24:28Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -579,42 +595,101 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Assignments.Builder leftProjections,\n+                Assignments.Builder rightProjections,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n-                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n-            }\n+                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of(), joinFilterClauses, false);\n+            }\n+\n+            AtomicBoolean newProjectionAdded = new AtomicBoolean(false);\n+            ImmutableList.Builder<ComparisonExpression> comparisonClausesBuilder = ImmutableList.builder();\n+            equiJoinClauses\n+                    .stream()\n+                    .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference()))\n+                    .forEach(comparisonClausesBuilder::add);\n+            joinFilterClauses = joinFilterClauses.stream()\n+                    .map(clause -> {\n+                        if (!isJoinComparison(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_OPERATORS)) {\n+                            return clause;\n+                        }\n+                        ComparisonExpression comparison = (ComparisonExpression) clause;\n+                        boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(comparison.getLeft()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1NDc1NQ==", "bodyText": "ok, so this actually adds new symbols... but DF won't work for l1 + 10 anyway, so we can only support cases where left side consist of single symbol", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512054755", "createdAt": "2020-10-26T15:33:46Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -579,42 +595,101 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Assignments.Builder leftProjections,\n+                Assignments.Builder rightProjections,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n-                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n-            }\n+                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of(), joinFilterClauses, false);\n+            }\n+\n+            AtomicBoolean newProjectionAdded = new AtomicBoolean(false);\n+            ImmutableList.Builder<ComparisonExpression> comparisonClausesBuilder = ImmutableList.builder();\n+            equiJoinClauses\n+                    .stream()\n+                    .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference()))\n+                    .forEach(comparisonClausesBuilder::add);\n+            joinFilterClauses = joinFilterClauses.stream()\n+                    .map(clause -> {\n+                        if (!isJoinComparison(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_OPERATORS)) {\n+                            return clause;\n+                        }\n+                        ComparisonExpression comparison = (ComparisonExpression) clause;\n+                        boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(comparison.getLeft()));\n+                        Expression leftExpression = (alignedComparison) ? comparison.getLeft() : comparison.getRight();\n+                        Expression rightExpression = (alignedComparison) ? comparison.getRight() : comparison.getLeft();\n+                        ComparisonExpression.Operator operator = alignedComparison ? comparison.getOperator() : comparison.getOperator().flip();\n+\n+                        Symbol leftSymbol = symbolForExpression(leftExpression);\n+                        if (!node.getLeft().getOutputSymbols().contains(leftSymbol)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA2MjM0NQ==", "bodyText": "so this actually can affect join performance when DF are not effective, e.g a new symbol l2=l1+10 might be send over the network and stored in build side (even though l1 is already send). I would rather avoid that. Let's assume that right side is single symbol. We could also add a support in DynamicFilterSourceOperator for basic expressions, e.g l1+10 later", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512062345", "createdAt": "2020-10-26T15:43:29Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -579,42 +595,101 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Assignments.Builder leftProjections,\n+                Assignments.Builder rightProjections,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n-                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n-            }\n+                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of(), joinFilterClauses, false);\n+            }\n+\n+            AtomicBoolean newProjectionAdded = new AtomicBoolean(false);\n+            ImmutableList.Builder<ComparisonExpression> comparisonClausesBuilder = ImmutableList.builder();\n+            equiJoinClauses\n+                    .stream()\n+                    .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference()))\n+                    .forEach(comparisonClausesBuilder::add);\n+            joinFilterClauses = joinFilterClauses.stream()\n+                    .map(clause -> {\n+                        if (!isJoinComparison(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_OPERATORS)) {\n+                            return clause;\n+                        }\n+                        ComparisonExpression comparison = (ComparisonExpression) clause;\n+                        boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(comparison.getLeft()));\n+                        Expression leftExpression = (alignedComparison) ? comparison.getLeft() : comparison.getRight();\n+                        Expression rightExpression = (alignedComparison) ? comparison.getRight() : comparison.getLeft();\n+                        ComparisonExpression.Operator operator = alignedComparison ? comparison.getOperator() : comparison.getOperator().flip();\n+\n+                        Symbol leftSymbol = symbolForExpression(leftExpression);\n+                        if (!node.getLeft().getOutputSymbols().contains(leftSymbol)) {\n+                            leftProjections.put(leftSymbol, leftExpression);\n+                            newProjectionAdded.set(true);\n+                        }\n+\n+                        Symbol rightSymbol = symbolForExpression(rightExpression);\n+                        if (!node.getRight().getOutputSymbols().contains(rightSymbol)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 127}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "c90421ad83858768e9a899599329620e8f3b9081", "author": {"user": {"login": "rzeyde-varada", "name": "Roman Z"}}, "url": "https://github.com/trinodb/trino/commit/c90421ad83858768e9a899599329620e8f3b9081", "committedDate": "2020-10-28T20:02:21Z", "message": "Use static import for SymbolsExtractor.extractUnique"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5Njg5MzQx", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-519689341", "createdAt": "2020-10-29T13:55:20Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMzo1NToyMVrOHqc9nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNDowMTo0MVrOHqdP0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI3Njc2NQ==", "bodyText": "use toImmutableSet", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r514276765", "createdAt": "2020-10-29T13:55:21Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -580,31 +597,67 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n                 return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n             }\n \n+            List<ComparisonExpression> clauses = Streams.concat(\n+                    equiJoinClauses\n+                            .stream()\n+                            .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference())),\n+                    joinFilterClauses.stream()\n+                            .filter(clause -> joinComparisonExpression(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_COMPARISONS))\n+                            .map(ComparisonExpression.class::cast)\n+                            .filter(comparison -> comparison.getLeft() instanceof SymbolReference && comparison.getRight() instanceof SymbolReference)\n+                            .map(comparison -> {\n+                                Symbol leftSymbol = Symbol.from(comparison.getLeft());\n+                                Symbol rightSymbol = Symbol.from(comparison.getRight());\n+                                boolean alignedComparison = node.getLeft().getOutputSymbols().contains(leftSymbol);\n+                                return new ComparisonExpression(\n+                                        alignedComparison ? comparison.getOperator() : comparison.getOperator().flip(),\n+                                        (alignedComparison ? leftSymbol : rightSymbol).toSymbolReference(),\n+                                        (alignedComparison ? rightSymbol : leftSymbol).toSymbolReference());\n+                            }))\n+                    .collect(toImmutableList());\n+\n             // New equiJoinClauses could potentially not contain symbols used in current dynamic filters.\n             // Since we use PredicatePushdown to push dynamic filters themselves,\n             // instead of separate ApplyDynamicFilters rule we derive dynamic filters within PredicatePushdown itself.\n             // Even if equiJoinClauses.equals(node.getCriteria), current dynamic filters may not match equiJoinClauses\n-            ImmutableMap.Builder<DynamicFilterId, Symbol> dynamicFiltersBuilder = ImmutableMap.builder();\n-            ImmutableList.Builder<Expression> predicatesBuilder = ImmutableList.builder();\n-            // reuse existing dynamic filters to make planning more stable\n-            Map<Symbol, DynamicFilterId> buildSymbolToDynamicFilter = new HashMap<>(node.getDynamicFilters().entrySet().stream()\n-                    .collect(toImmutableMap(Map.Entry::getValue, Map.Entry::getKey)));\n-            for (JoinNode.EquiJoinClause clause : equiJoinClauses) {\n-                Symbol probeSymbol = clause.getLeft();\n-                Symbol buildSymbol = clause.getRight();\n-                DynamicFilterId id = buildSymbolToDynamicFilter.computeIfAbsent(\n+\n+            // Collect build symbols:\n+            Set<Symbol> buildSymbols = clauses.stream()\n+                    .map(ComparisonExpression::getRight)\n+                    .map(Symbol::from)\n+                    .collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI4MTQyNg==", "bodyText": "make a defensive copy of buildSymbolToDynamicFilter in DynamicFiltersResult", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r514281426", "createdAt": "2020-10-29T14:01:41Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -580,31 +597,67 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n                 return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n             }\n \n+            List<ComparisonExpression> clauses = Streams.concat(\n+                    equiJoinClauses\n+                            .stream()\n+                            .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference())),\n+                    joinFilterClauses.stream()\n+                            .filter(clause -> joinComparisonExpression(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_COMPARISONS))\n+                            .map(ComparisonExpression.class::cast)\n+                            .filter(comparison -> comparison.getLeft() instanceof SymbolReference && comparison.getRight() instanceof SymbolReference)\n+                            .map(comparison -> {\n+                                Symbol leftSymbol = Symbol.from(comparison.getLeft());\n+                                Symbol rightSymbol = Symbol.from(comparison.getRight());\n+                                boolean alignedComparison = node.getLeft().getOutputSymbols().contains(leftSymbol);\n+                                return new ComparisonExpression(\n+                                        alignedComparison ? comparison.getOperator() : comparison.getOperator().flip(),\n+                                        (alignedComparison ? leftSymbol : rightSymbol).toSymbolReference(),\n+                                        (alignedComparison ? rightSymbol : leftSymbol).toSymbolReference());\n+                            }))\n+                    .collect(toImmutableList());\n+\n             // New equiJoinClauses could potentially not contain symbols used in current dynamic filters.\n             // Since we use PredicatePushdown to push dynamic filters themselves,\n             // instead of separate ApplyDynamicFilters rule we derive dynamic filters within PredicatePushdown itself.\n             // Even if equiJoinClauses.equals(node.getCriteria), current dynamic filters may not match equiJoinClauses\n-            ImmutableMap.Builder<DynamicFilterId, Symbol> dynamicFiltersBuilder = ImmutableMap.builder();\n-            ImmutableList.Builder<Expression> predicatesBuilder = ImmutableList.builder();\n-            // reuse existing dynamic filters to make planning more stable\n-            Map<Symbol, DynamicFilterId> buildSymbolToDynamicFilter = new HashMap<>(node.getDynamicFilters().entrySet().stream()\n-                    .collect(toImmutableMap(Map.Entry::getValue, Map.Entry::getKey)));\n-            for (JoinNode.EquiJoinClause clause : equiJoinClauses) {\n-                Symbol probeSymbol = clause.getLeft();\n-                Symbol buildSymbol = clause.getRight();\n-                DynamicFilterId id = buildSymbolToDynamicFilter.computeIfAbsent(\n+\n+            // Collect build symbols:\n+            Set<Symbol> buildSymbols = clauses.stream()\n+                    .map(ComparisonExpression::getRight)\n+                    .map(Symbol::from)\n+                    .collect(Collectors.toSet());\n+\n+            // Allocate new dynamic filter IDs for for each build symbol:\n+            BiMap<Symbol, DynamicFilterId> buildSymbolToDynamicFilter = HashBiMap.create(node.getDynamicFilters()).inverse();\n+            for (Symbol buildSymbol : buildSymbols) {\n+                buildSymbolToDynamicFilter.computeIfAbsent(\n                         buildSymbol,\n                         key -> new DynamicFilterId(\"df_\" + idAllocator.getNextId().toString()));\n-                predicatesBuilder.add(createDynamicFilterExpression(metadata, id, symbolAllocator.getTypes().get(probeSymbol), probeSymbol.toSymbolReference()));\n-                dynamicFiltersBuilder.put(id, buildSymbol);\n             }\n-            return new DynamicFiltersResult(dynamicFiltersBuilder.build(), predicatesBuilder.build());\n+\n+            // Multiple probe symbols may depend on a single build symbol / dynamic filter ID:\n+            List<Expression> predicates = clauses\n+                    .stream()\n+                    .map(clause -> {\n+                        Symbol probeSymbol = Symbol.from(clause.getLeft());\n+                        Symbol buildSymbol = Symbol.from(clause.getRight());\n+                        Type type = symbolAllocator.getTypes().get(probeSymbol);\n+                        DynamicFilterId id = requireNonNull(buildSymbolToDynamicFilter.get(buildSymbol), () -> \"missing dynamic filter for symbol \" + buildSymbol);\n+                        return createDynamicFilterExpression(metadata, id, type, probeSymbol.toSymbolReference(), clause.getOperator());\n+                    })\n+                    .collect(toImmutableList());\n+            // Return a mapping from build symbols to corresponding dynamic filter IDs:\n+            return new DynamicFiltersResult(buildSymbolToDynamicFilter.inverse(), predicates);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 142}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMDg0NDQw", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-520084440", "createdAt": "2020-10-29T21:03:16Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMTowMzoxNlrOHqukHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMTowMzoxNlrOHqukHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU2NTE1MQ==", "bodyText": "please also add support for between predicate (+ tests), you can rewrite between into two comparisons", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r514565151", "createdAt": "2020-10-29T21:03:16Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -580,31 +598,67 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n                 return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n             }\n \n+            List<ComparisonExpression> clauses = Streams.concat(\n+                    equiJoinClauses\n+                            .stream()\n+                            .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference())),\n+                    joinFilterClauses.stream()\n+                            .filter(clause -> joinComparisonExpression(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_COMPARISONS))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNTUyMzU4", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-520552358", "createdAt": "2020-10-30T10:44:50Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMDo0NDo1MVrOHrJrRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMTowMDo0M1rOHrKJsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAwOTM0OQ==", "bodyText": "please add two TODOs and corresponding issues in Prestosql:\n\ncollect min/max ranges for ineqaulity dynamic filters\nsupport for complex inequalities, e.g left < right + 10", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515009349", "createdAt": "2020-10-30T10:44:51Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -580,31 +598,67 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxMDU1Mw==", "bodyText": "actually, this seems redundant to testInnerInequalityJoinWithEquiJoinConjuncts. Please remove this one, sorry", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515010553", "createdAt": "2020-10-30T10:47:17Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -141,6 +148,66 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey > l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY > L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableList.of(new DynamicFilterPattern(\"O_ORDERKEY\", GREATER_THAN, \"L_ORDERKEY\")),\n+                                filter(\n+                                        TRUE_LITERAL,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))),\n+                                exchange(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")))))));\n+    }\n+\n+    @Test\n+    public void testEquiJoinInequalityDF()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxMzYyMA==", "bodyText": "please use just one column handle. Let's make sure that range gets clamped.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515013620", "createdAt": "2020-10-30T10:53:36Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "diffHunk": "@@ -182,6 +186,44 @@ public void testMultipleProbeColumns()\n         assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(column1, domain, column2, domain)));\n     }\n \n+    @Test\n+    public void testMultipleComparisons()\n+    {\n+        LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector(metadata, typeOperators, session);\n+        DynamicFilterId filterId = new DynamicFilterId(\"filter\");\n+        collector.register(ImmutableSet.of(filterId));\n+        SymbolAllocator symbolAllocator = new SymbolAllocator();\n+\n+        // Same build-side column being compared to multiple probe-side columns.\n+        Symbol symbol1 = symbolAllocator.newSymbol(\"symbol1\", BIGINT);\n+        Symbol symbol2 = symbolAllocator.newSymbol(\"symbol2\", BIGINT);\n+        ColumnHandle column1 = new TestingColumnHandle(\"column1\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxMzc3OQ==", "bodyText": "Please use filter(TRUE_PREDICATE here and in other cases.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515013779", "createdAt": "2020-10-30T10:53:57Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -298,8 +301,11 @@ public void testDistinctLimitOverInequalityJoin()\n                         node(DistinctLimitNode.class,\n                                 anyTree(\n                                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n-                                                join(INNER, ImmutableList.of(), Optional.empty(),\n-                                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\")),\n+                                                join(INNER,\n+                                                        ImmutableList.of(),\n+                                                        ImmutableList.of(new DynamicFilterPattern(\"O_ORDERKEY\", LESS_THAN, \"L_ORDERKEY\")),\n+                                                        node(FilterNode.class,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNDIxOA==", "bodyText": "can we use pattern without these two empty params?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515014218", "createdAt": "2020-10-30T10:54:45Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -341,8 +347,14 @@ public void testInnerInequalityJoinNoEquiJoinConjuncts()\n         assertPlan(\"SELECT 1 FROM orders o JOIN lineitem l ON o.orderkey < l.orderkey\",\n                 anyTree(\n                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n-                                join(INNER, ImmutableList.of(), Optional.empty(),\n-                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\")),\n+                                join(INNER,\n+                                        ImmutableList.of(),\n+                                        Optional.empty(),\n+                                        Optional.of(ImmutableList.of(new DynamicFilterPattern(\"O_ORDERKEY\", LESS_THAN, \"L_ORDERKEY\"))),\n+                                        Optional.empty(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNDQ3MQ==", "bodyText": "match filter here too", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515014471", "createdAt": "2020-10-30T10:55:15Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -355,6 +367,11 @@ public void testInnerInequalityJoinWithEquiJoinConjuncts()\n                                 join(INNER,\n                                         ImmutableList.of(equiJoinClause(\"O_SHIPPRIORITY\", \"L_LINENUMBER\")),\n                                         Optional.of(\"O_ORDERKEY < L_ORDERKEY\"),\n+                                        Optional.of(ImmutableList.of(\n+                                                new DynamicFilterPattern(\"O_SHIPPRIORITY\", EQUAL, \"L_LINENUMBER\"),\n+                                                new DynamicFilterPattern(\"O_ORDERKEY\", LESS_THAN, \"L_ORDERKEY\"))),\n+                                        Optional.empty(),\n+                                        Optional.empty(),\n                                         anyTree(tableScan(\"orders\", ImmutableMap.of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNTM0MA==", "bodyText": "remove // FIXUP", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515015340", "createdAt": "2020-10-30T10:56:59Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/JoinMatcher.java", "diffHunk": "@@ -173,8 +178,7 @@ public String toString()\n                 .add(\"equiCriteria\", equiCriteria)\n                 .add(\"filter\", filter.orElse(null))\n                 .add(\"distributionType\", distributionType)\n-                .add(\"dynamicFilter\", expectedDynamicFilterAliases.map(aliases -> aliases.values().stream()\n-                        .collect(toImmutableMap(rightSymbol -> rightSymbol.toString() + \"_alias\", SymbolAlias::toString))))\n+                .add(\"dynamicFilter\", expectedDynamicFilter)  // FIXUP", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNjY0OA==", "bodyText": "Why does orders.orderkey + 1 work? There is orderkey + 1 expression here, so it shouldn't work", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515016648", "createdAt": "2020-10-30T10:59:45Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +263,81 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        // \"<\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey < orders.orderkey + 1 AND \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNzEzNg==", "bodyText": "Could we choose range (or remove comment predicate) so that number of results is less than 6 when clamped (too show that both comparisons are effective)\nlineitem.orderkey <= orders.orderkey alone ensures 6 rows", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515017136", "createdAt": "2020-10-30T11:00:43Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +263,81 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        // \"<\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey < orders.orderkey + 1 AND \" +\n+                            \"orders.comment = 'nstructions sleep furiously among '\",\n+                    withBroadcastJoin(),\n+                    6,\n+                    ImmutableSet.of(6, ORDERS_COUNT));\n+        }\n+        // \"<=\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey <= orders.orderkey AND \" +\n+                            \"orders.comment = 'nstructions sleep furiously among '\",\n+                    withBroadcastJoin(),\n+                    6,\n+                    ImmutableSet.of(6, ORDERS_COUNT));\n+        }\n+        // \"<=\" and \">\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey <= orders.orderkey AND \" +\n+                            \"lineitem.orderkey > orders.orderkey - 1 AND \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxNTUyNzEy", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-521552712", "createdAt": "2020-11-02T11:37:22Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMTozNzoyMlrOHsA3pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMTo0MTozMFrOHsA_Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxMzYzOQ==", "bodyText": "add links to the issues in code", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515913639", "createdAt": "2020-11-02T11:37:22Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -580,31 +598,67 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAwOTM0OQ=="}, "originalCommit": null, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNDQ0Mw==", "bodyText": "nit: reverse sides in O_COMMENT < CAST(L_COMMENT AS varchar(79)) to match join order", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515914443", "createdAt": "2020-11-02T11:39:13Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -141,6 +148,44 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey > l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY > L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableList.of(new DynamicFilterPattern(\"O_ORDERKEY\", GREATER_THAN, \"L_ORDERKEY\")),\n+                                filter(\n+                                        TRUE_LITERAL,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))),\n+                                exchange(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")))))));\n+    }\n+\n+    @Test\n+    public void testCrossJoinInequalityNoDFWithCast()\n+    {\n+        assertPlan(\"SELECT o.comment, l.comment FROM lineitem l, orders o WHERE o.comment < l.comment\",\n+                anyTree(filter(\"O_COMMENT < CAST(L_COMMENT AS varchar(79))\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNTEwNA==", "bodyText": "let's use pattern with Optional.empty() here", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515915104", "createdAt": "2020-11-02T11:40:35Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -355,9 +365,16 @@ public void testInnerInequalityJoinWithEquiJoinConjuncts()\n                                 join(INNER,\n                                         ImmutableList.of(equiJoinClause(\"O_SHIPPRIORITY\", \"L_LINENUMBER\")),\n                                         Optional.of(\"O_ORDERKEY < L_ORDERKEY\"),\n-                                        anyTree(tableScan(\"orders\", ImmutableMap.of(\n-                                                \"O_SHIPPRIORITY\", \"shippriority\",\n-                                                \"O_ORDERKEY\", \"orderkey\"))),\n+                                        Optional.of(ImmutableList.of(\n+                                                new DynamicFilterPattern(\"O_SHIPPRIORITY\", EQUAL, \"L_LINENUMBER\"),\n+                                                new DynamicFilterPattern(\"O_ORDERKEY\", LESS_THAN, \"L_ORDERKEY\"))),\n+                                        Optional.empty(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNTU4Nw==", "bodyText": "add a test case for between here too", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515915587", "createdAt": "2020-11-02T11:41:30Z", "author": {"login": "sopel39"}, "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -141,6 +148,44 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxNTczMjcz", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-521573273", "createdAt": "2020-11-02T12:09:57Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMjowOTo1N1rOHsB1Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMjowOTo1N1rOHsB1Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkyOTM1MQ==", "bodyText": "please add a test cases:\nSELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax + 1\nSELECT * FROM probe JOIN build ON v >= vmin AND v <= vmax +1\nSELECT * FROM probe JOIN build WHERE >= vmin AND v <= vmax + 1\nSELECT * FROM probe WHERE v <= (SELECT max(vmax) FROM build)", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515929351", "createdAt": "2020-11-02T12:09:57Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +264,36 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        assertUpdate(\"CREATE TABLE probe (k VARCHAR, v INTEGER)\");\n+        assertUpdate(\"CREATE TABLE build (vmin INTEGER, vmax INTEGER)\");\n+        assertUpdate(\"INSERT INTO probe VALUES ('a', 0), ('b', 1), ('c', 2), ('d', 3)\", 4);\n+        assertUpdate(\"INSERT INTO build VALUES (1, 2)\", 1);\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v <= vmax\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v < vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v < vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v <= vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v < vmax\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND vmax < 0\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v <= vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMzM1Mjk4", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-522335298", "createdAt": "2020-11-03T09:55:09Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwOTo1NToxMFrOHsnTLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMDo0NDo0OFrOHspLIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU0MzI3OA==", "bodyText": "static import", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516543278", "createdAt": "2020-11-03T09:55:10Z", "author": {"login": "sopel39"}, "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -154,11 +176,18 @@ public ExtractResult(List<Expression> staticConjuncts, List<Descriptor> dynamicC\n     {\n         private final DynamicFilterId id;\n         private final Expression input;\n+        private final ComparisonExpression.Operator operator;\n \n-        public Descriptor(DynamicFilterId id, Expression input)\n+        public Descriptor(DynamicFilterId id, Expression input, ComparisonExpression.Operator operator)\n         {\n             this.id = requireNonNull(id, \"id is null\");\n             this.input = requireNonNull(input, \"input is null\");\n+            this.operator = requireNonNull(operator, \"operator is null\");\n+        }\n+\n+        public Descriptor(DynamicFilterId id, Expression input)\n+        {\n+            this(id, input, ComparisonExpression.Operator.EQUAL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU3Mzk4NQ==", "bodyText": "From the test I don't know if vmax + 1 filtered anything or not (that's why I suggested vmin + 1). Please change the test so that upper boundary also filters data.", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516573985", "createdAt": "2020-11-03T10:44:48Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +264,40 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        assertUpdate(\"CREATE TABLE probe (k VARCHAR, v INTEGER)\");\n+        assertUpdate(\"CREATE TABLE build (vmin INTEGER, vmax INTEGER)\");\n+        assertUpdate(\"INSERT INTO probe VALUES ('a', 0), ('b', 1), ('c', 2), ('d', 3)\", 4);\n+        assertUpdate(\"INSERT INTO build VALUES (1, 2)\", 1);\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v <= vmax\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v < vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v < vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v <= vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v < vmax\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND vmax < 0\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v <= vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax + 1\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNjM3Njk4", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-522637698", "createdAt": "2020-11-03T15:53:54Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNTo1Mzo1NFrOHs1Q_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNTo1Njo1OFrOHs1aPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3MjA5NQ==", "bodyText": "why ImmutableSet.of(1) has one element here?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516772095", "createdAt": "2020-11-03T15:53:54Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +264,61 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        assertUpdate(\"CREATE TABLE probe (k VARCHAR, v INTEGER)\");\n+        assertUpdate(\"CREATE TABLE build (vmin INTEGER, vmax INTEGER)\");\n+        assertUpdate(\"INSERT INTO probe VALUES ('a', 0), ('b', 1), ('c', 2), ('d', 3)\", 4);\n+        assertUpdate(\"INSERT INTO build VALUES (1, 2)\", 1);\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v <= vmax\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v < vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v < vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3MjU0MQ==", "bodyText": "Make assertDynamicFiltering accept ImmutableList", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516772541", "createdAt": "2020-11-03T15:54:28Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -307,7 +363,7 @@ private Session withPartitionedJoin()\n         QueryStats stats = runner.getCoordinator().getQueryManager().getFullQueryInfo(queryId).getQueryStats();\n         return stats.getOperatorSummaries()\n                 .stream()\n-                .filter(summary -> summary.getOperatorType().equals(\"ScanFilterAndProjectOperator\"))\n+                .filter(summary -> summary.getOperatorType().contains(\"Scan\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3NDQ2MA==", "bodyText": "why set has one element?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516774460", "createdAt": "2020-11-03T15:56:58Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +264,61 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        assertUpdate(\"CREATE TABLE probe (k VARCHAR, v INTEGER)\");\n+        assertUpdate(\"CREATE TABLE build (vmin INTEGER, vmax INTEGER)\");\n+        assertUpdate(\"INSERT INTO probe VALUES ('a', 0), ('b', 1), ('c', 2), ('d', 3)\", 4);\n+        assertUpdate(\"INSERT INTO build VALUES (1, 2)\", 1);\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v <= vmax\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v < vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v < vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v <= vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v < vmax\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND vmax < 0\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v <= vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v BETWEEN vmin AND vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v >= vmin AND v <= vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+\n+        // TODO: support complex inequality join clauses: https://github.com/prestosql/presto/issues/5755\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax - 1\", withBroadcastJoin(), 1, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin + 1 AND vmax\", withBroadcastJoin(), 1, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin + 1 AND vmax - 1\", withBroadcastJoin(), 0, ImmutableSet.of(4, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v BETWEEN vmin AND vmax - 1\", withBroadcastJoin(), 1, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v BETWEEN vmin + 1 AND vmax\", withBroadcastJoin(), 1, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v BETWEEN vmin + 1 AND vmax - 1\", withBroadcastJoin(), 0, ImmutableSet.of(4, 1));\n+\n+        // TODO: make sure it works after https://github.com/prestosql/presto/issues/5777 is fixed\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v <= vmax - 1\", withBroadcastJoin(), 1, ImmutableSet.of(1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 44}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMjM0NjY0", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-523234664", "createdAt": "2020-11-04T10:35:19Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMDozNToyMFrOHtSTGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMDozNToyMFrOHtSTGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI0Nzc2OQ==", "bodyText": "why no order? Why not to compare lists directly?", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r517247769", "createdAt": "2020-11-04T10:35:20Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -260,16 +260,16 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                         \"WHERE t.partkey IN (SELECT p.partkey FROM part p WHERE p.comment = 'onic deposits')\",\n                 withBroadcastJoinNonReordering(),\n                 1,\n-                ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n+                ImmutableList.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n-    private void assertDynamicFiltering(@Language(\"SQL\") String selectQuery, Session session, int expectedRowCount, Set<Integer> expectedOperatorRowsRead)\n+    private void assertDynamicFiltering(@Language(\"SQL\") String selectQuery, Session session, int expectedRowCount, List<Integer> expectedOperatorRowsRead)\n     {\n         DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n         ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(session, selectQuery);\n \n         assertEquals(result.getResult().getRowCount(), expectedRowCount);\n-        assertEquals(getOperatorRowsRead(runner, result.getQueryId()), expectedOperatorRowsRead);\n+        assertEqualsNoOrder(getOperatorRowsRead(runner, result.getQueryId()).toArray(), expectedOperatorRowsRead.toArray());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 165}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNDU4ODI5", "url": "https://github.com/trinodb/trino/pull/2674#pullrequestreview-523458829", "createdAt": "2020-11-04T15:15:13Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNToxNToxM1rOHtcrBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNToxNToxM1rOHtcrBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxNzczNA==", "bodyText": "nit: we probably could use vararg here", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r517417734", "createdAt": "2020-11-04T15:15:13Z", "author": {"login": "sopel39"}, "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -106,7 +105,7 @@ public void testJoinDynamicFilteringNone()\n                 \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n                 withBroadcastJoin(),\n                 0,\n-                ImmutableSet.of(0, ORDERS_COUNT));\n+                ImmutableList.of(0, ORDERS_COUNT));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f4c676f43a4e2e6feacb4a208922aa3e9f3d3db", "author": {"user": {"login": "rzeyde-varada", "name": "Roman Z"}}, "url": "https://github.com/trinodb/trino/commit/7f4c676f43a4e2e6feacb4a208922aa3e9f3d3db", "committedDate": "2020-11-04T16:12:52Z", "message": "Improve matching of read rows in TestMemorySmoke"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7aa4b22b40f8665e104f7b53dd64e19e831d0f86", "author": {"user": {"login": "rzeyde-varada", "name": "Roman Z"}}, "url": "https://github.com/trinodb/trino/commit/7aa4b22b40f8665e104f7b53dd64e19e831d0f86", "committedDate": "2020-11-04T16:12:53Z", "message": "Allow dynamic filtering with comparison operators"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "7aa4b22b40f8665e104f7b53dd64e19e831d0f86", "author": {"user": {"login": "rzeyde-varada", "name": "Roman Z"}}, "url": "https://github.com/trinodb/trino/commit/7aa4b22b40f8665e104f7b53dd64e19e831d0f86", "committedDate": "2020-11-04T16:12:53Z", "message": "Allow dynamic filtering with comparison operators"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1739, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}