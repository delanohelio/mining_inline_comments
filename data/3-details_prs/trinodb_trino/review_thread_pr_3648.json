{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0MTQ4MTQx", "number": 3648, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNDo1MzoxNVrOD52wNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNjoyMzo1OFrOD6h0LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxOTkyNTAxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/connector/system/SystemTablesMetadata.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNDo1MzoxNVrOGRW_hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNDo1MzoxNVrOGRW_hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg1NTY4Ng==", "bodyText": "#3647", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r420855686", "createdAt": "2020-05-06T14:53:15Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/connector/system/SystemTablesMetadata.java", "diffHunk": "@@ -156,12 +157,24 @@ public ConnectorTableProperties getTableProperties(ConnectorSession session, Con\n \n         TupleDomain<ColumnHandle> oldDomain = table.getConstraint();\n         TupleDomain<ColumnHandle> newDomain = oldDomain.intersect(constraint.getSummary());\n+        if (oldDomain.equals(newDomain) && !constraint.predicate().isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        SystemTable systemTable = checkAndGetTable(session, table);\n+        if (systemTable instanceof JdbcTable) {\n+            TupleDomain<ColumnHandle> filtered = ((JdbcTable) systemTable).applyFilter(session, new Constraint(newDomain, constraint.predicate(), constraint.getColumns()));\n+            newDomain = newDomain.intersect(filtered);\n+        }\n+\n         if (oldDomain.equals(newDomain)) {\n             return Optional.empty();\n         }\n \n+        if (newDomain.isNone()) {\n+            // TODO (https://github.com/prestosql/presto/issues/3647) indicate the table scan is empty", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjI2MTI3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/connector/system/SystemTablesMetadata.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMzo0NTo0M1rOGRtVdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMTo0MzoyMVrOGSRXWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMTc0OQ==", "bodyText": "Why special-case JdbcTable? It'd be more naturally (and less code-smelly) to add applyFilter to SystemTable.", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421221749", "createdAt": "2020-05-07T03:45:43Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/connector/system/SystemTablesMetadata.java", "diffHunk": "@@ -156,12 +157,24 @@ public ConnectorTableProperties getTableProperties(ConnectorSession session, Con\n \n         TupleDomain<ColumnHandle> oldDomain = table.getConstraint();\n         TupleDomain<ColumnHandle> newDomain = oldDomain.intersect(constraint.getSummary());\n+        if (oldDomain.equals(newDomain) && !constraint.predicate().isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        SystemTable systemTable = checkAndGetTable(session, table);\n+        if (systemTable instanceof JdbcTable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2NzM0MA==", "bodyText": "For the cursor method, we translate TupleDomain<ColumnHandle>, into ordinals:  TupleDomain<Integer>.\nFor applyFilter\n\nWe can't pass Constraint since  it is expressed in terms of ColumnHandle, but SystemColumnHandle is not SPI. And we can't translate to ordinals, because of  f148e56 (of course, we can revert that, but I would strongly prefer this to be a follow up)\nfor same reason we cannot have the method return ConstraintApplicationResult... The applyFilter  returns refined domain.\n\nI concluded we are not ready to add this method to SystemTable. I considered adding a new interface for this, but decided it's not warranted in current situation.\nHence this is how it is. But this is definitely easy to improve in the future, when we conclude this is ready. (So far I didn't change SPI in any way, so no debt on this aspect.)", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421267340", "createdAt": "2020-05-07T06:27:53Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/connector/system/SystemTablesMetadata.java", "diffHunk": "@@ -156,12 +157,24 @@ public ConnectorTableProperties getTableProperties(ConnectorSession session, Con\n \n         TupleDomain<ColumnHandle> oldDomain = table.getConstraint();\n         TupleDomain<ColumnHandle> newDomain = oldDomain.intersect(constraint.getSummary());\n+        if (oldDomain.equals(newDomain) && !constraint.predicate().isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        SystemTable systemTable = checkAndGetTable(session, table);\n+        if (systemTable instanceof JdbcTable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMTc0OQ=="}, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY0Nzg3MA==", "bodyText": "Can you add a comment with a TODO so that future readers know why it was done this way?", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421647870", "createdAt": "2020-05-07T16:48:16Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/connector/system/SystemTablesMetadata.java", "diffHunk": "@@ -156,12 +157,24 @@ public ConnectorTableProperties getTableProperties(ConnectorSession session, Con\n \n         TupleDomain<ColumnHandle> oldDomain = table.getConstraint();\n         TupleDomain<ColumnHandle> newDomain = oldDomain.intersect(constraint.getSummary());\n+        if (oldDomain.equals(newDomain) && !constraint.predicate().isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        SystemTable systemTable = checkAndGetTable(session, table);\n+        if (systemTable instanceof JdbcTable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMTc0OQ=="}, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgxMjA1OQ==", "bodyText": "Added some comment in the code too.", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421812059", "createdAt": "2020-05-07T21:43:21Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/connector/system/SystemTablesMetadata.java", "diffHunk": "@@ -156,12 +157,24 @@ public ConnectorTableProperties getTableProperties(ConnectorSession session, Con\n \n         TupleDomain<ColumnHandle> oldDomain = table.getConstraint();\n         TupleDomain<ColumnHandle> newDomain = oldDomain.intersect(constraint.getSummary());\n+        if (oldDomain.equals(newDomain) && !constraint.predicate().isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        SystemTable systemTable = checkAndGetTable(session, table);\n+        if (systemTable instanceof JdbcTable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMTc0OQ=="}, "originalCommit": null, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjI2NTM1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/connector/system/jdbc/ColumnJdbcTable.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMzo0ODoxMVrOGRtXxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNTo0NDo0MlrOGSEyyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMjM0MQ==", "bodyText": "In what scenarios would these be empty strings? If this is just an optimization, add a comment.", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421222341", "createdAt": "2020-05-07T03:48:11Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/connector/system/jdbc/ColumnJdbcTable.java", "diffHunk": "@@ -111,24 +139,155 @@ public ConnectorTableMetadata getTableMetadata()\n         return METADATA;\n     }\n \n+    @Override\n+    public TupleDomain<ColumnHandle> applyFilter(ConnectorSession connectorSession, Constraint constraint)\n+    {\n+        TupleDomain<ColumnHandle> tupleDomain = constraint.getSummary();\n+        if (tupleDomain.isNone() || !constraint.predicate().isPresent()) {\n+            return tupleDomain;\n+        }\n+        Predicate<Map<ColumnHandle, NullableValue>> predicate = constraint.predicate().get();\n+        Set<ColumnHandle> predicateColumns = constraint.getColumns().orElseThrow(() -> new VerifyException(\"columns not present for a predicate\"));\n+\n+        boolean hasSchemaPredicate = predicateColumns.contains(TABLE_SCHEMA_COLUMN);\n+        boolean hasTablePredicate = predicateColumns.contains(TABLE_NAME_COLUMN);\n+        if (!hasSchemaPredicate && !hasTablePredicate) {\n+            // No filter on schema name and table name at all.\n+            return tupleDomain;\n+        }\n+\n+        Session session = ((FullConnectorSession) connectorSession).getSession();\n+\n+        Optional<String> catalogFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_CATALOG_COLUMN);\n+        Optional<String> schemaFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_SCHEMA_COLUMN);\n+        Optional<String> tableFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_NAME_COLUMN);\n+\n+        if (catalogFilter.equals(Optional.of(\"\")) ||\n+                schemaFilter.equals(Optional.of(\"\")) ||\n+                tableFilter.equals(Optional.of(\"\"))) {\n+            return TupleDomain.none();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2Nzg5NQ==", "bodyText": "It will be empty string when user query contains filters like TABLE_CAT = ''.\nIt is not really an optimization, because eg SchemaTablePrefix constrcuted below validates args are non-empty, so the code would fail without this if here.", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421267895", "createdAt": "2020-05-07T06:29:18Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/connector/system/jdbc/ColumnJdbcTable.java", "diffHunk": "@@ -111,24 +139,155 @@ public ConnectorTableMetadata getTableMetadata()\n         return METADATA;\n     }\n \n+    @Override\n+    public TupleDomain<ColumnHandle> applyFilter(ConnectorSession connectorSession, Constraint constraint)\n+    {\n+        TupleDomain<ColumnHandle> tupleDomain = constraint.getSummary();\n+        if (tupleDomain.isNone() || !constraint.predicate().isPresent()) {\n+            return tupleDomain;\n+        }\n+        Predicate<Map<ColumnHandle, NullableValue>> predicate = constraint.predicate().get();\n+        Set<ColumnHandle> predicateColumns = constraint.getColumns().orElseThrow(() -> new VerifyException(\"columns not present for a predicate\"));\n+\n+        boolean hasSchemaPredicate = predicateColumns.contains(TABLE_SCHEMA_COLUMN);\n+        boolean hasTablePredicate = predicateColumns.contains(TABLE_NAME_COLUMN);\n+        if (!hasSchemaPredicate && !hasTablePredicate) {\n+            // No filter on schema name and table name at all.\n+            return tupleDomain;\n+        }\n+\n+        Session session = ((FullConnectorSession) connectorSession).getSession();\n+\n+        Optional<String> catalogFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_CATALOG_COLUMN);\n+        Optional<String> schemaFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_SCHEMA_COLUMN);\n+        Optional<String> tableFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_NAME_COLUMN);\n+\n+        if (catalogFilter.equals(Optional.of(\"\")) ||\n+                schemaFilter.equals(Optional.of(\"\")) ||\n+                tableFilter.equals(Optional.of(\"\"))) {\n+            return TupleDomain.none();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMjM0MQ=="}, "originalCommit": null, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2NzkzMQ==", "bodyText": "Will add a comment.", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421267931", "createdAt": "2020-05-07T06:29:25Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/connector/system/jdbc/ColumnJdbcTable.java", "diffHunk": "@@ -111,24 +139,155 @@ public ConnectorTableMetadata getTableMetadata()\n         return METADATA;\n     }\n \n+    @Override\n+    public TupleDomain<ColumnHandle> applyFilter(ConnectorSession connectorSession, Constraint constraint)\n+    {\n+        TupleDomain<ColumnHandle> tupleDomain = constraint.getSummary();\n+        if (tupleDomain.isNone() || !constraint.predicate().isPresent()) {\n+            return tupleDomain;\n+        }\n+        Predicate<Map<ColumnHandle, NullableValue>> predicate = constraint.predicate().get();\n+        Set<ColumnHandle> predicateColumns = constraint.getColumns().orElseThrow(() -> new VerifyException(\"columns not present for a predicate\"));\n+\n+        boolean hasSchemaPredicate = predicateColumns.contains(TABLE_SCHEMA_COLUMN);\n+        boolean hasTablePredicate = predicateColumns.contains(TABLE_NAME_COLUMN);\n+        if (!hasSchemaPredicate && !hasTablePredicate) {\n+            // No filter on schema name and table name at all.\n+            return tupleDomain;\n+        }\n+\n+        Session session = ((FullConnectorSession) connectorSession).getSession();\n+\n+        Optional<String> catalogFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_CATALOG_COLUMN);\n+        Optional<String> schemaFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_SCHEMA_COLUMN);\n+        Optional<String> tableFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_NAME_COLUMN);\n+\n+        if (catalogFilter.equals(Optional.of(\"\")) ||\n+                schemaFilter.equals(Optional.of(\"\")) ||\n+                tableFilter.equals(Optional.of(\"\"))) {\n+            return TupleDomain.none();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMjM0MQ=="}, "originalCommit": null, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYwNjA4OQ==", "bodyText": "This is same problem as in #2523. I will rework that fix, so that it's applicable to .jdbc.columns as well.", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421606089", "createdAt": "2020-05-07T15:44:42Z", "author": {"login": "findepi"}, "path": "presto-main/src/main/java/io/prestosql/connector/system/jdbc/ColumnJdbcTable.java", "diffHunk": "@@ -111,24 +139,155 @@ public ConnectorTableMetadata getTableMetadata()\n         return METADATA;\n     }\n \n+    @Override\n+    public TupleDomain<ColumnHandle> applyFilter(ConnectorSession connectorSession, Constraint constraint)\n+    {\n+        TupleDomain<ColumnHandle> tupleDomain = constraint.getSummary();\n+        if (tupleDomain.isNone() || !constraint.predicate().isPresent()) {\n+            return tupleDomain;\n+        }\n+        Predicate<Map<ColumnHandle, NullableValue>> predicate = constraint.predicate().get();\n+        Set<ColumnHandle> predicateColumns = constraint.getColumns().orElseThrow(() -> new VerifyException(\"columns not present for a predicate\"));\n+\n+        boolean hasSchemaPredicate = predicateColumns.contains(TABLE_SCHEMA_COLUMN);\n+        boolean hasTablePredicate = predicateColumns.contains(TABLE_NAME_COLUMN);\n+        if (!hasSchemaPredicate && !hasTablePredicate) {\n+            // No filter on schema name and table name at all.\n+            return tupleDomain;\n+        }\n+\n+        Session session = ((FullConnectorSession) connectorSession).getSession();\n+\n+        Optional<String> catalogFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_CATALOG_COLUMN);\n+        Optional<String> schemaFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_SCHEMA_COLUMN);\n+        Optional<String> tableFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_NAME_COLUMN);\n+\n+        if (catalogFilter.equals(Optional.of(\"\")) ||\n+                schemaFilter.equals(Optional.of(\"\")) ||\n+                tableFilter.equals(Optional.of(\"\"))) {\n+            return TupleDomain.none();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMjM0MQ=="}, "originalCommit": null, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjI5MDIwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/connector/system/jdbc/ColumnJdbcTable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNDowMjozM1rOGRtlvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNDowMjozM1rOGRtlvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyNTkxOA==", "bodyText": "Using ImmutableMap.builder() is less sensitive to reformatting changes that may end up placing arguments in separate lines (and even if that happens, it's still clear which ones are keys and which ones are values). TLDR, when there are multiple entries, it's more robust to use the builder form than the multi-entry ImmutableMap.of().", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421225918", "createdAt": "2020-05-07T04:02:33Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/connector/system/jdbc/ColumnJdbcTable.java", "diffHunk": "@@ -111,24 +139,155 @@ public ConnectorTableMetadata getTableMetadata()\n         return METADATA;\n     }\n \n+    @Override\n+    public TupleDomain<ColumnHandle> applyFilter(ConnectorSession connectorSession, Constraint constraint)\n+    {\n+        TupleDomain<ColumnHandle> tupleDomain = constraint.getSummary();\n+        if (tupleDomain.isNone() || !constraint.predicate().isPresent()) {\n+            return tupleDomain;\n+        }\n+        Predicate<Map<ColumnHandle, NullableValue>> predicate = constraint.predicate().get();\n+        Set<ColumnHandle> predicateColumns = constraint.getColumns().orElseThrow(() -> new VerifyException(\"columns not present for a predicate\"));\n+\n+        boolean hasSchemaPredicate = predicateColumns.contains(TABLE_SCHEMA_COLUMN);\n+        boolean hasTablePredicate = predicateColumns.contains(TABLE_NAME_COLUMN);\n+        if (!hasSchemaPredicate && !hasTablePredicate) {\n+            // No filter on schema name and table name at all.\n+            return tupleDomain;\n+        }\n+\n+        Session session = ((FullConnectorSession) connectorSession).getSession();\n+\n+        Optional<String> catalogFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_CATALOG_COLUMN);\n+        Optional<String> schemaFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_SCHEMA_COLUMN);\n+        Optional<String> tableFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_NAME_COLUMN);\n+\n+        if (catalogFilter.equals(Optional.of(\"\")) ||\n+                schemaFilter.equals(Optional.of(\"\")) ||\n+                tableFilter.equals(Optional.of(\"\"))) {\n+            return TupleDomain.none();\n+        }\n+\n+        List<String> catalogs = listCatalogs(session, metadata, accessControl, catalogFilter).keySet().stream()\n+                .filter(catalogName -> predicate.test(ImmutableMap.of(TABLE_CATALOG_COLUMN, toNullableValue(catalogName))))\n+                .collect(toImmutableList());\n+\n+        List<CatalogSchemaName> schemas = catalogs.stream()\n+                .flatMap(catalogName ->\n+                        listSchemas(session, metadata, accessControl, catalogName, schemaFilter).stream()\n+                                .filter(schemaName -> !hasSchemaPredicate || predicate.test(ImmutableMap.of(\n+                                        TABLE_CATALOG_COLUMN, toNullableValue(catalogName),\n+                                        TABLE_SCHEMA_COLUMN, toNullableValue(schemaName))))\n+                                .map(schemaName -> new CatalogSchemaName(catalogName, schemaName)))\n+                .collect(toImmutableList());\n+\n+        if (!hasTablePredicate) {\n+            return TupleDomain.withColumnDomains(ImmutableMap.of(\n+                    TABLE_CATALOG_COLUMN, schemas.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjI5Mzg0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/connector/system/jdbc/ColumnJdbcTable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNDowNDo1NFrOGRtn2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNDowNDo1NFrOGRtn2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyNjQ1OQ==", "bodyText": ".simplify(...) on the next line", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421226459", "createdAt": "2020-05-07T04:04:54Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/connector/system/jdbc/ColumnJdbcTable.java", "diffHunk": "@@ -111,24 +139,155 @@ public ConnectorTableMetadata getTableMetadata()\n         return METADATA;\n     }\n \n+    @Override\n+    public TupleDomain<ColumnHandle> applyFilter(ConnectorSession connectorSession, Constraint constraint)\n+    {\n+        TupleDomain<ColumnHandle> tupleDomain = constraint.getSummary();\n+        if (tupleDomain.isNone() || !constraint.predicate().isPresent()) {\n+            return tupleDomain;\n+        }\n+        Predicate<Map<ColumnHandle, NullableValue>> predicate = constraint.predicate().get();\n+        Set<ColumnHandle> predicateColumns = constraint.getColumns().orElseThrow(() -> new VerifyException(\"columns not present for a predicate\"));\n+\n+        boolean hasSchemaPredicate = predicateColumns.contains(TABLE_SCHEMA_COLUMN);\n+        boolean hasTablePredicate = predicateColumns.contains(TABLE_NAME_COLUMN);\n+        if (!hasSchemaPredicate && !hasTablePredicate) {\n+            // No filter on schema name and table name at all.\n+            return tupleDomain;\n+        }\n+\n+        Session session = ((FullConnectorSession) connectorSession).getSession();\n+\n+        Optional<String> catalogFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_CATALOG_COLUMN);\n+        Optional<String> schemaFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_SCHEMA_COLUMN);\n+        Optional<String> tableFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_NAME_COLUMN);\n+\n+        if (catalogFilter.equals(Optional.of(\"\")) ||\n+                schemaFilter.equals(Optional.of(\"\")) ||\n+                tableFilter.equals(Optional.of(\"\"))) {\n+            return TupleDomain.none();\n+        }\n+\n+        List<String> catalogs = listCatalogs(session, metadata, accessControl, catalogFilter).keySet().stream()\n+                .filter(catalogName -> predicate.test(ImmutableMap.of(TABLE_CATALOG_COLUMN, toNullableValue(catalogName))))\n+                .collect(toImmutableList());\n+\n+        List<CatalogSchemaName> schemas = catalogs.stream()\n+                .flatMap(catalogName ->\n+                        listSchemas(session, metadata, accessControl, catalogName, schemaFilter).stream()\n+                                .filter(schemaName -> !hasSchemaPredicate || predicate.test(ImmutableMap.of(\n+                                        TABLE_CATALOG_COLUMN, toNullableValue(catalogName),\n+                                        TABLE_SCHEMA_COLUMN, toNullableValue(schemaName))))\n+                                .map(schemaName -> new CatalogSchemaName(catalogName, schemaName)))\n+                .collect(toImmutableList());\n+\n+        if (!hasTablePredicate) {\n+            return TupleDomain.withColumnDomains(ImmutableMap.of(\n+                    TABLE_CATALOG_COLUMN, schemas.stream()\n+                            .map(CatalogSchemaName::getCatalogName)\n+                            .collect(toVarcharDomain())\n+                            .simplify(MAX_DOMAIN_SIZE),\n+                    TABLE_SCHEMA_COLUMN, schemas.stream()\n+                            .map(CatalogSchemaName::getSchemaName)\n+                            .collect(toVarcharDomain())\n+                            .simplify(MAX_DOMAIN_SIZE)));\n+        }\n+\n+        List<CatalogSchemaTableName> tables = schemas.stream()\n+                .flatMap(schema -> {\n+                    QualifiedTablePrefix tablePrefix = tableFilter.isPresent()\n+                            ? new QualifiedTablePrefix(schema.getCatalogName(), schema.getSchemaName(), tableFilter.get())\n+                            : new QualifiedTablePrefix(schema.getCatalogName(), schema.getSchemaName());\n+                    return listTables(session, metadata, accessControl, tablePrefix).stream()\n+                            .filter(schemaTableName -> predicate.test(ImmutableMap.of(\n+                                    TABLE_CATALOG_COLUMN, toNullableValue(schema.getCatalogName()),\n+                                    TABLE_SCHEMA_COLUMN, toNullableValue(schemaTableName.getSchemaName()),\n+                                    TABLE_NAME_COLUMN, toNullableValue(schemaTableName.getTableName()))))\n+                            .map(schemaTableName -> new CatalogSchemaTableName(schema.getCatalogName(), schemaTableName.getSchemaName(), schemaTableName.getTableName()));\n+                })\n+                .collect(toImmutableList());\n+\n+        return TupleDomain.withColumnDomains(ImmutableMap.of(\n+                TABLE_CATALOG_COLUMN, tables.stream()\n+                        .map(CatalogSchemaTableName::getCatalogName)\n+                        .collect(toVarcharDomain()).simplify(MAX_DOMAIN_SIZE),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjk4MDI5OnYy", "diffSide": "LEFT", "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestPrestoDatabaseMetaData.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNjoyMzo1OFrOGSak1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNjoyMzo1OFrOGSak1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk2Mjk2NA==", "bodyText": "Nice!", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421962964", "createdAt": "2020-05-08T06:23:58Z", "author": {"login": "kokosing"}, "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestPrestoDatabaseMetaData.java", "diffHunk": "@@ -1169,22 +1169,52 @@ public void testGetColumnsMetadataCalls()\n                         list(\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"TYPE_NAME\")),\n                 list(list(COUNTING_CATALOG, \"test_schema1\", \"test_table1\", \"column_17\", \"varchar\")),\n                 new MetadataCallsCount()\n-                        .withListSchemasCount(1)\n-                        .withListTablesCount(2)\n-                        .withGetColumnsCount(3000));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b82112eb15004567793b2c72a115918c93283b6"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 54, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}