{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIwODgzOTQ2", "number": 5959, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxOToyOTo1OVrOE6uyig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTo1Mjo1NFrOE8X2RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMDE5NDY2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformCorrelatedAggregationToJoin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxOToyOTo1OVrOH1-q4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxOTozNDoyMVrOH1-1TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2MzM2Mw==", "bodyText": "The method name is not very clear. What does \"join sources\" refer to, and what is a \"helper\" symbol?", "url": "https://github.com/trinodb/trino/pull/5959#discussion_r526363363", "createdAt": "2020-11-18T19:29:59Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformCorrelatedAggregationToJoin.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.metadata.FunctionId;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.iterative.Rule.Context;\n+import io.prestosql.sql.planner.optimizations.PlanNodeDecorrelator;\n+import io.prestosql.sql.planner.optimizations.PlanNodeDecorrelator.DecorrelatedNode;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.Aggregation;\n+import io.prestosql.sql.planner.plan.AssignUniqueId;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.CorrelatedJoinNode;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.QualifiedName;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.sql.analyzer.TypeSignatureProvider.fromTypes;\n+import static io.prestosql.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static java.util.Objects.requireNonNull;\n+\n+public class TransformCorrelatedAggregationToJoin\n+{\n+    private final Metadata metadata;\n+\n+    public TransformCorrelatedAggregationToJoin(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    public Set<Rule<?>> rules()\n+    {\n+        return ImmutableSet.of(\n+                new TransformCorrelatedGlobalAggregationWithProjection(metadata),\n+                new TransformCorrelatedGlobalAggregationWithoutProjection(metadata),\n+                new TransformCorrelatedDistinctAggregationWithProjection(metadata),\n+                new TransformCorrelatedDistinctAggregationWithoutProjection(metadata),\n+                new TransformCorrelatedGroupedAggregationWithProjection(metadata),\n+                new TransformCorrelatedGroupedAggregationWithoutProjection(metadata));\n+    }\n+\n+    public static boolean isDistinctOperator(PlanNode node)\n+    {\n+        return node instanceof AggregationNode &&\n+                ((AggregationNode) node).getAggregations().isEmpty() &&\n+                ((AggregationNode) node).getGroupingSetCount() == 1 &&\n+                ((AggregationNode) node).hasNonEmptyGroupingSet();\n+    }\n+\n+    public static Optional<JoinNode> joinSourcesWithHelperSymbols(CorrelatedJoinNode correlatedJoinNode, PlanNode rightSource, JoinNode.Type joinType, Optional<Symbol> nonNull, Context context, Metadata metadata)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2NjAyOA==", "bodyText": "Since this method takes \"rightSource\" (which, btw, would be more accurate to call \"nested plan\"), passing CorrelatedJoinNode is confusing and error prone. It allows, or appears to allow, passing a rightSource that's unrelated to the correlationJoinNode argument.\nInstead, pass the input, nested plan and correlations as separate arguments.", "url": "https://github.com/trinodb/trino/pull/5959#discussion_r526366028", "createdAt": "2020-11-18T19:34:21Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformCorrelatedAggregationToJoin.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.metadata.FunctionId;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.iterative.Rule.Context;\n+import io.prestosql.sql.planner.optimizations.PlanNodeDecorrelator;\n+import io.prestosql.sql.planner.optimizations.PlanNodeDecorrelator.DecorrelatedNode;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.Aggregation;\n+import io.prestosql.sql.planner.plan.AssignUniqueId;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.CorrelatedJoinNode;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.QualifiedName;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.sql.analyzer.TypeSignatureProvider.fromTypes;\n+import static io.prestosql.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static java.util.Objects.requireNonNull;\n+\n+public class TransformCorrelatedAggregationToJoin\n+{\n+    private final Metadata metadata;\n+\n+    public TransformCorrelatedAggregationToJoin(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    public Set<Rule<?>> rules()\n+    {\n+        return ImmutableSet.of(\n+                new TransformCorrelatedGlobalAggregationWithProjection(metadata),\n+                new TransformCorrelatedGlobalAggregationWithoutProjection(metadata),\n+                new TransformCorrelatedDistinctAggregationWithProjection(metadata),\n+                new TransformCorrelatedDistinctAggregationWithoutProjection(metadata),\n+                new TransformCorrelatedGroupedAggregationWithProjection(metadata),\n+                new TransformCorrelatedGroupedAggregationWithoutProjection(metadata));\n+    }\n+\n+    public static boolean isDistinctOperator(PlanNode node)\n+    {\n+        return node instanceof AggregationNode &&\n+                ((AggregationNode) node).getAggregations().isEmpty() &&\n+                ((AggregationNode) node).getGroupingSetCount() == 1 &&\n+                ((AggregationNode) node).hasNonEmptyGroupingSet();\n+    }\n+\n+    public static Optional<JoinNode> joinSourcesWithHelperSymbols(CorrelatedJoinNode correlatedJoinNode, PlanNode rightSource, JoinNode.Type joinType, Optional<Symbol> nonNull, Context context, Metadata metadata)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2MzM2Mw=="}, "originalCommit": null, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMDIyMzMzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformCorrelatedAggregationToJoin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxOTozNjo1NVrOH1-7_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMTozNDoyOFrOH2DF9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2Nzc0MA==", "bodyText": "The fact that this is only relevant for LEFT join (even though this method can take different joinTypes), makes me think this method is doing to much and modeling a union of overlapping behaviors. I think it would be cleaner to either:\n\npartially inline this method in the callers\nhave dedicated variants for the different use cases it handles\n\nI'll try out a couple of options.", "url": "https://github.com/trinodb/trino/pull/5959#discussion_r526367740", "createdAt": "2020-11-18T19:36:55Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformCorrelatedAggregationToJoin.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.metadata.FunctionId;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.iterative.Rule.Context;\n+import io.prestosql.sql.planner.optimizations.PlanNodeDecorrelator;\n+import io.prestosql.sql.planner.optimizations.PlanNodeDecorrelator.DecorrelatedNode;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.Aggregation;\n+import io.prestosql.sql.planner.plan.AssignUniqueId;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.CorrelatedJoinNode;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.QualifiedName;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.sql.analyzer.TypeSignatureProvider.fromTypes;\n+import static io.prestosql.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static java.util.Objects.requireNonNull;\n+\n+public class TransformCorrelatedAggregationToJoin\n+{\n+    private final Metadata metadata;\n+\n+    public TransformCorrelatedAggregationToJoin(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    public Set<Rule<?>> rules()\n+    {\n+        return ImmutableSet.of(\n+                new TransformCorrelatedGlobalAggregationWithProjection(metadata),\n+                new TransformCorrelatedGlobalAggregationWithoutProjection(metadata),\n+                new TransformCorrelatedDistinctAggregationWithProjection(metadata),\n+                new TransformCorrelatedDistinctAggregationWithoutProjection(metadata),\n+                new TransformCorrelatedGroupedAggregationWithProjection(metadata),\n+                new TransformCorrelatedGroupedAggregationWithoutProjection(metadata));\n+    }\n+\n+    public static boolean isDistinctOperator(PlanNode node)\n+    {\n+        return node instanceof AggregationNode &&\n+                ((AggregationNode) node).getAggregations().isEmpty() &&\n+                ((AggregationNode) node).getGroupingSetCount() == 1 &&\n+                ((AggregationNode) node).hasNonEmptyGroupingSet();\n+    }\n+\n+    public static Optional<JoinNode> joinSourcesWithHelperSymbols(CorrelatedJoinNode correlatedJoinNode, PlanNode rightSource, JoinNode.Type joinType, Optional<Symbol> nonNull, Context context, Metadata metadata)\n+    {\n+        // decorrelate source\n+        PlanNodeDecorrelator decorrelator = new PlanNodeDecorrelator(metadata, context.getSymbolAllocator(), context.getLookup());\n+        Optional<DecorrelatedNode> decorrelatedSource = decorrelator.decorrelateFilters(rightSource, correlatedJoinNode.getCorrelation());\n+        if (decorrelatedSource.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        PlanNode source = decorrelatedSource.get().getNode();\n+\n+        // append non-null symbol on source. It will be used to restore semantics of count(*) aggregations after LEFT join\n+        if (nonNull.isPresent()) {\n+            source = new ProjectNode(\n+                    context.getIdAllocator().getNextId(),\n+                    source,\n+                    Assignments.builder()\n+                            .putIdentities(source.getOutputSymbols())\n+                            .put(nonNull.get(), TRUE_LITERAL)\n+                            .build());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQzNTgyOA==", "bodyText": "Indeed, at least for TransformCorrelatedDistinctAggregationWithoutProjection, it's a lot clearer what's going on if you inline this method and the calls to appendAggregations. They seem like unnecessary abstractions that don't add much value.", "url": "https://github.com/trinodb/trino/pull/5959#discussion_r526435828", "createdAt": "2020-11-18T21:34:28Z", "author": {"login": "martint"}, "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformCorrelatedAggregationToJoin.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.metadata.FunctionId;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.iterative.Rule.Context;\n+import io.prestosql.sql.planner.optimizations.PlanNodeDecorrelator;\n+import io.prestosql.sql.planner.optimizations.PlanNodeDecorrelator.DecorrelatedNode;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.Aggregation;\n+import io.prestosql.sql.planner.plan.AssignUniqueId;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.CorrelatedJoinNode;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.QualifiedName;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.sql.analyzer.TypeSignatureProvider.fromTypes;\n+import static io.prestosql.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static java.util.Objects.requireNonNull;\n+\n+public class TransformCorrelatedAggregationToJoin\n+{\n+    private final Metadata metadata;\n+\n+    public TransformCorrelatedAggregationToJoin(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    public Set<Rule<?>> rules()\n+    {\n+        return ImmutableSet.of(\n+                new TransformCorrelatedGlobalAggregationWithProjection(metadata),\n+                new TransformCorrelatedGlobalAggregationWithoutProjection(metadata),\n+                new TransformCorrelatedDistinctAggregationWithProjection(metadata),\n+                new TransformCorrelatedDistinctAggregationWithoutProjection(metadata),\n+                new TransformCorrelatedGroupedAggregationWithProjection(metadata),\n+                new TransformCorrelatedGroupedAggregationWithoutProjection(metadata));\n+    }\n+\n+    public static boolean isDistinctOperator(PlanNode node)\n+    {\n+        return node instanceof AggregationNode &&\n+                ((AggregationNode) node).getAggregations().isEmpty() &&\n+                ((AggregationNode) node).getGroupingSetCount() == 1 &&\n+                ((AggregationNode) node).hasNonEmptyGroupingSet();\n+    }\n+\n+    public static Optional<JoinNode> joinSourcesWithHelperSymbols(CorrelatedJoinNode correlatedJoinNode, PlanNode rightSource, JoinNode.Type joinType, Optional<Symbol> nonNull, Context context, Metadata metadata)\n+    {\n+        // decorrelate source\n+        PlanNodeDecorrelator decorrelator = new PlanNodeDecorrelator(metadata, context.getSymbolAllocator(), context.getLookup());\n+        Optional<DecorrelatedNode> decorrelatedSource = decorrelator.decorrelateFilters(rightSource, correlatedJoinNode.getCorrelation());\n+        if (decorrelatedSource.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        PlanNode source = decorrelatedSource.get().getNode();\n+\n+        // append non-null symbol on source. It will be used to restore semantics of count(*) aggregations after LEFT join\n+        if (nonNull.isPresent()) {\n+            source = new ProjectNode(\n+                    context.getIdAllocator().getNextId(),\n+                    source,\n+                    Assignments.builder()\n+                            .putIdentities(source.getOutputSymbols())\n+                            .put(nonNull.get(), TRUE_LITERAL)\n+                            .build());\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2Nzc0MA=="}, "originalCommit": null, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzQwNzE3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/query/TestCorrelatedAggregation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTo1Mjo1MVrOH4dCyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTo1Mjo1MVrOH4dCyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk1ODE1Mw==", "bodyText": "Add some tests involving ORDER BY within aggregations and FILTER (WHERE ...)", "url": "https://github.com/trinodb/trino/pull/5959#discussion_r528958153", "createdAt": "2020-11-23T19:52:51Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/sql/query/TestCorrelatedAggregation.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.query;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestCorrelatedAggregation", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzQwNzQwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/io/prestosql/sql/query/TestCorrelatedAggregation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTo1Mjo1NFrOH4dC7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTo1Mjo1NFrOH4dC7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk1ODE4OQ==", "bodyText": "Use lower-case for table names. T -> t", "url": "https://github.com/trinodb/trino/pull/5959#discussion_r528958189", "createdAt": "2020-11-23T19:52:54Z", "author": {"login": "martint"}, "path": "presto-main/src/test/java/io/prestosql/sql/query/TestCorrelatedAggregation.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.query;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestCorrelatedAggregation\n+{\n+    protected QueryAssertions assertions;\n+\n+    @BeforeClass\n+    public void init()\n+    {\n+        assertions = new QueryAssertions();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void teardown()\n+    {\n+        assertions.close();\n+        assertions = null;\n+    }\n+\n+    @Test\n+    public void testGlobalDistinctAggregation()\n+    {\n+        assertThat(assertions.query(\"SELECT * FROM \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4781, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}