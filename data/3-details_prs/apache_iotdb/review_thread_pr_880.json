{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzMDkzMTcx", "number": 880, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwMzowNTozMlrODlRsGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwMzowNzozNVrODlRtTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDEzNzIwOnYy", "diffSide": "RIGHT", "path": "session/src/main/java/org/apache/iotdb/session/pool/SessionPool.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwMzowNTozMlrOFyFCnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwMzowNTozMlrOFyFCnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA1NTcwOA==", "bodyText": "should the password be printed?", "url": "https://github.com/apache/iotdb/pull/880#discussion_r388055708", "createdAt": "2020-03-05T03:05:32Z", "author": {"login": "qiaojialin"}, "path": "session/src/main/java/org/apache/iotdb/session/pool/SessionPool.java", "diffHunk": "@@ -0,0 +1,670 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.session.pool;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentMap;\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.service.rpc.thrift.TSExecuteBatchStatementResp;\n+import org.apache.iotdb.service.rpc.thrift.TSStatus;\n+import org.apache.iotdb.session.Config;\n+import org.apache.iotdb.session.IoTDBSessionException;\n+import org.apache.iotdb.session.Session;\n+import org.apache.iotdb.session.SessionDataSet;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.write.record.RowBatch;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * SessionPool is a wrapper of a Session Set.\n+ * Using SessionPool, the user do not need to consider how to reuse a session connection.\n+ * Even if the session is disconnected, the session pool can recognize it and remove the borken\n+ * session connection and create a new one.\n+ *\n+ * If there is no available connections and the pool reaches its max size, the all methods will hang\n+ * until there is a available connection.\n+ *\n+ * If a user has waited for a session for more than 60 seconds, a warn log will be printed.\n+ *\n+ *\n+ * The only thing you have to remember is that:\n+ *\n+ * For a query, if you have get all data, i.e., SessionDataSetWrapper.hasNext() == false, it is ok.\n+ * Otherwise, i.e., you want to stop the query before you get all data (SessionDataSetWrapper.hasNext() == true),\n+ * then you have to call closeResultSet(SessionDataSetWrapper wrapper) manually.\n+ * Otherwise the connection is occupied by the query.\n+ *\n+ * Another case that you have to manually call closeResultSet() is that when there is exception\n+ * when you call SessionDataSetWrapper.hasNext() or next()\n+ *\n+ *\n+ */\n+public class SessionPool {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(SessionPool.class);\n+  private ConcurrentLinkedDeque<Session> queue = new ConcurrentLinkedDeque<>();\n+  //for session whose resultSet is not released.\n+  private ConcurrentMap<Session, Session> occupied = new ConcurrentHashMap<>();\n+\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize) {\n+    this(ip, port, user, password, maxSize, Config.DEFAULT_FETCH_SIZE);\n+  }\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize, int fetchSize) {\n+    this.maxSize = maxSize;\n+    this.ip = ip;\n+    this.port = port;\n+    this.user = user;\n+    this.password = password;\n+    this.fetchSize = fetchSize;\n+  }\n+\n+  private int size = 0;\n+  private int maxSize = 0;\n+  private String ip;\n+  private int port;\n+  private String user;\n+  private String password;\n+\n+  private int fetchSize;\n+\n+  //if this method throws an exception, either the server is broken, or the ip/port/user/password is incorrect.\n+  //TODO: we can add a mechanism that if the user waits too long time, throw exception.\n+  private Session getSession() throws IoTDBSessionException {\n+    Session session = queue.poll();\n+    if (session != null) {\n+      return session;\n+    } else {\n+      synchronized (this) {\n+        long start = System.currentTimeMillis();\n+        while (session == null) {\n+          if (size < maxSize) {\n+            //we can create more session\n+            size++;\n+            //but we do it after skip synchronized block because connection a session is time consuming.\n+            break;\n+          } else {\n+            //we have to wait for someone returns a session.\n+            try {\n+              this.wait(1000);\n+              if (System.currentTimeMillis() - start > 60_000) {\n+                logger.warn(\n+                    \"the SessionPool has wait for {} seconds to get a new connection: {}:{} with {}, {}\",\n+                    (System.currentTimeMillis() - start) / 1000, ip, port, user, password);\n+              }\n+            } catch (InterruptedException e) {\n+              logger.error(\"the SessionPool is damaged\", e);\n+              Thread.currentThread().interrupt();\n+            }\n+            session = queue.poll();\n+          }\n+        }\n+        if (session != null) {\n+          return session;\n+        }\n+      }\n+      if (logger.isDebugEnabled()) {\n+        logger.error(\"Create a new Session {}, {}, {}, {}\", ip, port, user, password);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7157addd0a53bf9cba3a4a20c7648d714ec2b8d"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDEzOTY1OnYy", "diffSide": "RIGHT", "path": "session/src/main/java/org/apache/iotdb/session/pool/SessionPool.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwMzowNzowN1rOFyFEEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzo0Mjo1M1rOF0r6yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA1NjA4Mw==", "bodyText": "Is it needed to export the methods of Session in this Pool? the codes are double...", "url": "https://github.com/apache/iotdb/pull/880#discussion_r388056083", "createdAt": "2020-03-05T03:07:07Z", "author": {"login": "qiaojialin"}, "path": "session/src/main/java/org/apache/iotdb/session/pool/SessionPool.java", "diffHunk": "@@ -0,0 +1,670 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.session.pool;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentMap;\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.service.rpc.thrift.TSExecuteBatchStatementResp;\n+import org.apache.iotdb.service.rpc.thrift.TSStatus;\n+import org.apache.iotdb.session.Config;\n+import org.apache.iotdb.session.IoTDBSessionException;\n+import org.apache.iotdb.session.Session;\n+import org.apache.iotdb.session.SessionDataSet;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.write.record.RowBatch;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * SessionPool is a wrapper of a Session Set.\n+ * Using SessionPool, the user do not need to consider how to reuse a session connection.\n+ * Even if the session is disconnected, the session pool can recognize it and remove the borken\n+ * session connection and create a new one.\n+ *\n+ * If there is no available connections and the pool reaches its max size, the all methods will hang\n+ * until there is a available connection.\n+ *\n+ * If a user has waited for a session for more than 60 seconds, a warn log will be printed.\n+ *\n+ *\n+ * The only thing you have to remember is that:\n+ *\n+ * For a query, if you have get all data, i.e., SessionDataSetWrapper.hasNext() == false, it is ok.\n+ * Otherwise, i.e., you want to stop the query before you get all data (SessionDataSetWrapper.hasNext() == true),\n+ * then you have to call closeResultSet(SessionDataSetWrapper wrapper) manually.\n+ * Otherwise the connection is occupied by the query.\n+ *\n+ * Another case that you have to manually call closeResultSet() is that when there is exception\n+ * when you call SessionDataSetWrapper.hasNext() or next()\n+ *\n+ *\n+ */\n+public class SessionPool {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(SessionPool.class);\n+  private ConcurrentLinkedDeque<Session> queue = new ConcurrentLinkedDeque<>();\n+  //for session whose resultSet is not released.\n+  private ConcurrentMap<Session, Session> occupied = new ConcurrentHashMap<>();\n+\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize) {\n+    this(ip, port, user, password, maxSize, Config.DEFAULT_FETCH_SIZE);\n+  }\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize, int fetchSize) {\n+    this.maxSize = maxSize;\n+    this.ip = ip;\n+    this.port = port;\n+    this.user = user;\n+    this.password = password;\n+    this.fetchSize = fetchSize;\n+  }\n+\n+  private int size = 0;\n+  private int maxSize = 0;\n+  private String ip;\n+  private int port;\n+  private String user;\n+  private String password;\n+\n+  private int fetchSize;\n+\n+  //if this method throws an exception, either the server is broken, or the ip/port/user/password is incorrect.\n+  //TODO: we can add a mechanism that if the user waits too long time, throw exception.\n+  private Session getSession() throws IoTDBSessionException {\n+    Session session = queue.poll();\n+    if (session != null) {\n+      return session;\n+    } else {\n+      synchronized (this) {\n+        long start = System.currentTimeMillis();\n+        while (session == null) {\n+          if (size < maxSize) {\n+            //we can create more session\n+            size++;\n+            //but we do it after skip synchronized block because connection a session is time consuming.\n+            break;\n+          } else {\n+            //we have to wait for someone returns a session.\n+            try {\n+              this.wait(1000);\n+              if (System.currentTimeMillis() - start > 60_000) {\n+                logger.warn(\n+                    \"the SessionPool has wait for {} seconds to get a new connection: {}:{} with {}, {}\",\n+                    (System.currentTimeMillis() - start) / 1000, ip, port, user, password);\n+              }\n+            } catch (InterruptedException e) {\n+              logger.error(\"the SessionPool is damaged\", e);\n+              Thread.currentThread().interrupt();\n+            }\n+            session = queue.poll();\n+          }\n+        }\n+        if (session != null) {\n+          return session;\n+        }\n+      }\n+      if (logger.isDebugEnabled()) {\n+        logger.error(\"Create a new Session {}, {}, {}, {}\", ip, port, user, password);\n+      }\n+      session = new Session(ip, port, user, password, fetchSize);\n+      session.open();\n+      return session;\n+    }\n+  }\n+\n+  public int currentAvailableSize() {\n+    return queue.size();\n+  }\n+\n+  public int currentOccupiedSize() {\n+    return occupied.size();\n+  }\n+\n+  private void putBack(Session session) {\n+    queue.push(session);\n+    synchronized (this) {\n+      this.notifyAll();\n+    }\n+  }\n+\n+  private void occupy(Session session) {\n+    occupied.put(session, session);\n+  }\n+\n+  /**\n+   * close all connections in the pool\n+   */\n+  public synchronized void close() {\n+    for (Session session : queue) {\n+      try {\n+        session.close();\n+      } catch (IoTDBSessionException e) {\n+        //do nothing\n+      }\n+    }\n+    for (Session session : occupied.keySet()) {\n+      try {\n+        session.close();\n+      } catch (IoTDBSessionException e) {\n+        //do nothing\n+      }\n+    }\n+    queue.clear();\n+    occupied.clear();\n+  }\n+\n+  public void closeResultSet(SessionDataSetWrapper wrapper) throws SQLException {\n+    boolean putback = true;\n+    try {\n+      wrapper.sessionDataSet.closeOperationHandle();\n+    } catch (SQLException e) {\n+      if (e.getCause() instanceof TException) {\n+        // the connection is broken.\n+        removeSession();\n+        putback = false;\n+      } else {\n+        throw e;\n+      }\n+    } finally {\n+      Session session = occupied.remove(wrapper.session);\n+      if (putback && session != null) {\n+        putBack(wrapper.session);\n+      }\n+    }\n+  }\n+\n+  private synchronized void removeSession() {\n+    if (logger.isDebugEnabled()) {\n+      logger.error(\"Remove a broken Session {}, {}, {}, {}\", ip, port, user, password);\n+    }\n+    size--;\n+  }\n+\n+  private void closeSession(Session session) {\n+    if (session != null) {\n+      try {\n+        session.close();\n+      } catch (Exception e2) {\n+        //do nothing. We just want to guarantee the session is closed.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * use batch interface to insert sorted data times in row batch must be sorted before!\n+   *\n+   * @param rowBatch data batch\n+   */\n+  public TSExecuteBatchStatementResp insertSortedBatch(RowBatch rowBatch)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7157addd0a53bf9cba3a4a20c7648d714ec2b8d"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNzgzMw==", "bodyText": "the codes are double...\n\nAh?", "url": "https://github.com/apache/iotdb/pull/880#discussion_r389237833", "createdAt": "2020-03-07T08:22:29Z", "author": {"login": "jixuan1989"}, "path": "session/src/main/java/org/apache/iotdb/session/pool/SessionPool.java", "diffHunk": "@@ -0,0 +1,670 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.session.pool;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentMap;\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.service.rpc.thrift.TSExecuteBatchStatementResp;\n+import org.apache.iotdb.service.rpc.thrift.TSStatus;\n+import org.apache.iotdb.session.Config;\n+import org.apache.iotdb.session.IoTDBSessionException;\n+import org.apache.iotdb.session.Session;\n+import org.apache.iotdb.session.SessionDataSet;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.write.record.RowBatch;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * SessionPool is a wrapper of a Session Set.\n+ * Using SessionPool, the user do not need to consider how to reuse a session connection.\n+ * Even if the session is disconnected, the session pool can recognize it and remove the borken\n+ * session connection and create a new one.\n+ *\n+ * If there is no available connections and the pool reaches its max size, the all methods will hang\n+ * until there is a available connection.\n+ *\n+ * If a user has waited for a session for more than 60 seconds, a warn log will be printed.\n+ *\n+ *\n+ * The only thing you have to remember is that:\n+ *\n+ * For a query, if you have get all data, i.e., SessionDataSetWrapper.hasNext() == false, it is ok.\n+ * Otherwise, i.e., you want to stop the query before you get all data (SessionDataSetWrapper.hasNext() == true),\n+ * then you have to call closeResultSet(SessionDataSetWrapper wrapper) manually.\n+ * Otherwise the connection is occupied by the query.\n+ *\n+ * Another case that you have to manually call closeResultSet() is that when there is exception\n+ * when you call SessionDataSetWrapper.hasNext() or next()\n+ *\n+ *\n+ */\n+public class SessionPool {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(SessionPool.class);\n+  private ConcurrentLinkedDeque<Session> queue = new ConcurrentLinkedDeque<>();\n+  //for session whose resultSet is not released.\n+  private ConcurrentMap<Session, Session> occupied = new ConcurrentHashMap<>();\n+\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize) {\n+    this(ip, port, user, password, maxSize, Config.DEFAULT_FETCH_SIZE);\n+  }\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize, int fetchSize) {\n+    this.maxSize = maxSize;\n+    this.ip = ip;\n+    this.port = port;\n+    this.user = user;\n+    this.password = password;\n+    this.fetchSize = fetchSize;\n+  }\n+\n+  private int size = 0;\n+  private int maxSize = 0;\n+  private String ip;\n+  private int port;\n+  private String user;\n+  private String password;\n+\n+  private int fetchSize;\n+\n+  //if this method throws an exception, either the server is broken, or the ip/port/user/password is incorrect.\n+  //TODO: we can add a mechanism that if the user waits too long time, throw exception.\n+  private Session getSession() throws IoTDBSessionException {\n+    Session session = queue.poll();\n+    if (session != null) {\n+      return session;\n+    } else {\n+      synchronized (this) {\n+        long start = System.currentTimeMillis();\n+        while (session == null) {\n+          if (size < maxSize) {\n+            //we can create more session\n+            size++;\n+            //but we do it after skip synchronized block because connection a session is time consuming.\n+            break;\n+          } else {\n+            //we have to wait for someone returns a session.\n+            try {\n+              this.wait(1000);\n+              if (System.currentTimeMillis() - start > 60_000) {\n+                logger.warn(\n+                    \"the SessionPool has wait for {} seconds to get a new connection: {}:{} with {}, {}\",\n+                    (System.currentTimeMillis() - start) / 1000, ip, port, user, password);\n+              }\n+            } catch (InterruptedException e) {\n+              logger.error(\"the SessionPool is damaged\", e);\n+              Thread.currentThread().interrupt();\n+            }\n+            session = queue.poll();\n+          }\n+        }\n+        if (session != null) {\n+          return session;\n+        }\n+      }\n+      if (logger.isDebugEnabled()) {\n+        logger.error(\"Create a new Session {}, {}, {}, {}\", ip, port, user, password);\n+      }\n+      session = new Session(ip, port, user, password, fetchSize);\n+      session.open();\n+      return session;\n+    }\n+  }\n+\n+  public int currentAvailableSize() {\n+    return queue.size();\n+  }\n+\n+  public int currentOccupiedSize() {\n+    return occupied.size();\n+  }\n+\n+  private void putBack(Session session) {\n+    queue.push(session);\n+    synchronized (this) {\n+      this.notifyAll();\n+    }\n+  }\n+\n+  private void occupy(Session session) {\n+    occupied.put(session, session);\n+  }\n+\n+  /**\n+   * close all connections in the pool\n+   */\n+  public synchronized void close() {\n+    for (Session session : queue) {\n+      try {\n+        session.close();\n+      } catch (IoTDBSessionException e) {\n+        //do nothing\n+      }\n+    }\n+    for (Session session : occupied.keySet()) {\n+      try {\n+        session.close();\n+      } catch (IoTDBSessionException e) {\n+        //do nothing\n+      }\n+    }\n+    queue.clear();\n+    occupied.clear();\n+  }\n+\n+  public void closeResultSet(SessionDataSetWrapper wrapper) throws SQLException {\n+    boolean putback = true;\n+    try {\n+      wrapper.sessionDataSet.closeOperationHandle();\n+    } catch (SQLException e) {\n+      if (e.getCause() instanceof TException) {\n+        // the connection is broken.\n+        removeSession();\n+        putback = false;\n+      } else {\n+        throw e;\n+      }\n+    } finally {\n+      Session session = occupied.remove(wrapper.session);\n+      if (putback && session != null) {\n+        putBack(wrapper.session);\n+      }\n+    }\n+  }\n+\n+  private synchronized void removeSession() {\n+    if (logger.isDebugEnabled()) {\n+      logger.error(\"Remove a broken Session {}, {}, {}, {}\", ip, port, user, password);\n+    }\n+    size--;\n+  }\n+\n+  private void closeSession(Session session) {\n+    if (session != null) {\n+      try {\n+        session.close();\n+      } catch (Exception e2) {\n+        //do nothing. We just want to guarantee the session is closed.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * use batch interface to insert sorted data times in row batch must be sorted before!\n+   *\n+   * @param rowBatch data batch\n+   */\n+  public TSExecuteBatchStatementResp insertSortedBatch(RowBatch rowBatch)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA1NjA4Mw=="}, "originalCommit": {"oid": "e7157addd0a53bf9cba3a4a20c7648d714ec2b8d"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc4OTgzNA==", "bodyText": "the interfaces are double...", "url": "https://github.com/apache/iotdb/pull/880#discussion_r390789834", "createdAt": "2020-03-11T07:42:53Z", "author": {"login": "qiaojialin"}, "path": "session/src/main/java/org/apache/iotdb/session/pool/SessionPool.java", "diffHunk": "@@ -0,0 +1,670 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.session.pool;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentMap;\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.service.rpc.thrift.TSExecuteBatchStatementResp;\n+import org.apache.iotdb.service.rpc.thrift.TSStatus;\n+import org.apache.iotdb.session.Config;\n+import org.apache.iotdb.session.IoTDBSessionException;\n+import org.apache.iotdb.session.Session;\n+import org.apache.iotdb.session.SessionDataSet;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.write.record.RowBatch;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * SessionPool is a wrapper of a Session Set.\n+ * Using SessionPool, the user do not need to consider how to reuse a session connection.\n+ * Even if the session is disconnected, the session pool can recognize it and remove the borken\n+ * session connection and create a new one.\n+ *\n+ * If there is no available connections and the pool reaches its max size, the all methods will hang\n+ * until there is a available connection.\n+ *\n+ * If a user has waited for a session for more than 60 seconds, a warn log will be printed.\n+ *\n+ *\n+ * The only thing you have to remember is that:\n+ *\n+ * For a query, if you have get all data, i.e., SessionDataSetWrapper.hasNext() == false, it is ok.\n+ * Otherwise, i.e., you want to stop the query before you get all data (SessionDataSetWrapper.hasNext() == true),\n+ * then you have to call closeResultSet(SessionDataSetWrapper wrapper) manually.\n+ * Otherwise the connection is occupied by the query.\n+ *\n+ * Another case that you have to manually call closeResultSet() is that when there is exception\n+ * when you call SessionDataSetWrapper.hasNext() or next()\n+ *\n+ *\n+ */\n+public class SessionPool {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(SessionPool.class);\n+  private ConcurrentLinkedDeque<Session> queue = new ConcurrentLinkedDeque<>();\n+  //for session whose resultSet is not released.\n+  private ConcurrentMap<Session, Session> occupied = new ConcurrentHashMap<>();\n+\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize) {\n+    this(ip, port, user, password, maxSize, Config.DEFAULT_FETCH_SIZE);\n+  }\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize, int fetchSize) {\n+    this.maxSize = maxSize;\n+    this.ip = ip;\n+    this.port = port;\n+    this.user = user;\n+    this.password = password;\n+    this.fetchSize = fetchSize;\n+  }\n+\n+  private int size = 0;\n+  private int maxSize = 0;\n+  private String ip;\n+  private int port;\n+  private String user;\n+  private String password;\n+\n+  private int fetchSize;\n+\n+  //if this method throws an exception, either the server is broken, or the ip/port/user/password is incorrect.\n+  //TODO: we can add a mechanism that if the user waits too long time, throw exception.\n+  private Session getSession() throws IoTDBSessionException {\n+    Session session = queue.poll();\n+    if (session != null) {\n+      return session;\n+    } else {\n+      synchronized (this) {\n+        long start = System.currentTimeMillis();\n+        while (session == null) {\n+          if (size < maxSize) {\n+            //we can create more session\n+            size++;\n+            //but we do it after skip synchronized block because connection a session is time consuming.\n+            break;\n+          } else {\n+            //we have to wait for someone returns a session.\n+            try {\n+              this.wait(1000);\n+              if (System.currentTimeMillis() - start > 60_000) {\n+                logger.warn(\n+                    \"the SessionPool has wait for {} seconds to get a new connection: {}:{} with {}, {}\",\n+                    (System.currentTimeMillis() - start) / 1000, ip, port, user, password);\n+              }\n+            } catch (InterruptedException e) {\n+              logger.error(\"the SessionPool is damaged\", e);\n+              Thread.currentThread().interrupt();\n+            }\n+            session = queue.poll();\n+          }\n+        }\n+        if (session != null) {\n+          return session;\n+        }\n+      }\n+      if (logger.isDebugEnabled()) {\n+        logger.error(\"Create a new Session {}, {}, {}, {}\", ip, port, user, password);\n+      }\n+      session = new Session(ip, port, user, password, fetchSize);\n+      session.open();\n+      return session;\n+    }\n+  }\n+\n+  public int currentAvailableSize() {\n+    return queue.size();\n+  }\n+\n+  public int currentOccupiedSize() {\n+    return occupied.size();\n+  }\n+\n+  private void putBack(Session session) {\n+    queue.push(session);\n+    synchronized (this) {\n+      this.notifyAll();\n+    }\n+  }\n+\n+  private void occupy(Session session) {\n+    occupied.put(session, session);\n+  }\n+\n+  /**\n+   * close all connections in the pool\n+   */\n+  public synchronized void close() {\n+    for (Session session : queue) {\n+      try {\n+        session.close();\n+      } catch (IoTDBSessionException e) {\n+        //do nothing\n+      }\n+    }\n+    for (Session session : occupied.keySet()) {\n+      try {\n+        session.close();\n+      } catch (IoTDBSessionException e) {\n+        //do nothing\n+      }\n+    }\n+    queue.clear();\n+    occupied.clear();\n+  }\n+\n+  public void closeResultSet(SessionDataSetWrapper wrapper) throws SQLException {\n+    boolean putback = true;\n+    try {\n+      wrapper.sessionDataSet.closeOperationHandle();\n+    } catch (SQLException e) {\n+      if (e.getCause() instanceof TException) {\n+        // the connection is broken.\n+        removeSession();\n+        putback = false;\n+      } else {\n+        throw e;\n+      }\n+    } finally {\n+      Session session = occupied.remove(wrapper.session);\n+      if (putback && session != null) {\n+        putBack(wrapper.session);\n+      }\n+    }\n+  }\n+\n+  private synchronized void removeSession() {\n+    if (logger.isDebugEnabled()) {\n+      logger.error(\"Remove a broken Session {}, {}, {}, {}\", ip, port, user, password);\n+    }\n+    size--;\n+  }\n+\n+  private void closeSession(Session session) {\n+    if (session != null) {\n+      try {\n+        session.close();\n+      } catch (Exception e2) {\n+        //do nothing. We just want to guarantee the session is closed.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * use batch interface to insert sorted data times in row batch must be sorted before!\n+   *\n+   * @param rowBatch data batch\n+   */\n+  public TSExecuteBatchStatementResp insertSortedBatch(RowBatch rowBatch)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA1NjA4Mw=="}, "originalCommit": {"oid": "e7157addd0a53bf9cba3a4a20c7648d714ec2b8d"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDE0MDI4OnYy", "diffSide": "RIGHT", "path": "session/src/main/java/org/apache/iotdb/session/pool/SessionPool.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwMzowNzozNVrOFyFEdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwODoyMTo0NVrOFzNMNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA1NjE4MQ==", "bodyText": "get a new one?", "url": "https://github.com/apache/iotdb/pull/880#discussion_r388056181", "createdAt": "2020-03-05T03:07:35Z", "author": {"login": "qiaojialin"}, "path": "session/src/main/java/org/apache/iotdb/session/pool/SessionPool.java", "diffHunk": "@@ -0,0 +1,670 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.session.pool;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentMap;\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.service.rpc.thrift.TSExecuteBatchStatementResp;\n+import org.apache.iotdb.service.rpc.thrift.TSStatus;\n+import org.apache.iotdb.session.Config;\n+import org.apache.iotdb.session.IoTDBSessionException;\n+import org.apache.iotdb.session.Session;\n+import org.apache.iotdb.session.SessionDataSet;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.write.record.RowBatch;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * SessionPool is a wrapper of a Session Set.\n+ * Using SessionPool, the user do not need to consider how to reuse a session connection.\n+ * Even if the session is disconnected, the session pool can recognize it and remove the borken\n+ * session connection and create a new one.\n+ *\n+ * If there is no available connections and the pool reaches its max size, the all methods will hang\n+ * until there is a available connection.\n+ *\n+ * If a user has waited for a session for more than 60 seconds, a warn log will be printed.\n+ *\n+ *\n+ * The only thing you have to remember is that:\n+ *\n+ * For a query, if you have get all data, i.e., SessionDataSetWrapper.hasNext() == false, it is ok.\n+ * Otherwise, i.e., you want to stop the query before you get all data (SessionDataSetWrapper.hasNext() == true),\n+ * then you have to call closeResultSet(SessionDataSetWrapper wrapper) manually.\n+ * Otherwise the connection is occupied by the query.\n+ *\n+ * Another case that you have to manually call closeResultSet() is that when there is exception\n+ * when you call SessionDataSetWrapper.hasNext() or next()\n+ *\n+ *\n+ */\n+public class SessionPool {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(SessionPool.class);\n+  private ConcurrentLinkedDeque<Session> queue = new ConcurrentLinkedDeque<>();\n+  //for session whose resultSet is not released.\n+  private ConcurrentMap<Session, Session> occupied = new ConcurrentHashMap<>();\n+\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize) {\n+    this(ip, port, user, password, maxSize, Config.DEFAULT_FETCH_SIZE);\n+  }\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize, int fetchSize) {\n+    this.maxSize = maxSize;\n+    this.ip = ip;\n+    this.port = port;\n+    this.user = user;\n+    this.password = password;\n+    this.fetchSize = fetchSize;\n+  }\n+\n+  private int size = 0;\n+  private int maxSize = 0;\n+  private String ip;\n+  private int port;\n+  private String user;\n+  private String password;\n+\n+  private int fetchSize;\n+\n+  //if this method throws an exception, either the server is broken, or the ip/port/user/password is incorrect.\n+  //TODO: we can add a mechanism that if the user waits too long time, throw exception.\n+  private Session getSession() throws IoTDBSessionException {\n+    Session session = queue.poll();\n+    if (session != null) {\n+      return session;\n+    } else {\n+      synchronized (this) {\n+        long start = System.currentTimeMillis();\n+        while (session == null) {\n+          if (size < maxSize) {\n+            //we can create more session\n+            size++;\n+            //but we do it after skip synchronized block because connection a session is time consuming.\n+            break;\n+          } else {\n+            //we have to wait for someone returns a session.\n+            try {\n+              this.wait(1000);\n+              if (System.currentTimeMillis() - start > 60_000) {\n+                logger.warn(\n+                    \"the SessionPool has wait for {} seconds to get a new connection: {}:{} with {}, {}\",\n+                    (System.currentTimeMillis() - start) / 1000, ip, port, user, password);\n+              }\n+            } catch (InterruptedException e) {\n+              logger.error(\"the SessionPool is damaged\", e);\n+              Thread.currentThread().interrupt();\n+            }\n+            session = queue.poll();\n+          }\n+        }\n+        if (session != null) {\n+          return session;\n+        }\n+      }\n+      if (logger.isDebugEnabled()) {\n+        logger.error(\"Create a new Session {}, {}, {}, {}\", ip, port, user, password);\n+      }\n+      session = new Session(ip, port, user, password, fetchSize);\n+      session.open();\n+      return session;\n+    }\n+  }\n+\n+  public int currentAvailableSize() {\n+    return queue.size();\n+  }\n+\n+  public int currentOccupiedSize() {\n+    return occupied.size();\n+  }\n+\n+  private void putBack(Session session) {\n+    queue.push(session);\n+    synchronized (this) {\n+      this.notifyAll();\n+    }\n+  }\n+\n+  private void occupy(Session session) {\n+    occupied.put(session, session);\n+  }\n+\n+  /**\n+   * close all connections in the pool\n+   */\n+  public synchronized void close() {\n+    for (Session session : queue) {\n+      try {\n+        session.close();\n+      } catch (IoTDBSessionException e) {\n+        //do nothing\n+      }\n+    }\n+    for (Session session : occupied.keySet()) {\n+      try {\n+        session.close();\n+      } catch (IoTDBSessionException e) {\n+        //do nothing\n+      }\n+    }\n+    queue.clear();\n+    occupied.clear();\n+  }\n+\n+  public void closeResultSet(SessionDataSetWrapper wrapper) throws SQLException {\n+    boolean putback = true;\n+    try {\n+      wrapper.sessionDataSet.closeOperationHandle();\n+    } catch (SQLException e) {\n+      if (e.getCause() instanceof TException) {\n+        // the connection is broken.\n+        removeSession();\n+        putback = false;\n+      } else {\n+        throw e;\n+      }\n+    } finally {\n+      Session session = occupied.remove(wrapper.session);\n+      if (putback && session != null) {\n+        putBack(wrapper.session);\n+      }\n+    }\n+  }\n+\n+  private synchronized void removeSession() {\n+    if (logger.isDebugEnabled()) {\n+      logger.error(\"Remove a broken Session {}, {}, {}, {}\", ip, port, user, password);\n+    }\n+    size--;\n+  }\n+\n+  private void closeSession(Session session) {\n+    if (session != null) {\n+      try {\n+        session.close();\n+      } catch (Exception e2) {\n+        //do nothing. We just want to guarantee the session is closed.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * use batch interface to insert sorted data times in row batch must be sorted before!\n+   *\n+   * @param rowBatch data batch\n+   */\n+  public TSExecuteBatchStatementResp insertSortedBatch(RowBatch rowBatch)\n+      throws IoTDBSessionException {\n+    while (true) {\n+      Session session = getSession();\n+      try {\n+        TSExecuteBatchStatementResp resp = session.insertSortedBatch(rowBatch);\n+        putBack(session);\n+        return resp;\n+      } catch (IoTDBSessionException e) {\n+        if (e.getCause() instanceof TException) {\n+          // TException means the connection is broken, remove it and get a new one.\n+          closeSession(session);\n+          removeSession();\n+        } else {\n+          putBack(session);\n+          throw e;\n+        }\n+      }\n+    }\n+  }\n+\n+\n+\n+  /**\n+   * use batch interface to insert data\n+   *\n+   * @param rowBatch data batch\n+   */\n+  public TSExecuteBatchStatementResp insertBatch(RowBatch rowBatch) throws IoTDBSessionException {\n+    while (true) {\n+      Session session = getSession();\n+      try {\n+        TSExecuteBatchStatementResp resp = session.insertBatch(rowBatch);\n+        putBack(session);\n+        return resp;\n+      } catch (IoTDBSessionException e) {\n+        if (e.getCause() instanceof TException) {\n+          // TException means the connection is broken, remove it and get a new one.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7157addd0a53bf9cba3a4a20c7648d714ec2b8d"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNzgxNA==", "bodyText": "will fix.", "url": "https://github.com/apache/iotdb/pull/880#discussion_r389237814", "createdAt": "2020-03-07T08:21:45Z", "author": {"login": "jixuan1989"}, "path": "session/src/main/java/org/apache/iotdb/session/pool/SessionPool.java", "diffHunk": "@@ -0,0 +1,670 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.session.pool;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentMap;\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.service.rpc.thrift.TSExecuteBatchStatementResp;\n+import org.apache.iotdb.service.rpc.thrift.TSStatus;\n+import org.apache.iotdb.session.Config;\n+import org.apache.iotdb.session.IoTDBSessionException;\n+import org.apache.iotdb.session.Session;\n+import org.apache.iotdb.session.SessionDataSet;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.write.record.RowBatch;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * SessionPool is a wrapper of a Session Set.\n+ * Using SessionPool, the user do not need to consider how to reuse a session connection.\n+ * Even if the session is disconnected, the session pool can recognize it and remove the borken\n+ * session connection and create a new one.\n+ *\n+ * If there is no available connections and the pool reaches its max size, the all methods will hang\n+ * until there is a available connection.\n+ *\n+ * If a user has waited for a session for more than 60 seconds, a warn log will be printed.\n+ *\n+ *\n+ * The only thing you have to remember is that:\n+ *\n+ * For a query, if you have get all data, i.e., SessionDataSetWrapper.hasNext() == false, it is ok.\n+ * Otherwise, i.e., you want to stop the query before you get all data (SessionDataSetWrapper.hasNext() == true),\n+ * then you have to call closeResultSet(SessionDataSetWrapper wrapper) manually.\n+ * Otherwise the connection is occupied by the query.\n+ *\n+ * Another case that you have to manually call closeResultSet() is that when there is exception\n+ * when you call SessionDataSetWrapper.hasNext() or next()\n+ *\n+ *\n+ */\n+public class SessionPool {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(SessionPool.class);\n+  private ConcurrentLinkedDeque<Session> queue = new ConcurrentLinkedDeque<>();\n+  //for session whose resultSet is not released.\n+  private ConcurrentMap<Session, Session> occupied = new ConcurrentHashMap<>();\n+\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize) {\n+    this(ip, port, user, password, maxSize, Config.DEFAULT_FETCH_SIZE);\n+  }\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize, int fetchSize) {\n+    this.maxSize = maxSize;\n+    this.ip = ip;\n+    this.port = port;\n+    this.user = user;\n+    this.password = password;\n+    this.fetchSize = fetchSize;\n+  }\n+\n+  private int size = 0;\n+  private int maxSize = 0;\n+  private String ip;\n+  private int port;\n+  private String user;\n+  private String password;\n+\n+  private int fetchSize;\n+\n+  //if this method throws an exception, either the server is broken, or the ip/port/user/password is incorrect.\n+  //TODO: we can add a mechanism that if the user waits too long time, throw exception.\n+  private Session getSession() throws IoTDBSessionException {\n+    Session session = queue.poll();\n+    if (session != null) {\n+      return session;\n+    } else {\n+      synchronized (this) {\n+        long start = System.currentTimeMillis();\n+        while (session == null) {\n+          if (size < maxSize) {\n+            //we can create more session\n+            size++;\n+            //but we do it after skip synchronized block because connection a session is time consuming.\n+            break;\n+          } else {\n+            //we have to wait for someone returns a session.\n+            try {\n+              this.wait(1000);\n+              if (System.currentTimeMillis() - start > 60_000) {\n+                logger.warn(\n+                    \"the SessionPool has wait for {} seconds to get a new connection: {}:{} with {}, {}\",\n+                    (System.currentTimeMillis() - start) / 1000, ip, port, user, password);\n+              }\n+            } catch (InterruptedException e) {\n+              logger.error(\"the SessionPool is damaged\", e);\n+              Thread.currentThread().interrupt();\n+            }\n+            session = queue.poll();\n+          }\n+        }\n+        if (session != null) {\n+          return session;\n+        }\n+      }\n+      if (logger.isDebugEnabled()) {\n+        logger.error(\"Create a new Session {}, {}, {}, {}\", ip, port, user, password);\n+      }\n+      session = new Session(ip, port, user, password, fetchSize);\n+      session.open();\n+      return session;\n+    }\n+  }\n+\n+  public int currentAvailableSize() {\n+    return queue.size();\n+  }\n+\n+  public int currentOccupiedSize() {\n+    return occupied.size();\n+  }\n+\n+  private void putBack(Session session) {\n+    queue.push(session);\n+    synchronized (this) {\n+      this.notifyAll();\n+    }\n+  }\n+\n+  private void occupy(Session session) {\n+    occupied.put(session, session);\n+  }\n+\n+  /**\n+   * close all connections in the pool\n+   */\n+  public synchronized void close() {\n+    for (Session session : queue) {\n+      try {\n+        session.close();\n+      } catch (IoTDBSessionException e) {\n+        //do nothing\n+      }\n+    }\n+    for (Session session : occupied.keySet()) {\n+      try {\n+        session.close();\n+      } catch (IoTDBSessionException e) {\n+        //do nothing\n+      }\n+    }\n+    queue.clear();\n+    occupied.clear();\n+  }\n+\n+  public void closeResultSet(SessionDataSetWrapper wrapper) throws SQLException {\n+    boolean putback = true;\n+    try {\n+      wrapper.sessionDataSet.closeOperationHandle();\n+    } catch (SQLException e) {\n+      if (e.getCause() instanceof TException) {\n+        // the connection is broken.\n+        removeSession();\n+        putback = false;\n+      } else {\n+        throw e;\n+      }\n+    } finally {\n+      Session session = occupied.remove(wrapper.session);\n+      if (putback && session != null) {\n+        putBack(wrapper.session);\n+      }\n+    }\n+  }\n+\n+  private synchronized void removeSession() {\n+    if (logger.isDebugEnabled()) {\n+      logger.error(\"Remove a broken Session {}, {}, {}, {}\", ip, port, user, password);\n+    }\n+    size--;\n+  }\n+\n+  private void closeSession(Session session) {\n+    if (session != null) {\n+      try {\n+        session.close();\n+      } catch (Exception e2) {\n+        //do nothing. We just want to guarantee the session is closed.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * use batch interface to insert sorted data times in row batch must be sorted before!\n+   *\n+   * @param rowBatch data batch\n+   */\n+  public TSExecuteBatchStatementResp insertSortedBatch(RowBatch rowBatch)\n+      throws IoTDBSessionException {\n+    while (true) {\n+      Session session = getSession();\n+      try {\n+        TSExecuteBatchStatementResp resp = session.insertSortedBatch(rowBatch);\n+        putBack(session);\n+        return resp;\n+      } catch (IoTDBSessionException e) {\n+        if (e.getCause() instanceof TException) {\n+          // TException means the connection is broken, remove it and get a new one.\n+          closeSession(session);\n+          removeSession();\n+        } else {\n+          putBack(session);\n+          throw e;\n+        }\n+      }\n+    }\n+  }\n+\n+\n+\n+  /**\n+   * use batch interface to insert data\n+   *\n+   * @param rowBatch data batch\n+   */\n+  public TSExecuteBatchStatementResp insertBatch(RowBatch rowBatch) throws IoTDBSessionException {\n+    while (true) {\n+      Session session = getSession();\n+      try {\n+        TSExecuteBatchStatementResp resp = session.insertBatch(rowBatch);\n+        putBack(session);\n+        return resp;\n+      } catch (IoTDBSessionException e) {\n+        if (e.getCause() instanceof TException) {\n+          // TException means the connection is broken, remove it and get a new one.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA1NjE4MQ=="}, "originalCommit": {"oid": "e7157addd0a53bf9cba3a4a20c7648d714ec2b8d"}, "originalPosition": 259}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 281, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}