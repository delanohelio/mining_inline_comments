{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ1ODkxOTA2", "number": 2353, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwNzowMDo0NFrOFJ8tVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQwMToyMTozN1rOFRr4AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1OTc2MTUxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwNzowMDo0NFrOIMfNCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwNzoxNjowMFrOIMf3Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk2NTA2NA==", "bodyText": "Should consider carefully whether workSequenceTsFileProcessors (The tsFileProcessorTreeMap in this method) is thread safety.", "url": "https://github.com/apache/iotdb/pull/2353#discussion_r549965064", "createdAt": "2020-12-30T07:00:44Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -969,35 +969,35 @@ private TsFileProcessor getOrCreateTsFileProcessorIntern(long timeRangeId,\n       boolean sequence)\n       throws IOException, DiskSpaceInsufficientException {\n \n-    TsFileProcessor res;\n-    // we have to ensure only one thread can change workSequenceTsFileProcessors\n-    writeLock();\n-    try {\n-      res = tsFileProcessorTreeMap.get(timeRangeId);\n-      if (res == null) {\n-        // we have to remove oldest processor to control the num of the memtables\n-        // TODO: use a method to control the number of memtables\n-        if (tsFileProcessorTreeMap.size()\n-            >= IoTDBDescriptor.getInstance().getConfig().getConcurrentWritingTimePartition()) {\n-          Map.Entry<Long, TsFileProcessor> processorEntry = tsFileProcessorTreeMap.firstEntry();\n-          logger.info(\n-              \"will close a {} TsFile because too many active partitions ({} > {}) in the storage group {},\",\n-              sequence, tsFileProcessorTreeMap.size(),\n-              IoTDBDescriptor.getInstance().getConfig().getConcurrentWritingTimePartition(),\n-              storageGroupName);\n-          asyncCloseOneTsFileProcessor(sequence, processorEntry.getValue());\n-        }\n+    TsFileProcessor res = tsFileProcessorTreeMap.get(timeRangeId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495cb3625cec1f4f0722f25171b761b383e664cb"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk3NTg5MA==", "bodyText": "Method getOrCreateTsFileProcessorIntern is called by getOrCreateTsFileProcessor which ready guard by lock in StorageGroupProcessor,  this method in fact is trying to get the same lock again", "url": "https://github.com/apache/iotdb/pull/2353#discussion_r549975890", "createdAt": "2020-12-30T07:16:00Z", "author": {"login": "yuqi1129"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -969,35 +969,35 @@ private TsFileProcessor getOrCreateTsFileProcessorIntern(long timeRangeId,\n       boolean sequence)\n       throws IOException, DiskSpaceInsufficientException {\n \n-    TsFileProcessor res;\n-    // we have to ensure only one thread can change workSequenceTsFileProcessors\n-    writeLock();\n-    try {\n-      res = tsFileProcessorTreeMap.get(timeRangeId);\n-      if (res == null) {\n-        // we have to remove oldest processor to control the num of the memtables\n-        // TODO: use a method to control the number of memtables\n-        if (tsFileProcessorTreeMap.size()\n-            >= IoTDBDescriptor.getInstance().getConfig().getConcurrentWritingTimePartition()) {\n-          Map.Entry<Long, TsFileProcessor> processorEntry = tsFileProcessorTreeMap.firstEntry();\n-          logger.info(\n-              \"will close a {} TsFile because too many active partitions ({} > {}) in the storage group {},\",\n-              sequence, tsFileProcessorTreeMap.size(),\n-              IoTDBDescriptor.getInstance().getConfig().getConcurrentWritingTimePartition(),\n-              storageGroupName);\n-          asyncCloseOneTsFileProcessor(sequence, processorEntry.getValue());\n-        }\n+    TsFileProcessor res = tsFileProcessorTreeMap.get(timeRangeId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk2NTA2NA=="}, "originalCommit": {"oid": "495cb3625cec1f4f0722f25171b761b383e664cb"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1OTg0MTgyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwNzoxOTozM1rOIMgBUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwNzoyNDozM1rOIMgPgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk3ODQ0OA==", "bodyText": "newTsFileProcess() is better.\nAnd,  I think the following should also be in the method.\n    tsFileProcessor.addCloseFileListeners(customCloseFileListeners);\n    tsFileProcessor.addFlushListeners(customFlushListeners);\n\n    tsFileProcessor.setTimeRangeId(timePartitionId);", "url": "https://github.com/apache/iotdb/pull/2353#discussion_r549978448", "createdAt": "2020-12-30T07:19:33Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1006,50 +1006,49 @@ private TsFileProcessor getOrCreateTsFileProcessorIntern(long timeRangeId,\n \n   private TsFileProcessor createTsFileProcessor(boolean sequence, long timePartitionId)\n       throws IOException, DiskSpaceInsufficientException {\n-    String baseDir;\n-    if (sequence) {\n-      baseDir = DirectoryManager.getInstance().getNextFolderForSequenceFile();\n-    } else {\n-      baseDir = DirectoryManager.getInstance().getNextFolderForUnSequenceFile();\n-    }\n+    DirectoryManager directoryManager = DirectoryManager.getInstance();\n+    String baseDir = sequence ? directoryManager.getNextFolderForSequenceFile()\n+        : directoryManager.getNextFolderForUnSequenceFile();\n+\n     fsFactory.getFile(baseDir, storageGroupName).mkdirs();\n \n     String filePath =\n         baseDir + File.separator + storageGroupName + File.separator + timePartitionId\n             + File.separator\n             + getNewTsFileName(timePartitionId);\n \n-    TsFileProcessor tsFileProcessor;\n     VersionController versionController = getVersionControllerByTimePartitionId(timePartitionId);\n+    TsFileProcessor tsFileProcessor = getTsFileProcessor(sequence, filePath, versionController);\n+    tsFileProcessor.addCloseFileListeners(customCloseFileListeners);\n+    tsFileProcessor.addFlushListeners(customFlushListeners);\n+\n+    tsFileProcessor.setTimeRangeId(timePartitionId);\n+    return tsFileProcessor;\n+  }\n+\n+  private TsFileProcessor getTsFileProcessor(boolean sequence, String filePath,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495cb3625cec1f4f0722f25171b761b383e664cb"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk4MjA4MQ==", "bodyText": "Good idea, i will follow your suggestion", "url": "https://github.com/apache/iotdb/pull/2353#discussion_r549982081", "createdAt": "2020-12-30T07:24:33Z", "author": {"login": "yuqi1129"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1006,50 +1006,49 @@ private TsFileProcessor getOrCreateTsFileProcessorIntern(long timeRangeId,\n \n   private TsFileProcessor createTsFileProcessor(boolean sequence, long timePartitionId)\n       throws IOException, DiskSpaceInsufficientException {\n-    String baseDir;\n-    if (sequence) {\n-      baseDir = DirectoryManager.getInstance().getNextFolderForSequenceFile();\n-    } else {\n-      baseDir = DirectoryManager.getInstance().getNextFolderForUnSequenceFile();\n-    }\n+    DirectoryManager directoryManager = DirectoryManager.getInstance();\n+    String baseDir = sequence ? directoryManager.getNextFolderForSequenceFile()\n+        : directoryManager.getNextFolderForUnSequenceFile();\n+\n     fsFactory.getFile(baseDir, storageGroupName).mkdirs();\n \n     String filePath =\n         baseDir + File.separator + storageGroupName + File.separator + timePartitionId\n             + File.separator\n             + getNewTsFileName(timePartitionId);\n \n-    TsFileProcessor tsFileProcessor;\n     VersionController versionController = getVersionControllerByTimePartitionId(timePartitionId);\n+    TsFileProcessor tsFileProcessor = getTsFileProcessor(sequence, filePath, versionController);\n+    tsFileProcessor.addCloseFileListeners(customCloseFileListeners);\n+    tsFileProcessor.addFlushListeners(customFlushListeners);\n+\n+    tsFileProcessor.setTimeRangeId(timePartitionId);\n+    return tsFileProcessor;\n+  }\n+\n+  private TsFileProcessor getTsFileProcessor(boolean sequence, String filePath,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk3ODQ0OA=="}, "originalCommit": {"oid": "495cb3625cec1f4f0722f25171b761b383e664cb"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0MDg4OTYwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQwMToyMTozN1rOIYQhoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQwMTo1MTo1MFrOIYRGLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjMwNzQ4OQ==", "bodyText": "As you say, outer code has lock this write lock. How come you lock it twice?  May be this lock op can also be removed.", "url": "https://github.com/apache/iotdb/pull/2353#discussion_r562307489", "createdAt": "2021-01-22T01:21:37Z", "author": {"login": "SilverNarcissus"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -969,87 +969,86 @@ private TsFileProcessor getOrCreateTsFileProcessorIntern(long timeRangeId,\n       boolean sequence)\n       throws IOException, DiskSpaceInsufficientException {\n \n-    TsFileProcessor res;\n-    // we have to ensure only one thread can change workSequenceTsFileProcessors\n-    writeLock();\n-    try {\n-      res = tsFileProcessorTreeMap.get(timeRangeId);\n-      if (res == null) {\n-        // we have to remove oldest processor to control the num of the memtables\n-        // TODO: use a method to control the number of memtables\n-        if (tsFileProcessorTreeMap.size()\n-            >= IoTDBDescriptor.getInstance().getConfig().getConcurrentWritingTimePartition()) {\n-          Map.Entry<Long, TsFileProcessor> processorEntry = tsFileProcessorTreeMap.firstEntry();\n-          logger.info(\n-              \"will close a {} TsFile because too many active partitions ({} > {}) in the storage group {},\",\n-              sequence, tsFileProcessorTreeMap.size(),\n-              IoTDBDescriptor.getInstance().getConfig().getConcurrentWritingTimePartition(),\n-              storageGroupName);\n-          asyncCloseOneTsFileProcessor(sequence, processorEntry.getValue());\n-        }\n+    TsFileProcessor res = tsFileProcessorTreeMap.get(timeRangeId);\n \n-        // build new processor\n-        TsFileProcessor newProcessor = createTsFileProcessor(sequence, timeRangeId);\n-        tsFileProcessorTreeMap.put(timeRangeId, newProcessor);\n-        tsFileManagement.add(newProcessor.getTsFileResource(), sequence);\n-        res = newProcessor;\n-      }\n+    //Use double-check to shorten the lock range\n+    if (null == res) {\n+      writeLock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eb1fc66fe4c23ddcf916bdec9decfb1df5cc959"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjMxNjg0NA==", "bodyText": "Yes, further optimization about the lock can be made, i will remove related duplication code later, thanks", "url": "https://github.com/apache/iotdb/pull/2353#discussion_r562316844", "createdAt": "2021-01-22T01:51:50Z", "author": {"login": "yuqi1129"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -969,87 +969,86 @@ private TsFileProcessor getOrCreateTsFileProcessorIntern(long timeRangeId,\n       boolean sequence)\n       throws IOException, DiskSpaceInsufficientException {\n \n-    TsFileProcessor res;\n-    // we have to ensure only one thread can change workSequenceTsFileProcessors\n-    writeLock();\n-    try {\n-      res = tsFileProcessorTreeMap.get(timeRangeId);\n-      if (res == null) {\n-        // we have to remove oldest processor to control the num of the memtables\n-        // TODO: use a method to control the number of memtables\n-        if (tsFileProcessorTreeMap.size()\n-            >= IoTDBDescriptor.getInstance().getConfig().getConcurrentWritingTimePartition()) {\n-          Map.Entry<Long, TsFileProcessor> processorEntry = tsFileProcessorTreeMap.firstEntry();\n-          logger.info(\n-              \"will close a {} TsFile because too many active partitions ({} > {}) in the storage group {},\",\n-              sequence, tsFileProcessorTreeMap.size(),\n-              IoTDBDescriptor.getInstance().getConfig().getConcurrentWritingTimePartition(),\n-              storageGroupName);\n-          asyncCloseOneTsFileProcessor(sequence, processorEntry.getValue());\n-        }\n+    TsFileProcessor res = tsFileProcessorTreeMap.get(timeRangeId);\n \n-        // build new processor\n-        TsFileProcessor newProcessor = createTsFileProcessor(sequence, timeRangeId);\n-        tsFileProcessorTreeMap.put(timeRangeId, newProcessor);\n-        tsFileManagement.add(newProcessor.getTsFileResource(), sequence);\n-        res = newProcessor;\n-      }\n+    //Use double-check to shorten the lock range\n+    if (null == res) {\n+      writeLock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjMwNzQ4OQ=="}, "originalCommit": {"oid": "9eb1fc66fe4c23ddcf916bdec9decfb1df5cc959"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 484, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}