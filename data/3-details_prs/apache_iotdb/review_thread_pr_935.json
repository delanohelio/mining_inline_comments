{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyMjkzODU1", "number": 935, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMjowNToxNFrODqno4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNTo1ODowN1rODq26bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDE2MjI1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMjowNToxNFrOF6emKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMzo0OToxM1rOF6gHuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2MzAxOA==", "bodyText": "All devices in A are newer than those in B.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396863018", "createdAt": "2020-03-24T02:05:14Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1638,12 +1646,98 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n     }\n   }\n \n+  /**\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n+   * @param newTsFileResource\n+   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n+   *         POS_OVERLAP(-3) if some file overlaps the new file\n+   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   */\n+  private int findInsertionPosition(TsFileResource newTsFileResource) {\n+    File tsfileToBeInserted = newTsFileResource.getFile();\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    int insertPos = -1;\n+\n+    List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n+    // find the position where the new file should be inserted\n+    for (int i = 0; i < sequenceList.size(); i++) {\n+      TsFileResource localFile = sequenceList.get(i);\n+      if (localFile.getFile().getName().equals(tsfileToBeInserted.getName())) {\n+        return POS_ALREADY_EXIST;\n+      }\n+      long localPartitionId = Long.parseLong(localFile.getFile().getParent());\n+      if (i == sequenceList.size() - 1 && localFile.getEndTimeMap().isEmpty()\n+          || newFilePartitionId != localPartitionId) {\n+        // skip files that are not in the partition as the new file and the last empty file\n+        continue;\n+      }\n+\n+      int fileComparison = compareTsFileDevices(newTsFileResource, localFile);\n+      switch (fileComparison) {\n+        case 0:\n+          // some devices are newer but some devices are older, the two files overlap in general\n+          return POS_OVERLAP;\n+        case -1:\n+          // all devices in the local file are newer than the new file, the new file can be\n+          // inserted before the new file\n+          return i - 1;\n+        default:\n+          // all devices in the local file are older than the new file, proceed to the next file\n+          insertPos = i;\n+      }\n+    }\n+    return insertPos;\n+  }\n+\n+  /**\n+   * Compare each device in the two files to find the time relation of them.\n+   * @param fileA\n+   * @param fileB\n+   * @return -1 if fileA is totally older than fileB (A < B)\n+   *          0 if fileA is partially older than fileB and partially newer than fileB (A X B)\n+   *          1 if fileA is totally newer than fileB (B < A)\n+   */\n+  private int compareTsFileDevices(TsFileResource fileA, TsFileResource fileB) {\n+    boolean hasPre = false, hasSubsequence = false;\n+    for (String device : fileA.getStartTimeMap().keySet()) {\n+      if (!fileB.getStartTimeMap().containsKey(device)) {\n+        continue;\n+      }\n+      long startTimeA = fileA.getStartTimeMap().get(device);\n+      long endTimeA = fileA.getEndTimeMap().get(device);\n+      long startTimeB = fileB.getStartTimeMap().get(device);\n+      long endTimeB = fileB.getEndTimeMap().get(device);\n+      if (startTimeA > endTimeB) {\n+        // A's data of the device is later than to the B's data\n+        hasSubsequence = true;\n+      } else if (startTimeB > endTimeA) {\n+        // A's data of the device is previous to the B's data\n+        hasPre = true;\n+      } else {\n+        // the two files overlap in the device\n+        return 0;\n+      }\n+    }\n+    if (hasPre && hasSubsequence) {\n+      // some devices are newer but some devices are older, the two files overlap in general\n+      return 0;\n+    }\n+    if (!hasPre && hasSubsequence) {\n+      // all devices in B are newer than those in A", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 412}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4Nzk5Mw==", "bodyText": "I have changed the assignments of hasPre and hasSubsequence, now hasPre means \"B has previous data to A\", so this should remain.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396887993", "createdAt": "2020-03-24T03:49:13Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1638,12 +1646,98 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n     }\n   }\n \n+  /**\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n+   * @param newTsFileResource\n+   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n+   *         POS_OVERLAP(-3) if some file overlaps the new file\n+   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   */\n+  private int findInsertionPosition(TsFileResource newTsFileResource) {\n+    File tsfileToBeInserted = newTsFileResource.getFile();\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    int insertPos = -1;\n+\n+    List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n+    // find the position where the new file should be inserted\n+    for (int i = 0; i < sequenceList.size(); i++) {\n+      TsFileResource localFile = sequenceList.get(i);\n+      if (localFile.getFile().getName().equals(tsfileToBeInserted.getName())) {\n+        return POS_ALREADY_EXIST;\n+      }\n+      long localPartitionId = Long.parseLong(localFile.getFile().getParent());\n+      if (i == sequenceList.size() - 1 && localFile.getEndTimeMap().isEmpty()\n+          || newFilePartitionId != localPartitionId) {\n+        // skip files that are not in the partition as the new file and the last empty file\n+        continue;\n+      }\n+\n+      int fileComparison = compareTsFileDevices(newTsFileResource, localFile);\n+      switch (fileComparison) {\n+        case 0:\n+          // some devices are newer but some devices are older, the two files overlap in general\n+          return POS_OVERLAP;\n+        case -1:\n+          // all devices in the local file are newer than the new file, the new file can be\n+          // inserted before the new file\n+          return i - 1;\n+        default:\n+          // all devices in the local file are older than the new file, proceed to the next file\n+          insertPos = i;\n+      }\n+    }\n+    return insertPos;\n+  }\n+\n+  /**\n+   * Compare each device in the two files to find the time relation of them.\n+   * @param fileA\n+   * @param fileB\n+   * @return -1 if fileA is totally older than fileB (A < B)\n+   *          0 if fileA is partially older than fileB and partially newer than fileB (A X B)\n+   *          1 if fileA is totally newer than fileB (B < A)\n+   */\n+  private int compareTsFileDevices(TsFileResource fileA, TsFileResource fileB) {\n+    boolean hasPre = false, hasSubsequence = false;\n+    for (String device : fileA.getStartTimeMap().keySet()) {\n+      if (!fileB.getStartTimeMap().containsKey(device)) {\n+        continue;\n+      }\n+      long startTimeA = fileA.getStartTimeMap().get(device);\n+      long endTimeA = fileA.getEndTimeMap().get(device);\n+      long startTimeB = fileB.getStartTimeMap().get(device);\n+      long endTimeB = fileB.getEndTimeMap().get(device);\n+      if (startTimeA > endTimeB) {\n+        // A's data of the device is later than to the B's data\n+        hasSubsequence = true;\n+      } else if (startTimeB > endTimeA) {\n+        // A's data of the device is previous to the B's data\n+        hasPre = true;\n+      } else {\n+        // the two files overlap in the device\n+        return 0;\n+      }\n+    }\n+    if (hasPre && hasSubsequence) {\n+      // some devices are newer but some devices are older, the two files overlap in general\n+      return 0;\n+    }\n+    if (!hasPre && hasSubsequence) {\n+      // all devices in B are newer than those in A", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2MzAxOA=="}, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 412}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDE2MjYyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMjowNToyNFrOF6emYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMzo0OToxOVrOF6gHzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2MzA3NA==", "bodyText": "All devices in A are older than those in B.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396863074", "createdAt": "2020-03-24T02:05:24Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1638,12 +1646,98 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n     }\n   }\n \n+  /**\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n+   * @param newTsFileResource\n+   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n+   *         POS_OVERLAP(-3) if some file overlaps the new file\n+   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   */\n+  private int findInsertionPosition(TsFileResource newTsFileResource) {\n+    File tsfileToBeInserted = newTsFileResource.getFile();\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    int insertPos = -1;\n+\n+    List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n+    // find the position where the new file should be inserted\n+    for (int i = 0; i < sequenceList.size(); i++) {\n+      TsFileResource localFile = sequenceList.get(i);\n+      if (localFile.getFile().getName().equals(tsfileToBeInserted.getName())) {\n+        return POS_ALREADY_EXIST;\n+      }\n+      long localPartitionId = Long.parseLong(localFile.getFile().getParent());\n+      if (i == sequenceList.size() - 1 && localFile.getEndTimeMap().isEmpty()\n+          || newFilePartitionId != localPartitionId) {\n+        // skip files that are not in the partition as the new file and the last empty file\n+        continue;\n+      }\n+\n+      int fileComparison = compareTsFileDevices(newTsFileResource, localFile);\n+      switch (fileComparison) {\n+        case 0:\n+          // some devices are newer but some devices are older, the two files overlap in general\n+          return POS_OVERLAP;\n+        case -1:\n+          // all devices in the local file are newer than the new file, the new file can be\n+          // inserted before the new file\n+          return i - 1;\n+        default:\n+          // all devices in the local file are older than the new file, proceed to the next file\n+          insertPos = i;\n+      }\n+    }\n+    return insertPos;\n+  }\n+\n+  /**\n+   * Compare each device in the two files to find the time relation of them.\n+   * @param fileA\n+   * @param fileB\n+   * @return -1 if fileA is totally older than fileB (A < B)\n+   *          0 if fileA is partially older than fileB and partially newer than fileB (A X B)\n+   *          1 if fileA is totally newer than fileB (B < A)\n+   */\n+  private int compareTsFileDevices(TsFileResource fileA, TsFileResource fileB) {\n+    boolean hasPre = false, hasSubsequence = false;\n+    for (String device : fileA.getStartTimeMap().keySet()) {\n+      if (!fileB.getStartTimeMap().containsKey(device)) {\n+        continue;\n+      }\n+      long startTimeA = fileA.getStartTimeMap().get(device);\n+      long endTimeA = fileA.getEndTimeMap().get(device);\n+      long startTimeB = fileB.getStartTimeMap().get(device);\n+      long endTimeB = fileB.getEndTimeMap().get(device);\n+      if (startTimeA > endTimeB) {\n+        // A's data of the device is later than to the B's data\n+        hasSubsequence = true;\n+      } else if (startTimeB > endTimeA) {\n+        // A's data of the device is previous to the B's data\n+        hasPre = true;\n+      } else {\n+        // the two files overlap in the device\n+        return 0;\n+      }\n+    }\n+    if (hasPre && hasSubsequence) {\n+      // some devices are newer but some devices are older, the two files overlap in general\n+      return 0;\n+    }\n+    if (!hasPre && hasSubsequence) {\n+      // all devices in B are newer than those in A\n+      return -1;\n+    }\n+    // all devices in B are older than those in A", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 415}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4ODAxMg==", "bodyText": "See above.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396888012", "createdAt": "2020-03-24T03:49:19Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1638,12 +1646,98 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n     }\n   }\n \n+  /**\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n+   * @param newTsFileResource\n+   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n+   *         POS_OVERLAP(-3) if some file overlaps the new file\n+   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   */\n+  private int findInsertionPosition(TsFileResource newTsFileResource) {\n+    File tsfileToBeInserted = newTsFileResource.getFile();\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    int insertPos = -1;\n+\n+    List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n+    // find the position where the new file should be inserted\n+    for (int i = 0; i < sequenceList.size(); i++) {\n+      TsFileResource localFile = sequenceList.get(i);\n+      if (localFile.getFile().getName().equals(tsfileToBeInserted.getName())) {\n+        return POS_ALREADY_EXIST;\n+      }\n+      long localPartitionId = Long.parseLong(localFile.getFile().getParent());\n+      if (i == sequenceList.size() - 1 && localFile.getEndTimeMap().isEmpty()\n+          || newFilePartitionId != localPartitionId) {\n+        // skip files that are not in the partition as the new file and the last empty file\n+        continue;\n+      }\n+\n+      int fileComparison = compareTsFileDevices(newTsFileResource, localFile);\n+      switch (fileComparison) {\n+        case 0:\n+          // some devices are newer but some devices are older, the two files overlap in general\n+          return POS_OVERLAP;\n+        case -1:\n+          // all devices in the local file are newer than the new file, the new file can be\n+          // inserted before the new file\n+          return i - 1;\n+        default:\n+          // all devices in the local file are older than the new file, proceed to the next file\n+          insertPos = i;\n+      }\n+    }\n+    return insertPos;\n+  }\n+\n+  /**\n+   * Compare each device in the two files to find the time relation of them.\n+   * @param fileA\n+   * @param fileB\n+   * @return -1 if fileA is totally older than fileB (A < B)\n+   *          0 if fileA is partially older than fileB and partially newer than fileB (A X B)\n+   *          1 if fileA is totally newer than fileB (B < A)\n+   */\n+  private int compareTsFileDevices(TsFileResource fileA, TsFileResource fileB) {\n+    boolean hasPre = false, hasSubsequence = false;\n+    for (String device : fileA.getStartTimeMap().keySet()) {\n+      if (!fileB.getStartTimeMap().containsKey(device)) {\n+        continue;\n+      }\n+      long startTimeA = fileA.getStartTimeMap().get(device);\n+      long endTimeA = fileA.getEndTimeMap().get(device);\n+      long startTimeB = fileB.getStartTimeMap().get(device);\n+      long endTimeB = fileB.getEndTimeMap().get(device);\n+      if (startTimeA > endTimeB) {\n+        // A's data of the device is later than to the B's data\n+        hasSubsequence = true;\n+      } else if (startTimeB > endTimeA) {\n+        // A's data of the device is previous to the B's data\n+        hasPre = true;\n+      } else {\n+        // the two files overlap in the device\n+        return 0;\n+      }\n+    }\n+    if (hasPre && hasSubsequence) {\n+      // some devices are newer but some devices are older, the two files overlap in general\n+      return 0;\n+    }\n+    if (!hasPre && hasSubsequence) {\n+      // all devices in B are newer than those in A\n+      return -1;\n+    }\n+    // all devices in B are older than those in A", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2MzA3NA=="}, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 415}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDE3MjUyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMjoxMjoxOFrOF6esuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMzo1MTowNFrOF6gJLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2NDY5Nw==", "bodyText": "case 1:", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396864697", "createdAt": "2020-03-24T02:12:18Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1638,12 +1646,98 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n     }\n   }\n \n+  /**\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n+   * @param newTsFileResource\n+   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n+   *         POS_OVERLAP(-3) if some file overlaps the new file\n+   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   */\n+  private int findInsertionPosition(TsFileResource newTsFileResource) {\n+    File tsfileToBeInserted = newTsFileResource.getFile();\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    int insertPos = -1;\n+\n+    List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n+    // find the position where the new file should be inserted\n+    for (int i = 0; i < sequenceList.size(); i++) {\n+      TsFileResource localFile = sequenceList.get(i);\n+      if (localFile.getFile().getName().equals(tsfileToBeInserted.getName())) {\n+        return POS_ALREADY_EXIST;\n+      }\n+      long localPartitionId = Long.parseLong(localFile.getFile().getParent());\n+      if (i == sequenceList.size() - 1 && localFile.getEndTimeMap().isEmpty()\n+          || newFilePartitionId != localPartitionId) {\n+        // skip files that are not in the partition as the new file and the last empty file\n+        continue;\n+      }\n+\n+      int fileComparison = compareTsFileDevices(newTsFileResource, localFile);\n+      switch (fileComparison) {\n+        case 0:\n+          // some devices are newer but some devices are older, the two files overlap in general\n+          return POS_OVERLAP;\n+        case -1:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 366}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4ODM2Ng==", "bodyText": "I believe it should be -1, which means data in the new file has smaller timestamps than the local file, so we can insert the new file before the local file.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396888366", "createdAt": "2020-03-24T03:51:04Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1638,12 +1646,98 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n     }\n   }\n \n+  /**\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n+   * @param newTsFileResource\n+   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n+   *         POS_OVERLAP(-3) if some file overlaps the new file\n+   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   */\n+  private int findInsertionPosition(TsFileResource newTsFileResource) {\n+    File tsfileToBeInserted = newTsFileResource.getFile();\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    int insertPos = -1;\n+\n+    List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n+    // find the position where the new file should be inserted\n+    for (int i = 0; i < sequenceList.size(); i++) {\n+      TsFileResource localFile = sequenceList.get(i);\n+      if (localFile.getFile().getName().equals(tsfileToBeInserted.getName())) {\n+        return POS_ALREADY_EXIST;\n+      }\n+      long localPartitionId = Long.parseLong(localFile.getFile().getParent());\n+      if (i == sequenceList.size() - 1 && localFile.getEndTimeMap().isEmpty()\n+          || newFilePartitionId != localPartitionId) {\n+        // skip files that are not in the partition as the new file and the last empty file\n+        continue;\n+      }\n+\n+      int fileComparison = compareTsFileDevices(newTsFileResource, localFile);\n+      switch (fileComparison) {\n+        case 0:\n+          // some devices are newer but some devices are older, the two files overlap in general\n+          return POS_OVERLAP;\n+        case -1:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2NDY5Nw=="}, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 366}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDE5MDI5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMjoyNDoxMFrOF6e38w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMzo1MTo0N1rOF6gJuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2NzU3MQ==", "bodyText": "I think this method needs to be  checked carefully.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396867571", "createdAt": "2020-03-24T02:24:10Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1638,12 +1646,98 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n     }\n   }\n \n+  /**\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n+   * @param newTsFileResource\n+   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n+   *         POS_OVERLAP(-3) if some file overlaps the new file\n+   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   */\n+  private int findInsertionPosition(TsFileResource newTsFileResource) {\n+    File tsfileToBeInserted = newTsFileResource.getFile();\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    int insertPos = -1;\n+\n+    List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n+    // find the position where the new file should be inserted\n+    for (int i = 0; i < sequenceList.size(); i++) {\n+      TsFileResource localFile = sequenceList.get(i);\n+      if (localFile.getFile().getName().equals(tsfileToBeInserted.getName())) {\n+        return POS_ALREADY_EXIST;\n+      }\n+      long localPartitionId = Long.parseLong(localFile.getFile().getParent());\n+      if (i == sequenceList.size() - 1 && localFile.getEndTimeMap().isEmpty()\n+          || newFilePartitionId != localPartitionId) {\n+        // skip files that are not in the partition as the new file and the last empty file\n+        continue;\n+      }\n+\n+      int fileComparison = compareTsFileDevices(newTsFileResource, localFile);\n+      switch (fileComparison) {\n+        case 0:\n+          // some devices are newer but some devices are older, the two files overlap in general\n+          return POS_OVERLAP;\n+        case -1:\n+          // all devices in the local file are newer than the new file, the new file can be\n+          // inserted before the new file\n+          return i - 1;\n+        default:\n+          // all devices in the local file are older than the new file, proceed to the next file\n+          insertPos = i;\n+      }\n+    }\n+    return insertPos;\n+  }\n+\n+  /**\n+   * Compare each device in the two files to find the time relation of them.\n+   * @param fileA\n+   * @param fileB\n+   * @return -1 if fileA is totally older than fileB (A < B)\n+   *          0 if fileA is partially older than fileB and partially newer than fileB (A X B)\n+   *          1 if fileA is totally newer than fileB (B < A)\n+   */\n+  private int compareTsFileDevices(TsFileResource fileA, TsFileResource fileB) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 386}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4ODUwNw==", "bodyText": "Yes, I mistakenly reversed the condition and now it is fixed.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396888507", "createdAt": "2020-03-24T03:51:47Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1638,12 +1646,98 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n     }\n   }\n \n+  /**\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n+   * @param newTsFileResource\n+   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n+   *         POS_OVERLAP(-3) if some file overlaps the new file\n+   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   */\n+  private int findInsertionPosition(TsFileResource newTsFileResource) {\n+    File tsfileToBeInserted = newTsFileResource.getFile();\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    int insertPos = -1;\n+\n+    List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n+    // find the position where the new file should be inserted\n+    for (int i = 0; i < sequenceList.size(); i++) {\n+      TsFileResource localFile = sequenceList.get(i);\n+      if (localFile.getFile().getName().equals(tsfileToBeInserted.getName())) {\n+        return POS_ALREADY_EXIST;\n+      }\n+      long localPartitionId = Long.parseLong(localFile.getFile().getParent());\n+      if (i == sequenceList.size() - 1 && localFile.getEndTimeMap().isEmpty()\n+          || newFilePartitionId != localPartitionId) {\n+        // skip files that are not in the partition as the new file and the last empty file\n+        continue;\n+      }\n+\n+      int fileComparison = compareTsFileDevices(newTsFileResource, localFile);\n+      switch (fileComparison) {\n+        case 0:\n+          // some devices are newer but some devices are older, the two files overlap in general\n+          return POS_OVERLAP;\n+        case -1:\n+          // all devices in the local file are newer than the new file, the new file can be\n+          // inserted before the new file\n+          return i - 1;\n+        default:\n+          // all devices in the local file are older than the new file, proceed to the next file\n+          insertPos = i;\n+      }\n+    }\n+    return insertPos;\n+  }\n+\n+  /**\n+   * Compare each device in the two files to find the time relation of them.\n+   * @param fileA\n+   * @param fileB\n+   * @return -1 if fileA is totally older than fileB (A < B)\n+   *          0 if fileA is partially older than fileB and partially newer than fileB (A X B)\n+   *          1 if fileA is totally newer than fileB (B < A)\n+   */\n+  private int compareTsFileDevices(TsFileResource fileA, TsFileResource fileB) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2NzU3MQ=="}, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 386}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDE5NDQ3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMjoyNzowNlrOF6e6pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMzo1MzowNFrOF6gK2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2ODI2MQ==", "bodyText": "return i;\nIt needs to add in the cur pos and move all newer files backward.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396868261", "createdAt": "2020-03-24T02:27:06Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1638,12 +1646,98 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n     }\n   }\n \n+  /**\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n+   * @param newTsFileResource\n+   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n+   *         POS_OVERLAP(-3) if some file overlaps the new file\n+   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   */\n+  private int findInsertionPosition(TsFileResource newTsFileResource) {\n+    File tsfileToBeInserted = newTsFileResource.getFile();\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    int insertPos = -1;\n+\n+    List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n+    // find the position where the new file should be inserted\n+    for (int i = 0; i < sequenceList.size(); i++) {\n+      TsFileResource localFile = sequenceList.get(i);\n+      if (localFile.getFile().getName().equals(tsfileToBeInserted.getName())) {\n+        return POS_ALREADY_EXIST;\n+      }\n+      long localPartitionId = Long.parseLong(localFile.getFile().getParent());\n+      if (i == sequenceList.size() - 1 && localFile.getEndTimeMap().isEmpty()\n+          || newFilePartitionId != localPartitionId) {\n+        // skip files that are not in the partition as the new file and the last empty file\n+        continue;\n+      }\n+\n+      int fileComparison = compareTsFileDevices(newTsFileResource, localFile);\n+      switch (fileComparison) {\n+        case 0:\n+          // some devices are newer but some devices are older, the two files overlap in general\n+          return POS_OVERLAP;\n+        case -1:\n+          // all devices in the local file are newer than the new file, the new file can be\n+          // inserted before the new file\n+          return i - 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 369}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4ODc5NQ==", "bodyText": "As I have explained in the javadoc that the file will be inserted between [i, i +1], I think it does not really matter.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396888795", "createdAt": "2020-03-24T03:53:04Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1638,12 +1646,98 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n     }\n   }\n \n+  /**\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n+   * @param newTsFileResource\n+   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n+   *         POS_OVERLAP(-3) if some file overlaps the new file\n+   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   */\n+  private int findInsertionPosition(TsFileResource newTsFileResource) {\n+    File tsfileToBeInserted = newTsFileResource.getFile();\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    int insertPos = -1;\n+\n+    List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n+    // find the position where the new file should be inserted\n+    for (int i = 0; i < sequenceList.size(); i++) {\n+      TsFileResource localFile = sequenceList.get(i);\n+      if (localFile.getFile().getName().equals(tsfileToBeInserted.getName())) {\n+        return POS_ALREADY_EXIST;\n+      }\n+      long localPartitionId = Long.parseLong(localFile.getFile().getParent());\n+      if (i == sequenceList.size() - 1 && localFile.getEndTimeMap().isEmpty()\n+          || newFilePartitionId != localPartitionId) {\n+        // skip files that are not in the partition as the new file and the last empty file\n+        continue;\n+      }\n+\n+      int fileComparison = compareTsFileDevices(newTsFileResource, localFile);\n+      switch (fileComparison) {\n+        case 0:\n+          // some devices are newer but some devices are older, the two files overlap in general\n+          return POS_OVERLAP;\n+        case -1:\n+          // all devices in the local file are newer than the new file, the new file can be\n+          // inserted before the new file\n+          return i - 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2ODI2MQ=="}, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 369}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDE5NjU2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMjoyODoyNFrOF6e7_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMzo1MzozMFrOF6gLPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2ODYwNA==", "bodyText": "return i + 1;\nIt needs to be inserted after the older files.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396868604", "createdAt": "2020-03-24T02:28:24Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1638,12 +1646,98 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n     }\n   }\n \n+  /**\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n+   * @param newTsFileResource\n+   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n+   *         POS_OVERLAP(-3) if some file overlaps the new file\n+   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   */\n+  private int findInsertionPosition(TsFileResource newTsFileResource) {\n+    File tsfileToBeInserted = newTsFileResource.getFile();\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    int insertPos = -1;\n+\n+    List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n+    // find the position where the new file should be inserted\n+    for (int i = 0; i < sequenceList.size(); i++) {\n+      TsFileResource localFile = sequenceList.get(i);\n+      if (localFile.getFile().getName().equals(tsfileToBeInserted.getName())) {\n+        return POS_ALREADY_EXIST;\n+      }\n+      long localPartitionId = Long.parseLong(localFile.getFile().getParent());\n+      if (i == sequenceList.size() - 1 && localFile.getEndTimeMap().isEmpty()\n+          || newFilePartitionId != localPartitionId) {\n+        // skip files that are not in the partition as the new file and the last empty file\n+        continue;\n+      }\n+\n+      int fileComparison = compareTsFileDevices(newTsFileResource, localFile);\n+      switch (fileComparison) {\n+        case 0:\n+          // some devices are newer but some devices are older, the two files overlap in general\n+          return POS_OVERLAP;\n+        case -1:\n+          // all devices in the local file are newer than the new file, the new file can be\n+          // inserted before the new file\n+          return i - 1;\n+        default:\n+          // all devices in the local file are older than the new file, proceed to the next file\n+          insertPos = i;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4ODg5NA==", "bodyText": "See above.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396888894", "createdAt": "2020-03-24T03:53:30Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1638,12 +1646,98 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n     }\n   }\n \n+  /**\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n+   * @param newTsFileResource\n+   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n+   *         POS_OVERLAP(-3) if some file overlaps the new file\n+   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   */\n+  private int findInsertionPosition(TsFileResource newTsFileResource) {\n+    File tsfileToBeInserted = newTsFileResource.getFile();\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    int insertPos = -1;\n+\n+    List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n+    // find the position where the new file should be inserted\n+    for (int i = 0; i < sequenceList.size(); i++) {\n+      TsFileResource localFile = sequenceList.get(i);\n+      if (localFile.getFile().getName().equals(tsfileToBeInserted.getName())) {\n+        return POS_ALREADY_EXIST;\n+      }\n+      long localPartitionId = Long.parseLong(localFile.getFile().getParent());\n+      if (i == sequenceList.size() - 1 && localFile.getEndTimeMap().isEmpty()\n+          || newFilePartitionId != localPartitionId) {\n+        // skip files that are not in the partition as the new file and the last empty file\n+        continue;\n+      }\n+\n+      int fileComparison = compareTsFileDevices(newTsFileResource, localFile);\n+      switch (fileComparison) {\n+        case 0:\n+          // some devices are newer but some devices are older, the two files overlap in general\n+          return POS_OVERLAP;\n+        case -1:\n+          // all devices in the local file are newer than the new file, the new file can be\n+          // inserted before the new file\n+          return i - 1;\n+        default:\n+          // all devices in the local file are older than the new file, proceed to the next file\n+          insertPos = i;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2ODYwNA=="}, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 372}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDIwMDE1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMjozMDoyNFrOF6e-HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMzo1Njo0OVrOF6gOcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2OTE0OQ==", "bodyText": "You can use if(! sequenceFileTreeSet.isEmpty()).\nThe origin if (subsequentIndex != sequenceFileTreeSet.size() || preIndex != -1) is equals to above.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396869149", "createdAt": "2020-03-24T02:30:24Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1559,61 +1601,24 @@ public void loadNewTsFileForSync(TsFileResource newTsFileResource)\n   public void loadNewTsFile(TsFileResource newTsFileResource)\n       throws TsFileProcessorException {\n     File tsfileToBeInserted = newTsFileResource.getFile();\n+\n     writeLock();\n     mergeLock.writeLock().lock();\n     try {\n-      boolean isOverlap = false;\n-      int preIndex = -1, subsequentIndex = sequenceFileTreeSet.size();\n-\n-      List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n-      // check new tsfile\n-      outer:\n-      for (int i = 0; i < sequenceList.size(); i++) {\n-        if (sequenceList.get(i).getFile().getName().equals(tsfileToBeInserted.getName())) {\n-          return;\n-        }\n-        if (i == sequenceList.size() - 1 && sequenceList.get(i).getEndTimeMap().isEmpty()) {\n-          continue;\n-        }\n-        boolean hasPre = false, hasSubsequence = false;\n-        for (String device : newTsFileResource.getStartTimeMap().keySet()) {\n-          if (sequenceList.get(i).getStartTimeMap().containsKey(device)) {\n-            long startTime1 = sequenceList.get(i).getStartTimeMap().get(device);\n-            long endTime1 = sequenceList.get(i).getEndTimeMap().get(device);\n-            long startTime2 = newTsFileResource.getStartTimeMap().get(device);\n-            long endTime2 = newTsFileResource.getEndTimeMap().get(device);\n-            if (startTime1 > endTime2) {\n-              hasSubsequence = true;\n-            } else if (startTime2 > endTime1) {\n-              hasPre = true;\n-            } else {\n-              isOverlap = true;\n-              break outer;\n-            }\n-          }\n-        }\n-        if (hasPre && hasSubsequence) {\n-          isOverlap = true;\n-          break;\n-        }\n-        if (!hasPre && hasSubsequence) {\n-          subsequentIndex = i;\n-          break;\n-        }\n-        if (hasPre) {\n-          preIndex = i;\n-        }\n+      int insertPos = findInsertionPosition(newTsFileResource);\n+      if (insertPos == POS_ALREADY_EXIST) {\n+        return;\n       }\n \n       // loading tsfile by type\n-      if (isOverlap) {\n+      if (insertPos == POS_OVERLAP) {\n         loadTsFileByType(LoadTsFileType.LOAD_UNSEQUENCE, tsfileToBeInserted, newTsFileResource);\n       } else {\n \n         // check whether the file name needs to be renamed.\n-        if (subsequentIndex != sequenceFileTreeSet.size() || preIndex != -1) {\n-          String newFileName = getFileNameForLoadingFile(tsfileToBeInserted.getName(), preIndex,\n-              subsequentIndex, getTimePartitionFromTsFileResource(newTsFileResource));\n+        if (insertPos != sequenceFileTreeSet.size() - 1 || insertPos != -1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4OTcxNA==", "bodyText": "Changed. But I doubt the quality of them, as the file being inserted at the head or the tail does not necessarily indicate the set is empty.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396889714", "createdAt": "2020-03-24T03:56:49Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1559,61 +1601,24 @@ public void loadNewTsFileForSync(TsFileResource newTsFileResource)\n   public void loadNewTsFile(TsFileResource newTsFileResource)\n       throws TsFileProcessorException {\n     File tsfileToBeInserted = newTsFileResource.getFile();\n+\n     writeLock();\n     mergeLock.writeLock().lock();\n     try {\n-      boolean isOverlap = false;\n-      int preIndex = -1, subsequentIndex = sequenceFileTreeSet.size();\n-\n-      List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n-      // check new tsfile\n-      outer:\n-      for (int i = 0; i < sequenceList.size(); i++) {\n-        if (sequenceList.get(i).getFile().getName().equals(tsfileToBeInserted.getName())) {\n-          return;\n-        }\n-        if (i == sequenceList.size() - 1 && sequenceList.get(i).getEndTimeMap().isEmpty()) {\n-          continue;\n-        }\n-        boolean hasPre = false, hasSubsequence = false;\n-        for (String device : newTsFileResource.getStartTimeMap().keySet()) {\n-          if (sequenceList.get(i).getStartTimeMap().containsKey(device)) {\n-            long startTime1 = sequenceList.get(i).getStartTimeMap().get(device);\n-            long endTime1 = sequenceList.get(i).getEndTimeMap().get(device);\n-            long startTime2 = newTsFileResource.getStartTimeMap().get(device);\n-            long endTime2 = newTsFileResource.getEndTimeMap().get(device);\n-            if (startTime1 > endTime2) {\n-              hasSubsequence = true;\n-            } else if (startTime2 > endTime1) {\n-              hasPre = true;\n-            } else {\n-              isOverlap = true;\n-              break outer;\n-            }\n-          }\n-        }\n-        if (hasPre && hasSubsequence) {\n-          isOverlap = true;\n-          break;\n-        }\n-        if (!hasPre && hasSubsequence) {\n-          subsequentIndex = i;\n-          break;\n-        }\n-        if (hasPre) {\n-          preIndex = i;\n-        }\n+      int insertPos = findInsertionPosition(newTsFileResource);\n+      if (insertPos == POS_ALREADY_EXIST) {\n+        return;\n       }\n \n       // loading tsfile by type\n-      if (isOverlap) {\n+      if (insertPos == POS_OVERLAP) {\n         loadTsFileByType(LoadTsFileType.LOAD_UNSEQUENCE, tsfileToBeInserted, newTsFileResource);\n       } else {\n \n         // check whether the file name needs to be renamed.\n-        if (subsequentIndex != sequenceFileTreeSet.size() || preIndex != -1) {\n-          String newFileName = getFileNameForLoadingFile(tsfileToBeInserted.getName(), preIndex,\n-              subsequentIndex, getTimePartitionFromTsFileResource(newTsFileResource));\n+        if (insertPos != sequenceFileTreeSet.size() - 1 || insertPos != -1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2OTE0OQ=="}, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 313}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDIwNTc5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMjozMzo1OVrOF6fBmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMzo1OTozOVrOF6gQtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg3MDA0MQ==", "bodyText": "insertIndex == sequenceFileTreeSet.size()\nLogic:\nIf it needs to be inserted to be the last in the list.\nJust a note: currently, insertPos  is equals to subsequentIndex .", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396870041", "createdAt": "2020-03-24T02:33:59Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1702,24 +1796,26 @@ private void removeFullyOverlapFiles(TsFileResource resource, Iterator<TsFileRes\n    * version number is the version number in the tsfile with a larger timestamp.\n    *\n    * @param tsfileName origin tsfile name\n+   * @param insertIndex the new file will be inserted between the files [insertIndex, insertIndex\n+   *                   + 1]\n    * @return appropriate filename\n    */\n-  private String getFileNameForLoadingFile(String tsfileName, int preIndex, int subsequentIndex,\n+  private String getFileNameForLoadingFile(String tsfileName, int insertIndex,\n       long timePartitionId) {\n     long currentTsFileTime = Long\n         .parseLong(tsfileName.split(IoTDBConstant.TSFILE_NAME_SEPARATOR)[0]);\n     long preTime;\n     List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n-    if (preIndex == -1) {\n+    if (insertIndex == -1) {\n       preTime = 0L;\n     } else {\n-      String preName = sequenceList.get(preIndex).getFile().getName();\n+      String preName = sequenceList.get(insertIndex).getFile().getName();\n       preTime = Long.parseLong(preName.split(IoTDBConstant.TSFILE_NAME_SEPARATOR)[0]);\n     }\n-    if (subsequentIndex == sequenceFileTreeSet.size()) {\n+    if (insertIndex == sequenceFileTreeSet.size() - 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 454}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg5MDI5NQ==", "bodyText": "You have misunderstood the meaning of insertIndex, please read the Javadoc. For example, if the insertIndex is -1, it means the new file will be inserted between [-1, 0], not that the new file will be inserted at -1.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396890295", "createdAt": "2020-03-24T03:59:39Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1702,24 +1796,26 @@ private void removeFullyOverlapFiles(TsFileResource resource, Iterator<TsFileRes\n    * version number is the version number in the tsfile with a larger timestamp.\n    *\n    * @param tsfileName origin tsfile name\n+   * @param insertIndex the new file will be inserted between the files [insertIndex, insertIndex\n+   *                   + 1]\n    * @return appropriate filename\n    */\n-  private String getFileNameForLoadingFile(String tsfileName, int preIndex, int subsequentIndex,\n+  private String getFileNameForLoadingFile(String tsfileName, int insertIndex,\n       long timePartitionId) {\n     long currentTsFileTime = Long\n         .parseLong(tsfileName.split(IoTDBConstant.TSFILE_NAME_SEPARATOR)[0]);\n     long preTime;\n     List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n-    if (preIndex == -1) {\n+    if (insertIndex == -1) {\n       preTime = 0L;\n     } else {\n-      String preName = sequenceList.get(preIndex).getFile().getName();\n+      String preName = sequenceList.get(insertIndex).getFile().getName();\n       preTime = Long.parseLong(preName.split(IoTDBConstant.TSFILE_NAME_SEPARATOR)[0]);\n     }\n-    if (subsequentIndex == sequenceFileTreeSet.size()) {\n+    if (insertIndex == sequenceFileTreeSet.size() - 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg3MDA0MQ=="}, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 454}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MjY2NDc4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNTo1ODowN1rOF63Okw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwMjowNTowOFrOF7JphQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NjU3OQ==", "bodyText": "The parent file of the file may not be its time range. It's better to get time range from the time.\nSuch as:\nload /data/1584445970309-101-1.tsfile", "url": "https://github.com/apache/iotdb/pull/935#discussion_r397266579", "createdAt": "2020-03-24T15:58:07Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1655,7 +1655,7 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n    */\n   private int findInsertionPosition(TsFileResource newTsFileResource) {\n     File tsfileToBeInserted = newTsFileResource.getFile();\n-    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParentFile().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac2f66ee9ec0d6af3167788eae4806debeece43d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU2NTY0OQ==", "bodyText": "Fixed. But there is still one thing remaining, what if the file belongs to more than one partition? Currently, I will report an error and a delicate solution will be left as a future job.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r397565649", "createdAt": "2020-03-25T01:54:37Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1655,7 +1655,7 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n    */\n   private int findInsertionPosition(TsFileResource newTsFileResource) {\n     File tsfileToBeInserted = newTsFileResource.getFile();\n-    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParentFile().getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NjU3OQ=="}, "originalCommit": {"oid": "ac2f66ee9ec0d6af3167788eae4806debeece43d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU2ODM4OQ==", "bodyText": "Yes, I agree with you.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r397568389", "createdAt": "2020-03-25T02:05:08Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1655,7 +1655,7 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n    */\n   private int findInsertionPosition(TsFileResource newTsFileResource) {\n     File tsfileToBeInserted = newTsFileResource.getFile();\n-    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParentFile().getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NjU3OQ=="}, "originalCommit": {"oid": "ac2f66ee9ec0d6af3167788eae4806debeece43d"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 153, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}