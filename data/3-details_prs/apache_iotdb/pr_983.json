{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4MjEyNjYz", "number": 983, "title": "Online Upgrade Tool", "bodyText": "In order to upgrade 0.9.x TsFile to 0.10.x, please follow these steps.\n\nstop inserting data to 0.9.x IoTDB\nopen CLI, manually input flush to flush data to the disk\nclose 0.9.x IoTDB, open 0.10.x IoTDB\nmove or link the 0.9.x data directory to the location of 0.10.x's\nstart running 0.10.x IoTDB\n\nAfter these steps, the online upgrade tool will be able to upgrade 0.9.x TsFile to 0.10.x version.\nDuring upgrading, query can work normally.", "createdAt": "2020-04-03T14:38:53Z", "url": "https://github.com/apache/iotdb/pull/983", "merged": true, "mergeCommit": {"oid": "3fe522a657d0e29963e93e012e86b0ab44825fcb"}, "closed": true, "closedAt": "2020-05-17T14:40:45Z", "author": {"login": "HTHou"}, "timelineItems": {"totalCount": 110, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABchYbtLAH2gAyMzk4MjEyNjYzOmM3Y2JhYjAyMjA4Y2ZkZWM1NjU2OTdiY2VkZjE4ODQxYzdiNTU2NzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABciLAYogH2gAyMzk4MjEyNjYzOmJjNzE2MDRjOWVjYTdhNjdkM2UzYWRkNGQ3YzEzZTlkOWM3MDlhZWY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c7cbab02208cfdec565697bcedf18841c7b55674", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/c7cbab02208cfdec565697bcedf18841c7b55674", "committedDate": "2020-05-15T02:13:34Z", "message": "Merge branch 'upgrade_tool' of https://github.com/apache/incubator-iotdb into upgrade_tool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dab1f48c8f6a797e5a5f2797d54536943be59588", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/dab1f48c8f6a797e5a5f2797d54536943be59588", "committedDate": "2020-05-15T02:44:59Z", "message": "update javadoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMDM5ODg1", "url": "https://github.com/apache/iotdb/pull/983#pullrequestreview-413039885", "createdAt": "2020-05-16T02:36:36Z", "commit": {"oid": "dab1f48c8f6a797e5a5f2797d54536943be59588"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwMjozNjozNlrOGWXqHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwMjozNjozNlrOGWXqHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwOTQ3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class OldChunkGroupMetaData {\n          \n          \n            \n            public class ChunkGroupMetaDataV1 {", "url": "https://github.com/apache/iotdb/pull/983#discussion_r426109471", "createdAt": "2020-05-16T02:36:36Z", "author": {"login": "qiaojialin"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/v1/file/metadata/OldChunkGroupMetaData.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.tsfile.v1.file.metadata;\n+\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Metadata of ChunkGroup.\n+ */\n+public class OldChunkGroupMetaData {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dab1f48c8f6a797e5a5f2797d54536943be59588"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMDQwNjM5", "url": "https://github.com/apache/iotdb/pull/983#pullrequestreview-413040639", "createdAt": "2020-05-16T02:48:46Z", "commit": {"oid": "dab1f48c8f6a797e5a5f2797d54536943be59588"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwMjo0ODo0NlrOGWXtpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwMjo1NjoxOFrOGWXv5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExMDM3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class TsFileSequenceReaderForOldFile extends TsFileSequenceReader {\n          \n          \n            \n            public class TsFileSequenceReaderForV1 extends TsFileSequenceReader {", "url": "https://github.com/apache/iotdb/pull/983#discussion_r426110374", "createdAt": "2020-05-16T02:48:46Z", "author": {"login": "qiaojialin"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/v1/read/TsFileSequenceReaderForOldFile.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.tsfile.v1.read;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.apache.iotdb.tsfile.common.conf.TSFileConfig;\n+import org.apache.iotdb.tsfile.file.header.ChunkHeader;\n+import org.apache.iotdb.tsfile.file.header.PageHeader;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.TimeseriesMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Chunk;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.reader.TsFileInput;\n+import org.apache.iotdb.tsfile.utils.BloomFilter;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.apache.iotdb.tsfile.v1.file.metadata.OldChunkGroupMetaData;\n+import org.apache.iotdb.tsfile.v1.file.metadata.OldChunkMetadata;\n+import org.apache.iotdb.tsfile.v1.file.metadata.OldTsDeviceMetadata;\n+import org.apache.iotdb.tsfile.v1.file.metadata.OldTsDeviceMetadataIndex;\n+import org.apache.iotdb.tsfile.v1.file.metadata.OldTsFileMetadata;\n+import org.apache.iotdb.tsfile.v1.file.metadata.TimeseriesMetadataForOldFile;\n+import org.apache.iotdb.tsfile.v1.file.utils.HeaderUtils;\n+\n+public class TsFileSequenceReaderForOldFile extends TsFileSequenceReader {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dab1f48c8f6a797e5a5f2797d54536943be59588"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExMDk1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    try (TsFileSequenceReader reader = new TsFileSequenceReader(filePath)) {\n          \n          \n            \n                      if (reader.readVersionNumber().equals(TSFileConfig.OLD_VERSION)) {\n          \n          \n            \n                        tsFileReader = new TsFileSequenceReaderForOldFile(filePath);\n          \n          \n            \n                      }\n          \n          \n            \n                      else {\n          \n          \n            \n                        tsFileReader = new TsFileSequenceReader(filePath);\n          \n          \n            \n                      }\n          \n          \n            \n                    }\n          \n          \n            \n                    tsfileReader = new TsFileSequenceReader(filePath);\n          \n          \n            \n                    switch (tsfileReader.readVersionNumber) {\n          \n          \n            \n                        case TsFileConfig.V1:\n          \n          \n            \n                            reader.close();\n          \n          \n            \n                            tsfileReader = new TsFileSequenceReaderForOldFile(filePath);\n          \n          \n            \n                            break;\n          \n          \n            \n                        case TsFileConfig.V2:\n          \n          \n            \n                            break;\n          \n          \n            \n                    }", "url": "https://github.com/apache/iotdb/pull/983#discussion_r426110951", "createdAt": "2020-05-16T02:56:18Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/control/FileReaderManager.java", "diffHunk": "@@ -158,9 +160,21 @@ public synchronized TsFileSequenceReader get(String filePath, boolean isClosed)\n         logger.warn(\"Query has opened {} files !\", readerMap.size());\n       }\n \n-      TsFileSequenceReader tsFileReader = !isClosed ? new UnClosedTsFileReader(filePath)\n-          : new TsFileSequenceReader(filePath);\n-\n+      TsFileSequenceReader tsFileReader = null;\n+      // check if the file is old version\n+      if (!isClosed) {\n+        tsFileReader = new UnClosedTsFileReader(filePath);\n+      }\n+      else {\n+        try (TsFileSequenceReader reader = new TsFileSequenceReader(filePath)) {\n+          if (reader.readVersionNumber().equals(TSFileConfig.OLD_VERSION)) {\n+            tsFileReader = new TsFileSequenceReaderForOldFile(filePath);\n+          }\n+          else {\n+            tsFileReader = new TsFileSequenceReader(filePath);\n+          }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dab1f48c8f6a797e5a5f2797d54536943be59588"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec3d4cf58f6e8b45ab850fd271745d32b62fd8c6", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/ec3d4cf58f6e8b45ab850fd271745d32b62fd8c6", "committedDate": "2020-05-16T04:30:31Z", "message": "fix review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c516b5edb10aacf8642a99f19985be582b7c7133", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/c516b5edb10aacf8642a99f19985be582b7c7133", "committedDate": "2020-05-16T05:08:15Z", "message": "fix sonar"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa0f86e0273c38594e48e1d16dafa4eaa4279c63", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/fa0f86e0273c38594e48e1d16dafa4eaa4279c63", "committedDate": "2020-05-16T05:43:52Z", "message": "sonar bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d53fcd0d6cc24b6bfbe106e6fe3fb212cceb2b8", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/2d53fcd0d6cc24b6bfbe106e6fe3fb212cceb2b8", "committedDate": "2020-05-16T06:10:49Z", "message": "sonar bug"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMTU2ODI3", "url": "https://github.com/apache/iotdb/pull/983#pullrequestreview-413156827", "createdAt": "2020-05-17T12:18:46Z", "commit": {"oid": "c516b5edb10aacf8642a99f19985be582b7c7133"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc71604c9eca7a67d3e3add4d7c13e9d9c709aef", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/bc71604c9eca7a67d3e3add4d7c13e9d9c709aef", "committedDate": "2020-05-17T13:08:53Z", "message": "fix conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b9fb3f47ba69ecd5cbd13bcb944518db18b62ee", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/5b9fb3f47ba69ecd5cbd13bcb944518db18b62ee", "committedDate": "2020-03-31T02:52:18Z", "message": "add the old upgrade tool back"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b296d3fa5f31653538a8da12fd21899fd2ba69b", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/9b296d3fa5f31653538a8da12fd21899fd2ba69b", "committedDate": "2020-04-01T06:34:47Z", "message": "Merge branch 'master' of https://github.com/apache/incubator-iotdb into upgrade_tool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "795fc3ba28e4ec1cc46d4448892786843c09b94e", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/795fc3ba28e4ec1cc46d4448892786843c09b94e", "committedDate": "2020-04-01T09:15:11Z", "message": "upgrade system.properties"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d79c63f2d2f37010540f970ac657fdcf05ced6d", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/5d79c63f2d2f37010540f970ac657fdcf05ced6d", "committedDate": "2020-04-08T09:54:48Z", "message": "support reading 0.9 TsFile"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a0908719b83fa237b1b01007b1b771dd4e0bce4", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/5a0908719b83fa237b1b01007b1b771dd4e0bce4", "committedDate": "2020-04-08T13:43:27Z", "message": "reading 0.9 TsFile"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c827a15e0b205bd6d05ae8d20ee32d975d6e3870", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/c827a15e0b205bd6d05ae8d20ee32d975d6e3870", "committedDate": "2020-04-09T01:24:56Z", "message": "add storage_group_time_range check in IoTDBConfigCheck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d6548bf38f5b9753c9fc5ac02fcf21bc807c575", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/7d6548bf38f5b9753c9fc5ac02fcf21bc807c575", "committedDate": "2020-04-09T02:18:15Z", "message": "remove useless code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7ba1f021248aee10e6f90020d6d2ca8faac58c8", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/e7ba1f021248aee10e6f90020d6d2ca8faac58c8", "committedDate": "2020-04-09T02:19:37Z", "message": "Merge branch 'upgrade_tool' of https://github.com/apache/incubator-iotdb into upgrade_tool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "781f9da72aad41fb74d6262d805a97f6863a682f", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/781f9da72aad41fb74d6262d805a97f6863a682f", "committedDate": "2020-04-09T03:26:29Z", "message": "move old files to upgrade folder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b5d2530585f742fd8a7087da66a0b05c20ce22e", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/6b5d2530585f742fd8a7087da66a0b05c20ce22e", "committedDate": "2020-04-09T03:30:29Z", "message": "resolve conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8858bbc2796c2cdd6509db624954632618525f9f", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/8858bbc2796c2cdd6509db624954632618525f9f", "committedDate": "2020-04-09T13:09:27Z", "message": "upgrade old TsFile"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea914bd52fd995d3aa5f9bf71138e82a2c249119", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/ea914bd52fd995d3aa5f9bf71138e82a2c249119", "committedDate": "2020-04-09T13:54:15Z", "message": "add upgrade folder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "626a0c3ddd8c87856a943aaf5062e0158311333d", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/626a0c3ddd8c87856a943aaf5062e0158311333d", "committedDate": "2020-04-13T01:21:58Z", "message": "upgrade old tsfile"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d1b7553092ee1a5bbf7e2d2e5d2a49bffdb7f96", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/3d1b7553092ee1a5bbf7e2d2e5d2a49bffdb7f96", "committedDate": "2020-04-13T01:38:34Z", "message": "merge from master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9af47581d412963e8de26e12caef74d605c5e793", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/9af47581d412963e8de26e12caef74d605c5e793", "committedDate": "2020-04-13T09:10:05Z", "message": "upgrade old TsFile"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f19b6b131854cffdb9cb7d05a997d9b3ff395b7", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/6f19b6b131854cffdb9cb7d05a997d9b3ff395b7", "committedDate": "2020-04-14T07:09:11Z", "message": "Merge branch 'upgrade_tool' of https://github.com/apache/incubator-iotdb into upgrade_tool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f554c0fbc612e56aea7bc1fa04497b4341a83ac4", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/f554c0fbc612e56aea7bc1fa04497b4341a83ac4", "committedDate": "2020-04-14T16:47:50Z", "message": "move files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0607230eedd68397924b770a899e5d720360cb6b", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/0607230eedd68397924b770a899e5d720360cb6b", "committedDate": "2020-04-16T16:58:46Z", "message": "implement two ways to upgrade an old tsFile"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b805b65948313cae0527d60854bca262ba656de", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/0b805b65948313cae0527d60854bca262ba656de", "committedDate": "2020-04-17T03:17:39Z", "message": "add comments and fix upgrade old statistics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdfb76428a1da9d445d5d07ec3a73501d509d6de", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/fdfb76428a1da9d445d5d07ec3a73501d509d6de", "committedDate": "2020-04-17T13:59:08Z", "message": "fix upgrading chunkgroup in same time partition"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11475495cd9380af606514f901a60c0a7417a5c5", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/11475495cd9380af606514f901a60c0a7417a5c5", "committedDate": "2020-04-19T02:09:31Z", "message": "load upgraded resources"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c47d726c31c9fe6340b5f225147efd36c909f16", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/5c47d726c31c9fe6340b5f225147efd36c909f16", "committedDate": "2020-04-19T02:33:40Z", "message": "merge master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55366fd896cea75f90e501d434c4149528a26056", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/55366fd896cea75f90e501d434c4149528a26056", "committedDate": "2020-04-19T02:54:27Z", "message": "fix a TsFileMetadata name bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56409b3dbbcea945352b0db790ceb8958c9c47e9", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/56409b3dbbcea945352b0db790ceb8958c9c47e9", "committedDate": "2020-04-19T03:34:56Z", "message": "Merge branch 'master' of https://github.com/apache/incubator-iotdb into upgrade_tool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24db597ced1a66483ceeb9a2ac2f90800c3ac575", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/24db597ced1a66483ceeb9a2ac2f90800c3ac575", "committedDate": "2020-04-19T03:35:44Z", "message": "fix bugs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac3dad5a1ae043c4680459824cd4bcdf452973c6", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/ac3dad5a1ae043c4680459824cd4bcdf452973c6", "committedDate": "2020-04-19T03:41:07Z", "message": "remove unnecessary code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5bbd2b4f13eee62da4675c3a1fa0dd66894542a5", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/5bbd2b4f13eee62da4675c3a1fa0dd66894542a5", "committedDate": "2020-04-19T03:49:16Z", "message": "fix bugs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "693047524fa66860c608f212eba56b04029cdfc6", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/693047524fa66860c608f212eba56b04029cdfc6", "committedDate": "2020-04-19T05:16:20Z", "message": "reduce code smells"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92799154661b19ab2601e2b3aca6562487cc426b", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/92799154661b19ab2601e2b3aca6562487cc426b", "committedDate": "2020-04-19T07:07:37Z", "message": "continue reducing code smells"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac7b4093521f13ac8d75e252d644ff2b8f3a6590", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/ac7b4093521f13ac8d75e252d644ff2b8f3a6590", "committedDate": "2020-04-19T07:12:22Z", "message": "continue reducing code smells"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e8dbade3ba183fdd882939227b059110cef559a", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/3e8dbade3ba183fdd882939227b059110cef559a", "committedDate": "2020-04-19T07:45:59Z", "message": "remove unnecessary code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8ae075bd2025aad146eb1cdfe5c2024f48d773a", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/a8ae075bd2025aad146eb1cdfe5c2024f48d773a", "committedDate": "2020-04-19T08:29:29Z", "message": "remove unnecessary code in sequenceReader"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "742188b8c565b0aa0ab819e9968010f1f1d9eb47", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/742188b8c565b0aa0ab819e9968010f1f1d9eb47", "committedDate": "2020-04-19T09:34:11Z", "message": "fix VULNERABILITY"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "476a00f380b3d894a984fd54b77639f87759ada5", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/476a00f380b3d894a984fd54b77639f87759ada5", "committedDate": "2020-04-20T06:41:58Z", "message": "fix recoverUpgrade method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53a67a7fcec628c1dd394cba1919c0881e797797", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/53a67a7fcec628c1dd394cba1919c0881e797797", "committedDate": "2020-04-20T06:54:56Z", "message": "fix recoverUpgrade method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b36f25d940d430558f2f0cefc002c33fbca9550", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/0b36f25d940d430558f2f0cefc002c33fbca9550", "committedDate": "2020-04-20T13:17:57Z", "message": "query"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7aee7fe897d12d5dc6083a2305d34e1d7aec346b", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/7aee7fe897d12d5dc6083a2305d34e1d7aec346b", "committedDate": "2020-04-20T14:25:44Z", "message": "fix sonar fail"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42d6ee78f9f13472dc03e0251d908070e1694100", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/42d6ee78f9f13472dc03e0251d908070e1694100", "committedDate": "2020-04-21T01:37:09Z", "message": "Merge branch 'upgrade_tool' of https://github.com/apache/incubator-iotdb into upgrade_tool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5d0d929d9859a76315c5ea02dab0603f20b1cb6", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/a5d0d929d9859a76315c5ea02dab0603f20b1cb6", "committedDate": "2020-04-21T01:39:01Z", "message": "fix converting oldChunkMetadata to chunkMetadata"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c9e24df1cdb2a71a4f008109dff65c1ba5c8c1f", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/7c9e24df1cdb2a71a4f008109dff65c1ba5c8c1f", "committedDate": "2020-04-21T01:40:06Z", "message": "query debug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d00592a51602b4a685dc6e0ad82c39b5ed9e7156", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/d00592a51602b4a685dc6e0ad82c39b5ed9e7156", "committedDate": "2020-04-21T01:40:13Z", "message": "Merge branch 'upgrade_tool' of https://github.com/apache/incubator-iotdb into upgrade_tool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d41a4637c5c9ce476771a694e7263726de0c1a3", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/1d41a4637c5c9ce476771a694e7263726de0c1a3", "committedDate": "2020-04-21T01:49:37Z", "message": "fix an oldMetadata version bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "412980842f4a7cafc7ceac241ec48c15053b95d9", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/412980842f4a7cafc7ceac241ec48c15053b95d9", "committedDate": "2020-04-21T01:51:35Z", "message": "Merge branch 'upgrade_tool' of https://github.com/apache/incubator-iotdb into upgrade_tool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e6c491f6daa5b43d504c32226104e2d3a513b70", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/1e6c491f6daa5b43d504c32226104e2d3a513b70", "committedDate": "2020-04-21T03:00:36Z", "message": "query is basically ok"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d1ea1b147a3ea2ba9dc16dfad37253615e76fd6", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/8d1ea1b147a3ea2ba9dc16dfad37253615e76fd6", "committedDate": "2020-04-21T15:42:01Z", "message": "remove upgrade check in mergeFileSelecter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d3a82d1e0c9159f8fda643d16b70f0d74a3d70a", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/6d3a82d1e0c9159f8fda643d16b70f0d74a3d70a", "committedDate": "2020-04-23T01:45:26Z", "message": "merge master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54f5bf9e3466fc2e4333db6399d3bba6cc9e1417", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/54f5bf9e3466fc2e4333db6399d3bba6cc9e1417", "committedDate": "2020-04-23T06:35:06Z", "message": "fix upgrading system.properties"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6d160b1acd3e52dce637fbdb622a6be862697ba", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/b6d160b1acd3e52dce637fbdb622a6be862697ba", "committedDate": "2020-04-23T07:54:35Z", "message": "fix MaxFileMergeFileSelector"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4e59c6d0fe877516eb7152bed7b40d2cdefec07", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/c4e59c6d0fe877516eb7152bed7b40d2cdefec07", "committedDate": "2020-04-23T07:55:33Z", "message": "reformat"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MDMwNzUz", "url": "https://github.com/apache/iotdb/pull/983#pullrequestreview-399030753", "createdAt": "2020-04-23T12:04:29Z", "commit": {"oid": "54f5bf9e3466fc2e4333db6399d3bba6cc9e1417"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMjowNDoyOVrOGKlweg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMjowNDoyOVrOGKlweg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc1NzU2Mg==", "bodyText": "Here, v0.9.0's data throws java.io.FileNotFoundException", "url": "https://github.com/apache/iotdb/pull/983#discussion_r413757562", "createdAt": "2020-04-23T12:04:29Z", "author": {"login": "EJTTianYu"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -100,46 +102,83 @@ private void checkFile(String filepath) {\n           properties.store(outputStream, \"System properties:\");\n         }\n       }\n+      else if (!file.exists() && tmpPropertiesFile.exists()) {\n+        // rename upgraded system.properties.tmp to system.properties\n+        FSFactoryProducer.getFSFactory().moveFile(tmpPropertiesFile, file);\n+        logger.info(\" {} has been upgraded.\", file.getAbsolutePath());\n+      }\n     } catch (IOException e) {\n       logger.error(\"Can not create {}.\", file.getAbsolutePath(), e);\n     }\n+    \n     // get existed properties from system_properties.txt\n     File inputFile = SystemFileFactory.INSTANCE\n             .getFile(filepath + File.separator + PROPERTIES_FILE_NAME);\n     try (FileInputStream inputStream = new FileInputStream(inputFile.toString())) {\n       properties.load(new InputStreamReader(inputStream, TSFileConfig.STRING_CHARSET));\n-      if (!properties.getProperty(\"timestamp_precision\").equals(timestampPrecision)) {\n-        logger.error(\"Wrong timestamp precision, please set as: \" + properties\n-                .getProperty(\"timestamp_precision\") + \" !\");\n-        System.exit(-1);\n-      }\n-      if (!(Long.parseLong(properties.getProperty(\"storage_group_time_range\"))\n-              == partitionInterval)) {\n-        logger.error(\"Wrong storage group time range, please set as: \" + properties\n-                .getProperty(\"storage_group_time_range\") + \" !\");\n-        System.exit(-1);\n-      }\n-      if (!(properties.getProperty(\"tsfile_storage_fs\").equals(tsfileFileSystem))) {\n-        logger.error(\"Wrong tsfile file system, please set as: \" + properties\n-            .getProperty(\"tsfile_storage_fs\") + \" !\");\n-        System.exit(-1);\n-      }\n-      if (properties.getProperty(\"iotdb_version\") == null) {\n-        logger.info(\"Lower iotdb version detected, upgrading old mlog file... \");\n-        MLogWriter.upgradeMLog(IoTDBDescriptor.getInstance().getConfig().getSchemaDir(), \n-            MetadataConstant.METADATA_LOG);\n-        logger.info(\"Old mlog file is upgraded.\");\n-        try (FileOutputStream outputStream = new FileOutputStream(file.toString())) {\n-          properties.setProperty(\"timestamp_precision\", timestampPrecision);\n-          properties.setProperty(\"storage_group_time_range\", String.valueOf(partitionInterval));\n-          properties.setProperty(\"tsfile_storage_fs\", tsfileFileSystem);\n-          properties.setProperty(\"iotdb_version\", iotdbVersion);\n-          properties.store(outputStream, \"System properties:\");\n+      // need to upgrade\n+      if (!properties.containsKey(\"iotdb_version\")) {\n+        properties.setProperty(\"storage_group_time_range\", String.valueOf(partitionInterval));\n+        properties.setProperty(\"tsfile_storage_fs\", tsfileFileSystem);\n+        properties.setProperty(\"iotdb_version\", iotdbVersion);\n+        // upgrade mlog\n+        try {\n+          MLogWriter.upgradeMLog(IoTDBDescriptor.getInstance().getConfig().getSchemaDir(), \n+              MetadataConstant.METADATA_LOG);\n+        } catch (IOException e) {\n+          logger.error(\"Upgrade mlog.txt from {} failed.\", file.getAbsolutePath(), e);\n         }\n+      } else {\n+        checkProperties();\n+        return;\n       }\n     } catch (IOException e) {\n       logger.error(\"Load system.properties from {} failed.\", file.getAbsolutePath(), e);\n     }\n+\n+    // it's an old version system.properties\n+    // try to add the storage_group_time_range, tsfile_storage_fs \n+    // and iotdb_version property in system.properties.tmp\n+    try (FileOutputStream outputStream = new FileOutputStream(tmpPropertiesFile.toString())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54f5bf9e3466fc2e4333db6399d3bba6cc9e1417"}, "originalPosition": 119}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MDU0MDQ5", "url": "https://github.com/apache/iotdb/pull/983#pullrequestreview-399054049", "createdAt": "2020-04-23T12:35:22Z", "commit": {"oid": "c4e59c6d0fe877516eb7152bed7b40d2cdefec07"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMjozNToyMlrOGKm-hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMjozNToyMlrOGKm-hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc3NzU0Mg==", "bodyText": "when the file exists during upgrade, both the if and elif does not work", "url": "https://github.com/apache/iotdb/pull/983#discussion_r413777542", "createdAt": "2020-04-23T12:35:22Z", "author": {"login": "EJTTianYu"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -84,12 +84,14 @@ private void createDir(String filepath) {\n   }\n \n   private void checkFile(String filepath) {\n-    // create file : read timestamp precision from engine.properties, create system_properties.txt\n+    // create file : read timestamp precision from engine.properties, create system.properties\n     // use output stream to write timestamp precision to file.\n     File file = SystemFileFactory.INSTANCE\n             .getFile(filepath + File.separator + PROPERTIES_FILE_NAME);\n+    File tmpPropertiesFile = new File(file.getAbsoluteFile() \n+        + File.separator + \"tmp\");\n     try {\n-      if (!file.exists()) {\n+      if (!file.exists() && !tmpPropertiesFile.exists()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4e59c6d0fe877516eb7152bed7b40d2cdefec07"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MDcxODEw", "url": "https://github.com/apache/iotdb/pull/983#pullrequestreview-399071810", "createdAt": "2020-04-23T12:57:28Z", "commit": {"oid": "c4e59c6d0fe877516eb7152bed7b40d2cdefec07"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMjo1NzoyOFrOGKn7Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMjo1NzoyOFrOGKn7Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc5MzA2Mg==", "bodyText": "maybe the comment is upgrading unsequence TsFile resource list", "url": "https://github.com/apache/iotdb/pull/983#discussion_r413793062", "createdAt": "2020-04-23T12:57:28Z", "author": {"login": "EJTTianYu"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -160,9 +145,16 @@\n         return rangeCompare == 0 ? compareFileName(o1.getFile(), o2.getFile()) : rangeCompare;\n       });\n \n+  // upgrading sequence TsFile resource list\n+  private List<TsFileResource> upgradeSeqFileList = new LinkedList<>();\n+\n   private CopyOnReadLinkedList<TsFileProcessor> closingSequenceTsFileProcessor = new CopyOnReadLinkedList<>();\n   // includes sealed and unsealed unSequence TsFiles\n   private List<TsFileResource> unSequenceFileList = new ArrayList<>();\n+\n+  // upgrading sequence TsFile resource list", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4e59c6d0fe877516eb7152bed7b40d2cdefec07"}, "originalPosition": 71}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48440ca61571c86783e347f4ec9bc4c1dfa57d4a", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/48440ca61571c86783e347f4ec9bc4c1dfa57d4a", "committedDate": "2020-04-23T13:52:46Z", "message": "totally fix system.properties upgrade"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "197d2ca45be153adbd6f3fefb5dcaae1888477af", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/197d2ca45be153adbd6f3fefb5dcaae1888477af", "committedDate": "2020-04-23T14:26:46Z", "message": "fix tsfile upgrade"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6648e8505da61f4e4188f9cba477639b6faf6b47", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/6648e8505da61f4e4188f9cba477639b6faf6b47", "committedDate": "2020-04-23T14:30:00Z", "message": "fix sonar"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "599e268a4409dc8ffa052294db016ec632b59cec", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/599e268a4409dc8ffa052294db016ec632b59cec", "committedDate": "2020-04-23T14:54:55Z", "message": "fix review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d4cdd2cd4c42ecec9c65640b437c0d8971ca868", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/5d4cdd2cd4c42ecec9c65640b437c0d8971ca868", "committedDate": "2020-04-24T02:09:50Z", "message": "fix query"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25650a210a51bc8d6c57e02e9b1fe5f8dc4a64e7", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/25650a210a51bc8d6c57e02e9b1fe5f8dc4a64e7", "committedDate": "2020-04-26T03:53:13Z", "message": "reduce code smells"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1885d8d682d195a70c0e29d01f45beb5dbd85b4b", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/1885d8d682d195a70c0e29d01f45beb5dbd85b4b", "committedDate": "2020-04-26T05:44:18Z", "message": "reduce code smells"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe5505d2b1eaf5f5856a1aec4d2557227bcd3ce4", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/fe5505d2b1eaf5f5856a1aec4d2557227bcd3ce4", "committedDate": "2020-04-26T05:56:21Z", "message": "reduce code smells"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42a913e9c773cfc9c6fff8d043cff46a671de8c5", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/42a913e9c773cfc9c6fff8d043cff46a671de8c5", "committedDate": "2020-04-26T10:00:13Z", "message": "fix query old data with text datatype"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee90844f134b181c475a9887851af8117bfaa350", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/ee90844f134b181c475a9887851af8117bfaa350", "committedDate": "2020-04-26T10:11:48Z", "message": "move register storageengine back to the end"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f273600bc99a98e5aefe6b33db433343601eeb95", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/f273600bc99a98e5aefe6b33db433343601eeb95", "committedDate": "2020-04-27T08:15:46Z", "message": "remove empty tmp partition dirs in upgrade dir"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43f23eb7fac7b0b3608475559b622cb52a80dabd", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/43f23eb7fac7b0b3608475559b622cb52a80dabd", "committedDate": "2020-04-27T09:27:52Z", "message": "do not create upgrade when there are no old files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49ff1941a8866e2131a8f4c30018394ab2ed9e90", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/49ff1941a8866e2131a8f4c30018394ab2ed9e90", "committedDate": "2020-04-27T10:42:29Z", "message": "remove empty upgrade dir"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca20dce4109781b30c663a15046dc52ac50b11a9", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/ca20dce4109781b30c663a15046dc52ac50b11a9", "committedDate": "2020-04-27T14:01:17Z", "message": "Merge branch 'master' into upgrade_tool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa88f1899456f9b2ed374410741c73f0c6380e0f", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/aa88f1899456f9b2ed374410741c73f0c6380e0f", "committedDate": "2020-04-29T02:07:05Z", "message": "Merge branch 'master' of https://github.com/apache/incubator-iotdb into upgrade_tool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "322029efca7e931b00c4c8ed4ec23a65aee1c62b", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/322029efca7e931b00c4c8ed4ec23a65aee1c62b", "committedDate": "2020-04-30T03:18:24Z", "message": "merge master and resolve conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eed08dee6751ca465f1de4c0c61c2efab7b412ce", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/eed08dee6751ca465f1de4c0c61c2efab7b412ce", "committedDate": "2020-04-30T03:18:39Z", "message": "Merge branch 'master' of https://github.com/apache/incubator-iotdb into upgrade_tool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee5503cb716eb4f7ff025bd6276bfe1048cc42e0", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/ee5503cb716eb4f7ff025bd6276bfe1048cc42e0", "committedDate": "2020-04-30T06:14:02Z", "message": "fix bugs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3375d6a0c5b65c5b704f342570121bd43449ce2", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/e3375d6a0c5b65c5b704f342570121bd43449ce2", "committedDate": "2020-05-04T17:15:35Z", "message": "fix get file in upgrading mlog"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6683f0a76e88f7191e44f28cc82edb9f9993a171", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/6683f0a76e88f7191e44f28cc82edb9f9993a171", "committedDate": "2020-05-06T02:36:33Z", "message": "Merge branch 'master' of https://github.com/apache/incubator-iotdb into upgrade_tool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "627f8551c186c329fc17d42ee292da001aa1b0b4", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/627f8551c186c329fc17d42ee292da001aa1b0b4", "committedDate": "2020-05-06T05:50:56Z", "message": "fix code smells"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af744a33340c3dbae4b142a0a18cd272a38870c2", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/af744a33340c3dbae4b142a0a18cd272a38870c2", "committedDate": "2020-05-06T13:18:32Z", "message": "remove unnecessary code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ace75a0ee5833b53fdc361deca28de9b641b2e8", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/2ace75a0ee5833b53fdc361deca28de9b641b2e8", "committedDate": "2020-05-07T04:04:52Z", "message": "merge master and fix cache timeseriesmetadata from 0.9 file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a79e8fb6ef7c5e27fd6ecba5bd4cf253c33f24ac", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/a79e8fb6ef7c5e27fd6ecba5bd4cf253c33f24ac", "committedDate": "2020-05-07T04:07:07Z", "message": "open upgrade service"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/e42cbb6a5bae08661155c7927ae6b97e9012aa05", "committedDate": "2020-05-09T03:08:21Z", "message": "Merge branch 'master' into upgrade_tool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f353517a99b190223ad69c1aa291c6d516cc745", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/3f353517a99b190223ad69c1aa291c6d516cc745", "committedDate": "2020-05-10T04:06:18Z", "message": "Fix wrong usage of FSFactoryProducer"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NjMyNjI5", "url": "https://github.com/apache/iotdb/pull/983#pullrequestreview-408632629", "createdAt": "2020-05-09T09:26:06Z", "commit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "state": "COMMENTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwOToyNjowNlrOGS5y-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQwODo0ODozMFrOGTCNBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ3NDQ5MA==", "bodyText": "this check is not needed", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422474490", "createdAt": "2020-05-09T09:26:06Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -99,48 +101,103 @@ private void checkFile(String filepath) {\n           properties.setProperty(\"iotdb_version\", iotdbVersion);\n           properties.store(outputStream, \"System properties:\");\n         }\n+        checkProperties();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU3NzAxNg==", "bodyText": "FSFactoryProducer is not designed for system file. We need to construct a SystemFileProducer", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422577016", "createdAt": "2020-05-10T03:12:17Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MLogWriter.java", "diffHunk": "@@ -124,7 +124,8 @@ public void changeOffset(String path, long offset) throws IOException {\n   public static void upgradeMLog(String schemaDir, String logFileName) throws IOException {\n     File logFile = FSFactoryProducer.getFSFactory()\n         .getFile(schemaDir + File.separator + logFileName);\n-    File tmpLogFile = new File(logFile.getAbsolutePath() + \".tmp\");\n+    File tmpLogFile = FSFactoryProducer.getFSFactory()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4MDQyMQ==", "bodyText": "it's better to store this file in directoryPath / upgrade folder, be consistent with other partitions", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422580421", "createdAt": "2020-05-10T03:58:26Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/version/SimpleFileVersionController.java", "diffHunk": "@@ -54,6 +55,15 @@ public SimpleFileVersionController(String directoryPath, long timePartitionId)\n     restore();\n   }\n \n+  /**\n+   * only used for upgrading\n+   */\n+  public SimpleFileVersionController(String directoryPath) throws IOException {\n+    this.directoryPath = directoryPath;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4MDUxOA==", "bodyText": "add javadoc: for upgrade? in which case this will be called", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422580518", "createdAt": "2020-05-10T03:59:41Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/reader/chunk/metadata/DiskChunkMetadataLoader.java", "diffHunk": "@@ -63,6 +63,10 @@ public DiskChunkMetadataLoader(TsFileResource resource, Path seriesPath, QueryCo\n             || chunkMetaData.getStartTime() > chunkMetaData.getEndTime());\n     return chunkMetadataList;\n   }\n+  \n+  public void setDiskChunkLoader(List<ChunkMetadata> chunkMetadataList) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4MDY4OQ==", "bodyText": "How about combining this class with TsFileOnlineUpgradeTool", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422580689", "createdAt": "2020-05-10T04:01:56Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/tools/upgrade/UpgradeTool.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.upgrade;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.tsfile.exception.write.WriteProcessException;\n+\n+public class UpgradeTool {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4MDg2Mg==", "bodyText": "why not just use the upgradeSeqFileList.size()?", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422580862", "createdAt": "2020-05-10T04:04:27Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1313,12 +1450,12 @@ private void closeUnsealedTsFileProcessorCallBack(\n    */\n   public int countUpgradeFiles() {\n     int cntUpgradeFileNum = 0;\n-    for (TsFileResource seqTsFileResource : sequenceFileTreeSet) {\n+    for (TsFileResource seqTsFileResource : upgradeSeqFileList) {\n       if (UpgradeUtils.isNeedUpgrade(seqTsFileResource)) {\n         cntUpgradeFileNum += 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4MDg3Nw==", "bodyText": "the same with above", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422580877", "createdAt": "2020-05-10T04:04:44Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1313,12 +1450,12 @@ private void closeUnsealedTsFileProcessorCallBack(\n    */\n   public int countUpgradeFiles() {\n     int cntUpgradeFileNum = 0;\n-    for (TsFileResource seqTsFileResource : sequenceFileTreeSet) {\n+    for (TsFileResource seqTsFileResource : upgradeSeqFileList) {\n       if (UpgradeUtils.isNeedUpgrade(seqTsFileResource)) {\n         cntUpgradeFileNum += 1;\n       }\n     }\n-    for (TsFileResource unseqTsFileResource : unSequenceFileList) {\n+    for (TsFileResource unseqTsFileResource : upgradeUnseqFileList) {\n       if (UpgradeUtils.isNeedUpgrade(unseqTsFileResource)) {\n         cntUpgradeFileNum += 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 300}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4MTAyMQ==", "bodyText": "I can not come up with why we need this method. In merge process, the candidate files should all come from the new files.", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422581021", "createdAt": "2020-05-10T04:06:27Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/UpgradeUtils.java", "diffHunk": "@@ -76,9 +76,13 @@ public static boolean isNeedUpgrade(TsFileResource tsFileResource) {\n     return false;\n   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4MTA5NA==", "bodyText": "add javadoc", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422581094", "createdAt": "2020-05-10T04:07:48Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/UpgradeUtils.java", "diffHunk": "@@ -76,9 +76,13 @@ public static boolean isNeedUpgrade(TsFileResource tsFileResource) {\n     return false;\n   }\n \n-  public static String getUpgradeFileName(File upgradeResource) {\n-    return upgradeResource.getParentFile().getParent() + File.separator + TMP_STRING\n-        + File.separator + UPGRADE_FILE_PREFIX + upgradeResource.getName();\n+  public static String getOneUpgradedFileName(TsFileResource upgradeResource)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4MTE4Mw==", "bodyText": "I thought upgradedResource does not have a partitionId. Is the upgradeResource a upgraded or to be upgraded?", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422581183", "createdAt": "2020-05-10T04:08:39Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/UpgradeUtils.java", "diffHunk": "@@ -76,9 +76,13 @@ public static boolean isNeedUpgrade(TsFileResource tsFileResource) {\n     return false;\n   }\n \n-  public static String getUpgradeFileName(File upgradeResource) {\n-    return upgradeResource.getParentFile().getParent() + File.separator + TMP_STRING\n-        + File.separator + UPGRADE_FILE_PREFIX + upgradeResource.getName();\n+  public static String getOneUpgradedFileName(TsFileResource upgradeResource)\n+      throws IOException {\n+    upgradeResource.deserialize();\n+    long firstPartitionId = upgradeResource.getTimePartition();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4ODEwOQ==", "bodyText": "add javadoc   for  old tsfile", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422588109", "createdAt": "2020-05-10T05:30:46Z", "author": {"login": "qiaojialin"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/TimeseriesMetadata.java", "diffHunk": "@@ -114,10 +118,26 @@ public void setChunkMetadataLoader(IChunkMetadataLoader chunkMetadataLoader) {\n     this.chunkMetadataLoader = chunkMetadataLoader;\n   }\n \n+\n   public List<ChunkMetadata> loadChunkMetadataList() throws IOException {\n+    if (chunkMetadataList != null) {\n+      chunkMetadataLoader.setDiskChunkLoader(chunkMetadataList);\n+      return chunkMetadataList;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU5OTQzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    long offsetOfChunkGroupMetaData = oldChunkGroupMetadata.getStartOffsetOfChunkGroup();\n          \n          \n            \n                    long offsetOfChunkGroup = oldChunkGroupMetadata.getStartOffsetOfChunkGroup();", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422599437", "createdAt": "2020-05-10T07:07:03Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/tools/upgrade/TsfileOnlineUpgradeTool.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.upgrade;\n+\n+import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.tsfile.common.conf.TSFileConfig;\n+import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n+import org.apache.iotdb.tsfile.compress.IUnCompressor;\n+import org.apache.iotdb.tsfile.encoding.decoder.Decoder;\n+import org.apache.iotdb.tsfile.exception.write.PageException;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.exception.write.WriteProcessException;\n+import org.apache.iotdb.tsfile.file.MetaMarker;\n+import org.apache.iotdb.tsfile.file.footer.ChunkGroupFooter;\n+import org.apache.iotdb.tsfile.file.header.ChunkHeader;\n+import org.apache.iotdb.tsfile.file.header.PageHeader;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkGroupMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldChunkGroupMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.OldChunkMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsDeviceMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsDeviceMetadataIndex;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsFileMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.TimeseriesMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.reader.LocalTsFileInput;\n+import org.apache.iotdb.tsfile.read.reader.TsFileInput;\n+import org.apache.iotdb.tsfile.read.reader.page.PageReader;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.apache.iotdb.tsfile.write.chunk.ChunkWriterImpl;\n+import org.apache.iotdb.tsfile.write.chunk.IChunkWriter;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.iotdb.tsfile.write.writer.TsFileIOWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+public class TsfileOnlineUpgradeTool implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(TsfileOnlineUpgradeTool.class);\n+\n+  private TsFileInput tsFileInput;\n+  private long fileMetadataPos;\n+  private int fileMetadataSize;\n+  private ByteBuffer markerBuffer = ByteBuffer.allocate(Byte.BYTES);\n+  protected String file;\n+  \n+  // PartitionId -> TsFileIOWriter \n+  private Map<Long, TsFileIOWriter> partitionWriterMap;\n+\n+  /**\n+   * Create a file reader of the given file. The reader will read the tail of the file to get the\n+   * file metadata size.Then the reader will skip the first TSFileConfig.OLD_MAGIC_STRING.length()\n+   * bytes of the file for preparing reading real data.\n+   *\n+   * @param file the data file\n+   * @throws IOException If some I/O error occurs\n+   */\n+  public TsfileOnlineUpgradeTool(String file) throws IOException {\n+    this(file, true);\n+  }\n+\n+  /**\n+   * construct function for TsfileOnlineUpgradeTool.\n+   *\n+   * @param file -given file name\n+   * @param loadMetadataSize -load meta data size\n+   */\n+  public TsfileOnlineUpgradeTool(String file, boolean loadMetadataSize) throws IOException {\n+    this.file = file;\n+    final java.nio.file.Path path = Paths.get(file);\n+    tsFileInput = new LocalTsFileInput(path);\n+    partitionWriterMap = new HashMap<>();\n+    try {\n+      if (loadMetadataSize) {\n+        loadMetadataSize();\n+      }\n+    } catch (Exception e) {\n+      tsFileInput.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * \n+   */\n+  public void loadMetadataSize() throws IOException {\n+    ByteBuffer metadataSize = ByteBuffer.allocate(Integer.BYTES);\n+    tsFileInput.read(metadataSize,\n+        tsFileInput.size() - TSFileConfig.MAGIC_STRING.getBytes().length - Integer.BYTES);\n+    metadataSize.flip();\n+    // read file metadata size and position\n+    fileMetadataSize = ReadWriteIOUtils.readInt(metadataSize);\n+    fileMetadataPos =\n+        tsFileInput.size() - TSFileConfig.MAGIC_STRING.getBytes().length - Integer.BYTES\n+            - fileMetadataSize;\n+    // skip the magic header\n+    position(TSFileConfig.MAGIC_STRING.length());\n+  }\n+\n+  public String readTailMagic() throws IOException {\n+    long totalSize = tsFileInput.size();\n+\n+    ByteBuffer magicStringBytes = ByteBuffer.allocate(TSFileConfig.MAGIC_STRING.length());\n+    tsFileInput.read(magicStringBytes, totalSize - TSFileConfig.MAGIC_STRING.length());\n+    magicStringBytes.flip();\n+    return new String(magicStringBytes.array());\n+  }\n+\n+  /**\n+   * whether the file is a complete TsFile: only if the head magic and tail magic string exists.\n+   */\n+  public boolean isComplete() throws IOException {\n+    return tsFileInput.size() >= TSFileConfig.MAGIC_STRING.length() * 2 && readTailMagic()\n+        .equals(readHeadMagic());\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public String readHeadMagic() throws IOException {\n+    return readHeadMagic(false);\n+  }\n+\n+  /**\n+   * @param movePosition whether move the position of the file reader after reading the magic header\n+   * to the end of the magic head string.\n+   */\n+  public String readHeadMagic(boolean movePosition) throws IOException {\n+    ByteBuffer magicStringBytes = ByteBuffer.allocate(TSFileConfig.MAGIC_STRING.length());\n+    if (movePosition) {\n+      tsFileInput.position(0);\n+      tsFileInput.read(magicStringBytes);\n+    } else {\n+      tsFileInput.read(magicStringBytes, 0);\n+    }\n+    magicStringBytes.flip();\n+    return new String(magicStringBytes.array());\n+  }\n+\n+  /**\n+   * this function reads version number and checks compatibility of TsFile.\n+   */\n+  public String readVersionNumber() throws IOException {\n+    ByteBuffer versionNumberBytes = ByteBuffer\n+        .allocate(TSFileConfig.VERSION_NUMBER.getBytes().length);\n+    tsFileInput.position(TSFileConfig.MAGIC_STRING.getBytes().length);\n+    tsFileInput.read(versionNumberBytes);\n+    versionNumberBytes.flip();\n+    return new String(versionNumberBytes.array());\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public OldTsFileMetadata readFileMetadata() throws IOException {\n+    return OldTsFileMetadata.deserializeFrom(readData(fileMetadataPos, fileMetadataSize));\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public OldTsDeviceMetadata readTsDeviceMetaData(OldTsDeviceMetadataIndex index) throws IOException {\n+    return OldTsDeviceMetadata.deserializeFrom(readData(index.getOffset(), index.getLen()));\n+  }\n+\n+  /**\n+   * read data from current position of the input, and deserialize it to a CHUNK_GROUP_FOOTER. <br>\n+   * This method is not threadsafe.\n+   *\n+   * @return a CHUNK_GROUP_FOOTER\n+   * @throws IOException io error\n+   */\n+  public ChunkGroupFooter readChunkGroupFooter() throws IOException {\n+    return ChunkGroupFooter.deserializeFrom(tsFileInput.wrapAsInputStream(), true);\n+  }\n+\n+  /**\n+   * read data from current position of the input, and deserialize it to a CHUNK_HEADER. <br> This\n+   * method is not threadsafe.\n+   *\n+   * @return a CHUNK_HEADER\n+   * @throws IOException io error\n+   */\n+  public ChunkHeader readChunkHeader() throws IOException {\n+    return ChunkHeader.deserializeFrom(tsFileInput.wrapAsInputStream(), true, true);\n+  }\n+\n+  /**\n+   * not thread safe.\n+   *\n+   * @param type given tsfile data type\n+   */\n+  public PageHeader readPageHeader(TSDataType type) throws IOException {\n+    return PageHeader.deserializeFrom(tsFileInput.wrapAsInputStream(), type, true);\n+  }\n+\n+  public ByteBuffer readPage(PageHeader header, CompressionType type)\n+      throws IOException {\n+    ByteBuffer buffer = readData(-1, header.getCompressedSize());\n+    IUnCompressor unCompressor = IUnCompressor.getUnCompressor(type);\n+    ByteBuffer uncompressedBuffer = ByteBuffer.allocate(header.getUncompressedSize());\n+    if (type == CompressionType.UNCOMPRESSED) {\n+      return buffer;\n+    }\n+    unCompressor.uncompress(buffer.array(), buffer.position(), buffer.remaining(),\n+        uncompressedBuffer.array(),\n+        0);\n+    return uncompressedBuffer;\n+  }\n+  \n+  public ByteBuffer readCompressedPage(PageHeader header) throws IOException {\n+    return readData(-1, header.getCompressedSize());\n+  }\n+\n+  public long position() throws IOException {\n+    return tsFileInput.position();\n+  }\n+\n+  public void position(long offset) throws IOException {\n+    tsFileInput.position(offset);\n+  }\n+\n+  /**\n+   * read one byte from the input. <br> this method is not thread safe\n+   */\n+  public byte readMarker() throws IOException {\n+    markerBuffer.clear();\n+    if (ReadWriteIOUtils.readAsPossible(tsFileInput, markerBuffer) == 0) {\n+      throw new IOException(\"reach the end of the file.\");\n+    }\n+    markerBuffer.flip();\n+    return markerBuffer.get();\n+  }\n+\n+  public byte readMarker(long position) throws IOException {\n+    return readData(position, Byte.BYTES).get();\n+  }\n+\n+  public void close() throws IOException {\n+    this.tsFileInput.close();\n+  }\n+\n+  public String getFileName() {\n+    return this.file;\n+  }\n+\n+  /**\n+   * read data from tsFileInput, from the current position (if position = -1), or the given\n+   * position. <br> if position = -1, the tsFileInput's position will be changed to the current\n+   * position + real data size that been read. Other wise, the tsFileInput's position is not\n+   * changed.\n+   *\n+   * @param position the start position of data in the tsFileInput, or the current position if\n+   * position = -1\n+   * @param size the size of data that want to read\n+   * @return data that been read.\n+   */\n+  private ByteBuffer readData(long position, int size) throws IOException {\n+    ByteBuffer buffer = ByteBuffer.allocate(size);\n+    if (position == -1) {\n+      if (ReadWriteIOUtils.readAsPossible(tsFileInput, buffer) != size) {\n+        throw new IOException(\"reach the end of the data\");\n+      }\n+    } else {\n+      if (ReadWriteIOUtils.readAsPossible(tsFileInput, buffer, position, size) != size) {\n+        throw new IOException(\"reach the end of the data\");\n+      }\n+    }\n+    buffer.flip();\n+    return buffer;\n+  }\n+\n+  /**\n+   * upgrade file and resource, return the boolean value whether upgrade task completes\n+   * @throws IOException, WriteProcessException \n+   */\n+  public boolean upgradeFile(List<TsFileResource> upgradedResources) \n+      throws IOException, WriteProcessException {\n+    File oldTsFile = FSFactoryProducer.getFSFactory().getFile(this.file);\n+\n+    // check if the old TsFile has correct header \n+    if (!fileCheck(oldTsFile)) {\n+      return false;\n+    }\n+\n+    // ChunkGroupOffset -> version\n+    Map<Long, Long> oldVersionInfo = new HashMap<>();\n+\n+    // ChunkGroupOffset -> time partition, record the offsets of chunk group that data are in same partition\n+    Map<Long, Long> chunkGroupTimePartitionInfo = new HashMap<>();\n+\n+    // scan metadata to get version Info and chunkGroupTimePartitionInfo\n+    scanMetadata(oldVersionInfo, chunkGroupTimePartitionInfo);\n+    \n+    // start to scan chunks and chunkGroups\n+    long startOffsetOfChunkGroup = 0;\n+    boolean newChunkGroup = true;\n+    long versionOfChunkGroup = 0;\n+    boolean chunkGroupInSamePartition = false;\n+    List<ChunkGroupMetadata> newMetaData = new ArrayList<>();\n+    List<List<PageHeader>> pageHeadersInChunkGroup = new ArrayList<>();\n+    List<List<ByteBuffer>> dataInChunkGroup = new ArrayList<>();\n+    byte marker;\n+    List<MeasurementSchema> measurementSchemaList = new ArrayList<>();\n+    try {\n+      while ((marker = this.readMarker()) != MetaMarker.SEPARATOR) {\n+        switch (marker) {\n+          case MetaMarker.CHUNK_HEADER:\n+            // this is the first chunk of a new ChunkGroup.\n+            if (newChunkGroup) {\n+              newChunkGroup = false;\n+              startOffsetOfChunkGroup = this.position() - 1;\n+              versionOfChunkGroup = oldVersionInfo.get(startOffsetOfChunkGroup);\n+              chunkGroupInSamePartition = chunkGroupTimePartitionInfo\n+                  .containsKey(startOffsetOfChunkGroup);\n+            }\n+            ChunkHeader header = this.readChunkHeader();\n+            MeasurementSchema measurementSchema = new MeasurementSchema(header.getMeasurementID(),\n+                header.getDataType(),\n+                header.getEncodingType(), \n+                header.getCompressionType());\n+            measurementSchemaList.add(measurementSchema);\n+            List<PageHeader> pageHeadersInChunk = new ArrayList<>();\n+            List<ByteBuffer> dataInChunk = new ArrayList<>();\n+            for (int j = 0; j < header.getNumOfPages(); j++) {\n+              PageHeader pageHeader = readPageHeader(header.getDataType());\n+              ByteBuffer pageData = chunkGroupInSamePartition ? \n+                  readCompressedPage(pageHeader) : readPage(pageHeader, header.getCompressionType());\n+              pageHeadersInChunk.add(pageHeader);\n+              dataInChunk.add(pageData);\n+            }\n+            pageHeadersInChunkGroup.add(pageHeadersInChunk);\n+            dataInChunkGroup.add(dataInChunk);\n+            break;\n+          case MetaMarker.CHUNK_GROUP_FOOTER:\n+            // this is the footer of a ChunkGroup.\n+            ChunkGroupFooter chunkGroupFooter = this.readChunkGroupFooter();\n+            String deviceID = chunkGroupFooter.getDeviceID();\n+            if (chunkGroupInSamePartition) {\n+              quickRewrite(oldTsFile, deviceID, measurementSchemaList, pageHeadersInChunkGroup,\n+                  dataInChunkGroup, versionOfChunkGroup, chunkGroupTimePartitionInfo.get(startOffsetOfChunkGroup));\n+            } else {\n+              rewrite(oldTsFile, deviceID, measurementSchemaList, \n+                dataInChunkGroup, versionOfChunkGroup);\n+            }\n+\n+            pageHeadersInChunkGroup.clear();\n+            dataInChunkGroup.clear();\n+            measurementSchemaList.clear();\n+            newChunkGroup = true;\n+            break;\n+\n+          default:\n+            // the disk file is corrupted, using this file may be dangerous\n+            logger.error(\"Unrecognized marker detected, this file may be corrupted\");\n+            return false;\n+        }\n+      }\n+      // close upgraded tsFiles and generate resources for them\n+      for (TsFileIOWriter tsFileIOWriter : partitionWriterMap.values()) {\n+        upgradedResources.add(endFileAndGenerateResource(tsFileIOWriter));\n+      }\n+      return true;\n+    } catch (IOException e2) {\n+      logger.info(\"TsFile upgrade process cannot proceed at position {} after {} chunk groups \"\n+          + \"recovered, because : {}\", this.position(), newMetaData.size(), e2.getMessage());\n+      return false;\n+    } finally {\n+      if (tsFileInput != null) {\n+        tsFileInput.close();\n+      }\n+    }\n+  }\n+\n+  /**\n+   *  Rewrite the chunk group to new TsFile.\n+   *  If data of this chunk group are in different time partitions,\n+   *  create multiple new TsFiles and rewrite data in each partition.\n+   */\n+  private void rewrite(File oldTsFile, String deviceId, List<MeasurementSchema> schemas, \n+      List<List<ByteBuffer>> dataInChunkGroup, long versionOfChunkGroup) \n+          throws IOException {\n+\n+    Map<Long, Map<MeasurementSchema, IChunkWriter>> chunkWritersInChunkGroup = new HashMap<>();\n+    for (int i = 0; i < schemas.size(); i++) {\n+      MeasurementSchema schema = schemas.get(i);\n+      Decoder defaultTimeDecoder = Decoder.getDecoderByType(\n+          TSEncoding.valueOf(TSFileDescriptor.getInstance().getConfig().getTimeEncoder()),\n+          TSDataType.INT64);\n+      Decoder valueDecoder = Decoder\n+          .getDecoderByType(schema.getEncodingType(), schema.getType());\n+      List<ByteBuffer> dataInChunk = dataInChunkGroup.get(i);\n+      for (ByteBuffer pageData : dataInChunk) {\n+        valueDecoder.reset();\n+        PageReader pageReader = new PageReader(pageData, schema.getType(), valueDecoder,\n+            defaultTimeDecoder, null);\n+        BatchData batchData = pageReader.getAllSatisfiedPageData();\n+        while (batchData.hasCurrent()) {\n+          long time = batchData.currentTime();\n+          Object value = batchData.currentValue();\n+          long partition = StorageEngine.getTimePartition(time);\n+          \n+          Map<MeasurementSchema, IChunkWriter> chunkWriters = chunkWritersInChunkGroup.getOrDefault(partition, new HashMap<>());\n+          IChunkWriter chunkWriter = chunkWriters.getOrDefault(schema, new ChunkWriterImpl(schema));\n+          TsFileIOWriter tsFileIOWriter = getOrDefaultTsFileIOWriter(oldTsFile, partition);\n+          partitionWriterMap.put(partition, tsFileIOWriter);\n+          switch (schema.getType()) {\n+            case INT32:\n+              chunkWriter.write(time, (int) value);\n+              break;\n+            case INT64:\n+              chunkWriter.write(time, (long) value);\n+              break;\n+            case FLOAT:\n+              chunkWriter.write(time, (float) value);\n+              break;\n+            case DOUBLE:\n+              chunkWriter.write(time, (double) value);\n+              break;\n+            case BOOLEAN:\n+              chunkWriter.write(time, (boolean) value);\n+              break;\n+            case TEXT:\n+              chunkWriter.write(time, (Binary) value);\n+              break;\n+            default:\n+              throw new UnSupportedDataTypeException(\n+                  String.format(\"Data type %s is not supported.\", schema.getType()));\n+            }\n+          chunkWriters.put(schema, chunkWriter);\n+          chunkWritersInChunkGroup.put(partition, chunkWriters);\n+          batchData.next();\n+        }\n+      }\n+    }\n+    // set version info to each upgraded tsFile \n+    for (Entry<Long, Map<MeasurementSchema, IChunkWriter>> entry : chunkWritersInChunkGroup.entrySet()) {\n+      long partition = entry.getKey();\n+      TsFileIOWriter tsFileIOWriter = partitionWriterMap.get(partition);\n+      tsFileIOWriter.startChunkGroup(deviceId);\n+      for (IChunkWriter chunkWriter : entry.getValue().values()) {\n+        chunkWriter.writeToFileWriter(tsFileIOWriter);\n+      }\n+      tsFileIOWriter.endChunkGroup();\n+      tsFileIOWriter.writeVersion(versionOfChunkGroup);\n+    }\n+  }\n+\n+  /**\n+   * \n+   * @param oldTsFile\n+   * @param deviceId\n+   * @param schemas\n+   * @param pageHeadersInChunkGroup\n+   * @param dataInChunkGroup\n+   * @param versionOfChunkGroup\n+   * @param partition\n+   * @throws IOException\n+   * @throws PageException\n+   */\n+  private void quickRewrite(File oldTsFile, String deviceId, List<MeasurementSchema> schemas, \n+      List<List<PageHeader>> pageHeadersInChunkGroup, List<List<ByteBuffer>> dataInChunkGroup, \n+      long versionOfChunkGroup, long partition) throws IOException, PageException {\n+    TsFileIOWriter tsFileIOWriter = getOrDefaultTsFileIOWriter(oldTsFile, partition);\n+    tsFileIOWriter.startChunkGroup(deviceId);\n+    for (int i = 0; i < schemas.size(); i++) {\n+      ChunkWriterImpl chunkWriter = new ChunkWriterImpl(schemas.get(i));\n+      List<PageHeader> pageHeaderList = pageHeadersInChunkGroup.get(i);\n+      List<ByteBuffer> pageList = dataInChunkGroup.get(i);\n+      for (int j = 0; j < pageHeaderList.size(); j++) {\n+        chunkWriter.writePageHeaderAndDataIntoBuff(pageList.get(j), pageHeaderList.get(j));\n+      }\n+      chunkWriter.writeToFileWriter(tsFileIOWriter);\n+    }\n+    tsFileIOWriter.endChunkGroup();\n+    tsFileIOWriter.writeVersion(versionOfChunkGroup);\n+  }\n+\n+  private TsFileIOWriter getOrDefaultTsFileIOWriter(File oldTsFile, long partition) {\n+    return partitionWriterMap.computeIfAbsent(partition, k -> \n+      {\n+        File partitionDir = FSFactoryProducer.getFSFactory().getFile(oldTsFile.getParent()\n+            + File.separator + partition);\n+        if (!partitionDir.exists()) {\n+          partitionDir.mkdirs();\n+        }\n+        File newFile = FSFactoryProducer.getFSFactory().getFile(oldTsFile.getParent()\n+            + File.separator + partition + File.separator+ oldTsFile.getName());\n+        try {\n+          if (!newFile.createNewFile()) {\n+            logger.error(\"The TsFile {} has been created \", newFile);\n+            return null;\n+          }\n+          return new TsFileIOWriter(newFile);\n+        } catch (IOException e) {\n+          logger.error(\"Create new TsFile {} failed \", newFile);\n+          return null;\n+        }\n+      }\n+    );\n+  }\n+\n+  /**\n+   *  check if the file to be upgraded has correct magic strings and version number\n+   *  @param oldTsFile\n+   *  @throws IOException \n+   */\n+  private boolean fileCheck(File oldTsFile) throws IOException {\n+    long fileSize;\n+    if (!oldTsFile.exists()) {\n+      logger.error(\"the file to be updated does not exist, file path: {}\", oldTsFile.getPath());\n+      return false;\n+    } else {\n+      fileSize = oldTsFile.length();\n+    }\n+\n+    String magic = readHeadMagic(true);\n+    if (!magic.equals(TSFileConfig.MAGIC_STRING)) {\n+      logger.error(\"the file's MAGIC STRING is incorrect, file path: {}\", oldTsFile.getPath());\n+      return false;\n+    }\n+    \n+    String versionNumber = readVersionNumber();\n+    if (!versionNumber.equals(TSFileConfig.OLD_VERSION)) {\n+      logger.error(\"the file's Version Number is incorrect, file path: {}\", oldTsFile.getPath());\n+      return false;\n+    }\n+\n+    if (fileSize == TSFileConfig.MAGIC_STRING.length()) {\n+      logger.error(\"the file only contains magic string, file path: {}\", oldTsFile.getPath());\n+      return false;\n+    } else if (!readTailMagic().equals(TSFileConfig.MAGIC_STRING)) {\n+      logger.error(\"the file cannot upgrade, file path: {}\", oldTsFile.getPath());\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private void scanMetadata(Map<Long, Long> oldVersionInfo, \n+      Map<Long, Long> chunkGroupTimePartitionInfo) throws IOException {\n+    OldTsFileMetadata fileMetadata = readFileMetadata();\n+    List<OldTsDeviceMetadata> oldDeviceMetadataList = new ArrayList<>();\n+    for (OldTsDeviceMetadataIndex index : fileMetadata.getDeviceMap().values()) {\n+      OldTsDeviceMetadata oldDeviceMetadata = readTsDeviceMetaData(index);\n+      oldDeviceMetadataList.add(oldDeviceMetadata);\n+    }\n+\n+    for (OldTsDeviceMetadata oldTsDeviceMetadata : oldDeviceMetadataList) {\n+      for (OldChunkGroupMetaData oldChunkGroupMetadata : oldTsDeviceMetadata\n+          .getChunkGroupMetaDataList()) {\n+        long version = oldChunkGroupMetadata.getVersion();\n+        long offsetOfChunkGroupMetaData = oldChunkGroupMetadata.getStartOffsetOfChunkGroup();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 583}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYwMjAwNA==", "bodyText": "add javadoc or rename to rewriteCompressedPage", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422602004", "createdAt": "2020-05-10T07:31:54Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/tools/upgrade/TsfileOnlineUpgradeTool.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.upgrade;\n+\n+import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.tsfile.common.conf.TSFileConfig;\n+import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n+import org.apache.iotdb.tsfile.compress.IUnCompressor;\n+import org.apache.iotdb.tsfile.encoding.decoder.Decoder;\n+import org.apache.iotdb.tsfile.exception.write.PageException;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.exception.write.WriteProcessException;\n+import org.apache.iotdb.tsfile.file.MetaMarker;\n+import org.apache.iotdb.tsfile.file.footer.ChunkGroupFooter;\n+import org.apache.iotdb.tsfile.file.header.ChunkHeader;\n+import org.apache.iotdb.tsfile.file.header.PageHeader;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkGroupMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldChunkGroupMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.OldChunkMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsDeviceMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsDeviceMetadataIndex;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsFileMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.TimeseriesMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.reader.LocalTsFileInput;\n+import org.apache.iotdb.tsfile.read.reader.TsFileInput;\n+import org.apache.iotdb.tsfile.read.reader.page.PageReader;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.apache.iotdb.tsfile.write.chunk.ChunkWriterImpl;\n+import org.apache.iotdb.tsfile.write.chunk.IChunkWriter;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.iotdb.tsfile.write.writer.TsFileIOWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+public class TsfileOnlineUpgradeTool implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(TsfileOnlineUpgradeTool.class);\n+\n+  private TsFileInput tsFileInput;\n+  private long fileMetadataPos;\n+  private int fileMetadataSize;\n+  private ByteBuffer markerBuffer = ByteBuffer.allocate(Byte.BYTES);\n+  protected String file;\n+  \n+  // PartitionId -> TsFileIOWriter \n+  private Map<Long, TsFileIOWriter> partitionWriterMap;\n+\n+  /**\n+   * Create a file reader of the given file. The reader will read the tail of the file to get the\n+   * file metadata size.Then the reader will skip the first TSFileConfig.OLD_MAGIC_STRING.length()\n+   * bytes of the file for preparing reading real data.\n+   *\n+   * @param file the data file\n+   * @throws IOException If some I/O error occurs\n+   */\n+  public TsfileOnlineUpgradeTool(String file) throws IOException {\n+    this(file, true);\n+  }\n+\n+  /**\n+   * construct function for TsfileOnlineUpgradeTool.\n+   *\n+   * @param file -given file name\n+   * @param loadMetadataSize -load meta data size\n+   */\n+  public TsfileOnlineUpgradeTool(String file, boolean loadMetadataSize) throws IOException {\n+    this.file = file;\n+    final java.nio.file.Path path = Paths.get(file);\n+    tsFileInput = new LocalTsFileInput(path);\n+    partitionWriterMap = new HashMap<>();\n+    try {\n+      if (loadMetadataSize) {\n+        loadMetadataSize();\n+      }\n+    } catch (Exception e) {\n+      tsFileInput.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * \n+   */\n+  public void loadMetadataSize() throws IOException {\n+    ByteBuffer metadataSize = ByteBuffer.allocate(Integer.BYTES);\n+    tsFileInput.read(metadataSize,\n+        tsFileInput.size() - TSFileConfig.MAGIC_STRING.getBytes().length - Integer.BYTES);\n+    metadataSize.flip();\n+    // read file metadata size and position\n+    fileMetadataSize = ReadWriteIOUtils.readInt(metadataSize);\n+    fileMetadataPos =\n+        tsFileInput.size() - TSFileConfig.MAGIC_STRING.getBytes().length - Integer.BYTES\n+            - fileMetadataSize;\n+    // skip the magic header\n+    position(TSFileConfig.MAGIC_STRING.length());\n+  }\n+\n+  public String readTailMagic() throws IOException {\n+    long totalSize = tsFileInput.size();\n+\n+    ByteBuffer magicStringBytes = ByteBuffer.allocate(TSFileConfig.MAGIC_STRING.length());\n+    tsFileInput.read(magicStringBytes, totalSize - TSFileConfig.MAGIC_STRING.length());\n+    magicStringBytes.flip();\n+    return new String(magicStringBytes.array());\n+  }\n+\n+  /**\n+   * whether the file is a complete TsFile: only if the head magic and tail magic string exists.\n+   */\n+  public boolean isComplete() throws IOException {\n+    return tsFileInput.size() >= TSFileConfig.MAGIC_STRING.length() * 2 && readTailMagic()\n+        .equals(readHeadMagic());\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public String readHeadMagic() throws IOException {\n+    return readHeadMagic(false);\n+  }\n+\n+  /**\n+   * @param movePosition whether move the position of the file reader after reading the magic header\n+   * to the end of the magic head string.\n+   */\n+  public String readHeadMagic(boolean movePosition) throws IOException {\n+    ByteBuffer magicStringBytes = ByteBuffer.allocate(TSFileConfig.MAGIC_STRING.length());\n+    if (movePosition) {\n+      tsFileInput.position(0);\n+      tsFileInput.read(magicStringBytes);\n+    } else {\n+      tsFileInput.read(magicStringBytes, 0);\n+    }\n+    magicStringBytes.flip();\n+    return new String(magicStringBytes.array());\n+  }\n+\n+  /**\n+   * this function reads version number and checks compatibility of TsFile.\n+   */\n+  public String readVersionNumber() throws IOException {\n+    ByteBuffer versionNumberBytes = ByteBuffer\n+        .allocate(TSFileConfig.VERSION_NUMBER.getBytes().length);\n+    tsFileInput.position(TSFileConfig.MAGIC_STRING.getBytes().length);\n+    tsFileInput.read(versionNumberBytes);\n+    versionNumberBytes.flip();\n+    return new String(versionNumberBytes.array());\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public OldTsFileMetadata readFileMetadata() throws IOException {\n+    return OldTsFileMetadata.deserializeFrom(readData(fileMetadataPos, fileMetadataSize));\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public OldTsDeviceMetadata readTsDeviceMetaData(OldTsDeviceMetadataIndex index) throws IOException {\n+    return OldTsDeviceMetadata.deserializeFrom(readData(index.getOffset(), index.getLen()));\n+  }\n+\n+  /**\n+   * read data from current position of the input, and deserialize it to a CHUNK_GROUP_FOOTER. <br>\n+   * This method is not threadsafe.\n+   *\n+   * @return a CHUNK_GROUP_FOOTER\n+   * @throws IOException io error\n+   */\n+  public ChunkGroupFooter readChunkGroupFooter() throws IOException {\n+    return ChunkGroupFooter.deserializeFrom(tsFileInput.wrapAsInputStream(), true);\n+  }\n+\n+  /**\n+   * read data from current position of the input, and deserialize it to a CHUNK_HEADER. <br> This\n+   * method is not threadsafe.\n+   *\n+   * @return a CHUNK_HEADER\n+   * @throws IOException io error\n+   */\n+  public ChunkHeader readChunkHeader() throws IOException {\n+    return ChunkHeader.deserializeFrom(tsFileInput.wrapAsInputStream(), true, true);\n+  }\n+\n+  /**\n+   * not thread safe.\n+   *\n+   * @param type given tsfile data type\n+   */\n+  public PageHeader readPageHeader(TSDataType type) throws IOException {\n+    return PageHeader.deserializeFrom(tsFileInput.wrapAsInputStream(), type, true);\n+  }\n+\n+  public ByteBuffer readPage(PageHeader header, CompressionType type)\n+      throws IOException {\n+    ByteBuffer buffer = readData(-1, header.getCompressedSize());\n+    IUnCompressor unCompressor = IUnCompressor.getUnCompressor(type);\n+    ByteBuffer uncompressedBuffer = ByteBuffer.allocate(header.getUncompressedSize());\n+    if (type == CompressionType.UNCOMPRESSED) {\n+      return buffer;\n+    }\n+    unCompressor.uncompress(buffer.array(), buffer.position(), buffer.remaining(),\n+        uncompressedBuffer.array(),\n+        0);\n+    return uncompressedBuffer;\n+  }\n+  \n+  public ByteBuffer readCompressedPage(PageHeader header) throws IOException {\n+    return readData(-1, header.getCompressedSize());\n+  }\n+\n+  public long position() throws IOException {\n+    return tsFileInput.position();\n+  }\n+\n+  public void position(long offset) throws IOException {\n+    tsFileInput.position(offset);\n+  }\n+\n+  /**\n+   * read one byte from the input. <br> this method is not thread safe\n+   */\n+  public byte readMarker() throws IOException {\n+    markerBuffer.clear();\n+    if (ReadWriteIOUtils.readAsPossible(tsFileInput, markerBuffer) == 0) {\n+      throw new IOException(\"reach the end of the file.\");\n+    }\n+    markerBuffer.flip();\n+    return markerBuffer.get();\n+  }\n+\n+  public byte readMarker(long position) throws IOException {\n+    return readData(position, Byte.BYTES).get();\n+  }\n+\n+  public void close() throws IOException {\n+    this.tsFileInput.close();\n+  }\n+\n+  public String getFileName() {\n+    return this.file;\n+  }\n+\n+  /**\n+   * read data from tsFileInput, from the current position (if position = -1), or the given\n+   * position. <br> if position = -1, the tsFileInput's position will be changed to the current\n+   * position + real data size that been read. Other wise, the tsFileInput's position is not\n+   * changed.\n+   *\n+   * @param position the start position of data in the tsFileInput, or the current position if\n+   * position = -1\n+   * @param size the size of data that want to read\n+   * @return data that been read.\n+   */\n+  private ByteBuffer readData(long position, int size) throws IOException {\n+    ByteBuffer buffer = ByteBuffer.allocate(size);\n+    if (position == -1) {\n+      if (ReadWriteIOUtils.readAsPossible(tsFileInput, buffer) != size) {\n+        throw new IOException(\"reach the end of the data\");\n+      }\n+    } else {\n+      if (ReadWriteIOUtils.readAsPossible(tsFileInput, buffer, position, size) != size) {\n+        throw new IOException(\"reach the end of the data\");\n+      }\n+    }\n+    buffer.flip();\n+    return buffer;\n+  }\n+\n+  /**\n+   * upgrade file and resource, return the boolean value whether upgrade task completes\n+   * @throws IOException, WriteProcessException \n+   */\n+  public boolean upgradeFile(List<TsFileResource> upgradedResources) \n+      throws IOException, WriteProcessException {\n+    File oldTsFile = FSFactoryProducer.getFSFactory().getFile(this.file);\n+\n+    // check if the old TsFile has correct header \n+    if (!fileCheck(oldTsFile)) {\n+      return false;\n+    }\n+\n+    // ChunkGroupOffset -> version\n+    Map<Long, Long> oldVersionInfo = new HashMap<>();\n+\n+    // ChunkGroupOffset -> time partition, record the offsets of chunk group that data are in same partition\n+    Map<Long, Long> chunkGroupTimePartitionInfo = new HashMap<>();\n+\n+    // scan metadata to get version Info and chunkGroupTimePartitionInfo\n+    scanMetadata(oldVersionInfo, chunkGroupTimePartitionInfo);\n+    \n+    // start to scan chunks and chunkGroups\n+    long startOffsetOfChunkGroup = 0;\n+    boolean newChunkGroup = true;\n+    long versionOfChunkGroup = 0;\n+    boolean chunkGroupInSamePartition = false;\n+    List<ChunkGroupMetadata> newMetaData = new ArrayList<>();\n+    List<List<PageHeader>> pageHeadersInChunkGroup = new ArrayList<>();\n+    List<List<ByteBuffer>> dataInChunkGroup = new ArrayList<>();\n+    byte marker;\n+    List<MeasurementSchema> measurementSchemaList = new ArrayList<>();\n+    try {\n+      while ((marker = this.readMarker()) != MetaMarker.SEPARATOR) {\n+        switch (marker) {\n+          case MetaMarker.CHUNK_HEADER:\n+            // this is the first chunk of a new ChunkGroup.\n+            if (newChunkGroup) {\n+              newChunkGroup = false;\n+              startOffsetOfChunkGroup = this.position() - 1;\n+              versionOfChunkGroup = oldVersionInfo.get(startOffsetOfChunkGroup);\n+              chunkGroupInSamePartition = chunkGroupTimePartitionInfo\n+                  .containsKey(startOffsetOfChunkGroup);\n+            }\n+            ChunkHeader header = this.readChunkHeader();\n+            MeasurementSchema measurementSchema = new MeasurementSchema(header.getMeasurementID(),\n+                header.getDataType(),\n+                header.getEncodingType(), \n+                header.getCompressionType());\n+            measurementSchemaList.add(measurementSchema);\n+            List<PageHeader> pageHeadersInChunk = new ArrayList<>();\n+            List<ByteBuffer> dataInChunk = new ArrayList<>();\n+            for (int j = 0; j < header.getNumOfPages(); j++) {\n+              PageHeader pageHeader = readPageHeader(header.getDataType());\n+              ByteBuffer pageData = chunkGroupInSamePartition ? \n+                  readCompressedPage(pageHeader) : readPage(pageHeader, header.getCompressionType());\n+              pageHeadersInChunk.add(pageHeader);\n+              dataInChunk.add(pageData);\n+            }\n+            pageHeadersInChunkGroup.add(pageHeadersInChunk);\n+            dataInChunkGroup.add(dataInChunk);\n+            break;\n+          case MetaMarker.CHUNK_GROUP_FOOTER:\n+            // this is the footer of a ChunkGroup.\n+            ChunkGroupFooter chunkGroupFooter = this.readChunkGroupFooter();\n+            String deviceID = chunkGroupFooter.getDeviceID();\n+            if (chunkGroupInSamePartition) {\n+              quickRewrite(oldTsFile, deviceID, measurementSchemaList, pageHeadersInChunkGroup,\n+                  dataInChunkGroup, versionOfChunkGroup, chunkGroupTimePartitionInfo.get(startOffsetOfChunkGroup));\n+            } else {\n+              rewrite(oldTsFile, deviceID, measurementSchemaList, \n+                dataInChunkGroup, versionOfChunkGroup);\n+            }\n+\n+            pageHeadersInChunkGroup.clear();\n+            dataInChunkGroup.clear();\n+            measurementSchemaList.clear();\n+            newChunkGroup = true;\n+            break;\n+\n+          default:\n+            // the disk file is corrupted, using this file may be dangerous\n+            logger.error(\"Unrecognized marker detected, this file may be corrupted\");\n+            return false;\n+        }\n+      }\n+      // close upgraded tsFiles and generate resources for them\n+      for (TsFileIOWriter tsFileIOWriter : partitionWriterMap.values()) {\n+        upgradedResources.add(endFileAndGenerateResource(tsFileIOWriter));\n+      }\n+      return true;\n+    } catch (IOException e2) {\n+      logger.info(\"TsFile upgrade process cannot proceed at position {} after {} chunk groups \"\n+          + \"recovered, because : {}\", this.position(), newMetaData.size(), e2.getMessage());\n+      return false;\n+    } finally {\n+      if (tsFileInput != null) {\n+        tsFileInput.close();\n+      }\n+    }\n+  }\n+\n+  /**\n+   *  Rewrite the chunk group to new TsFile.\n+   *  If data of this chunk group are in different time partitions,\n+   *  create multiple new TsFiles and rewrite data in each partition.\n+   */\n+  private void rewrite(File oldTsFile, String deviceId, List<MeasurementSchema> schemas, \n+      List<List<ByteBuffer>> dataInChunkGroup, long versionOfChunkGroup) \n+          throws IOException {\n+\n+    Map<Long, Map<MeasurementSchema, IChunkWriter>> chunkWritersInChunkGroup = new HashMap<>();\n+    for (int i = 0; i < schemas.size(); i++) {\n+      MeasurementSchema schema = schemas.get(i);\n+      Decoder defaultTimeDecoder = Decoder.getDecoderByType(\n+          TSEncoding.valueOf(TSFileDescriptor.getInstance().getConfig().getTimeEncoder()),\n+          TSDataType.INT64);\n+      Decoder valueDecoder = Decoder\n+          .getDecoderByType(schema.getEncodingType(), schema.getType());\n+      List<ByteBuffer> dataInChunk = dataInChunkGroup.get(i);\n+      for (ByteBuffer pageData : dataInChunk) {\n+        valueDecoder.reset();\n+        PageReader pageReader = new PageReader(pageData, schema.getType(), valueDecoder,\n+            defaultTimeDecoder, null);\n+        BatchData batchData = pageReader.getAllSatisfiedPageData();\n+        while (batchData.hasCurrent()) {\n+          long time = batchData.currentTime();\n+          Object value = batchData.currentValue();\n+          long partition = StorageEngine.getTimePartition(time);\n+          \n+          Map<MeasurementSchema, IChunkWriter> chunkWriters = chunkWritersInChunkGroup.getOrDefault(partition, new HashMap<>());\n+          IChunkWriter chunkWriter = chunkWriters.getOrDefault(schema, new ChunkWriterImpl(schema));\n+          TsFileIOWriter tsFileIOWriter = getOrDefaultTsFileIOWriter(oldTsFile, partition);\n+          partitionWriterMap.put(partition, tsFileIOWriter);\n+          switch (schema.getType()) {\n+            case INT32:\n+              chunkWriter.write(time, (int) value);\n+              break;\n+            case INT64:\n+              chunkWriter.write(time, (long) value);\n+              break;\n+            case FLOAT:\n+              chunkWriter.write(time, (float) value);\n+              break;\n+            case DOUBLE:\n+              chunkWriter.write(time, (double) value);\n+              break;\n+            case BOOLEAN:\n+              chunkWriter.write(time, (boolean) value);\n+              break;\n+            case TEXT:\n+              chunkWriter.write(time, (Binary) value);\n+              break;\n+            default:\n+              throw new UnSupportedDataTypeException(\n+                  String.format(\"Data type %s is not supported.\", schema.getType()));\n+            }\n+          chunkWriters.put(schema, chunkWriter);\n+          chunkWritersInChunkGroup.put(partition, chunkWriters);\n+          batchData.next();\n+        }\n+      }\n+    }\n+    // set version info to each upgraded tsFile \n+    for (Entry<Long, Map<MeasurementSchema, IChunkWriter>> entry : chunkWritersInChunkGroup.entrySet()) {\n+      long partition = entry.getKey();\n+      TsFileIOWriter tsFileIOWriter = partitionWriterMap.get(partition);\n+      tsFileIOWriter.startChunkGroup(deviceId);\n+      for (IChunkWriter chunkWriter : entry.getValue().values()) {\n+        chunkWriter.writeToFileWriter(tsFileIOWriter);\n+      }\n+      tsFileIOWriter.endChunkGroup();\n+      tsFileIOWriter.writeVersion(versionOfChunkGroup);\n+    }\n+  }\n+\n+  /**\n+   * \n+   * @param oldTsFile\n+   * @param deviceId\n+   * @param schemas\n+   * @param pageHeadersInChunkGroup\n+   * @param dataInChunkGroup\n+   * @param versionOfChunkGroup\n+   * @param partition\n+   * @throws IOException\n+   * @throws PageException\n+   */\n+  private void quickRewrite(File oldTsFile, String deviceId, List<MeasurementSchema> schemas, ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 492}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYwMjAzMQ==", "bodyText": "add javadoc or rename to rewriteUnCompressedPage", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422602031", "createdAt": "2020-05-10T07:32:21Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/tools/upgrade/TsfileOnlineUpgradeTool.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.upgrade;\n+\n+import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.tsfile.common.conf.TSFileConfig;\n+import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n+import org.apache.iotdb.tsfile.compress.IUnCompressor;\n+import org.apache.iotdb.tsfile.encoding.decoder.Decoder;\n+import org.apache.iotdb.tsfile.exception.write.PageException;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.exception.write.WriteProcessException;\n+import org.apache.iotdb.tsfile.file.MetaMarker;\n+import org.apache.iotdb.tsfile.file.footer.ChunkGroupFooter;\n+import org.apache.iotdb.tsfile.file.header.ChunkHeader;\n+import org.apache.iotdb.tsfile.file.header.PageHeader;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkGroupMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldChunkGroupMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.OldChunkMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsDeviceMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsDeviceMetadataIndex;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsFileMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.TimeseriesMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.reader.LocalTsFileInput;\n+import org.apache.iotdb.tsfile.read.reader.TsFileInput;\n+import org.apache.iotdb.tsfile.read.reader.page.PageReader;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.apache.iotdb.tsfile.write.chunk.ChunkWriterImpl;\n+import org.apache.iotdb.tsfile.write.chunk.IChunkWriter;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.iotdb.tsfile.write.writer.TsFileIOWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+public class TsfileOnlineUpgradeTool implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(TsfileOnlineUpgradeTool.class);\n+\n+  private TsFileInput tsFileInput;\n+  private long fileMetadataPos;\n+  private int fileMetadataSize;\n+  private ByteBuffer markerBuffer = ByteBuffer.allocate(Byte.BYTES);\n+  protected String file;\n+  \n+  // PartitionId -> TsFileIOWriter \n+  private Map<Long, TsFileIOWriter> partitionWriterMap;\n+\n+  /**\n+   * Create a file reader of the given file. The reader will read the tail of the file to get the\n+   * file metadata size.Then the reader will skip the first TSFileConfig.OLD_MAGIC_STRING.length()\n+   * bytes of the file for preparing reading real data.\n+   *\n+   * @param file the data file\n+   * @throws IOException If some I/O error occurs\n+   */\n+  public TsfileOnlineUpgradeTool(String file) throws IOException {\n+    this(file, true);\n+  }\n+\n+  /**\n+   * construct function for TsfileOnlineUpgradeTool.\n+   *\n+   * @param file -given file name\n+   * @param loadMetadataSize -load meta data size\n+   */\n+  public TsfileOnlineUpgradeTool(String file, boolean loadMetadataSize) throws IOException {\n+    this.file = file;\n+    final java.nio.file.Path path = Paths.get(file);\n+    tsFileInput = new LocalTsFileInput(path);\n+    partitionWriterMap = new HashMap<>();\n+    try {\n+      if (loadMetadataSize) {\n+        loadMetadataSize();\n+      }\n+    } catch (Exception e) {\n+      tsFileInput.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * \n+   */\n+  public void loadMetadataSize() throws IOException {\n+    ByteBuffer metadataSize = ByteBuffer.allocate(Integer.BYTES);\n+    tsFileInput.read(metadataSize,\n+        tsFileInput.size() - TSFileConfig.MAGIC_STRING.getBytes().length - Integer.BYTES);\n+    metadataSize.flip();\n+    // read file metadata size and position\n+    fileMetadataSize = ReadWriteIOUtils.readInt(metadataSize);\n+    fileMetadataPos =\n+        tsFileInput.size() - TSFileConfig.MAGIC_STRING.getBytes().length - Integer.BYTES\n+            - fileMetadataSize;\n+    // skip the magic header\n+    position(TSFileConfig.MAGIC_STRING.length());\n+  }\n+\n+  public String readTailMagic() throws IOException {\n+    long totalSize = tsFileInput.size();\n+\n+    ByteBuffer magicStringBytes = ByteBuffer.allocate(TSFileConfig.MAGIC_STRING.length());\n+    tsFileInput.read(magicStringBytes, totalSize - TSFileConfig.MAGIC_STRING.length());\n+    magicStringBytes.flip();\n+    return new String(magicStringBytes.array());\n+  }\n+\n+  /**\n+   * whether the file is a complete TsFile: only if the head magic and tail magic string exists.\n+   */\n+  public boolean isComplete() throws IOException {\n+    return tsFileInput.size() >= TSFileConfig.MAGIC_STRING.length() * 2 && readTailMagic()\n+        .equals(readHeadMagic());\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public String readHeadMagic() throws IOException {\n+    return readHeadMagic(false);\n+  }\n+\n+  /**\n+   * @param movePosition whether move the position of the file reader after reading the magic header\n+   * to the end of the magic head string.\n+   */\n+  public String readHeadMagic(boolean movePosition) throws IOException {\n+    ByteBuffer magicStringBytes = ByteBuffer.allocate(TSFileConfig.MAGIC_STRING.length());\n+    if (movePosition) {\n+      tsFileInput.position(0);\n+      tsFileInput.read(magicStringBytes);\n+    } else {\n+      tsFileInput.read(magicStringBytes, 0);\n+    }\n+    magicStringBytes.flip();\n+    return new String(magicStringBytes.array());\n+  }\n+\n+  /**\n+   * this function reads version number and checks compatibility of TsFile.\n+   */\n+  public String readVersionNumber() throws IOException {\n+    ByteBuffer versionNumberBytes = ByteBuffer\n+        .allocate(TSFileConfig.VERSION_NUMBER.getBytes().length);\n+    tsFileInput.position(TSFileConfig.MAGIC_STRING.getBytes().length);\n+    tsFileInput.read(versionNumberBytes);\n+    versionNumberBytes.flip();\n+    return new String(versionNumberBytes.array());\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public OldTsFileMetadata readFileMetadata() throws IOException {\n+    return OldTsFileMetadata.deserializeFrom(readData(fileMetadataPos, fileMetadataSize));\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public OldTsDeviceMetadata readTsDeviceMetaData(OldTsDeviceMetadataIndex index) throws IOException {\n+    return OldTsDeviceMetadata.deserializeFrom(readData(index.getOffset(), index.getLen()));\n+  }\n+\n+  /**\n+   * read data from current position of the input, and deserialize it to a CHUNK_GROUP_FOOTER. <br>\n+   * This method is not threadsafe.\n+   *\n+   * @return a CHUNK_GROUP_FOOTER\n+   * @throws IOException io error\n+   */\n+  public ChunkGroupFooter readChunkGroupFooter() throws IOException {\n+    return ChunkGroupFooter.deserializeFrom(tsFileInput.wrapAsInputStream(), true);\n+  }\n+\n+  /**\n+   * read data from current position of the input, and deserialize it to a CHUNK_HEADER. <br> This\n+   * method is not threadsafe.\n+   *\n+   * @return a CHUNK_HEADER\n+   * @throws IOException io error\n+   */\n+  public ChunkHeader readChunkHeader() throws IOException {\n+    return ChunkHeader.deserializeFrom(tsFileInput.wrapAsInputStream(), true, true);\n+  }\n+\n+  /**\n+   * not thread safe.\n+   *\n+   * @param type given tsfile data type\n+   */\n+  public PageHeader readPageHeader(TSDataType type) throws IOException {\n+    return PageHeader.deserializeFrom(tsFileInput.wrapAsInputStream(), type, true);\n+  }\n+\n+  public ByteBuffer readPage(PageHeader header, CompressionType type)\n+      throws IOException {\n+    ByteBuffer buffer = readData(-1, header.getCompressedSize());\n+    IUnCompressor unCompressor = IUnCompressor.getUnCompressor(type);\n+    ByteBuffer uncompressedBuffer = ByteBuffer.allocate(header.getUncompressedSize());\n+    if (type == CompressionType.UNCOMPRESSED) {\n+      return buffer;\n+    }\n+    unCompressor.uncompress(buffer.array(), buffer.position(), buffer.remaining(),\n+        uncompressedBuffer.array(),\n+        0);\n+    return uncompressedBuffer;\n+  }\n+  \n+  public ByteBuffer readCompressedPage(PageHeader header) throws IOException {\n+    return readData(-1, header.getCompressedSize());\n+  }\n+\n+  public long position() throws IOException {\n+    return tsFileInput.position();\n+  }\n+\n+  public void position(long offset) throws IOException {\n+    tsFileInput.position(offset);\n+  }\n+\n+  /**\n+   * read one byte from the input. <br> this method is not thread safe\n+   */\n+  public byte readMarker() throws IOException {\n+    markerBuffer.clear();\n+    if (ReadWriteIOUtils.readAsPossible(tsFileInput, markerBuffer) == 0) {\n+      throw new IOException(\"reach the end of the file.\");\n+    }\n+    markerBuffer.flip();\n+    return markerBuffer.get();\n+  }\n+\n+  public byte readMarker(long position) throws IOException {\n+    return readData(position, Byte.BYTES).get();\n+  }\n+\n+  public void close() throws IOException {\n+    this.tsFileInput.close();\n+  }\n+\n+  public String getFileName() {\n+    return this.file;\n+  }\n+\n+  /**\n+   * read data from tsFileInput, from the current position (if position = -1), or the given\n+   * position. <br> if position = -1, the tsFileInput's position will be changed to the current\n+   * position + real data size that been read. Other wise, the tsFileInput's position is not\n+   * changed.\n+   *\n+   * @param position the start position of data in the tsFileInput, or the current position if\n+   * position = -1\n+   * @param size the size of data that want to read\n+   * @return data that been read.\n+   */\n+  private ByteBuffer readData(long position, int size) throws IOException {\n+    ByteBuffer buffer = ByteBuffer.allocate(size);\n+    if (position == -1) {\n+      if (ReadWriteIOUtils.readAsPossible(tsFileInput, buffer) != size) {\n+        throw new IOException(\"reach the end of the data\");\n+      }\n+    } else {\n+      if (ReadWriteIOUtils.readAsPossible(tsFileInput, buffer, position, size) != size) {\n+        throw new IOException(\"reach the end of the data\");\n+      }\n+    }\n+    buffer.flip();\n+    return buffer;\n+  }\n+\n+  /**\n+   * upgrade file and resource, return the boolean value whether upgrade task completes\n+   * @throws IOException, WriteProcessException \n+   */\n+  public boolean upgradeFile(List<TsFileResource> upgradedResources) \n+      throws IOException, WriteProcessException {\n+    File oldTsFile = FSFactoryProducer.getFSFactory().getFile(this.file);\n+\n+    // check if the old TsFile has correct header \n+    if (!fileCheck(oldTsFile)) {\n+      return false;\n+    }\n+\n+    // ChunkGroupOffset -> version\n+    Map<Long, Long> oldVersionInfo = new HashMap<>();\n+\n+    // ChunkGroupOffset -> time partition, record the offsets of chunk group that data are in same partition\n+    Map<Long, Long> chunkGroupTimePartitionInfo = new HashMap<>();\n+\n+    // scan metadata to get version Info and chunkGroupTimePartitionInfo\n+    scanMetadata(oldVersionInfo, chunkGroupTimePartitionInfo);\n+    \n+    // start to scan chunks and chunkGroups\n+    long startOffsetOfChunkGroup = 0;\n+    boolean newChunkGroup = true;\n+    long versionOfChunkGroup = 0;\n+    boolean chunkGroupInSamePartition = false;\n+    List<ChunkGroupMetadata> newMetaData = new ArrayList<>();\n+    List<List<PageHeader>> pageHeadersInChunkGroup = new ArrayList<>();\n+    List<List<ByteBuffer>> dataInChunkGroup = new ArrayList<>();\n+    byte marker;\n+    List<MeasurementSchema> measurementSchemaList = new ArrayList<>();\n+    try {\n+      while ((marker = this.readMarker()) != MetaMarker.SEPARATOR) {\n+        switch (marker) {\n+          case MetaMarker.CHUNK_HEADER:\n+            // this is the first chunk of a new ChunkGroup.\n+            if (newChunkGroup) {\n+              newChunkGroup = false;\n+              startOffsetOfChunkGroup = this.position() - 1;\n+              versionOfChunkGroup = oldVersionInfo.get(startOffsetOfChunkGroup);\n+              chunkGroupInSamePartition = chunkGroupTimePartitionInfo\n+                  .containsKey(startOffsetOfChunkGroup);\n+            }\n+            ChunkHeader header = this.readChunkHeader();\n+            MeasurementSchema measurementSchema = new MeasurementSchema(header.getMeasurementID(),\n+                header.getDataType(),\n+                header.getEncodingType(), \n+                header.getCompressionType());\n+            measurementSchemaList.add(measurementSchema);\n+            List<PageHeader> pageHeadersInChunk = new ArrayList<>();\n+            List<ByteBuffer> dataInChunk = new ArrayList<>();\n+            for (int j = 0; j < header.getNumOfPages(); j++) {\n+              PageHeader pageHeader = readPageHeader(header.getDataType());\n+              ByteBuffer pageData = chunkGroupInSamePartition ? \n+                  readCompressedPage(pageHeader) : readPage(pageHeader, header.getCompressionType());\n+              pageHeadersInChunk.add(pageHeader);\n+              dataInChunk.add(pageData);\n+            }\n+            pageHeadersInChunkGroup.add(pageHeadersInChunk);\n+            dataInChunkGroup.add(dataInChunk);\n+            break;\n+          case MetaMarker.CHUNK_GROUP_FOOTER:\n+            // this is the footer of a ChunkGroup.\n+            ChunkGroupFooter chunkGroupFooter = this.readChunkGroupFooter();\n+            String deviceID = chunkGroupFooter.getDeviceID();\n+            if (chunkGroupInSamePartition) {\n+              quickRewrite(oldTsFile, deviceID, measurementSchemaList, pageHeadersInChunkGroup,\n+                  dataInChunkGroup, versionOfChunkGroup, chunkGroupTimePartitionInfo.get(startOffsetOfChunkGroup));\n+            } else {\n+              rewrite(oldTsFile, deviceID, measurementSchemaList, \n+                dataInChunkGroup, versionOfChunkGroup);\n+            }\n+\n+            pageHeadersInChunkGroup.clear();\n+            dataInChunkGroup.clear();\n+            measurementSchemaList.clear();\n+            newChunkGroup = true;\n+            break;\n+\n+          default:\n+            // the disk file is corrupted, using this file may be dangerous\n+            logger.error(\"Unrecognized marker detected, this file may be corrupted\");\n+            return false;\n+        }\n+      }\n+      // close upgraded tsFiles and generate resources for them\n+      for (TsFileIOWriter tsFileIOWriter : partitionWriterMap.values()) {\n+        upgradedResources.add(endFileAndGenerateResource(tsFileIOWriter));\n+      }\n+      return true;\n+    } catch (IOException e2) {\n+      logger.info(\"TsFile upgrade process cannot proceed at position {} after {} chunk groups \"\n+          + \"recovered, because : {}\", this.position(), newMetaData.size(), e2.getMessage());\n+      return false;\n+    } finally {\n+      if (tsFileInput != null) {\n+        tsFileInput.close();\n+      }\n+    }\n+  }\n+\n+  /**\n+   *  Rewrite the chunk group to new TsFile.\n+   *  If data of this chunk group are in different time partitions,\n+   *  create multiple new TsFiles and rewrite data in each partition.\n+   */\n+  private void rewrite(File oldTsFile, String deviceId, List<MeasurementSchema> schemas, ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 411}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYwMzQwOQ==", "bodyText": "this could be deduplicated, not a big problem.", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422603409", "createdAt": "2020-05-10T07:45:30Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/tools/upgrade/TsfileOnlineUpgradeTool.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.upgrade;\n+\n+import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.tsfile.common.conf.TSFileConfig;\n+import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n+import org.apache.iotdb.tsfile.compress.IUnCompressor;\n+import org.apache.iotdb.tsfile.encoding.decoder.Decoder;\n+import org.apache.iotdb.tsfile.exception.write.PageException;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.exception.write.WriteProcessException;\n+import org.apache.iotdb.tsfile.file.MetaMarker;\n+import org.apache.iotdb.tsfile.file.footer.ChunkGroupFooter;\n+import org.apache.iotdb.tsfile.file.header.ChunkHeader;\n+import org.apache.iotdb.tsfile.file.header.PageHeader;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkGroupMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldChunkGroupMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.OldChunkMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsDeviceMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsDeviceMetadataIndex;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsFileMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.TimeseriesMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.reader.LocalTsFileInput;\n+import org.apache.iotdb.tsfile.read.reader.TsFileInput;\n+import org.apache.iotdb.tsfile.read.reader.page.PageReader;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.apache.iotdb.tsfile.write.chunk.ChunkWriterImpl;\n+import org.apache.iotdb.tsfile.write.chunk.IChunkWriter;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.iotdb.tsfile.write.writer.TsFileIOWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+public class TsfileOnlineUpgradeTool implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(TsfileOnlineUpgradeTool.class);\n+\n+  private TsFileInput tsFileInput;\n+  private long fileMetadataPos;\n+  private int fileMetadataSize;\n+  private ByteBuffer markerBuffer = ByteBuffer.allocate(Byte.BYTES);\n+  protected String file;\n+  \n+  // PartitionId -> TsFileIOWriter \n+  private Map<Long, TsFileIOWriter> partitionWriterMap;\n+\n+  /**\n+   * Create a file reader of the given file. The reader will read the tail of the file to get the\n+   * file metadata size.Then the reader will skip the first TSFileConfig.OLD_MAGIC_STRING.length()\n+   * bytes of the file for preparing reading real data.\n+   *\n+   * @param file the data file\n+   * @throws IOException If some I/O error occurs\n+   */\n+  public TsfileOnlineUpgradeTool(String file) throws IOException {\n+    this(file, true);\n+  }\n+\n+  /**\n+   * construct function for TsfileOnlineUpgradeTool.\n+   *\n+   * @param file -given file name\n+   * @param loadMetadataSize -load meta data size\n+   */\n+  public TsfileOnlineUpgradeTool(String file, boolean loadMetadataSize) throws IOException {\n+    this.file = file;\n+    final java.nio.file.Path path = Paths.get(file);\n+    tsFileInput = new LocalTsFileInput(path);\n+    partitionWriterMap = new HashMap<>();\n+    try {\n+      if (loadMetadataSize) {\n+        loadMetadataSize();\n+      }\n+    } catch (Exception e) {\n+      tsFileInput.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * \n+   */\n+  public void loadMetadataSize() throws IOException {\n+    ByteBuffer metadataSize = ByteBuffer.allocate(Integer.BYTES);\n+    tsFileInput.read(metadataSize,\n+        tsFileInput.size() - TSFileConfig.MAGIC_STRING.getBytes().length - Integer.BYTES);\n+    metadataSize.flip();\n+    // read file metadata size and position\n+    fileMetadataSize = ReadWriteIOUtils.readInt(metadataSize);\n+    fileMetadataPos =\n+        tsFileInput.size() - TSFileConfig.MAGIC_STRING.getBytes().length - Integer.BYTES\n+            - fileMetadataSize;\n+    // skip the magic header\n+    position(TSFileConfig.MAGIC_STRING.length());\n+  }\n+\n+  public String readTailMagic() throws IOException {\n+    long totalSize = tsFileInput.size();\n+\n+    ByteBuffer magicStringBytes = ByteBuffer.allocate(TSFileConfig.MAGIC_STRING.length());\n+    tsFileInput.read(magicStringBytes, totalSize - TSFileConfig.MAGIC_STRING.length());\n+    magicStringBytes.flip();\n+    return new String(magicStringBytes.array());\n+  }\n+\n+  /**\n+   * whether the file is a complete TsFile: only if the head magic and tail magic string exists.\n+   */\n+  public boolean isComplete() throws IOException {\n+    return tsFileInput.size() >= TSFileConfig.MAGIC_STRING.length() * 2 && readTailMagic()\n+        .equals(readHeadMagic());\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public String readHeadMagic() throws IOException {\n+    return readHeadMagic(false);\n+  }\n+\n+  /**\n+   * @param movePosition whether move the position of the file reader after reading the magic header\n+   * to the end of the magic head string.\n+   */\n+  public String readHeadMagic(boolean movePosition) throws IOException {\n+    ByteBuffer magicStringBytes = ByteBuffer.allocate(TSFileConfig.MAGIC_STRING.length());\n+    if (movePosition) {\n+      tsFileInput.position(0);\n+      tsFileInput.read(magicStringBytes);\n+    } else {\n+      tsFileInput.read(magicStringBytes, 0);\n+    }\n+    magicStringBytes.flip();\n+    return new String(magicStringBytes.array());\n+  }\n+\n+  /**\n+   * this function reads version number and checks compatibility of TsFile.\n+   */\n+  public String readVersionNumber() throws IOException {\n+    ByteBuffer versionNumberBytes = ByteBuffer\n+        .allocate(TSFileConfig.VERSION_NUMBER.getBytes().length);\n+    tsFileInput.position(TSFileConfig.MAGIC_STRING.getBytes().length);\n+    tsFileInput.read(versionNumberBytes);\n+    versionNumberBytes.flip();\n+    return new String(versionNumberBytes.array());\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public OldTsFileMetadata readFileMetadata() throws IOException {\n+    return OldTsFileMetadata.deserializeFrom(readData(fileMetadataPos, fileMetadataSize));\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public OldTsDeviceMetadata readTsDeviceMetaData(OldTsDeviceMetadataIndex index) throws IOException {\n+    return OldTsDeviceMetadata.deserializeFrom(readData(index.getOffset(), index.getLen()));\n+  }\n+\n+  /**\n+   * read data from current position of the input, and deserialize it to a CHUNK_GROUP_FOOTER. <br>\n+   * This method is not threadsafe.\n+   *\n+   * @return a CHUNK_GROUP_FOOTER\n+   * @throws IOException io error\n+   */\n+  public ChunkGroupFooter readChunkGroupFooter() throws IOException {\n+    return ChunkGroupFooter.deserializeFrom(tsFileInput.wrapAsInputStream(), true);\n+  }\n+\n+  /**\n+   * read data from current position of the input, and deserialize it to a CHUNK_HEADER. <br> This\n+   * method is not threadsafe.\n+   *\n+   * @return a CHUNK_HEADER\n+   * @throws IOException io error\n+   */\n+  public ChunkHeader readChunkHeader() throws IOException {\n+    return ChunkHeader.deserializeFrom(tsFileInput.wrapAsInputStream(), true, true);\n+  }\n+\n+  /**\n+   * not thread safe.\n+   *\n+   * @param type given tsfile data type\n+   */\n+  public PageHeader readPageHeader(TSDataType type) throws IOException {\n+    return PageHeader.deserializeFrom(tsFileInput.wrapAsInputStream(), type, true);\n+  }\n+\n+  public ByteBuffer readPage(PageHeader header, CompressionType type)\n+      throws IOException {\n+    ByteBuffer buffer = readData(-1, header.getCompressedSize());\n+    IUnCompressor unCompressor = IUnCompressor.getUnCompressor(type);\n+    ByteBuffer uncompressedBuffer = ByteBuffer.allocate(header.getUncompressedSize());\n+    if (type == CompressionType.UNCOMPRESSED) {\n+      return buffer;\n+    }\n+    unCompressor.uncompress(buffer.array(), buffer.position(), buffer.remaining(),\n+        uncompressedBuffer.array(),\n+        0);\n+    return uncompressedBuffer;\n+  }\n+  \n+  public ByteBuffer readCompressedPage(PageHeader header) throws IOException {\n+    return readData(-1, header.getCompressedSize());\n+  }\n+\n+  public long position() throws IOException {\n+    return tsFileInput.position();\n+  }\n+\n+  public void position(long offset) throws IOException {\n+    tsFileInput.position(offset);\n+  }\n+\n+  /**\n+   * read one byte from the input. <br> this method is not thread safe\n+   */\n+  public byte readMarker() throws IOException {\n+    markerBuffer.clear();\n+    if (ReadWriteIOUtils.readAsPossible(tsFileInput, markerBuffer) == 0) {\n+      throw new IOException(\"reach the end of the file.\");\n+    }\n+    markerBuffer.flip();\n+    return markerBuffer.get();\n+  }\n+\n+  public byte readMarker(long position) throws IOException {\n+    return readData(position, Byte.BYTES).get();\n+  }\n+\n+  public void close() throws IOException {\n+    this.tsFileInput.close();\n+  }\n+\n+  public String getFileName() {\n+    return this.file;\n+  }\n+\n+  /**\n+   * read data from tsFileInput, from the current position (if position = -1), or the given\n+   * position. <br> if position = -1, the tsFileInput's position will be changed to the current\n+   * position + real data size that been read. Other wise, the tsFileInput's position is not\n+   * changed.\n+   *\n+   * @param position the start position of data in the tsFileInput, or the current position if\n+   * position = -1\n+   * @param size the size of data that want to read\n+   * @return data that been read.\n+   */\n+  private ByteBuffer readData(long position, int size) throws IOException {\n+    ByteBuffer buffer = ByteBuffer.allocate(size);\n+    if (position == -1) {\n+      if (ReadWriteIOUtils.readAsPossible(tsFileInput, buffer) != size) {\n+        throw new IOException(\"reach the end of the data\");\n+      }\n+    } else {\n+      if (ReadWriteIOUtils.readAsPossible(tsFileInput, buffer, position, size) != size) {\n+        throw new IOException(\"reach the end of the data\");\n+      }\n+    }\n+    buffer.flip();\n+    return buffer;\n+  }\n+\n+  /**\n+   * upgrade file and resource, return the boolean value whether upgrade task completes\n+   * @throws IOException, WriteProcessException \n+   */\n+  public boolean upgradeFile(List<TsFileResource> upgradedResources) \n+      throws IOException, WriteProcessException {\n+    File oldTsFile = FSFactoryProducer.getFSFactory().getFile(this.file);\n+\n+    // check if the old TsFile has correct header \n+    if (!fileCheck(oldTsFile)) {\n+      return false;\n+    }\n+\n+    // ChunkGroupOffset -> version\n+    Map<Long, Long> oldVersionInfo = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYwMzYwMg==", "bodyText": "I prefer to do this check for each page header.", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422603602", "createdAt": "2020-05-10T07:47:22Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/tools/upgrade/TsfileOnlineUpgradeTool.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.upgrade;\n+\n+import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.tsfile.common.conf.TSFileConfig;\n+import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n+import org.apache.iotdb.tsfile.compress.IUnCompressor;\n+import org.apache.iotdb.tsfile.encoding.decoder.Decoder;\n+import org.apache.iotdb.tsfile.exception.write.PageException;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.exception.write.WriteProcessException;\n+import org.apache.iotdb.tsfile.file.MetaMarker;\n+import org.apache.iotdb.tsfile.file.footer.ChunkGroupFooter;\n+import org.apache.iotdb.tsfile.file.header.ChunkHeader;\n+import org.apache.iotdb.tsfile.file.header.PageHeader;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkGroupMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldChunkGroupMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.OldChunkMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsDeviceMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsDeviceMetadataIndex;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsFileMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.TimeseriesMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.reader.LocalTsFileInput;\n+import org.apache.iotdb.tsfile.read.reader.TsFileInput;\n+import org.apache.iotdb.tsfile.read.reader.page.PageReader;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.apache.iotdb.tsfile.write.chunk.ChunkWriterImpl;\n+import org.apache.iotdb.tsfile.write.chunk.IChunkWriter;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.iotdb.tsfile.write.writer.TsFileIOWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+public class TsfileOnlineUpgradeTool implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(TsfileOnlineUpgradeTool.class);\n+\n+  private TsFileInput tsFileInput;\n+  private long fileMetadataPos;\n+  private int fileMetadataSize;\n+  private ByteBuffer markerBuffer = ByteBuffer.allocate(Byte.BYTES);\n+  protected String file;\n+  \n+  // PartitionId -> TsFileIOWriter \n+  private Map<Long, TsFileIOWriter> partitionWriterMap;\n+\n+  /**\n+   * Create a file reader of the given file. The reader will read the tail of the file to get the\n+   * file metadata size.Then the reader will skip the first TSFileConfig.OLD_MAGIC_STRING.length()\n+   * bytes of the file for preparing reading real data.\n+   *\n+   * @param file the data file\n+   * @throws IOException If some I/O error occurs\n+   */\n+  public TsfileOnlineUpgradeTool(String file) throws IOException {\n+    this(file, true);\n+  }\n+\n+  /**\n+   * construct function for TsfileOnlineUpgradeTool.\n+   *\n+   * @param file -given file name\n+   * @param loadMetadataSize -load meta data size\n+   */\n+  public TsfileOnlineUpgradeTool(String file, boolean loadMetadataSize) throws IOException {\n+    this.file = file;\n+    final java.nio.file.Path path = Paths.get(file);\n+    tsFileInput = new LocalTsFileInput(path);\n+    partitionWriterMap = new HashMap<>();\n+    try {\n+      if (loadMetadataSize) {\n+        loadMetadataSize();\n+      }\n+    } catch (Exception e) {\n+      tsFileInput.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * \n+   */\n+  public void loadMetadataSize() throws IOException {\n+    ByteBuffer metadataSize = ByteBuffer.allocate(Integer.BYTES);\n+    tsFileInput.read(metadataSize,\n+        tsFileInput.size() - TSFileConfig.MAGIC_STRING.getBytes().length - Integer.BYTES);\n+    metadataSize.flip();\n+    // read file metadata size and position\n+    fileMetadataSize = ReadWriteIOUtils.readInt(metadataSize);\n+    fileMetadataPos =\n+        tsFileInput.size() - TSFileConfig.MAGIC_STRING.getBytes().length - Integer.BYTES\n+            - fileMetadataSize;\n+    // skip the magic header\n+    position(TSFileConfig.MAGIC_STRING.length());\n+  }\n+\n+  public String readTailMagic() throws IOException {\n+    long totalSize = tsFileInput.size();\n+\n+    ByteBuffer magicStringBytes = ByteBuffer.allocate(TSFileConfig.MAGIC_STRING.length());\n+    tsFileInput.read(magicStringBytes, totalSize - TSFileConfig.MAGIC_STRING.length());\n+    magicStringBytes.flip();\n+    return new String(magicStringBytes.array());\n+  }\n+\n+  /**\n+   * whether the file is a complete TsFile: only if the head magic and tail magic string exists.\n+   */\n+  public boolean isComplete() throws IOException {\n+    return tsFileInput.size() >= TSFileConfig.MAGIC_STRING.length() * 2 && readTailMagic()\n+        .equals(readHeadMagic());\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public String readHeadMagic() throws IOException {\n+    return readHeadMagic(false);\n+  }\n+\n+  /**\n+   * @param movePosition whether move the position of the file reader after reading the magic header\n+   * to the end of the magic head string.\n+   */\n+  public String readHeadMagic(boolean movePosition) throws IOException {\n+    ByteBuffer magicStringBytes = ByteBuffer.allocate(TSFileConfig.MAGIC_STRING.length());\n+    if (movePosition) {\n+      tsFileInput.position(0);\n+      tsFileInput.read(magicStringBytes);\n+    } else {\n+      tsFileInput.read(magicStringBytes, 0);\n+    }\n+    magicStringBytes.flip();\n+    return new String(magicStringBytes.array());\n+  }\n+\n+  /**\n+   * this function reads version number and checks compatibility of TsFile.\n+   */\n+  public String readVersionNumber() throws IOException {\n+    ByteBuffer versionNumberBytes = ByteBuffer\n+        .allocate(TSFileConfig.VERSION_NUMBER.getBytes().length);\n+    tsFileInput.position(TSFileConfig.MAGIC_STRING.getBytes().length);\n+    tsFileInput.read(versionNumberBytes);\n+    versionNumberBytes.flip();\n+    return new String(versionNumberBytes.array());\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public OldTsFileMetadata readFileMetadata() throws IOException {\n+    return OldTsFileMetadata.deserializeFrom(readData(fileMetadataPos, fileMetadataSize));\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public OldTsDeviceMetadata readTsDeviceMetaData(OldTsDeviceMetadataIndex index) throws IOException {\n+    return OldTsDeviceMetadata.deserializeFrom(readData(index.getOffset(), index.getLen()));\n+  }\n+\n+  /**\n+   * read data from current position of the input, and deserialize it to a CHUNK_GROUP_FOOTER. <br>\n+   * This method is not threadsafe.\n+   *\n+   * @return a CHUNK_GROUP_FOOTER\n+   * @throws IOException io error\n+   */\n+  public ChunkGroupFooter readChunkGroupFooter() throws IOException {\n+    return ChunkGroupFooter.deserializeFrom(tsFileInput.wrapAsInputStream(), true);\n+  }\n+\n+  /**\n+   * read data from current position of the input, and deserialize it to a CHUNK_HEADER. <br> This\n+   * method is not threadsafe.\n+   *\n+   * @return a CHUNK_HEADER\n+   * @throws IOException io error\n+   */\n+  public ChunkHeader readChunkHeader() throws IOException {\n+    return ChunkHeader.deserializeFrom(tsFileInput.wrapAsInputStream(), true, true);\n+  }\n+\n+  /**\n+   * not thread safe.\n+   *\n+   * @param type given tsfile data type\n+   */\n+  public PageHeader readPageHeader(TSDataType type) throws IOException {\n+    return PageHeader.deserializeFrom(tsFileInput.wrapAsInputStream(), type, true);\n+  }\n+\n+  public ByteBuffer readPage(PageHeader header, CompressionType type)\n+      throws IOException {\n+    ByteBuffer buffer = readData(-1, header.getCompressedSize());\n+    IUnCompressor unCompressor = IUnCompressor.getUnCompressor(type);\n+    ByteBuffer uncompressedBuffer = ByteBuffer.allocate(header.getUncompressedSize());\n+    if (type == CompressionType.UNCOMPRESSED) {\n+      return buffer;\n+    }\n+    unCompressor.uncompress(buffer.array(), buffer.position(), buffer.remaining(),\n+        uncompressedBuffer.array(),\n+        0);\n+    return uncompressedBuffer;\n+  }\n+  \n+  public ByteBuffer readCompressedPage(PageHeader header) throws IOException {\n+    return readData(-1, header.getCompressedSize());\n+  }\n+\n+  public long position() throws IOException {\n+    return tsFileInput.position();\n+  }\n+\n+  public void position(long offset) throws IOException {\n+    tsFileInput.position(offset);\n+  }\n+\n+  /**\n+   * read one byte from the input. <br> this method is not thread safe\n+   */\n+  public byte readMarker() throws IOException {\n+    markerBuffer.clear();\n+    if (ReadWriteIOUtils.readAsPossible(tsFileInput, markerBuffer) == 0) {\n+      throw new IOException(\"reach the end of the file.\");\n+    }\n+    markerBuffer.flip();\n+    return markerBuffer.get();\n+  }\n+\n+  public byte readMarker(long position) throws IOException {\n+    return readData(position, Byte.BYTES).get();\n+  }\n+\n+  public void close() throws IOException {\n+    this.tsFileInput.close();\n+  }\n+\n+  public String getFileName() {\n+    return this.file;\n+  }\n+\n+  /**\n+   * read data from tsFileInput, from the current position (if position = -1), or the given\n+   * position. <br> if position = -1, the tsFileInput's position will be changed to the current\n+   * position + real data size that been read. Other wise, the tsFileInput's position is not\n+   * changed.\n+   *\n+   * @param position the start position of data in the tsFileInput, or the current position if\n+   * position = -1\n+   * @param size the size of data that want to read\n+   * @return data that been read.\n+   */\n+  private ByteBuffer readData(long position, int size) throws IOException {\n+    ByteBuffer buffer = ByteBuffer.allocate(size);\n+    if (position == -1) {\n+      if (ReadWriteIOUtils.readAsPossible(tsFileInput, buffer) != size) {\n+        throw new IOException(\"reach the end of the data\");\n+      }\n+    } else {\n+      if (ReadWriteIOUtils.readAsPossible(tsFileInput, buffer, position, size) != size) {\n+        throw new IOException(\"reach the end of the data\");\n+      }\n+    }\n+    buffer.flip();\n+    return buffer;\n+  }\n+\n+  /**\n+   * upgrade file and resource, return the boolean value whether upgrade task completes\n+   * @throws IOException, WriteProcessException \n+   */\n+  public boolean upgradeFile(List<TsFileResource> upgradedResources) \n+      throws IOException, WriteProcessException {\n+    File oldTsFile = FSFactoryProducer.getFSFactory().getFile(this.file);\n+\n+    // check if the old TsFile has correct header \n+    if (!fileCheck(oldTsFile)) {\n+      return false;\n+    }\n+\n+    // ChunkGroupOffset -> version\n+    Map<Long, Long> oldVersionInfo = new HashMap<>();\n+\n+    // ChunkGroupOffset -> time partition, record the offsets of chunk group that data are in same partition\n+    Map<Long, Long> chunkGroupTimePartitionInfo = new HashMap<>();\n+\n+    // scan metadata to get version Info and chunkGroupTimePartitionInfo\n+    scanMetadata(oldVersionInfo, chunkGroupTimePartitionInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYwMzk1Mg==", "bodyText": "no need to put again", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422603952", "createdAt": "2020-05-10T07:50:17Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/tools/upgrade/TsfileOnlineUpgradeTool.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.upgrade;\n+\n+import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.tsfile.common.conf.TSFileConfig;\n+import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n+import org.apache.iotdb.tsfile.compress.IUnCompressor;\n+import org.apache.iotdb.tsfile.encoding.decoder.Decoder;\n+import org.apache.iotdb.tsfile.exception.write.PageException;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.exception.write.WriteProcessException;\n+import org.apache.iotdb.tsfile.file.MetaMarker;\n+import org.apache.iotdb.tsfile.file.footer.ChunkGroupFooter;\n+import org.apache.iotdb.tsfile.file.header.ChunkHeader;\n+import org.apache.iotdb.tsfile.file.header.PageHeader;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkGroupMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldChunkGroupMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.OldChunkMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsDeviceMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsDeviceMetadataIndex;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsFileMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.TimeseriesMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.reader.LocalTsFileInput;\n+import org.apache.iotdb.tsfile.read.reader.TsFileInput;\n+import org.apache.iotdb.tsfile.read.reader.page.PageReader;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.apache.iotdb.tsfile.write.chunk.ChunkWriterImpl;\n+import org.apache.iotdb.tsfile.write.chunk.IChunkWriter;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.iotdb.tsfile.write.writer.TsFileIOWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+public class TsfileOnlineUpgradeTool implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(TsfileOnlineUpgradeTool.class);\n+\n+  private TsFileInput tsFileInput;\n+  private long fileMetadataPos;\n+  private int fileMetadataSize;\n+  private ByteBuffer markerBuffer = ByteBuffer.allocate(Byte.BYTES);\n+  protected String file;\n+  \n+  // PartitionId -> TsFileIOWriter \n+  private Map<Long, TsFileIOWriter> partitionWriterMap;\n+\n+  /**\n+   * Create a file reader of the given file. The reader will read the tail of the file to get the\n+   * file metadata size.Then the reader will skip the first TSFileConfig.OLD_MAGIC_STRING.length()\n+   * bytes of the file for preparing reading real data.\n+   *\n+   * @param file the data file\n+   * @throws IOException If some I/O error occurs\n+   */\n+  public TsfileOnlineUpgradeTool(String file) throws IOException {\n+    this(file, true);\n+  }\n+\n+  /**\n+   * construct function for TsfileOnlineUpgradeTool.\n+   *\n+   * @param file -given file name\n+   * @param loadMetadataSize -load meta data size\n+   */\n+  public TsfileOnlineUpgradeTool(String file, boolean loadMetadataSize) throws IOException {\n+    this.file = file;\n+    final java.nio.file.Path path = Paths.get(file);\n+    tsFileInput = new LocalTsFileInput(path);\n+    partitionWriterMap = new HashMap<>();\n+    try {\n+      if (loadMetadataSize) {\n+        loadMetadataSize();\n+      }\n+    } catch (Exception e) {\n+      tsFileInput.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * \n+   */\n+  public void loadMetadataSize() throws IOException {\n+    ByteBuffer metadataSize = ByteBuffer.allocate(Integer.BYTES);\n+    tsFileInput.read(metadataSize,\n+        tsFileInput.size() - TSFileConfig.MAGIC_STRING.getBytes().length - Integer.BYTES);\n+    metadataSize.flip();\n+    // read file metadata size and position\n+    fileMetadataSize = ReadWriteIOUtils.readInt(metadataSize);\n+    fileMetadataPos =\n+        tsFileInput.size() - TSFileConfig.MAGIC_STRING.getBytes().length - Integer.BYTES\n+            - fileMetadataSize;\n+    // skip the magic header\n+    position(TSFileConfig.MAGIC_STRING.length());\n+  }\n+\n+  public String readTailMagic() throws IOException {\n+    long totalSize = tsFileInput.size();\n+\n+    ByteBuffer magicStringBytes = ByteBuffer.allocate(TSFileConfig.MAGIC_STRING.length());\n+    tsFileInput.read(magicStringBytes, totalSize - TSFileConfig.MAGIC_STRING.length());\n+    magicStringBytes.flip();\n+    return new String(magicStringBytes.array());\n+  }\n+\n+  /**\n+   * whether the file is a complete TsFile: only if the head magic and tail magic string exists.\n+   */\n+  public boolean isComplete() throws IOException {\n+    return tsFileInput.size() >= TSFileConfig.MAGIC_STRING.length() * 2 && readTailMagic()\n+        .equals(readHeadMagic());\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public String readHeadMagic() throws IOException {\n+    return readHeadMagic(false);\n+  }\n+\n+  /**\n+   * @param movePosition whether move the position of the file reader after reading the magic header\n+   * to the end of the magic head string.\n+   */\n+  public String readHeadMagic(boolean movePosition) throws IOException {\n+    ByteBuffer magicStringBytes = ByteBuffer.allocate(TSFileConfig.MAGIC_STRING.length());\n+    if (movePosition) {\n+      tsFileInput.position(0);\n+      tsFileInput.read(magicStringBytes);\n+    } else {\n+      tsFileInput.read(magicStringBytes, 0);\n+    }\n+    magicStringBytes.flip();\n+    return new String(magicStringBytes.array());\n+  }\n+\n+  /**\n+   * this function reads version number and checks compatibility of TsFile.\n+   */\n+  public String readVersionNumber() throws IOException {\n+    ByteBuffer versionNumberBytes = ByteBuffer\n+        .allocate(TSFileConfig.VERSION_NUMBER.getBytes().length);\n+    tsFileInput.position(TSFileConfig.MAGIC_STRING.getBytes().length);\n+    tsFileInput.read(versionNumberBytes);\n+    versionNumberBytes.flip();\n+    return new String(versionNumberBytes.array());\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public OldTsFileMetadata readFileMetadata() throws IOException {\n+    return OldTsFileMetadata.deserializeFrom(readData(fileMetadataPos, fileMetadataSize));\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public OldTsDeviceMetadata readTsDeviceMetaData(OldTsDeviceMetadataIndex index) throws IOException {\n+    return OldTsDeviceMetadata.deserializeFrom(readData(index.getOffset(), index.getLen()));\n+  }\n+\n+  /**\n+   * read data from current position of the input, and deserialize it to a CHUNK_GROUP_FOOTER. <br>\n+   * This method is not threadsafe.\n+   *\n+   * @return a CHUNK_GROUP_FOOTER\n+   * @throws IOException io error\n+   */\n+  public ChunkGroupFooter readChunkGroupFooter() throws IOException {\n+    return ChunkGroupFooter.deserializeFrom(tsFileInput.wrapAsInputStream(), true);\n+  }\n+\n+  /**\n+   * read data from current position of the input, and deserialize it to a CHUNK_HEADER. <br> This\n+   * method is not threadsafe.\n+   *\n+   * @return a CHUNK_HEADER\n+   * @throws IOException io error\n+   */\n+  public ChunkHeader readChunkHeader() throws IOException {\n+    return ChunkHeader.deserializeFrom(tsFileInput.wrapAsInputStream(), true, true);\n+  }\n+\n+  /**\n+   * not thread safe.\n+   *\n+   * @param type given tsfile data type\n+   */\n+  public PageHeader readPageHeader(TSDataType type) throws IOException {\n+    return PageHeader.deserializeFrom(tsFileInput.wrapAsInputStream(), type, true);\n+  }\n+\n+  public ByteBuffer readPage(PageHeader header, CompressionType type)\n+      throws IOException {\n+    ByteBuffer buffer = readData(-1, header.getCompressedSize());\n+    IUnCompressor unCompressor = IUnCompressor.getUnCompressor(type);\n+    ByteBuffer uncompressedBuffer = ByteBuffer.allocate(header.getUncompressedSize());\n+    if (type == CompressionType.UNCOMPRESSED) {\n+      return buffer;\n+    }\n+    unCompressor.uncompress(buffer.array(), buffer.position(), buffer.remaining(),\n+        uncompressedBuffer.array(),\n+        0);\n+    return uncompressedBuffer;\n+  }\n+  \n+  public ByteBuffer readCompressedPage(PageHeader header) throws IOException {\n+    return readData(-1, header.getCompressedSize());\n+  }\n+\n+  public long position() throws IOException {\n+    return tsFileInput.position();\n+  }\n+\n+  public void position(long offset) throws IOException {\n+    tsFileInput.position(offset);\n+  }\n+\n+  /**\n+   * read one byte from the input. <br> this method is not thread safe\n+   */\n+  public byte readMarker() throws IOException {\n+    markerBuffer.clear();\n+    if (ReadWriteIOUtils.readAsPossible(tsFileInput, markerBuffer) == 0) {\n+      throw new IOException(\"reach the end of the file.\");\n+    }\n+    markerBuffer.flip();\n+    return markerBuffer.get();\n+  }\n+\n+  public byte readMarker(long position) throws IOException {\n+    return readData(position, Byte.BYTES).get();\n+  }\n+\n+  public void close() throws IOException {\n+    this.tsFileInput.close();\n+  }\n+\n+  public String getFileName() {\n+    return this.file;\n+  }\n+\n+  /**\n+   * read data from tsFileInput, from the current position (if position = -1), or the given\n+   * position. <br> if position = -1, the tsFileInput's position will be changed to the current\n+   * position + real data size that been read. Other wise, the tsFileInput's position is not\n+   * changed.\n+   *\n+   * @param position the start position of data in the tsFileInput, or the current position if\n+   * position = -1\n+   * @param size the size of data that want to read\n+   * @return data that been read.\n+   */\n+  private ByteBuffer readData(long position, int size) throws IOException {\n+    ByteBuffer buffer = ByteBuffer.allocate(size);\n+    if (position == -1) {\n+      if (ReadWriteIOUtils.readAsPossible(tsFileInput, buffer) != size) {\n+        throw new IOException(\"reach the end of the data\");\n+      }\n+    } else {\n+      if (ReadWriteIOUtils.readAsPossible(tsFileInput, buffer, position, size) != size) {\n+        throw new IOException(\"reach the end of the data\");\n+      }\n+    }\n+    buffer.flip();\n+    return buffer;\n+  }\n+\n+  /**\n+   * upgrade file and resource, return the boolean value whether upgrade task completes\n+   * @throws IOException, WriteProcessException \n+   */\n+  public boolean upgradeFile(List<TsFileResource> upgradedResources) \n+      throws IOException, WriteProcessException {\n+    File oldTsFile = FSFactoryProducer.getFSFactory().getFile(this.file);\n+\n+    // check if the old TsFile has correct header \n+    if (!fileCheck(oldTsFile)) {\n+      return false;\n+    }\n+\n+    // ChunkGroupOffset -> version\n+    Map<Long, Long> oldVersionInfo = new HashMap<>();\n+\n+    // ChunkGroupOffset -> time partition, record the offsets of chunk group that data are in same partition\n+    Map<Long, Long> chunkGroupTimePartitionInfo = new HashMap<>();\n+\n+    // scan metadata to get version Info and chunkGroupTimePartitionInfo\n+    scanMetadata(oldVersionInfo, chunkGroupTimePartitionInfo);\n+    \n+    // start to scan chunks and chunkGroups\n+    long startOffsetOfChunkGroup = 0;\n+    boolean newChunkGroup = true;\n+    long versionOfChunkGroup = 0;\n+    boolean chunkGroupInSamePartition = false;\n+    List<ChunkGroupMetadata> newMetaData = new ArrayList<>();\n+    List<List<PageHeader>> pageHeadersInChunkGroup = new ArrayList<>();\n+    List<List<ByteBuffer>> dataInChunkGroup = new ArrayList<>();\n+    byte marker;\n+    List<MeasurementSchema> measurementSchemaList = new ArrayList<>();\n+    try {\n+      while ((marker = this.readMarker()) != MetaMarker.SEPARATOR) {\n+        switch (marker) {\n+          case MetaMarker.CHUNK_HEADER:\n+            // this is the first chunk of a new ChunkGroup.\n+            if (newChunkGroup) {\n+              newChunkGroup = false;\n+              startOffsetOfChunkGroup = this.position() - 1;\n+              versionOfChunkGroup = oldVersionInfo.get(startOffsetOfChunkGroup);\n+              chunkGroupInSamePartition = chunkGroupTimePartitionInfo\n+                  .containsKey(startOffsetOfChunkGroup);\n+            }\n+            ChunkHeader header = this.readChunkHeader();\n+            MeasurementSchema measurementSchema = new MeasurementSchema(header.getMeasurementID(),\n+                header.getDataType(),\n+                header.getEncodingType(), \n+                header.getCompressionType());\n+            measurementSchemaList.add(measurementSchema);\n+            List<PageHeader> pageHeadersInChunk = new ArrayList<>();\n+            List<ByteBuffer> dataInChunk = new ArrayList<>();\n+            for (int j = 0; j < header.getNumOfPages(); j++) {\n+              PageHeader pageHeader = readPageHeader(header.getDataType());\n+              ByteBuffer pageData = chunkGroupInSamePartition ? \n+                  readCompressedPage(pageHeader) : readPage(pageHeader, header.getCompressionType());\n+              pageHeadersInChunk.add(pageHeader);\n+              dataInChunk.add(pageData);\n+            }\n+            pageHeadersInChunkGroup.add(pageHeadersInChunk);\n+            dataInChunkGroup.add(dataInChunk);\n+            break;\n+          case MetaMarker.CHUNK_GROUP_FOOTER:\n+            // this is the footer of a ChunkGroup.\n+            ChunkGroupFooter chunkGroupFooter = this.readChunkGroupFooter();\n+            String deviceID = chunkGroupFooter.getDeviceID();\n+            if (chunkGroupInSamePartition) {\n+              quickRewrite(oldTsFile, deviceID, measurementSchemaList, pageHeadersInChunkGroup,\n+                  dataInChunkGroup, versionOfChunkGroup, chunkGroupTimePartitionInfo.get(startOffsetOfChunkGroup));\n+            } else {\n+              rewrite(oldTsFile, deviceID, measurementSchemaList, \n+                dataInChunkGroup, versionOfChunkGroup);\n+            }\n+\n+            pageHeadersInChunkGroup.clear();\n+            dataInChunkGroup.clear();\n+            measurementSchemaList.clear();\n+            newChunkGroup = true;\n+            break;\n+\n+          default:\n+            // the disk file is corrupted, using this file may be dangerous\n+            logger.error(\"Unrecognized marker detected, this file may be corrupted\");\n+            return false;\n+        }\n+      }\n+      // close upgraded tsFiles and generate resources for them\n+      for (TsFileIOWriter tsFileIOWriter : partitionWriterMap.values()) {\n+        upgradedResources.add(endFileAndGenerateResource(tsFileIOWriter));\n+      }\n+      return true;\n+    } catch (IOException e2) {\n+      logger.info(\"TsFile upgrade process cannot proceed at position {} after {} chunk groups \"\n+          + \"recovered, because : {}\", this.position(), newMetaData.size(), e2.getMessage());\n+      return false;\n+    } finally {\n+      if (tsFileInput != null) {\n+        tsFileInput.close();\n+      }\n+    }\n+  }\n+\n+  /**\n+   *  Rewrite the chunk group to new TsFile.\n+   *  If data of this chunk group are in different time partitions,\n+   *  create multiple new TsFiles and rewrite data in each partition.\n+   */\n+  private void rewrite(File oldTsFile, String deviceId, List<MeasurementSchema> schemas, \n+      List<List<ByteBuffer>> dataInChunkGroup, long versionOfChunkGroup) \n+          throws IOException {\n+\n+    Map<Long, Map<MeasurementSchema, IChunkWriter>> chunkWritersInChunkGroup = new HashMap<>();\n+    for (int i = 0; i < schemas.size(); i++) {\n+      MeasurementSchema schema = schemas.get(i);\n+      Decoder defaultTimeDecoder = Decoder.getDecoderByType(\n+          TSEncoding.valueOf(TSFileDescriptor.getInstance().getConfig().getTimeEncoder()),\n+          TSDataType.INT64);\n+      Decoder valueDecoder = Decoder\n+          .getDecoderByType(schema.getEncodingType(), schema.getType());\n+      List<ByteBuffer> dataInChunk = dataInChunkGroup.get(i);\n+      for (ByteBuffer pageData : dataInChunk) {\n+        valueDecoder.reset();\n+        PageReader pageReader = new PageReader(pageData, schema.getType(), valueDecoder,\n+            defaultTimeDecoder, null);\n+        BatchData batchData = pageReader.getAllSatisfiedPageData();\n+        while (batchData.hasCurrent()) {\n+          long time = batchData.currentTime();\n+          Object value = batchData.currentValue();\n+          long partition = StorageEngine.getTimePartition(time);\n+          \n+          Map<MeasurementSchema, IChunkWriter> chunkWriters = chunkWritersInChunkGroup.getOrDefault(partition, new HashMap<>());\n+          IChunkWriter chunkWriter = chunkWriters.getOrDefault(schema, new ChunkWriterImpl(schema));\n+          TsFileIOWriter tsFileIOWriter = getOrDefaultTsFileIOWriter(oldTsFile, partition);\n+          partitionWriterMap.put(partition, tsFileIOWriter);\n+          switch (schema.getType()) {\n+            case INT32:\n+              chunkWriter.write(time, (int) value);\n+              break;\n+            case INT64:\n+              chunkWriter.write(time, (long) value);\n+              break;\n+            case FLOAT:\n+              chunkWriter.write(time, (float) value);\n+              break;\n+            case DOUBLE:\n+              chunkWriter.write(time, (double) value);\n+              break;\n+            case BOOLEAN:\n+              chunkWriter.write(time, (boolean) value);\n+              break;\n+            case TEXT:\n+              chunkWriter.write(time, (Binary) value);\n+              break;\n+            default:\n+              throw new UnSupportedDataTypeException(\n+                  String.format(\"Data type %s is not supported.\", schema.getType()));\n+            }\n+          chunkWriters.put(schema, chunkWriter);\n+          chunkWritersInChunkGroup.put(partition, chunkWriters);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 462}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYwNDIwNg==", "bodyText": "no need to put again.  if the writer is newly created, it will be put into the map and then get.", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422604206", "createdAt": "2020-05-10T07:52:09Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/tools/upgrade/TsfileOnlineUpgradeTool.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.upgrade;\n+\n+import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.tsfile.common.conf.TSFileConfig;\n+import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n+import org.apache.iotdb.tsfile.compress.IUnCompressor;\n+import org.apache.iotdb.tsfile.encoding.decoder.Decoder;\n+import org.apache.iotdb.tsfile.exception.write.PageException;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.exception.write.WriteProcessException;\n+import org.apache.iotdb.tsfile.file.MetaMarker;\n+import org.apache.iotdb.tsfile.file.footer.ChunkGroupFooter;\n+import org.apache.iotdb.tsfile.file.header.ChunkHeader;\n+import org.apache.iotdb.tsfile.file.header.PageHeader;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkGroupMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldChunkGroupMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.OldChunkMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsDeviceMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsDeviceMetadataIndex;\n+import org.apache.iotdb.tsfile.file.metadata.OldTsFileMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.TimeseriesMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.reader.LocalTsFileInput;\n+import org.apache.iotdb.tsfile.read.reader.TsFileInput;\n+import org.apache.iotdb.tsfile.read.reader.page.PageReader;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.apache.iotdb.tsfile.write.chunk.ChunkWriterImpl;\n+import org.apache.iotdb.tsfile.write.chunk.IChunkWriter;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.iotdb.tsfile.write.writer.TsFileIOWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+public class TsfileOnlineUpgradeTool implements AutoCloseable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(TsfileOnlineUpgradeTool.class);\n+\n+  private TsFileInput tsFileInput;\n+  private long fileMetadataPos;\n+  private int fileMetadataSize;\n+  private ByteBuffer markerBuffer = ByteBuffer.allocate(Byte.BYTES);\n+  protected String file;\n+  \n+  // PartitionId -> TsFileIOWriter \n+  private Map<Long, TsFileIOWriter> partitionWriterMap;\n+\n+  /**\n+   * Create a file reader of the given file. The reader will read the tail of the file to get the\n+   * file metadata size.Then the reader will skip the first TSFileConfig.OLD_MAGIC_STRING.length()\n+   * bytes of the file for preparing reading real data.\n+   *\n+   * @param file the data file\n+   * @throws IOException If some I/O error occurs\n+   */\n+  public TsfileOnlineUpgradeTool(String file) throws IOException {\n+    this(file, true);\n+  }\n+\n+  /**\n+   * construct function for TsfileOnlineUpgradeTool.\n+   *\n+   * @param file -given file name\n+   * @param loadMetadataSize -load meta data size\n+   */\n+  public TsfileOnlineUpgradeTool(String file, boolean loadMetadataSize) throws IOException {\n+    this.file = file;\n+    final java.nio.file.Path path = Paths.get(file);\n+    tsFileInput = new LocalTsFileInput(path);\n+    partitionWriterMap = new HashMap<>();\n+    try {\n+      if (loadMetadataSize) {\n+        loadMetadataSize();\n+      }\n+    } catch (Exception e) {\n+      tsFileInput.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * \n+   */\n+  public void loadMetadataSize() throws IOException {\n+    ByteBuffer metadataSize = ByteBuffer.allocate(Integer.BYTES);\n+    tsFileInput.read(metadataSize,\n+        tsFileInput.size() - TSFileConfig.MAGIC_STRING.getBytes().length - Integer.BYTES);\n+    metadataSize.flip();\n+    // read file metadata size and position\n+    fileMetadataSize = ReadWriteIOUtils.readInt(metadataSize);\n+    fileMetadataPos =\n+        tsFileInput.size() - TSFileConfig.MAGIC_STRING.getBytes().length - Integer.BYTES\n+            - fileMetadataSize;\n+    // skip the magic header\n+    position(TSFileConfig.MAGIC_STRING.length());\n+  }\n+\n+  public String readTailMagic() throws IOException {\n+    long totalSize = tsFileInput.size();\n+\n+    ByteBuffer magicStringBytes = ByteBuffer.allocate(TSFileConfig.MAGIC_STRING.length());\n+    tsFileInput.read(magicStringBytes, totalSize - TSFileConfig.MAGIC_STRING.length());\n+    magicStringBytes.flip();\n+    return new String(magicStringBytes.array());\n+  }\n+\n+  /**\n+   * whether the file is a complete TsFile: only if the head magic and tail magic string exists.\n+   */\n+  public boolean isComplete() throws IOException {\n+    return tsFileInput.size() >= TSFileConfig.MAGIC_STRING.length() * 2 && readTailMagic()\n+        .equals(readHeadMagic());\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public String readHeadMagic() throws IOException {\n+    return readHeadMagic(false);\n+  }\n+\n+  /**\n+   * @param movePosition whether move the position of the file reader after reading the magic header\n+   * to the end of the magic head string.\n+   */\n+  public String readHeadMagic(boolean movePosition) throws IOException {\n+    ByteBuffer magicStringBytes = ByteBuffer.allocate(TSFileConfig.MAGIC_STRING.length());\n+    if (movePosition) {\n+      tsFileInput.position(0);\n+      tsFileInput.read(magicStringBytes);\n+    } else {\n+      tsFileInput.read(magicStringBytes, 0);\n+    }\n+    magicStringBytes.flip();\n+    return new String(magicStringBytes.array());\n+  }\n+\n+  /**\n+   * this function reads version number and checks compatibility of TsFile.\n+   */\n+  public String readVersionNumber() throws IOException {\n+    ByteBuffer versionNumberBytes = ByteBuffer\n+        .allocate(TSFileConfig.VERSION_NUMBER.getBytes().length);\n+    tsFileInput.position(TSFileConfig.MAGIC_STRING.getBytes().length);\n+    tsFileInput.read(versionNumberBytes);\n+    versionNumberBytes.flip();\n+    return new String(versionNumberBytes.array());\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public OldTsFileMetadata readFileMetadata() throws IOException {\n+    return OldTsFileMetadata.deserializeFrom(readData(fileMetadataPos, fileMetadataSize));\n+  }\n+\n+  /**\n+   * this function does not modify the position of the file reader.\n+   */\n+  public OldTsDeviceMetadata readTsDeviceMetaData(OldTsDeviceMetadataIndex index) throws IOException {\n+    return OldTsDeviceMetadata.deserializeFrom(readData(index.getOffset(), index.getLen()));\n+  }\n+\n+  /**\n+   * read data from current position of the input, and deserialize it to a CHUNK_GROUP_FOOTER. <br>\n+   * This method is not threadsafe.\n+   *\n+   * @return a CHUNK_GROUP_FOOTER\n+   * @throws IOException io error\n+   */\n+  public ChunkGroupFooter readChunkGroupFooter() throws IOException {\n+    return ChunkGroupFooter.deserializeFrom(tsFileInput.wrapAsInputStream(), true);\n+  }\n+\n+  /**\n+   * read data from current position of the input, and deserialize it to a CHUNK_HEADER. <br> This\n+   * method is not threadsafe.\n+   *\n+   * @return a CHUNK_HEADER\n+   * @throws IOException io error\n+   */\n+  public ChunkHeader readChunkHeader() throws IOException {\n+    return ChunkHeader.deserializeFrom(tsFileInput.wrapAsInputStream(), true, true);\n+  }\n+\n+  /**\n+   * not thread safe.\n+   *\n+   * @param type given tsfile data type\n+   */\n+  public PageHeader readPageHeader(TSDataType type) throws IOException {\n+    return PageHeader.deserializeFrom(tsFileInput.wrapAsInputStream(), type, true);\n+  }\n+\n+  public ByteBuffer readPage(PageHeader header, CompressionType type)\n+      throws IOException {\n+    ByteBuffer buffer = readData(-1, header.getCompressedSize());\n+    IUnCompressor unCompressor = IUnCompressor.getUnCompressor(type);\n+    ByteBuffer uncompressedBuffer = ByteBuffer.allocate(header.getUncompressedSize());\n+    if (type == CompressionType.UNCOMPRESSED) {\n+      return buffer;\n+    }\n+    unCompressor.uncompress(buffer.array(), buffer.position(), buffer.remaining(),\n+        uncompressedBuffer.array(),\n+        0);\n+    return uncompressedBuffer;\n+  }\n+  \n+  public ByteBuffer readCompressedPage(PageHeader header) throws IOException {\n+    return readData(-1, header.getCompressedSize());\n+  }\n+\n+  public long position() throws IOException {\n+    return tsFileInput.position();\n+  }\n+\n+  public void position(long offset) throws IOException {\n+    tsFileInput.position(offset);\n+  }\n+\n+  /**\n+   * read one byte from the input. <br> this method is not thread safe\n+   */\n+  public byte readMarker() throws IOException {\n+    markerBuffer.clear();\n+    if (ReadWriteIOUtils.readAsPossible(tsFileInput, markerBuffer) == 0) {\n+      throw new IOException(\"reach the end of the file.\");\n+    }\n+    markerBuffer.flip();\n+    return markerBuffer.get();\n+  }\n+\n+  public byte readMarker(long position) throws IOException {\n+    return readData(position, Byte.BYTES).get();\n+  }\n+\n+  public void close() throws IOException {\n+    this.tsFileInput.close();\n+  }\n+\n+  public String getFileName() {\n+    return this.file;\n+  }\n+\n+  /**\n+   * read data from tsFileInput, from the current position (if position = -1), or the given\n+   * position. <br> if position = -1, the tsFileInput's position will be changed to the current\n+   * position + real data size that been read. Other wise, the tsFileInput's position is not\n+   * changed.\n+   *\n+   * @param position the start position of data in the tsFileInput, or the current position if\n+   * position = -1\n+   * @param size the size of data that want to read\n+   * @return data that been read.\n+   */\n+  private ByteBuffer readData(long position, int size) throws IOException {\n+    ByteBuffer buffer = ByteBuffer.allocate(size);\n+    if (position == -1) {\n+      if (ReadWriteIOUtils.readAsPossible(tsFileInput, buffer) != size) {\n+        throw new IOException(\"reach the end of the data\");\n+      }\n+    } else {\n+      if (ReadWriteIOUtils.readAsPossible(tsFileInput, buffer, position, size) != size) {\n+        throw new IOException(\"reach the end of the data\");\n+      }\n+    }\n+    buffer.flip();\n+    return buffer;\n+  }\n+\n+  /**\n+   * upgrade file and resource, return the boolean value whether upgrade task completes\n+   * @throws IOException, WriteProcessException \n+   */\n+  public boolean upgradeFile(List<TsFileResource> upgradedResources) \n+      throws IOException, WriteProcessException {\n+    File oldTsFile = FSFactoryProducer.getFSFactory().getFile(this.file);\n+\n+    // check if the old TsFile has correct header \n+    if (!fileCheck(oldTsFile)) {\n+      return false;\n+    }\n+\n+    // ChunkGroupOffset -> version\n+    Map<Long, Long> oldVersionInfo = new HashMap<>();\n+\n+    // ChunkGroupOffset -> time partition, record the offsets of chunk group that data are in same partition\n+    Map<Long, Long> chunkGroupTimePartitionInfo = new HashMap<>();\n+\n+    // scan metadata to get version Info and chunkGroupTimePartitionInfo\n+    scanMetadata(oldVersionInfo, chunkGroupTimePartitionInfo);\n+    \n+    // start to scan chunks and chunkGroups\n+    long startOffsetOfChunkGroup = 0;\n+    boolean newChunkGroup = true;\n+    long versionOfChunkGroup = 0;\n+    boolean chunkGroupInSamePartition = false;\n+    List<ChunkGroupMetadata> newMetaData = new ArrayList<>();\n+    List<List<PageHeader>> pageHeadersInChunkGroup = new ArrayList<>();\n+    List<List<ByteBuffer>> dataInChunkGroup = new ArrayList<>();\n+    byte marker;\n+    List<MeasurementSchema> measurementSchemaList = new ArrayList<>();\n+    try {\n+      while ((marker = this.readMarker()) != MetaMarker.SEPARATOR) {\n+        switch (marker) {\n+          case MetaMarker.CHUNK_HEADER:\n+            // this is the first chunk of a new ChunkGroup.\n+            if (newChunkGroup) {\n+              newChunkGroup = false;\n+              startOffsetOfChunkGroup = this.position() - 1;\n+              versionOfChunkGroup = oldVersionInfo.get(startOffsetOfChunkGroup);\n+              chunkGroupInSamePartition = chunkGroupTimePartitionInfo\n+                  .containsKey(startOffsetOfChunkGroup);\n+            }\n+            ChunkHeader header = this.readChunkHeader();\n+            MeasurementSchema measurementSchema = new MeasurementSchema(header.getMeasurementID(),\n+                header.getDataType(),\n+                header.getEncodingType(), \n+                header.getCompressionType());\n+            measurementSchemaList.add(measurementSchema);\n+            List<PageHeader> pageHeadersInChunk = new ArrayList<>();\n+            List<ByteBuffer> dataInChunk = new ArrayList<>();\n+            for (int j = 0; j < header.getNumOfPages(); j++) {\n+              PageHeader pageHeader = readPageHeader(header.getDataType());\n+              ByteBuffer pageData = chunkGroupInSamePartition ? \n+                  readCompressedPage(pageHeader) : readPage(pageHeader, header.getCompressionType());\n+              pageHeadersInChunk.add(pageHeader);\n+              dataInChunk.add(pageData);\n+            }\n+            pageHeadersInChunkGroup.add(pageHeadersInChunk);\n+            dataInChunkGroup.add(dataInChunk);\n+            break;\n+          case MetaMarker.CHUNK_GROUP_FOOTER:\n+            // this is the footer of a ChunkGroup.\n+            ChunkGroupFooter chunkGroupFooter = this.readChunkGroupFooter();\n+            String deviceID = chunkGroupFooter.getDeviceID();\n+            if (chunkGroupInSamePartition) {\n+              quickRewrite(oldTsFile, deviceID, measurementSchemaList, pageHeadersInChunkGroup,\n+                  dataInChunkGroup, versionOfChunkGroup, chunkGroupTimePartitionInfo.get(startOffsetOfChunkGroup));\n+            } else {\n+              rewrite(oldTsFile, deviceID, measurementSchemaList, \n+                dataInChunkGroup, versionOfChunkGroup);\n+            }\n+\n+            pageHeadersInChunkGroup.clear();\n+            dataInChunkGroup.clear();\n+            measurementSchemaList.clear();\n+            newChunkGroup = true;\n+            break;\n+\n+          default:\n+            // the disk file is corrupted, using this file may be dangerous\n+            logger.error(\"Unrecognized marker detected, this file may be corrupted\");\n+            return false;\n+        }\n+      }\n+      // close upgraded tsFiles and generate resources for them\n+      for (TsFileIOWriter tsFileIOWriter : partitionWriterMap.values()) {\n+        upgradedResources.add(endFileAndGenerateResource(tsFileIOWriter));\n+      }\n+      return true;\n+    } catch (IOException e2) {\n+      logger.info(\"TsFile upgrade process cannot proceed at position {} after {} chunk groups \"\n+          + \"recovered, because : {}\", this.position(), newMetaData.size(), e2.getMessage());\n+      return false;\n+    } finally {\n+      if (tsFileInput != null) {\n+        tsFileInput.close();\n+      }\n+    }\n+  }\n+\n+  /**\n+   *  Rewrite the chunk group to new TsFile.\n+   *  If data of this chunk group are in different time partitions,\n+   *  create multiple new TsFiles and rewrite data in each partition.\n+   */\n+  private void rewrite(File oldTsFile, String deviceId, List<MeasurementSchema> schemas, \n+      List<List<ByteBuffer>> dataInChunkGroup, long versionOfChunkGroup) \n+          throws IOException {\n+\n+    Map<Long, Map<MeasurementSchema, IChunkWriter>> chunkWritersInChunkGroup = new HashMap<>();\n+    for (int i = 0; i < schemas.size(); i++) {\n+      MeasurementSchema schema = schemas.get(i);\n+      Decoder defaultTimeDecoder = Decoder.getDecoderByType(\n+          TSEncoding.valueOf(TSFileDescriptor.getInstance().getConfig().getTimeEncoder()),\n+          TSDataType.INT64);\n+      Decoder valueDecoder = Decoder\n+          .getDecoderByType(schema.getEncodingType(), schema.getType());\n+      List<ByteBuffer> dataInChunk = dataInChunkGroup.get(i);\n+      for (ByteBuffer pageData : dataInChunk) {\n+        valueDecoder.reset();\n+        PageReader pageReader = new PageReader(pageData, schema.getType(), valueDecoder,\n+            defaultTimeDecoder, null);\n+        BatchData batchData = pageReader.getAllSatisfiedPageData();\n+        while (batchData.hasCurrent()) {\n+          long time = batchData.currentTime();\n+          Object value = batchData.currentValue();\n+          long partition = StorageEngine.getTimePartition(time);\n+          \n+          Map<MeasurementSchema, IChunkWriter> chunkWriters = chunkWritersInChunkGroup.getOrDefault(partition, new HashMap<>());\n+          IChunkWriter chunkWriter = chunkWriters.getOrDefault(schema, new ChunkWriterImpl(schema));\n+          TsFileIOWriter tsFileIOWriter = getOrDefaultTsFileIOWriter(oldTsFile, partition);\n+          partitionWriterMap.put(partition, tsFileIOWriter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 437}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYwNDg0Mw==", "bodyText": "I suggest not return a boolean, because we usually do not handly it. Check code to see whether you clean the crashed files when restarting, Do you handle crashed upgraded files by covering?", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422604843", "createdAt": "2020-05-10T07:56:26Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/tools/upgrade/UpgradeTool.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.tools.upgrade;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.tsfile.exception.write.WriteProcessException;\n+\n+public class UpgradeTool {\n+  \n+  private UpgradeTool() {\n+  }\n+\n+  /**\n+   * upgrade a single tsfile\n+   *\n+   * @param tsfileName old version tsFile's absolute path\n+   * @param upgradedResources new version tsFiles' resources\n+   * @throws WriteProcessException \n+   */\n+  public static void upgradeOneTsfile(String tsFileName, List<TsFileResource> upgradedResources) \n+      throws IOException, WriteProcessException {\n+    try (TsfileOnlineUpgradeTool updater = new TsfileOnlineUpgradeTool(tsFileName)) {\n+      updater.upgradeFile(upgradedResources);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYwNzY1OQ==", "bodyText": "the upgradedResources is under control, no need to getTimepartition with check", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422607659", "createdAt": "2020-05-10T08:15:29Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/upgrade/UpgradeTask.java", "diffHunk": "@@ -40,30 +47,69 @@ public UpgradeTask(TsFileResource upgradeResource) {\n   @Override\n   public void runMayThrow() {\n     try {\n-      upgradeResource.getWriteQueryLock().readLock().lock();\n-      String tsfilePathBefore = upgradeResource.getFile().getAbsolutePath();\n-      String tsfilePathAfter = UpgradeUtils.getUpgradeFileName(upgradeResource.getFile());\n-\n-      UpgradeLog.writeUpgradeLogFile(\n-          tsfilePathBefore + COMMA_SEPERATOR + UpgradeCheckStatus.BEGIN_UPGRADE_FILE);\n+      List<TsFileResource> upgradedResources = generateUpgradedFiles();\n       upgradeResource.getWriteQueryLock().writeLock().lock();\n+      String oldTsfilePath = upgradeResource.getFile().getAbsolutePath();\n       try {\n-        FSFactoryProducer.getFSFactory().getFile(tsfilePathBefore).delete();\n-        FSFactoryProducer.getFSFactory()\n-            .moveFile(FSFactoryProducer.getFSFactory().getFile(tsfilePathAfter),\n-                FSFactoryProducer.getFSFactory().getFile(tsfilePathBefore));\n+        // delete old TsFile\n+        upgradeResource.remove();\n+        // move upgraded TsFiles to their own partition directories\n+        for (TsFileResource upgradedResource : upgradedResources) {\n+          File upgradedFile = upgradedResource.getFile();\n+          long partition = upgradedResource.getTimePartitionWithCheck();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYwODMyMQ==", "bodyText": "this may produce NullPointerException, better to have a check", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422608321", "createdAt": "2020-05-10T08:20:17Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/upgrade/UpgradeTask.java", "diffHunk": "@@ -40,30 +47,69 @@ public UpgradeTask(TsFileResource upgradeResource) {\n   @Override\n   public void runMayThrow() {\n     try {\n-      upgradeResource.getWriteQueryLock().readLock().lock();\n-      String tsfilePathBefore = upgradeResource.getFile().getAbsolutePath();\n-      String tsfilePathAfter = UpgradeUtils.getUpgradeFileName(upgradeResource.getFile());\n-\n-      UpgradeLog.writeUpgradeLogFile(\n-          tsfilePathBefore + COMMA_SEPERATOR + UpgradeCheckStatus.BEGIN_UPGRADE_FILE);\n+      List<TsFileResource> upgradedResources = generateUpgradedFiles();\n       upgradeResource.getWriteQueryLock().writeLock().lock();\n+      String oldTsfilePath = upgradeResource.getFile().getAbsolutePath();\n       try {\n-        FSFactoryProducer.getFSFactory().getFile(tsfilePathBefore).delete();\n-        FSFactoryProducer.getFSFactory()\n-            .moveFile(FSFactoryProducer.getFSFactory().getFile(tsfilePathAfter),\n-                FSFactoryProducer.getFSFactory().getFile(tsfilePathBefore));\n+        // delete old TsFile\n+        upgradeResource.remove();\n+        // move upgraded TsFiles to their own partition directories\n+        for (TsFileResource upgradedResource : upgradedResources) {\n+          File upgradedFile = upgradedResource.getFile();\n+          long partition = upgradedResource.getTimePartitionWithCheck();\n+          String storageGroupPath = upgradedFile.getParentFile().getParentFile().getParent();\n+          File partitionDir = FSFactoryProducer.getFSFactory().getFile(storageGroupPath, partition + \"\");\n+          if (!partitionDir.exists()) {\n+            partitionDir.mkdir();\n+          }\n+          FSFactoryProducer.getFSFactory().moveFile(upgradedFile,\n+              FSFactoryProducer.getFSFactory().getFile(partitionDir, upgradedFile.getName()));\n+          upgradedResource.setFile(\n+              FSFactoryProducer.getFSFactory().getFile(partitionDir, upgradedFile.getName()));\n+          upgradedResource.serialize();\n+          // delete tmp partition folder when it is empty\n+          if (upgradedFile.getParentFile().isDirectory() \n+              && upgradedFile.getParentFile().listFiles().length == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYxMDg0MA==", "bodyText": "lock once is enough", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422610840", "createdAt": "2020-05-10T08:37:58Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1106,6 +1220,18 @@ public void writeUnlock() {\n         closeQueryLock.readLock().unlock();\n       }\n     }\n+    // for upgrade files and old files must be closed\n+    for (TsFileResource tsFileResource : upgradeTsFileResources) {\n+      if (!isTsFileResourceSatisfied(tsFileResource, deviceId, timeFilter)) {\n+        continue;\n+      }\n+      closeQueryLock.readLock().lock();\n+      try {\n+        tsfileResourcesForQuery.add(tsFileResource);\n+      } finally {\n+        closeQueryLock.readLock().unlock();\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYxMjIyOA==", "bodyText": "check if it is end with .tsfile, do not warning", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422612228", "createdAt": "2020-05-10T08:48:30Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -316,40 +377,93 @@ private VersionController getVersionControllerByTimePartitionId(long timePartiti\n         });\n   }\n \n-  private List<TsFileResource> getAllFiles(List<String> folders) {\n+  private Pair<List<TsFileResource>, List<TsFileResource>> getAllFiles(List<String> folders) throws IOException {\n     List<File> tsFiles = new ArrayList<>();\n+    List<File> upgradeFiles = new ArrayList<>();\n     for (String baseDir : folders) {\n       File fileFolder = fsFactory.getFile(baseDir, storageGroupName);\n       if (!fileFolder.exists()) {\n         continue;\n       }\n \n+      // old version\n+      // some TsFileResource may be being persisted when the system crashed, try recovering such\n+      // resources\n+      continueFailedRenames(fileFolder, TEMP_SUFFIX);\n+\n+      // some TsFiles were going to be replaced by the merged files when the system crashed and\n+      // the process was interrupted before the merged files could be named\n+      continueFailedRenames(fileFolder, MERGE_SUFFIX);\n+\n+      File[] oldTsfileArray = fsFactory.listFilesBySuffix(fileFolder.getAbsolutePath(), TSFILE_SUFFIX);\n+      File[] oldResourceFileArray = fsFactory.listFilesBySuffix(fileFolder.getAbsolutePath(), TsFileResource.RESOURCE_SUFFIX);\n+      File upgradeFolder = fsFactory.getFile(fileFolder, IoTDBConstant.UPGRADE_FOLDER_NAME);\n+      // move the old files to upgrade folder if exists\n+      if (oldTsfileArray.length != 0 || oldResourceFileArray.length != 0) {\n+        // create upgrade directory if not exist\n+        if (upgradeFolder.mkdirs()) {\n+          logger.info(\"Upgrade Directory {} doesn't exist, create it\",\n+              upgradeFolder.getPath());\n+        } else if (!upgradeFolder.exists()) {\n+          logger.error(\"Create upgrade Directory {} failed\",\n+              upgradeFolder.getPath());\n+        }\n+        // move .tsfile to upgrade folder\n+        for (File file : oldTsfileArray) {\n+          if (!file.renameTo(fsFactory.getFile(upgradeFolder, file.getName()))) {\n+            logger.error(\"Failed to move {} to upgrade folder\", file);\n+          }\n+        }\n+        // move .resource to upgrade folder\n+        for (File file : oldResourceFileArray) {\n+          if (!file.renameTo(fsFactory.getFile(upgradeFolder, file.getName()))) {\n+            logger.error(\"Failed to move {} to upgrade folder\", file);\n+          }\n+        }\n+\n+        Collections.addAll(upgradeFiles,\n+            fsFactory.listFilesBySuffix(upgradeFolder.getAbsolutePath(), TSFILE_SUFFIX));\n+      }\n+      // if already move old files to upgradeFolder \n+      else if (upgradeFolder.exists()) {\n+        Collections.addAll(upgradeFiles,\n+            fsFactory.listFilesBySuffix(upgradeFolder.getAbsolutePath(), TSFILE_SUFFIX));\n+      }\n+\n       File[] subFiles = fileFolder.listFiles();\n       if (subFiles != null) {\n         for (File partitionFolder : subFiles) {\n-          // some TsFileResource may be being persisted when the system crashed, try recovering such\n-          // resources\n-          continueFailedRenames(partitionFolder, TEMP_SUFFIX);\n-\n-          // some TsFiles were going to be replaced by the merged files when the system crashed and\n-          // the process was interrupted before the merged files could be named\n-          continueFailedRenames(partitionFolder, MERGE_SUFFIX);\n-\n-        if (!partitionFolder.isDirectory()) {\n-          logger.warn(\"{} is not a directory.\", partitionFolder.getAbsolutePath());\n-          continue;\n-        }\n-\n-        Collections.addAll(tsFiles,\n-            fsFactory.listFilesBySuffix(partitionFolder.getAbsolutePath(), TSFILE_SUFFIX));\n+          if (!partitionFolder.isDirectory()) {\n+            logger.warn(\"{} is not a directory.\", partitionFolder.getAbsolutePath());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42cbb6a5bae08661155c7927ae6b97e9012aa05"}, "originalPosition": 188}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfa08304c916c375827647f3a83580a257d8a61b", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/cfa08304c916c375827647f3a83580a257d8a61b", "committedDate": "2020-05-10T15:42:20Z", "message": "fix review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80ac01444d906bf153c8fffb32c316e06d2eb921", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/80ac01444d906bf153c8fffb32c316e06d2eb921", "committedDate": "2020-05-10T16:12:52Z", "message": "fix bug"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4ODI5MzYy", "url": "https://github.com/apache/iotdb/pull/983#pullrequestreview-408829362", "createdAt": "2020-05-11T02:50:11Z", "commit": {"oid": "80ac01444d906bf153c8fffb32c316e06d2eb921"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwMjo1MDoxMVrOGTKvHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwMzoyNjowM1rOGTLMBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc1MjAyOQ==", "bodyText": "I think a name like updateLastestFlushedTime suits better.", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422752029", "createdAt": "2020-05-11T02:50:11Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -298,6 +319,46 @@ private void updatePartitionFileVersion(long partitionNum, long fileVersion) {\n     }\n   }\n \n+  /**\n+   * use old seq file to update latestTimeForEachDevice, globalLatestFlushedTimeForEachDevice,\n+   * partitionLatestFlushedTimeForEachDevice and timePartitionIdVersionControllerMap\n+   *\n+   */\n+  private void doUpdate() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80ac01444d906bf153c8fffb32c316e06d2eb921"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc1OTQzMA==", "bodyText": "This is my understanding:\nFiles that are already in the partitioned folders (like data/sg1/0/1-1-1.tsfile) will not be upgraded, but files that are not in the partitioned folders  (like data/sg1/1-1-1.tsfile) will be moved to an upgrading folder (like data/sg1/upgrade/1-1-1.tsfile), upgraded and reloaded into IoTDB.\nBut what if the files in the partitioned folders also need upgrading?", "url": "https://github.com/apache/iotdb/pull/983#discussion_r422759430", "createdAt": "2020-05-11T03:26:03Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -316,40 +377,93 @@ private VersionController getVersionControllerByTimePartitionId(long timePartiti\n         });\n   }\n \n-  private List<TsFileResource> getAllFiles(List<String> folders) {\n+  private Pair<List<TsFileResource>, List<TsFileResource>> getAllFiles(List<String> folders) throws IOException {\n     List<File> tsFiles = new ArrayList<>();\n+    List<File> upgradeFiles = new ArrayList<>();\n     for (String baseDir : folders) {\n       File fileFolder = fsFactory.getFile(baseDir, storageGroupName);\n       if (!fileFolder.exists()) {\n         continue;\n       }\n \n+      // old version\n+      // some TsFileResource may be being persisted when the system crashed, try recovering such\n+      // resources\n+      continueFailedRenames(fileFolder, TEMP_SUFFIX);\n+\n+      // some TsFiles were going to be replaced by the merged files when the system crashed and\n+      // the process was interrupted before the merged files could be named\n+      continueFailedRenames(fileFolder, MERGE_SUFFIX);\n+\n+      File[] oldTsfileArray = fsFactory.listFilesBySuffix(fileFolder.getAbsolutePath(), TSFILE_SUFFIX);\n+      File[] oldResourceFileArray = fsFactory.listFilesBySuffix(fileFolder.getAbsolutePath(), TsFileResource.RESOURCE_SUFFIX);\n+      File upgradeFolder = fsFactory.getFile(fileFolder, IoTDBConstant.UPGRADE_FOLDER_NAME);\n+      // move the old files to upgrade folder if exists\n+      if (oldTsfileArray.length != 0 || oldResourceFileArray.length != 0) {\n+        // create upgrade directory if not exist\n+        if (upgradeFolder.mkdirs()) {\n+          logger.info(\"Upgrade Directory {} doesn't exist, create it\",\n+              upgradeFolder.getPath());\n+        } else if (!upgradeFolder.exists()) {\n+          logger.error(\"Create upgrade Directory {} failed\",\n+              upgradeFolder.getPath());\n+        }\n+        // move .tsfile to upgrade folder\n+        for (File file : oldTsfileArray) {\n+          if (!file.renameTo(fsFactory.getFile(upgradeFolder, file.getName()))) {\n+            logger.error(\"Failed to move {} to upgrade folder\", file);\n+          }\n+        }\n+        // move .resource to upgrade folder\n+        for (File file : oldResourceFileArray) {\n+          if (!file.renameTo(fsFactory.getFile(upgradeFolder, file.getName()))) {\n+            logger.error(\"Failed to move {} to upgrade folder\", file);\n+          }\n+        }\n+\n+        Collections.addAll(upgradeFiles,\n+            fsFactory.listFilesBySuffix(upgradeFolder.getAbsolutePath(), TSFILE_SUFFIX));\n+      }\n+      // if already move old files to upgradeFolder \n+      else if (upgradeFolder.exists()) {\n+        Collections.addAll(upgradeFiles,\n+            fsFactory.listFilesBySuffix(upgradeFolder.getAbsolutePath(), TSFILE_SUFFIX));\n+      }\n+\n       File[] subFiles = fileFolder.listFiles();\n       if (subFiles != null) {\n         for (File partitionFolder : subFiles) {\n-          // some TsFileResource may be being persisted when the system crashed, try recovering such\n-          // resources\n-          continueFailedRenames(partitionFolder, TEMP_SUFFIX);\n-\n-          // some TsFiles were going to be replaced by the merged files when the system crashed and\n-          // the process was interrupted before the merged files could be named\n-          continueFailedRenames(partitionFolder, MERGE_SUFFIX);\n-\n-        if (!partitionFolder.isDirectory()) {\n-          logger.warn(\"{} is not a directory.\", partitionFolder.getAbsolutePath());\n-          continue;\n-        }\n-\n-        Collections.addAll(tsFiles,\n-            fsFactory.listFilesBySuffix(partitionFolder.getAbsolutePath(), TSFILE_SUFFIX));\n+          if (!partitionFolder.isDirectory()) {\n+            logger.warn(\"{} is not a directory.\", partitionFolder.getAbsolutePath());\n+          } else if (!partitionFolder.getName().equals(IoTDBConstant.UPGRADE_FOLDER_NAME)) {\n+            // some TsFileResource may be being persisted when the system crashed, try recovering such\n+            // resources\n+            continueFailedRenames(partitionFolder, TEMP_SUFFIX);\n+\n+            // some TsFiles were going to be replaced by the merged files when the system crashed and\n+            // the process was interrupted before the merged files could be named\n+            continueFailedRenames(partitionFolder, MERGE_SUFFIX);\n+\n+            Collections.addAll(tsFiles,\n+                fsFactory.listFilesBySuffix(partitionFolder.getAbsolutePath(), TSFILE_SUFFIX));\n+          }\n         }\n       }\n \n     }\n     tsFiles.sort(this::compareFileName);\n     List<TsFileResource> ret = new ArrayList<>();\n     tsFiles.forEach(f -> ret.add(new TsFileResource(f)));\n-    return ret;\n+    upgradeFiles.sort(this::compareFileName);\n+    List<TsFileResource> upgradeRet = new ArrayList<>();\n+    for (File f : upgradeFiles) {\n+      TsFileResource fileResource = new TsFileResource(f);\n+      fileResource.setClosed(true);\n+      // make sure the flush command is called before IoTDB is down.\n+      fileResource.deserialize();\n+      upgradeRet.add(fileResource);\n+    }\n+    return new Pair<>(ret, upgradeRet);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80ac01444d906bf153c8fffb32c316e06d2eb921"}, "originalPosition": 218}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "587056599f49872f4fd0b07558069f1e4e55c37e", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/587056599f49872f4fd0b07558069f1e4e55c37e", "committedDate": "2020-05-11T09:42:11Z", "message": "move old codes to another package"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e35ea700bf82823840f561414e99f5eb06f0f316", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/e35ea700bf82823840f561414e99f5eb06f0f316", "committedDate": "2020-05-11T09:58:15Z", "message": "fix code smell"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f4082a28a262293004cb5cf1c266cd267395b5e", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/7f4082a28a262293004cb5cf1c266cd267395b5e", "committedDate": "2020-05-11T13:48:03Z", "message": "move method for old TsFile out of TimeseriesMetadata"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e64bb523eeef3385e453409bfccf465c49bf8647", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/e64bb523eeef3385e453409bfccf465c49bf8647", "committedDate": "2020-05-11T14:17:33Z", "message": "fix sonar"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc665f80ee77892a2198eb9a375de27cdd58459f", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/fc665f80ee77892a2198eb9a375de27cdd58459f", "committedDate": "2020-05-11T18:14:06Z", "message": "kill the bug taken my night"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edf1d8d1c9cebeef6e3d97dfb8ea8b3554d64e01", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/edf1d8d1c9cebeef6e3d97dfb8ea8b3554d64e01", "committedDate": "2020-05-12T02:02:10Z", "message": "fix sonar and add javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6ae16accdc460b81706ee394b2224924a13fd9d", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/b6ae16accdc460b81706ee394b2224924a13fd9d", "committedDate": "2020-05-12T06:03:46Z", "message": "mods files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c96888c8c2023e0bfbda57aed6de35b93c21359", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/9c96888c8c2023e0bfbda57aed6de35b93c21359", "committedDate": "2020-05-12T08:12:28Z", "message": "fix move mods file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78bd03e3cba3dd352d0182ccc3f4a4fcc95f7975", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/78bd03e3cba3dd352d0182ccc3f4a4fcc95f7975", "committedDate": "2020-05-12T08:28:24Z", "message": "fix sonar"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d7a8a27db18a9286ebee212ccc5a5df52b94375", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/4d7a8a27db18a9286ebee212ccc5a5df52b94375", "committedDate": "2020-05-12T14:05:21Z", "message": "refactor upgradeTool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53ab4459da73d9604c8d531aa75331c91e25a029", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/53ab4459da73d9604c8d531aa75331c91e25a029", "committedDate": "2020-05-12T14:32:33Z", "message": "Merge branch 'master' of https://github.com/apache/incubator-iotdb into upgrade_tool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1bd4c40c6953e9ece9cc1bd1eb9e93347854ce36", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/1bd4c40c6953e9ece9cc1bd1eb9e93347854ce36", "committedDate": "2020-05-12T15:19:14Z", "message": "fix review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b8587451b1200e13bd3afd182a6f327d4c96abb", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/2b8587451b1200e13bd3afd182a6f327d4c96abb", "committedDate": "2020-05-13T07:57:34Z", "message": "Merge branch 'master' of https://github.com/apache/incubator-iotdb into upgrade_tool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "534b79eccff61456408898e37afb329252c4f1b7", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/534b79eccff61456408898e37afb329252c4f1b7", "committedDate": "2020-05-13T08:03:31Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "534215505b5f2fbf50b1040074ac6a4a8561c82d", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/534215505b5f2fbf50b1040074ac6a4a8561c82d", "committedDate": "2020-05-13T08:24:11Z", "message": "fix sonar"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6841ff318612ada9f9b7d163fa8d632d65edf36c", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/6841ff318612ada9f9b7d163fa8d632d65edf36c", "committedDate": "2020-05-15T01:42:58Z", "message": "Merge branch 'master' into upgrade_tool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63dad07773463f1a5c685d8d7cfb155f0fcb8fad", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/63dad07773463f1a5c685d8d7cfb155f0fcb8fad", "committedDate": "2020-05-15T02:11:42Z", "message": "merge master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "758d0308ded6b2cbbef1293d95fd8054ec2f6f9c", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/758d0308ded6b2cbbef1293d95fd8054ec2f6f9c", "committedDate": "2020-05-15T02:12:55Z", "message": "fix test"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3059, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}