{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyMjkzODU1", "number": 935, "title": "Integrate data file version recording with time partitioning", "bodyText": "Previously the data file version recording is not integrated with time partitioning, so versions of different partitions may be mixed.\nThis PR will make file versions of different partitions be managed separately using a map.\nSome other minor fixes and extractions are also included to improve the code quality.", "createdAt": "2020-03-23T10:25:19Z", "url": "https://github.com/apache/iotdb/pull/935", "merged": true, "mergeCommit": {"oid": "f6f216e888459dedf392cbe1d7754f097e11db91"}, "closed": true, "closedAt": "2020-03-25T08:35:23Z", "author": {"login": "jt2594838"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcQa-VIgH2gAyMzkyMjkzODU1OjY3NTgwMjczZjhiOWE4ODFhZWQ0NDFmMjE1MWI1ZmM1YzZlOTUwMTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcRCznbgH2gAyMzkyMjkzODU1OmY0ZDFmYThkYzFjMjRkMDE1YzFhN2NjMTAwOWZiMjI2NTBkOWRhZjQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "67580273f8b9a881aed441f2151b5fc5c6e95013", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/67580273f8b9a881aed441f2151b5fc5c6e95013", "committedDate": "2020-03-23T09:34:29Z", "message": "integrate data partition with file version management"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/790d2a7a5330e31594f0e12ae0b7abed8b398568", "committedDate": "2020-03-23T10:20:23Z", "message": "code refinements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5OTUyOTgx", "url": "https://github.com/apache/iotdb/pull/935#pullrequestreview-379952981", "createdAt": "2020-03-24T02:05:14Z", "commit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMjowNToxNFrOF6emKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMjozMzo1OVrOF6fBmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2MzAxOA==", "bodyText": "All devices in A are newer than those in B.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396863018", "createdAt": "2020-03-24T02:05:14Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1638,12 +1646,98 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n     }\n   }\n \n+  /**\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n+   * @param newTsFileResource\n+   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n+   *         POS_OVERLAP(-3) if some file overlaps the new file\n+   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   */\n+  private int findInsertionPosition(TsFileResource newTsFileResource) {\n+    File tsfileToBeInserted = newTsFileResource.getFile();\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    int insertPos = -1;\n+\n+    List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n+    // find the position where the new file should be inserted\n+    for (int i = 0; i < sequenceList.size(); i++) {\n+      TsFileResource localFile = sequenceList.get(i);\n+      if (localFile.getFile().getName().equals(tsfileToBeInserted.getName())) {\n+        return POS_ALREADY_EXIST;\n+      }\n+      long localPartitionId = Long.parseLong(localFile.getFile().getParent());\n+      if (i == sequenceList.size() - 1 && localFile.getEndTimeMap().isEmpty()\n+          || newFilePartitionId != localPartitionId) {\n+        // skip files that are not in the partition as the new file and the last empty file\n+        continue;\n+      }\n+\n+      int fileComparison = compareTsFileDevices(newTsFileResource, localFile);\n+      switch (fileComparison) {\n+        case 0:\n+          // some devices are newer but some devices are older, the two files overlap in general\n+          return POS_OVERLAP;\n+        case -1:\n+          // all devices in the local file are newer than the new file, the new file can be\n+          // inserted before the new file\n+          return i - 1;\n+        default:\n+          // all devices in the local file are older than the new file, proceed to the next file\n+          insertPos = i;\n+      }\n+    }\n+    return insertPos;\n+  }\n+\n+  /**\n+   * Compare each device in the two files to find the time relation of them.\n+   * @param fileA\n+   * @param fileB\n+   * @return -1 if fileA is totally older than fileB (A < B)\n+   *          0 if fileA is partially older than fileB and partially newer than fileB (A X B)\n+   *          1 if fileA is totally newer than fileB (B < A)\n+   */\n+  private int compareTsFileDevices(TsFileResource fileA, TsFileResource fileB) {\n+    boolean hasPre = false, hasSubsequence = false;\n+    for (String device : fileA.getStartTimeMap().keySet()) {\n+      if (!fileB.getStartTimeMap().containsKey(device)) {\n+        continue;\n+      }\n+      long startTimeA = fileA.getStartTimeMap().get(device);\n+      long endTimeA = fileA.getEndTimeMap().get(device);\n+      long startTimeB = fileB.getStartTimeMap().get(device);\n+      long endTimeB = fileB.getEndTimeMap().get(device);\n+      if (startTimeA > endTimeB) {\n+        // A's data of the device is later than to the B's data\n+        hasSubsequence = true;\n+      } else if (startTimeB > endTimeA) {\n+        // A's data of the device is previous to the B's data\n+        hasPre = true;\n+      } else {\n+        // the two files overlap in the device\n+        return 0;\n+      }\n+    }\n+    if (hasPre && hasSubsequence) {\n+      // some devices are newer but some devices are older, the two files overlap in general\n+      return 0;\n+    }\n+    if (!hasPre && hasSubsequence) {\n+      // all devices in B are newer than those in A", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 412}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2MzA3NA==", "bodyText": "All devices in A are older than those in B.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396863074", "createdAt": "2020-03-24T02:05:24Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1638,12 +1646,98 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n     }\n   }\n \n+  /**\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n+   * @param newTsFileResource\n+   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n+   *         POS_OVERLAP(-3) if some file overlaps the new file\n+   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   */\n+  private int findInsertionPosition(TsFileResource newTsFileResource) {\n+    File tsfileToBeInserted = newTsFileResource.getFile();\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    int insertPos = -1;\n+\n+    List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n+    // find the position where the new file should be inserted\n+    for (int i = 0; i < sequenceList.size(); i++) {\n+      TsFileResource localFile = sequenceList.get(i);\n+      if (localFile.getFile().getName().equals(tsfileToBeInserted.getName())) {\n+        return POS_ALREADY_EXIST;\n+      }\n+      long localPartitionId = Long.parseLong(localFile.getFile().getParent());\n+      if (i == sequenceList.size() - 1 && localFile.getEndTimeMap().isEmpty()\n+          || newFilePartitionId != localPartitionId) {\n+        // skip files that are not in the partition as the new file and the last empty file\n+        continue;\n+      }\n+\n+      int fileComparison = compareTsFileDevices(newTsFileResource, localFile);\n+      switch (fileComparison) {\n+        case 0:\n+          // some devices are newer but some devices are older, the two files overlap in general\n+          return POS_OVERLAP;\n+        case -1:\n+          // all devices in the local file are newer than the new file, the new file can be\n+          // inserted before the new file\n+          return i - 1;\n+        default:\n+          // all devices in the local file are older than the new file, proceed to the next file\n+          insertPos = i;\n+      }\n+    }\n+    return insertPos;\n+  }\n+\n+  /**\n+   * Compare each device in the two files to find the time relation of them.\n+   * @param fileA\n+   * @param fileB\n+   * @return -1 if fileA is totally older than fileB (A < B)\n+   *          0 if fileA is partially older than fileB and partially newer than fileB (A X B)\n+   *          1 if fileA is totally newer than fileB (B < A)\n+   */\n+  private int compareTsFileDevices(TsFileResource fileA, TsFileResource fileB) {\n+    boolean hasPre = false, hasSubsequence = false;\n+    for (String device : fileA.getStartTimeMap().keySet()) {\n+      if (!fileB.getStartTimeMap().containsKey(device)) {\n+        continue;\n+      }\n+      long startTimeA = fileA.getStartTimeMap().get(device);\n+      long endTimeA = fileA.getEndTimeMap().get(device);\n+      long startTimeB = fileB.getStartTimeMap().get(device);\n+      long endTimeB = fileB.getEndTimeMap().get(device);\n+      if (startTimeA > endTimeB) {\n+        // A's data of the device is later than to the B's data\n+        hasSubsequence = true;\n+      } else if (startTimeB > endTimeA) {\n+        // A's data of the device is previous to the B's data\n+        hasPre = true;\n+      } else {\n+        // the two files overlap in the device\n+        return 0;\n+      }\n+    }\n+    if (hasPre && hasSubsequence) {\n+      // some devices are newer but some devices are older, the two files overlap in general\n+      return 0;\n+    }\n+    if (!hasPre && hasSubsequence) {\n+      // all devices in B are newer than those in A\n+      return -1;\n+    }\n+    // all devices in B are older than those in A", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 415}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2NDY5Nw==", "bodyText": "case 1:", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396864697", "createdAt": "2020-03-24T02:12:18Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1638,12 +1646,98 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n     }\n   }\n \n+  /**\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n+   * @param newTsFileResource\n+   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n+   *         POS_OVERLAP(-3) if some file overlaps the new file\n+   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   */\n+  private int findInsertionPosition(TsFileResource newTsFileResource) {\n+    File tsfileToBeInserted = newTsFileResource.getFile();\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    int insertPos = -1;\n+\n+    List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n+    // find the position where the new file should be inserted\n+    for (int i = 0; i < sequenceList.size(); i++) {\n+      TsFileResource localFile = sequenceList.get(i);\n+      if (localFile.getFile().getName().equals(tsfileToBeInserted.getName())) {\n+        return POS_ALREADY_EXIST;\n+      }\n+      long localPartitionId = Long.parseLong(localFile.getFile().getParent());\n+      if (i == sequenceList.size() - 1 && localFile.getEndTimeMap().isEmpty()\n+          || newFilePartitionId != localPartitionId) {\n+        // skip files that are not in the partition as the new file and the last empty file\n+        continue;\n+      }\n+\n+      int fileComparison = compareTsFileDevices(newTsFileResource, localFile);\n+      switch (fileComparison) {\n+        case 0:\n+          // some devices are newer but some devices are older, the two files overlap in general\n+          return POS_OVERLAP;\n+        case -1:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 366}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2NzU3MQ==", "bodyText": "I think this method needs to be  checked carefully.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396867571", "createdAt": "2020-03-24T02:24:10Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1638,12 +1646,98 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n     }\n   }\n \n+  /**\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n+   * @param newTsFileResource\n+   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n+   *         POS_OVERLAP(-3) if some file overlaps the new file\n+   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   */\n+  private int findInsertionPosition(TsFileResource newTsFileResource) {\n+    File tsfileToBeInserted = newTsFileResource.getFile();\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    int insertPos = -1;\n+\n+    List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n+    // find the position where the new file should be inserted\n+    for (int i = 0; i < sequenceList.size(); i++) {\n+      TsFileResource localFile = sequenceList.get(i);\n+      if (localFile.getFile().getName().equals(tsfileToBeInserted.getName())) {\n+        return POS_ALREADY_EXIST;\n+      }\n+      long localPartitionId = Long.parseLong(localFile.getFile().getParent());\n+      if (i == sequenceList.size() - 1 && localFile.getEndTimeMap().isEmpty()\n+          || newFilePartitionId != localPartitionId) {\n+        // skip files that are not in the partition as the new file and the last empty file\n+        continue;\n+      }\n+\n+      int fileComparison = compareTsFileDevices(newTsFileResource, localFile);\n+      switch (fileComparison) {\n+        case 0:\n+          // some devices are newer but some devices are older, the two files overlap in general\n+          return POS_OVERLAP;\n+        case -1:\n+          // all devices in the local file are newer than the new file, the new file can be\n+          // inserted before the new file\n+          return i - 1;\n+        default:\n+          // all devices in the local file are older than the new file, proceed to the next file\n+          insertPos = i;\n+      }\n+    }\n+    return insertPos;\n+  }\n+\n+  /**\n+   * Compare each device in the two files to find the time relation of them.\n+   * @param fileA\n+   * @param fileB\n+   * @return -1 if fileA is totally older than fileB (A < B)\n+   *          0 if fileA is partially older than fileB and partially newer than fileB (A X B)\n+   *          1 if fileA is totally newer than fileB (B < A)\n+   */\n+  private int compareTsFileDevices(TsFileResource fileA, TsFileResource fileB) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 386}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2ODI2MQ==", "bodyText": "return i;\nIt needs to add in the cur pos and move all newer files backward.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396868261", "createdAt": "2020-03-24T02:27:06Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1638,12 +1646,98 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n     }\n   }\n \n+  /**\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n+   * @param newTsFileResource\n+   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n+   *         POS_OVERLAP(-3) if some file overlaps the new file\n+   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   */\n+  private int findInsertionPosition(TsFileResource newTsFileResource) {\n+    File tsfileToBeInserted = newTsFileResource.getFile();\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    int insertPos = -1;\n+\n+    List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n+    // find the position where the new file should be inserted\n+    for (int i = 0; i < sequenceList.size(); i++) {\n+      TsFileResource localFile = sequenceList.get(i);\n+      if (localFile.getFile().getName().equals(tsfileToBeInserted.getName())) {\n+        return POS_ALREADY_EXIST;\n+      }\n+      long localPartitionId = Long.parseLong(localFile.getFile().getParent());\n+      if (i == sequenceList.size() - 1 && localFile.getEndTimeMap().isEmpty()\n+          || newFilePartitionId != localPartitionId) {\n+        // skip files that are not in the partition as the new file and the last empty file\n+        continue;\n+      }\n+\n+      int fileComparison = compareTsFileDevices(newTsFileResource, localFile);\n+      switch (fileComparison) {\n+        case 0:\n+          // some devices are newer but some devices are older, the two files overlap in general\n+          return POS_OVERLAP;\n+        case -1:\n+          // all devices in the local file are newer than the new file, the new file can be\n+          // inserted before the new file\n+          return i - 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 369}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2ODYwNA==", "bodyText": "return i + 1;\nIt needs to be inserted after the older files.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396868604", "createdAt": "2020-03-24T02:28:24Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1638,12 +1646,98 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n     }\n   }\n \n+  /**\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n+   * @param newTsFileResource\n+   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n+   *         POS_OVERLAP(-3) if some file overlaps the new file\n+   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   */\n+  private int findInsertionPosition(TsFileResource newTsFileResource) {\n+    File tsfileToBeInserted = newTsFileResource.getFile();\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    int insertPos = -1;\n+\n+    List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n+    // find the position where the new file should be inserted\n+    for (int i = 0; i < sequenceList.size(); i++) {\n+      TsFileResource localFile = sequenceList.get(i);\n+      if (localFile.getFile().getName().equals(tsfileToBeInserted.getName())) {\n+        return POS_ALREADY_EXIST;\n+      }\n+      long localPartitionId = Long.parseLong(localFile.getFile().getParent());\n+      if (i == sequenceList.size() - 1 && localFile.getEndTimeMap().isEmpty()\n+          || newFilePartitionId != localPartitionId) {\n+        // skip files that are not in the partition as the new file and the last empty file\n+        continue;\n+      }\n+\n+      int fileComparison = compareTsFileDevices(newTsFileResource, localFile);\n+      switch (fileComparison) {\n+        case 0:\n+          // some devices are newer but some devices are older, the two files overlap in general\n+          return POS_OVERLAP;\n+        case -1:\n+          // all devices in the local file are newer than the new file, the new file can be\n+          // inserted before the new file\n+          return i - 1;\n+        default:\n+          // all devices in the local file are older than the new file, proceed to the next file\n+          insertPos = i;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg2OTE0OQ==", "bodyText": "You can use if(! sequenceFileTreeSet.isEmpty()).\nThe origin if (subsequentIndex != sequenceFileTreeSet.size() || preIndex != -1) is equals to above.", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396869149", "createdAt": "2020-03-24T02:30:24Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1559,61 +1601,24 @@ public void loadNewTsFileForSync(TsFileResource newTsFileResource)\n   public void loadNewTsFile(TsFileResource newTsFileResource)\n       throws TsFileProcessorException {\n     File tsfileToBeInserted = newTsFileResource.getFile();\n+\n     writeLock();\n     mergeLock.writeLock().lock();\n     try {\n-      boolean isOverlap = false;\n-      int preIndex = -1, subsequentIndex = sequenceFileTreeSet.size();\n-\n-      List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n-      // check new tsfile\n-      outer:\n-      for (int i = 0; i < sequenceList.size(); i++) {\n-        if (sequenceList.get(i).getFile().getName().equals(tsfileToBeInserted.getName())) {\n-          return;\n-        }\n-        if (i == sequenceList.size() - 1 && sequenceList.get(i).getEndTimeMap().isEmpty()) {\n-          continue;\n-        }\n-        boolean hasPre = false, hasSubsequence = false;\n-        for (String device : newTsFileResource.getStartTimeMap().keySet()) {\n-          if (sequenceList.get(i).getStartTimeMap().containsKey(device)) {\n-            long startTime1 = sequenceList.get(i).getStartTimeMap().get(device);\n-            long endTime1 = sequenceList.get(i).getEndTimeMap().get(device);\n-            long startTime2 = newTsFileResource.getStartTimeMap().get(device);\n-            long endTime2 = newTsFileResource.getEndTimeMap().get(device);\n-            if (startTime1 > endTime2) {\n-              hasSubsequence = true;\n-            } else if (startTime2 > endTime1) {\n-              hasPre = true;\n-            } else {\n-              isOverlap = true;\n-              break outer;\n-            }\n-          }\n-        }\n-        if (hasPre && hasSubsequence) {\n-          isOverlap = true;\n-          break;\n-        }\n-        if (!hasPre && hasSubsequence) {\n-          subsequentIndex = i;\n-          break;\n-        }\n-        if (hasPre) {\n-          preIndex = i;\n-        }\n+      int insertPos = findInsertionPosition(newTsFileResource);\n+      if (insertPos == POS_ALREADY_EXIST) {\n+        return;\n       }\n \n       // loading tsfile by type\n-      if (isOverlap) {\n+      if (insertPos == POS_OVERLAP) {\n         loadTsFileByType(LoadTsFileType.LOAD_UNSEQUENCE, tsfileToBeInserted, newTsFileResource);\n       } else {\n \n         // check whether the file name needs to be renamed.\n-        if (subsequentIndex != sequenceFileTreeSet.size() || preIndex != -1) {\n-          String newFileName = getFileNameForLoadingFile(tsfileToBeInserted.getName(), preIndex,\n-              subsequentIndex, getTimePartitionFromTsFileResource(newTsFileResource));\n+        if (insertPos != sequenceFileTreeSet.size() - 1 || insertPos != -1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg3MDA0MQ==", "bodyText": "insertIndex == sequenceFileTreeSet.size()\nLogic:\nIf it needs to be inserted to be the last in the list.\nJust a note: currently, insertPos  is equals to subsequentIndex .", "url": "https://github.com/apache/iotdb/pull/935#discussion_r396870041", "createdAt": "2020-03-24T02:33:59Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1702,24 +1796,26 @@ private void removeFullyOverlapFiles(TsFileResource resource, Iterator<TsFileRes\n    * version number is the version number in the tsfile with a larger timestamp.\n    *\n    * @param tsfileName origin tsfile name\n+   * @param insertIndex the new file will be inserted between the files [insertIndex, insertIndex\n+   *                   + 1]\n    * @return appropriate filename\n    */\n-  private String getFileNameForLoadingFile(String tsfileName, int preIndex, int subsequentIndex,\n+  private String getFileNameForLoadingFile(String tsfileName, int insertIndex,\n       long timePartitionId) {\n     long currentTsFileTime = Long\n         .parseLong(tsfileName.split(IoTDBConstant.TSFILE_NAME_SEPARATOR)[0]);\n     long preTime;\n     List<TsFileResource> sequenceList = new ArrayList<>(sequenceFileTreeSet);\n-    if (preIndex == -1) {\n+    if (insertIndex == -1) {\n       preTime = 0L;\n     } else {\n-      String preName = sequenceList.get(preIndex).getFile().getName();\n+      String preName = sequenceList.get(insertIndex).getFile().getName();\n       preTime = Long.parseLong(preName.split(IoTDBConstant.TSFILE_NAME_SEPARATOR)[0]);\n     }\n-    if (subsequentIndex == sequenceFileTreeSet.size()) {\n+    if (insertIndex == sequenceFileTreeSet.size() - 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790d2a7a5330e31594f0e12ae0b7abed8b398568"}, "originalPosition": 454}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03045b093114652fbf384cbf79d74365ea3a519b", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/03045b093114652fbf384cbf79d74365ea3a519b", "committedDate": "2020-03-24T03:45:31Z", "message": "fix comparison and tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac2f66ee9ec0d6af3167788eae4806debeece43d", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/ac2f66ee9ec0d6af3167788eae4806debeece43d", "committedDate": "2020-03-24T04:00:09Z", "message": "fix by review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNDU0NDQ5", "url": "https://github.com/apache/iotdb/pull/935#pullrequestreview-380454449", "createdAt": "2020-03-24T15:58:07Z", "commit": {"oid": "ac2f66ee9ec0d6af3167788eae4806debeece43d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNTo1ODowN1rOF63Okw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNTo1ODowN1rOF63Okw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NjU3OQ==", "bodyText": "The parent file of the file may not be its time range. It's better to get time range from the time.\nSuch as:\nload /data/1584445970309-101-1.tsfile", "url": "https://github.com/apache/iotdb/pull/935#discussion_r397266579", "createdAt": "2020-03-24T15:58:07Z", "author": {"login": "fanhualta"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1655,7 +1655,7 @@ public void loadNewTsFile(TsFileResource newTsFileResource)\n    */\n   private int findInsertionPosition(TsFileResource newTsFileResource) {\n     File tsfileToBeInserted = newTsFileResource.getFile();\n-    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParent());\n+    long newFilePartitionId = Long.parseLong(tsfileToBeInserted.getParentFile().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac2f66ee9ec0d6af3167788eae4806debeece43d"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9cd6e24eb02cdabaa9ce60d7680257ae56d9bde", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/b9cd6e24eb02cdabaa9ce60d7680257ae56d9bde", "committedDate": "2020-03-25T02:03:34Z", "message": "fix time partition id getter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODE1MjMx", "url": "https://github.com/apache/iotdb/pull/935#pullrequestreview-380815231", "createdAt": "2020-03-25T02:05:48Z", "commit": {"oid": "b9cd6e24eb02cdabaa9ce60d7680257ae56d9bde"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8a5e6c3766b897d187c7726c4414c8c31be2fb9", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/a8a5e6c3766b897d187c7726c4414c8c31be2fb9", "committedDate": "2020-03-25T02:06:23Z", "message": "Merge branch 'master' into partitioned_file_version_management"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1069cba6bb1ab1ac9542ee594100bebb29a4af15", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/1069cba6bb1ab1ac9542ee594100bebb29a4af15", "committedDate": "2020-03-25T04:17:04Z", "message": "modify skip file condition"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f593088e888758171b8d5e6377a737fa32960eb", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/8f593088e888758171b8d5e6377a737fa32960eb", "committedDate": "2020-03-25T05:26:45Z", "message": "fix a comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96c0481a041c3ca54971c99bf6f104fb7d5818a8", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/96c0481a041c3ca54971c99bf6f104fb7d5818a8", "committedDate": "2020-03-25T05:53:35Z", "message": "avoid copy resource twice when loading new file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b544b9f403603214f966df8004a3bc54d794985b", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/b544b9f403603214f966df8004a3bc54d794985b", "committedDate": "2020-03-25T06:09:25Z", "message": "fix comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODc4Mzky", "url": "https://github.com/apache/iotdb/pull/935#pullrequestreview-380878392", "createdAt": "2020-03-25T06:10:47Z", "commit": {"oid": "a8a5e6c3766b897d187c7726c4414c8c31be2fb9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d92118723c10afbfbd1b997cb308ce53c6539cc7", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/d92118723c10afbfbd1b997cb308ce53c6539cc7", "committedDate": "2020-03-25T06:22:30Z", "message": "reduce exception depth"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4d1fa8dc1c24d015c1a7cc1009fb22650d9daf4", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/f4d1fa8dc1c24d015c1a7cc1009fb22650d9daf4", "committedDate": "2020-03-25T07:58:59Z", "message": "fix exception"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3028, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}