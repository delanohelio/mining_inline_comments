{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4Mjk4NjM5", "number": 1408, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwODoyNzo0MlrOEH3gSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQxMjoyMzo0OFrOEJcTJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2Njg0ODczOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwODoyNzo0MlrOGnewEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMToxMDo1MlrOGn_mTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA1MTQ3NA==", "bodyText": "No need to set this, the insertplan will be gc soon", "url": "https://github.com/apache/iotdb/pull/1408#discussion_r444051474", "createdAt": "2020-06-23T08:27:42Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -1800,4 +1807,207 @@ private void checkMTreeModified() {\n       }\n     }\n   }\n+\n+  /**\n+   * get schema for device.\n+   * Attention!!!  Only support insertPlan and insertTabletsPlan\n+   * @param deviceId\n+   * @param measurementList\n+   * @param plan\n+   * @return\n+   * @throws MetadataException\n+   */\n+  public MeasurementSchema[] getSeriesSchemasAndLock(String deviceId, String[] measurementList, PhysicalPlan plan) throws MetadataException {\n+    MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n+\n+    MNode deviceNode = null;\n+    // 1. get device node\n+    deviceNode = getDeviceNodeWithAutoCreateAndReadLock(deviceId);\n+    // To reduce the String number in memory, set the deviceId from MManager to insertPlan\n+    if (plan instanceof InsertPlan) {\n+      ((InsertPlan) plan).setDeviceId(deviceNode.getFullPath());\n+    } else if (plan instanceof InsertTabletPlan) {\n+      ((InsertTabletPlan) plan).setDeviceId(deviceNode.getFullPath());\n+    } else {\n+      throw new MetadataException(String.format(\n+        \"Only support insert and insertTablets, deviceId[%s], plans [%s]\", deviceId, plan.getOperatorType()));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d5105b438986ff1e68e38f085ca591db3a5b162"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU4OTY0NA==", "bodyText": "ok", "url": "https://github.com/apache/iotdb/pull/1408#discussion_r444589644", "createdAt": "2020-06-24T01:10:52Z", "author": {"login": "mychaow"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -1800,4 +1807,207 @@ private void checkMTreeModified() {\n       }\n     }\n   }\n+\n+  /**\n+   * get schema for device.\n+   * Attention!!!  Only support insertPlan and insertTabletsPlan\n+   * @param deviceId\n+   * @param measurementList\n+   * @param plan\n+   * @return\n+   * @throws MetadataException\n+   */\n+  public MeasurementSchema[] getSeriesSchemasAndLock(String deviceId, String[] measurementList, PhysicalPlan plan) throws MetadataException {\n+    MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n+\n+    MNode deviceNode = null;\n+    // 1. get device node\n+    deviceNode = getDeviceNodeWithAutoCreateAndReadLock(deviceId);\n+    // To reduce the String number in memory, set the deviceId from MManager to insertPlan\n+    if (plan instanceof InsertPlan) {\n+      ((InsertPlan) plan).setDeviceId(deviceNode.getFullPath());\n+    } else if (plan instanceof InsertTabletPlan) {\n+      ((InsertTabletPlan) plan).setDeviceId(deviceNode.getFullPath());\n+    } else {\n+      throw new MetadataException(String.format(\n+        \"Only support insert and insertTablets, deviceId[%s], plans [%s]\", deviceId, plan.getOperatorType()));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA1MTQ3NA=="}, "originalCommit": {"oid": "0d5105b438986ff1e68e38f085ca591db3a5b162"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2Njg5OTg4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwODo0MTowOVrOGnfRAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwODo0MTowOVrOGnfRAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA1OTkwNw==", "bodyText": "what if the measurement already exists?\nadd\nelse {\nisCreated = true\n}\nbesides\uff0ccombine these to one line", "url": "https://github.com/apache/iotdb/pull/1408#discussion_r444059907", "createdAt": "2020-06-23T08:41:09Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -1800,4 +1807,207 @@ private void checkMTreeModified() {\n       }\n     }\n   }\n+\n+  /**\n+   * get schema for device.\n+   * Attention!!!  Only support insertPlan and insertTabletsPlan\n+   * @param deviceId\n+   * @param measurementList\n+   * @param plan\n+   * @return\n+   * @throws MetadataException\n+   */\n+  public MeasurementSchema[] getSeriesSchemasAndLock(String deviceId, String[] measurementList, PhysicalPlan plan) throws MetadataException {\n+    MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n+\n+    MNode deviceNode = null;\n+    // 1. get device node\n+    deviceNode = getDeviceNodeWithAutoCreateAndReadLock(deviceId);\n+    // To reduce the String number in memory, set the deviceId from MManager to insertPlan\n+    if (plan instanceof InsertPlan) {\n+      ((InsertPlan) plan).setDeviceId(deviceNode.getFullPath());\n+    } else if (plan instanceof InsertTabletPlan) {\n+      ((InsertTabletPlan) plan).setDeviceId(deviceNode.getFullPath());\n+    } else {\n+      throw new MetadataException(String.format(\n+        \"Only support insert and insertTablets, deviceId[%s], plans [%s]\", deviceId, plan.getOperatorType()));\n+    }\n+\n+    // 2. get schema of each measurement\n+    for (int i = 0; i < measurementList.length; i++) {\n+      try {\n+        // if do not has measurement\n+        boolean isCreated = false;\n+        if (!deviceNode.hasChild(measurementList[i])) {\n+          // could not create it\n+          if (!config.isAutoCreateSchemaEnabled()) {\n+            throw new MetadataException(String.format(\n+              \"Current deviceId[%s] does not contain measurement:%s\", deviceId, measurementList[i]));\n+          }\n+\n+          // create it\n+          Path path = new Path(deviceId, measurementList[i]);\n+          TSDataType dataType = getTypeInLoc(plan, i);\n+\n+          createTimeseries(\n+            path.getFullPath(),\n+            dataType,\n+            getDefaultEncoding(dataType),\n+            TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+            Collections.emptyMap());\n+          isCreated = true;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d5105b438986ff1e68e38f085ca591db3a5b162"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjkwMzI5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwODo0MjoxMVrOGnfTOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwODo0MjoxMVrOGnfTOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA2MDQ3Mg==", "bodyText": "insertDataType", "url": "https://github.com/apache/iotdb/pull/1408#discussion_r444060472", "createdAt": "2020-06-23T08:42:11Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -1800,4 +1807,207 @@ private void checkMTreeModified() {\n       }\n     }\n   }\n+\n+  /**\n+   * get schema for device.\n+   * Attention!!!  Only support insertPlan and insertTabletsPlan\n+   * @param deviceId\n+   * @param measurementList\n+   * @param plan\n+   * @return\n+   * @throws MetadataException\n+   */\n+  public MeasurementSchema[] getSeriesSchemasAndLock(String deviceId, String[] measurementList, PhysicalPlan plan) throws MetadataException {\n+    MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n+\n+    MNode deviceNode = null;\n+    // 1. get device node\n+    deviceNode = getDeviceNodeWithAutoCreateAndReadLock(deviceId);\n+    // To reduce the String number in memory, set the deviceId from MManager to insertPlan\n+    if (plan instanceof InsertPlan) {\n+      ((InsertPlan) plan).setDeviceId(deviceNode.getFullPath());\n+    } else if (plan instanceof InsertTabletPlan) {\n+      ((InsertTabletPlan) plan).setDeviceId(deviceNode.getFullPath());\n+    } else {\n+      throw new MetadataException(String.format(\n+        \"Only support insert and insertTablets, deviceId[%s], plans [%s]\", deviceId, plan.getOperatorType()));\n+    }\n+\n+    // 2. get schema of each measurement\n+    for (int i = 0; i < measurementList.length; i++) {\n+      try {\n+        // if do not has measurement\n+        boolean isCreated = false;\n+        if (!deviceNode.hasChild(measurementList[i])) {\n+          // could not create it\n+          if (!config.isAutoCreateSchemaEnabled()) {\n+            throw new MetadataException(String.format(\n+              \"Current deviceId[%s] does not contain measurement:%s\", deviceId, measurementList[i]));\n+          }\n+\n+          // create it\n+          Path path = new Path(deviceId, measurementList[i]);\n+          TSDataType dataType = getTypeInLoc(plan, i);\n+\n+          createTimeseries(\n+            path.getFullPath(),\n+            dataType,\n+            getDefaultEncoding(dataType),\n+            TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+            Collections.emptyMap());\n+          isCreated = true;\n+        }\n+\n+        MeasurementMNode measurementNode = (MeasurementMNode) getChild(deviceNode, measurementList[i]);\n+\n+        // check type is match\n+        if (plan instanceof InsertTabletPlan) {\n+          TSDataType trueType = getTypeInLoc(plan, i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d5105b438986ff1e68e38f085ca591db3a5b162"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjkxNjU2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwODo0NTo0OFrOGnfbyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMToyNTozNFrOGn_0gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA2MjY2NQ==", "bodyText": "Is the isCreated needed? If a measurement does not exist, we already throw an exception", "url": "https://github.com/apache/iotdb/pull/1408#discussion_r444062665", "createdAt": "2020-06-23T08:45:48Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -1800,4 +1807,207 @@ private void checkMTreeModified() {\n       }\n     }\n   }\n+\n+  /**\n+   * get schema for device.\n+   * Attention!!!  Only support insertPlan and insertTabletsPlan\n+   * @param deviceId\n+   * @param measurementList\n+   * @param plan\n+   * @return\n+   * @throws MetadataException\n+   */\n+  public MeasurementSchema[] getSeriesSchemasAndLock(String deviceId, String[] measurementList, PhysicalPlan plan) throws MetadataException {\n+    MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n+\n+    MNode deviceNode = null;\n+    // 1. get device node\n+    deviceNode = getDeviceNodeWithAutoCreateAndReadLock(deviceId);\n+    // To reduce the String number in memory, set the deviceId from MManager to insertPlan\n+    if (plan instanceof InsertPlan) {\n+      ((InsertPlan) plan).setDeviceId(deviceNode.getFullPath());\n+    } else if (plan instanceof InsertTabletPlan) {\n+      ((InsertTabletPlan) plan).setDeviceId(deviceNode.getFullPath());\n+    } else {\n+      throw new MetadataException(String.format(\n+        \"Only support insert and insertTablets, deviceId[%s], plans [%s]\", deviceId, plan.getOperatorType()));\n+    }\n+\n+    // 2. get schema of each measurement\n+    for (int i = 0; i < measurementList.length; i++) {\n+      try {\n+        // if do not has measurement\n+        boolean isCreated = false;\n+        if (!deviceNode.hasChild(measurementList[i])) {\n+          // could not create it\n+          if (!config.isAutoCreateSchemaEnabled()) {\n+            throw new MetadataException(String.format(\n+              \"Current deviceId[%s] does not contain measurement:%s\", deviceId, measurementList[i]));\n+          }\n+\n+          // create it\n+          Path path = new Path(deviceId, measurementList[i]);\n+          TSDataType dataType = getTypeInLoc(plan, i);\n+\n+          createTimeseries(\n+            path.getFullPath(),\n+            dataType,\n+            getDefaultEncoding(dataType),\n+            TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+            Collections.emptyMap());\n+          isCreated = true;\n+        }\n+\n+        MeasurementMNode measurementNode = (MeasurementMNode) getChild(deviceNode, measurementList[i]);\n+\n+        // check type is match\n+        if (plan instanceof InsertTabletPlan) {\n+          TSDataType trueType = getTypeInLoc(plan, i);\n+          if (measurementNode.getSchema().getType() != trueType) {\n+            logger.warn(\"Datatype mismatch, Insert measurement {} type {}, metadata tree type {}\",\n+              measurementList[i], trueType, measurementNode.getSchema().getType());\n+            if (!config.isEnablePartialInsert()) {\n+              throw new MetadataException(String.format(\n+                \"Datatype mismatch, Insert measurement %s type %s, metadata tree type %s\",\n+                measurementList[i], measurementNode.getSchema().getType(),\n+                trueType));\n+            } else {\n+              // mark failed measurement\n+              ((InsertTabletPlan) plan).markMeasurementInsertionFailed(i);\n+              continue;\n+            }\n+          }\n+        }\n+\n+        if ((plan instanceof InsertPlan) && isCreated) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d5105b438986ff1e68e38f085ca591db3a5b162"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5MzI4Mw==", "bodyText": "if a measurement exist, but the value is string (like jdbc insert), we need to convert the value to the true type", "url": "https://github.com/apache/iotdb/pull/1408#discussion_r444593283", "createdAt": "2020-06-24T01:25:34Z", "author": {"login": "mychaow"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -1800,4 +1807,207 @@ private void checkMTreeModified() {\n       }\n     }\n   }\n+\n+  /**\n+   * get schema for device.\n+   * Attention!!!  Only support insertPlan and insertTabletsPlan\n+   * @param deviceId\n+   * @param measurementList\n+   * @param plan\n+   * @return\n+   * @throws MetadataException\n+   */\n+  public MeasurementSchema[] getSeriesSchemasAndLock(String deviceId, String[] measurementList, PhysicalPlan plan) throws MetadataException {\n+    MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n+\n+    MNode deviceNode = null;\n+    // 1. get device node\n+    deviceNode = getDeviceNodeWithAutoCreateAndReadLock(deviceId);\n+    // To reduce the String number in memory, set the deviceId from MManager to insertPlan\n+    if (plan instanceof InsertPlan) {\n+      ((InsertPlan) plan).setDeviceId(deviceNode.getFullPath());\n+    } else if (plan instanceof InsertTabletPlan) {\n+      ((InsertTabletPlan) plan).setDeviceId(deviceNode.getFullPath());\n+    } else {\n+      throw new MetadataException(String.format(\n+        \"Only support insert and insertTablets, deviceId[%s], plans [%s]\", deviceId, plan.getOperatorType()));\n+    }\n+\n+    // 2. get schema of each measurement\n+    for (int i = 0; i < measurementList.length; i++) {\n+      try {\n+        // if do not has measurement\n+        boolean isCreated = false;\n+        if (!deviceNode.hasChild(measurementList[i])) {\n+          // could not create it\n+          if (!config.isAutoCreateSchemaEnabled()) {\n+            throw new MetadataException(String.format(\n+              \"Current deviceId[%s] does not contain measurement:%s\", deviceId, measurementList[i]));\n+          }\n+\n+          // create it\n+          Path path = new Path(deviceId, measurementList[i]);\n+          TSDataType dataType = getTypeInLoc(plan, i);\n+\n+          createTimeseries(\n+            path.getFullPath(),\n+            dataType,\n+            getDefaultEncoding(dataType),\n+            TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+            Collections.emptyMap());\n+          isCreated = true;\n+        }\n+\n+        MeasurementMNode measurementNode = (MeasurementMNode) getChild(deviceNode, measurementList[i]);\n+\n+        // check type is match\n+        if (plan instanceof InsertTabletPlan) {\n+          TSDataType trueType = getTypeInLoc(plan, i);\n+          if (measurementNode.getSchema().getType() != trueType) {\n+            logger.warn(\"Datatype mismatch, Insert measurement {} type {}, metadata tree type {}\",\n+              measurementList[i], trueType, measurementNode.getSchema().getType());\n+            if (!config.isEnablePartialInsert()) {\n+              throw new MetadataException(String.format(\n+                \"Datatype mismatch, Insert measurement %s type %s, metadata tree type %s\",\n+                measurementList[i], measurementNode.getSchema().getType(),\n+                trueType));\n+            } else {\n+              // mark failed measurement\n+              ((InsertTabletPlan) plan).markMeasurementInsertionFailed(i);\n+              continue;\n+            }\n+          }\n+        }\n+\n+        if ((plan instanceof InsertPlan) && isCreated) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA2MjY2NQ=="}, "originalCommit": {"oid": "0d5105b438986ff1e68e38f085ca591db3a5b162"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NzAyMzg5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwOToxMzozNlrOGnggjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMTowNzo1OFrOGn_jgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4MDI2OQ==", "bodyText": "remove these two methods and use mManager.getSeriesSchemasAndLock direclty", "url": "https://github.com/apache/iotdb/pull/1408#discussion_r444080269", "createdAt": "2020-06-23T09:13:36Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -907,6 +907,17 @@ public void delete(Path path, long timestamp) throws QueryProcessException {\n     }\n   }\n \n+  protected MeasurementSchema[] getSeriesSchemas(InsertPlan insertPlan)\n+    throws MetadataException {\n+    return mManager.getSeriesSchemasAndLock(insertPlan.getDeviceId(), insertPlan.getMeasurements(), insertPlan);\n+  }\n+\n+  protected MeasurementSchema[] getSeriesSchemas(InsertTabletPlan insertTabletPlan)\n+    throws MetadataException {\n+    return mManager.getSeriesSchemasAndLock(insertTabletPlan.getDeviceId(),\n+      insertTabletPlan.getMeasurements(), insertTabletPlan);\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d5105b438986ff1e68e38f085ca591db3a5b162"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU4ODkyOQ==", "bodyText": "These functions is just for cluster version, cluster version will override this two function.", "url": "https://github.com/apache/iotdb/pull/1408#discussion_r444588929", "createdAt": "2020-06-24T01:07:58Z", "author": {"login": "mychaow"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -907,6 +907,17 @@ public void delete(Path path, long timestamp) throws QueryProcessException {\n     }\n   }\n \n+  protected MeasurementSchema[] getSeriesSchemas(InsertPlan insertPlan)\n+    throws MetadataException {\n+    return mManager.getSeriesSchemasAndLock(insertPlan.getDeviceId(), insertPlan.getMeasurements(), insertPlan);\n+  }\n+\n+  protected MeasurementSchema[] getSeriesSchemas(InsertTabletPlan insertTabletPlan)\n+    throws MetadataException {\n+    return mManager.getSeriesSchemasAndLock(insertTabletPlan.getDeviceId(),\n+      insertTabletPlan.getMeasurements(), insertTabletPlan);\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4MDI2OQ=="}, "originalCommit": {"oid": "0d5105b438986ff1e68e38f085ca591db3a5b162"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTQwMjA1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDowMjo0OVrOGoLhuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzowODo0NVrOGoRUFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NTA4MQ==", "bodyText": "I would suggest you separate the locking part from getSeriesSchemasAndLock and explicitly call it in this method, as it is always better to explicitly put lock and unlock in the same code block.", "url": "https://github.com/apache/iotdb/pull/1408#discussion_r444785081", "createdAt": "2020-06-24T10:02:49Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -915,227 +926,19 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       StorageEngine.getInstance().insert(insertPlan);\n       if (insertPlan.getFailedMeasurements() != null) {\n         throw new StorageEngineException(\n-            \"failed to insert points \" + insertPlan.getFailedMeasurements());\n+            \"failed to insert measurements \" + insertPlan.getFailedMeasurements());\n       }\n     } catch (StorageEngineException | MetadataException e) {\n       throw new QueryProcessException(e);\n-    }\n-  }\n-\n-  protected MeasurementSchema[] getSeriesSchemas(InsertPlan insertPlan) throws MetadataException {\n-    String[] measurementList = insertPlan.getMeasurements();\n-    String deviceId = insertPlan.getDeviceId();\n-    MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n-\n-    MNode node = null;\n-    try {\n-      node = mManager.getDeviceNodeWithAutoCreateAndReadLock(deviceId);\n-      // To reduce the String number in memory, set the deviceId from MManager to insertPlan\n-      insertPlan.setDeviceId(node.getFullPath());\n-    } catch (PathNotExistException e) {\n-      // ignore\n-    }\n-    try {\n-      for (int i = 0; i < measurementList.length; i++) {\n-        try {\n-          schemas[i] = getSeriesSchema(node, insertPlan, i);\n-          if (schemas[i] != null) {\n-            measurementList[i] = schemas[i].getMeasurementId();\n-          }\n-        } catch (MetadataException e) {\n-          logger.warn(\"meet error when check {}.{}, message: {}\", deviceId, measurementList[i],\n-              e.getMessage());\n-          if (enablePartialInsert) {\n-            insertPlan.markMeasurementInsertionFailed(i);\n-          } else {\n-            throw e;\n-          }\n-        }\n-      }\n     } finally {\n-      if (node != null) {\n-        node.readUnlock();\n-      }\n-    }\n-    return schemas;\n-  }\n-\n-  /**\n-   * @param loc index of measurement in insertPlan\n-   */\n-  private MeasurementSchema getSeriesSchema(MNode deviceNode, InsertPlan insertPlan, int loc)\n-      throws MetadataException {\n-    String measurement = insertPlan.getMeasurements()[loc];\n-    String deviceId = insertPlan.getDeviceId();\n-    Object value = insertPlan.getValues()[loc];\n-    boolean isInferType = insertPlan.isInferType();\n-\n-    MeasurementSchema measurementSchema;\n-    if (deviceNode != null && !deviceNode.hasChild(measurement)) {\n-      // devices exists in MTree\n-      if (!IoTDBDescriptor.getInstance().getConfig().isAutoCreateSchemaEnabled()) {\n-        // but measurement not in MTree and cannot auto-create, try the cache\n-        measurementSchema = MManager.getInstance().getSeriesSchema(deviceId, measurement);\n-        if (measurementSchema == null) {\n-          throw new PathNotExistException(deviceId + PATH_SEPARATOR + measurement);\n-        }\n-      } else {\n-        // auto-create\n-        TSDataType dataType = TypeInferenceUtils.getPredictedDataType(value, isInferType);\n-        Path path = new Path(deviceId, measurement);\n-        internalCreateTimeseries(path.toString(), dataType);\n-\n-        MeasurementMNode measurementNode = (MeasurementMNode) mManager\n-            .getChild(deviceNode, measurement);\n-        measurementSchema = measurementNode.getSchema();\n-        if (!isInferType) {\n-          checkType(insertPlan, loc, measurementNode.getSchema().getType());\n-        }\n-      }\n-    } else if (deviceNode != null) {\n-      // device and measurement exists in MTree\n-      MeasurementMNode measurementNode = (MeasurementMNode) MManager.getInstance()\n-          .getChild(deviceNode, measurement);\n-      measurementSchema = measurementNode.getSchema();\n-    } else {\n-      // device in not in MTree, try the cache\n-      measurementSchema = mManager.getSeriesSchema(deviceId, measurement);\n-    }\n-    return measurementSchema;\n-  }\n-\n-  private void checkType(InsertPlan plan, int loc, TSDataType type) {\n-    plan.getTypes()[loc] = type;\n-    try {\n-      switch (type) {\n-        case INT32:\n-          if (!(plan.getValues()[loc] instanceof Integer)) {\n-            plan.getValues()[loc] =\n-                Integer.parseInt(((Binary) plan.getValues()[loc]).getStringValue());\n-          }\n-          break;\n-        case INT64:\n-          if (!(plan.getValues()[loc] instanceof Long)) {\n-            plan.getValues()[loc] =\n-                Long.parseLong(((Binary) plan.getValues()[loc]).getStringValue());\n-          }\n-          break;\n-        case DOUBLE:\n-          if (!(plan.getValues()[loc] instanceof Double)) {\n-            plan.getValues()[loc] =\n-                Double.parseDouble(((Binary) plan.getValues()[loc]).getStringValue());\n-          }\n-          break;\n-        case FLOAT:\n-          if (!(plan.getValues()[loc] instanceof Float)) {\n-            plan.getValues()[loc] =\n-                Float.parseFloat(((Binary) plan.getValues()[loc]).getStringValue());\n-          }\n-          break;\n-        case BOOLEAN:\n-          if (!(plan.getValues()[loc] instanceof Boolean)) {\n-            plan.getValues()[loc] =\n-                Boolean.parseBoolean(((Binary) plan.getValues()[loc]).getStringValue());\n-          }\n-          break;\n-        case TEXT:\n-          // need to do nothing\n-          break;\n-      }\n-    } catch (ClassCastException e) {\n-      logger.error(\"inconsistent type between client and server\");\n-    }\n-  }\n-\n-  /**\n-   * create timeseries with ignore PathAlreadyExistException\n-   */\n-  private void internalCreateTimeseries(String path, TSDataType dataType) throws MetadataException {\n-    try {\n-      mManager.createTimeseries(\n-          path,\n-          dataType,\n-          getDefaultEncoding(dataType),\n-          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-          Collections.emptyMap());\n-    } catch (PathAlreadyExistException e) {\n-      if (logger.isDebugEnabled()) {\n-        logger.debug(\"Ignore PathAlreadyExistException when Concurrent inserting\"\n-            + \" a non-exist time series {}\", path);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Get default encoding by dataType\n-   */\n-  private TSEncoding getDefaultEncoding(TSDataType dataType) {\n-    IoTDBConfig conf = IoTDBDescriptor.getInstance().getConfig();\n-    switch (dataType) {\n-      case BOOLEAN:\n-        return conf.getDefaultBooleanEncoding();\n-      case INT32:\n-        return conf.getDefaultInt32Encoding();\n-      case INT64:\n-        return conf.getDefaultInt64Encoding();\n-      case FLOAT:\n-        return conf.getDefaultFloatEncoding();\n-      case DOUBLE:\n-        return conf.getDefaultDoubleEncoding();\n-      case TEXT:\n-        return conf.getDefaultTextEncoding();\n-      default:\n-        throw new UnSupportedDataTypeException(\n-            String.format(\"Data type %s is not supported.\", dataType.toString()));\n+      mManager.unlockInsert(insertPlan.getDeviceId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd4552a3b49343f60d0edc2ed157da8df5752d6d"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg3OTg5NA==", "bodyText": "ok", "url": "https://github.com/apache/iotdb/pull/1408#discussion_r444879894", "createdAt": "2020-06-24T13:08:45Z", "author": {"login": "mychaow"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -915,227 +926,19 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       StorageEngine.getInstance().insert(insertPlan);\n       if (insertPlan.getFailedMeasurements() != null) {\n         throw new StorageEngineException(\n-            \"failed to insert points \" + insertPlan.getFailedMeasurements());\n+            \"failed to insert measurements \" + insertPlan.getFailedMeasurements());\n       }\n     } catch (StorageEngineException | MetadataException e) {\n       throw new QueryProcessException(e);\n-    }\n-  }\n-\n-  protected MeasurementSchema[] getSeriesSchemas(InsertPlan insertPlan) throws MetadataException {\n-    String[] measurementList = insertPlan.getMeasurements();\n-    String deviceId = insertPlan.getDeviceId();\n-    MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n-\n-    MNode node = null;\n-    try {\n-      node = mManager.getDeviceNodeWithAutoCreateAndReadLock(deviceId);\n-      // To reduce the String number in memory, set the deviceId from MManager to insertPlan\n-      insertPlan.setDeviceId(node.getFullPath());\n-    } catch (PathNotExistException e) {\n-      // ignore\n-    }\n-    try {\n-      for (int i = 0; i < measurementList.length; i++) {\n-        try {\n-          schemas[i] = getSeriesSchema(node, insertPlan, i);\n-          if (schemas[i] != null) {\n-            measurementList[i] = schemas[i].getMeasurementId();\n-          }\n-        } catch (MetadataException e) {\n-          logger.warn(\"meet error when check {}.{}, message: {}\", deviceId, measurementList[i],\n-              e.getMessage());\n-          if (enablePartialInsert) {\n-            insertPlan.markMeasurementInsertionFailed(i);\n-          } else {\n-            throw e;\n-          }\n-        }\n-      }\n     } finally {\n-      if (node != null) {\n-        node.readUnlock();\n-      }\n-    }\n-    return schemas;\n-  }\n-\n-  /**\n-   * @param loc index of measurement in insertPlan\n-   */\n-  private MeasurementSchema getSeriesSchema(MNode deviceNode, InsertPlan insertPlan, int loc)\n-      throws MetadataException {\n-    String measurement = insertPlan.getMeasurements()[loc];\n-    String deviceId = insertPlan.getDeviceId();\n-    Object value = insertPlan.getValues()[loc];\n-    boolean isInferType = insertPlan.isInferType();\n-\n-    MeasurementSchema measurementSchema;\n-    if (deviceNode != null && !deviceNode.hasChild(measurement)) {\n-      // devices exists in MTree\n-      if (!IoTDBDescriptor.getInstance().getConfig().isAutoCreateSchemaEnabled()) {\n-        // but measurement not in MTree and cannot auto-create, try the cache\n-        measurementSchema = MManager.getInstance().getSeriesSchema(deviceId, measurement);\n-        if (measurementSchema == null) {\n-          throw new PathNotExistException(deviceId + PATH_SEPARATOR + measurement);\n-        }\n-      } else {\n-        // auto-create\n-        TSDataType dataType = TypeInferenceUtils.getPredictedDataType(value, isInferType);\n-        Path path = new Path(deviceId, measurement);\n-        internalCreateTimeseries(path.toString(), dataType);\n-\n-        MeasurementMNode measurementNode = (MeasurementMNode) mManager\n-            .getChild(deviceNode, measurement);\n-        measurementSchema = measurementNode.getSchema();\n-        if (!isInferType) {\n-          checkType(insertPlan, loc, measurementNode.getSchema().getType());\n-        }\n-      }\n-    } else if (deviceNode != null) {\n-      // device and measurement exists in MTree\n-      MeasurementMNode measurementNode = (MeasurementMNode) MManager.getInstance()\n-          .getChild(deviceNode, measurement);\n-      measurementSchema = measurementNode.getSchema();\n-    } else {\n-      // device in not in MTree, try the cache\n-      measurementSchema = mManager.getSeriesSchema(deviceId, measurement);\n-    }\n-    return measurementSchema;\n-  }\n-\n-  private void checkType(InsertPlan plan, int loc, TSDataType type) {\n-    plan.getTypes()[loc] = type;\n-    try {\n-      switch (type) {\n-        case INT32:\n-          if (!(plan.getValues()[loc] instanceof Integer)) {\n-            plan.getValues()[loc] =\n-                Integer.parseInt(((Binary) plan.getValues()[loc]).getStringValue());\n-          }\n-          break;\n-        case INT64:\n-          if (!(plan.getValues()[loc] instanceof Long)) {\n-            plan.getValues()[loc] =\n-                Long.parseLong(((Binary) plan.getValues()[loc]).getStringValue());\n-          }\n-          break;\n-        case DOUBLE:\n-          if (!(plan.getValues()[loc] instanceof Double)) {\n-            plan.getValues()[loc] =\n-                Double.parseDouble(((Binary) plan.getValues()[loc]).getStringValue());\n-          }\n-          break;\n-        case FLOAT:\n-          if (!(plan.getValues()[loc] instanceof Float)) {\n-            plan.getValues()[loc] =\n-                Float.parseFloat(((Binary) plan.getValues()[loc]).getStringValue());\n-          }\n-          break;\n-        case BOOLEAN:\n-          if (!(plan.getValues()[loc] instanceof Boolean)) {\n-            plan.getValues()[loc] =\n-                Boolean.parseBoolean(((Binary) plan.getValues()[loc]).getStringValue());\n-          }\n-          break;\n-        case TEXT:\n-          // need to do nothing\n-          break;\n-      }\n-    } catch (ClassCastException e) {\n-      logger.error(\"inconsistent type between client and server\");\n-    }\n-  }\n-\n-  /**\n-   * create timeseries with ignore PathAlreadyExistException\n-   */\n-  private void internalCreateTimeseries(String path, TSDataType dataType) throws MetadataException {\n-    try {\n-      mManager.createTimeseries(\n-          path,\n-          dataType,\n-          getDefaultEncoding(dataType),\n-          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-          Collections.emptyMap());\n-    } catch (PathAlreadyExistException e) {\n-      if (logger.isDebugEnabled()) {\n-        logger.debug(\"Ignore PathAlreadyExistException when Concurrent inserting\"\n-            + \" a non-exist time series {}\", path);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Get default encoding by dataType\n-   */\n-  private TSEncoding getDefaultEncoding(TSDataType dataType) {\n-    IoTDBConfig conf = IoTDBDescriptor.getInstance().getConfig();\n-    switch (dataType) {\n-      case BOOLEAN:\n-        return conf.getDefaultBooleanEncoding();\n-      case INT32:\n-        return conf.getDefaultInt32Encoding();\n-      case INT64:\n-        return conf.getDefaultInt64Encoding();\n-      case FLOAT:\n-        return conf.getDefaultFloatEncoding();\n-      case DOUBLE:\n-        return conf.getDefaultDoubleEncoding();\n-      case TEXT:\n-        return conf.getDefaultTextEncoding();\n-      default:\n-        throw new UnSupportedDataTypeException(\n-            String.format(\"Data type %s is not supported.\", dataType.toString()));\n+      mManager.unlockInsert(insertPlan.getDeviceId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NTA4MQ=="}, "originalCommit": {"oid": "cd4552a3b49343f60d0edc2ed157da8df5752d6d"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MzM1ODY2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/InsertPlan.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQxMjoxODo0MVrOGp89jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQxMjoxODo0MVrOGp89jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY0MzU5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              // if values is String[], isNeedInferType must be true, so we could infer types from them\n          \n          \n            \n              // if isNeedInferType is true, the values must be String[], so we could infer types from them", "url": "https://github.com/apache/iotdb/pull/1408#discussion_r446643599", "createdAt": "2020-06-28T12:18:41Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/InsertPlan.java", "diffHunk": "@@ -57,9 +58,9 @@\n   private TSDataType[] types;\n   private MeasurementSchema[] schemas;\n \n-  // if inferType is false, use the type of values directly\n-  // if inferType is true, values is String[], and infer types from them\n-  private boolean inferType = false;\n+  // if values is String[], isNeedInferType must be true, so we could infer types from them", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be88cfbf8eada8efea5fc4eb756f60d66c2f30fa"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MzM2MTM4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQxMjoyMTo0NVrOGp8-7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQxMjoyMTo0NVrOGp8-7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY0Mzk0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if ((plan instanceof InsertPlan)) {\n          \n          \n            \n                    if ((plan instanceof InsertPlan && ((InsertPlan) plan).isNeedInferType()) {", "url": "https://github.com/apache/iotdb/pull/1408#discussion_r446643948", "createdAt": "2020-06-28T12:21:45Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -1846,4 +1836,219 @@ public void createMTreeSnapshot() {\n       lock.readLock().unlock();\n     }\n   }\n+\n+  /**\n+   * get schema for device.\n+   * Attention!!!  Only support insertPlan and insertTabletsPlan\n+   * @param deviceId\n+   * @param measurementList\n+   * @param plan\n+   * @return\n+   * @throws MetadataException\n+   */\n+  public MeasurementSchema[] getSeriesSchemas(String deviceId, String[] measurementList, PhysicalPlan plan) throws MetadataException {\n+    MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n+\n+    MNode deviceNode = null;\n+    // 1. get device node\n+    deviceNode = getDeviceNode(deviceId);\n+\n+    // 2. get schema of each measurement\n+    for (int i = 0; i < measurementList.length; i++) {\n+      try {\n+        // if do not has measurement\n+        if (!deviceNode.hasChild(measurementList[i])) {\n+          // could not create it\n+          if (!config.isAutoCreateSchemaEnabled()) {\n+            throw new MetadataException(String.format(\n+              \"Current deviceId[%s] does not contain measurement:%s\", deviceId, measurementList[i]));\n+          }\n+\n+          // create it\n+          Path path = new Path(deviceId, measurementList[i]);\n+          TSDataType dataType = getTypeInLoc(plan, i);\n+\n+          createTimeseries(\n+            path.getFullPath(),\n+            dataType,\n+            getDefaultEncoding(dataType),\n+            TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+            Collections.emptyMap());\n+        }\n+\n+        MeasurementMNode measurementNode = (MeasurementMNode) getChild(deviceNode, measurementList[i]);\n+\n+        // check type is match\n+        TSDataType insertDataType = null;\n+        if (plan instanceof InsertPlan) {\n+          if (!((InsertPlan)plan).isNeedInferType()) {\n+            // only when InsertPlan's values is object[], we should check type\n+            insertDataType = getTypeInLoc(plan, i);\n+          } else {\n+            insertDataType = measurementNode.getSchema().getType();\n+          }\n+        } else if (plan instanceof InsertTabletPlan) {\n+          insertDataType = getTypeInLoc(plan, i);\n+        }\n+\n+        if (measurementNode.getSchema().getType() != insertDataType) {\n+          logger.warn(\"DataType mismatch, Insert measurement {} type {}, metadata tree type {}\",\n+            measurementList[i], insertDataType, measurementNode.getSchema().getType());\n+          if (!config.isEnablePartialInsert()) {\n+            throw new MetadataException(String.format(\n+              \"DataType mismatch, Insert measurement %s type %s, metadata tree type %s\",\n+              measurementList[i], insertDataType, measurementNode.getSchema().getType()));\n+          } else {\n+            // mark failed measurement\n+            if (plan instanceof InsertTabletPlan) {\n+              ((InsertTabletPlan) plan).markMeasurementInsertionFailed(i);\n+            } else if (plan instanceof InsertPlan) {\n+              ((InsertPlan) plan).markMeasurementInsertionFailed(i);\n+            }\n+            continue;\n+          }\n+        }\n+\n+        // maybe need to convert value type to the true type\n+        if ((plan instanceof InsertPlan)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be88cfbf8eada8efea5fc4eb756f60d66c2f30fa"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MzM2MTg1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQxMjoyMjoyM1rOGp8_JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQxMjoyMjoyM1rOGp8_JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY0NDAwNQ==", "bodyText": "The String needs to be cast to Binary", "url": "https://github.com/apache/iotdb/pull/1408#discussion_r446644005", "createdAt": "2020-06-28T12:22:23Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -1846,4 +1836,219 @@ public void createMTreeSnapshot() {\n       lock.readLock().unlock();\n     }\n   }\n+\n+  /**\n+   * get schema for device.\n+   * Attention!!!  Only support insertPlan and insertTabletsPlan\n+   * @param deviceId\n+   * @param measurementList\n+   * @param plan\n+   * @return\n+   * @throws MetadataException\n+   */\n+  public MeasurementSchema[] getSeriesSchemas(String deviceId, String[] measurementList, PhysicalPlan plan) throws MetadataException {\n+    MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n+\n+    MNode deviceNode = null;\n+    // 1. get device node\n+    deviceNode = getDeviceNode(deviceId);\n+\n+    // 2. get schema of each measurement\n+    for (int i = 0; i < measurementList.length; i++) {\n+      try {\n+        // if do not has measurement\n+        if (!deviceNode.hasChild(measurementList[i])) {\n+          // could not create it\n+          if (!config.isAutoCreateSchemaEnabled()) {\n+            throw new MetadataException(String.format(\n+              \"Current deviceId[%s] does not contain measurement:%s\", deviceId, measurementList[i]));\n+          }\n+\n+          // create it\n+          Path path = new Path(deviceId, measurementList[i]);\n+          TSDataType dataType = getTypeInLoc(plan, i);\n+\n+          createTimeseries(\n+            path.getFullPath(),\n+            dataType,\n+            getDefaultEncoding(dataType),\n+            TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+            Collections.emptyMap());\n+        }\n+\n+        MeasurementMNode measurementNode = (MeasurementMNode) getChild(deviceNode, measurementList[i]);\n+\n+        // check type is match\n+        TSDataType insertDataType = null;\n+        if (plan instanceof InsertPlan) {\n+          if (!((InsertPlan)plan).isNeedInferType()) {\n+            // only when InsertPlan's values is object[], we should check type\n+            insertDataType = getTypeInLoc(plan, i);\n+          } else {\n+            insertDataType = measurementNode.getSchema().getType();\n+          }\n+        } else if (plan instanceof InsertTabletPlan) {\n+          insertDataType = getTypeInLoc(plan, i);\n+        }\n+\n+        if (measurementNode.getSchema().getType() != insertDataType) {\n+          logger.warn(\"DataType mismatch, Insert measurement {} type {}, metadata tree type {}\",\n+            measurementList[i], insertDataType, measurementNode.getSchema().getType());\n+          if (!config.isEnablePartialInsert()) {\n+            throw new MetadataException(String.format(\n+              \"DataType mismatch, Insert measurement %s type %s, metadata tree type %s\",\n+              measurementList[i], insertDataType, measurementNode.getSchema().getType()));\n+          } else {\n+            // mark failed measurement\n+            if (plan instanceof InsertTabletPlan) {\n+              ((InsertTabletPlan) plan).markMeasurementInsertionFailed(i);\n+            } else if (plan instanceof InsertPlan) {\n+              ((InsertPlan) plan).markMeasurementInsertionFailed(i);\n+            }\n+            continue;\n+          }\n+        }\n+\n+        // maybe need to convert value type to the true type\n+        if ((plan instanceof InsertPlan)) {\n+          changeValueToRealType((InsertPlan) plan, i, measurementNode.getSchema().getType());\n+        }\n+\n+        schemas[i] = measurementNode.getSchema();\n+        if (schemas[i] != null) {\n+          measurementList[i] = schemas[i].getMeasurementId();\n+        }\n+      } catch (MetadataException e) {\n+        logger.warn(\"meet error when check {}.{}, message: {}\", deviceId, measurementList[i],\n+          e.getMessage());\n+        if (config.isEnablePartialInsert()) {\n+          // mark failed measurement\n+          if (plan instanceof InsertPlan) {\n+            ((InsertPlan) plan).markMeasurementInsertionFailed(i);\n+          } else if (plan instanceof InsertTabletPlan) {\n+            ((InsertTabletPlan) plan).markMeasurementInsertionFailed(i);\n+          }\n+        } else {\n+          throw e;\n+        }\n+      }\n+    }\n+    return schemas;\n+  }\n+\n+  private void changeValueToRealType(InsertPlan plan, int loc, TSDataType type) throws MetadataException {\n+    plan.getTypes()[loc] = type;\n+    try {\n+      switch (type) {\n+        case INT32:\n+          if (!(plan.getValues()[loc] instanceof Integer)) {\n+            plan.getValues()[loc] =\n+              Integer.parseInt(String.valueOf(plan.getValues()[loc]));\n+          }\n+          break;\n+        case INT64:\n+          if (!(plan.getValues()[loc] instanceof Long)) {\n+            plan.getValues()[loc] =\n+              Long.parseLong(String.valueOf(plan.getValues()[loc]));\n+          }\n+          break;\n+        case DOUBLE:\n+          if (!(plan.getValues()[loc] instanceof Double)) {\n+            plan.getValues()[loc] =\n+              Double.parseDouble(String.valueOf(plan.getValues()[loc]));\n+          }\n+          break;\n+        case FLOAT:\n+          if (!(plan.getValues()[loc] instanceof Float)) {\n+            plan.getValues()[loc] =\n+              Float.parseFloat(String.valueOf(plan.getValues()[loc]));\n+          }\n+          break;\n+        case BOOLEAN:\n+          if (!(plan.getValues()[loc] instanceof Boolean)) {\n+            plan.getValues()[loc] =\n+              Boolean.parseBoolean(String.valueOf(plan.getValues()[loc]));\n+          }\n+          break;\n+        case TEXT:\n+          // need to do nothing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be88cfbf8eada8efea5fc4eb756f60d66c2f30fa"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MzM2MjQ0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQxMjoyMzowMlrOGp8_cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQxMjoyMzowMlrOGp8_cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY0NDA4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private void changeValueToRealType(InsertPlan plan, int loc, TSDataType type) throws MetadataException {\n          \n          \n            \n              private void changeStringValueToRealType(InsertPlan plan, int loc, TSDataType type) throws MetadataException {", "url": "https://github.com/apache/iotdb/pull/1408#discussion_r446644083", "createdAt": "2020-06-28T12:23:02Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -1846,4 +1836,219 @@ public void createMTreeSnapshot() {\n       lock.readLock().unlock();\n     }\n   }\n+\n+  /**\n+   * get schema for device.\n+   * Attention!!!  Only support insertPlan and insertTabletsPlan\n+   * @param deviceId\n+   * @param measurementList\n+   * @param plan\n+   * @return\n+   * @throws MetadataException\n+   */\n+  public MeasurementSchema[] getSeriesSchemas(String deviceId, String[] measurementList, PhysicalPlan plan) throws MetadataException {\n+    MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n+\n+    MNode deviceNode = null;\n+    // 1. get device node\n+    deviceNode = getDeviceNode(deviceId);\n+\n+    // 2. get schema of each measurement\n+    for (int i = 0; i < measurementList.length; i++) {\n+      try {\n+        // if do not has measurement\n+        if (!deviceNode.hasChild(measurementList[i])) {\n+          // could not create it\n+          if (!config.isAutoCreateSchemaEnabled()) {\n+            throw new MetadataException(String.format(\n+              \"Current deviceId[%s] does not contain measurement:%s\", deviceId, measurementList[i]));\n+          }\n+\n+          // create it\n+          Path path = new Path(deviceId, measurementList[i]);\n+          TSDataType dataType = getTypeInLoc(plan, i);\n+\n+          createTimeseries(\n+            path.getFullPath(),\n+            dataType,\n+            getDefaultEncoding(dataType),\n+            TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+            Collections.emptyMap());\n+        }\n+\n+        MeasurementMNode measurementNode = (MeasurementMNode) getChild(deviceNode, measurementList[i]);\n+\n+        // check type is match\n+        TSDataType insertDataType = null;\n+        if (plan instanceof InsertPlan) {\n+          if (!((InsertPlan)plan).isNeedInferType()) {\n+            // only when InsertPlan's values is object[], we should check type\n+            insertDataType = getTypeInLoc(plan, i);\n+          } else {\n+            insertDataType = measurementNode.getSchema().getType();\n+          }\n+        } else if (plan instanceof InsertTabletPlan) {\n+          insertDataType = getTypeInLoc(plan, i);\n+        }\n+\n+        if (measurementNode.getSchema().getType() != insertDataType) {\n+          logger.warn(\"DataType mismatch, Insert measurement {} type {}, metadata tree type {}\",\n+            measurementList[i], insertDataType, measurementNode.getSchema().getType());\n+          if (!config.isEnablePartialInsert()) {\n+            throw new MetadataException(String.format(\n+              \"DataType mismatch, Insert measurement %s type %s, metadata tree type %s\",\n+              measurementList[i], insertDataType, measurementNode.getSchema().getType()));\n+          } else {\n+            // mark failed measurement\n+            if (plan instanceof InsertTabletPlan) {\n+              ((InsertTabletPlan) plan).markMeasurementInsertionFailed(i);\n+            } else if (plan instanceof InsertPlan) {\n+              ((InsertPlan) plan).markMeasurementInsertionFailed(i);\n+            }\n+            continue;\n+          }\n+        }\n+\n+        // maybe need to convert value type to the true type\n+        if ((plan instanceof InsertPlan)) {\n+          changeValueToRealType((InsertPlan) plan, i, measurementNode.getSchema().getType());\n+        }\n+\n+        schemas[i] = measurementNode.getSchema();\n+        if (schemas[i] != null) {\n+          measurementList[i] = schemas[i].getMeasurementId();\n+        }\n+      } catch (MetadataException e) {\n+        logger.warn(\"meet error when check {}.{}, message: {}\", deviceId, measurementList[i],\n+          e.getMessage());\n+        if (config.isEnablePartialInsert()) {\n+          // mark failed measurement\n+          if (plan instanceof InsertPlan) {\n+            ((InsertPlan) plan).markMeasurementInsertionFailed(i);\n+          } else if (plan instanceof InsertTabletPlan) {\n+            ((InsertTabletPlan) plan).markMeasurementInsertionFailed(i);\n+          }\n+        } else {\n+          throw e;\n+        }\n+      }\n+    }\n+    return schemas;\n+  }\n+\n+  private void changeValueToRealType(InsertPlan plan, int loc, TSDataType type) throws MetadataException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be88cfbf8eada8efea5fc4eb756f60d66c2f30fa"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MzM2Mjk0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQxMjoyMzo0OFrOGp8_uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQxMjozNDowNVrOGp9ELQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY0NDE1NQ==", "bodyText": "Do we need this check? I think only String value need to be inferred.", "url": "https://github.com/apache/iotdb/pull/1408#discussion_r446644155", "createdAt": "2020-06-28T12:23:48Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -1846,4 +1836,219 @@ public void createMTreeSnapshot() {\n       lock.readLock().unlock();\n     }\n   }\n+\n+  /**\n+   * get schema for device.\n+   * Attention!!!  Only support insertPlan and insertTabletsPlan\n+   * @param deviceId\n+   * @param measurementList\n+   * @param plan\n+   * @return\n+   * @throws MetadataException\n+   */\n+  public MeasurementSchema[] getSeriesSchemas(String deviceId, String[] measurementList, PhysicalPlan plan) throws MetadataException {\n+    MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n+\n+    MNode deviceNode = null;\n+    // 1. get device node\n+    deviceNode = getDeviceNode(deviceId);\n+\n+    // 2. get schema of each measurement\n+    for (int i = 0; i < measurementList.length; i++) {\n+      try {\n+        // if do not has measurement\n+        if (!deviceNode.hasChild(measurementList[i])) {\n+          // could not create it\n+          if (!config.isAutoCreateSchemaEnabled()) {\n+            throw new MetadataException(String.format(\n+              \"Current deviceId[%s] does not contain measurement:%s\", deviceId, measurementList[i]));\n+          }\n+\n+          // create it\n+          Path path = new Path(deviceId, measurementList[i]);\n+          TSDataType dataType = getTypeInLoc(plan, i);\n+\n+          createTimeseries(\n+            path.getFullPath(),\n+            dataType,\n+            getDefaultEncoding(dataType),\n+            TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+            Collections.emptyMap());\n+        }\n+\n+        MeasurementMNode measurementNode = (MeasurementMNode) getChild(deviceNode, measurementList[i]);\n+\n+        // check type is match\n+        TSDataType insertDataType = null;\n+        if (plan instanceof InsertPlan) {\n+          if (!((InsertPlan)plan).isNeedInferType()) {\n+            // only when InsertPlan's values is object[], we should check type\n+            insertDataType = getTypeInLoc(plan, i);\n+          } else {\n+            insertDataType = measurementNode.getSchema().getType();\n+          }\n+        } else if (plan instanceof InsertTabletPlan) {\n+          insertDataType = getTypeInLoc(plan, i);\n+        }\n+\n+        if (measurementNode.getSchema().getType() != insertDataType) {\n+          logger.warn(\"DataType mismatch, Insert measurement {} type {}, metadata tree type {}\",\n+            measurementList[i], insertDataType, measurementNode.getSchema().getType());\n+          if (!config.isEnablePartialInsert()) {\n+            throw new MetadataException(String.format(\n+              \"DataType mismatch, Insert measurement %s type %s, metadata tree type %s\",\n+              measurementList[i], insertDataType, measurementNode.getSchema().getType()));\n+          } else {\n+            // mark failed measurement\n+            if (plan instanceof InsertTabletPlan) {\n+              ((InsertTabletPlan) plan).markMeasurementInsertionFailed(i);\n+            } else if (plan instanceof InsertPlan) {\n+              ((InsertPlan) plan).markMeasurementInsertionFailed(i);\n+            }\n+            continue;\n+          }\n+        }\n+\n+        // maybe need to convert value type to the true type\n+        if ((plan instanceof InsertPlan)) {\n+          changeValueToRealType((InsertPlan) plan, i, measurementNode.getSchema().getType());\n+        }\n+\n+        schemas[i] = measurementNode.getSchema();\n+        if (schemas[i] != null) {\n+          measurementList[i] = schemas[i].getMeasurementId();\n+        }\n+      } catch (MetadataException e) {\n+        logger.warn(\"meet error when check {}.{}, message: {}\", deviceId, measurementList[i],\n+          e.getMessage());\n+        if (config.isEnablePartialInsert()) {\n+          // mark failed measurement\n+          if (plan instanceof InsertPlan) {\n+            ((InsertPlan) plan).markMeasurementInsertionFailed(i);\n+          } else if (plan instanceof InsertTabletPlan) {\n+            ((InsertTabletPlan) plan).markMeasurementInsertionFailed(i);\n+          }\n+        } else {\n+          throw e;\n+        }\n+      }\n+    }\n+    return schemas;\n+  }\n+\n+  private void changeValueToRealType(InsertPlan plan, int loc, TSDataType type) throws MetadataException {\n+    plan.getTypes()[loc] = type;\n+    try {\n+      switch (type) {\n+        case INT32:\n+          if (!(plan.getValues()[loc] instanceof Integer)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be88cfbf8eada8efea5fc4eb756f60d66c2f30fa"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY0NTI5Mw==", "bodyText": "yes, could remove this check.", "url": "https://github.com/apache/iotdb/pull/1408#discussion_r446645293", "createdAt": "2020-06-28T12:34:05Z", "author": {"login": "mychaow"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -1846,4 +1836,219 @@ public void createMTreeSnapshot() {\n       lock.readLock().unlock();\n     }\n   }\n+\n+  /**\n+   * get schema for device.\n+   * Attention!!!  Only support insertPlan and insertTabletsPlan\n+   * @param deviceId\n+   * @param measurementList\n+   * @param plan\n+   * @return\n+   * @throws MetadataException\n+   */\n+  public MeasurementSchema[] getSeriesSchemas(String deviceId, String[] measurementList, PhysicalPlan plan) throws MetadataException {\n+    MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n+\n+    MNode deviceNode = null;\n+    // 1. get device node\n+    deviceNode = getDeviceNode(deviceId);\n+\n+    // 2. get schema of each measurement\n+    for (int i = 0; i < measurementList.length; i++) {\n+      try {\n+        // if do not has measurement\n+        if (!deviceNode.hasChild(measurementList[i])) {\n+          // could not create it\n+          if (!config.isAutoCreateSchemaEnabled()) {\n+            throw new MetadataException(String.format(\n+              \"Current deviceId[%s] does not contain measurement:%s\", deviceId, measurementList[i]));\n+          }\n+\n+          // create it\n+          Path path = new Path(deviceId, measurementList[i]);\n+          TSDataType dataType = getTypeInLoc(plan, i);\n+\n+          createTimeseries(\n+            path.getFullPath(),\n+            dataType,\n+            getDefaultEncoding(dataType),\n+            TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+            Collections.emptyMap());\n+        }\n+\n+        MeasurementMNode measurementNode = (MeasurementMNode) getChild(deviceNode, measurementList[i]);\n+\n+        // check type is match\n+        TSDataType insertDataType = null;\n+        if (plan instanceof InsertPlan) {\n+          if (!((InsertPlan)plan).isNeedInferType()) {\n+            // only when InsertPlan's values is object[], we should check type\n+            insertDataType = getTypeInLoc(plan, i);\n+          } else {\n+            insertDataType = measurementNode.getSchema().getType();\n+          }\n+        } else if (plan instanceof InsertTabletPlan) {\n+          insertDataType = getTypeInLoc(plan, i);\n+        }\n+\n+        if (measurementNode.getSchema().getType() != insertDataType) {\n+          logger.warn(\"DataType mismatch, Insert measurement {} type {}, metadata tree type {}\",\n+            measurementList[i], insertDataType, measurementNode.getSchema().getType());\n+          if (!config.isEnablePartialInsert()) {\n+            throw new MetadataException(String.format(\n+              \"DataType mismatch, Insert measurement %s type %s, metadata tree type %s\",\n+              measurementList[i], insertDataType, measurementNode.getSchema().getType()));\n+          } else {\n+            // mark failed measurement\n+            if (plan instanceof InsertTabletPlan) {\n+              ((InsertTabletPlan) plan).markMeasurementInsertionFailed(i);\n+            } else if (plan instanceof InsertPlan) {\n+              ((InsertPlan) plan).markMeasurementInsertionFailed(i);\n+            }\n+            continue;\n+          }\n+        }\n+\n+        // maybe need to convert value type to the true type\n+        if ((plan instanceof InsertPlan)) {\n+          changeValueToRealType((InsertPlan) plan, i, measurementNode.getSchema().getType());\n+        }\n+\n+        schemas[i] = measurementNode.getSchema();\n+        if (schemas[i] != null) {\n+          measurementList[i] = schemas[i].getMeasurementId();\n+        }\n+      } catch (MetadataException e) {\n+        logger.warn(\"meet error when check {}.{}, message: {}\", deviceId, measurementList[i],\n+          e.getMessage());\n+        if (config.isEnablePartialInsert()) {\n+          // mark failed measurement\n+          if (plan instanceof InsertPlan) {\n+            ((InsertPlan) plan).markMeasurementInsertionFailed(i);\n+          } else if (plan instanceof InsertTabletPlan) {\n+            ((InsertTabletPlan) plan).markMeasurementInsertionFailed(i);\n+          }\n+        } else {\n+          throw e;\n+        }\n+      }\n+    }\n+    return schemas;\n+  }\n+\n+  private void changeValueToRealType(InsertPlan plan, int loc, TSDataType type) throws MetadataException {\n+    plan.getTypes()[loc] = type;\n+    try {\n+      switch (type) {\n+        case INT32:\n+          if (!(plan.getValues()[loc] instanceof Integer)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY0NDE1NQ=="}, "originalCommit": {"oid": "be88cfbf8eada8efea5fc4eb756f60d66c2f30fa"}, "originalPosition": 194}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4823, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}