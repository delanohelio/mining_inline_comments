{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1MjA2OTc1", "number": 802, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNTo1MzoyNlrODfyROA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMDoxNTo1NlrODf10bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjU2MDU2OnYy", "diffSide": "RIGHT", "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNTo1MzoyNlrOFpsQAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNTo1MzoyNlrOFpsQAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI2MDkzMQ==", "bodyText": "this name lacks \"chunk\", how about remove this parameter and dynamically adjust in the server", "url": "https://github.com/apache/iotdb/pull/802#discussion_r379260931", "createdAt": "2020-02-14T05:53:26Z", "author": {"login": "qiaojialin"}, "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "diffHunk": "@@ -275,9 +275,9 @@ chunk_merge_point_threshold=20480\n \n # whether to cache meta data(ChunkMetaData and TsFileMetaData) or not.\n meta_data_cache_enable=true\n-# Read memory Allocation Ratio: FileMetaDataCache, ChunkMetaDataCache, and Free Memory Used in Query.\n-# The parameter form is a:b:c, where a, b and c are integers. for example: 1:1:1 , 3:6:10\n-filemeta_chunkmeta_free_memory_proportion=3:6:10\n+# Read memory Allocation Ratio: FileMetaDataCache, ChunkMetaDataCache, ChunkCache and Free Memory Used in Query.\n+# The parameter form is a:b:c:d, where a, b, c and d are integers. for example: 1:1:1:1 , 3:6:10:20\n+filemeta_chunkmeta_free_memory_proportion=3:6:10:20", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7abc72483959b2bb52995105d6f3988c5f6415"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjU2NDc3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/cache/ChunkCache.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNTo1NjowM1rOFpsSdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNTo1NjowM1rOFpsSdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI2MTU1OA==", "bodyText": "I suggest using lock.readLock to replace the readLock field", "url": "https://github.com/apache/iotdb/pull/802#discussion_r379261558", "createdAt": "2020-02-14T05:56:03Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/cache/ChunkCache.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.cache;\n+\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Chunk;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * This class is used to cache <code>Chunk</code> of <code>ChunkMetaData</code> in IoTDB. The caching\n+ * strategy is LRU.\n+ */\n+public class ChunkCache {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(ChunkCache.class);\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final long MEMORY_THRESHOLD_IN_CHUNK_CACHE = config.getAllocateMemoryForChunkCache();\n+  private static boolean cacheEnable = config.isMetaDataCacheEnable();\n+\n+  private final LRULinkedHashMap<ChunkMetaData, Chunk> lruCache;\n+\n+  private AtomicLong cacheHitNum = new AtomicLong();\n+  private AtomicLong cacheRequestNum = new AtomicLong();\n+\n+  private final ReadWriteLock lock = new ReentrantReadWriteLock();\n+  private final Lock readLock = lock.readLock();\n+  private final Lock writeLock = lock.writeLock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7abc72483959b2bb52995105d6f3988c5f6415"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjU3MTIyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/cache/ChunkCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNjowMDo0NVrOFpsWhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNzowMjowNlrOFptMIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI2MjU5Nw==", "bodyText": "why not return the chunk got from cache?", "url": "https://github.com/apache/iotdb/pull/802#discussion_r379262597", "createdAt": "2020-02-14T06:00:45Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/cache/ChunkCache.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.cache;\n+\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Chunk;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * This class is used to cache <code>Chunk</code> of <code>ChunkMetaData</code> in IoTDB. The caching\n+ * strategy is LRU.\n+ */\n+public class ChunkCache {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(ChunkCache.class);\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final long MEMORY_THRESHOLD_IN_CHUNK_CACHE = config.getAllocateMemoryForChunkCache();\n+  private static boolean cacheEnable = config.isMetaDataCacheEnable();\n+\n+  private final LRULinkedHashMap<ChunkMetaData, Chunk> lruCache;\n+\n+  private AtomicLong cacheHitNum = new AtomicLong();\n+  private AtomicLong cacheRequestNum = new AtomicLong();\n+\n+  private final ReadWriteLock lock = new ReentrantReadWriteLock();\n+  private final Lock readLock = lock.readLock();\n+  private final Lock writeLock = lock.writeLock();\n+\n+\n+  private ChunkCache() {\n+    lruCache = new LRULinkedHashMap<ChunkMetaData, Chunk>(MEMORY_THRESHOLD_IN_CHUNK_CACHE, true) {\n+      @Override\n+      protected long calEntrySize(ChunkMetaData key, Chunk value) {\n+        return RamUsageEstimator.sizeOf(value) + RamUsageEstimator.sizeOf(value);\n+      }\n+    };\n+  }\n+\n+  public static ChunkCache getInstance() {\n+    return ChunkCacheHolder.INSTANCE;\n+  }\n+\n+  public Chunk get(ChunkMetaData chunkMetaData, TsFileSequenceReader reader) throws IOException {\n+    if (!cacheEnable) {\n+      Chunk chunk = reader.readMemChunk(chunkMetaData);\n+      return new Chunk(chunk.getHeader(), chunk.getData().duplicate(), chunk.getDeletedAt(), reader.getEndianType());\n+    }\n+\n+    cacheRequestNum.incrementAndGet();\n+\n+    try {\n+      readLock.lock();\n+      if (lruCache.containsKey(chunkMetaData)) {\n+        cacheHitNum.incrementAndGet();\n+        printCacheLog(true);\n+        Chunk chunk = lruCache.get(chunkMetaData);\n+        return new Chunk(chunk.getHeader(), chunk.getData().duplicate(), chunk.getDeletedAt(), reader.getEndianType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7abc72483959b2bb52995105d6f3988c5f6415"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI3NjMyMQ==", "bodyText": "The chunk has a field byte buffer, it should be reused.", "url": "https://github.com/apache/iotdb/pull/802#discussion_r379276321", "createdAt": "2020-02-14T07:02:06Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/cache/ChunkCache.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.cache;\n+\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Chunk;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * This class is used to cache <code>Chunk</code> of <code>ChunkMetaData</code> in IoTDB. The caching\n+ * strategy is LRU.\n+ */\n+public class ChunkCache {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(ChunkCache.class);\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final long MEMORY_THRESHOLD_IN_CHUNK_CACHE = config.getAllocateMemoryForChunkCache();\n+  private static boolean cacheEnable = config.isMetaDataCacheEnable();\n+\n+  private final LRULinkedHashMap<ChunkMetaData, Chunk> lruCache;\n+\n+  private AtomicLong cacheHitNum = new AtomicLong();\n+  private AtomicLong cacheRequestNum = new AtomicLong();\n+\n+  private final ReadWriteLock lock = new ReentrantReadWriteLock();\n+  private final Lock readLock = lock.readLock();\n+  private final Lock writeLock = lock.writeLock();\n+\n+\n+  private ChunkCache() {\n+    lruCache = new LRULinkedHashMap<ChunkMetaData, Chunk>(MEMORY_THRESHOLD_IN_CHUNK_CACHE, true) {\n+      @Override\n+      protected long calEntrySize(ChunkMetaData key, Chunk value) {\n+        return RamUsageEstimator.sizeOf(value) + RamUsageEstimator.sizeOf(value);\n+      }\n+    };\n+  }\n+\n+  public static ChunkCache getInstance() {\n+    return ChunkCacheHolder.INSTANCE;\n+  }\n+\n+  public Chunk get(ChunkMetaData chunkMetaData, TsFileSequenceReader reader) throws IOException {\n+    if (!cacheEnable) {\n+      Chunk chunk = reader.readMemChunk(chunkMetaData);\n+      return new Chunk(chunk.getHeader(), chunk.getData().duplicate(), chunk.getDeletedAt(), reader.getEndianType());\n+    }\n+\n+    cacheRequestNum.incrementAndGet();\n+\n+    try {\n+      readLock.lock();\n+      if (lruCache.containsKey(chunkMetaData)) {\n+        cacheHitNum.incrementAndGet();\n+        printCacheLog(true);\n+        Chunk chunk = lruCache.get(chunkMetaData);\n+        return new Chunk(chunk.getHeader(), chunk.getData().duplicate(), chunk.getDeletedAt(), reader.getEndianType());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI2MjU5Nw=="}, "originalCommit": {"oid": "be7abc72483959b2bb52995105d6f3988c5f6415"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NzExMzI3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/cache/ChunkCache.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMDowNjo1NFrOFpxdzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMTozNTo1NVrOFpz2cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM0NjM4MA==", "bodyText": "why this return valueSize * 2 ?", "url": "https://github.com/apache/iotdb/pull/802#discussion_r379346380", "createdAt": "2020-02-14T10:06:54Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/cache/ChunkCache.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.cache;\n+\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Chunk;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * This class is used to cache <code>Chunk</code> of <code>ChunkMetaData</code> in IoTDB. The caching\n+ * strategy is LRU.\n+ */\n+public class ChunkCache {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(ChunkCache.class);\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final long MEMORY_THRESHOLD_IN_CHUNK_CACHE = config.getAllocateMemoryForChunkCache();\n+  private static boolean cacheEnable = config.isMetaDataCacheEnable();\n+\n+  private final LRULinkedHashMap<ChunkMetaData, Chunk> lruCache;\n+\n+  private AtomicLong cacheHitNum = new AtomicLong();\n+  private AtomicLong cacheRequestNum = new AtomicLong();\n+\n+  private final ReadWriteLock lock = new ReentrantReadWriteLock();\n+  private final Lock readLock = lock.readLock();\n+  private final Lock writeLock = lock.writeLock();\n+\n+\n+  private ChunkCache() {\n+    lruCache = new LRULinkedHashMap<ChunkMetaData, Chunk>(MEMORY_THRESHOLD_IN_CHUNK_CACHE, true) {\n+      @Override\n+      protected long calEntrySize(ChunkMetaData key, Chunk value) {\n+        return RamUsageEstimator.sizeOf(value) + RamUsageEstimator.sizeOf(value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7abc72483959b2bb52995105d6f3988c5f6415"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM4NTQ1OA==", "bodyText": "it's a typo, should be RamUsageEstimator.sizeOf(key) + RamUsageEstimator.sizeOf(value);\nFixed", "url": "https://github.com/apache/iotdb/pull/802#discussion_r379385458", "createdAt": "2020-02-14T11:35:55Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/cache/ChunkCache.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.cache;\n+\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Chunk;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * This class is used to cache <code>Chunk</code> of <code>ChunkMetaData</code> in IoTDB. The caching\n+ * strategy is LRU.\n+ */\n+public class ChunkCache {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(ChunkCache.class);\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final long MEMORY_THRESHOLD_IN_CHUNK_CACHE = config.getAllocateMemoryForChunkCache();\n+  private static boolean cacheEnable = config.isMetaDataCacheEnable();\n+\n+  private final LRULinkedHashMap<ChunkMetaData, Chunk> lruCache;\n+\n+  private AtomicLong cacheHitNum = new AtomicLong();\n+  private AtomicLong cacheRequestNum = new AtomicLong();\n+\n+  private final ReadWriteLock lock = new ReentrantReadWriteLock();\n+  private final Lock readLock = lock.readLock();\n+  private final Lock writeLock = lock.writeLock();\n+\n+\n+  private ChunkCache() {\n+    lruCache = new LRULinkedHashMap<ChunkMetaData, Chunk>(MEMORY_THRESHOLD_IN_CHUNK_CACHE, true) {\n+      @Override\n+      protected long calEntrySize(ChunkMetaData key, Chunk value) {\n+        return RamUsageEstimator.sizeOf(value) + RamUsageEstimator.sizeOf(value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM0NjM4MA=="}, "originalCommit": {"oid": "be7abc72483959b2bb52995105d6f3988c5f6415"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NzEyNzcxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/cache/ChunkCache.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMDoxMToyNlrOFpxmeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMDoxMToyNlrOFpxmeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM0ODYwMg==", "bodyText": "Why not down the lock to readLock directly", "url": "https://github.com/apache/iotdb/pull/802#discussion_r379348602", "createdAt": "2020-02-14T10:11:26Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/cache/ChunkCache.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.cache;\n+\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Chunk;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * This class is used to cache <code>Chunk</code> of <code>ChunkMetaData</code> in IoTDB. The caching\n+ * strategy is LRU.\n+ */\n+public class ChunkCache {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(ChunkCache.class);\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final long MEMORY_THRESHOLD_IN_CHUNK_CACHE = config.getAllocateMemoryForChunkCache();\n+  private static boolean cacheEnable = config.isMetaDataCacheEnable();\n+\n+  private final LRULinkedHashMap<ChunkMetaData, Chunk> lruCache;\n+\n+  private AtomicLong cacheHitNum = new AtomicLong();\n+  private AtomicLong cacheRequestNum = new AtomicLong();\n+\n+  private final ReadWriteLock lock = new ReentrantReadWriteLock();\n+  private final Lock readLock = lock.readLock();\n+  private final Lock writeLock = lock.writeLock();\n+\n+\n+  private ChunkCache() {\n+    lruCache = new LRULinkedHashMap<ChunkMetaData, Chunk>(MEMORY_THRESHOLD_IN_CHUNK_CACHE, true) {\n+      @Override\n+      protected long calEntrySize(ChunkMetaData key, Chunk value) {\n+        return RamUsageEstimator.sizeOf(value) + RamUsageEstimator.sizeOf(value);\n+      }\n+    };\n+  }\n+\n+  public static ChunkCache getInstance() {\n+    return ChunkCacheHolder.INSTANCE;\n+  }\n+\n+  public Chunk get(ChunkMetaData chunkMetaData, TsFileSequenceReader reader) throws IOException {\n+    if (!cacheEnable) {\n+      Chunk chunk = reader.readMemChunk(chunkMetaData);\n+      return new Chunk(chunk.getHeader(), chunk.getData().duplicate(), chunk.getDeletedAt(), reader.getEndianType());\n+    }\n+\n+    cacheRequestNum.incrementAndGet();\n+\n+    try {\n+      readLock.lock();\n+      if (lruCache.containsKey(chunkMetaData)) {\n+        cacheHitNum.incrementAndGet();\n+        printCacheLog(true);\n+        Chunk chunk = lruCache.get(chunkMetaData);\n+        return new Chunk(chunk.getHeader(), chunk.getData().duplicate(), chunk.getDeletedAt(), reader.getEndianType());\n+      }\n+    } finally {\n+      readLock.unlock();\n+    }\n+\n+    writeLock.lock();\n+    if (lruCache.containsKey(chunkMetaData)) {\n+      writeLock.unlock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7abc72483959b2bb52995105d6f3988c5f6415"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NzE0MjIxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/chunk/DiskChunkLoader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMDoxNTo1NlrOFpxvSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMDoxNTo1NlrOFpxvSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM1MDg1OA==", "bodyText": "i think , this method can delete for  interface, neither memChunk nor diskChunk don't need to clear ,and the cache is  LRU", "url": "https://github.com/apache/iotdb/pull/802#discussion_r379350858", "createdAt": "2020-02-14T10:15:56Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/query/reader/chunk/DiskChunkLoader.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.reader.chunk;\n+\n+import org.apache.iotdb.db.engine.cache.ChunkCache;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Chunk;\n+import org.apache.iotdb.tsfile.read.controller.IChunkLoader;\n+\n+import java.io.IOException;\n+\n+public class DiskChunkLoader implements IChunkLoader {\n+\n+  private final TsFileSequenceReader reader;\n+\n+  public DiskChunkLoader(TsFileSequenceReader reader) {\n+    this.reader = reader;\n+  }\n+\n+  @Override\n+  public Chunk getChunk(ChunkMetaData chunkMetaData) throws IOException {\n+    return ChunkCache.getInstance().get(chunkMetaData, reader);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    reader.close();\n+  }\n+\n+  @Override\n+  public void clear() {\n+    // no cache need clear", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7abc72483959b2bb52995105d6f3988c5f6415"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 414, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}