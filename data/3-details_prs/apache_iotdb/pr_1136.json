{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExMzI1MjI3", "number": 1136, "title": "[IOTDB-632]Performance improve for Linear Fill", "bodyText": "This PR is a reimplementation for Linear Fill.\nConsider the Linear Fill function within range [T-before_range, T+after_range].\n\nSearch the \"before_value\" within [T-before_range, T] in a reverse order.\nSearch the \"after_value\" within [T, T+after_range] using aggregation functions.\n\nPerformance Test result:\nIoTDB configuration:\nenable_parameter_adapter=false\ntsfile_size_threshold=1M\nmemtable_size_threshold=1M\nTimeseries and Data preparation:\nsession.createTimeseries(\"root.test.d1.s1\", TSDataType.INT64, TSEncoding.PLAIN, CompressionType.SNAPPY);\nsession.createTimeseries(\"root.test.d1.s2\", TSDataType.INT64, TSEncoding.PLAIN, CompressionType.SNAPPY);\nsession.createTimeseries(\"root.test.d1.s3\", TSDataType.INT64, TSEncoding.PLAIN, CompressionType.SNAPPY);\nsession.createTimeseries(\"root.test.d2.s1\", TSDataType.INT64, TSEncoding.PLAIN, CompressionType.SNAPPY);\nsession.createTimeseries(\"root.test.d2.s2\", TSDataType.INT64, TSEncoding.PLAIN, CompressionType.SNAPPY);\nsession.createTimeseries(\"root.test.d2.s3\", TSDataType.INT64, TSEncoding.PLAIN, CompressionType.SNAPPY);\n\nCase 1: 10000 seq files, 1000 unseq files. 1000 points in each TsFile.\nCase 2: 1000 seq files, 500 unseq files, 1000 points in each TsFile.\nQuery Result:\nQ1:   select s1, s2, s3 from root.test.d1 where time = T_1 Fill(int64[linear])\nTimestamp [T_1] is only covered with seq files.\nQ2:    select s1, s2, s3 from root.test.d1 where time = T_2 Fill(int64[linear])\nTimestamp [T_2] is covered by both seq files and several unseq files.\nBelow is one of the typical query performance result.\nCase 1: 10000 seqFiles  1000 unseq files, 1000 rows in each file.\nMaster Version\nq1: 1696ms, q2: 2943ms\nNew Version\nq1: 38ms, q2: 673ms\nCase 2: 1000 seqFiles  100 unseen files, 1000 rows in each file\nMaster Version:\nq1: 201ms, q2: 577ms\nNew Version:\nq1: 12ms, q2: 72ms", "createdAt": "2020-04-30T10:27:28Z", "url": "https://github.com/apache/iotdb/pull/1136", "merged": true, "mergeCommit": {"oid": "5ce272a4451427c6c5c040118d6924d103e27845"}, "closed": true, "closedAt": "2020-05-07T09:37:06Z", "author": {"login": "wshao08"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABccqYJcgH2gAyNDExMzI1MjI3OjliMWJjNDkyZTAyOTcxNDJkYjQ2ZWI4N2Y1NDdmYjcyYjYwMWQ0MWY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABce5QpfgH2gAyNDExMzI1MjI3OmU3ZjZhZjA4NzRhZGYyNGFkNDU2MmRhYTg5ZjQ5ZDM4MTdkMmIyZDc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9b1bc492e0297142db46eb87f547fb72b601d41f", "author": {"user": {"login": "wshao08", "name": null}}, "url": "https://github.com/apache/iotdb/commit/9b1bc492e0297142db46eb87f547fb72b601d41f", "committedDate": "2020-04-30T10:18:21Z", "message": "reposition fill module"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d591d7cd6af378b832ccf71c55eaa9f8b0bb96f", "author": {"user": {"login": "wshao08", "name": null}}, "url": "https://github.com/apache/iotdb/commit/3d591d7cd6af378b832ccf71c55eaa9f8b0bb96f", "committedDate": "2020-04-30T10:18:35Z", "message": "Re-implement linear fill"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNDUyMDA3", "url": "https://github.com/apache/iotdb/pull/1136#pullrequestreview-403452007", "createdAt": "2020-04-30T12:00:19Z", "commit": {"oid": "3d591d7cd6af378b832ccf71c55eaa9f8b0bb96f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMjowMDoyMFrOGOmGyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMjowMDoyMFrOGOmGyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk1NzU3OA==", "bodyText": "XXX?", "url": "https://github.com/apache/iotdb/pull/1136#discussion_r417957578", "createdAt": "2020-04-30T12:00:20Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/fill/PreviousFill.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.query.executor.fill;\n+\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.RawDataQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.tsfile.file.metadata.TimeseriesMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.filter.factory.FilterFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class PreviousFill extends IFill {\n+\n+  private Path seriesPath;\n+  private QueryContext context;\n+  private long beforeRange;\n+  private Set<String> allSensors;\n+  private Filter timeFilter;\n+\n+  private boolean untilLast;\n+\n+  public PreviousFill(TSDataType dataType, long queryTime, long beforeRange) {\n+    this(dataType, queryTime, beforeRange, false);\n+  }\n+\n+  public PreviousFill(long beforeRange) {\n+    this(beforeRange, false);\n+  }\n+\n+\n+  public PreviousFill(long beforeRange, boolean untilLast) {\n+    this.beforeRange = beforeRange;\n+    this.untilLast = untilLast;\n+  }\n+\n+\n+  public PreviousFill(TSDataType dataType, long queryTime, long beforeRange, boolean untilLast) {\n+    super(dataType, queryTime);\n+    this.beforeRange = beforeRange;\n+    this.untilLast = untilLast;\n+  }\n+\n+  @Override\n+  public IFill copy() {\n+    return new PreviousFill(dataType,  queryTime, beforeRange, untilLast);\n+  }\n+\n+  @Override\n+  void constructFilter() {\n+    Filter lowerBound = beforeRange == -1 ? TimeFilter.gtEq(Long.MIN_VALUE)\n+        : TimeFilter.gtEq(queryTime - beforeRange);\n+    // time in [queryTime - beforeRange, queryTime]\n+    timeFilter = FilterFactory.and(lowerBound, TimeFilter.ltEq(queryTime));\n+  }\n+\n+  public long getBeforeRange() {\n+    return beforeRange;\n+  }\n+\n+  @Override\n+  public void configureFill(\n+      Path path, TSDataType dataType, long queryTime, Set<String> sensors, QueryContext context) {\n+    this.seriesPath = path;\n+    this.dataType = dataType;\n+    this.context = context;\n+    this.queryTime = queryTime;\n+    this.allSensors = sensors;\n+    constructFilter();\n+  }\n+\n+  @Override\n+  public TimeValuePair getFillResult()\n+      throws IOException, QueryProcessException, StorageEngineException {\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, timeFilter);\n+    // update filter by TTL\n+    timeFilter = dataSource.updateFilterUsingTTL(timeFilter);\n+    LastPointReader lastReader = new LastPointReader(\n+        seriesPath, dataType, allSensors, context, dataSource, queryTime, timeFilter);\n+\n+    return lastReader.getTimeseriesLastPointXXX();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d591d7cd6af378b832ccf71c55eaa9f8b0bb96f"}, "originalPosition": 107}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97228086f571be511ddfd07dc74c0abda0babab0", "author": {"user": {"login": "wshao08", "name": null}}, "url": "https://github.com/apache/iotdb/commit/97228086f571be511ddfd07dc74c0abda0babab0", "committedDate": "2020-05-01T08:49:27Z", "message": "rename to readLastPoint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ad2cbe3f95af040202cbb7f7312712517a01f49", "author": {"user": {"login": "wshao08", "name": null}}, "url": "https://github.com/apache/iotdb/commit/0ad2cbe3f95af040202cbb7f7312712517a01f49", "committedDate": "2020-05-06T02:13:50Z", "message": "Merge remote-tracking branch 'upstream/master' into linearFill_refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "413518a90b049219f757596a03ebb556ad96bf58", "author": {"user": {"login": "wshao08", "name": null}}, "url": "https://github.com/apache/iotdb/commit/413518a90b049219f757596a03ebb556ad96bf58", "committedDate": "2020-05-06T04:09:11Z", "message": "Update Linear Fill documentations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2Mzc5OTUz", "url": "https://github.com/apache/iotdb/pull/1136#pullrequestreview-406379953", "createdAt": "2020-05-06T07:57:48Z", "commit": {"oid": "413518a90b049219f757596a03ebb556ad96bf58"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNzo1Nzo0OVrOGRH5gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODowOTowMlrOGRIPJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYwODM4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private TimeValuePair calculatFirstPointAfterQueryTime()\n          \n          \n            \n              private TimeValuePair calculateFirstPointAfterQueryTime()", "url": "https://github.com/apache/iotdb/pull/1136#discussion_r420608387", "createdAt": "2020-05-06T07:57:49Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/fill/LinearFill.java", "diffHunk": "@@ -83,57 +92,80 @@ public IFill copy() {\n   }\n \n   @Override\n-  Filter constructFilter() {\n+  void constructFilter() {\n     Filter lowerBound = beforeRange == -1 ? TimeFilter.gtEq(Long.MIN_VALUE)\n         : TimeFilter.gtEq(queryTime - beforeRange);\n     Filter upperBound = afterRange == -1 ? TimeFilter.ltEq(Long.MAX_VALUE)\n         : TimeFilter.ltEq(queryTime + afterRange);\n     // [queryTIme - beforeRange, queryTime + afterRange]\n-    return FilterFactory.and(lowerBound, upperBound);\n+    beforeFilter = FilterFactory.and(lowerBound, TimeFilter.ltEq(queryTime));\n+    afterFilter = FilterFactory.and(TimeFilter.gtEq(queryTime), upperBound);\n   }\n \n   @Override\n-  public void configureFill(Path path, TSDataType dataType, long queryTime,\n-      Set<String> sensors, QueryContext context)\n-      throws StorageEngineException, QueryProcessException {\n+  public void configureFill(\n+      Path path, TSDataType dataType, long queryTime, Set<String> sensors, QueryContext context) {\n+    this.seriesPath = path;\n     this.dataType = dataType;\n     this.queryTime = queryTime;\n-    Filter timeFilter = constructFilter();\n-    dataReader = new SeriesRawDataBatchReader(path, sensors, dataType, context,\n-        QueryResourceManager.getInstance().getQueryDataSource(path, context, timeFilter),\n-        timeFilter, null, null);\n+    this.context = context;\n+    this.allSensors = sensors;\n+    constructFilter();\n   }\n \n   @Override\n-  public TimeValuePair getFillResult() throws IOException, UnSupportedFillTypeException {\n-    TimeValuePair beforePair = null;\n-    TimeValuePair afterPair = null;\n-    while (batchData.hasCurrent() || dataReader.hasNextBatch()) {\n-      if (!batchData.hasCurrent() && dataReader.hasNextBatch()) {\n-        batchData = dataReader.nextBatch();\n-      }\n-      afterPair = new TimeValuePair(batchData.currentTime(), batchData.currentTsPrimitiveType());\n-      batchData.next();\n-      if (afterPair.getTimestamp() <= queryTime) {\n-        beforePair = afterPair;\n-      } else {\n-        break;\n-      }\n-    }\n+  public TimeValuePair getFillResult()\n+      throws IOException, QueryProcessException, StorageEngineException {\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, beforeFilter);\n+    LastPointReader lastReader =\n+        new LastPointReader(seriesPath, dataType, allSensors, context, dataSource, queryTime, beforeFilter);\n+\n+    TimeValuePair beforePair = lastReader.readLastPoint();\n+    TimeValuePair afterPair = calculatFirstPointAfterQueryTime();\n \n     // no before data or has data on the query timestamp\n-    if (beforePair == null || beforePair.getTimestamp() == queryTime) {\n+    if (beforePair.getValue() == null || beforePair.getTimestamp() == queryTime) {\n       return beforePair;\n     }\n \n     // on after data or after data is out of range\n-    if (afterPair.getTimestamp() < queryTime || (afterRange != -1 && afterPair.getTimestamp() > queryTime + afterRange)) {\n+    if (afterPair.getValue() == null || afterPair.getTimestamp() < queryTime ||\n+        (afterRange != -1 && afterPair.getTimestamp() > queryTime + afterRange)) {\n       return new TimeValuePair(queryTime, null);\n     }\n \n     return average(beforePair, afterPair);\n   }\n \n+  private TimeValuePair calculatFirstPointAfterQueryTime()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413518a90b049219f757596a03ebb556ad96bf58"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYwOTMyMg==", "bodyText": "This is not needed, you could directly construct AggregateResult using dataType.", "url": "https://github.com/apache/iotdb/pull/1136#discussion_r420609322", "createdAt": "2020-05-06T07:59:38Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/fill/LinearFill.java", "diffHunk": "@@ -83,57 +92,80 @@ public IFill copy() {\n   }\n \n   @Override\n-  Filter constructFilter() {\n+  void constructFilter() {\n     Filter lowerBound = beforeRange == -1 ? TimeFilter.gtEq(Long.MIN_VALUE)\n         : TimeFilter.gtEq(queryTime - beforeRange);\n     Filter upperBound = afterRange == -1 ? TimeFilter.ltEq(Long.MAX_VALUE)\n         : TimeFilter.ltEq(queryTime + afterRange);\n     // [queryTIme - beforeRange, queryTime + afterRange]\n-    return FilterFactory.and(lowerBound, upperBound);\n+    beforeFilter = FilterFactory.and(lowerBound, TimeFilter.ltEq(queryTime));\n+    afterFilter = FilterFactory.and(TimeFilter.gtEq(queryTime), upperBound);\n   }\n \n   @Override\n-  public void configureFill(Path path, TSDataType dataType, long queryTime,\n-      Set<String> sensors, QueryContext context)\n-      throws StorageEngineException, QueryProcessException {\n+  public void configureFill(\n+      Path path, TSDataType dataType, long queryTime, Set<String> sensors, QueryContext context) {\n+    this.seriesPath = path;\n     this.dataType = dataType;\n     this.queryTime = queryTime;\n-    Filter timeFilter = constructFilter();\n-    dataReader = new SeriesRawDataBatchReader(path, sensors, dataType, context,\n-        QueryResourceManager.getInstance().getQueryDataSource(path, context, timeFilter),\n-        timeFilter, null, null);\n+    this.context = context;\n+    this.allSensors = sensors;\n+    constructFilter();\n   }\n \n   @Override\n-  public TimeValuePair getFillResult() throws IOException, UnSupportedFillTypeException {\n-    TimeValuePair beforePair = null;\n-    TimeValuePair afterPair = null;\n-    while (batchData.hasCurrent() || dataReader.hasNextBatch()) {\n-      if (!batchData.hasCurrent() && dataReader.hasNextBatch()) {\n-        batchData = dataReader.nextBatch();\n-      }\n-      afterPair = new TimeValuePair(batchData.currentTime(), batchData.currentTsPrimitiveType());\n-      batchData.next();\n-      if (afterPair.getTimestamp() <= queryTime) {\n-        beforePair = afterPair;\n-      } else {\n-        break;\n-      }\n-    }\n+  public TimeValuePair getFillResult()\n+      throws IOException, QueryProcessException, StorageEngineException {\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, beforeFilter);\n+    LastPointReader lastReader =\n+        new LastPointReader(seriesPath, dataType, allSensors, context, dataSource, queryTime, beforeFilter);\n+\n+    TimeValuePair beforePair = lastReader.readLastPoint();\n+    TimeValuePair afterPair = calculatFirstPointAfterQueryTime();\n \n     // no before data or has data on the query timestamp\n-    if (beforePair == null || beforePair.getTimestamp() == queryTime) {\n+    if (beforePair.getValue() == null || beforePair.getTimestamp() == queryTime) {\n       return beforePair;\n     }\n \n     // on after data or after data is out of range\n-    if (afterPair.getTimestamp() < queryTime || (afterRange != -1 && afterPair.getTimestamp() > queryTime + afterRange)) {\n+    if (afterPair.getValue() == null || afterPair.getTimestamp() < queryTime ||\n+        (afterRange != -1 && afterPair.getTimestamp() > queryTime + afterRange)) {\n       return new TimeValuePair(queryTime, null);\n     }\n \n     return average(beforePair, afterPair);\n   }\n \n+  private TimeValuePair calculatFirstPointAfterQueryTime()\n+      throws IOException, StorageEngineException, QueryProcessException {\n+    TimeValuePair result = new TimeValuePair(0, null);\n+    List<String> aggregations = new ArrayList<>();\n+    aggregations.add(AggregationType.MIN_TIME.toString());\n+    aggregations.add(AggregationType.FIRST_VALUE.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413518a90b049219f757596a03ebb556ad96bf58"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYxMzkyNg==", "bodyText": "add the LinearFill in UserGuide, explain how we fill when beforePair or afterPair is null", "url": "https://github.com/apache/iotdb/pull/1136#discussion_r420613926", "createdAt": "2020-05-06T08:09:02Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/fill/LinearFill.java", "diffHunk": "@@ -83,57 +92,80 @@ public IFill copy() {\n   }\n \n   @Override\n-  Filter constructFilter() {\n+  void constructFilter() {\n     Filter lowerBound = beforeRange == -1 ? TimeFilter.gtEq(Long.MIN_VALUE)\n         : TimeFilter.gtEq(queryTime - beforeRange);\n     Filter upperBound = afterRange == -1 ? TimeFilter.ltEq(Long.MAX_VALUE)\n         : TimeFilter.ltEq(queryTime + afterRange);\n     // [queryTIme - beforeRange, queryTime + afterRange]\n-    return FilterFactory.and(lowerBound, upperBound);\n+    beforeFilter = FilterFactory.and(lowerBound, TimeFilter.ltEq(queryTime));\n+    afterFilter = FilterFactory.and(TimeFilter.gtEq(queryTime), upperBound);\n   }\n \n   @Override\n-  public void configureFill(Path path, TSDataType dataType, long queryTime,\n-      Set<String> sensors, QueryContext context)\n-      throws StorageEngineException, QueryProcessException {\n+  public void configureFill(\n+      Path path, TSDataType dataType, long queryTime, Set<String> sensors, QueryContext context) {\n+    this.seriesPath = path;\n     this.dataType = dataType;\n     this.queryTime = queryTime;\n-    Filter timeFilter = constructFilter();\n-    dataReader = new SeriesRawDataBatchReader(path, sensors, dataType, context,\n-        QueryResourceManager.getInstance().getQueryDataSource(path, context, timeFilter),\n-        timeFilter, null, null);\n+    this.context = context;\n+    this.allSensors = sensors;\n+    constructFilter();\n   }\n \n   @Override\n-  public TimeValuePair getFillResult() throws IOException, UnSupportedFillTypeException {\n-    TimeValuePair beforePair = null;\n-    TimeValuePair afterPair = null;\n-    while (batchData.hasCurrent() || dataReader.hasNextBatch()) {\n-      if (!batchData.hasCurrent() && dataReader.hasNextBatch()) {\n-        batchData = dataReader.nextBatch();\n-      }\n-      afterPair = new TimeValuePair(batchData.currentTime(), batchData.currentTsPrimitiveType());\n-      batchData.next();\n-      if (afterPair.getTimestamp() <= queryTime) {\n-        beforePair = afterPair;\n-      } else {\n-        break;\n-      }\n-    }\n+  public TimeValuePair getFillResult()\n+      throws IOException, QueryProcessException, StorageEngineException {\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, beforeFilter);\n+    LastPointReader lastReader =\n+        new LastPointReader(seriesPath, dataType, allSensors, context, dataSource, queryTime, beforeFilter);\n+\n+    TimeValuePair beforePair = lastReader.readLastPoint();\n+    TimeValuePair afterPair = calculatFirstPointAfterQueryTime();\n \n     // no before data or has data on the query timestamp\n-    if (beforePair == null || beforePair.getTimestamp() == queryTime) {\n+    if (beforePair.getValue() == null || beforePair.getTimestamp() == queryTime) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413518a90b049219f757596a03ebb556ad96bf58"}, "originalPosition": 111}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39fea6c8aa256bfa9dd136c9bc22f080fd9eb662", "author": {"user": {"login": "wshao08", "name": null}}, "url": "https://github.com/apache/iotdb/commit/39fea6c8aa256bfa9dd136c9bc22f080fd9eb662", "committedDate": "2020-05-06T16:30:37Z", "message": "Update user guide for linear fill"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d418649ea6ccd18ef3aa75d27484756da35e1d01", "author": {"user": {"login": "wshao08", "name": null}}, "url": "https://github.com/apache/iotdb/commit/d418649ea6ccd18ef3aa75d27484756da35e1d01", "committedDate": "2020-05-07T01:43:03Z", "message": "Delete unused imports"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MTAwOTkx", "url": "https://github.com/apache/iotdb/pull/1136#pullrequestreview-407100991", "createdAt": "2020-05-07T01:55:57Z", "commit": {"oid": "d418649ea6ccd18ef3aa75d27484756da35e1d01"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMTo1NTo1N1rOGRrpEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMTo1NTo1N1rOGRrpEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5NDAwMw==", "bodyText": "T\u4e4b\u540e\u7684\u6700\u65e9\u65f6\u95f4\u6233\u5bf9\u5e94\u7684\u503c", "url": "https://github.com/apache/iotdb/pull/1136#discussion_r421194003", "createdAt": "2020-05-07T01:55:57Z", "author": {"login": "JackieTien97"}, "path": "docs/zh/SystemDesign/5-DataQuery/9-FillFunction.md", "diffHunk": "@@ -146,3 +146,14 @@ public TimeValuePair getFillResult() throws IOException {\n     return lastPointResult;\n }\n ```\n+\n+# Linear \u586b\u5145\n+\n+\u5bf9\u4e8eT\u65f6\u95f4\u7684 Linear Fill \u7ebf\u6027\u586b\u5145\u503c\u662f\u7531\u8be5\u65f6\u95f4\u5e8f\u5217\u7684\u4e24\u4e2a\u76f8\u5173\u503c\u505a\u7ebf\u6027\u62df\u5408\u5f97\u5230\u7684\uff1aT\u4e4b\u524d\u7684\u6700\u8fd1\u65f6\u95f4\u6233\u5bf9\u5e94\u7684\u503c\uff0cT\u4e4b\u540e\u7684\u6700\u8fd1\u65f6\u95f4\u6233\u5bf9\u5e94\u7684\u503c\u3002", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d418649ea6ccd18ef3aa75d27484756da35e1d01"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "227dbddcf434478a090397f108103824e602f22f", "author": {"user": {"login": "wshao08", "name": null}}, "url": "https://github.com/apache/iotdb/commit/227dbddcf434478a090397f108103824e602f22f", "committedDate": "2020-05-07T07:54:38Z", "message": "Fix a null before_pair bug and add tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MjM1NzMx", "url": "https://github.com/apache/iotdb/pull/1136#pullrequestreview-407235731", "createdAt": "2020-05-07T08:01:11Z", "commit": {"oid": "227dbddcf434478a090397f108103824e602f22f"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwODowMToxMVrOGRy8qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwODowMTo1NFrOGRy-Yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMxMzcwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                AggregateResult minTimeResult =\n          \n          \n            \n                    AggregateResultFactory.getAggrResultByName(AggregationType.MIN_TIME.toString(), dataType);\n          \n          \n            \n                AggregateResult minTimeResult = new MinTimeAggrResult(dataType);", "url": "https://github.com/apache/iotdb/pull/1136#discussion_r421313706", "createdAt": "2020-05-07T08:01:11Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/fill/LinearFill.java", "diffHunk": "@@ -83,57 +89,79 @@ public IFill copy() {\n   }\n \n   @Override\n-  Filter constructFilter() {\n+  void constructFilter() {\n     Filter lowerBound = beforeRange == -1 ? TimeFilter.gtEq(Long.MIN_VALUE)\n         : TimeFilter.gtEq(queryTime - beforeRange);\n     Filter upperBound = afterRange == -1 ? TimeFilter.ltEq(Long.MAX_VALUE)\n         : TimeFilter.ltEq(queryTime + afterRange);\n     // [queryTIme - beforeRange, queryTime + afterRange]\n-    return FilterFactory.and(lowerBound, upperBound);\n+    beforeFilter = FilterFactory.and(lowerBound, TimeFilter.ltEq(queryTime));\n+    afterFilter = FilterFactory.and(TimeFilter.gtEq(queryTime), upperBound);\n   }\n \n   @Override\n-  public void configureFill(Path path, TSDataType dataType, long queryTime,\n-      Set<String> sensors, QueryContext context)\n-      throws StorageEngineException, QueryProcessException {\n+  public void configureFill(\n+      Path path, TSDataType dataType, long queryTime, Set<String> sensors, QueryContext context) {\n+    this.seriesPath = path;\n     this.dataType = dataType;\n     this.queryTime = queryTime;\n-    Filter timeFilter = constructFilter();\n-    dataReader = new SeriesRawDataBatchReader(path, sensors, dataType, context,\n-        QueryResourceManager.getInstance().getQueryDataSource(path, context, timeFilter),\n-        timeFilter, null, null);\n+    this.context = context;\n+    this.allSensors = sensors;\n+    constructFilter();\n   }\n \n   @Override\n-  public TimeValuePair getFillResult() throws IOException, UnSupportedFillTypeException {\n-    TimeValuePair beforePair = null;\n-    TimeValuePair afterPair = null;\n-    while (batchData.hasCurrent() || dataReader.hasNextBatch()) {\n-      if (!batchData.hasCurrent() && dataReader.hasNextBatch()) {\n-        batchData = dataReader.nextBatch();\n-      }\n-      afterPair = new TimeValuePair(batchData.currentTime(), batchData.currentTsPrimitiveType());\n-      batchData.next();\n-      if (afterPair.getTimestamp() <= queryTime) {\n-        beforePair = afterPair;\n-      } else {\n-        break;\n-      }\n-    }\n+  public TimeValuePair getFillResult()\n+      throws IOException, QueryProcessException, StorageEngineException {\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, beforeFilter);\n+    LastPointReader lastReader =\n+        new LastPointReader(seriesPath, dataType, allSensors, context, dataSource, queryTime, beforeFilter);\n+\n+    TimeValuePair beforePair = lastReader.readLastPoint();\n+    TimeValuePair afterPair = calculateFirstPointAfterQueryTime();\n \n     // no before data or has data on the query timestamp\n-    if (beforePair == null || beforePair.getTimestamp() == queryTime) {\n+    if (beforePair.getValue() == null || beforePair.getTimestamp() == queryTime) {\n+      beforePair.setTimestamp(queryTime);\n       return beforePair;\n     }\n \n     // on after data or after data is out of range\n-    if (afterPair.getTimestamp() < queryTime || (afterRange != -1 && afterPair.getTimestamp() > queryTime + afterRange)) {\n+    if (afterPair.getValue() == null || afterPair.getTimestamp() < queryTime ||\n+        (afterRange != -1 && afterPair.getTimestamp() > queryTime + afterRange)) {\n       return new TimeValuePair(queryTime, null);\n     }\n \n     return average(beforePair, afterPair);\n   }\n \n+  private TimeValuePair calculateFirstPointAfterQueryTime()\n+      throws IOException, StorageEngineException, QueryProcessException {\n+    TimeValuePair result = new TimeValuePair(0, null);\n+\n+    List<AggregateResult> aggregateResultList = new ArrayList<>();\n+    AggregateResult minTimeResult =\n+        AggregateResultFactory.getAggrResultByName(AggregationType.MIN_TIME.toString(), dataType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "227dbddcf434478a090397f108103824e602f22f"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMxNDE0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                AggregateResult firstValueResult =\n          \n          \n            \n                    AggregateResultFactory.getAggrResultByName(\n          \n          \n            \n                        AggregationType.FIRST_VALUE.toString(), dataType);\n          \n          \n            \n                AggregateResult firstValueResult = new FirstValueAggrResult(dataType);", "url": "https://github.com/apache/iotdb/pull/1136#discussion_r421314146", "createdAt": "2020-05-07T08:01:54Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/fill/LinearFill.java", "diffHunk": "@@ -83,57 +89,79 @@ public IFill copy() {\n   }\n \n   @Override\n-  Filter constructFilter() {\n+  void constructFilter() {\n     Filter lowerBound = beforeRange == -1 ? TimeFilter.gtEq(Long.MIN_VALUE)\n         : TimeFilter.gtEq(queryTime - beforeRange);\n     Filter upperBound = afterRange == -1 ? TimeFilter.ltEq(Long.MAX_VALUE)\n         : TimeFilter.ltEq(queryTime + afterRange);\n     // [queryTIme - beforeRange, queryTime + afterRange]\n-    return FilterFactory.and(lowerBound, upperBound);\n+    beforeFilter = FilterFactory.and(lowerBound, TimeFilter.ltEq(queryTime));\n+    afterFilter = FilterFactory.and(TimeFilter.gtEq(queryTime), upperBound);\n   }\n \n   @Override\n-  public void configureFill(Path path, TSDataType dataType, long queryTime,\n-      Set<String> sensors, QueryContext context)\n-      throws StorageEngineException, QueryProcessException {\n+  public void configureFill(\n+      Path path, TSDataType dataType, long queryTime, Set<String> sensors, QueryContext context) {\n+    this.seriesPath = path;\n     this.dataType = dataType;\n     this.queryTime = queryTime;\n-    Filter timeFilter = constructFilter();\n-    dataReader = new SeriesRawDataBatchReader(path, sensors, dataType, context,\n-        QueryResourceManager.getInstance().getQueryDataSource(path, context, timeFilter),\n-        timeFilter, null, null);\n+    this.context = context;\n+    this.allSensors = sensors;\n+    constructFilter();\n   }\n \n   @Override\n-  public TimeValuePair getFillResult() throws IOException, UnSupportedFillTypeException {\n-    TimeValuePair beforePair = null;\n-    TimeValuePair afterPair = null;\n-    while (batchData.hasCurrent() || dataReader.hasNextBatch()) {\n-      if (!batchData.hasCurrent() && dataReader.hasNextBatch()) {\n-        batchData = dataReader.nextBatch();\n-      }\n-      afterPair = new TimeValuePair(batchData.currentTime(), batchData.currentTsPrimitiveType());\n-      batchData.next();\n-      if (afterPair.getTimestamp() <= queryTime) {\n-        beforePair = afterPair;\n-      } else {\n-        break;\n-      }\n-    }\n+  public TimeValuePair getFillResult()\n+      throws IOException, QueryProcessException, StorageEngineException {\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, beforeFilter);\n+    LastPointReader lastReader =\n+        new LastPointReader(seriesPath, dataType, allSensors, context, dataSource, queryTime, beforeFilter);\n+\n+    TimeValuePair beforePair = lastReader.readLastPoint();\n+    TimeValuePair afterPair = calculateFirstPointAfterQueryTime();\n \n     // no before data or has data on the query timestamp\n-    if (beforePair == null || beforePair.getTimestamp() == queryTime) {\n+    if (beforePair.getValue() == null || beforePair.getTimestamp() == queryTime) {\n+      beforePair.setTimestamp(queryTime);\n       return beforePair;\n     }\n \n     // on after data or after data is out of range\n-    if (afterPair.getTimestamp() < queryTime || (afterRange != -1 && afterPair.getTimestamp() > queryTime + afterRange)) {\n+    if (afterPair.getValue() == null || afterPair.getTimestamp() < queryTime ||\n+        (afterRange != -1 && afterPair.getTimestamp() > queryTime + afterRange)) {\n       return new TimeValuePair(queryTime, null);\n     }\n \n     return average(beforePair, afterPair);\n   }\n \n+  private TimeValuePair calculateFirstPointAfterQueryTime()\n+      throws IOException, StorageEngineException, QueryProcessException {\n+    TimeValuePair result = new TimeValuePair(0, null);\n+\n+    List<AggregateResult> aggregateResultList = new ArrayList<>();\n+    AggregateResult minTimeResult =\n+        AggregateResultFactory.getAggrResultByName(AggregationType.MIN_TIME.toString(), dataType);\n+    AggregateResult firstValueResult =\n+        AggregateResultFactory.getAggrResultByName(\n+            AggregationType.FIRST_VALUE.toString(), dataType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "227dbddcf434478a090397f108103824e602f22f"}, "originalPosition": 141}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e21bf1c2b646a3672995fcd86e603e4afda21e6a", "author": {"user": {"login": "wshao08", "name": null}}, "url": "https://github.com/apache/iotdb/commit/e21bf1c2b646a3672995fcd86e603e4afda21e6a", "committedDate": "2020-05-07T08:06:41Z", "message": "Update server/src/main/java/org/apache/iotdb/db/query/executor/fill/LinearFill.java\n\nCo-authored-by: Jialin Qiao <qjl16@mails.tsinghua.edu.cn>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ced502c9acfc0aa2519df0a5a3922030dd707e93", "author": {"user": {"login": "wshao08", "name": null}}, "url": "https://github.com/apache/iotdb/commit/ced502c9acfc0aa2519df0a5a3922030dd707e93", "committedDate": "2020-05-07T08:07:02Z", "message": "Update server/src/main/java/org/apache/iotdb/db/query/executor/fill/LinearFill.java\n\nCo-authored-by: Jialin Qiao <qjl16@mails.tsinghua.edu.cn>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7f6af0874adf24ad4562daa89f49d3817d2b2d7", "author": {"user": {"login": "wshao08", "name": null}}, "url": "https://github.com/apache/iotdb/commit/e7f6af0874adf24ad4562daa89f49d3817d2b2d7", "committedDate": "2020-05-07T08:46:35Z", "message": "Add missing imports"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3916, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}