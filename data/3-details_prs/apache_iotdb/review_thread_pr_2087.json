{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0Mzg3NDcy", "number": 2087, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwODowOToyNlrOE7bfDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwOTozMTowN1rOE9jMXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNzUxNzU2OnYy", "diffSide": "RIGHT", "path": "antlr/src/main/antlr4/org/apache/iotdb/db/qp/strategy/SqlBase.g4", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwODowOToyNlrOH3EtFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMDoxMjoxNVrOH4Gv8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUxMDgwNQ==", "bodyText": "Maybe you need to add some parameter name of sdt?\nAnd Please add some example in the docs.", "url": "https://github.com/apache/iotdb/pull/2087#discussion_r527510805", "createdAt": "2020-11-20T08:09:26Z", "author": {"login": "mychaow"}, "path": "antlr/src/main/antlr4/org/apache/iotdb/db/qp/strategy/SqlBase.g4", "diffHunk": "@@ -641,6 +640,7 @@ dateFormat\n constant\n     : dateExpression\n     | NaN\n+    | SDT", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62253ce3538e3a3b441639b3e2bea0cebd8a1ef0"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU5Mjg4MQ==", "bodyText": "if SDT is a constant or propertyValue, I don't think it needs a keyword.", "url": "https://github.com/apache/iotdb/pull/2087#discussion_r528592881", "createdAt": "2020-11-23T10:12:15Z", "author": {"login": "Genius-pig"}, "path": "antlr/src/main/antlr4/org/apache/iotdb/db/qp/strategy/SqlBase.g4", "diffHunk": "@@ -641,6 +640,7 @@ dateFormat\n constant\n     : dateExpression\n     | NaN\n+    | SDT", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUxMDgwNQ=="}, "originalCommit": {"oid": "62253ce3538e3a3b441639b3e2bea0cebd8a1ef0"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNzUzNjkxOnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/write/chunk/ChunkWriterImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwODoxNDo1N1rOH3E4OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwODoxNDo1N1rOH3E4OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUxMzY1Nw==", "bodyText": "cd is too simple", "url": "https://github.com/apache/iotdb/pull/2087#discussion_r527513657", "createdAt": "2020-11-20T08:14:57Z", "author": {"login": "mychaow"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/write/chunk/ChunkWriterImpl.java", "diffHunk": "@@ -97,18 +109,93 @@ public ChunkWriterImpl(MeasurementSchema schema) {\n     this.pageWriter = new PageWriter(measurementSchema);\n     this.pageWriter.setTimeEncoder(measurementSchema.getTimeEncoder());\n     this.pageWriter.setValueEncoder(measurementSchema.getValueEncoder());\n+\n+    //check if the measurement schema uses SDT\n+    checkSdtEncoding();\n+  }\n+\n+  public ChunkWriterImpl(MeasurementSchema schema, boolean isMerging) {\n+    this(schema);\n+    this.isMerging = isMerging;\n+  }\n+\n+  private void checkSdtEncoding() {\n+    if (measurementSchema.getProps() != null && !isMerging) {\n+      for (Map.Entry<String, String> entry : measurementSchema.getProps().entrySet()) {\n+        //check if is sdt encoding\n+        if (entry.getKey().toLowerCase().equals(\"loss\") && entry.getValue().toLowerCase()\n+            .equals(\"sdt\")) {\n+          isSdtEncoding = true;\n+          sdtEncoder = new SdtEncoder();\n+        }\n+\n+        //set compression deviation\n+        else if (isSdtEncoding &&\n+            entry.getKey().toLowerCase().equals(\"cd\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62253ce3538e3a3b441639b3e2bea0cebd8a1ef0"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNzY1Mzk4OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/write/chunk/ChunkWriterImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwODo0ODoxOFrOH3F96g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwODo0ODoxOFrOH3F96g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUzMTQ5OA==", "bodyText": "so, how about double[] ?", "url": "https://github.com/apache/iotdb/pull/2087#discussion_r527531498", "createdAt": "2020-11-20T08:48:18Z", "author": {"login": "mychaow"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/write/chunk/ChunkWriterImpl.java", "diffHunk": "@@ -155,6 +266,12 @@ public void write(long[] timestamps, boolean[] values, int batchSize) {\n \n   @Override\n   public void write(long[] timestamps, float[] values, int batchSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62253ce3538e3a3b441639b3e2bea0cebd8a1ef0"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMjcyODA3OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/write/chunk/ChunkWriterImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQwNDozODo1NlrOH3zuqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwMzowNzoyN1rOH3-MEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODI4MTI1Ng==", "bodyText": "No need to iterate the map, and also there is no guarantee that \"loss\" property will be got before other sdt parameters.\nYou can directly use map.contains and map.get() to get whatever property you want.", "url": "https://github.com/apache/iotdb/pull/2087#discussion_r528281256", "createdAt": "2020-11-22T04:38:56Z", "author": {"login": "JackieTien97"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/write/chunk/ChunkWriterImpl.java", "diffHunk": "@@ -97,18 +109,93 @@ public ChunkWriterImpl(MeasurementSchema schema) {\n     this.pageWriter = new PageWriter(measurementSchema);\n     this.pageWriter.setTimeEncoder(measurementSchema.getTimeEncoder());\n     this.pageWriter.setValueEncoder(measurementSchema.getValueEncoder());\n+\n+    //check if the measurement schema uses SDT\n+    checkSdtEncoding();\n+  }\n+\n+  public ChunkWriterImpl(MeasurementSchema schema, boolean isMerging) {\n+    this(schema);\n+    this.isMerging = isMerging;\n+  }\n+\n+  private void checkSdtEncoding() {\n+    if (measurementSchema.getProps() != null && !isMerging) {\n+      for (Map.Entry<String, String> entry : measurementSchema.getProps().entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3bc81e10d13191eec4b2242256aa79af2d58614"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ1MjYyNw==", "bodyText": "will do. thank you.\nFor \"The paper calculate the FV of the next segment but you just use the endPoint of the last segment.\", what do you mean by that? When ending segment0 and starting segment1, I use segment0's endpoint as segment1's startpoint. How do you calculate segment1's first value..?", "url": "https://github.com/apache/iotdb/pull/2087#discussion_r528452627", "createdAt": "2020-11-23T03:07:27Z", "author": {"login": "haimeiguo"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/write/chunk/ChunkWriterImpl.java", "diffHunk": "@@ -97,18 +109,93 @@ public ChunkWriterImpl(MeasurementSchema schema) {\n     this.pageWriter = new PageWriter(measurementSchema);\n     this.pageWriter.setTimeEncoder(measurementSchema.getTimeEncoder());\n     this.pageWriter.setValueEncoder(measurementSchema.getValueEncoder());\n+\n+    //check if the measurement schema uses SDT\n+    checkSdtEncoding();\n+  }\n+\n+  public ChunkWriterImpl(MeasurementSchema schema, boolean isMerging) {\n+    this(schema);\n+    this.isMerging = isMerging;\n+  }\n+\n+  private void checkSdtEncoding() {\n+    if (measurementSchema.getProps() != null && !isMerging) {\n+      for (Map.Entry<String, String> entry : measurementSchema.getProps().entrySet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODI4MTI1Ng=="}, "originalCommit": {"oid": "a3bc81e10d13191eec4b2242256aa79af2d58614"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNDc3NzAxOnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/encoding/encoder/SdtEncoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwOTowMToxNlrOH4EK6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwOTowMToxNlrOH4EK6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU1MDYzNQ==", "bodyText": "need a blank line", "url": "https://github.com/apache/iotdb/pull/2087#discussion_r528550635", "createdAt": "2020-11-23T09:01:16Z", "author": {"login": "mychaow"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/encoding/encoder/SdtEncoder.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.tsfile.encoding.encoder;\n+\n+import java.nio.FloatBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.Pair;\n+\n+public class SdtEncoder {\n+\n+  /**\n+   * the last read pair <time, value></>\n+   * if upperDoor >= lowerDoor meaning out of compDeviation range, will store lastReadPair\n+   */\n+  private Pair<Long, Double> lastReadDouble;\n+  private Pair<Long, Long> lastReadLong;\n+  private Pair<Long, Float> lastReadFloat;\n+  private Pair<Long, Integer> lastReadInt;\n+\n+  /**\n+   * the last stored pair <time, value></>\n+   * we compare current point against lastStoredPair\n+   */\n+  private Pair<Long, Double> lastStoredDouble;\n+  private Pair<Long, Long> lastStoredLong;\n+  private Pair<Long, Float> lastStoredFloat;\n+  private Pair<Long, Integer> lastStoredInt;\n+  /**\n+   * the maximum curUpperSlope between the lastStoredPoint to the current point\n+   * upperDoor can only open up\n+   */\n+  private double upperDoor;\n+\n+  /**\n+   * the minimum curLowerSlope between the lastStoredPoint to the current point\n+   * lowerDoor can only open downard\n+   */\n+  private double lowerDoor;\n+\n+  private List<Long> timestamps;\n+  private List<Double> doubleValues;\n+  private List<Long> longValues;\n+  private List<Integer> intValues;\n+  private List<Float> floatValues;\n+\n+\n+\n+  /**\n+   * the maximum absolute difference the user set\n+   * if the data's value is within compDeviation, it will be compressed and discarded\n+   * after compression, it will only store out of range <time, data></> to form the trend\n+   */\n+  private double compDeviation;\n+\n+  /**\n+   * the minimum time distance between two stored data points\n+   * if current point time to the last stored point time distance <= compMin,\n+   * current point will NOT be stored regardless of compression deviation\n+   */\n+  private double compMin;\n+\n+  /**\n+   * the maximum time distance between two stored data points\n+   * if current point time to the last stored point time distance >= compMax,\n+   * current point will be stored regardless of compression deviation\n+   */\n+  private double compMax;\n+\n+  TSDataType dataType;\n+\n+  public SdtEncoder(TSDataType dataType) {\n+    timestamps = new ArrayList<Long>();\n+    upperDoor = Integer.MIN_VALUE;\n+    lowerDoor = Integer.MAX_VALUE;\n+    compDeviation = -1;\n+    compMin = Integer.MIN_VALUE;\n+    compMax = Integer.MAX_VALUE;\n+    this.dataType = dataType;\n+\n+    switch (dataType) {\n+      case INT32:\n+        lastReadInt = new Pair<>(null, null);\n+        lastStoredInt = new Pair<>(null, null);\n+        intValues = new ArrayList<>();\n+        break;\n+      case INT64:\n+        lastReadLong = new Pair<>(null, null);\n+        lastStoredLong = new Pair<>(null, null);\n+        longValues = new ArrayList<>();\n+        break;\n+      case DOUBLE:\n+        lastReadDouble = new Pair<>(null, null);\n+        lastStoredDouble = new Pair<>(null, null);\n+        doubleValues = new ArrayList<>();\n+        break;\n+      case FLOAT:\n+        lastReadFloat = new Pair<>(null, null);\n+        lastStoredFloat = new Pair<>(null, null);\n+        floatValues = new ArrayList<>();\n+        break;\n+    }\n+  }\n+\n+  public boolean encodeFloat(long time, float value) {\n+    // store the first time and value pair\n+    if (firstPair(time, value)) {\n+      return true;\n+    }\n+\n+    // if current point to the last stored point's time distance is within compMin,\n+    // will not check two doors nor store any point within the compMin time range\n+    if (time - lastStoredFloat.left <= compMin) {\n+      return false;\n+    }\n+\n+    // if current point to the last stored point's time distance is larger than compMax,\n+    // will reset two doors, and store current point;\n+    if (time - lastStoredFloat.left >= compMax) {\n+      reset(time, value);\n+      return true;\n+    }\n+\n+    double curUpperSlope = (value - lastStoredFloat.right - compDeviation) / (time - lastStoredFloat.left);\n+    if (curUpperSlope > upperDoor) {\n+      upperDoor = curUpperSlope;\n+    }\n+\n+    double curLowerSlope = (value - lastStoredFloat.right + compDeviation) / (time - lastStoredFloat.left);\n+    if (curLowerSlope < lowerDoor) {\n+      lowerDoor = curLowerSlope;\n+    }\n+\n+    // current point to the lastStoredPair's value exceeds compDev, will store lastReadPair and update two doors\n+    if (upperDoor >= lowerDoor) {\n+      lastStoredFloat = lastReadFloat;\n+      upperDoor = (value - lastStoredFloat.right - compDeviation) / (time - lastStoredFloat.left);\n+      lowerDoor = (value - lastStoredFloat.right + compDeviation) / (time - lastStoredFloat.left);\n+      lastReadFloat = new Pair<>(time, value);\n+      return true;\n+    }\n+\n+    lastReadFloat = new Pair<>(time, value);\n+    return false;\n+  }\n+\n+  public boolean encodeLong(long time, long value) {\n+    // store the first time and value pair\n+    if (firstPair(time, value)) {\n+      return true;\n+    }\n+\n+    // if current point to the last stored point's time distance is within compMin,\n+    // will not check two doors nor store any point within the compMin time range\n+    if (time - lastStoredLong.left <= compMin) {\n+      return false;\n+    }\n+\n+    // if current point to the last stored point's time distance is larger than compMax,\n+    // will reset two doors, and store current point;\n+    if (time - lastStoredLong.left >= compMax) {\n+      reset(time, value);\n+      return true;\n+    }\n+\n+    double curUpperSlope = (value - lastStoredLong.right - compDeviation) / (time - lastStoredLong.left);\n+    if (curUpperSlope > upperDoor) {\n+      upperDoor = curUpperSlope;\n+    }\n+\n+    double curLowerSlope = (value - lastStoredLong.right + compDeviation) / (time - lastStoredLong.left);\n+    if (curLowerSlope < lowerDoor) {\n+      lowerDoor = curLowerSlope;\n+    }\n+\n+    // current point to the lastStoredPair's value exceeds compDev, will store lastReadPair and update two doors\n+    if (upperDoor >= lowerDoor) {\n+      lastStoredLong = lastReadLong;\n+      upperDoor = (value - lastStoredLong.right - compDeviation) / (time - lastStoredLong.left);\n+      lowerDoor = (value - lastStoredLong.right + compDeviation) / (time - lastStoredLong.left);\n+      lastReadLong = new Pair<>(time, value);\n+      return true;\n+    }\n+\n+    lastReadLong = new Pair<>(time, value);\n+    return false;\n+  }\n+\n+  public boolean encodeInt(long time, int value) {\n+    // store the first time and value pair\n+    if (firstPair(time, value)) {\n+      return true;\n+    }\n+\n+    // if current point to the last stored point's time distance is within compMin,\n+    // will not check two doors nor store any point within the compMin time range\n+    if (time - lastStoredInt.left <= compMin) {\n+      return false;\n+    }\n+\n+    // if current point to the last stored point's time distance is larger than compMax,\n+    // will reset two doors, and store current point;\n+    if (time - lastStoredInt.left >= compMax) {\n+      reset(time, value);\n+      return true;\n+    }\n+\n+    double curUpperSlope = (value - lastStoredInt.right - compDeviation) / (time - lastStoredInt.left);\n+    if (curUpperSlope > upperDoor) {\n+      upperDoor = curUpperSlope;\n+    }\n+\n+    double curLowerSlope = (value - lastStoredInt.right + compDeviation) / (time - lastStoredInt.left);\n+    if (curLowerSlope < lowerDoor) {\n+      lowerDoor = curLowerSlope;\n+    }\n+\n+    // current point to the lastStoredPair's value exceeds compDev, will store lastReadPair and update two doors\n+    if (upperDoor >= lowerDoor) {\n+      lastStoredInt = lastReadInt;\n+      upperDoor = (value - lastStoredInt.right - compDeviation) / (time - lastStoredInt.left);\n+      lowerDoor = (value - lastStoredInt.right + compDeviation) / (time - lastStoredInt.left);\n+      lastReadInt = new Pair<>(time, value);\n+      return true;\n+    }\n+\n+    lastReadInt = new Pair<>(time, value);\n+    return false;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb9dcb16e44e539cdde0de0045487dde57fd96e2"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNDc3OTUwOnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/encoding/encoder/SdtEncoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwOTowMjowNVrOH4EMbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwOTowMjowNVrOH4EMbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU1MTAyMA==", "bodyText": "maybe have divide zero exception", "url": "https://github.com/apache/iotdb/pull/2087#discussion_r528551020", "createdAt": "2020-11-23T09:02:05Z", "author": {"login": "mychaow"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/encoding/encoder/SdtEncoder.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.tsfile.encoding.encoder;\n+\n+import java.nio.FloatBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.Pair;\n+\n+public class SdtEncoder {\n+\n+  /**\n+   * the last read pair <time, value></>\n+   * if upperDoor >= lowerDoor meaning out of compDeviation range, will store lastReadPair\n+   */\n+  private Pair<Long, Double> lastReadDouble;\n+  private Pair<Long, Long> lastReadLong;\n+  private Pair<Long, Float> lastReadFloat;\n+  private Pair<Long, Integer> lastReadInt;\n+\n+  /**\n+   * the last stored pair <time, value></>\n+   * we compare current point against lastStoredPair\n+   */\n+  private Pair<Long, Double> lastStoredDouble;\n+  private Pair<Long, Long> lastStoredLong;\n+  private Pair<Long, Float> lastStoredFloat;\n+  private Pair<Long, Integer> lastStoredInt;\n+  /**\n+   * the maximum curUpperSlope between the lastStoredPoint to the current point\n+   * upperDoor can only open up\n+   */\n+  private double upperDoor;\n+\n+  /**\n+   * the minimum curLowerSlope between the lastStoredPoint to the current point\n+   * lowerDoor can only open downard\n+   */\n+  private double lowerDoor;\n+\n+  private List<Long> timestamps;\n+  private List<Double> doubleValues;\n+  private List<Long> longValues;\n+  private List<Integer> intValues;\n+  private List<Float> floatValues;\n+\n+\n+\n+  /**\n+   * the maximum absolute difference the user set\n+   * if the data's value is within compDeviation, it will be compressed and discarded\n+   * after compression, it will only store out of range <time, data></> to form the trend\n+   */\n+  private double compDeviation;\n+\n+  /**\n+   * the minimum time distance between two stored data points\n+   * if current point time to the last stored point time distance <= compMin,\n+   * current point will NOT be stored regardless of compression deviation\n+   */\n+  private double compMin;\n+\n+  /**\n+   * the maximum time distance between two stored data points\n+   * if current point time to the last stored point time distance >= compMax,\n+   * current point will be stored regardless of compression deviation\n+   */\n+  private double compMax;\n+\n+  TSDataType dataType;\n+\n+  public SdtEncoder(TSDataType dataType) {\n+    timestamps = new ArrayList<Long>();\n+    upperDoor = Integer.MIN_VALUE;\n+    lowerDoor = Integer.MAX_VALUE;\n+    compDeviation = -1;\n+    compMin = Integer.MIN_VALUE;\n+    compMax = Integer.MAX_VALUE;\n+    this.dataType = dataType;\n+\n+    switch (dataType) {\n+      case INT32:\n+        lastReadInt = new Pair<>(null, null);\n+        lastStoredInt = new Pair<>(null, null);\n+        intValues = new ArrayList<>();\n+        break;\n+      case INT64:\n+        lastReadLong = new Pair<>(null, null);\n+        lastStoredLong = new Pair<>(null, null);\n+        longValues = new ArrayList<>();\n+        break;\n+      case DOUBLE:\n+        lastReadDouble = new Pair<>(null, null);\n+        lastStoredDouble = new Pair<>(null, null);\n+        doubleValues = new ArrayList<>();\n+        break;\n+      case FLOAT:\n+        lastReadFloat = new Pair<>(null, null);\n+        lastStoredFloat = new Pair<>(null, null);\n+        floatValues = new ArrayList<>();\n+        break;\n+    }\n+  }\n+\n+  public boolean encodeFloat(long time, float value) {\n+    // store the first time and value pair\n+    if (firstPair(time, value)) {\n+      return true;\n+    }\n+\n+    // if current point to the last stored point's time distance is within compMin,\n+    // will not check two doors nor store any point within the compMin time range\n+    if (time - lastStoredFloat.left <= compMin) {\n+      return false;\n+    }\n+\n+    // if current point to the last stored point's time distance is larger than compMax,\n+    // will reset two doors, and store current point;\n+    if (time - lastStoredFloat.left >= compMax) {\n+      reset(time, value);\n+      return true;\n+    }\n+\n+    double curUpperSlope = (value - lastStoredFloat.right - compDeviation) / (time - lastStoredFloat.left);\n+    if (curUpperSlope > upperDoor) {\n+      upperDoor = curUpperSlope;\n+    }\n+\n+    double curLowerSlope = (value - lastStoredFloat.right + compDeviation) / (time - lastStoredFloat.left);\n+    if (curLowerSlope < lowerDoor) {\n+      lowerDoor = curLowerSlope;\n+    }\n+\n+    // current point to the lastStoredPair's value exceeds compDev, will store lastReadPair and update two doors\n+    if (upperDoor >= lowerDoor) {\n+      lastStoredFloat = lastReadFloat;\n+      upperDoor = (value - lastStoredFloat.right - compDeviation) / (time - lastStoredFloat.left);\n+      lowerDoor = (value - lastStoredFloat.right + compDeviation) / (time - lastStoredFloat.left);\n+      lastReadFloat = new Pair<>(time, value);\n+      return true;\n+    }\n+\n+    lastReadFloat = new Pair<>(time, value);\n+    return false;\n+  }\n+\n+  public boolean encodeLong(long time, long value) {\n+    // store the first time and value pair\n+    if (firstPair(time, value)) {\n+      return true;\n+    }\n+\n+    // if current point to the last stored point's time distance is within compMin,\n+    // will not check two doors nor store any point within the compMin time range\n+    if (time - lastStoredLong.left <= compMin) {\n+      return false;\n+    }\n+\n+    // if current point to the last stored point's time distance is larger than compMax,\n+    // will reset two doors, and store current point;\n+    if (time - lastStoredLong.left >= compMax) {\n+      reset(time, value);\n+      return true;\n+    }\n+\n+    double curUpperSlope = (value - lastStoredLong.right - compDeviation) / (time - lastStoredLong.left);\n+    if (curUpperSlope > upperDoor) {\n+      upperDoor = curUpperSlope;\n+    }\n+\n+    double curLowerSlope = (value - lastStoredLong.right + compDeviation) / (time - lastStoredLong.left);\n+    if (curLowerSlope < lowerDoor) {\n+      lowerDoor = curLowerSlope;\n+    }\n+\n+    // current point to the lastStoredPair's value exceeds compDev, will store lastReadPair and update two doors\n+    if (upperDoor >= lowerDoor) {\n+      lastStoredLong = lastReadLong;\n+      upperDoor = (value - lastStoredLong.right - compDeviation) / (time - lastStoredLong.left);\n+      lowerDoor = (value - lastStoredLong.right + compDeviation) / (time - lastStoredLong.left);\n+      lastReadLong = new Pair<>(time, value);\n+      return true;\n+    }\n+\n+    lastReadLong = new Pair<>(time, value);\n+    return false;\n+  }\n+\n+  public boolean encodeInt(long time, int value) {\n+    // store the first time and value pair\n+    if (firstPair(time, value)) {\n+      return true;\n+    }\n+\n+    // if current point to the last stored point's time distance is within compMin,\n+    // will not check two doors nor store any point within the compMin time range\n+    if (time - lastStoredInt.left <= compMin) {\n+      return false;\n+    }\n+\n+    // if current point to the last stored point's time distance is larger than compMax,\n+    // will reset two doors, and store current point;\n+    if (time - lastStoredInt.left >= compMax) {\n+      reset(time, value);\n+      return true;\n+    }\n+\n+    double curUpperSlope = (value - lastStoredInt.right - compDeviation) / (time - lastStoredInt.left);\n+    if (curUpperSlope > upperDoor) {\n+      upperDoor = curUpperSlope;\n+    }\n+\n+    double curLowerSlope = (value - lastStoredInt.right + compDeviation) / (time - lastStoredInt.left);\n+    if (curLowerSlope < lowerDoor) {\n+      lowerDoor = curLowerSlope;\n+    }\n+\n+    // current point to the lastStoredPair's value exceeds compDev, will store lastReadPair and update two doors\n+    if (upperDoor >= lowerDoor) {\n+      lastStoredInt = lastReadInt;\n+      upperDoor = (value - lastStoredInt.right - compDeviation) / (time - lastStoredInt.left);\n+      lowerDoor = (value - lastStoredInt.right + compDeviation) / (time - lastStoredInt.left);\n+      lastReadInt = new Pair<>(time, value);\n+      return true;\n+    }\n+\n+    lastReadInt = new Pair<>(time, value);\n+    return false;\n+  }\n+  public boolean encodeDouble(long time, double value) {\n+    // store the first time and value pair\n+    if (firstPair(time, value)) {\n+      return true;\n+    }\n+\n+    // if current point to the last stored point's time distance is within compMin,\n+    // will not check two doors nor store any point within the compMin time range\n+    if (time - lastStoredDouble.left <= compMin) {\n+      return false;\n+    }\n+\n+    // if current point to the last stored point's time distance is larger than compMax,\n+    // will reset two doors, and store current point;\n+    if (time - lastStoredDouble.left >= compMax) {\n+      reset(time, value);\n+      return true;\n+    }\n+\n+    double curUpperSlope = (value - lastStoredDouble.right - compDeviation) / (time - lastStoredDouble.left);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb9dcb16e44e539cdde0de0045487dde57fd96e2"}, "originalPosition": 267}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNDc4MzYxOnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/encoding/encoder/SdtEncoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwOTowMzoyOFrOH4EO4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwOTowMzoyOFrOH4EO4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU1MTY0OQ==", "bodyText": "use primitive data type, this is also has box cost.", "url": "https://github.com/apache/iotdb/pull/2087#discussion_r528551649", "createdAt": "2020-11-23T09:03:28Z", "author": {"login": "mychaow"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/encoding/encoder/SdtEncoder.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.tsfile.encoding.encoder;\n+\n+import java.nio.FloatBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.Pair;\n+\n+public class SdtEncoder {\n+\n+  /**\n+   * the last read pair <time, value></>\n+   * if upperDoor >= lowerDoor meaning out of compDeviation range, will store lastReadPair\n+   */\n+  private Pair<Long, Double> lastReadDouble;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb9dcb16e44e539cdde0de0045487dde57fd96e2"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNTAyNTg0OnYy", "diffSide": "RIGHT", "path": "antlr/src/main/antlr4/org/apache/iotdb/db/qp/strategy/SqlBase.g4", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMDowNDo0MVrOH4GeRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMToxMjo0NFrOH4I3Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU4ODM1OA==", "bodyText": "Why write like this. didn't SDT need case insensitive? if SDT is a constant or propertyValue, I don't think it needs a keyword.", "url": "https://github.com/apache/iotdb/pull/2087#discussion_r528588358", "createdAt": "2020-11-23T10:04:41Z", "author": {"login": "Genius-pig"}, "path": "antlr/src/main/antlr4/org/apache/iotdb/db/qp/strategy/SqlBase.g4", "diffHunk": "@@ -1272,6 +1268,8 @@ UNDERLINE : '_';\n \n NaN : 'NaN';\n \n+SDT : 'SDT';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7729e91862fcb087ea60a3f83c30d2051b5c7e8f"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNzUwNg==", "bodyText": "removed. thank you!", "url": "https://github.com/apache/iotdb/pull/2087#discussion_r528627506", "createdAt": "2020-11-23T11:12:44Z", "author": {"login": "haimeiguo"}, "path": "antlr/src/main/antlr4/org/apache/iotdb/db/qp/strategy/SqlBase.g4", "diffHunk": "@@ -1272,6 +1268,8 @@ UNDERLINE : '_';\n \n NaN : 'NaN';\n \n+SDT : 'SDT';", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU4ODM1OA=="}, "originalCommit": {"oid": "7729e91862fcb087ea60a3f83c30d2051b5c7e8f"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDI1Njk4OnYy", "diffSide": "RIGHT", "path": "example/session/src/main/java/org/apache/iotdb/SessionExample.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMTozMjowOFrOH5fuPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMTozMjowOFrOH5fuPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA1MDYyMg==", "bodyText": "Hi, please recover this class.", "url": "https://github.com/apache/iotdb/pull/2087#discussion_r530050622", "createdAt": "2020-11-25T01:32:08Z", "author": {"login": "qiaojialin"}, "path": "example/session/src/main/java/org/apache/iotdb/SessionExample.java", "diffHunk": "@@ -48,28 +48,41 @@\n \n   public static void main(String[] args)\n       throws IoTDBConnectionException, StatementExecutionException {\n-    session = new Session(\"127.0.0.1\", 6667, \"root\", \"root\");\n+    session = new Session(\"172.16.48.4\", 58890, \"root\", \"root\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b7fa48da0560be34dcbf26bb191d5909ecf7728"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDI5MjQ2OnYy", "diffSide": "LEFT", "path": "example/session/src/main/java/org/apache/iotdb/SessionExample.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMTo0OToyN1rOH5gCNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMTo0OToyN1rOH5gCNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA1NTczMw==", "bodyText": "could the SDT be set using Session nosql API?", "url": "https://github.com/apache/iotdb/pull/2087#discussion_r530055733", "createdAt": "2020-11-25T01:49:27Z", "author": {"login": "qiaojialin"}, "path": "example/session/src/main/java/org/apache/iotdb/SessionExample.java", "diffHunk": "@@ -48,28 +48,41 @@\n \n   public static void main(String[] args)\n       throws IoTDBConnectionException, StatementExecutionException {\n-    session = new Session(\"127.0.0.1\", 6667, \"root\", \"root\");\n+    session = new Session(\"172.16.48.4\", 58890, \"root\", \"root\");\n     session.open(false);\n \n+   // session.executeNonQueryStatement(\"delete storage group root\");\n+    /*\n     try {\n       session.setStorageGroup(\"root.sg1\");\n     } catch (StatementExecutionException e) {\n       if (e.getStatusCode() != TSStatusCode.PATH_ALREADY_EXIST_ERROR.getStatusCode())\n         throw e;\n     }\n \n-    createTimeseries();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b7fa48da0560be34dcbf26bb191d5909ecf7728"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDI5ODg5OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/write/chunk/ChunkWriterImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMTo1MjozNVrOH5gF5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMTo1MjozNVrOH5gF5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA1NjY3OA==", "bodyText": "could we getDoubleValue()?", "url": "https://github.com/apache/iotdb/pull/2087#discussion_r530056678", "createdAt": "2020-11-25T01:52:35Z", "author": {"login": "qiaojialin"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/write/chunk/ChunkWriterImpl.java", "diffHunk": "@@ -119,14 +194,26 @@ public void write(long time, boolean value) {\n \n   @Override\n   public void write(long time, float value) {\n-    pageWriter.write(time, value);\n-    checkPageSizeAndMayOpenANewPage();\n+    if (!isSdtEncoding || sdtEncoder.encodeFloat(time, value)) {\n+      if (isSdtEncoding) {\n+        time = sdtEncoder.getTime();\n+        value = (float) sdtEncoder.getValue();\n+      }\n+      pageWriter.write(time, value);\n+      checkPageSizeAndMayOpenANewPage();\n+    }\n   }\n \n   @Override\n   public void write(long time, double value) {\n-    pageWriter.write(time, value);\n-    checkPageSizeAndMayOpenANewPage();\n+    if (!isSdtEncoding || sdtEncoder.encodeDouble(time, value)) {\n+      if (isSdtEncoding) {\n+        time = sdtEncoder.getTime();\n+        value = (double) sdtEncoder.getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b7fa48da0560be34dcbf26bb191d5909ecf7728"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDI5OTUxOnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/encoding/encoder/SdtEncoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMTo1MzowNFrOH5gGRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMTo1MzowNFrOH5gGRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA1Njc3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class SdtEncoder {\n          \n          \n            \n            public class SDTEncoder {", "url": "https://github.com/apache/iotdb/pull/2087#discussion_r530056774", "createdAt": "2020-11-25T01:53:04Z", "author": {"login": "qiaojialin"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/encoding/encoder/SdtEncoder.java", "diffHunk": "@@ -0,0 +1,583 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.tsfile.encoding.encoder;\n+\n+import java.nio.FloatBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+\n+public class SdtEncoder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b7fa48da0560be34dcbf26bb191d5909ecf7728"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyOTc1MTk3OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/encoding/encoder/SDTEncoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwOTozMTowN1rOH6S5bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwOTozMTowN1rOH6S5bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg4OTA2OQ==", "bodyText": "false? Otherwise, the lastStoredTimestamp you stored will be replaced by next point", "url": "https://github.com/apache/iotdb/pull/2087#discussion_r530889069", "createdAt": "2020-11-26T09:31:07Z", "author": {"login": "qiaojialin"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/encoding/encoder/SDTEncoder.java", "diffHunk": "@@ -0,0 +1,540 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.tsfile.encoding.encoder;\n+\n+public class SDTEncoder {\n+\n+  /**\n+   * the last read time and value\n+   * if upperDoor >= lowerDoor meaning out of compDeviation range, will store lastReadPair\n+   */\n+  private long lastReadTimestamp;\n+  private long lastReadLong;\n+  private double lastReadDouble;\n+  private int lastReadInt;\n+  private float lastReadFloat;\n+\n+  /**\n+   * the last stored time and vlaue\n+   * we compare current point against lastStoredPair\n+   */\n+  private long lastStoredTimestamp;\n+  private long lastStoredLong;\n+  private double lastStoredDouble;\n+  private int lastStoredInt;\n+  private float lastStoredFloat;\n+\n+  /**\n+   * the maximum curUpperSlope between the lastStoredPoint to the current point\n+   * upperDoor can only open up\n+   */\n+  private double upperDoor;\n+\n+  /**\n+   * the minimum curLowerSlope between the lastStoredPoint to the current point\n+   * lowerDoor can only open downard\n+   */\n+  private double lowerDoor;\n+\n+  /**\n+   * the maximum absolute difference the user set\n+   * if the data's value is within compDeviation, it will be compressed and discarded\n+   * after compression, it will only store out of range <time, data></> to form the trend\n+   */\n+  private double compDeviation;\n+\n+  /**\n+   * the minimum time distance between two stored data points\n+   * if current point time to the last stored point time distance <= compMin,\n+   * current point will NOT be stored regardless of compression deviation\n+   */\n+  private double compMin;\n+\n+  /**\n+   * the maximum time distance between two stored data points\n+   * if current point time to the last stored point time distance >= compMax,\n+   * current point will be stored regardless of compression deviation\n+   */\n+  private double compMax;\n+\n+  /**\n+   * isFirstValue is true when the encoder takes the first point or reset() when cur point's\n+   * distance to the last stored point's distance exceeds compMax\n+   */\n+  private boolean isFirstValue;\n+\n+  public SDTEncoder() {\n+    upperDoor = Integer.MIN_VALUE;\n+    lowerDoor = Integer.MAX_VALUE;\n+    compDeviation = -1;\n+    compMin = Integer.MIN_VALUE;\n+    compMax = Integer.MAX_VALUE;\n+    isFirstValue = true;\n+  }\n+\n+  public boolean encodeFloat(long time, float value) {\n+    // store the first time and value pair\n+    if (isFirstValue(time, value)) {\n+      return true;\n+    }\n+\n+    // if current point to the last stored point's time distance is within compMin,\n+    // will not check two doors nor store any point within the compMin time range\n+    if (time - lastStoredTimestamp <= compMin) {\n+      return false;\n+    }\n+\n+    // if current point to the last stored point's time distance is larger than compMax,\n+    // will reset two doors, and store current point;\n+    if (time - lastStoredTimestamp >= compMax) {\n+      reset(time, value);\n+      return true;\n+    }\n+\n+    double curUpperSlope = (value - lastStoredFloat - compDeviation) / (time - lastStoredTimestamp);\n+    if (curUpperSlope > upperDoor) {\n+      upperDoor = curUpperSlope;\n+      if (upperDoor > lowerDoor) {\n+        // slope between curr point and last read point\n+        double slope = (value - lastReadFloat) / (time - lastReadTimestamp);\n+        // start point of the next segment\n+        long timestamp = (long) ((lastStoredFloat + compDeviation - lastReadFloat + slope * lastReadTimestamp -\n+            lowerDoor * lastStoredTimestamp) / (slope - lowerDoor));\n+        lastStoredFloat = (float) (lastStoredFloat + compDeviation + lowerDoor * (timestamp - lastStoredTimestamp)\n+            - compDeviation / 2);\n+        lastStoredTimestamp = timestamp;\n+        // recalculate upperDoor and lowerDoor\n+        upperDoor = (value - lastStoredFloat - compDeviation) / (time - lastStoredTimestamp);\n+        lowerDoor = (value - lastStoredFloat + compDeviation) / (time - lastStoredTimestamp);\n+        // update last read point to current point\n+        lastReadFloat = value;\n+        lastReadTimestamp = time;\n+        return true;\n+      }\n+    }\n+\n+    double curLowerSlope = (value - lastStoredFloat + compDeviation) / (time - lastStoredTimestamp);\n+    if (curLowerSlope < lowerDoor) {\n+      lowerDoor = curLowerSlope;\n+      if (upperDoor > lowerDoor) {\n+        // slope between curr point and last read point\n+        double slope = (value - lastReadFloat) / (time - lastReadTimestamp);\n+        // start point of the next segment\n+        long timestamp = (long) ((lastStoredFloat - compDeviation - lastReadFloat + slope * lastReadTimestamp -\n+            upperDoor * lastStoredTimestamp) / (slope - upperDoor));\n+        lastStoredFloat = (float) (lastStoredFloat - compDeviation + upperDoor * (timestamp - lastStoredTimestamp)\n+            + compDeviation / 2);\n+        lastStoredTimestamp = timestamp;\n+        // recalculate upperDoor and lowerDoor\n+        upperDoor = (value - lastStoredFloat - compDeviation) / (time - lastStoredTimestamp);\n+        lowerDoor = (value - lastStoredFloat + compDeviation) / (time - lastStoredTimestamp);\n+        // update last read point to current point\n+        lastReadFloat = value;\n+        lastReadTimestamp = time;\n+        return true;\n+      }\n+    }\n+\n+    lastReadFloat = value;\n+    lastReadTimestamp = time;\n+    return false;\n+  }\n+\n+  public boolean encodeLong(long time, long value) {\n+    // store the first time and value pair\n+    if (isFirstValue(time, value)) {\n+      return true;\n+    }\n+\n+    // if current point to the last stored point's time distance is within compMin,\n+    // will not check two doors nor store any point within the compMin time range\n+    if (time - lastStoredTimestamp <= compMin) {\n+      return false;\n+    }\n+\n+    // if current point to the last stored point's time distance is larger than compMax,\n+    // will reset two doors, and store current point;\n+    if (time - lastStoredTimestamp >= compMax) {\n+      reset(time, value);\n+      return true;\n+    }\n+\n+    double curUpperSlope = (value - lastStoredLong - compDeviation) / (time - lastStoredTimestamp);\n+    if (curUpperSlope > upperDoor) {\n+      upperDoor = curUpperSlope;\n+      if (upperDoor > lowerDoor) {\n+        // slope between curr point and last read point\n+        double slope = ((double) value - lastReadLong) / (time - lastReadTimestamp);\n+        // start point of the next segment\n+        long timestamp = (long) ((lastStoredLong + compDeviation - lastReadLong + slope * lastReadTimestamp -\n+            lowerDoor * lastStoredTimestamp) / (slope - lowerDoor));\n+        lastStoredLong = Math.round((lastStoredLong + compDeviation + lowerDoor * (timestamp - lastStoredTimestamp)\n+            - compDeviation / 2));\n+        lastStoredTimestamp = timestamp;\n+        // recalculate upperDoor and lowerDoor\n+        upperDoor = (value - lastStoredLong - compDeviation) / (time - lastStoredTimestamp);\n+        lowerDoor = (value - lastStoredLong + compDeviation) / (time - lastStoredTimestamp);\n+        // update last read point to current point\n+        lastReadLong = value;\n+        lastReadTimestamp = time;\n+        return true;\n+      }\n+    }\n+\n+    double curLowerSlope = (value - lastStoredLong + compDeviation) / (time - lastStoredTimestamp);\n+    if (curLowerSlope < lowerDoor) {\n+      lowerDoor = curLowerSlope;\n+      if (upperDoor > lowerDoor) {\n+        // slope between curr point and last read point\n+        double slope = ((double) value - lastReadLong) / (time - lastReadTimestamp);\n+        // start point of the next segment\n+        long timestamp = (long) ((lastStoredLong - compDeviation - lastReadLong + slope * lastReadTimestamp -\n+            upperDoor * lastStoredTimestamp) / (slope - upperDoor));\n+        lastStoredLong = Math.round((lastStoredLong - compDeviation + upperDoor * (timestamp - lastStoredTimestamp)\n+            + compDeviation / 2));\n+        lastStoredTimestamp = timestamp;\n+\n+        // recalculate upperDoor and lowerDoor\n+        upperDoor = (value - lastStoredLong - compDeviation) / (time - lastStoredTimestamp);\n+        lowerDoor = (value - lastStoredLong + compDeviation) / (time - lastStoredTimestamp);\n+        // update last read point to current point\n+        lastReadLong = value;\n+        lastReadTimestamp = time;\n+        return true;\n+      }\n+    }\n+    lastReadLong = value;\n+    lastReadTimestamp = time;\n+\n+    return false;\n+  }\n+\n+  public boolean encodeInt(long time, int value) {\n+    // store the first time and value pair\n+    if (isFirstValue(time, value)) {\n+      return true;\n+    }\n+\n+    // if current point to the last stored point's time distance is within compMin,\n+    // will not check two doors nor store any point within the compMin time range\n+    if (time - lastStoredTimestamp <= compMin) {\n+      return false;\n+    }\n+\n+    // if current point to the last stored point's time distance is larger than compMax,\n+    // will reset two doors, and store current point;\n+    if (time - lastStoredTimestamp >= compMax) {\n+      reset(time, value);\n+      return true;\n+    }\n+\n+    double curUpperSlope = (value - lastStoredInt - compDeviation) / (time - lastStoredTimestamp);\n+    if (curUpperSlope > upperDoor) {\n+      upperDoor = curUpperSlope;\n+      if (upperDoor > lowerDoor) {\n+        // slope between curr point and last read point\n+        double slope = ((double) value - lastReadInt) / (time - lastReadTimestamp);\n+        // start point of the next segment\n+        long timestamp = (long) ((lastStoredInt + compDeviation - lastReadInt + slope * lastReadTimestamp -\n+            lowerDoor * lastStoredTimestamp) / (slope - lowerDoor));\n+        lastStoredInt = (int) Math.round((lastStoredInt + compDeviation + lowerDoor * (timestamp - lastStoredTimestamp)\n+            - compDeviation / 2));\n+        lastStoredTimestamp = timestamp;\n+        // recalculate upperDoor and lowerDoor\n+        upperDoor = (value - lastStoredInt - compDeviation) / (time - lastStoredTimestamp);\n+        lowerDoor = (value - lastStoredInt + compDeviation) / (time - lastStoredTimestamp);\n+        // update last read point to current point\n+        lastReadInt = value;\n+        lastReadTimestamp = time;\n+        return true;\n+      }\n+    }\n+\n+    double curLowerSlope = (value - lastStoredInt + compDeviation) / (time - lastStoredTimestamp);\n+    if (curLowerSlope < lowerDoor) {\n+      lowerDoor = curLowerSlope;\n+      if (upperDoor > lowerDoor) {\n+        // slope between curr point and last read point\n+        double slope = ((double) value - lastReadInt) / (time - lastReadTimestamp);\n+        // start point of the next segment\n+        long timestamp = (long) ((lastStoredInt - compDeviation - lastReadInt + slope * lastReadTimestamp -\n+            upperDoor * lastStoredTimestamp) / (slope - upperDoor));\n+        lastStoredInt = (int) Math.round((lastStoredInt - compDeviation + upperDoor * (timestamp - lastStoredTimestamp)\n+            + compDeviation / 2));\n+        lastStoredTimestamp = timestamp;\n+        // recalculate upperDoor and lowerDoor\n+        upperDoor = (value - lastStoredInt - compDeviation) / (time - lastStoredTimestamp);\n+        lowerDoor = (value - lastStoredInt + compDeviation) / (time - lastStoredTimestamp);\n+        // update last read point to current point\n+        lastReadInt = value;\n+        lastReadTimestamp = time;\n+        return true;\n+      }\n+    }\n+\n+    lastReadInt = value;\n+    lastReadTimestamp = time;\n+    return false;\n+  }\n+\n+  public boolean encodeDouble(long time, double value) {\n+    // store the first time and value pair\n+    if (isFirstValue(time, value)) {\n+      return true;\n+    }\n+\n+    // if current point to the last stored point's time distance is within compMin,\n+    // will not check two doors nor store any point within the compMin time range\n+    if (time - lastStoredTimestamp <= compMin) {\n+      return false;\n+    }\n+\n+    // if current point to the last stored point's time distance is larger than compMax,\n+    // will reset two doors, and store current point;\n+    if (time - lastStoredTimestamp >= compMax) {\n+      reset(time, value);\n+      return true;\n+    }\n+\n+    double curUpperSlope = (value - lastStoredDouble - compDeviation) / (time - lastStoredTimestamp);\n+    if (curUpperSlope > upperDoor) {\n+      upperDoor = curUpperSlope;\n+      if (upperDoor > lowerDoor) {\n+        // slope between curr point and last read point\n+        double slope = (value - lastReadDouble) / (time - lastReadTimestamp);\n+        // start point of the next segment\n+        long timestamp = (long) ((lastStoredDouble + compDeviation - lastReadDouble + slope * lastReadTimestamp -\n+            lowerDoor * lastStoredTimestamp) / (slope - lowerDoor));\n+        lastStoredDouble = (lastStoredDouble + compDeviation + lowerDoor * (timestamp - lastStoredTimestamp)\n+            - compDeviation / 2);\n+        lastStoredTimestamp = timestamp;\n+        // recalculate upperDoor and lowerDoor\n+        upperDoor = (value - lastStoredDouble - compDeviation) / (time - lastStoredTimestamp);\n+        lowerDoor = (value - lastStoredDouble + compDeviation) / (time - lastStoredTimestamp);\n+        // update last read point to current point\n+        lastReadDouble = value;\n+        lastReadTimestamp = time;\n+        return true;\n+      }\n+    }\n+\n+    double curLowerSlope = (value - lastStoredDouble + compDeviation) / (time - lastStoredTimestamp);\n+    if (curLowerSlope < lowerDoor) {\n+      lowerDoor = curLowerSlope;\n+      if (upperDoor > lowerDoor) {\n+        // slope between curr point and last read point\n+        double slope = (value - lastReadDouble) / (time - lastReadTimestamp);\n+        // start point of the next segment\n+        long timestamp = (long) ((lastStoredDouble - compDeviation - lastReadDouble + slope * lastReadTimestamp -\n+            upperDoor * lastStoredTimestamp) / (slope - upperDoor));\n+        lastStoredDouble = (lastStoredDouble - compDeviation + upperDoor * (timestamp - lastStoredTimestamp)\n+            + compDeviation / 2);\n+        lastStoredTimestamp = timestamp;\n+        // recalculate upperDoor and lowerDoor\n+        upperDoor = (value - lastStoredDouble - compDeviation) / (time - lastStoredTimestamp);\n+        lowerDoor = (value - lastStoredDouble + compDeviation) / (time - lastStoredTimestamp);\n+        // update last read point to current point\n+        lastReadDouble = value;\n+        lastReadTimestamp = time;\n+        return true;\n+      }\n+    }\n+\n+    lastReadDouble = value;\n+    lastReadTimestamp = time;\n+    return false;\n+  }\n+\n+  public int encode(long[] timestamps, double[] values, int batchSize) {\n+    int index = 0;\n+    for (int i = 0; i < batchSize; i++) {\n+      if (encodeDouble(timestamps[i], values[i])) {\n+        timestamps[index] = lastStoredTimestamp;\n+        values[index] = lastStoredDouble;\n+        index++;\n+      }\n+    }\n+    return index;\n+  }\n+\n+  public int encode(long[] timestamps, int[] values, int batchSize) {\n+    int index = 0;\n+    for (int i = 0; i < batchSize; i++) {\n+      if (encodeInt(timestamps[i], values[i])) {\n+        timestamps[index] = lastStoredTimestamp;\n+        values[index] = lastStoredInt;\n+        index++;\n+      }\n+    }\n+    return index;\n+  }\n+\n+  public int encode(long[] timestamps, long[] values, int batchSize) {\n+    int index = 0;\n+    for (int i = 0; i < batchSize; i++) {\n+      if (encodeLong(timestamps[i], values[i])) {\n+        timestamps[index] = lastStoredTimestamp;\n+        values[index] = lastStoredLong;\n+        index++;\n+      }\n+    }\n+    return index;\n+  }\n+\n+  public int encode(long[] timestamps, float[] values, int batchSize) {\n+    int index = 0;\n+    for (int i = 0; i < batchSize; i++) {\n+      if (encodeFloat(timestamps[i], values[i])) {\n+        timestamps[index] = lastStoredTimestamp;\n+        values[index] = lastStoredFloat;\n+        index++;\n+      }\n+    }\n+    return index;\n+  }\n+\n+  private boolean isFirstValue(long time, float value) {\n+    if (isFirstValue) {\n+      isFirstValue = false;\n+      lastReadTimestamp = time;\n+      lastReadFloat = value;\n+      lastStoredTimestamp = time;\n+      lastStoredFloat = value;\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private boolean isFirstValue(long time, long value) {\n+    if (isFirstValue) {\n+      isFirstValue = false;\n+      lastReadTimestamp = time;\n+      lastReadLong = value;\n+      lastStoredTimestamp = time;\n+      lastStoredLong = value;\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private boolean isFirstValue(long time, int value) {\n+    if (isFirstValue) {\n+      isFirstValue = false;\n+      lastReadTimestamp = time;\n+      lastReadInt = value;\n+      lastStoredTimestamp = time;\n+      lastStoredInt = value;\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private boolean isFirstValue(long time, double value) {\n+    if (isFirstValue) {\n+      isFirstValue = false;\n+      lastReadTimestamp = time;\n+      lastReadDouble = value;\n+      lastStoredTimestamp = time;\n+      lastStoredDouble = value;\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private void reset() {\n+    upperDoor = Integer.MIN_VALUE;\n+    lowerDoor = Integer.MAX_VALUE;\n+    isFirstValue = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5af139b8d8e9746d428f3a7efd0ba1a70b14a26f"}, "originalPosition": 464}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 576, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}