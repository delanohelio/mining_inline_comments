{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzOTE5OTc4", "number": 1157, "title": "[IOTDB-567] Apache IoTDB's Peer Tracker for The Raft Protocol", "bodyText": "", "createdAt": "2020-05-06T07:17:53Z", "url": "https://github.com/apache/iotdb/pull/1157", "merged": true, "mergeCommit": {"oid": "fd16dba9e60f15df68443afb170ce66448d1da5e"}, "closed": true, "closedAt": "2020-05-07T03:57:15Z", "author": {"login": "LebronAl"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcc9aKkgH2gAyNDEzOTE5OTc4OjM3M2M1NWI4MDM4MzczM2JlYWJkZTE5NDZhY2YyZDViNjk2NjM2MjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABce1HkpgFqTQwNzEzMzUyMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "373c55b80383733beabde1946acf2d5b69663622", "author": {"user": {"login": "LebronAl", "name": "Potato"}}, "url": "https://github.com/apache/iotdb/commit/373c55b80383733beabde1946acf2d5b69663622", "committedDate": "2020-05-01T08:28:45Z", "message": "fix a leader_not_found bug by amending appendEntry rpc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a8e06f00513891af02e6acd9369891fa93ac141", "author": {"user": {"login": "LebronAl", "name": "Potato"}}, "url": "https://github.com/apache/iotdb/commit/5a8e06f00513891af02e6acd9369891fa93ac141", "committedDate": "2020-05-06T01:45:04Z", "message": "fix addnode failed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12c4eb8c028bf7ffa381df0cb18f8309c6ff3ca8", "author": {"user": {"login": "LebronAl", "name": "Potato"}}, "url": "https://github.com/apache/iotdb/commit/12c4eb8c028bf7ffa381df0cb18f8309c6ff3ca8", "committedDate": "2020-05-06T05:37:39Z", "message": "add peer tracker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "398a9da4c0438ce2f0f466c895d96313a752f7c4", "author": {"user": {"login": "LebronAl", "name": "Potato"}}, "url": "https://github.com/apache/iotdb/commit/398a9da4c0438ce2f0f466c895d96313a752f7c4", "committedDate": "2020-05-06T06:14:18Z", "message": "Merge branch 'cluster_new' of github.com:Apache/incubator-iotdb into cluster_new_peer_tracker"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "42169ed67213b4818a0dd821abc9a6ca4c327d16", "author": {"user": {"login": "LebronAl", "name": "Potato"}}, "url": "https://github.com/apache/iotdb/commit/42169ed67213b4818a0dd821abc9a6ca4c327d16", "committedDate": "2020-05-06T07:14:32Z", "message": "add checkTest"}, "afterCommit": {"oid": "701f328eb1ed191f38482f1d192fb067d1ec3d5d", "author": {"user": {"login": "LebronAl", "name": "Potato"}}, "url": "https://github.com/apache/iotdb/commit/701f328eb1ed191f38482f1d192fb067d1ec3d5d", "committedDate": "2020-05-06T08:25:39Z", "message": "add checkTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "701f328eb1ed191f38482f1d192fb067d1ec3d5d", "author": {"user": {"login": "LebronAl", "name": "Potato"}}, "url": "https://github.com/apache/iotdb/commit/701f328eb1ed191f38482f1d192fb067d1ec3d5d", "committedDate": "2020-05-06T08:25:39Z", "message": "add checkTest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MTExMDQx", "url": "https://github.com/apache/iotdb/pull/1157#pullrequestreview-407111041", "createdAt": "2020-05-07T02:31:47Z", "commit": {"oid": "701f328eb1ed191f38482f1d192fb067d1ec3d5d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMjozMTo0N1rOGRsNCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMjozNDoxM1rOGRsPeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwMzIwOA==", "bodyText": "It would be better to perform a binary search, but it is fine for now.", "url": "https://github.com/apache/iotdb/pull/1157#discussion_r421203208", "createdAt": "2020-05-07T02:31:47Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/catchup/CatchUpTask.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.catchup;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.cluster.log.logtypes.EmptyContentLog;\n+import org.apache.iotdb.cluster.rpc.thrift.AppendEntryRequest;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.cluster.rpc.thrift.RaftService.AsyncClient;\n+import org.apache.iotdb.cluster.server.NodeCharacter;\n+import org.apache.iotdb.cluster.server.Peer;\n+import org.apache.iotdb.cluster.server.RaftServer;\n+import org.apache.iotdb.cluster.server.handlers.caller.LogCatchUpHandler;\n+import org.apache.iotdb.cluster.server.member.RaftMember;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CatchUpTask implements Runnable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(LogCatchUpTask.class);\n+\n+  private Node node;\n+  private Peer peer;\n+  private RaftMember raftMember;\n+  private Snapshot snapshot;\n+  private List<Log> logs;\n+\n+\n+  public CatchUpTask(Node node, Peer peer, RaftMember raftMember) {\n+    this.node = node;\n+    this.peer = peer;\n+    this.raftMember = raftMember;\n+    this.logs = Collections.emptyList();\n+    this.snapshot = null;\n+  }\n+\n+  boolean checkMatchIndex() throws TException, InterruptedException {\n+    AppendEntryRequest request = new AppendEntryRequest();\n+    AtomicBoolean isMatch = new AtomicBoolean(false);\n+\n+    LogCatchUpHandler handler = new LogCatchUpHandler();\n+    handler.setAppendSucceed(isMatch);\n+    handler.setRaftMember(raftMember);\n+    handler.setFollower(node);\n+    if (raftMember.getHeader() != null) {\n+      request.setHeader(raftMember.getHeader());\n+    }\n+    request.setLeader(raftMember.getThisNode());\n+    // not update follower's commitIndex in order to append the log which index is matchIndex twice\n+    request.setLeaderCommit(-1);\n+    synchronized (raftMember.getLogManager()) {\n+      peer.setNextIndex(raftMember.getLogManager().getLastLogIndex());\n+      try {\n+        logs = raftMember.getLogManager().getEntries(\n+            Math.max(raftMember.getLogManager().getFirstIndex(), peer.getMatchIndex() + 1),\n+            peer.getNextIndex() + 1);\n+      } catch (Exception e) {\n+        logger.error(\"Unexpected error in logManager's getEntries during matchIndexCheck\", e);\n+      }\n+    }\n+\n+    int index = logs.size() - 1;\n+    EmptyContentLog emptyLog = new EmptyContentLog();\n+    while (index >= 0) {\n+      Log log = logs.get(index);\n+      emptyLog.setCurrLogIndex(log.getCurrLogIndex());\n+      emptyLog.setCurrLogTerm(log.getCurrLogTerm());\n+      synchronized (raftMember.getTerm()) {\n+        // make sure this node is still a leader\n+        if (raftMember.getCharacter() != NodeCharacter.LEADER) {\n+          logger.debug(\"Leadership is lost when doing a catch-up to {}, aborting\", node);\n+          break;\n+        }\n+        request.setTerm(raftMember.getTerm().get());\n+      }\n+      if (index > 0) {\n+        request.setPrevLogIndex(logs.get(index - 1).getCurrLogIndex());\n+        request.setPrevLogTerm(logs.get(index - 1).getCurrLogTerm());\n+      } else {\n+        request.setPrevLogIndex(log.getCurrLogIndex() - 1);\n+        try {\n+          request.setPrevLogTerm(raftMember.getLogManager().getTerm(log.getCurrLogIndex() - 1));\n+        } catch (Exception e) {\n+          logger.error(\"getTerm failed for newly append entries\", e);\n+        }\n+      }\n+\n+      handler.setLog(log);\n+      request.setEntry(emptyLog.serialize());\n+\n+      synchronized (isMatch) {\n+        AsyncClient client = raftMember.connectNode(node);\n+        if (client == null) {\n+          break;\n+        }\n+        client.appendEntry(request, handler);\n+        raftMember.getLastCatchUpResponseTime().put(node, System.currentTimeMillis());\n+        isMatch.wait(RaftServer.connectionTimeoutInMS);\n+      }\n+      if (isMatch.get()) {\n+        // if follower return RESPONSE.AGREE with this empty log, then start sending real logs from this emptyContentLog's index.\n+        // which means the log which index is matchIndex will be send twice, but at the first time it sent an empty log.\n+        logs.subList(0, index).clear();\n+        if (logger.isDebugEnabled()) {\n+          logger.debug(\"{} makes {} catch up with {} cached logs\", raftMember.getName(), node,\n+              logs.size());\n+        }\n+        return false;\n+      }\n+      index--;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "701f328eb1ed191f38482f1d192fb067d1ec3d5d"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwMzgzMw==", "bodyText": "Batched log catch-up has been introduced, better to switch to better.", "url": "https://github.com/apache/iotdb/pull/1157#discussion_r421203833", "createdAt": "2020-05-07T02:34:13Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/catchup/CatchUpTask.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.catchup;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.cluster.log.logtypes.EmptyContentLog;\n+import org.apache.iotdb.cluster.rpc.thrift.AppendEntryRequest;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.cluster.rpc.thrift.RaftService.AsyncClient;\n+import org.apache.iotdb.cluster.server.NodeCharacter;\n+import org.apache.iotdb.cluster.server.Peer;\n+import org.apache.iotdb.cluster.server.RaftServer;\n+import org.apache.iotdb.cluster.server.handlers.caller.LogCatchUpHandler;\n+import org.apache.iotdb.cluster.server.member.RaftMember;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CatchUpTask implements Runnable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(LogCatchUpTask.class);\n+\n+  private Node node;\n+  private Peer peer;\n+  private RaftMember raftMember;\n+  private Snapshot snapshot;\n+  private List<Log> logs;\n+\n+\n+  public CatchUpTask(Node node, Peer peer, RaftMember raftMember) {\n+    this.node = node;\n+    this.peer = peer;\n+    this.raftMember = raftMember;\n+    this.logs = Collections.emptyList();\n+    this.snapshot = null;\n+  }\n+\n+  boolean checkMatchIndex() throws TException, InterruptedException {\n+    AppendEntryRequest request = new AppendEntryRequest();\n+    AtomicBoolean isMatch = new AtomicBoolean(false);\n+\n+    LogCatchUpHandler handler = new LogCatchUpHandler();\n+    handler.setAppendSucceed(isMatch);\n+    handler.setRaftMember(raftMember);\n+    handler.setFollower(node);\n+    if (raftMember.getHeader() != null) {\n+      request.setHeader(raftMember.getHeader());\n+    }\n+    request.setLeader(raftMember.getThisNode());\n+    // not update follower's commitIndex in order to append the log which index is matchIndex twice\n+    request.setLeaderCommit(-1);\n+    synchronized (raftMember.getLogManager()) {\n+      peer.setNextIndex(raftMember.getLogManager().getLastLogIndex());\n+      try {\n+        logs = raftMember.getLogManager().getEntries(\n+            Math.max(raftMember.getLogManager().getFirstIndex(), peer.getMatchIndex() + 1),\n+            peer.getNextIndex() + 1);\n+      } catch (Exception e) {\n+        logger.error(\"Unexpected error in logManager's getEntries during matchIndexCheck\", e);\n+      }\n+    }\n+\n+    int index = logs.size() - 1;\n+    EmptyContentLog emptyLog = new EmptyContentLog();\n+    while (index >= 0) {\n+      Log log = logs.get(index);\n+      emptyLog.setCurrLogIndex(log.getCurrLogIndex());\n+      emptyLog.setCurrLogTerm(log.getCurrLogTerm());\n+      synchronized (raftMember.getTerm()) {\n+        // make sure this node is still a leader\n+        if (raftMember.getCharacter() != NodeCharacter.LEADER) {\n+          logger.debug(\"Leadership is lost when doing a catch-up to {}, aborting\", node);\n+          break;\n+        }\n+        request.setTerm(raftMember.getTerm().get());\n+      }\n+      if (index > 0) {\n+        request.setPrevLogIndex(logs.get(index - 1).getCurrLogIndex());\n+        request.setPrevLogTerm(logs.get(index - 1).getCurrLogTerm());\n+      } else {\n+        request.setPrevLogIndex(log.getCurrLogIndex() - 1);\n+        try {\n+          request.setPrevLogTerm(raftMember.getLogManager().getTerm(log.getCurrLogIndex() - 1));\n+        } catch (Exception e) {\n+          logger.error(\"getTerm failed for newly append entries\", e);\n+        }\n+      }\n+\n+      handler.setLog(log);\n+      request.setEntry(emptyLog.serialize());\n+\n+      synchronized (isMatch) {\n+        AsyncClient client = raftMember.connectNode(node);\n+        if (client == null) {\n+          break;\n+        }\n+        client.appendEntry(request, handler);\n+        raftMember.getLastCatchUpResponseTime().put(node, System.currentTimeMillis());\n+        isMatch.wait(RaftServer.connectionTimeoutInMS);\n+      }\n+      if (isMatch.get()) {\n+        // if follower return RESPONSE.AGREE with this empty log, then start sending real logs from this emptyContentLog's index.\n+        // which means the log which index is matchIndex will be send twice, but at the first time it sent an empty log.\n+        logs.subList(0, index).clear();\n+        if (logger.isDebugEnabled()) {\n+          logger.debug(\"{} makes {} catch up with {} cached logs\", raftMember.getName(), node,\n+              logs.size());\n+        }\n+        return false;\n+      }\n+      index--;\n+    }\n+    try {\n+      raftMember.getLogManager().takeSnapshot();\n+    } catch (IOException e) {\n+      logger.error(\"Unexpected error when taking snapshot.\", e);\n+    }\n+    snapshot = raftMember.getLogManager().getSnapshot();\n+    if (logger.isDebugEnabled()) {\n+      logger\n+          .debug(\"{}: Logs in {} are too old, catch up with snapshot\", raftMember.getName(), node);\n+    }\n+    return true;\n+  }\n+\n+  public void run() {\n+    try {\n+      if (checkMatchIndex()) {\n+        SnapshotCatchUpTask task = new SnapshotCatchUpTask(logs, snapshot, node, raftMember);\n+        task.run();\n+      } else {\n+        LogCatchUpTask task = new LogCatchUpTask(logs, node, raftMember);\n+        task.run();\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "701f328eb1ed191f38482f1d192fb067d1ec3d5d"}, "originalPosition": 156}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f30050d78638fec749b19a19cc31ec25482bb64", "author": {"user": {"login": "LebronAl", "name": "Potato"}}, "url": "https://github.com/apache/iotdb/commit/4f30050d78638fec749b19a19cc31ec25482bb64", "committedDate": "2020-05-07T03:30:38Z", "message": "Merge branch 'cluster_new' of github.com:Apache/incubator-iotdb into cluster_new_peer_tracker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e7590f46abd0b6bd10acd99e4219e3f9f31e7e0", "author": {"user": {"login": "LebronAl", "name": "Potato"}}, "url": "https://github.com/apache/iotdb/commit/1e7590f46abd0b6bd10acd99e4219e3f9f31e7e0", "committedDate": "2020-05-07T03:39:31Z", "message": "Merge branch 'cluster_new' of github.com:Apache/incubator-iotdb into cluster_new_peer_tracker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ce349b8b09e2d3dd3a385a02dda15a9aac375ed", "author": {"user": {"login": "LebronAl", "name": "Potato"}}, "url": "https://github.com/apache/iotdb/commit/1ce349b8b09e2d3dd3a385a02dda15a9aac375ed", "committedDate": "2020-05-07T03:45:20Z", "message": "Merge branch 'cluster_new' of github.com:Apache/incubator-iotdb into cluster_new_peer_tracker"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MTMzNTIz", "url": "https://github.com/apache/iotdb/pull/1157#pullrequestreview-407133523", "createdAt": "2020-05-07T03:57:03Z", "commit": {"oid": "1ce349b8b09e2d3dd3a385a02dda15a9aac375ed"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3817, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}