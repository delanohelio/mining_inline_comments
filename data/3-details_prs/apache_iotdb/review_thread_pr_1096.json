{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4NTcyNTE4", "number": 1096, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOTowODo1MFrOD2FEbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOTozMDo1M1rOD2FReg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDMyNzUwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MetadataOperationType.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOTowODo1MFrOGLy05w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOTowODo1MFrOGLy05w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMDI2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static final String CHANGE_OFFSET = \"12\";\n          \n          \n            \n              public static final String SET_OFFSET = \"12\";", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415020263", "createdAt": "2020-04-25T09:08:50Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MetadataOperationType.java", "diffHunk": "@@ -29,4 +29,5 @@ private MetadataOperationType(){\n   public static final String SET_STORAGE_GROUP = \"2\";\n   public static final String SET_TTL = \"10\";\n   public static final String DELETE_STORAGE_GROUP = \"11\";\n+  public static final String CHANGE_OFFSET = \"12\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDM0Mjk4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToxODozMVrOGLy7kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToxODozMVrOGLy7kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMTk2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n          \n          \n            \n              public void dropTagsOrAttributes(Set<String> keySet, String fullPath) throws MetadataException, IOException {", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415021968", "createdAt": "2020-04-25T09:18:31Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 603}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDM0Njg4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToyMTowNlrOGLy9OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToyMTowNlrOGLy9OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMjM5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            // tag key -> tag values", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415022393", "createdAt": "2020-04-25T09:21:06Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 617}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDM0NzI5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToyMToxOFrOGLy9ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToyMToxOFrOGLy9ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMjQzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  Map<String, String> deleteTag = new HashMap<>();\n          \n          \n            \n                  Map<String, String> deletedTags = new HashMap<>();", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415022437", "createdAt": "2020-04-25T09:21:18Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 618}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDM0OTg5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToyMzoxM1rOGLy-iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToyMzoxM1rOGLy-iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMjcyOQ==", "bodyText": "add javadoc\nremove the empty tag value and tag key", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415022729", "createdAt": "2020-04-25T09:23:13Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 637}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDM1MDMzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToyMzo0MVrOGLy-vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToyMzo0MVrOGLy-vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMjc4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void setTag(Map<String, String> alterMap, String fullPath)\n          \n          \n            \n              public void changeTagValue(Map<String, String> alterMap, String fullPath)", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415022780", "createdAt": "2020-04-25T09:23:41Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {\n+          tagIndex.get(key).remove(value);\n+          if (tagIndex.get(key).isEmpty()) {\n+            tagIndex.remove(key);\n+          }\n+        }\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setTag(Map<String, String> alterMap, String fullPath)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 649}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDM1MDg1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToyNDowMlrOGLy-9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToyNDowMlrOGLy-9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMjgzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  Map<String, String> beforeTagValue = new HashMap<>();\n          \n          \n            \n                  Map<String, String> oldTagValue = new HashMap<>();", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415022837", "createdAt": "2020-04-25T09:24:02Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {\n+          tagIndex.get(key).remove(value);\n+          if (tagIndex.get(key).isEmpty()) {\n+            tagIndex.remove(key);\n+          }\n+        }\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setTag(Map<String, String> alterMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      if (leafMNode.getOffset() < 0) {\n+        throw new MetadataException(\n+                String.format(\"TimeSeries [%s] does not have any tag/attribute.\", fullPath));\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+      Map<String, String> beforeTagValue = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 664}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDM1MTMwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToyNDoxNVrOGLy_JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToyNDoxNVrOGLy_JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMjg4NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  Map<String, String> currentTagValue = new HashMap<>();\n          \n          \n            \n                  Map<String, String> newTagValue = new HashMap<>();", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415022885", "createdAt": "2020-04-25T09:24:15Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {\n+          tagIndex.get(key).remove(value);\n+          if (tagIndex.get(key).isEmpty()) {\n+            tagIndex.remove(key);\n+          }\n+        }\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setTag(Map<String, String> alterMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      if (leafMNode.getOffset() < 0) {\n+        throw new MetadataException(\n+                String.format(\"TimeSeries [%s] does not have any tag/attribute.\", fullPath));\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+      Map<String, String> beforeTagValue = new HashMap<>();\n+      Map<String, String> currentTagValue = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 665}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDM1MzAzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToyNToyOVrOGLy_6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToyNToyOVrOGLy_6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMzA4Mw==", "bodyText": "add some example...", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415023083", "createdAt": "2020-04-25T09:25:29Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {\n+          tagIndex.get(key).remove(value);\n+          if (tagIndex.get(key).isEmpty()) {\n+            tagIndex.remove(key);\n+          }\n+        }\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setTag(Map<String, String> alterMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      if (leafMNode.getOffset() < 0) {\n+        throw new MetadataException(\n+                String.format(\"TimeSeries [%s] does not have any tag/attribute.\", fullPath));\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+      Map<String, String> beforeTagValue = new HashMap<>();\n+      Map<String, String> currentTagValue = new HashMap<>();\n+      for (Entry<String, String> entry : alterMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // check tag map\n+        if (pair.left.containsKey(key)) {\n+          beforeTagValue.put(key, pair.left.get(key));\n+          currentTagValue.put(key, value);\n+          pair.left.put(key, value);\n+        } else if (pair.right.containsKey(key)) {\n+          // check attribute map\n+          pair.right.put(key, value);\n+        } else {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] does not have tag/attribute [%s].\", fullPath, key));\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : beforeTagValue.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 686}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDM1MzI1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToyNTo1M1rOGLzACQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToyNTo1M1rOGLzACQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMzExMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    tagIndex\n          \n          \n            \n                            .computeIfAbsent(key, k -> new HashMap<>())\n          \n          \n            \n                    tagIndex.computeIfAbsent(key, k -> new HashMap<>())", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415023113", "createdAt": "2020-04-25T09:25:53Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {\n+          tagIndex.get(key).remove(value);\n+          if (tagIndex.get(key).isEmpty()) {\n+            tagIndex.remove(key);\n+          }\n+        }\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setTag(Map<String, String> alterMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      if (leafMNode.getOffset() < 0) {\n+        throw new MetadataException(\n+                String.format(\"TimeSeries [%s] does not have any tag/attribute.\", fullPath));\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+      Map<String, String> beforeTagValue = new HashMap<>();\n+      Map<String, String> currentTagValue = new HashMap<>();\n+      for (Entry<String, String> entry : alterMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // check tag map\n+        if (pair.left.containsKey(key)) {\n+          beforeTagValue.put(key, pair.left.get(key));\n+          currentTagValue.put(key, value);\n+          pair.left.put(key, value);\n+        } else if (pair.right.containsKey(key)) {\n+          // check attribute map\n+          pair.right.put(key, value);\n+        } else {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] does not have tag/attribute [%s].\", fullPath, key));\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : beforeTagValue.entrySet()) {\n+        String key = entry.getKey();\n+        String beforeValue = entry.getValue();\n+        String currentValue = currentTagValue.get(key);\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(beforeValue).remove(leafMNode);\n+        tagIndex\n+                .computeIfAbsent(key, k -> new HashMap<>())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 693}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDM1OTY0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToyOTo1MlrOGLzCsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOToyOTo1MlrOGLzCsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMzc5NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String value = pair.left.remove(beforeName);\n          \n          \n            \n                    String oldTagvalue = pair.left.remove(beforeName);", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415023794", "createdAt": "2020-04-25T09:29:52Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {\n+          tagIndex.get(key).remove(value);\n+          if (tagIndex.get(key).isEmpty()) {\n+            tagIndex.remove(key);\n+          }\n+        }\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setTag(Map<String, String> alterMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      if (leafMNode.getOffset() < 0) {\n+        throw new MetadataException(\n+                String.format(\"TimeSeries [%s] does not have any tag/attribute.\", fullPath));\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+      Map<String, String> beforeTagValue = new HashMap<>();\n+      Map<String, String> currentTagValue = new HashMap<>();\n+      for (Entry<String, String> entry : alterMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // check tag map\n+        if (pair.left.containsKey(key)) {\n+          beforeTagValue.put(key, pair.left.get(key));\n+          currentTagValue.put(key, value);\n+          pair.left.put(key, value);\n+        } else if (pair.right.containsKey(key)) {\n+          // check attribute map\n+          pair.right.put(key, value);\n+        } else {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] does not have tag/attribute [%s].\", fullPath, key));\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : beforeTagValue.entrySet()) {\n+        String key = entry.getKey();\n+        String beforeValue = entry.getValue();\n+        String currentValue = currentTagValue.get(key);\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(beforeValue).remove(leafMNode);\n+        tagIndex\n+                .computeIfAbsent(key, k -> new HashMap<>())\n+                .computeIfAbsent(currentValue, k -> new HashSet<>())\n+                .add(leafMNode);\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void renameTag(String beforeName, String currentName, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      if (leafMNode.getOffset() < 0) {\n+        throw new MetadataException(\n+                String.format(\"TimeSeries [%s] does not have [%s] tag/attribute.\", fullPath, beforeName));\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      // current name has existed\n+      if (pair.left.containsKey(currentName) || pair.right.containsKey(currentName)) {\n+        throw new MetadataException(\n+                String.format(\n+                        \"TimeSeries [%s] already has a tag/attribute named [%s].\", fullPath, currentName));\n+      }\n+\n+      // check tag map\n+      if (pair.left.containsKey(beforeName)) {\n+        String value = pair.left.remove(beforeName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 727}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDM2MDkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MLogWriter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOTozMDo1M1rOGLzDSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOTozMDo1M1rOGLzDSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMzk0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void changeOffset(String path, long offset) throws IOException {\n          \n          \n            \n              public void setOffset(String path, long offset) throws IOException {", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415023944", "createdAt": "2020-04-25T09:30:53Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MLogWriter.java", "diffHunk": "@@ -115,6 +115,12 @@ public void setTTL(String storageGroup, long ttl) throws IOException {\n     writer.flush();\n   }\n \n+  public void changeOffset(String path, long offset) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 94, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}