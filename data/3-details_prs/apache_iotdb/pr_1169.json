{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1MDM4Njgx", "number": 1169, "title": "Premerge for the distributed version", "bodyText": "", "createdAt": "2020-05-08T04:29:03Z", "url": "https://github.com/apache/iotdb/pull/1169", "merged": true, "mergeCommit": {"oid": "1079e2e0d6923a4abe495018fd5f64737d80c19e"}, "closed": true, "closedAt": "2020-06-08T06:58:17Z", "author": {"login": "jt2594838"}, "timelineItems": {"totalCount": 47, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcfKKEbgH2gAyNDE1MDM4NjgxOjk0MTBjZTI5Zjg0YWQ2ZmZiMzkyMzk3OTc4MzI5NGUzODkzODQ3MTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpHRx8AH2gAyNDE1MDM4NjgxOjQ3MDQ3YTNkODI3YmM3YTIyODZjOGQzM2IxZGVkYzBhMTc4NzZlYzk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9410ce29f84ad6ffb3923979783294e389384717", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/9410ce29f84ad6ffb3923979783294e389384717", "committedDate": "2020-05-08T04:27:47Z", "message": "premerge for the distributed version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "380874c7f27c90b9ae0ead44a6a3ae164413dd91", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/380874c7f27c90b9ae0ead44a6a3ae164413dd91", "committedDate": "2020-05-08T08:11:34Z", "message": "Merge branch 'master' into cluster_premerge\n\n# Conflicts:\n#\tserver/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba7e7632234937baea8fb3e1a5a25c569150e64d", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/ba7e7632234937baea8fb3e1a5a25c569150e64d", "committedDate": "2020-05-08T11:18:23Z", "message": "Merge branch 'master' into cluster_premerge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb8cef7fe2ccd34f104f213b5c6c8b83b85f8e6c", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/cb8cef7fe2ccd34f104f213b5c6c8b83b85f8e6c", "committedDate": "2020-05-08T11:30:55Z", "message": "fix align"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b674ea3b96b85796f6c24ee2cc692a01c885f296", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/b674ea3b96b85796f6c24ee2cc692a01c885f296", "committedDate": "2020-05-09T01:59:02Z", "message": "Merge branch 'master' into cluster_premerge\n\n# Conflicts:\n#\tserver/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01f59248c21200bdec8d9ed4e3241aa739646644", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/01f59248c21200bdec8d9ed4e3241aa739646644", "committedDate": "2020-05-11T01:06:36Z", "message": "Merge branch 'master' into cluster_premerge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c688dffe23c5429f17a8208f4f52764bc0b87a5a", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/c688dffe23c5429f17a8208f4f52764bc0b87a5a", "committedDate": "2020-05-12T01:44:10Z", "message": "Merge branch 'master' into cluster_premerge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e884f7641b81b156068160b456f82f9bcfbb520", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/0e884f7641b81b156068160b456f82f9bcfbb520", "committedDate": "2020-05-12T02:02:17Z", "message": "fix sonar issues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNjgzNDY5", "url": "https://github.com/apache/iotdb/pull/1169#pullrequestreview-410683469", "createdAt": "2020-05-13T08:06:16Z", "commit": {"oid": "0e884f7641b81b156068160b456f82f9bcfbb520"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODowNjoxNlrOGUmIJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODowNjoxNlrOGUmIJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0OTM4Mg==", "bodyText": "why set it as true?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r424249382", "createdAt": "2020-05-13T08:06:16Z", "author": {"login": "jixuan1989"}, "path": "jdbc/src/main/java/org/apache/iotdb/jdbc/Config.java", "diffHunk": "@@ -52,6 +52,6 @@ private Config(){}\n \n   public static final String JDBC_DRIVER_NAME = \"org.apache.iotdb.jdbc.IoTDBDriver\";\n \n-  public static boolean rpcThriftCompressionEnable = false;\n+  public static boolean rpcThriftCompressionEnable = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e884f7641b81b156068160b456f82f9bcfbb520"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76acdd59ee12c227464659f142056028167a988e", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/76acdd59ee12c227464659f142056028167a988e", "committedDate": "2020-05-14T02:10:18Z", "message": "Merge branch 'master' into cluster_premerge\n\n# Conflicts:\n#\tsession/src/main/java/org/apache/iotdb/session/Session.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "448c5b80f3bba7a521c8700b98073488c14399b8", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/448c5b80f3bba7a521c8700b98073488c14399b8", "committedDate": "2020-05-18T02:42:06Z", "message": "Merge branch 'master' into cluster_premerge\n\n# Conflicts:\n#\tserver/src/main/java/org/apache/iotdb/db/engine/upgrade/UpgradeTask.java\n#\tserver/src/main/java/org/apache/iotdb/db/engine/version/SimpleFileVersionController.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/425ec9dabebeda7ec9e0960ac5975dbbfb21d6de", "committedDate": "2020-05-18T03:57:28Z", "message": "fix sonar isssues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMjMzMjQ3", "url": "https://github.com/apache/iotdb/pull/1169#pullrequestreview-413233247", "createdAt": "2020-05-18T02:08:33Z", "commit": {"oid": "76acdd59ee12c227464659f142056028167a988e"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMjowODozM1rOGWlnAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODozMDoxM1rOGWsu6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzODA0OA==", "bodyText": "Should we change rpcThriftCompressionEnable and other changed configs in server/src/assembly/resources/conf/iotdb-engine.property as well?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426338048", "createdAt": "2020-05-18T02:08:33Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -96,7 +96,7 @@\n   /**\n    * whether to use thrift compression.\n    */\n-  private boolean rpcThriftCompressionEnable = false;\n+  private boolean rpcThriftCompressionEnable = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76acdd59ee12c227464659f142056028167a988e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMTc3MA==", "bodyText": "Please don't forget to update the rpc-changelist.md file.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426431770", "createdAt": "2020-05-18T07:51:40Z", "author": {"login": "HTHou"}, "path": "service-rpc/src/main/thrift/cluster.thrift", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+include \"rpc.thrift\"\n+namespace java org.apache.iotdb.cluster.rpc.thrift\n+\n+typedef i32 int \n+typedef i16 short\n+typedef i64 long\n+\n+// leader -> follower\n+struct HeartBeatRequest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzNDg0MA==", "bodyText": "format\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            // leader -> follower\n          \n          \n            \n            struct StartUpStatus {\n          \n          \n            \n             1: required long partitionInterval\n          \n          \n            \n             2: required int hashSalt\n          \n          \n            \n             3: required int replicationNumber\n          \n          \n            \n            }\n          \n          \n            \n            \n          \n          \n            \n            // leader -> follower\n          \n          \n            \n            struct StartUpStatus {\n          \n          \n            \n              1: required long partitionInterval\n          \n          \n            \n              2: required int hashSalt\n          \n          \n            \n              3: required int replicationNumber\n          \n          \n            \n            }", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426434840", "createdAt": "2020-05-18T07:57:10Z", "author": {"login": "HTHou"}, "path": "service-rpc/src/main/thrift/cluster.thrift", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+include \"rpc.thrift\"\n+namespace java org.apache.iotdb.cluster.rpc.thrift\n+\n+typedef i32 int \n+typedef i16 short\n+typedef i64 long\n+\n+// leader -> follower\n+struct HeartBeatRequest {\n+  1: required long term // leader's meta log\n+  2: required long commitLogIndex  // leader's meta log\n+  3: required long commitLogTerm\n+  4: required Node leader\n+  // if the leader does not know the follower's id, and require it reports to the leader, then true\n+  5: required bool requireIdentifier\n+  6: required bool regenerateIdentifier //if the leader finds the follower's id is conflicted,\n+  // then true\n+  // serialized partitionTable\n+  7: optional binary partitionTableBytes\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  8: optional Node header\n+}\n+\n+// follower -> leader\n+struct HeartBeatResponse {\n+  1: required long term\n+  2: optional long lastLogIndex // follower's meta log\n+  3: optional long lastLogTerm // follower's meta log\n+  // used to perform a catch up when necessary\n+  4: optional Node follower\n+  5: optional int followerIdentifier\n+  6: required bool requirePartitionTable\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+// node -> node\n+struct ElectionRequest {\n+  1: required long term\n+  2: required long lastLogTerm\n+  3: required long lastLogIndex\n+  4: required Node elector\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  5: optional Node header\n+  6: optional long dataLogLastIndex\n+  7: optional long dataLogLastTerm\n+}\n+\n+// leader -> follower\n+struct AppendEntryRequest {\n+  1: required long term // leader's\n+  2: required Node leader\n+  3: required long prevLogIndex\n+  4: required long prevLogTerm\n+  5: required long leaderCommit\n+  6: required binary entry // data\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+// leader -> follower\n+struct AppendEntriesRequest {\n+  1: required long term // leader's\n+  2: required Node leader\n+  3: required list<binary> entries // data\n+  4: required long prevLogIndex\n+  5: required long prevLogTerm\n+  6: required long leaderCommit\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+struct AddNodeResponse {\n+  // -1: accept to add new node or the node is already in this cluster, otherwise: fail to\n+  // add new node\n+  1: required int respNum\n+  2: optional binary partitionTableBytes\n+  3: optional CheckStatusResponse checkStatusResponse\n+}\n+\n+struct Node {\n+  1: required string ip\n+  2: required int metaPort\n+  3: required int nodeIdentifier\n+  4: required int dataPort\n+}\n+\n+// leader -> follower\n+struct StartUpStatus {\n+ 1: required long partitionInterval\n+ 2: required int hashSalt\n+ 3: required int replicationNumber\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzNTQwMA==", "bodyText": "format\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // follower -> leader\n          \n          \n            \n            struct CheckStatusResponse {\n          \n          \n            \n             1: required bool partitionalIntervalEquals\n          \n          \n            \n             2: required bool hashSaltEquals\n          \n          \n            \n             3: required bool replicationNumEquals\n          \n          \n            \n            }\n          \n          \n            \n            // follower -> leader\n          \n          \n            \n            struct CheckStatusResponse {\n          \n          \n            \n              1: required bool partitionalIntervalEquals\n          \n          \n            \n              2: required bool hashSaltEquals\n          \n          \n            \n              3: required bool replicationNumEquals\n          \n          \n            \n            }", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426435400", "createdAt": "2020-05-18T07:58:05Z", "author": {"login": "HTHou"}, "path": "service-rpc/src/main/thrift/cluster.thrift", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+include \"rpc.thrift\"\n+namespace java org.apache.iotdb.cluster.rpc.thrift\n+\n+typedef i32 int \n+typedef i16 short\n+typedef i64 long\n+\n+// leader -> follower\n+struct HeartBeatRequest {\n+  1: required long term // leader's meta log\n+  2: required long commitLogIndex  // leader's meta log\n+  3: required long commitLogTerm\n+  4: required Node leader\n+  // if the leader does not know the follower's id, and require it reports to the leader, then true\n+  5: required bool requireIdentifier\n+  6: required bool regenerateIdentifier //if the leader finds the follower's id is conflicted,\n+  // then true\n+  // serialized partitionTable\n+  7: optional binary partitionTableBytes\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  8: optional Node header\n+}\n+\n+// follower -> leader\n+struct HeartBeatResponse {\n+  1: required long term\n+  2: optional long lastLogIndex // follower's meta log\n+  3: optional long lastLogTerm // follower's meta log\n+  // used to perform a catch up when necessary\n+  4: optional Node follower\n+  5: optional int followerIdentifier\n+  6: required bool requirePartitionTable\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+// node -> node\n+struct ElectionRequest {\n+  1: required long term\n+  2: required long lastLogTerm\n+  3: required long lastLogIndex\n+  4: required Node elector\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  5: optional Node header\n+  6: optional long dataLogLastIndex\n+  7: optional long dataLogLastTerm\n+}\n+\n+// leader -> follower\n+struct AppendEntryRequest {\n+  1: required long term // leader's\n+  2: required Node leader\n+  3: required long prevLogIndex\n+  4: required long prevLogTerm\n+  5: required long leaderCommit\n+  6: required binary entry // data\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+// leader -> follower\n+struct AppendEntriesRequest {\n+  1: required long term // leader's\n+  2: required Node leader\n+  3: required list<binary> entries // data\n+  4: required long prevLogIndex\n+  5: required long prevLogTerm\n+  6: required long leaderCommit\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+struct AddNodeResponse {\n+  // -1: accept to add new node or the node is already in this cluster, otherwise: fail to\n+  // add new node\n+  1: required int respNum\n+  2: optional binary partitionTableBytes\n+  3: optional CheckStatusResponse checkStatusResponse\n+}\n+\n+struct Node {\n+  1: required string ip\n+  2: required int metaPort\n+  3: required int nodeIdentifier\n+  4: required int dataPort\n+}\n+\n+// leader -> follower\n+struct StartUpStatus {\n+ 1: required long partitionInterval\n+ 2: required int hashSalt\n+ 3: required int replicationNumber\n+}\n+\n+// follower -> leader\n+struct CheckStatusResponse {\n+ 1: required bool partitionalIntervalEquals\n+ 2: required bool hashSaltEquals\n+ 3: required bool replicationNumEquals\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzNjE3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              **/\n          \n          \n            \n            \tHeartBeatResponse sendHeartbeat(1:HeartBeatRequest request);\n          \n          \n            \n              **/\n          \n          \n            \n              HeartBeatResponse sendHeartbeat(1:HeartBeatRequest request);", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426436170", "createdAt": "2020-05-18T07:59:30Z", "author": {"login": "HTHou"}, "path": "service-rpc/src/main/thrift/cluster.thrift", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+include \"rpc.thrift\"\n+namespace java org.apache.iotdb.cluster.rpc.thrift\n+\n+typedef i32 int \n+typedef i16 short\n+typedef i64 long\n+\n+// leader -> follower\n+struct HeartBeatRequest {\n+  1: required long term // leader's meta log\n+  2: required long commitLogIndex  // leader's meta log\n+  3: required long commitLogTerm\n+  4: required Node leader\n+  // if the leader does not know the follower's id, and require it reports to the leader, then true\n+  5: required bool requireIdentifier\n+  6: required bool regenerateIdentifier //if the leader finds the follower's id is conflicted,\n+  // then true\n+  // serialized partitionTable\n+  7: optional binary partitionTableBytes\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  8: optional Node header\n+}\n+\n+// follower -> leader\n+struct HeartBeatResponse {\n+  1: required long term\n+  2: optional long lastLogIndex // follower's meta log\n+  3: optional long lastLogTerm // follower's meta log\n+  // used to perform a catch up when necessary\n+  4: optional Node follower\n+  5: optional int followerIdentifier\n+  6: required bool requirePartitionTable\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+// node -> node\n+struct ElectionRequest {\n+  1: required long term\n+  2: required long lastLogTerm\n+  3: required long lastLogIndex\n+  4: required Node elector\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  5: optional Node header\n+  6: optional long dataLogLastIndex\n+  7: optional long dataLogLastTerm\n+}\n+\n+// leader -> follower\n+struct AppendEntryRequest {\n+  1: required long term // leader's\n+  2: required Node leader\n+  3: required long prevLogIndex\n+  4: required long prevLogTerm\n+  5: required long leaderCommit\n+  6: required binary entry // data\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+// leader -> follower\n+struct AppendEntriesRequest {\n+  1: required long term // leader's\n+  2: required Node leader\n+  3: required list<binary> entries // data\n+  4: required long prevLogIndex\n+  5: required long prevLogTerm\n+  6: required long leaderCommit\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+struct AddNodeResponse {\n+  // -1: accept to add new node or the node is already in this cluster, otherwise: fail to\n+  // add new node\n+  1: required int respNum\n+  2: optional binary partitionTableBytes\n+  3: optional CheckStatusResponse checkStatusResponse\n+}\n+\n+struct Node {\n+  1: required string ip\n+  2: required int metaPort\n+  3: required int nodeIdentifier\n+  4: required int dataPort\n+}\n+\n+// leader -> follower\n+struct StartUpStatus {\n+ 1: required long partitionInterval\n+ 2: required int hashSalt\n+ 3: required int replicationNumber\n+}\n+\n+// follower -> leader\n+struct CheckStatusResponse {\n+ 1: required bool partitionalIntervalEquals\n+ 2: required bool hashSaltEquals\n+ 3: required bool replicationNumEquals\n+}\n+\n+struct SendSnapshotRequest {\n+  1: required binary snapshotBytes\n+  // for data group\n+  2: optional Node header\n+}\n+\n+struct PullSnapshotRequest {\n+  1: required list<int> requiredSlots\n+  // for data group\n+  2: optional Node header\n+  // set to true if the previous holder has been removed from the cluster.\n+  // This will make the previous holder read-only so that different new\n+  // replicas can pull the same snapshot.\n+  3: required bool requireReadOnly\n+}\n+\n+struct PullSnapshotResp {\n+  1: optional map<int, binary> snapshotBytes\n+}\n+\n+struct ExecutNonQueryReq {\n+  1: required binary planBytes\n+  2: optional Node header\n+}\n+\n+struct PullSchemaRequest {\n+  1: required list<string> prefixPaths\n+  2: optional Node header\n+}\n+\n+struct PullSchemaResp {\n+  1: required binary schemaBytes\n+}\n+\n+struct SingleSeriesQueryRequest {\n+  1: required string path\n+  2: optional binary timeFilterBytes\n+  3: optional binary valueFilterBytes\n+  4: required long queryId\n+  5: required Node requester\n+  6: required Node header\n+  7: required int dataTypeOrdinal\n+  8: required set<string> deviceMeasurements\n+}\n+\n+struct PreviousFillRequest {\n+  1: required string path\n+  2: required long queryTime\n+  3: required long beforeRange\n+  4: required long queryId\n+  5: required Node requester\n+  6: required Node header\n+  7: required int dataTypeOrdinal\n+  8: required set<string> deviceMeasurements\n+}\n+\n+// the spec and load of a node, for query coordinating\n+struct TNodeStatus {\n+\n+}\n+\n+struct GetAggrResultRequest {\n+  1: required string path\n+  2: required list<string> aggregations\n+  3: required int dataTypeOrdinal\n+  4: optional binary timeFilterBytes\n+  5: required Node header\n+  6: required long queryId\n+  7: required Node requestor\n+  8: required set<string> deviceMeasurements\n+}\n+\n+struct GroupByRequest {\n+  1: required string path\n+  2: required int dataTypeOrdinal\n+  3: optional binary timeFilterBytes\n+  4: required long queryId\n+  5: required list<int> aggregationTypeOrdinals\n+  6: required Node header\n+  7: required Node requestor\n+  8: required set<string> deviceMeasurements\n+}\n+\n+service RaftService {\n+  /**\n+  * Leader will call this method to all followers to ensure its authority.\n+  * <br>For the receiver,\n+  * The method will check the authority of the leader.\n+  *\n+  * @param request information of the leader\n+  * @return if the leader is valid, HeartBeatResponse.term will set -1, and the follower will tell\n+  * leader its lastLogIndex; otherwise, the follower will tell the fake leader its term.\n+  **/\n+\tHeartBeatResponse sendHeartbeat(1:HeartBeatRequest request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzNjkzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n               /**\n          \n          \n            \n               * When a node is removed from the cluster, if it is not the meta leader, it cannot receive\n          \n          \n            \n               * the commit command by heartbeat since it has been removed, so the leader should tell it\n          \n          \n            \n               * directly that it is no longer in the cluster.\n          \n          \n            \n               **/\n          \n          \n            \n               void exile()\n          \n          \n            \n            \n          \n          \n            \n              /**\n          \n          \n            \n              * When a node is removed from the cluster, if it is not the meta leader, it cannot receive\n          \n          \n            \n              * the commit command by heartbeat since it has been removed, so the leader should tell it\n          \n          \n            \n              * directly that it is no longer in the cluster.\n          \n          \n            \n              **/\n          \n          \n            \n              void exile()", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426436931", "createdAt": "2020-05-18T08:00:47Z", "author": {"login": "HTHou"}, "path": "service-rpc/src/main/thrift/cluster.thrift", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+include \"rpc.thrift\"\n+namespace java org.apache.iotdb.cluster.rpc.thrift\n+\n+typedef i32 int \n+typedef i16 short\n+typedef i64 long\n+\n+// leader -> follower\n+struct HeartBeatRequest {\n+  1: required long term // leader's meta log\n+  2: required long commitLogIndex  // leader's meta log\n+  3: required long commitLogTerm\n+  4: required Node leader\n+  // if the leader does not know the follower's id, and require it reports to the leader, then true\n+  5: required bool requireIdentifier\n+  6: required bool regenerateIdentifier //if the leader finds the follower's id is conflicted,\n+  // then true\n+  // serialized partitionTable\n+  7: optional binary partitionTableBytes\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  8: optional Node header\n+}\n+\n+// follower -> leader\n+struct HeartBeatResponse {\n+  1: required long term\n+  2: optional long lastLogIndex // follower's meta log\n+  3: optional long lastLogTerm // follower's meta log\n+  // used to perform a catch up when necessary\n+  4: optional Node follower\n+  5: optional int followerIdentifier\n+  6: required bool requirePartitionTable\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+// node -> node\n+struct ElectionRequest {\n+  1: required long term\n+  2: required long lastLogTerm\n+  3: required long lastLogIndex\n+  4: required Node elector\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  5: optional Node header\n+  6: optional long dataLogLastIndex\n+  7: optional long dataLogLastTerm\n+}\n+\n+// leader -> follower\n+struct AppendEntryRequest {\n+  1: required long term // leader's\n+  2: required Node leader\n+  3: required long prevLogIndex\n+  4: required long prevLogTerm\n+  5: required long leaderCommit\n+  6: required binary entry // data\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+// leader -> follower\n+struct AppendEntriesRequest {\n+  1: required long term // leader's\n+  2: required Node leader\n+  3: required list<binary> entries // data\n+  4: required long prevLogIndex\n+  5: required long prevLogTerm\n+  6: required long leaderCommit\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+struct AddNodeResponse {\n+  // -1: accept to add new node or the node is already in this cluster, otherwise: fail to\n+  // add new node\n+  1: required int respNum\n+  2: optional binary partitionTableBytes\n+  3: optional CheckStatusResponse checkStatusResponse\n+}\n+\n+struct Node {\n+  1: required string ip\n+  2: required int metaPort\n+  3: required int nodeIdentifier\n+  4: required int dataPort\n+}\n+\n+// leader -> follower\n+struct StartUpStatus {\n+ 1: required long partitionInterval\n+ 2: required int hashSalt\n+ 3: required int replicationNumber\n+}\n+\n+// follower -> leader\n+struct CheckStatusResponse {\n+ 1: required bool partitionalIntervalEquals\n+ 2: required bool hashSaltEquals\n+ 3: required bool replicationNumEquals\n+}\n+\n+struct SendSnapshotRequest {\n+  1: required binary snapshotBytes\n+  // for data group\n+  2: optional Node header\n+}\n+\n+struct PullSnapshotRequest {\n+  1: required list<int> requiredSlots\n+  // for data group\n+  2: optional Node header\n+  // set to true if the previous holder has been removed from the cluster.\n+  // This will make the previous holder read-only so that different new\n+  // replicas can pull the same snapshot.\n+  3: required bool requireReadOnly\n+}\n+\n+struct PullSnapshotResp {\n+  1: optional map<int, binary> snapshotBytes\n+}\n+\n+struct ExecutNonQueryReq {\n+  1: required binary planBytes\n+  2: optional Node header\n+}\n+\n+struct PullSchemaRequest {\n+  1: required list<string> prefixPaths\n+  2: optional Node header\n+}\n+\n+struct PullSchemaResp {\n+  1: required binary schemaBytes\n+}\n+\n+struct SingleSeriesQueryRequest {\n+  1: required string path\n+  2: optional binary timeFilterBytes\n+  3: optional binary valueFilterBytes\n+  4: required long queryId\n+  5: required Node requester\n+  6: required Node header\n+  7: required int dataTypeOrdinal\n+  8: required set<string> deviceMeasurements\n+}\n+\n+struct PreviousFillRequest {\n+  1: required string path\n+  2: required long queryTime\n+  3: required long beforeRange\n+  4: required long queryId\n+  5: required Node requester\n+  6: required Node header\n+  7: required int dataTypeOrdinal\n+  8: required set<string> deviceMeasurements\n+}\n+\n+// the spec and load of a node, for query coordinating\n+struct TNodeStatus {\n+\n+}\n+\n+struct GetAggrResultRequest {\n+  1: required string path\n+  2: required list<string> aggregations\n+  3: required int dataTypeOrdinal\n+  4: optional binary timeFilterBytes\n+  5: required Node header\n+  6: required long queryId\n+  7: required Node requestor\n+  8: required set<string> deviceMeasurements\n+}\n+\n+struct GroupByRequest {\n+  1: required string path\n+  2: required int dataTypeOrdinal\n+  3: optional binary timeFilterBytes\n+  4: required long queryId\n+  5: required list<int> aggregationTypeOrdinals\n+  6: required Node header\n+  7: required Node requestor\n+  8: required set<string> deviceMeasurements\n+}\n+\n+service RaftService {\n+  /**\n+  * Leader will call this method to all followers to ensure its authority.\n+  * <br>For the receiver,\n+  * The method will check the authority of the leader.\n+  *\n+  * @param request information of the leader\n+  * @return if the leader is valid, HeartBeatResponse.term will set -1, and the follower will tell\n+  * leader its lastLogIndex; otherwise, the follower will tell the fake leader its term.\n+  **/\n+\tHeartBeatResponse sendHeartbeat(1:HeartBeatRequest request);\n+\n+\t/**\n+  * If a node wants to be a leader, it'll call the method to other nodes to get a vote.\n+  * <br>For the receiver,\n+  * The method will check whether the node can be a leader.\n+  *\n+  * @param voteRequest a candidate that wants to be a leader.\n+  * @return -1 means agree, otherwise return the voter's term\n+  **/\n+  long startElection(1:ElectionRequest request);\n+\n+  /**\n+  * Leader will call this method to send a batch of entries to all followers.\n+  * <br>For the receiver,\n+  * The method will check the authority of the leader and if the local log is complete.\n+  * If the leader is valid and local log is complete, the follower will append these entries to local log.\n+  *\n+  * @param request entries that need to be appended and the information of the leader.\n+  * @return -1: agree, -2: log index mismatch , otherwise return the follower's term\n+  **/\n+  long appendEntries(1:AppendEntriesRequest request)\n+\n+  /**\n+  * Leader will call this method to send a entry to all followers.\n+  * <br>For the receiver,\n+  * The method will check the authority of the leader and if the local log is complete.\n+  * If the leader is valid and local log is complete, the follower will append the entry to local log.\n+  *\n+  * @param request entry that needs to be appended and the information of the leader.\n+  * @return -1: agree, -2: log index mismatch , otherwise return the follower's term\n+  **/\n+  long appendEntry(1:AppendEntryRequest request)\n+\n+  void sendSnapshot(1:SendSnapshotRequest request)\n+\n+  /**\n+  * Execute a binarized non-query PhysicalPlan\n+  **/\n+  rpc.TSStatus executeNonQueryPlan(1:ExecutNonQueryReq request)\n+\n+  /**\n+  * Ask the leader for its commit index, used to check whether the node has caught up with the\n+  * leader.\n+  **/\n+  long requestCommitIndex(1:Node header)\n+\n+  binary readFile(1:string filePath, 2:i64 offset, 3:i32 length)\n+}\n+\n+\n+\n+service TSDataService extends RaftService {\n+\n+  /**\n+  * Query a time series without value filter.\n+  * @return a readerId >= 0 if the query succeeds, otherwise the query fails\n+  * TODO-Cluster: support query multiple series in a request\n+  **/\n+  long querySingleSeries(1:SingleSeriesQueryRequest request)\n+\n+  /**\n+  * Fetch at max fetchSize time-value pairs using the resultSetId generated by querySingleSeries.\n+  * @return a ByteBuffer containing the serialized time-value pairs or an empty buffer if there\n+  * are not more results.\n+  **/\n+  binary fetchSingleSeries(1:Node header, 2:long readerId)\n+\n+   /**\n+   * Query a time series and generate an IReaderByTimestamp.\n+   * @return a readerId >= 0 if the query succeeds, otherwise the query fails\n+   **/\n+  long querySingleSeriesByTimestamp(1:SingleSeriesQueryRequest request)\n+\n+   /**\n+   * Fetch one value at given timestamp using the resultSetId generated by\n+   * querySingleSeriesByTimestamp.\n+   * @return a ByteBuffer containing the serialized value or an empty buffer if there\n+   * are not more results.\n+   **/\n+   binary fetchSingleSeriesByTimestamp(1:Node header, 2:long readerId, 3:long timestamp)\n+\n+  /**\n+  * Find the local query established for the remote query and release all its resource.\n+  **/\n+  void endQuery(1:Node header, 2:Node thisNode, 3:long queryId)\n+\n+  /**\n+  * Given path patterns (paths with wildcard), return all paths they match.\n+  **/\n+  list<string> getAllPaths(1:Node header, 2:list<string> path)\n+\n+  /**\n+   * Given path patterns (paths with wildcard), return all devices they match.\n+   **/\n+  set<string> getAllDevices(1:Node header, 2:list<string> path)\n+\n+  list<string> getNodeList(1:Node header, 2:string path, 3:int nodeLevel)\n+\n+  set<string> getChildNodePathInNextLevel(1: Node header, 2: string path)\n+\n+  binary getAllMeasurementSchema(1: Node header, 2: binary planBinary)\n+\n+\n+  list<binary> getAggrResult(1:GetAggrResultRequest request)\n+\n+  PullSnapshotResp pullSnapshot(1:PullSnapshotRequest request)\n+\n+  /**\n+  * Create a GroupByExecutor for a path, executing the given aggregations.\n+  * @return the executorId\n+  **/\n+  long getGroupByExecutor(1:GroupByRequest request)\n+\n+  /**\n+  * Fetch the group by result in the interval [startTime, endTime) from the given executor.\n+  * @return the serialized AggregationResults, each is the result of one of the previously\n+  * required aggregations, and their orders are the same.\n+  **/\n+  list<binary> getGroupByResult(1:Node header, 2:long executorId, 3:long startTime, 4:long endTime)\n+\n+\n+  /**\n+  * Pull all timeseries schemas prefixed by a given path.\n+  **/\n+  PullSchemaResp pullTimeSeriesSchema(1: PullSchemaRequest request)\n+\n+  /**\n+  * Perform a previous fill and return the timevalue pair in binary.\n+  **/\n+  binary previousFill(1: PreviousFillRequest request)\n+}\n+\n+service TSMetaService extends RaftService {\n+  /**\n+  * Node which is not leader will call this method to try to add itself into the cluster as a new node.\n+  * <br>For the receiver,\n+  * If the local node is leader, it'll check whether the cluster can add this new node;\n+  * otherwise, the local node will transfer the request to the leader.\n+  *\n+  * @param node a new node that needs to be added\n+  **/\n+  AddNodeResponse addNode(1: Node node, 2: StartUpStatus startUpStatus)\n+\n+  /**\n+  * Remove a node from the cluster. If the node is not in the cluster or the cluster size will\n+  * less than replication number, the request will be rejected.\n+  * return -1(RESPONSE_AGREE) or -3(RESPONSE_REJECT) or -9(RESPONSE_CLUSTER_TOO_SMALL)\n+  **/\n+  long removeNode(1: Node node)\n+\n+   /**\n+   * When a node is removed from the cluster, if it is not the meta leader, it cannot receive\n+   * the commit command by heartbeat since it has been removed, so the leader should tell it\n+   * directly that it is no longer in the cluster.\n+   **/\n+   void exile()\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 381}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0MTMzNw==", "bodyText": "It will be better if you update the docs/UserGuide/4-Client/7-Status Codes.md file as well.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426441337", "createdAt": "2020-05-18T08:08:27Z", "author": {"login": "HTHou"}, "path": "service-rpc/src/main/java/org/apache/iotdb/rpc/TSStatusCode.java", "diffHunk": "@@ -63,10 +63,18 @@\n   READ_ONLY_SYSTEM_ERROR(502),\n   DISK_SPACE_INSUFFICIENT_ERROR(503),\n   START_UP_ERROR(504),\n+\n   WRONG_LOGIN_PASSWORD_ERROR(600),\n   NOT_LOGIN_ERROR(601),\n   NO_PERMISSION_ERROR(602),\n   UNINITIALIZED_AUTH_ERROR(603),\n+\n+  PARTITION_NOT_READY(700),\n+  TIME_OUT(701),\n+  NO_LEADER(702),\n+  UNSUPPORTED_OPERATION(703),\n+  NODE_READ_ONLY(704),\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0ODI3Nw==", "bodyText": "There are some number conflicts.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426448277", "createdAt": "2020-05-18T08:20:02Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/constant/SQLConstant.java", "diffHunk": "@@ -138,6 +138,8 @@ private SQLConstant() {\n   public static final int TOK_COUNT_TIMESERIES = 77;\n   public static final int TOK_COUNT_NODE_TIMESERIES = 78;\n   public static final int TOK_COUNT_NODES = 79;\n+  public static final int TOK_LOAD_CONFIGURATION_GLOBAL = 80;\n+  public static final int TOK_LOAD_CONFIGURATION_LOCAL = 81;\n \n   public static final int TOK_METADATA_ALTER = 80;\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ1MTc0Mg==", "bodyText": "There are a lot of format changes in this file. I don't think it's necessary.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426451742", "createdAt": "2020-05-18T08:25:42Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -163,7 +165,7 @@ public PlanExecutor() throws QueryProcessException {\n \n   @Override\n   public QueryDataSet processQuery(PhysicalPlan queryPlan, QueryContext context)\n-      throws IOException, StorageEngineException, QueryFilterOptimizationException,\n+          throws IOException, StorageEngineException, QueryFilterOptimizationException,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ1NDc2MQ==", "bodyText": "Format\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  queryDataSource = QueryResourceManager.getInstance()\n          \n          \n            \n                      .getQueryDataSource(path, context, timeFilter);\n          \n          \n            \n                queryDataSource = QueryResourceManager.getInstance()\n          \n          \n            \n                    .getQueryDataSource(path, context, timeFilter);", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426454761", "createdAt": "2020-05-18T08:30:13Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/LocalGroupByExecutor.java", "diffHunk": "@@ -49,11 +49,13 @@\n   private List<AggregateResult> results = new ArrayList<>();\n   private TimeRange timeRange;\n \n+  private QueryDataSource queryDataSource;\n+\n   public LocalGroupByExecutor(Path path, Set<String> allSensors, TSDataType dataType,\n       QueryContext context, Filter timeFilter, TsFileFilter fileFilter)\n       throws StorageEngineException, QueryProcessException {\n-    QueryDataSource queryDataSource =\n-        QueryResourceManager.getInstance().getQueryDataSource(path, context, timeFilter);\n+      queryDataSource = QueryResourceManager.getInstance()\n+          .getQueryDataSource(path, context, timeFilter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "780b426c1c16d61bf33c217face4b2a98ea15c0e", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/780b426c1c16d61bf33c217face4b2a98ea15c0e", "committedDate": "2020-05-18T09:48:12Z", "message": "fix sonar issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "898cede0b7ba6f2a103ce70f6c94d9a70d0c4f09", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/898cede0b7ba6f2a103ce70f6c94d9a70d0c4f09", "committedDate": "2020-05-19T02:33:41Z", "message": "Update service-rpc/src/main/thrift/cluster.thrift\n\nCo-authored-by: Haonan <hhaonan@outlook.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "135b8450ed5a5ec113f3d60bead389f8ad0d56b9", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/135b8450ed5a5ec113f3d60bead389f8ad0d56b9", "committedDate": "2020-05-19T02:33:58Z", "message": "Update service-rpc/src/main/thrift/cluster.thrift\n\nCo-authored-by: Haonan <hhaonan@outlook.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "207b2790d5bf7b722957291023333f2fda11ca39", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/207b2790d5bf7b722957291023333f2fda11ca39", "committedDate": "2020-05-19T02:34:07Z", "message": "Update service-rpc/src/main/thrift/cluster.thrift\n\nCo-authored-by: Haonan <hhaonan@outlook.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12b7aece1f98dce538c404cb692fd6d168555db2", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/12b7aece1f98dce538c404cb692fd6d168555db2", "committedDate": "2020-05-19T02:34:21Z", "message": "Update service-rpc/src/main/thrift/cluster.thrift\n\nCo-authored-by: Haonan <hhaonan@outlook.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a22c3b5006063b946a6fda95e21b2d469888295f", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/a22c3b5006063b946a6fda95e21b2d469888295f", "committedDate": "2020-05-19T02:40:02Z", "message": "fix by review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3892e24a979d931359ffc3869674130e152e8ac1", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/3892e24a979d931359ffc3869674130e152e8ac1", "committedDate": "2020-05-19T02:40:45Z", "message": "Merge branch 'cluster_premerge' of https://github.com/apache/incubator-iotdb into cluster_premerge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/495685e5bda7386e6f3551e3eba2d11a06c6ee6d", "committedDate": "2020-05-19T02:41:53Z", "message": "Merge branch 'master' into cluster_premerge\n\n# Conflicts:\n#\tserver/src/main/java/org/apache/iotdb/db/qp/constant/SQLConstant.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/126a946cbaa220f108894020eb5ccdcc1c0698a7", "committedDate": "2020-05-20T02:25:15Z", "message": "Merge branch 'master' into cluster_premerge"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMjkyMDMx", "url": "https://github.com/apache/iotdb/pull/1169#pullrequestreview-413292031", "createdAt": "2020-05-18T06:04:55Z", "commit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "state": "APPROVED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjowNDo1NVrOGWokug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMzo1NzozOVrOGX6aUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4NjYxOA==", "bodyText": "there is a field enableRPCCompression, better to change it to true", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426386618", "createdAt": "2020-05-18T06:04:55Z", "author": {"login": "qiaojialin"}, "path": "session/src/main/java/org/apache/iotdb/session/Session.java", "diffHunk": "@@ -105,7 +107,7 @@ public Session(String host, int port, String username, String password, int fetc\n   }\n \n   public synchronized void open() throws IoTDBConnectionException {\n-    open(false, Config.DEFAULT_TIMEOUT_MS);\n+    open(true, Config.DEFAULT_TIMEOUT_MS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM3MjUwMQ==", "bodyText": "in other methods the lock is used, but here synchronized this object, is there a concurrent error when using accessor?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427372501", "createdAt": "2020-05-19T15:00:14Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/auth/role/BasicRoleManager.java", "diffHunk": "@@ -167,4 +168,21 @@ public void reset() {\n     rtlist.sort(null);\n     return rtlist;\n   }\n+\n+  @Override\n+  public void replaceAllRoles(Map<String, Role> roles) throws AuthException {\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM3Mjg5NA==", "bodyText": "the same with BasicRoleManager", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427372894", "createdAt": "2020-05-19T15:00:43Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/auth/user/BasicUserManager.java", "diffHunk": "@@ -310,4 +311,23 @@ public void setUserUseWaterMark(String username, boolean useWaterMark) throws Au\n       throw new AuthException(e);\n     }\n   }\n+\n+\n+  @Override\n+  public void replaceAllUsers(Map<String, User> users) throws AuthException {\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4Mzc2Mg==", "bodyText": "retry?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427683762", "createdAt": "2020-05-20T01:01:05Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/modification/ModificationFile.java", "diffHunk": "@@ -125,4 +133,34 @@ public void remove() throws IOException {\n     FSFactoryProducer.getFSFactory().getFile(filePath).delete();\n   }\n \n+  public boolean exists() {\n+    return new File(filePath).exists();\n+  }\n+\n+  /**\n+   * Create a hardlink for the modification file.\n+   * The hardlink with have a suffix like \".{sysTime}_{randomLong}\"\n+   * @return a new ModificationFile with its path changed to the hardlink, or null if the origin\n+   * file does not exist or the hardlink cannot be created.\n+   */\n+  public ModificationFile createHardlink() {\n+    if (!exists()) {\n+      return null;\n+    }\n+\n+    while (true) {\n+      String hardlinkSuffix = \".\" + System.currentTimeMillis() + \"_\" + random.nextLong();\n+      File hardlink = new File(filePath + hardlinkSuffix);\n+\n+      try {\n+        Files.createLink(Paths.get(hardlink.getAbsolutePath()), Paths.get(filePath));\n+        return new ModificationFile(hardlink.getAbsolutePath());\n+      } catch (FileAlreadyExistsException e) {\n+        // retry a different name if the file is already created", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NzA1OA==", "bodyText": "how do we handle if trylock failed? ignore?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427697058", "createdAt": "2020-05-20T01:51:43Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1875,35 +1918,52 @@ public void removeFullyOverlapFiles(TsFileResource resource) {\n     closeQueryLock.writeLock().lock();\n     try {\n       Iterator<TsFileResource> iterator = sequenceFileTreeSet.iterator();\n-      removeFullyOverlapFiles(resource, iterator);\n+      removeFullyOverlapFiles(resource, iterator, true);\n \n       iterator = unSequenceFileList.iterator();\n-      removeFullyOverlapFiles(resource, iterator);\n+      removeFullyOverlapFiles(resource, iterator, false);\n     } finally {\n       closeQueryLock.writeLock().unlock();\n       writeUnlock();\n     }\n   }\n \n-  private void removeFullyOverlapFiles(TsFileResource resource, Iterator<TsFileResource> iterator) {\n+  private void removeFullyOverlapFiles(TsFileResource newTsFile, Iterator<TsFileResource> iterator\n+      , boolean isSeq) {\n     while (iterator.hasNext()) {\n-      TsFileResource seqFile = iterator.next();\n-      if (resource.getHistoricalVersions().containsAll(seqFile.getHistoricalVersions())\n-          && !resource.getHistoricalVersions().equals(seqFile.getHistoricalVersions())\n-          && seqFile.getWriteQueryLock().writeLock().tryLock()) {\n+      TsFileResource existingTsFile = iterator.next();\n+      if (newTsFile.getHistoricalVersions().containsAll(existingTsFile.getHistoricalVersions())\n+          && !newTsFile.getHistoricalVersions().equals(existingTsFile.getHistoricalVersions())\n+          && existingTsFile.tryWriteLock()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NzQ3Ng==", "bodyText": "this may take a long time, better add javadoc", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427697476", "createdAt": "2020-05-20T01:53:22Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1875,35 +1918,52 @@ public void removeFullyOverlapFiles(TsFileResource resource) {\n     closeQueryLock.writeLock().lock();\n     try {\n       Iterator<TsFileResource> iterator = sequenceFileTreeSet.iterator();\n-      removeFullyOverlapFiles(resource, iterator);\n+      removeFullyOverlapFiles(resource, iterator, true);\n \n       iterator = unSequenceFileList.iterator();\n-      removeFullyOverlapFiles(resource, iterator);\n+      removeFullyOverlapFiles(resource, iterator, false);\n     } finally {\n       closeQueryLock.writeLock().unlock();\n       writeUnlock();\n     }\n   }\n \n-  private void removeFullyOverlapFiles(TsFileResource resource, Iterator<TsFileResource> iterator) {\n+  private void removeFullyOverlapFiles(TsFileResource newTsFile, Iterator<TsFileResource> iterator\n+      , boolean isSeq) {\n     while (iterator.hasNext()) {\n-      TsFileResource seqFile = iterator.next();\n-      if (resource.getHistoricalVersions().containsAll(seqFile.getHistoricalVersions())\n-          && !resource.getHistoricalVersions().equals(seqFile.getHistoricalVersions())\n-          && seqFile.getWriteQueryLock().writeLock().tryLock()) {\n+      TsFileResource existingTsFile = iterator.next();\n+      if (newTsFile.getHistoricalVersions().containsAll(existingTsFile.getHistoricalVersions())\n+          && !newTsFile.getHistoricalVersions().equals(existingTsFile.getHistoricalVersions())\n+          && existingTsFile.tryWriteLock()) {\n         try {\n-          iterator.remove();\n-          seqFile.remove();\n+          removeFullyOverlapFile(existingTsFile, iterator, isSeq);\n         } catch (Exception e) {\n           logger.error(\"Something gets wrong while removing FullyOverlapFiles \", e);\n           throw e;\n         } finally {\n-          seqFile.getWriteQueryLock().writeLock().unlock();\n+          existingTsFile.writeUnlock();\n         }\n       }\n     }\n   }\n \n+  private void removeFullyOverlapFile(TsFileResource tsFileResource, Iterator<TsFileResource> iterator\n+      , boolean isSeq) {\n+    if (!tsFileResource.isClosed()) {\n+      // also remove the TsFileProcessor if the overlapped file is not closed\n+      long timePartition = tsFileResource.getTimePartition();\n+      Map<Long, TsFileProcessor> fileProcessorMap = isSeq ? workSequenceTsFileProcessors :\n+          workUnsequenceTsFileProcessors;\n+      TsFileProcessor tsFileProcessor = fileProcessorMap.get(timePartition);\n+      if (tsFileProcessor != null && tsFileProcessor.getTsFileResource() == tsFileResource) {\n+        tsFileProcessor.syncClose();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyNzQ0MA==", "bodyText": "it is obviously used...", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427727440", "createdAt": "2020-05-20T03:57:39Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -322,7 +323,13 @@ protected QueryDataSet processDataQuery(QueryPlan queryPlan, QueryContext contex\n     return queryDataSet;\n   }\n \n-  private QueryDataSet processShowQuery(ShowPlan showPlan)\n+  @SuppressWarnings(\"unused\")\n+  protected AlignByDeviceDataSet getAlignByDeviceDataSet(AlignByDevicePlan plan,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/3fa666caabef2aaa9c8583fae74b871369d19b75", "committedDate": "2020-05-20T11:58:49Z", "message": "fix by review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMzc3MzM4", "url": "https://github.com/apache/iotdb/pull/1169#pullrequestreview-413377338", "createdAt": "2020-05-18T08:30:00Z", "commit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODozMDowMFrOGWsuVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjoxMDowNVrOGYTRWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ1NDYxNQ==", "bodyText": "any UT?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426454615", "createdAt": "2020-05-18T08:30:00Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/antlr4/org/apache/iotdb/db/qp/strategy/SqlBase.g4", "diffHunk": "@@ -74,7 +74,7 @@ statement\n     | SHOW DEVICES prefixPath? #showDevices\n     | COUNT TIMESERIES prefixPath? (GROUP BY LEVEL OPERATOR_EQ INT)? #countTimeseries\n     | COUNT NODES prefixPath LEVEL OPERATOR_EQ INT #countNodes\n-    | LOAD CONFIGURATION #loadConfigurationStatement\n+    | LOAD CONFIGURATION (MINUS GLOBAL)? #loadConfigurationStatement", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTAyOQ==", "bodyText": "use the lock field of this class. (writeLock)", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426999029", "createdAt": "2020-05-19T02:47:24Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/auth/user/BasicUserManager.java", "diffHunk": "@@ -310,4 +311,23 @@ public void setUserUseWaterMark(String username, boolean useWaterMark) throws Au\n       throw new AuthException(e);\n     }\n   }\n+\n+\n+  @Override\n+  public void replaceAllUsers(Map<String, User> users) throws AuthException {\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTA5Ng==", "bodyText": "@neuyilan", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426999096", "createdAt": "2020-05-19T02:47:40Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/auth/user/BasicUserManager.java", "diffHunk": "@@ -310,4 +311,23 @@ public void setUserUseWaterMark(String username, boolean useWaterMark) throws Au\n       throw new AuthException(e);\n     }\n   }\n+\n+\n+  @Override\n+  public void replaceAllUsers(Map<String, User> users) throws AuthException {\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTAyOQ=="}, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTQ1OA==", "bodyText": "Not sure whether users having \"root\" user.\nIf it has, then initAdmin() in reset() is meaningless.\nIf it does not have, then you have to initAdmin() after this replacement.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426999458", "createdAt": "2020-05-19T02:49:01Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/auth/user/BasicUserManager.java", "diffHunk": "@@ -310,4 +311,23 @@ public void setUserUseWaterMark(String username, boolean useWaterMark) throws Au\n       throw new AuthException(e);\n     }\n   }\n+\n+\n+  @Override\n+  public void replaceAllUsers(Map<String, User> users) throws AuthException {\n+    synchronized (this) {\n+      reset();\n+      userMap = users;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxMjExNw==", "bodyText": "The same to userManager.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427012117", "createdAt": "2020-05-19T03:40:27Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/auth/role/BasicRoleManager.java", "diffHunk": "@@ -167,4 +168,21 @@ public void reset() {\n     rtlist.sort(null);\n     return rtlist;\n   }\n+\n+  @Override\n+  public void replaceAllRoles(Map<String, Role> roles) throws AuthException {\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3Mjk0NQ==", "bodyText": "why check null here? is there a bug before?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427472945", "createdAt": "2020-05-19T17:25:33Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -809,9 +808,10 @@ public void tryToUpdateInsertLastCache(InsertPlan plan, Long latestFlushedTime)\n       for (int i = 0; i < measurementList.length; i++) {\n         // Update cached last value with high priority\n         MNode measurementNode = node.getChild(measurementList[i]);\n-\n-        ((LeafMNode) measurementNode)\n-            .updateCachedLast(plan.composeTimeValuePair(i), true, latestFlushedTime);\n+        if (measurementNode != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NTE5OA==", "bodyText": "Long partition, Long version", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427475198", "createdAt": "2020-05-19T17:28:57Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1776,6 +1803,22 @@ public void loadNewTsFile(TsFileResource newTsFileResource) throws LoadFileExcep\n     }\n   }\n \n+  /**\n+   * Set the version in \"partition\" to \"version\" if \"version\" is larger than the current version.\n+   * @param partition\n+   * @param version\n+   */\n+  public void setPartitionFileVersionToMax(long partition, long version) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkzMTM5NA==", "bodyText": "hard to understand the javadoc.\nA tsFileResource is attached to a tsFile,  what is the meaning of \"when IOTDB has the same close file policy as the local one\".", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427931394", "createdAt": "2020-05-20T11:19:16Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -2215,9 +2275,41 @@ public String getStorageGroupName() {\n     return storageGroupName;\n   }\n \n+  /**\n+   * Check if the data of \"tsFileResource\" all exist locally by comparing the historical versions\n+   * in the partition of \"partitionNumber\". This is available only when the IoTDB which generated\n+   * \"tsFileResource\" has the same close file policy as the local one.\n+   * If one of the version in \"tsFileResource\" equals to a version of a working file, false is\n+   * also returned because \"tsFileResource\" may have unwritten data of that file.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0NTYzMw==", "bodyText": "I think we can mark this function as ForCluster, then the parameter tsFileResource  can be called remoteTsFileResource, and then the logic will be much easier to be understood.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427945633", "createdAt": "2020-05-20T11:47:51Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -2215,9 +2275,41 @@ public String getStorageGroupName() {\n     return storageGroupName;\n   }\n \n+  /**\n+   * Check if the data of \"tsFileResource\" all exist locally by comparing the historical versions\n+   * in the partition of \"partitionNumber\". This is available only when the IoTDB which generated\n+   * \"tsFileResource\" has the same close file policy as the local one.\n+   * If one of the version in \"tsFileResource\" equals to a version of a working file, false is\n+   * also returned because \"tsFileResource\" may have unwritten data of that file.\n+   * @param tsFileResource\n+   * @param partitionNum\n+   * @return true if the historicalVersions of \"tsFileResource\" is a subset of\n+   * partitionDirectFileVersions, or false if it is not a subset and it does not contain any\n+   * version of a working file\n+   */\n   public boolean isFileAlreadyExist(TsFileResource tsFileResource, long partitionNum) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0NzQ1OA==", "bodyText": "IMPORTANT.\ndon't use the absolute path in a tsfileResource. Otherwise it will be very hard to help users solving online problems.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427947458", "createdAt": "2020-05-20T11:51:25Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileResource.java", "diffHunk": "@@ -241,6 +244,10 @@ public void serialize() throws IOException {\n           ReadWriteIOUtils.write(historicalVersion, outputStream);\n         }\n       }\n+\n+      if (modFile != null && modFile.exists()) {\n+        ReadWriteIOUtils.write(modFile.getFilePath(), outputStream);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0Nzc1NA==", "bodyText": "will have", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427947754", "createdAt": "2020-05-20T11:52:03Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileResource.java", "diffHunk": "@@ -571,4 +603,56 @@ public long getTimePartitionWithCheck() throws PartitionViolationException {\n     }\n     return partitionId;\n   }\n+\n+  /**\n+   * Create a hardlink for the TsFile and modification file (if exists)\n+   * The hardlink with have a suffix like \".{sysTime}_{randomLong}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0ODIwNg==", "bodyText": "My another concern is, will the historicalVersion set be very large?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427948206", "createdAt": "2020-05-20T11:52:51Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileResource.java", "diffHunk": "@@ -571,4 +603,56 @@ public long getTimePartitionWithCheck() throws PartitionViolationException {\n     }\n     return partitionId;\n   }\n+\n+  /**\n+   * Create a hardlink for the TsFile and modification file (if exists)\n+   * The hardlink with have a suffix like \".{sysTime}_{randomLong}\"\n+   * @return a new TsFileResource with its file changed to the hardlink or null the hardlink\n+   * cannot be created.\n+   */\n+  public TsFileResource createHardlink() {\n+    if (!file.exists()) {\n+      return null;\n+    }\n+\n+    TsFileResource newResource;\n+    try {\n+      newResource = new TsFileResource(this);\n+    } catch (IOException e) {\n+      logger.error(\"Cannot create hardlink for {}\", file, e);\n+      return null;\n+    }\n+\n+    while (true) {\n+      String hardlinkSuffix = \".\" + System.currentTimeMillis() + \"_\" + random.nextLong();\n+      File hardlink = new File(file.getAbsolutePath() + hardlinkSuffix);\n+\n+      try {\n+        Files.createLink(Paths.get(hardlink.getAbsolutePath()), Paths.get(file.getAbsolutePath()));\n+        newResource.setFile(hardlink);\n+        if (modFile != null && modFile.exists()) {\n+          newResource.setModFile(modFile.createHardlink());\n+        }\n+        break;\n+      } catch (FileAlreadyExistsException e) {\n+        // retry a different name if the file is already created\n+      } catch (IOException e) {\n+        logger.error(\"Cannot create hardlink for {}\", file, e);\n+        return null;\n+      }\n+    }\n+    return newResource;\n+  }\n+\n+  public synchronized void setModFile(ModificationFile modFile) {\n+    this.modFile = modFile;\n+  }\n+\n+  public long getMaxVersion() {\n+    long maxVersion = 0;\n+    if (historicalVersions != null) {\n+      maxVersion = Collections.max(historicalVersions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk1MjQwNA==", "bodyText": "How about if mRemoteSchemaCache  has no the path?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427952404", "createdAt": "2020-05-20T12:00:43Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -565,6 +605,14 @@ public TSDataType getSeriesType(String path) throws MetadataException {\n       if (path.equals(SQLConstant.RESERVED_TIME)) {\n         return TSDataType.INT64;\n       }\n+\n+      try {\n+        MeasurementSchema schema = mRemoteSchemaCache.get(path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk1MzEyNw==", "bodyText": "why retry?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427953127", "createdAt": "2020-05-20T12:02:08Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -813,12 +861,33 @@ private boolean match(String fullPath, String[] prefixNodes) {\n     }\n   }\n \n-  public MeasurementSchema getSeriesSchema(String device, String measuremnet)\n+  public MeasurementSchema getSeriesSchema(String device, String measurement)\n       throws MetadataException {\n     lock.readLock().lock();\n     try {\n       InternalMNode node = (InternalMNode) mtree.getNodeByPath(device);\n-      return ((LeafMNode) node.getChild(measuremnet)).getSchema();\n+      MNode leaf = node.getChild(measurement);\n+      if (leaf != null) {\n+        return ((LeafMNode) leaf).getSchema();\n+      } else {\n+        return mRemoteSchemaCache\n+            .get(device + IoTDBConstant.PATH_SEPARATOR + measurement);\n+      }\n+    } catch (PathNotExistException e) {\n+      try {\n+        MeasurementSchema measurementSchema = mRemoteSchemaCache", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk1NDg1OA==", "bodyText": "hard to understand...", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427954858", "createdAt": "2020-05-20T12:05:33Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -1405,4 +1501,17 @@ public void collectSeries(String startingPath, List<MeasurementSchema> timeserie\n       lock.readLock().unlock();\n     }\n   }\n+\n+  public void cacheSchema(String path, MeasurementSchema schema) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk2MTA0MQ==", "bodyText": "What is the difference between showTimeseries and showTimeseriesWithIndex ?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427961041", "createdAt": "2020-05-20T12:16:18Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -523,6 +533,16 @@ private QueryDataSet getQueryDataSet(List<ShowTimeSeriesResult> timeseriesList)\n     return listDataSet;\n   }\n \n+  protected List<ShowTimeSeriesResult> showTimeseries(ShowTimeSeriesPlan plan)\n+      throws MetadataException {\n+    return MManager.getInstance().showTimeseries(plan);\n+  }\n+\n+  protected List<ShowTimeSeriesResult> showTimeseriesWithIndex(ShowTimeSeriesPlan plan)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk2NDUxMg==", "bodyText": "why create such a method??\nwhy not let the user call lock and unlock method explicitly. @JackieTien97", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427964512", "createdAt": "2020-05-20T12:21:49Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -864,43 +888,78 @@ public void delete(Path path, long timestamp) throws QueryProcessException {\n \n   @Override\n   public void insert(InsertPlan insertPlan) throws QueryProcessException {\n-    MNode node = null;\n     try {\n       String[] measurementList = insertPlan.getMeasurements();\n       String deviceId = insertPlan.getDeviceId();\n-      node = mManager.getDeviceNodeWithAutoCreateAndReadLock(deviceId);\n       String[] strValues = insertPlan.getValues();\n-      MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n-\n-      for (int i = 0; i < measurementList.length; i++) {\n-        String measurement = measurementList[i];\n-        if (!node.hasChild(measurement)) {\n-          if (!IoTDBDescriptor.getInstance().getConfig().isAutoCreateSchemaEnabled()) {\n-            throw new PathNotExistException(deviceId + PATH_SEPARATOR + measurement);\n-          }\n-          TSDataType dataType = TypeInferenceUtils.getPredictedDataType(strValues[i]);\n-          Path path = new Path(deviceId, measurement);\n-          internalCreateTimeseries(path.toString(), dataType);\n-        }\n-        LeafMNode measurementNode = (LeafMNode) node.getChild(measurement);\n-        schemas[i] = measurementNode.getSchema();\n-        // reset measurement to common name instead of alias\n-        measurementList[i] = measurementNode.getName();\n-      }\n-\n-      insertPlan.setMeasurements(measurementList);\n+      MeasurementSchema[] schemas = getSeriesSchemas(measurementList, deviceId, strValues);\n       insertPlan.setSchemas(schemas);\n       StorageEngine.getInstance().insert(insertPlan);\n     } catch (StorageEngineException | MetadataException e) {\n       throw new QueryProcessException(e);\n+    }\n+  }\n+\n+  protected MeasurementSchema[] getSeriesSchemas(String[] measurementList, String deviceId,\n+      String[] strValues) throws MetadataException {\n+    MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n+\n+    MNode node = null;\n+    try {\n+      node = mManager.getDeviceNodeWithAutoCreateAndReadLock(deviceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk2NTMxNw==", "bodyText": "For example, if this try-catch throws some RuntimeException (which PathNotExistException can not catch), then the lock is not released..", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427965317", "createdAt": "2020-05-20T12:23:00Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -864,43 +888,78 @@ public void delete(Path path, long timestamp) throws QueryProcessException {\n \n   @Override\n   public void insert(InsertPlan insertPlan) throws QueryProcessException {\n-    MNode node = null;\n     try {\n       String[] measurementList = insertPlan.getMeasurements();\n       String deviceId = insertPlan.getDeviceId();\n-      node = mManager.getDeviceNodeWithAutoCreateAndReadLock(deviceId);\n       String[] strValues = insertPlan.getValues();\n-      MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n-\n-      for (int i = 0; i < measurementList.length; i++) {\n-        String measurement = measurementList[i];\n-        if (!node.hasChild(measurement)) {\n-          if (!IoTDBDescriptor.getInstance().getConfig().isAutoCreateSchemaEnabled()) {\n-            throw new PathNotExistException(deviceId + PATH_SEPARATOR + measurement);\n-          }\n-          TSDataType dataType = TypeInferenceUtils.getPredictedDataType(strValues[i]);\n-          Path path = new Path(deviceId, measurement);\n-          internalCreateTimeseries(path.toString(), dataType);\n-        }\n-        LeafMNode measurementNode = (LeafMNode) node.getChild(measurement);\n-        schemas[i] = measurementNode.getSchema();\n-        // reset measurement to common name instead of alias\n-        measurementList[i] = measurementNode.getName();\n-      }\n-\n-      insertPlan.setMeasurements(measurementList);\n+      MeasurementSchema[] schemas = getSeriesSchemas(measurementList, deviceId, strValues);\n       insertPlan.setSchemas(schemas);\n       StorageEngine.getInstance().insert(insertPlan);\n     } catch (StorageEngineException | MetadataException e) {\n       throw new QueryProcessException(e);\n+    }\n+  }\n+\n+  protected MeasurementSchema[] getSeriesSchemas(String[] measurementList, String deviceId,\n+      String[] strValues) throws MetadataException {\n+    MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n+\n+    MNode node = null;\n+    try {\n+      node = mManager.getDeviceNodeWithAutoCreateAndReadLock(deviceId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk2NDUxMg=="}, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNzc5OQ==", "bodyText": "if transformOperatorTypeToAuthorType is only used by setAuthorType(AuthorType.values()[transformOperatorTypeToAuthorType(operatorType)]);, why not set the returned type as AuthorType directly?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428127799", "createdAt": "2020-05-20T15:59:54Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/sys/AuthorPlan.java", "diffHunk": "@@ -125,6 +130,58 @@ public AuthorPlan(AuthorOperator.AuthorType authorType, String userName, String\n     }\n   }\n \n+  public AuthorPlan(OperatorType operatorType) throws IOException {\n+    super(false, operatorType);\n+    setAuthorType(AuthorType.values()[transformOperatorTypeToAuthorType(operatorType)]);\n+  }\n+\n+  private int transformOperatorTypeToAuthorType(OperatorType operatorType)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyOTM4NA==", "bodyText": "format the code", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428129384", "createdAt": "2020-05-20T16:02:06Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java", "diffHunk": "@@ -201,7 +202,12 @@ public void enterRemoveFile(RemoveFileContext ctx) {\n   @Override\n   public void enterLoadConfigurationStatement(LoadConfigurationStatementContext ctx) {\n     super.enterLoadConfigurationStatement(ctx);\n-    initializedOperator = new LoadConfigurationOperator();\n+    if(ctx.GLOBAL()!=null){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMDQ3Nw==", "bodyText": "== true?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428130477", "createdAt": "2020-05-20T16:03:41Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/ShowTimeSeriesResult.java", "diffHunk": "@@ -68,4 +79,70 @@ public String getCompressor() {\n   public Map<String, String> getTagAndAttribute() {\n     return tagAndAttribute;\n   }\n+\n+  @Override\n+  public int compareTo(ShowTimeSeriesResult o) {\n+    return this.name.compareTo(o.name);\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    ShowTimeSeriesResult result = (ShowTimeSeriesResult) o;\n+    return Objects.equals(name, result.name);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(name);\n+  }\n+\n+  public void serialize(OutputStream outputStream) throws IOException {\n+    ReadWriteIOUtils.write(name, outputStream);\n+    ReadWriteIOUtils.write(alias != null, outputStream);\n+    if (alias != null) {\n+      ReadWriteIOUtils.write(alias, outputStream);\n+    }\n+    ReadWriteIOUtils.write(sgName, outputStream);\n+    ReadWriteIOUtils.write(dataType, outputStream);\n+    ReadWriteIOUtils.write(encoding, outputStream);\n+    ReadWriteIOUtils.write(compressor, outputStream);\n+\n+    ReadWriteIOUtils.write(tagAndAttribute != null, outputStream);\n+    if (tagAndAttribute != null) {\n+      ReadWriteIOUtils.write(tagAndAttribute.size(), outputStream);\n+      for (Entry<String, String> stringStringEntry : tagAndAttribute.entrySet()) {\n+        ReadWriteIOUtils.write(stringStringEntry.getKey(), outputStream);\n+        ReadWriteIOUtils.write(stringStringEntry.getValue(), outputStream);\n+      }\n+    }\n+  }\n+\n+  public static ShowTimeSeriesResult deserialize(ByteBuffer buffer) {\n+    ShowTimeSeriesResult result = new ShowTimeSeriesResult();\n+    result.name = ReadWriteIOUtils.readString(buffer);\n+    if (buffer.get() == 1) {\n+      result.alias = ReadWriteIOUtils.readString(buffer);\n+    }\n+    result.sgName = ReadWriteIOUtils.readString(buffer);\n+    result.dataType = ReadWriteIOUtils.readString(buffer);\n+    result.encoding = ReadWriteIOUtils.readString(buffer);\n+    result.compressor = ReadWriteIOUtils.readString(buffer);\n+\n+    if (buffer.get() == 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMjgxNA==", "bodyText": "what for? maybe we need to separate the time_out between the single node and cluster.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428132814", "createdAt": "2020-05-20T16:07:09Z", "author": {"login": "jixuan1989"}, "path": "service-rpc/src/main/java/org/apache/iotdb/rpc/TSStatusCode.java", "diffHunk": "@@ -63,10 +63,19 @@\n   READ_ONLY_SYSTEM_ERROR(502),\n   DISK_SPACE_INSUFFICIENT_ERROR(503),\n   START_UP_ERROR(504),\n+\n   WRONG_LOGIN_PASSWORD_ERROR(600),\n   NOT_LOGIN_ERROR(601),\n   NO_PERMISSION_ERROR(602),\n   UNINITIALIZED_AUTH_ERROR(603),\n+\n+  // TODO-Cluster: update docs when ready to merge\n+  PARTITION_NOT_READY(700),\n+  TIME_OUT(701),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzNDc0NA==", "bodyText": "How about merge this class and SerializeUtils.java", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428134744", "createdAt": "2020-05-20T16:10:05Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/utils/ReadWriteIOUtils.java", "diffHunk": "@@ -326,6 +326,15 @@ public static int write(ByteBuffer byteBuffer, OutputStream outputStream) throws\n     return len;\n   }\n \n+  /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf7d6a54d365e34d3b4507a342f25c39f3bc68a0", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/cf7d6a54d365e34d3b4507a342f25c39f3bc68a0", "committedDate": "2020-05-21T02:51:32Z", "message": "fix by review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32beaa0c2f4b3d16dd405c3df74c3affd3eea5e1", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/32beaa0c2f4b3d16dd405c3df74c3affd3eea5e1", "committedDate": "2020-05-21T05:38:42Z", "message": "change return type of transformOperatorTypeToAuthorType"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b16379dce6c7f2941ca590ba31e6e3d5c2061694", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/b16379dce6c7f2941ca590ba31e6e3d5c2061694", "committedDate": "2020-05-21T06:01:04Z", "message": "add comments for replace users and roles"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54f3de44ad78e68daaf8f35b6275740b9966452e", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/54f3de44ad78e68daaf8f35b6275740b9966452e", "committedDate": "2020-05-25T03:48:33Z", "message": "Merge branch 'master' into cluster_premerge\n\n# Conflicts:\n#\tserver/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java\n#\tserver/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java\n#\tserver/src/test/java/org/apache/iotdb/db/qp/plan/PhysicalPlanTest.java\n#\tsession/src/main/java/org/apache/iotdb/session/Session.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fa3907f0d1053e4573d3282a7847a986c627553", "author": {"user": null}, "url": "https://github.com/apache/iotdb/commit/3fa3907f0d1053e4573d3282a7847a986c627553", "committedDate": "2020-05-25T05:07:28Z", "message": "add comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9aa51cc2deb22453fd3688b02861c6ca8af765b4", "author": {"user": null}, "url": "https://github.com/apache/iotdb/commit/9aa51cc2deb22453fd3688b02861c6ca8af765b4", "committedDate": "2020-05-25T05:07:46Z", "message": "Merge branch 'cluster_premerge' of github.com:apache/incubator-iotdb into cluster_premerge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e78fabc23e873ccc1cc68d6c1a60f78930aea609", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/e78fabc23e873ccc1cc68d6c1a60f78930aea609", "committedDate": "2020-05-25T06:31:39Z", "message": "use relative path in mod file serialization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "598718e3ded0ebcb4f0c18211d7d3c0955148658", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/598718e3ded0ebcb4f0c18211d7d3c0955148658", "committedDate": "2020-05-26T03:48:50Z", "message": "Merge branch 'master' into cluster_premerge\n\n# Conflicts:\n#\tserver/src/test/java/org/apache/iotdb/db/qp/plan/PhysicalPlanTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57f1cbf422505b62fdfbe854e21500c6254c9dcf", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/57f1cbf422505b62fdfbe854e21500c6254c9dcf", "committedDate": "2020-06-03T02:43:55Z", "message": "Merge branch 'master' into cluster_premerge\n\n# Conflicts:\n#\tserver/src/main/antlr4/org/apache/iotdb/db/qp/strategy/SqlBase.g4\n#\tserver/src/main/java/org/apache/iotdb/db/auth/authorizer/BasicAuthorizer.java\n#\tserver/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n#\tserver/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n#\tserver/src/main/java/org/apache/iotdb/db/qp/physical/crud/InsertPlan.java\n#\tserver/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java\n#\tserver/src/test/java/org/apache/iotdb/db/qp/plan/PhysicalPlanTest.java\n#\tserver/src/test/java/org/apache/iotdb/db/tools/WalCheckerTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "998e97efa8ccc29eeabd1dc83fa11eec74ee0628", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/998e97efa8ccc29eeabd1dc83fa11eec74ee0628", "committedDate": "2020-06-03T02:48:23Z", "message": "fix wal checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae777e618c6bdf5cfccae20ccf707a09f3b94674", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/ae777e618c6bdf5cfccae20ccf707a09f3b94674", "committedDate": "2020-06-03T03:06:34Z", "message": "fix WalCheckerTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b39ef93d67c03de98556b16b00b5ec533a0a424", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/8b39ef93d67c03de98556b16b00b5ec533a0a424", "committedDate": "2020-06-03T03:26:16Z", "message": "disable Thrift compression by default"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea5d72a277fa89f78c0288b26e9d80ee77e485d0", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/ea5d72a277fa89f78c0288b26e9d80ee77e485d0", "committedDate": "2020-06-03T03:27:55Z", "message": "disable thrift compression in onfig"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d9e103ec851aca1563534908d7cdf7e0e299caa", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/2d9e103ec851aca1563534908d7cdf7e0e299caa", "committedDate": "2020-06-03T03:37:43Z", "message": "remove exception in remote cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be02cba64c5cdaee6e65cd7e8157c299d5f59e19", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/be02cba64c5cdaee6e65cd7e8157c299d5f59e19", "committedDate": "2020-06-03T04:06:20Z", "message": "disable compression in session pool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a39afecc7413d9c5b923b3537614f3b9d65f6c66", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/a39afecc7413d9c5b923b3537614f3b9d65f6c66", "committedDate": "2020-06-03T04:27:17Z", "message": "fix SessionPoolTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b9821f6ca4e3a77dce82158b939f7fd7c2206b2", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/9b9821f6ca4e3a77dce82158b939f7fd7c2206b2", "committedDate": "2020-06-04T02:27:09Z", "message": "Merge branch 'master' into cluster_premerge\n\n# Conflicts:\n#\tserver/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n#\tserver/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3b1d434ba257ea795e67de79ac3419c4be3ff3e", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/d3b1d434ba257ea795e67de79ac3419c4be3ff3e", "committedDate": "2020-06-04T03:23:09Z", "message": "remove while"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e259a2f5f34ef73d710aa55b41cb2c1bee561068", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/e259a2f5f34ef73d710aa55b41cb2c1bee561068", "committedDate": "2020-06-04T03:26:57Z", "message": "fix when schema is null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51c2ade26c3bd9b757bc1b7ccbb7db1e34c1bc0f", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/51c2ade26c3bd9b757bc1b7ccbb7db1e34c1bc0f", "committedDate": "2020-06-05T02:41:51Z", "message": "Merge branch 'master' into cluster_premerge\n\n# Conflicts:\n#\tserver/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java\n#\tserver/src/main/java/org/apache/iotdb/db/metadata/MManager.java\n#\tserver/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9b865063d164454b167556521576dd0888763e6", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/a9b865063d164454b167556521576dd0888763e6", "committedDate": "2020-06-08T02:25:14Z", "message": "Merge branch 'master' into cluster_premerge\n\n# Conflicts:\n#\tserver/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n#\tserver/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47047a3d827bc7a2286c8d33b1dedc0a17876ec9", "author": {"user": {"login": "jt2594838", "name": "Jiang Tian"}}, "url": "https://github.com/apache/iotdb/commit/47047a3d827bc7a2286c8d33b1dedc0a17876ec9", "committedDate": "2020-06-08T02:45:44Z", "message": "fix test"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3831, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}