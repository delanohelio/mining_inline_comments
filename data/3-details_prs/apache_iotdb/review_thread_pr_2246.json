{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1OTE0NTYw", "number": 2246, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjoxNToyNlrOFD9XWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjozNzoxOVrOFD92bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5Njk1NDUwOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/utils/MemUtilsTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjoxNToyNlrOID2RUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjoxNToyNlrOID2RUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkwNTgxMQ==", "bodyText": "What about seperating this single test to two? I think it's better to keep the test atomic.", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540905811", "createdAt": "2020-12-11T12:15:26Z", "author": {"login": "Alima777"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/MemUtilsTest.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.physical.crud.InsertTabletPlan;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.write.record.TSRecord;\n+import org.apache.iotdb.tsfile.write.record.datapoint.*;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MemUtilsTest {\n+\n+  @Test\n+  public void recordSizeTest() throws IllegalPathException {\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.INT32, 10, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.INT64, 10, true));\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.FLOAT, 10.0, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.DOUBLE, 10.0, true));\n+    Assert.assertEquals(8, MemUtils.getRecordSize(TSDataType.TEXT, \"10\", false));\n+\n+    PartialPath device = new PartialPath(\"root.sg.d1\");\n+    String[] measurements = {\"s1\", \"s2\", \"s3\", \"s4\", \"s5\"};\n+    List<Integer> dataTypes = new ArrayList<>();\n+    int sizeSum = 0;\n+    dataTypes.add(TSDataType.INT32.ordinal());\n+    sizeSum += 8 + TSDataType.INT32.getDataTypeSize();\n+    dataTypes.add(TSDataType.INT64.ordinal());\n+    sizeSum += 8 + TSDataType.INT64.getDataTypeSize();\n+    dataTypes.add(TSDataType.FLOAT.ordinal());\n+    sizeSum += 8 + TSDataType.FLOAT.getDataTypeSize();\n+    dataTypes.add(TSDataType.DOUBLE.ordinal());\n+    sizeSum += 8 + TSDataType.DOUBLE.getDataTypeSize();\n+    dataTypes.add(TSDataType.TEXT.ordinal());\n+    sizeSum += TSDataType.TEXT.getDataTypeSize();\n+    InsertTabletPlan insertPlan = new InsertTabletPlan(device, measurements, dataTypes);\n+    Assert.assertEquals(sizeSum, MemUtils.getRecordSize(insertPlan, 0, 1, false));\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5Njk3OTEyOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/utils/MemUtilsTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjoyMjoxOVrOID2fjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjoyMjoxOVrOID2fjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkwOTQ1NQ==", "bodyText": "TsRecordSizeTest -> TsRecordMemTest. And add javadoc for this test, it tests getDataPointMem() and getTsRecordMem().", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540909455", "createdAt": "2020-12-11T12:22:19Z", "author": {"login": "Alima777"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/MemUtilsTest.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.physical.crud.InsertTabletPlan;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.write.record.TSRecord;\n+import org.apache.iotdb.tsfile.write.record.datapoint.*;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MemUtilsTest {\n+\n+  @Test\n+  public void recordSizeTest() throws IllegalPathException {\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.INT32, 10, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.INT64, 10, true));\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.FLOAT, 10.0, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.DOUBLE, 10.0, true));\n+    Assert.assertEquals(8, MemUtils.getRecordSize(TSDataType.TEXT, \"10\", false));\n+\n+    PartialPath device = new PartialPath(\"root.sg.d1\");\n+    String[] measurements = {\"s1\", \"s2\", \"s3\", \"s4\", \"s5\"};\n+    List<Integer> dataTypes = new ArrayList<>();\n+    int sizeSum = 0;\n+    dataTypes.add(TSDataType.INT32.ordinal());\n+    sizeSum += 8 + TSDataType.INT32.getDataTypeSize();\n+    dataTypes.add(TSDataType.INT64.ordinal());\n+    sizeSum += 8 + TSDataType.INT64.getDataTypeSize();\n+    dataTypes.add(TSDataType.FLOAT.ordinal());\n+    sizeSum += 8 + TSDataType.FLOAT.getDataTypeSize();\n+    dataTypes.add(TSDataType.DOUBLE.ordinal());\n+    sizeSum += 8 + TSDataType.DOUBLE.getDataTypeSize();\n+    dataTypes.add(TSDataType.TEXT.ordinal());\n+    sizeSum += TSDataType.TEXT.getDataTypeSize();\n+    InsertTabletPlan insertPlan = new InsertTabletPlan(device, measurements, dataTypes);\n+    Assert.assertEquals(sizeSum, MemUtils.getRecordSize(insertPlan, 0, 1, false));\n+  }\n+\n+  @Test\n+  public void TsRecordSizeTest() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5Njk3OTgwOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/utils/MemUtilsTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjoyMjozNVrOID2f-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjoyMjozNVrOID2f-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkwOTU2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                totalSize += 8 * record.dataPointList.size() + MemUtils.getStringMem(device)+ 16;\n          \n          \n            \n                totalSize += 8 * record.dataPointList.size() + MemUtils.getStringMem(device) + 16;", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540909562", "createdAt": "2020-12-11T12:22:35Z", "author": {"login": "Alima777"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/MemUtilsTest.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.physical.crud.InsertTabletPlan;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.write.record.TSRecord;\n+import org.apache.iotdb.tsfile.write.record.datapoint.*;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MemUtilsTest {\n+\n+  @Test\n+  public void recordSizeTest() throws IllegalPathException {\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.INT32, 10, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.INT64, 10, true));\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.FLOAT, 10.0, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.DOUBLE, 10.0, true));\n+    Assert.assertEquals(8, MemUtils.getRecordSize(TSDataType.TEXT, \"10\", false));\n+\n+    PartialPath device = new PartialPath(\"root.sg.d1\");\n+    String[] measurements = {\"s1\", \"s2\", \"s3\", \"s4\", \"s5\"};\n+    List<Integer> dataTypes = new ArrayList<>();\n+    int sizeSum = 0;\n+    dataTypes.add(TSDataType.INT32.ordinal());\n+    sizeSum += 8 + TSDataType.INT32.getDataTypeSize();\n+    dataTypes.add(TSDataType.INT64.ordinal());\n+    sizeSum += 8 + TSDataType.INT64.getDataTypeSize();\n+    dataTypes.add(TSDataType.FLOAT.ordinal());\n+    sizeSum += 8 + TSDataType.FLOAT.getDataTypeSize();\n+    dataTypes.add(TSDataType.DOUBLE.ordinal());\n+    sizeSum += 8 + TSDataType.DOUBLE.getDataTypeSize();\n+    dataTypes.add(TSDataType.TEXT.ordinal());\n+    sizeSum += TSDataType.TEXT.getDataTypeSize();\n+    InsertTabletPlan insertPlan = new InsertTabletPlan(device, measurements, dataTypes);\n+    Assert.assertEquals(sizeSum, MemUtils.getRecordSize(insertPlan, 0, 1, false));\n+  }\n+\n+  @Test\n+  public void TsRecordSizeTest() {\n+    int totalSize = 0;\n+    String device = \"root.sg.d1\";\n+    TSRecord record = new TSRecord(0, device);\n+\n+    DataPoint point1 = new IntDataPoint(\"s1\", 1);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s1\") + 20, MemUtils.getDataPointMem(point1));\n+    totalSize += MemUtils.getDataPointMem(point1);\n+    record.addTuple(point1);\n+\n+    DataPoint point2 = new LongDataPoint(\"s2\", 1);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s2\") + 24, MemUtils.getDataPointMem(point2));\n+    totalSize += MemUtils.getDataPointMem(point2);\n+    record.addTuple(point2);\n+\n+    DataPoint point3 = new FloatDataPoint(\"s3\", 1.0f);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s3\") + 20, MemUtils.getDataPointMem(point3));\n+    totalSize += MemUtils.getDataPointMem(point3);\n+    record.addTuple(point3);\n+\n+    DataPoint point4 = new DoubleDataPoint(\"s4\", 1.0d);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s4\") + 24, MemUtils.getDataPointMem(point4));\n+    totalSize += MemUtils.getDataPointMem(point4);\n+    record.addTuple(point4);\n+\n+    DataPoint point5 = new BooleanDataPoint(\"s5\", true);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s5\") + 17, MemUtils.getDataPointMem(point5));\n+    totalSize += MemUtils.getDataPointMem(point5);\n+    record.addTuple(point5);\n+\n+    totalSize += 8 * record.dataPointList.size() + MemUtils.getStringMem(device)+ 16;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5Njk4MzU2OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/utils/MemUtilsTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjoyMzo0MFrOID2iLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjoyMzo0MFrOID2iLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkxMDEyNQ==", "bodyText": "Why not check StringDataPoint?", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540910125", "createdAt": "2020-12-11T12:23:40Z", "author": {"login": "Alima777"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/MemUtilsTest.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.physical.crud.InsertTabletPlan;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.write.record.TSRecord;\n+import org.apache.iotdb.tsfile.write.record.datapoint.*;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MemUtilsTest {\n+\n+  @Test\n+  public void recordSizeTest() throws IllegalPathException {\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.INT32, 10, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.INT64, 10, true));\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.FLOAT, 10.0, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.DOUBLE, 10.0, true));\n+    Assert.assertEquals(8, MemUtils.getRecordSize(TSDataType.TEXT, \"10\", false));\n+\n+    PartialPath device = new PartialPath(\"root.sg.d1\");\n+    String[] measurements = {\"s1\", \"s2\", \"s3\", \"s4\", \"s5\"};\n+    List<Integer> dataTypes = new ArrayList<>();\n+    int sizeSum = 0;\n+    dataTypes.add(TSDataType.INT32.ordinal());\n+    sizeSum += 8 + TSDataType.INT32.getDataTypeSize();\n+    dataTypes.add(TSDataType.INT64.ordinal());\n+    sizeSum += 8 + TSDataType.INT64.getDataTypeSize();\n+    dataTypes.add(TSDataType.FLOAT.ordinal());\n+    sizeSum += 8 + TSDataType.FLOAT.getDataTypeSize();\n+    dataTypes.add(TSDataType.DOUBLE.ordinal());\n+    sizeSum += 8 + TSDataType.DOUBLE.getDataTypeSize();\n+    dataTypes.add(TSDataType.TEXT.ordinal());\n+    sizeSum += TSDataType.TEXT.getDataTypeSize();\n+    InsertTabletPlan insertPlan = new InsertTabletPlan(device, measurements, dataTypes);\n+    Assert.assertEquals(sizeSum, MemUtils.getRecordSize(insertPlan, 0, 1, false));\n+  }\n+\n+  @Test\n+  public void TsRecordSizeTest() {\n+    int totalSize = 0;\n+    String device = \"root.sg.d1\";\n+    TSRecord record = new TSRecord(0, device);\n+\n+    DataPoint point1 = new IntDataPoint(\"s1\", 1);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s1\") + 20, MemUtils.getDataPointMem(point1));\n+    totalSize += MemUtils.getDataPointMem(point1);\n+    record.addTuple(point1);\n+\n+    DataPoint point2 = new LongDataPoint(\"s2\", 1);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s2\") + 24, MemUtils.getDataPointMem(point2));\n+    totalSize += MemUtils.getDataPointMem(point2);\n+    record.addTuple(point2);\n+\n+    DataPoint point3 = new FloatDataPoint(\"s3\", 1.0f);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s3\") + 20, MemUtils.getDataPointMem(point3));\n+    totalSize += MemUtils.getDataPointMem(point3);\n+    record.addTuple(point3);\n+\n+    DataPoint point4 = new DoubleDataPoint(\"s4\", 1.0d);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s4\") + 24, MemUtils.getDataPointMem(point4));\n+    totalSize += MemUtils.getDataPointMem(point4);\n+    record.addTuple(point4);\n+\n+    DataPoint point5 = new BooleanDataPoint(\"s5\", true);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s5\") + 17, MemUtils.getDataPointMem(point5));\n+    totalSize += MemUtils.getDataPointMem(point5);\n+    record.addTuple(point5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5Njk4OTk3OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjoyNTozMFrOID2l7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjoyNTozMFrOID2l7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkxMTA4NQ==", "bodyText": "I don't think serdes is a good abbreviation...", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540911085", "createdAt": "2020-12-11T12:25:30Z", "author": {"login": "Alima777"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SerializeUtilsTest {\n+  @Test\n+  public void serdesStringTest() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NzAwNDQ3OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjoyOToxM1rOID2t2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjoyOToxM1rOID2t2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkxMzExNA==", "bodyText": "Hi, I checked the name of this method in SerializeUtils, which called just serialize. FMP, it's better to rename it.\nserialize -> serializeIntList,  serialize -> serializeIntSet...", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540913114", "createdAt": "2020-12-11T12:29:13Z", "author": {"login": "Alima777"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SerializeUtilsTest {\n+  @Test\n+  public void serdesStringTest() {\n+    String str = \"abcd%+/123\\n\\t\";\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(str, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(str, SerializeUtils.deserializeString(buffer));\n+  }\n+\n+  @Test\n+  public void serdesStringListTest() {\n+    List<String> slist = Arrays.asList(\"abc\", \"123\", \"y87@\", \"9+&d\\n\");\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeStringList(slist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(slist, SerializeUtils.deserializeStringList(buffer));\n+  }\n+\n+  @Test\n+  public void serdesIntListTest() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NzAyMDAwOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjozMzozM1rOID22yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjozMzozM1rOID22yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkxNTQwMg==", "bodyText": "Actually, there are three types of BatchData, and two of them are subClass of BatchData. You should test them all.", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540915402", "createdAt": "2020-12-11T12:33:33Z", "author": {"login": "Alima777"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SerializeUtilsTest {\n+  @Test\n+  public void serdesStringTest() {\n+    String str = \"abcd%+/123\\n\\t\";\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(str, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(str, SerializeUtils.deserializeString(buffer));\n+  }\n+\n+  @Test\n+  public void serdesStringListTest() {\n+    List<String> slist = Arrays.asList(\"abc\", \"123\", \"y87@\", \"9+&d\\n\");\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeStringList(slist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(slist, SerializeUtils.deserializeStringList(buffer));\n+  }\n+\n+  @Test\n+  public void serdesIntListTest() {\n+    List<Integer> intlist = Arrays.asList(12, 34, 567, 8910);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(intlist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    List<Integer> anotherIntlist = new ArrayList<>();\n+    SerializeUtils.deserialize(anotherIntlist, buffer);\n+    Assert.assertEquals(intlist, anotherIntlist);\n+  }\n+\n+  @Test\n+  public void serdesIntSetTest() {\n+    List<Integer> intlist = Arrays.asList(12, 34, 567, 8910);\n+    Set<Integer> intSet = new TreeSet<>(intlist);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(intSet, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    List<Integer> anotherIntlist = new ArrayList<>();\n+    SerializeUtils.deserialize(anotherIntlist, buffer);\n+    Assert.assertEquals(intlist, anotherIntlist);\n+  }\n+\n+  @Test\n+  public void serdesNodeTest() {\n+    Node node = new Node(\"127.0.0.1\", 6667, 1, 6535, 4678);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(node, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Node anotherNode = new Node(\"127.0.0.1\", 6667, 1, 6535, 4678);\n+    SerializeUtils.deserialize(anotherNode, buffer);\n+    Assert.assertEquals(node, anotherNode);\n+  }\n+\n+  @Test\n+  public void serdesINT32BatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.INT32);\n+    int ivalue = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NzAyODY1OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjozNTo1MVrOID27ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjozNTo1MVrOID27ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkxNjYzOA==", "bodyText": "Add javadoc for this and the next test.", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540916638", "createdAt": "2020-12-11T12:35:51Z", "author": {"login": "Alima777"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SerializeUtilsTest {\n+  @Test\n+  public void serdesStringTest() {\n+    String str = \"abcd%+/123\\n\\t\";\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(str, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(str, SerializeUtils.deserializeString(buffer));\n+  }\n+\n+  @Test\n+  public void serdesStringListTest() {\n+    List<String> slist = Arrays.asList(\"abc\", \"123\", \"y87@\", \"9+&d\\n\");\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeStringList(slist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(slist, SerializeUtils.deserializeStringList(buffer));\n+  }\n+\n+  @Test\n+  public void serdesIntListTest() {\n+    List<Integer> intlist = Arrays.asList(12, 34, 567, 8910);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(intlist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    List<Integer> anotherIntlist = new ArrayList<>();\n+    SerializeUtils.deserialize(anotherIntlist, buffer);\n+    Assert.assertEquals(intlist, anotherIntlist);\n+  }\n+\n+  @Test\n+  public void serdesIntSetTest() {\n+    List<Integer> intlist = Arrays.asList(12, 34, 567, 8910);\n+    Set<Integer> intSet = new TreeSet<>(intlist);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(intSet, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    List<Integer> anotherIntlist = new ArrayList<>();\n+    SerializeUtils.deserialize(anotherIntlist, buffer);\n+    Assert.assertEquals(intlist, anotherIntlist);\n+  }\n+\n+  @Test\n+  public void serdesNodeTest() {\n+    Node node = new Node(\"127.0.0.1\", 6667, 1, 6535, 4678);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(node, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Node anotherNode = new Node(\"127.0.0.1\", 6667, 1, 6535, 4678);\n+    SerializeUtils.deserialize(anotherNode, buffer);\n+    Assert.assertEquals(node, anotherNode);\n+  }\n+\n+  @Test\n+  public void serdesINT32BatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.INT32);\n+    int ivalue = 0;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, ivalue);\n+      ivalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesINT64BatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.INT64);\n+    long lvalue = 0;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, lvalue);\n+      lvalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesFLOATBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.FLOAT);\n+    float fvalue = 0f;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, fvalue);\n+      fvalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesDOUBLEBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.DOUBLE);\n+    double dvalue = 0d;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, dvalue);\n+      dvalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesBOOLEANBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.BOOLEAN);\n+    batchData.putAnObject(1, true);\n+    batchData.putAnObject(2, false);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesTEXTBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.TEXT);\n+    String svalue = \"\";\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, Binary.valueOf(svalue));\n+      svalue += String.valueOf(time);\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesTVPairTest() {\n+    List<TimeValuePair> TVPairs = new ArrayList<>();\n+    TimeValuePair p1 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.BOOLEAN, true));\n+    TVPairs.add(p1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NzAzNDA3OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjozNzoxOVrOID2-pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjozNzoxOVrOID2-pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkxNzQxMw==", "bodyText": "It's Longs here. And add javadoc.", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540917413", "createdAt": "2020-12-11T12:37:19Z", "author": {"login": "Alima777"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SerializeUtilsTest {\n+  @Test\n+  public void serdesStringTest() {\n+    String str = \"abcd%+/123\\n\\t\";\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(str, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(str, SerializeUtils.deserializeString(buffer));\n+  }\n+\n+  @Test\n+  public void serdesStringListTest() {\n+    List<String> slist = Arrays.asList(\"abc\", \"123\", \"y87@\", \"9+&d\\n\");\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeStringList(slist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(slist, SerializeUtils.deserializeStringList(buffer));\n+  }\n+\n+  @Test\n+  public void serdesIntListTest() {\n+    List<Integer> intlist = Arrays.asList(12, 34, 567, 8910);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(intlist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    List<Integer> anotherIntlist = new ArrayList<>();\n+    SerializeUtils.deserialize(anotherIntlist, buffer);\n+    Assert.assertEquals(intlist, anotherIntlist);\n+  }\n+\n+  @Test\n+  public void serdesIntSetTest() {\n+    List<Integer> intlist = Arrays.asList(12, 34, 567, 8910);\n+    Set<Integer> intSet = new TreeSet<>(intlist);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(intSet, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    List<Integer> anotherIntlist = new ArrayList<>();\n+    SerializeUtils.deserialize(anotherIntlist, buffer);\n+    Assert.assertEquals(intlist, anotherIntlist);\n+  }\n+\n+  @Test\n+  public void serdesNodeTest() {\n+    Node node = new Node(\"127.0.0.1\", 6667, 1, 6535, 4678);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(node, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Node anotherNode = new Node(\"127.0.0.1\", 6667, 1, 6535, 4678);\n+    SerializeUtils.deserialize(anotherNode, buffer);\n+    Assert.assertEquals(node, anotherNode);\n+  }\n+\n+  @Test\n+  public void serdesINT32BatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.INT32);\n+    int ivalue = 0;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, ivalue);\n+      ivalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesINT64BatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.INT64);\n+    long lvalue = 0;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, lvalue);\n+      lvalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesFLOATBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.FLOAT);\n+    float fvalue = 0f;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, fvalue);\n+      fvalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesDOUBLEBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.DOUBLE);\n+    double dvalue = 0d;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, dvalue);\n+      dvalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesBOOLEANBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.BOOLEAN);\n+    batchData.putAnObject(1, true);\n+    batchData.putAnObject(2, false);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesTEXTBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.TEXT);\n+    String svalue = \"\";\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, Binary.valueOf(svalue));\n+      svalue += String.valueOf(time);\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesTVPairTest() {\n+    List<TimeValuePair> TVPairs = new ArrayList<>();\n+    TimeValuePair p1 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.BOOLEAN, true));\n+    TVPairs.add(p1);\n+    TimeValuePair p2 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.INT32, 1));\n+    TVPairs.add(p2);\n+    TimeValuePair p3 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.INT64, 1L));\n+    TVPairs.add(p3);\n+    TimeValuePair p4 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.FLOAT, 1.0f));\n+    TVPairs.add(p4);\n+    TimeValuePair p5 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.DOUBLE, 1.0d));\n+    TVPairs.add(p5);\n+    TimeValuePair p6 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.TEXT, Binary.valueOf(\"a\")));\n+    TVPairs.add(p6);\n+\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    for (TimeValuePair tv : TVPairs) {\n+      SerializeUtils.serializeTVPair(tv, outputStream);\n+      ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+      Assert.assertEquals(tv, SerializeUtils.deserializeTVPair(buffer));\n+      baos.reset();\n+    }\n+\n+  }\n+\n+  @Test\n+  public void serdesTVPairsTest() {\n+    List<List<TimeValuePair>> TVPairs = new ArrayList<>();\n+    TimeValuePair p1 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.BOOLEAN, true));\n+    TVPairs.add(Collections.singletonList(p1));\n+    TimeValuePair p2 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.INT32, 1));\n+    TVPairs.add(Collections.singletonList(p2));\n+    TimeValuePair p3 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.INT64, 1L));\n+    TVPairs.add(Collections.singletonList(p3));\n+    TimeValuePair p4 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.FLOAT, 1.0f));\n+    TVPairs.add(Collections.singletonList(p4));\n+    TimeValuePair p5 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.DOUBLE, 1.0d));\n+    TVPairs.add(Collections.singletonList(p5));\n+    TimeValuePair p6 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.TEXT, Binary.valueOf(\"a\")));\n+    TVPairs.add(Collections.singletonList(p6));\n+\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    for (List<TimeValuePair> tv : TVPairs) {\n+      SerializeUtils.serializeTVPairs(tv, outputStream);\n+      ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+      Assert.assertEquals(tv, SerializeUtils.deserializeTVPairs(buffer));\n+      baos.reset();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesObjectTest() {\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeObject(1, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(1, SerializeUtils.deserializeObject(buffer));\n+  }\n+\n+  @Test\n+  public void serdesObjectsTest() {\n+    Object[] objects = { 1, \"2\", 3d};\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeObjects(objects, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertArrayEquals(objects, SerializeUtils.deserializeObjects(buffer));\n+  }\n+\n+  @Test\n+  public void serdesLongTest() {\n+    long[] array = {1, 10, 100, 1000, 10000};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "originalPosition": 292}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 537, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}