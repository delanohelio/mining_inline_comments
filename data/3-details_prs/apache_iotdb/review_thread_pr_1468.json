{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0ODkyNjY1", "number": 1468, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMzoxNTo1NVrOEMEl6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMzoyMjowMlrOEMEv-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDkzNjA5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMzoxNTo1NlrOGt-Alg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMzoxNTo1NlrOGt-Alg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1NTA2Mg==", "bodyText": "copy vmWriters and vmTsFileResources to a new collection", "url": "https://github.com/apache/iotdb/pull/1468#discussion_r450855062", "createdAt": "2020-07-07T13:15:56Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "diffHunk": "@@ -1061,4 +960,104 @@ public void putMemTableBackAndClose() throws TsFileProcessorException {\n   public ReadWriteLock getFlushQueryLock() {\n     return flushQueryLock;\n   }\n+\n+  private File createNewTmpFile() {\n+    File parent = writer.getFile().getParentFile();\n+    return FSFactoryProducer.getFSFactory().getFile(parent,\n+        writer.getFile().getName() + IoTDBConstant.FILE_NAME_SEPARATOR + System\n+            .currentTimeMillis()\n+            + VM_SUFFIX + IoTDBConstant.PATH_SEPARATOR\n+            + PATH_UPGRADE);\n+  }\n+\n+  private void flushAllVmToTsFile(List<RestorableTsFileIOWriter> currMergeVmWriters,\n+      List<TsFileResource> currMergeVmFiles) throws IOException {\n+    VmMergeTask vmMergeTask = new VmMergeTask(writer, currMergeVmWriters,\n+        storageGroupName,\n+        new VmLogger(tsFileResource.getFile().getParent(),\n+            tsFileResource.getFile().getName()),\n+        new HashSet<>(), sequence);\n+    vmMergeTask.fullMerge();\n+    for (TsFileResource vmTsFileResource : currMergeVmFiles) {\n+      deleteVmFile(vmTsFileResource);\n+    }\n+    vmWriters.removeAll(currMergeVmWriters);\n+    vmTsFileResources.removeAll(currMergeVmFiles);\n+    File logFile = FSFactoryProducer.getFSFactory()\n+        .getFile(tsFileResource.getFile().getParent(),\n+            tsFileResource.getFile().getName() + VM_LOG_NAME);\n+    logFile.delete();\n+  }\n+\n+  class VmMergeLoop implements Callable<Void> {\n+\n+    public void merge() {\n+      try {\n+        if (shouldClose && flushingMemTables.isEmpty()) {\n+          // merge vm to tsfile\n+          logger.info(\"[Flush] merge all {} vms to TsFile\", vmTsFileResources.size() + 1);\n+          flushAllVmToTsFile(vmWriters, vmTsFileResources);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5361b993729cea215c12e9f8b2f03aee6ec34415"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDk0MTM5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMzoxNzoxNVrOGt-D1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMzoxNzoxNVrOGt-D1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1NTg5NQ==", "bodyText": "in this way, you will construct many Path and MeasurementSchema, use computeIfAbsent and Map<String, Map<String, MeasurementSchema>>", "url": "https://github.com/apache/iotdb/pull/1468#discussion_r450855895", "createdAt": "2020-07-07T13:17:15Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "diffHunk": "@@ -1061,4 +960,104 @@ public void putMemTableBackAndClose() throws TsFileProcessorException {\n   public ReadWriteLock getFlushQueryLock() {\n     return flushQueryLock;\n   }\n+\n+  private File createNewTmpFile() {\n+    File parent = writer.getFile().getParentFile();\n+    return FSFactoryProducer.getFSFactory().getFile(parent,\n+        writer.getFile().getName() + IoTDBConstant.FILE_NAME_SEPARATOR + System\n+            .currentTimeMillis()\n+            + VM_SUFFIX + IoTDBConstant.PATH_SEPARATOR\n+            + PATH_UPGRADE);\n+  }\n+\n+  private void flushAllVmToTsFile(List<RestorableTsFileIOWriter> currMergeVmWriters,\n+      List<TsFileResource> currMergeVmFiles) throws IOException {\n+    VmMergeTask vmMergeTask = new VmMergeTask(writer, currMergeVmWriters,\n+        storageGroupName,\n+        new VmLogger(tsFileResource.getFile().getParent(),\n+            tsFileResource.getFile().getName()),\n+        new HashSet<>(), sequence);\n+    vmMergeTask.fullMerge();\n+    for (TsFileResource vmTsFileResource : currMergeVmFiles) {\n+      deleteVmFile(vmTsFileResource);\n+    }\n+    vmWriters.removeAll(currMergeVmWriters);\n+    vmTsFileResources.removeAll(currMergeVmFiles);\n+    File logFile = FSFactoryProducer.getFSFactory()\n+        .getFile(tsFileResource.getFile().getParent(),\n+            tsFileResource.getFile().getName() + VM_LOG_NAME);\n+    logFile.delete();\n+  }\n+\n+  class VmMergeLoop implements Callable<Void> {\n+\n+    public void merge() {\n+      try {\n+        if (shouldClose && flushingMemTables.isEmpty()) {\n+          // merge vm to tsfile\n+          logger.info(\"[Flush] merge all {} vms to TsFile\", vmTsFileResources.size() + 1);\n+          flushAllVmToTsFile(vmWriters, vmTsFileResources);\n+          return;\n+        }\n+\n+        long vmPointNum = 0;\n+        // all flush to target file\n+        int mergeFileNum = vmWriters.size() - 1;\n+        List<RestorableTsFileIOWriter> flushVmWriters = vmWriters.subList(0, mergeFileNum);\n+        List<TsFileResource> flushVmFiles = vmTsFileResources.subList(0, mergeFileNum);\n+        Map<Path, MeasurementSchema> pathMeasurementSchemaMap = new HashMap<>();\n+        for (RestorableTsFileIOWriter vmWriter : flushVmWriters) {\n+          Map<String, Map<String, List<ChunkMetadata>>> schemaMap = vmWriter\n+              .getMetadatasForQuery();\n+          for (String device : schemaMap.keySet()) {\n+            for (String measurement : schemaMap.get(device).keySet()) {\n+              List<ChunkMetadata> chunkMetadataList = schemaMap.get(device).get(measurement);\n+              for (ChunkMetadata chunkMetadata : chunkMetadataList) {\n+                vmPointNum += chunkMetadata.getNumOfPoints();\n+              }\n+              pathMeasurementSchemaMap.putIfAbsent(new Path(device, measurement),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5361b993729cea215c12e9f8b2f03aee6ec34415"}, "originalPosition": 242}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDk1OTE5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMzoyMToyOFrOGt-Oug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMzoyMToyOFrOGt-Oug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1ODY4Mg==", "bodyText": "copy the vmWriters and vmResources and set to VmMergeLoop to avoid being changed.", "url": "https://github.com/apache/iotdb/pull/1468#discussion_r450858682", "createdAt": "2020-07-07T13:21:28Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "diffHunk": "@@ -803,28 +718,12 @@ public void flushOneMemTable() {\n             memTableToFlush.isSignalMemTable(), flushingMemTables.size());\n       }\n     }\n+    Future<Void> vmFuture = VmMergeTaskPoolManager.getInstance().submit(new VmMergeLoop());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5361b993729cea215c12e9f8b2f03aee6ec34415"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDk2MTg0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMzoyMjowMlrOGt-QPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMzoyMjowMlrOGt-QPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1OTA2OA==", "bodyText": "why left the last one?", "url": "https://github.com/apache/iotdb/pull/1468#discussion_r450859068", "createdAt": "2020-07-07T13:22:02Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "diffHunk": "@@ -1061,4 +960,104 @@ public void putMemTableBackAndClose() throws TsFileProcessorException {\n   public ReadWriteLock getFlushQueryLock() {\n     return flushQueryLock;\n   }\n+\n+  private File createNewTmpFile() {\n+    File parent = writer.getFile().getParentFile();\n+    return FSFactoryProducer.getFSFactory().getFile(parent,\n+        writer.getFile().getName() + IoTDBConstant.FILE_NAME_SEPARATOR + System\n+            .currentTimeMillis()\n+            + VM_SUFFIX + IoTDBConstant.PATH_SEPARATOR\n+            + PATH_UPGRADE);\n+  }\n+\n+  private void flushAllVmToTsFile(List<RestorableTsFileIOWriter> currMergeVmWriters,\n+      List<TsFileResource> currMergeVmFiles) throws IOException {\n+    VmMergeTask vmMergeTask = new VmMergeTask(writer, currMergeVmWriters,\n+        storageGroupName,\n+        new VmLogger(tsFileResource.getFile().getParent(),\n+            tsFileResource.getFile().getName()),\n+        new HashSet<>(), sequence);\n+    vmMergeTask.fullMerge();\n+    for (TsFileResource vmTsFileResource : currMergeVmFiles) {\n+      deleteVmFile(vmTsFileResource);\n+    }\n+    vmWriters.removeAll(currMergeVmWriters);\n+    vmTsFileResources.removeAll(currMergeVmFiles);\n+    File logFile = FSFactoryProducer.getFSFactory()\n+        .getFile(tsFileResource.getFile().getParent(),\n+            tsFileResource.getFile().getName() + VM_LOG_NAME);\n+    logFile.delete();\n+  }\n+\n+  class VmMergeLoop implements Callable<Void> {\n+\n+    public void merge() {\n+      try {\n+        if (shouldClose && flushingMemTables.isEmpty()) {\n+          // merge vm to tsfile\n+          logger.info(\"[Flush] merge all {} vms to TsFile\", vmTsFileResources.size() + 1);\n+          flushAllVmToTsFile(vmWriters, vmTsFileResources);\n+          return;\n+        }\n+\n+        long vmPointNum = 0;\n+        // all flush to target file\n+        int mergeFileNum = vmWriters.size() - 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5361b993729cea215c12e9f8b2f03aee6ec34415"}, "originalPosition": 229}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4861, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}