{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzMDkzMTcx", "number": 880, "title": "[IOTDB-538]add a simple connection pool for session api", "bodyText": "Well, I think the pool is more easy to use than the description in IOTDB-538.\nWe provided a connection pool (`SessionPool) for Native API.\nUsing the interface, you need to define the pool size.\nIf you can not get a session connection in 60 secondes, there is a warning log but the program will hang.\nIf a session has finished an operation, it will be put back to the pool automatically.\nIf a session connection is broken, the session will be removed automatically and the pool will try\nto create a new session and redo the operation.\nFor query operations:\n\nWhen using SessionPool to query data, the result set is SessionDataSetWrapper;\nGiven a SessionDataSetWrapper, if you have not scanned all the data in it and stop to use it,\nyou have to call SessionPool.closeResultSet(wrapper) manually;\nWhen you call hasNext() and next() of a SessionDataSetWrapper and there is an exception, then\nyou have to call SessionPool.closeResultSet(wrapper) manually;\nExamples: session/src/test/java/org/apache/iotdb/session/pool/SessionPoolTest.java", "createdAt": "2020-03-03T17:56:12Z", "url": "https://github.com/apache/iotdb/pull/880", "merged": true, "mergeCommit": {"oid": "f9fd91f80a53c978e32e26c232f24ad9254c9753"}, "closed": true, "closedAt": "2020-03-14T05:18:22Z", "author": {"login": "jixuan1989"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcKGHfMAH2gAyMzgzMDkzMTcxOjc1NjQ3ZTAzYjQ1OTczYTBjZTg1OTNkY2E3MzA0YWI5Zjk2MzY0ZjQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcNbubngH2gAyMzgzMDkzMTcxOjMzYjY4NGVkMzY3NzA4N2E3YWMwNzRjZGE5ODUxMWU1MjE0OThmOWY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "75647e03b45973a0ce8593dca7304ab9f96364f4", "author": {"user": null}, "url": "https://github.com/apache/iotdb/commit/75647e03b45973a0ce8593dca7304ab9f96364f4", "committedDate": "2020-03-03T17:52:56Z", "message": "add a simple connection pool for session api"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "779dd275acd330bcc9cbf4393109cb77b5ee23a0", "author": {"user": null}, "url": "https://github.com/apache/iotdb/commit/779dd275acd330bcc9cbf4393109cb77b5ee23a0", "committedDate": "2020-03-03T17:54:09Z", "message": "add a simple connection pool for session api"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0482887e22a21291cf58de76cff4066866d33ead", "author": {"user": null}, "url": "https://github.com/apache/iotdb/commit/0482887e22a21291cf58de76cff4066866d33ead", "committedDate": "2020-03-04T00:20:43Z", "message": "add apache rat"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7157addd0a53bf9cba3a4a20c7648d714ec2b8d", "author": {"user": null}, "url": "https://github.com/apache/iotdb/commit/e7157addd0a53bf9cba3a4a20c7648d714ec2b8d", "committedDate": "2020-03-05T00:43:18Z", "message": "add close() method and fix ut bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aceefbf5bd3ef46f9a5597d6fbd2decd2539d673", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/aceefbf5bd3ef46f9a5597d6fbd2decd2539d673", "committedDate": "2020-03-05T03:04:59Z", "message": "fix typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MjY4ODMx", "url": "https://github.com/apache/iotdb/pull/880#pullrequestreview-369268831", "createdAt": "2020-03-05T03:05:32Z", "commit": {"oid": "e7157addd0a53bf9cba3a4a20c7648d714ec2b8d"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwMzowNTozMlrOFyFCnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwMzowNzozNVrOFyFEdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA1NTcwOA==", "bodyText": "should the password be printed?", "url": "https://github.com/apache/iotdb/pull/880#discussion_r388055708", "createdAt": "2020-03-05T03:05:32Z", "author": {"login": "qiaojialin"}, "path": "session/src/main/java/org/apache/iotdb/session/pool/SessionPool.java", "diffHunk": "@@ -0,0 +1,670 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.session.pool;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentMap;\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.service.rpc.thrift.TSExecuteBatchStatementResp;\n+import org.apache.iotdb.service.rpc.thrift.TSStatus;\n+import org.apache.iotdb.session.Config;\n+import org.apache.iotdb.session.IoTDBSessionException;\n+import org.apache.iotdb.session.Session;\n+import org.apache.iotdb.session.SessionDataSet;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.write.record.RowBatch;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * SessionPool is a wrapper of a Session Set.\n+ * Using SessionPool, the user do not need to consider how to reuse a session connection.\n+ * Even if the session is disconnected, the session pool can recognize it and remove the borken\n+ * session connection and create a new one.\n+ *\n+ * If there is no available connections and the pool reaches its max size, the all methods will hang\n+ * until there is a available connection.\n+ *\n+ * If a user has waited for a session for more than 60 seconds, a warn log will be printed.\n+ *\n+ *\n+ * The only thing you have to remember is that:\n+ *\n+ * For a query, if you have get all data, i.e., SessionDataSetWrapper.hasNext() == false, it is ok.\n+ * Otherwise, i.e., you want to stop the query before you get all data (SessionDataSetWrapper.hasNext() == true),\n+ * then you have to call closeResultSet(SessionDataSetWrapper wrapper) manually.\n+ * Otherwise the connection is occupied by the query.\n+ *\n+ * Another case that you have to manually call closeResultSet() is that when there is exception\n+ * when you call SessionDataSetWrapper.hasNext() or next()\n+ *\n+ *\n+ */\n+public class SessionPool {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(SessionPool.class);\n+  private ConcurrentLinkedDeque<Session> queue = new ConcurrentLinkedDeque<>();\n+  //for session whose resultSet is not released.\n+  private ConcurrentMap<Session, Session> occupied = new ConcurrentHashMap<>();\n+\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize) {\n+    this(ip, port, user, password, maxSize, Config.DEFAULT_FETCH_SIZE);\n+  }\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize, int fetchSize) {\n+    this.maxSize = maxSize;\n+    this.ip = ip;\n+    this.port = port;\n+    this.user = user;\n+    this.password = password;\n+    this.fetchSize = fetchSize;\n+  }\n+\n+  private int size = 0;\n+  private int maxSize = 0;\n+  private String ip;\n+  private int port;\n+  private String user;\n+  private String password;\n+\n+  private int fetchSize;\n+\n+  //if this method throws an exception, either the server is broken, or the ip/port/user/password is incorrect.\n+  //TODO: we can add a mechanism that if the user waits too long time, throw exception.\n+  private Session getSession() throws IoTDBSessionException {\n+    Session session = queue.poll();\n+    if (session != null) {\n+      return session;\n+    } else {\n+      synchronized (this) {\n+        long start = System.currentTimeMillis();\n+        while (session == null) {\n+          if (size < maxSize) {\n+            //we can create more session\n+            size++;\n+            //but we do it after skip synchronized block because connection a session is time consuming.\n+            break;\n+          } else {\n+            //we have to wait for someone returns a session.\n+            try {\n+              this.wait(1000);\n+              if (System.currentTimeMillis() - start > 60_000) {\n+                logger.warn(\n+                    \"the SessionPool has wait for {} seconds to get a new connection: {}:{} with {}, {}\",\n+                    (System.currentTimeMillis() - start) / 1000, ip, port, user, password);\n+              }\n+            } catch (InterruptedException e) {\n+              logger.error(\"the SessionPool is damaged\", e);\n+              Thread.currentThread().interrupt();\n+            }\n+            session = queue.poll();\n+          }\n+        }\n+        if (session != null) {\n+          return session;\n+        }\n+      }\n+      if (logger.isDebugEnabled()) {\n+        logger.error(\"Create a new Session {}, {}, {}, {}\", ip, port, user, password);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7157addd0a53bf9cba3a4a20c7648d714ec2b8d"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA1NjA4Mw==", "bodyText": "Is it needed to export the methods of Session in this Pool? the codes are double...", "url": "https://github.com/apache/iotdb/pull/880#discussion_r388056083", "createdAt": "2020-03-05T03:07:07Z", "author": {"login": "qiaojialin"}, "path": "session/src/main/java/org/apache/iotdb/session/pool/SessionPool.java", "diffHunk": "@@ -0,0 +1,670 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.session.pool;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentMap;\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.service.rpc.thrift.TSExecuteBatchStatementResp;\n+import org.apache.iotdb.service.rpc.thrift.TSStatus;\n+import org.apache.iotdb.session.Config;\n+import org.apache.iotdb.session.IoTDBSessionException;\n+import org.apache.iotdb.session.Session;\n+import org.apache.iotdb.session.SessionDataSet;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.write.record.RowBatch;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * SessionPool is a wrapper of a Session Set.\n+ * Using SessionPool, the user do not need to consider how to reuse a session connection.\n+ * Even if the session is disconnected, the session pool can recognize it and remove the borken\n+ * session connection and create a new one.\n+ *\n+ * If there is no available connections and the pool reaches its max size, the all methods will hang\n+ * until there is a available connection.\n+ *\n+ * If a user has waited for a session for more than 60 seconds, a warn log will be printed.\n+ *\n+ *\n+ * The only thing you have to remember is that:\n+ *\n+ * For a query, if you have get all data, i.e., SessionDataSetWrapper.hasNext() == false, it is ok.\n+ * Otherwise, i.e., you want to stop the query before you get all data (SessionDataSetWrapper.hasNext() == true),\n+ * then you have to call closeResultSet(SessionDataSetWrapper wrapper) manually.\n+ * Otherwise the connection is occupied by the query.\n+ *\n+ * Another case that you have to manually call closeResultSet() is that when there is exception\n+ * when you call SessionDataSetWrapper.hasNext() or next()\n+ *\n+ *\n+ */\n+public class SessionPool {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(SessionPool.class);\n+  private ConcurrentLinkedDeque<Session> queue = new ConcurrentLinkedDeque<>();\n+  //for session whose resultSet is not released.\n+  private ConcurrentMap<Session, Session> occupied = new ConcurrentHashMap<>();\n+\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize) {\n+    this(ip, port, user, password, maxSize, Config.DEFAULT_FETCH_SIZE);\n+  }\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize, int fetchSize) {\n+    this.maxSize = maxSize;\n+    this.ip = ip;\n+    this.port = port;\n+    this.user = user;\n+    this.password = password;\n+    this.fetchSize = fetchSize;\n+  }\n+\n+  private int size = 0;\n+  private int maxSize = 0;\n+  private String ip;\n+  private int port;\n+  private String user;\n+  private String password;\n+\n+  private int fetchSize;\n+\n+  //if this method throws an exception, either the server is broken, or the ip/port/user/password is incorrect.\n+  //TODO: we can add a mechanism that if the user waits too long time, throw exception.\n+  private Session getSession() throws IoTDBSessionException {\n+    Session session = queue.poll();\n+    if (session != null) {\n+      return session;\n+    } else {\n+      synchronized (this) {\n+        long start = System.currentTimeMillis();\n+        while (session == null) {\n+          if (size < maxSize) {\n+            //we can create more session\n+            size++;\n+            //but we do it after skip synchronized block because connection a session is time consuming.\n+            break;\n+          } else {\n+            //we have to wait for someone returns a session.\n+            try {\n+              this.wait(1000);\n+              if (System.currentTimeMillis() - start > 60_000) {\n+                logger.warn(\n+                    \"the SessionPool has wait for {} seconds to get a new connection: {}:{} with {}, {}\",\n+                    (System.currentTimeMillis() - start) / 1000, ip, port, user, password);\n+              }\n+            } catch (InterruptedException e) {\n+              logger.error(\"the SessionPool is damaged\", e);\n+              Thread.currentThread().interrupt();\n+            }\n+            session = queue.poll();\n+          }\n+        }\n+        if (session != null) {\n+          return session;\n+        }\n+      }\n+      if (logger.isDebugEnabled()) {\n+        logger.error(\"Create a new Session {}, {}, {}, {}\", ip, port, user, password);\n+      }\n+      session = new Session(ip, port, user, password, fetchSize);\n+      session.open();\n+      return session;\n+    }\n+  }\n+\n+  public int currentAvailableSize() {\n+    return queue.size();\n+  }\n+\n+  public int currentOccupiedSize() {\n+    return occupied.size();\n+  }\n+\n+  private void putBack(Session session) {\n+    queue.push(session);\n+    synchronized (this) {\n+      this.notifyAll();\n+    }\n+  }\n+\n+  private void occupy(Session session) {\n+    occupied.put(session, session);\n+  }\n+\n+  /**\n+   * close all connections in the pool\n+   */\n+  public synchronized void close() {\n+    for (Session session : queue) {\n+      try {\n+        session.close();\n+      } catch (IoTDBSessionException e) {\n+        //do nothing\n+      }\n+    }\n+    for (Session session : occupied.keySet()) {\n+      try {\n+        session.close();\n+      } catch (IoTDBSessionException e) {\n+        //do nothing\n+      }\n+    }\n+    queue.clear();\n+    occupied.clear();\n+  }\n+\n+  public void closeResultSet(SessionDataSetWrapper wrapper) throws SQLException {\n+    boolean putback = true;\n+    try {\n+      wrapper.sessionDataSet.closeOperationHandle();\n+    } catch (SQLException e) {\n+      if (e.getCause() instanceof TException) {\n+        // the connection is broken.\n+        removeSession();\n+        putback = false;\n+      } else {\n+        throw e;\n+      }\n+    } finally {\n+      Session session = occupied.remove(wrapper.session);\n+      if (putback && session != null) {\n+        putBack(wrapper.session);\n+      }\n+    }\n+  }\n+\n+  private synchronized void removeSession() {\n+    if (logger.isDebugEnabled()) {\n+      logger.error(\"Remove a broken Session {}, {}, {}, {}\", ip, port, user, password);\n+    }\n+    size--;\n+  }\n+\n+  private void closeSession(Session session) {\n+    if (session != null) {\n+      try {\n+        session.close();\n+      } catch (Exception e2) {\n+        //do nothing. We just want to guarantee the session is closed.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * use batch interface to insert sorted data times in row batch must be sorted before!\n+   *\n+   * @param rowBatch data batch\n+   */\n+  public TSExecuteBatchStatementResp insertSortedBatch(RowBatch rowBatch)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7157addd0a53bf9cba3a4a20c7648d714ec2b8d"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA1NjE4MQ==", "bodyText": "get a new one?", "url": "https://github.com/apache/iotdb/pull/880#discussion_r388056181", "createdAt": "2020-03-05T03:07:35Z", "author": {"login": "qiaojialin"}, "path": "session/src/main/java/org/apache/iotdb/session/pool/SessionPool.java", "diffHunk": "@@ -0,0 +1,670 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.session.pool;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentMap;\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.service.rpc.thrift.TSExecuteBatchStatementResp;\n+import org.apache.iotdb.service.rpc.thrift.TSStatus;\n+import org.apache.iotdb.session.Config;\n+import org.apache.iotdb.session.IoTDBSessionException;\n+import org.apache.iotdb.session.Session;\n+import org.apache.iotdb.session.SessionDataSet;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.write.record.RowBatch;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * SessionPool is a wrapper of a Session Set.\n+ * Using SessionPool, the user do not need to consider how to reuse a session connection.\n+ * Even if the session is disconnected, the session pool can recognize it and remove the borken\n+ * session connection and create a new one.\n+ *\n+ * If there is no available connections and the pool reaches its max size, the all methods will hang\n+ * until there is a available connection.\n+ *\n+ * If a user has waited for a session for more than 60 seconds, a warn log will be printed.\n+ *\n+ *\n+ * The only thing you have to remember is that:\n+ *\n+ * For a query, if you have get all data, i.e., SessionDataSetWrapper.hasNext() == false, it is ok.\n+ * Otherwise, i.e., you want to stop the query before you get all data (SessionDataSetWrapper.hasNext() == true),\n+ * then you have to call closeResultSet(SessionDataSetWrapper wrapper) manually.\n+ * Otherwise the connection is occupied by the query.\n+ *\n+ * Another case that you have to manually call closeResultSet() is that when there is exception\n+ * when you call SessionDataSetWrapper.hasNext() or next()\n+ *\n+ *\n+ */\n+public class SessionPool {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(SessionPool.class);\n+  private ConcurrentLinkedDeque<Session> queue = new ConcurrentLinkedDeque<>();\n+  //for session whose resultSet is not released.\n+  private ConcurrentMap<Session, Session> occupied = new ConcurrentHashMap<>();\n+\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize) {\n+    this(ip, port, user, password, maxSize, Config.DEFAULT_FETCH_SIZE);\n+  }\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize, int fetchSize) {\n+    this.maxSize = maxSize;\n+    this.ip = ip;\n+    this.port = port;\n+    this.user = user;\n+    this.password = password;\n+    this.fetchSize = fetchSize;\n+  }\n+\n+  private int size = 0;\n+  private int maxSize = 0;\n+  private String ip;\n+  private int port;\n+  private String user;\n+  private String password;\n+\n+  private int fetchSize;\n+\n+  //if this method throws an exception, either the server is broken, or the ip/port/user/password is incorrect.\n+  //TODO: we can add a mechanism that if the user waits too long time, throw exception.\n+  private Session getSession() throws IoTDBSessionException {\n+    Session session = queue.poll();\n+    if (session != null) {\n+      return session;\n+    } else {\n+      synchronized (this) {\n+        long start = System.currentTimeMillis();\n+        while (session == null) {\n+          if (size < maxSize) {\n+            //we can create more session\n+            size++;\n+            //but we do it after skip synchronized block because connection a session is time consuming.\n+            break;\n+          } else {\n+            //we have to wait for someone returns a session.\n+            try {\n+              this.wait(1000);\n+              if (System.currentTimeMillis() - start > 60_000) {\n+                logger.warn(\n+                    \"the SessionPool has wait for {} seconds to get a new connection: {}:{} with {}, {}\",\n+                    (System.currentTimeMillis() - start) / 1000, ip, port, user, password);\n+              }\n+            } catch (InterruptedException e) {\n+              logger.error(\"the SessionPool is damaged\", e);\n+              Thread.currentThread().interrupt();\n+            }\n+            session = queue.poll();\n+          }\n+        }\n+        if (session != null) {\n+          return session;\n+        }\n+      }\n+      if (logger.isDebugEnabled()) {\n+        logger.error(\"Create a new Session {}, {}, {}, {}\", ip, port, user, password);\n+      }\n+      session = new Session(ip, port, user, password, fetchSize);\n+      session.open();\n+      return session;\n+    }\n+  }\n+\n+  public int currentAvailableSize() {\n+    return queue.size();\n+  }\n+\n+  public int currentOccupiedSize() {\n+    return occupied.size();\n+  }\n+\n+  private void putBack(Session session) {\n+    queue.push(session);\n+    synchronized (this) {\n+      this.notifyAll();\n+    }\n+  }\n+\n+  private void occupy(Session session) {\n+    occupied.put(session, session);\n+  }\n+\n+  /**\n+   * close all connections in the pool\n+   */\n+  public synchronized void close() {\n+    for (Session session : queue) {\n+      try {\n+        session.close();\n+      } catch (IoTDBSessionException e) {\n+        //do nothing\n+      }\n+    }\n+    for (Session session : occupied.keySet()) {\n+      try {\n+        session.close();\n+      } catch (IoTDBSessionException e) {\n+        //do nothing\n+      }\n+    }\n+    queue.clear();\n+    occupied.clear();\n+  }\n+\n+  public void closeResultSet(SessionDataSetWrapper wrapper) throws SQLException {\n+    boolean putback = true;\n+    try {\n+      wrapper.sessionDataSet.closeOperationHandle();\n+    } catch (SQLException e) {\n+      if (e.getCause() instanceof TException) {\n+        // the connection is broken.\n+        removeSession();\n+        putback = false;\n+      } else {\n+        throw e;\n+      }\n+    } finally {\n+      Session session = occupied.remove(wrapper.session);\n+      if (putback && session != null) {\n+        putBack(wrapper.session);\n+      }\n+    }\n+  }\n+\n+  private synchronized void removeSession() {\n+    if (logger.isDebugEnabled()) {\n+      logger.error(\"Remove a broken Session {}, {}, {}, {}\", ip, port, user, password);\n+    }\n+    size--;\n+  }\n+\n+  private void closeSession(Session session) {\n+    if (session != null) {\n+      try {\n+        session.close();\n+      } catch (Exception e2) {\n+        //do nothing. We just want to guarantee the session is closed.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * use batch interface to insert sorted data times in row batch must be sorted before!\n+   *\n+   * @param rowBatch data batch\n+   */\n+  public TSExecuteBatchStatementResp insertSortedBatch(RowBatch rowBatch)\n+      throws IoTDBSessionException {\n+    while (true) {\n+      Session session = getSession();\n+      try {\n+        TSExecuteBatchStatementResp resp = session.insertSortedBatch(rowBatch);\n+        putBack(session);\n+        return resp;\n+      } catch (IoTDBSessionException e) {\n+        if (e.getCause() instanceof TException) {\n+          // TException means the connection is broken, remove it and get a new one.\n+          closeSession(session);\n+          removeSession();\n+        } else {\n+          putBack(session);\n+          throw e;\n+        }\n+      }\n+    }\n+  }\n+\n+\n+\n+  /**\n+   * use batch interface to insert data\n+   *\n+   * @param rowBatch data batch\n+   */\n+  public TSExecuteBatchStatementResp insertBatch(RowBatch rowBatch) throws IoTDBSessionException {\n+    while (true) {\n+      Session session = getSession();\n+      try {\n+        TSExecuteBatchStatementResp resp = session.insertBatch(rowBatch);\n+        putBack(session);\n+        return resp;\n+      } catch (IoTDBSessionException e) {\n+        if (e.getCause() instanceof TException) {\n+          // TException means the connection is broken, remove it and get a new one.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7157addd0a53bf9cba3a4a20c7648d714ec2b8d"}, "originalPosition": 259}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5002afbdadb68848233f081149de90488690be8", "author": {"user": null}, "url": "https://github.com/apache/iotdb/commit/e5002afbdadb68848233f081149de90488690be8", "committedDate": "2020-03-13T00:58:33Z", "message": "add timeout and retry times"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d57b17daff36c1de7f1382d2464ad2f4fd52cf2", "author": {"user": null}, "url": "https://github.com/apache/iotdb/commit/5d57b17daff36c1de7f1382d2464ad2f4fd52cf2", "committedDate": "2020-03-13T03:49:26Z", "message": "merge with master to match new Exceptions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d3db5201aed160cc5c06104ca09748dbc2a9c1c", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/5d3db5201aed160cc5c06104ca09748dbc2a9c1c", "committedDate": "2020-03-14T02:04:26Z", "message": "add columnNameList in SessionDataSet"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33b684ed3677087a7ac074cda98511e521498f9f", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/33b684ed3677087a7ac074cda98511e521498f9f", "committedDate": "2020-03-14T02:45:15Z", "message": "add doc for getColumnNames of SessionDataSet"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3157, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}