{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg1MDEwNTcz", "number": 1725, "title": "[IOTDB-23] Restart state monitor module", "bodyText": "You can find the detail in [1].\n[1] https://lists.apache.org/list.html?dev@iotdb.apache.org:lte=1M:Restart\nCurrently, the status monitor module of iotdb is abandoned and not maintained now. It's time for us to restart this module.\nBefore, it was designed including two child modules: 1. the writing data status monitor and 2. the file size monitor.\n\nThe writing data monitor module is responsible for collecting writing data statistics.\n\nActually, many parts of origin design are redundant and not meaningful for users. Therefore, I want to just keep TOTAL_POINTS here and remove others. And i did not come up with some good ideas about what needs to be added to this monitor while writing data. Welcome to any ideas here!\n\nThe file size monitor is concerned about how much space the data file takes. It's supported partly and very limited now.\n\nI want to just remove it from iotdb.\nI used the benchmark to do the performance test, using the default IoTDB configuration while 8G machine memoery , the benchmark configuration is:\n----------------------Main Configurations----------------------\nDB_SWITCH: IoTDB\nOPERATION_PROPORTION: 1:0:0:0:0:0:0:0:0\nENABLE_THRIFT_COMPRESSION: false\nINSERT_DATATYPE_PROPORTION: 1:1:1:1:1:1\nENCODING(BOOLEAN/INT32/INT64/FLOAT/DOUBLE/TEXT): PLAIN/PLAIN/PLAIN/PLAIN/PLAIN/PLAIN\nIS_CLIENT_BIND: true\nCLIENT_NUMBER: 20\nGROUP_NUMBER: 10\nDEVICE_NUMBER: 10\nSENSOR_NUMBER: 100\nBATCH_SIZE: 100\nLOOP: 100000\nPOINT_STEP: 5000\nQUERY_INTERVAL: 250000\nIS_OVERFLOW: false\nOVERFLOW_MODE: 0\nOVERFLOW_RATIO: 0.5\nThe result is:\n| Close monitor | Open monitor without writing timeseries | Open Monitor with writing time series |\n| 1048.83 ms     |    1049.40ms                                           |                1064.90ms                           |\n|                         |   - 0.05%                                                 |                       -3%                                |", "createdAt": "2020-09-11T12:19:56Z", "url": "https://github.com/apache/iotdb/pull/1725", "merged": true, "mergeCommit": {"oid": "bf03882c0b7eeb4108d35f76c7918a779291658f"}, "closed": true, "closedAt": "2020-11-24T10:27:18Z", "author": {"login": "Alima777"}, "timelineItems": {"totalCount": 45, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdD9zmtgH2gAyNDg1MDEwNTczOjFmYjQ4NjgwYzgwMTM0NmQxZDdkZDE5YzdiMzFiYjkzZmYzNjM0ZjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdfnKc2AFqTUzNzM0OTMxOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1fb48680c801346d1d7dd19c7b31bb93ff3634f6", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/1fb48680c801346d1d7dd19c7b31bb93ff3634f6", "committedDate": "2020-08-30T12:59:35Z", "message": "delete something old,next step: insert"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd2793f6fb91e1d96c24e237f122c93a2f19f0f6", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/cd2793f6fb91e1d96c24e237f122c93a2f19f0f6", "committedDate": "2020-08-31T09:18:19Z", "message": "Add update method in flush()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5b6635dc02bf221f09002455f5af8f67ec2b9dc", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/e5b6635dc02bf221f09002455f5af8f67ec2b9dc", "committedDate": "2020-09-01T05:58:47Z", "message": "Merge branch 'state_monitor' of github.com:Alima777/incubator-iotdb into state_monitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35fa0dd8a2fa4db8847f209f0f9e90d807b24f4a", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/35fa0dd8a2fa4db8847f209f0f9e90d807b24f4a", "committedDate": "2020-09-03T13:00:26Z", "message": "implement monitorSeriesMap and cachedValueMap"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12bc8e0cebd28d9978a25cedea8a558efaac7c89", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/12bc8e0cebd28d9978a25cedea8a558efaac7c89", "committedDate": "2020-09-03T13:01:45Z", "message": "Merge branch 'state_monitor' of github.com:Alima777/incubator-iotdb into state_monitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09195967a9d6967ced96940bed81339c2aebfbe2", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/09195967a9d6967ced96940bed81339c2aebfbe2", "committedDate": "2020-09-03T13:58:13Z", "message": "update StatMonitorMBean"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d415597ca7e656d81e9b561b4bbbf1afb588c95", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/7d415597ca7e656d81e9b561b4bbbf1afb588c95", "committedDate": "2020-09-04T04:05:07Z", "message": "implement recovery"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "facee9d8395e7e8a5018bb6977c094eb0f5c9b4d", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/facee9d8395e7e8a5018bb6977c094eb0f5c9b4d", "committedDate": "2020-09-04T06:12:57Z", "message": "Merge branch 'state_monitor' of github.com:Alima777/incubator-iotdb into state_monitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7687584f97689e1b0315fc1f1dc38cefcbe99989", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/7687584f97689e1b0315fc1f1dc38cefcbe99989", "committedDate": "2020-09-04T07:11:05Z", "message": "add license and some metrics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b808331276016760b1ee50e3cf3446e52cdbeac", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/0b808331276016760b1ee50e3cf3446e52cdbeac", "committedDate": "2020-09-07T08:14:42Z", "message": "fix Url bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "575a0b1f1535d7b4dc0adda7b28e33a71ece89f0", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/575a0b1f1535d7b4dc0adda7b28e33a71ece89f0", "committedDate": "2020-09-07T08:19:14Z", "message": "Merge branch 'fixUrlBug' into state_monitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3afc748f0e5fcff2f28928ff75978fb9203085a7", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/3afc748f0e5fcff2f28928ff75978fb9203085a7", "committedDate": "2020-09-07T08:44:02Z", "message": "fix recovery bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5976ad97cdc4855b28117b86c9900f8b84739e6", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/d5976ad97cdc4855b28117b86c9900f8b84739e6", "committedDate": "2020-09-11T10:59:29Z", "message": "add mbean method:"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "640a2a02fe7336e47ebf7de53ac49f5e4f4eab73", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/640a2a02fe7336e47ebf7de53ac49f5e4f4eab73", "committedDate": "2020-09-11T12:13:26Z", "message": "update user guide doc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54e489bb083ba2655741ffc4fa40d2623745f605", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/54e489bb083ba2655741ffc4fa40d2623745f605", "committedDate": "2020-09-11T12:22:03Z", "message": "fix conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/43dfbef093e05d77704d5e65672294b28f8e5bdd", "committedDate": "2020-09-14T02:10:14Z", "message": "fix ci bug"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0MDA3ODU4", "url": "https://github.com/apache/iotdb/pull/1725#pullrequestreview-494007858", "createdAt": "2020-09-23T03:42:51Z", "commit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMzo0Mjo1MVrOHWVPww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjoxNjo1NFrOHWX5ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3ODgxOQ==", "bodyText": "put this out of the for-loop.\nAnd, set the size of the list as 3.", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493178819", "createdAt": "2020-09-23T03:42:51Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3ODkzNg==", "bodyText": "why adding \"?\nWhat will happen if a user storage group name is global", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493178936", "createdAt": "2020-09-23T03:43:28Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3OTE2MA==", "bodyText": "claim the size of the arrayList size as 1", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493179160", "createdAt": "2020-09-23T03:44:24Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3OTU2OA==", "bodyText": "are you sure RLE is ok?\nI think there are no two points having the same value... ( monotone increasing)", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493179568", "createdAt": "2020-09-23T03:46:04Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3OTkwMw==", "bodyText": "can we give a null rather than Collections.emptyMap() ?", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493179903", "createdAt": "2020-09-23T03:47:29Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIxOTMwNg==", "bodyText": "\uff1f\uff1f if so, why use for?\nand how about REQ_FAIL", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493219306", "createdAt": "2020-09-23T06:09:07Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());\n+    }\n   }\n \n-  void activate() {\n-    service = IoTDBThreadPoolFactory.newScheduledThreadPool(1,\n-        ThreadName.STAT_MONITOR.getName());\n-    service.scheduleAtFixedRate(\n-        new StatBackLoop(), 1, backLoopPeriod, TimeUnit.SECONDS);\n+  public void updateStatStorageGroupValue(String storageGroupName, int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap.get(storageGroupName);\n+    // update TOTAL_POINTS of each storage group\n+    cachedValueMap.computeIfPresent(monitorSeries.get(0),\n+        (key, oldValue) -> oldValue + successPointsNum);\n   }\n \n-  void clearIStatisticMap() {\n-    statisticMap.clear();\n+  public void updateStatGlobalValue(int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME);\n+    for (int i = 0; i < monitorSeries.size() - 1; i++) {\n+      // 0 -> TOTAL_POINTS, 1 -> REQ_SUCCESS, 2 -> REQ_FAIL", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyMTM4Ng==", "bodyText": "saveStatValue()?", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493221386", "createdAt": "2020-09-23T06:14:41Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());\n+    }\n   }\n \n-  void activate() {\n-    service = IoTDBThreadPoolFactory.newScheduledThreadPool(1,\n-        ThreadName.STAT_MONITOR.getName());\n-    service.scheduleAtFixedRate(\n-        new StatBackLoop(), 1, backLoopPeriod, TimeUnit.SECONDS);\n+  public void updateStatStorageGroupValue(String storageGroupName, int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap.get(storageGroupName);\n+    // update TOTAL_POINTS of each storage group\n+    cachedValueMap.computeIfPresent(monitorSeries.get(0),\n+        (key, oldValue) -> oldValue + successPointsNum);\n   }\n \n-  void clearIStatisticMap() {\n-    statisticMap.clear();\n+  public void updateStatGlobalValue(int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME);\n+    for (int i = 0; i < monitorSeries.size() - 1; i++) {\n+      // 0 -> TOTAL_POINTS, 1 -> REQ_SUCCESS, 2 -> REQ_FAIL\n+      switch (i) {\n+        case 0:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + successPointsNum);\n+          break;\n+        case 1:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + 1);\n+          break;\n+      }\n+    }\n   }\n \n-  public long getNumBackLoop() {\n-    return numBackLoop.get();\n+  public void updateFailedStatValue() {\n+    PartialPath failedSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME).get(2);\n+    cachedValueMap.computeIfPresent(failedSeries, (key, oldValue) -> oldValue + 1);\n   }\n \n   /**\n-   * register class which implemented IStatistic interface into statisticMap\n-   *\n-   * @param path the stat series prefix path, like root.stat.file.size\n-   * @param iStatistic instance of class which implemented IStatistic interface\n+   * Generate tsRecords for stat parameters and insert them into StorageEngine.\n    */\n-  public void registerStatistics(String path, IStatistic iStatistic) {\n-    synchronized (statisticMap) {\n-      logger.debug(\"Register {} to StatMonitor for statistics service\", path);\n-      this.statisticMap.put(path, iStatistic);\n+  public void cacheStatValue() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyMTY4OA==", "bodyText": "TSRecord should be refined, as we do not need to generate a String in TsRecord.", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493221688", "createdAt": "2020-09-23T06:15:26Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());\n+    }\n   }\n \n-  void activate() {\n-    service = IoTDBThreadPoolFactory.newScheduledThreadPool(1,\n-        ThreadName.STAT_MONITOR.getName());\n-    service.scheduleAtFixedRate(\n-        new StatBackLoop(), 1, backLoopPeriod, TimeUnit.SECONDS);\n+  public void updateStatStorageGroupValue(String storageGroupName, int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap.get(storageGroupName);\n+    // update TOTAL_POINTS of each storage group\n+    cachedValueMap.computeIfPresent(monitorSeries.get(0),\n+        (key, oldValue) -> oldValue + successPointsNum);\n   }\n \n-  void clearIStatisticMap() {\n-    statisticMap.clear();\n+  public void updateStatGlobalValue(int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME);\n+    for (int i = 0; i < monitorSeries.size() - 1; i++) {\n+      // 0 -> TOTAL_POINTS, 1 -> REQ_SUCCESS, 2 -> REQ_FAIL\n+      switch (i) {\n+        case 0:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + successPointsNum);\n+          break;\n+        case 1:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + 1);\n+          break;\n+      }\n+    }\n   }\n \n-  public long getNumBackLoop() {\n-    return numBackLoop.get();\n+  public void updateFailedStatValue() {\n+    PartialPath failedSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME).get(2);\n+    cachedValueMap.computeIfPresent(failedSeries, (key, oldValue) -> oldValue + 1);\n   }\n \n   /**\n-   * register class which implemented IStatistic interface into statisticMap\n-   *\n-   * @param path the stat series prefix path, like root.stat.file.size\n-   * @param iStatistic instance of class which implemented IStatistic interface\n+   * Generate tsRecords for stat parameters and insert them into StorageEngine.\n    */\n-  public void registerStatistics(String path, IStatistic iStatistic) {\n-    synchronized (statisticMap) {\n-      logger.debug(\"Register {} to StatMonitor for statistics service\", path);\n-      this.statisticMap.put(path, iStatistic);\n+  public void cacheStatValue() {\n+    StorageEngine storageEngine = StorageEngine.getInstance();\n+    long insertTime = System.currentTimeMillis();\n+    for (Entry<PartialPath, Long> cachedValue : cachedValueMap.entrySet()) {\n+      TSRecord tsRecord = new TSRecord(insertTime, cachedValue.getKey().getDevice());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyMjI0NA==", "bodyText": "and clear the data structures in memory", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493222244", "createdAt": "2020-09-23T06:16:54Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());\n+    }\n   }\n \n-  void activate() {\n-    service = IoTDBThreadPoolFactory.newScheduledThreadPool(1,\n-        ThreadName.STAT_MONITOR.getName());\n-    service.scheduleAtFixedRate(\n-        new StatBackLoop(), 1, backLoopPeriod, TimeUnit.SECONDS);\n+  public void updateStatStorageGroupValue(String storageGroupName, int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap.get(storageGroupName);\n+    // update TOTAL_POINTS of each storage group\n+    cachedValueMap.computeIfPresent(monitorSeries.get(0),\n+        (key, oldValue) -> oldValue + successPointsNum);\n   }\n \n-  void clearIStatisticMap() {\n-    statisticMap.clear();\n+  public void updateStatGlobalValue(int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME);\n+    for (int i = 0; i < monitorSeries.size() - 1; i++) {\n+      // 0 -> TOTAL_POINTS, 1 -> REQ_SUCCESS, 2 -> REQ_FAIL\n+      switch (i) {\n+        case 0:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + successPointsNum);\n+          break;\n+        case 1:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + 1);\n+          break;\n+      }\n+    }\n   }\n \n-  public long getNumBackLoop() {\n-    return numBackLoop.get();\n+  public void updateFailedStatValue() {\n+    PartialPath failedSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME).get(2);\n+    cachedValueMap.computeIfPresent(failedSeries, (key, oldValue) -> oldValue + 1);\n   }\n \n   /**\n-   * register class which implemented IStatistic interface into statisticMap\n-   *\n-   * @param path the stat series prefix path, like root.stat.file.size\n-   * @param iStatistic instance of class which implemented IStatistic interface\n+   * Generate tsRecords for stat parameters and insert them into StorageEngine.\n    */\n-  public void registerStatistics(String path, IStatistic iStatistic) {\n-    synchronized (statisticMap) {\n-      logger.debug(\"Register {} to StatMonitor for statistics service\", path);\n-      this.statisticMap.put(path, iStatistic);\n+  public void cacheStatValue() {\n+    StorageEngine storageEngine = StorageEngine.getInstance();\n+    long insertTime = System.currentTimeMillis();\n+    for (Entry<PartialPath, Long> cachedValue : cachedValueMap.entrySet()) {\n+      TSRecord tsRecord = new TSRecord(insertTime, cachedValue.getKey().getDevice());\n+      tsRecord.addTuple(\n+          new LongDataPoint(cachedValue.getKey().getMeasurement(), cachedValue.getValue()));\n+      try {\n+        storageEngine.insert(new InsertRowPlan(tsRecord));\n+      } catch (StorageEngineException | IllegalPathException e) {\n+        logger.error(\"Inserting stat points error.\", e);\n+      }\n     }\n   }\n \n-  /**\n-   * deregister statistics.\n-   */\n-  public void deregisterStatistics(String path) {\n-    logger.debug(\"Deregister {} in StatMonitor for stopping statistics service\", path);\n-    synchronized (statisticMap) {\n-      if (statisticMap.containsKey(path)) {\n-        statisticMap.put(path, null);\n+  public void recovery() {\n+    try {\n+      List<PartialPath> monitorSeries = mManager\n+          .getAllTimeseriesPath(new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY));\n+      for (PartialPath oneSeries : monitorSeries) {\n+        TimeValuePair timeValuePair = LastQueryExecutor\n+            .calculateLastPairForOneSeriesLocally(oneSeries, TSDataType.INT64, new QueryContext(\n+                    QueryResourceManager.getInstance().assignQueryId(true)),\n+                Collections.singleton(oneSeries.getMeasurement()));\n+        if (timeValuePair.getValue() != null) {\n+          cachedValueMap.put(oneSeries, timeValuePair.getValue().getLong());\n+        }\n       }\n+    } catch (MetadataException e) {\n+      logger.error(\"Can not get monitor series from mManager while recovering.\", e);\n+    } catch (StorageEngineException | IOException | QueryProcessException e) {\n+      logger.error(\"Load last value from disk error.\", e);\n     }\n   }\n \n-  /**\n-   * This function is not used and need to complete the query key concept.\n-   *\n-   * @return TSRecord, query statistics params\n-   */\n-  public Map<String, TSRecord> getOneStatisticsValue(String key) {\n-    // queryPath like fileNode seriesPath: root.stats.car1,\n-    // or StorageEngine seriesPath:StorageEngine\n-    String queryPath;\n-    if (key.contains(\"\\\\.\")) {\n-      queryPath =\n-          MonitorConstants.STAT_STORAGE_GROUP_PREFIX + MonitorConstants.MONITOR_PATH_SEPARATOR\n-              + key.replaceAll(\"\\\\.\", \"_\");\n-    } else {\n-      queryPath = key;\n-    }\n-    if (statisticMap.containsKey(queryPath)) {\n-      return statisticMap.get(queryPath).getAllStatisticsValue();\n-    } else {\n-      long currentTimeMillis = System.currentTimeMillis();\n-      HashMap<String, TSRecord> hashMap = new HashMap<>();\n-      TSRecord tsRecord = convertToTSRecord(\n-          MonitorConstants.initValues(MonitorConstants.FILENODE_PROCESSOR_CONST), queryPath,\n-          currentTimeMillis);\n-      hashMap.put(queryPath, tsRecord);\n-      return hashMap;\n-    }\n+  public void close() {\n+    config.setEnableStatMonitor(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 373}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0MjUwMDkz", "url": "https://github.com/apache/iotdb/pull/1725#pullrequestreview-494250093", "createdAt": "2020-09-23T06:33:06Z", "commit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjozMzowNlrOHWYUOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjozNDoyMFrOHWYWIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyOTExMw==", "bodyText": "have you tested the performance?\nI think maybe \"each tsfileProcessor records the results, and then reports to the SG processor (and then reports the the Storage Engine if needed)\" can reach a better performance.\nThe sacrifice is we can not get a real time stats.\nA solution is add an JMX interface to update the value immediately, (then the tsfileProcessors report the data immediately)", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493229113", "createdAt": "2020-09-23T06:33:06Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java", "diffHunk": "@@ -348,6 +352,9 @@ public void insert(InsertRowPlan insertRowPlan) throws StorageEngineException {\n     // TODO monitor: update statistics\n     try {\n       storageGroupProcessor.insert(insertRowPlan);\n+      if (config.isEnableStatMonitor()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyOTQzMA==", "bodyText": "remove", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493229430", "createdAt": "2020-09-23T06:33:56Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "diffHunk": "@@ -30,6 +30,7 @@\n import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n import org.apache.iotdb.db.exception.WriteProcessException;\n import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.monitor.StatMonitor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyOTYwMw==", "bodyText": "It is better to just flush the flushed SG.", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493229603", "createdAt": "2020-09-23T06:34:20Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/flush/FlushManager.java", "diffHunk": "@@ -93,6 +95,10 @@ public void runMayThrow() {\n             tsFileProcessor.getTsFileResource().getTsFile().getAbsolutePath());\n       }\n       registerTsFileProcessor(tsFileProcessor);\n+      // update stat monitor cache to system during each flush()\n+      if (IoTDBDescriptor.getInstance().getConfig().isEnableStatMonitor()) {\n+        StatMonitor.getInstance().cacheStatValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 19}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4643b11106068c30ab1878726e1ba9e9025b4c63", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/4643b11106068c30ab1878726e1ba9e9025b4c63", "committedDate": "2020-09-23T08:58:50Z", "message": "modify based on review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a5857e5ce0a37f5eae3079f7d64530246e58bc1", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/5a5857e5ce0a37f5eae3079f7d64530246e58bc1", "committedDate": "2020-09-29T08:15:25Z", "message": "delete conf properties"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df2d2f831a32ae8ab4619d26186ca353b79c9756", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/df2d2f831a32ae8ab4619d26186ca353b79c9756", "committedDate": "2020-09-29T12:38:29Z", "message": "change the cache strategy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1207fb23559c680b400396ce85dcc0ced4fd2ef6", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/1207fb23559c680b400396ce85dcc0ced4fd2ef6", "committedDate": "2020-09-30T07:24:34Z", "message": "extract some code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a144d5c09ab9fae9a5890b47b4bb6dd481a11f68", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/a144d5c09ab9fae9a5890b47b4bb6dd481a11f68", "committedDate": "2020-09-30T07:29:13Z", "message": "fix conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b00cf38d4cbd821abcd29b1f411ee1677a2d3fe7", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/b00cf38d4cbd821abcd29b1f411ee1677a2d3fe7", "committedDate": "2020-11-16T02:49:48Z", "message": "merge master and fix conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce58b3f347b61c595075f04b8653dbfca432a10f", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/ce58b3f347b61c595075f04b8653dbfca432a10f", "committedDate": "2020-11-16T04:23:54Z", "message": "add switch to control writing:"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c43b4dc5db380591fa725fdba916690c6a901ea4", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/c43b4dc5db380591fa725fdba916690c6a901ea4", "committedDate": "2020-11-16T11:43:17Z", "message": "modify properties"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0MDQ2MjIy", "url": "https://github.com/apache/iotdb/pull/1725#pullrequestreview-534046222", "createdAt": "2020-11-19T03:04:43Z", "commit": {"oid": "c43b4dc5db380591fa725fdba916690c6a901ea4"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMzowNDo0M1rOH2K09Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMzowNTo1NFrOH2K2OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU2MjU0OQ==", "bodyText": "Delete these configs in English doc?", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r526562549", "createdAt": "2020-11-19T03:04:43Z", "author": {"login": "HTHou"}, "path": "docs/zh/UserGuide/Server/Config Manual.md", "diffHunk": "@@ -181,15 +181,6 @@\n \n ### \u5f15\u64ce\u5c42\u914d\u7f6e\n \n-* back\\_loop\\_period\\_in\\_second\n-\n-|\u540d\u5b57| back\\_loop\\_period\\_in\\_second |\n-|:---:|:---|\n-|\u63cf\u8ff0| \u7cfb\u7edf\u7edf\u8ba1\u91cf\u89e6\u53d1\u7edf\u8ba1\u7684\u9891\u7387\uff0c\u5355\u4f4d\u4e3a\u79d2\u3002|\n-|\u7c7b\u578b|Int32|\n-|\u9ed8\u8ba4\u503c| 5 |\n-|\u6539\u540e\u751f\u6548\u65b9\u5f0f|\u91cd\u542f\u670d\u52a1\u5668\u751f\u6548|\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c43b4dc5db380591fa725fdba916690c6a901ea4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU2Mjg3Mg==", "bodyText": "Update english doc", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r526562872", "createdAt": "2020-11-19T03:05:54Z", "author": {"login": "HTHou"}, "path": "docs/zh/UserGuide/System Tools/Monitor and Log Tools.md", "diffHunk": "@@ -32,14 +32,21 @@\n #### JMX MBean\u76d1\u63a7\n \n \u901a\u8fc7\u4f7f\u7528JConsole\u5de5\u5177\u5e76\u4e0eJMX\u8fde\u63a5\uff0c\u60a8\u53ef\u4ee5\u67e5\u770b\u4e00\u4e9b\u7cfb\u7edf\u7edf\u8ba1\u4fe1\u606f\u548c\u53c2\u6570\u3002\n-\u672c\u8282\u63cf\u8ff0\u5982\u4f55\u4f7f\u7528JConsole\u7684\u201c Mbean\u201d\u9009\u9879\u5361\u6765\u76d1\u89c6IoTDB\u670d\u52a1\u8fdb\u7a0b\u6253\u5f00\u7684\u6587\u4ef6\u6570\uff0c\u6570\u636e\u6587\u4ef6\u7684\u5927\u5c0f\u7b49\u7b49\u3002 \u8fde\u63a5\u5230JMX\u540e\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7\u201c MBeans\u201d\u6807\u7b7e\u627e\u5230\u540d\u4e3a\u201c org.apache.iotdb.service\u201d\u7684\u201c MBean\u201d\uff0c\u5982\u4e0b\u56fe\u6240\u793a\u3002\n+\u672c\u8282\u63cf\u8ff0\u5982\u4f55\u4f7f\u7528JConsole\u7684 \"Mbean\" \u9009\u9879\u5361\u6765\u76d1\u89c6IoTDB\u7684\u4e00\u4e9b\u7cfb\u7edf\u914d\u7f6e\u3001\u5199\u5165\u6570\u636e\u7edf\u8ba1\u7b49\u7b49\u3002 \u8fde\u63a5\u5230JMX\u540e\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7 \"MBeans\" \u6807\u7b7e\u627e\u5230\u540d\u4e3a \"org.apache.iotdb.service\" \u7684 \"MBean\"\uff0c\u5982\u4e0b\u56fe\u6240\u793a\u3002\n \n-<img style=\"width:100%; max-width:800px; max-height:600px; margin-left:auto; margin-right:auto; display:block;\" src=\"https://user-images.githubusercontent.com/20263106/53316064-54aec080-3901-11e9-9a49-76563ac09192.png\">\n+<img style=\"width:100%; max-width:800px; max-height:600px; margin-left:auto; margin-right:auto; display:block;\" src=\"https://user-images.githubusercontent.com/34242296/92922876-16d4a700-f469-11ea-874d-dcf58d5bb1b3.png\"> <br>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c43b4dc5db380591fa725fdba916690c6a901ea4"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e741ce8bc21261d2bb49ab856938f78bdb9c1fa0", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/e741ce8bc21261d2bb49ab856938f78bdb9c1fa0", "committedDate": "2020-11-19T08:29:43Z", "message": "add english doc and return null if no storage group"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e4d662bd59d69575ac3e2fca4fb13b214f48a86", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/7e4d662bd59d69575ac3e2fca4fb13b214f48a86", "committedDate": "2020-11-19T10:04:31Z", "message": "return -1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "262a75213813a7e4b696a62806c11d3a62cb72ac", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/262a75213813a7e4b696a62806c11d3a62cb72ac", "committedDate": "2020-11-19T10:19:59Z", "message": "Merge branch 'master' into state_monitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c4b48efdb95218e676d7066722bb1f255d206a4", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/8c4b48efdb95218e676d7066722bb1f255d206a4", "committedDate": "2020-11-19T12:45:51Z", "message": "fix ci"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "859f31436bbc207f21e31a53f7c0098037652aac", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/859f31436bbc207f21e31a53f7c0098037652aac", "committedDate": "2020-11-20T08:07:18Z", "message": "Merge branch 'master' into state_monitor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2MTQ1NjYx", "url": "https://github.com/apache/iotdb/pull/1725#pullrequestreview-536145661", "createdAt": "2020-11-23T02:00:04Z", "commit": {"oid": "859f31436bbc207f21e31a53f7c0098037652aac"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a03cae1628621f39853b209e4521d6aefc507642", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/a03cae1628621f39853b209e4521d6aefc507642", "committedDate": "2020-11-23T02:19:18Z", "message": "fix conflict"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3MDIwNDI1", "url": "https://github.com/apache/iotdb/pull/1725#pullrequestreview-537020425", "createdAt": "2020-11-24T02:03:08Z", "commit": {"oid": "a03cae1628621f39853b209e4521d6aefc507642"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjowMzowOFrOH4nkdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjowMzowOFrOH4nkdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEzMDYxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Client\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0cUse Client for linux and WinClint for windows, you can start directly, need the parameter \"-h 127.0.0.1 -p 6667 -u root -pw root\"\n          \n          \n            \n            * Cli\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0cUse Cli for linux and WinCli for windows. You can start directly with the parameter \"-h 127.0.0.1 -p 6667 -u root -pw root\"", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r529130614", "createdAt": "2020-11-24T02:03:08Z", "author": {"login": "HTHou"}, "path": "docs/Development/ContributeGuide.md", "diffHunk": "@@ -102,7 +102,7 @@ You can go to jira to pick up the existing issue or create your own issue and ge\n Recommended Use Intellij idea. ```mvn clean package -DskipTests``` After putting ```antlr/target/generated-sources/antlr4``` and ```thrift/target/generated-sources/thrift``` marked as ```Source Root```\u3002 \n \n * Server main function\uff1a```server/src/main/java/org/apache/iotdb/db/service/IoTDB```\uff0cCan be started in debug mode\n-* Client\uff1a```client/src/main/java/org/apache/iotdb/client/```\uff0cUse Clinet for linux and WinClint for windows, you can start directly, need the parameter \"-h 127.0.0.1 -p 6667 -u root -pw root\"\n+* Client\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0cUse Client for linux and WinClint for windows, you can start directly, need the parameter \"-h 127.0.0.1 -p 6667 -u root -pw root\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a03cae1628621f39853b209e4521d6aefc507642"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3MDIxMDMy", "url": "https://github.com/apache/iotdb/pull/1725#pullrequestreview-537021032", "createdAt": "2020-11-24T02:04:50Z", "commit": {"oid": "a03cae1628621f39853b209e4521d6aefc507642"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjowNDo1MFrOH4nq5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjowNDo1MFrOH4nq5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEzMjI2MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * \u5ba2\u6237\u7aef\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0clinux \u7528 Client\uff0cwindows \u7528 WinClint\uff0c\u53ef\u4ee5\u76f4\u63a5\u542f\u52a8\uff0c\u9700\u8981\u53c2\u6570\"-h 127.0.0.1 -p 6667 -u root -pw root\"\n          \n          \n            \n            * \u547d\u4ee4\u884c\u754c\u9762\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0clinux \u7528 Cli\uff0cwindows \u7528 WinCli\u53ef\u4ee5\u76f4\u63a5\u542f\u52a8\u3002\u542f\u52a8\u65f6\u4f7f\u7528\u53c2\u6570\"-h 127.0.0.1 -p 6667 -u root -pw root\"", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r529132261", "createdAt": "2020-11-24T02:04:50Z", "author": {"login": "HTHou"}, "path": "docs/zh/Development/ContributeGuide.md", "diffHunk": "@@ -118,7 +118,7 @@ import -> Maven -> Existing Maven Projects\n ## \u8c03\u8bd5\u4ee3\u7801\n \n * \u670d\u52a1\u5668\u4e3b\u51fd\u6570\uff1a```server/src/main/java/org/apache/iotdb/db/service/IoTDB```\uff0c\u53ef\u4ee5debug\u6a21\u5f0f\u542f\u52a8\n-* \u5ba2\u6237\u7aef\uff1a```client/src/main/java/org/apache/iotdb/client/```\uff0clinux \u7528 Clinet\uff0cwindows \u7528 WinClint\uff0c\u53ef\u4ee5\u76f4\u63a5\u542f\u52a8\uff0c\u9700\u8981\u53c2\u6570\"-h 127.0.0.1 -p 6667 -u root -pw root\"\n+* \u5ba2\u6237\u7aef\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0clinux \u7528 Client\uff0cwindows \u7528 WinClint\uff0c\u53ef\u4ee5\u76f4\u63a5\u542f\u52a8\uff0c\u9700\u8981\u53c2\u6570\"-h 127.0.0.1 -p 6667 -u root -pw root\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a03cae1628621f39853b209e4521d6aefc507642"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09946ee13c2381d622bdf7986f4f65a0defab6fe", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/09946ee13c2381d622bdf7986f4f65a0defab6fe", "committedDate": "2020-11-24T02:13:37Z", "message": "fix doc typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3MDI1ODI5", "url": "https://github.com/apache/iotdb/pull/1725#pullrequestreview-537025829", "createdAt": "2020-11-24T02:17:54Z", "commit": {"oid": "09946ee13c2381d622bdf7986f4f65a0defab6fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjoxNzo1NFrOH4oawg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjoxNzo1NFrOH4oawg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE0NDUxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Cli\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0cUse Cli for linux and WinCli for windows, you can start directly, need the parameter \"-h 127.0.0.1 -p 6667 -u root -pw root\"\n          \n          \n            \n            * Cli\uff1a```cli/src/main/java/org/apache/iotdb/cli/```, Use Cli for linux and WinCli for windows, you can start directly with the parameter \"-h 127.0.0.1 -p 6667 -u root -pw root\"", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r529144514", "createdAt": "2020-11-24T02:17:54Z", "author": {"login": "HTHou"}, "path": "docs/Development/ContributeGuide.md", "diffHunk": "@@ -102,7 +102,7 @@ You can go to jira to pick up the existing issue or create your own issue and ge\n Recommended Use Intellij idea. ```mvn clean package -DskipTests``` After putting ```antlr/target/generated-sources/antlr4``` and ```thrift/target/generated-sources/thrift``` marked as ```Source Root```\u3002 \n \n * Server main function\uff1a```server/src/main/java/org/apache/iotdb/db/service/IoTDB```\uff0cCan be started in debug mode\n-* Client\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0cUse Client for linux and WinClint for windows, you can start directly, need the parameter \"-h 127.0.0.1 -p 6667 -u root -pw root\"\n+* Cli\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0cUse Cli for linux and WinCli for windows, you can start directly, need the parameter \"-h 127.0.0.1 -p 6667 -u root -pw root\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09946ee13c2381d622bdf7986f4f65a0defab6fe"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba1ab25aa0b8836a6e9bf0dc6a9517a6a63829ff", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/ba1ab25aa0b8836a6e9bf0dc6a9517a6a63829ff", "committedDate": "2020-11-24T02:20:19Z", "message": "fix doc again"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47ca8d86c3949c27577207ef4588da87ea13fa38", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/47ca8d86c3949c27577207ef4588da87ea13fa38", "committedDate": "2020-11-24T03:04:04Z", "message": "modify user doc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6aa9a21777839cefe014e154d49338d70cdd15b3", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/6aa9a21777839cefe014e154d49338d70cdd15b3", "committedDate": "2020-11-24T03:05:39Z", "message": "modify typo:"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47a33f526906f9ef001a8d7a407b0b0d212c90c3", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/47a33f526906f9ef001a8d7a407b0b0d212c90c3", "committedDate": "2020-11-24T03:06:06Z", "message": "modify typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29ccf2b4d742e51984443864993c2f46ffade68e", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/29ccf2b4d742e51984443864993c2f46ffade68e", "committedDate": "2020-11-24T03:09:35Z", "message": "remove redundant doc content"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "087f932072217cbe860f98b8a6fd3550417994a4", "author": {"user": {"login": "Alima777", "name": "Xiangwei Wei"}}, "url": "https://github.com/apache/iotdb/commit/087f932072217cbe860f98b8a6fd3550417994a4", "committedDate": "2020-11-24T09:10:04Z", "message": "modify user doc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3MzQ5MzE5", "url": "https://github.com/apache/iotdb/pull/1725#pullrequestreview-537349319", "createdAt": "2020-11-24T10:26:36Z", "commit": {"oid": "087f932072217cbe860f98b8a6fd3550417994a4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3828, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}