{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwMTExMDQ2", "number": 1635, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMToyNzowN1rOEdcR_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMToyNzowN1rOEdcR_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzA3NTE3OnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/FilePartitionedSnapshotLogManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMToyNzowN1rOHImdyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNDowNzoxMFrOHIozaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4MDg3NA==", "bodyText": "I am afraid that we cannot flush the whole storage group when time partitioning is enabled. Because in that case, a storage group will be managed by several data groups, if you flush one storage group without notifying other data groups, the file integrity of other data groups will be broken.\nSo you should either flush other related groups (which is rather hard to find), or only flush partitions that belong to the data group.", "url": "https://github.com/apache/iotdb/pull/1635#discussion_r478780874", "createdAt": "2020-08-28T01:27:07Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/FilePartitionedSnapshotLogManager.java", "diffHunk": "@@ -47,22 +52,47 @@\n       .getLogger(FilePartitionedSnapshotLogManager.class);\n \n   public FilePartitionedSnapshotLogManager(LogApplier logApplier, PartitionTable partitionTable,\n-      Node header, Node thisNode) {\n-    super(logApplier, partitionTable, header, thisNode, FileSnapshot::new);\n+      Node header, Node thisNode, DataGroupMember dataGroupMember) {\n+    super(logApplier, partitionTable, header, thisNode, FileSnapshot::new, dataGroupMember);\n+  }\n+\n+  /**\n+   * send FlushPlan to all nodes in one dataGroup\n+   */\n+  public void syncFlushAllProcessor() {\n+    logger.info(\"{}: Start flush all storage group processor in one data group\", getName());\n+    ConcurrentHashMap<String, StorageGroupProcessor> processorMap = StorageEngine.getInstance()\n+        .getProcessorMap();\n+    if (processorMap.size() == 0) {\n+      logger.info(\"{}: no need to flush processor\", getName());\n+      return;\n+    }\n+    List<Path> storageGroups = new ArrayList<>();\n+    for (Map.Entry<String, StorageGroupProcessor> entry : processorMap.entrySet()) {\n+      Path path = new Path(entry.getKey());\n+      storageGroups.add(path);\n+    }\n+    FlushPlan plan = new FlushPlan(null, true, storageGroups);\n+    dataGroupMember.flushFileWhenDoSnapshot(plan);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c3f239c3cdd59860141d85c9e3110ccc92bd110"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxOTE3OQ==", "bodyText": "Sure, thanks  for your advice, I'd like to only flush the partitions that belong to the data group", "url": "https://github.com/apache/iotdb/pull/1635#discussion_r478819179", "createdAt": "2020-08-28T04:07:10Z", "author": {"login": "neuyilan"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/FilePartitionedSnapshotLogManager.java", "diffHunk": "@@ -47,22 +52,47 @@\n       .getLogger(FilePartitionedSnapshotLogManager.class);\n \n   public FilePartitionedSnapshotLogManager(LogApplier logApplier, PartitionTable partitionTable,\n-      Node header, Node thisNode) {\n-    super(logApplier, partitionTable, header, thisNode, FileSnapshot::new);\n+      Node header, Node thisNode, DataGroupMember dataGroupMember) {\n+    super(logApplier, partitionTable, header, thisNode, FileSnapshot::new, dataGroupMember);\n+  }\n+\n+  /**\n+   * send FlushPlan to all nodes in one dataGroup\n+   */\n+  public void syncFlushAllProcessor() {\n+    logger.info(\"{}: Start flush all storage group processor in one data group\", getName());\n+    ConcurrentHashMap<String, StorageGroupProcessor> processorMap = StorageEngine.getInstance()\n+        .getProcessorMap();\n+    if (processorMap.size() == 0) {\n+      logger.info(\"{}: no need to flush processor\", getName());\n+      return;\n+    }\n+    List<Path> storageGroups = new ArrayList<>();\n+    for (Map.Entry<String, StorageGroupProcessor> entry : processorMap.entrySet()) {\n+      Path path = new Path(entry.getKey());\n+      storageGroups.add(path);\n+    }\n+    FlushPlan plan = new FlushPlan(null, true, storageGroups);\n+    dataGroupMember.flushFileWhenDoSnapshot(plan);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4MDg3NA=="}, "originalCommit": {"oid": "5c3f239c3cdd59860141d85c9e3110ccc92bd110"}, "originalPosition": 46}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4660, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}