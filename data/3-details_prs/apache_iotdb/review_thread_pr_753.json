{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0MTExNzAz", "number": 753, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwMjo1ODo0M1rODZBgSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwMzozNjowMlrODZBkqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTY1NjQyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwMjo1ODo0M1rOFfM6cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwNDo0NzoyNFrOFfNJQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2MTc0NQ==", "bodyText": "put this to clone method of TVList", "url": "https://github.com/apache/iotdb/pull/753#discussion_r368261745", "createdAt": "2020-01-19T02:58:43Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "diffHunk": "@@ -195,19 +199,19 @@ public boolean isEmpty() {\n   }\n \n   @Override\n-  public ReadOnlyMemChunk query(String deviceId, String measurement, TSDataType dataType,\n+  public TVList query(String deviceId, String measurement, TSDataType dataType,\n       Map<String, String> props, long timeLowerBound) {\n-    TimeValuePairSorter sorter;\n     if (!checkPath(deviceId, measurement)) {\n       return null;\n-    } else {\n-      long undeletedTime = findUndeletedTime(deviceId, measurement, timeLowerBound);\n-      IWritableMemChunk memChunk = memTableMap.get(deviceId).get(measurement);\n-      IWritableMemChunk chunkCopy = new WritableMemChunk(dataType, memChunk.getTVList().clone());\n-      chunkCopy.setTimeOffset(undeletedTime);\n-      sorter = chunkCopy;\n     }\n-    return new ReadOnlyMemChunk(measurement, dataType, sorter, props);\n+    long undeletedTime = findUndeletedTime(deviceId, measurement, timeLowerBound);\n+    IWritableMemChunk memChunk = memTableMap.get(deviceId).get(measurement);\n+    TVList chunkCopy = memChunk.getTVList().clone();\n+\n+    chunkCopy.setVersion(getVersion());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "180c0345f998a57f8ff38eabea610d87eeaee2d0"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2NTUzOQ==", "bodyText": "done", "url": "https://github.com/apache/iotdb/pull/753#discussion_r368265539", "createdAt": "2020-01-19T04:47:24Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "diffHunk": "@@ -195,19 +199,19 @@ public boolean isEmpty() {\n   }\n \n   @Override\n-  public ReadOnlyMemChunk query(String deviceId, String measurement, TSDataType dataType,\n+  public TVList query(String deviceId, String measurement, TSDataType dataType,\n       Map<String, String> props, long timeLowerBound) {\n-    TimeValuePairSorter sorter;\n     if (!checkPath(deviceId, measurement)) {\n       return null;\n-    } else {\n-      long undeletedTime = findUndeletedTime(deviceId, measurement, timeLowerBound);\n-      IWritableMemChunk memChunk = memTableMap.get(deviceId).get(measurement);\n-      IWritableMemChunk chunkCopy = new WritableMemChunk(dataType, memChunk.getTVList().clone());\n-      chunkCopy.setTimeOffset(undeletedTime);\n-      sorter = chunkCopy;\n     }\n-    return new ReadOnlyMemChunk(measurement, dataType, sorter, props);\n+    long undeletedTime = findUndeletedTime(deviceId, measurement, timeLowerBound);\n+    IWritableMemChunk memChunk = memTableMap.get(deviceId).get(measurement);\n+    TVList chunkCopy = memChunk.getTVList().clone();\n+\n+    chunkCopy.setVersion(getVersion());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2MTc0NQ=="}, "originalCommit": {"oid": "180c0345f998a57f8ff38eabea610d87eeaee2d0"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTY1OTk3OnYy", "diffSide": "LEFT", "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/WritableMemChunk.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwMzoxMDo1NVrOFfM8IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwNDo0Njo0NFrOFfNJMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2MjE3Ng==", "bodyText": "remove the sortedList field in this class and unused import", "url": "https://github.com/apache/iotdb/pull/753#discussion_r368262176", "createdAt": "2020-01-19T03:10:55Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/WritableMemChunk.java", "diffHunk": "@@ -223,51 +223,6 @@ public void setTimeOffset(long offset) {\n     list.setTimeOffset(offset);\n   }\n \n-  @Override\n-  public synchronized List<TimeValuePair> getSortedTimeValuePairList() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "180c0345f998a57f8ff38eabea610d87eeaee2d0"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2NTUyMg==", "bodyText": "done", "url": "https://github.com/apache/iotdb/pull/753#discussion_r368265522", "createdAt": "2020-01-19T04:46:44Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/WritableMemChunk.java", "diffHunk": "@@ -223,51 +223,6 @@ public void setTimeOffset(long offset) {\n     list.setTimeOffset(offset);\n   }\n \n-  @Override\n-  public synchronized List<TimeValuePair> getSortedTimeValuePairList() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2MjE3Ng=="}, "originalCommit": {"oid": "180c0345f998a57f8ff38eabea610d87eeaee2d0"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTY2NDM1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/querycontext/ReadOnlyMemChunk.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwMzoyNDozMlrOFfM-SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwNjowOTo1MVrOFfNVHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2MjcyOA==", "bodyText": "I suggest using one ReadOnlyMemChunk to store one chunk in a memtable. The TsFileProcessor return a Pair<List, List>\nInit the chunk metadata in the constructor in this class and cache it.\nTherefore, we only need one chunkreader, and it should not be a mergereader, we could directly get the  IPointReader in TVList.\nIn the AbstractMemTable, the version should be init by Long.MAX_VALUE for a working memtable, the memtable version is set only when it comes to a  flushing memtable.", "url": "https://github.com/apache/iotdb/pull/753#discussion_r368262728", "createdAt": "2020-01-19T03:24:32Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/querycontext/ReadOnlyMemChunk.java", "diffHunk": "@@ -18,106 +18,69 @@\n  */\n package org.apache.iotdb.db.engine.querycontext;\n \n-import java.util.Collections;\n-import java.util.Iterator;\n+import java.io.IOException;\n import java.util.List;\n import java.util.Map;\n-import org.apache.iotdb.db.engine.memtable.MemSeriesLazyMerger;\n-import org.apache.iotdb.db.engine.memtable.TimeValuePairSorter;\n import org.apache.iotdb.db.query.reader.MemChunkLoader;\n-import org.apache.iotdb.db.utils.MathUtils;\n-import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.db.query.reader.universal.PriorityMergeReader;\n+import org.apache.iotdb.db.utils.datastructure.TVList;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.encoding.encoder.Encoder;\n import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n-import org.apache.iotdb.tsfile.utils.TsPrimitiveType.TsDouble;\n-import org.apache.iotdb.tsfile.utils.TsPrimitiveType.TsFloat;\n+import org.apache.iotdb.tsfile.read.IPointReader;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n \n //TODO: merge ReadOnlyMemChunk and WritableMemChunk and IWritableMemChunk\n-public class ReadOnlyMemChunk implements TimeValuePairSorter {\n+public class ReadOnlyMemChunk {\n \n-  private boolean initialized;\n   private String measurementUid;\n   private TSDataType dataType;\n-  private TimeValuePairSorter memSeries;\n-  private List<TimeValuePair> sortedTimeValuePairList;\n \n   Map<String, String> props;\n   private int floatPrecision = TSFileDescriptor.getInstance().getConfig().getFloatPrecision();\n+  private ChunkMetaData cachedMetaData;\n+\n+  private PriorityMergeReader mergeReader;\n+  private PriorityMergeReader chunkedReader;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "180c0345f998a57f8ff38eabea610d87eeaee2d0"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2ODU3Mg==", "bodyText": "this is a pretty nice design", "url": "https://github.com/apache/iotdb/pull/753#discussion_r368268572", "createdAt": "2020-01-19T06:09:51Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/querycontext/ReadOnlyMemChunk.java", "diffHunk": "@@ -18,106 +18,69 @@\n  */\n package org.apache.iotdb.db.engine.querycontext;\n \n-import java.util.Collections;\n-import java.util.Iterator;\n+import java.io.IOException;\n import java.util.List;\n import java.util.Map;\n-import org.apache.iotdb.db.engine.memtable.MemSeriesLazyMerger;\n-import org.apache.iotdb.db.engine.memtable.TimeValuePairSorter;\n import org.apache.iotdb.db.query.reader.MemChunkLoader;\n-import org.apache.iotdb.db.utils.MathUtils;\n-import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.db.query.reader.universal.PriorityMergeReader;\n+import org.apache.iotdb.db.utils.datastructure.TVList;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.encoding.encoder.Encoder;\n import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n-import org.apache.iotdb.tsfile.utils.TsPrimitiveType.TsDouble;\n-import org.apache.iotdb.tsfile.utils.TsPrimitiveType.TsFloat;\n+import org.apache.iotdb.tsfile.read.IPointReader;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n \n //TODO: merge ReadOnlyMemChunk and WritableMemChunk and IWritableMemChunk\n-public class ReadOnlyMemChunk implements TimeValuePairSorter {\n+public class ReadOnlyMemChunk {\n \n-  private boolean initialized;\n   private String measurementUid;\n   private TSDataType dataType;\n-  private TimeValuePairSorter memSeries;\n-  private List<TimeValuePair> sortedTimeValuePairList;\n \n   Map<String, String> props;\n   private int floatPrecision = TSFileDescriptor.getInstance().getConfig().getFloatPrecision();\n+  private ChunkMetaData cachedMetaData;\n+\n+  private PriorityMergeReader mergeReader;\n+  private PriorityMergeReader chunkedReader;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2MjcyOA=="}, "originalCommit": {"oid": "180c0345f998a57f8ff38eabea610d87eeaee2d0"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTY2NjAzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/querycontext/ReadOnlyMemChunk.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwMzozMDozN1rOFfM_Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwNDo0ODoyN1rOFfNJYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2Mjk0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for (TVList pair : memSeries) {\n          \n          \n            \n                for (TVList tvlist : memSeries) {", "url": "https://github.com/apache/iotdb/pull/753#discussion_r368262947", "createdAt": "2020-01-19T03:30:37Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/querycontext/ReadOnlyMemChunk.java", "diffHunk": "@@ -18,106 +18,69 @@\n  */\n package org.apache.iotdb.db.engine.querycontext;\n \n-import java.util.Collections;\n-import java.util.Iterator;\n+import java.io.IOException;\n import java.util.List;\n import java.util.Map;\n-import org.apache.iotdb.db.engine.memtable.MemSeriesLazyMerger;\n-import org.apache.iotdb.db.engine.memtable.TimeValuePairSorter;\n import org.apache.iotdb.db.query.reader.MemChunkLoader;\n-import org.apache.iotdb.db.utils.MathUtils;\n-import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.db.query.reader.universal.PriorityMergeReader;\n+import org.apache.iotdb.db.utils.datastructure.TVList;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.encoding.encoder.Encoder;\n import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n-import org.apache.iotdb.tsfile.utils.TsPrimitiveType.TsDouble;\n-import org.apache.iotdb.tsfile.utils.TsPrimitiveType.TsFloat;\n+import org.apache.iotdb.tsfile.read.IPointReader;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n \n //TODO: merge ReadOnlyMemChunk and WritableMemChunk and IWritableMemChunk\n-public class ReadOnlyMemChunk implements TimeValuePairSorter {\n+public class ReadOnlyMemChunk {\n \n-  private boolean initialized;\n   private String measurementUid;\n   private TSDataType dataType;\n-  private TimeValuePairSorter memSeries;\n-  private List<TimeValuePair> sortedTimeValuePairList;\n \n   Map<String, String> props;\n   private int floatPrecision = TSFileDescriptor.getInstance().getConfig().getFloatPrecision();\n+  private ChunkMetaData cachedMetaData;\n+\n+  private PriorityMergeReader mergeReader;\n+  private PriorityMergeReader chunkedReader;\n \n   /**\n    * init by TSDataType and TimeValuePairSorter.\n    */\n-  public ReadOnlyMemChunk(String measurementUid, TSDataType dataType, TimeValuePairSorter memSeries,\n-      Map<String, String> props) {\n+  public ReadOnlyMemChunk(String measurementUid, TSDataType dataType,\n+      List<TVList> memSeries, Map<String, String> props) throws IOException {\n     this.measurementUid = measurementUid;\n     this.dataType = dataType;\n-    this.memSeries = memSeries;\n-    this.initialized = false;\n     this.props = props;\n     if (props.containsKey(Encoder.MAX_POINT_NUMBER)) {\n       this.floatPrecision = Integer.parseInt(props.get(Encoder.MAX_POINT_NUMBER));\n     }\n-  }\n-\n-  private void checkInitialized() {\n-    if (!initialized) {\n-      init();\n-    }\n-  }\n-\n-  private void init() {\n-    sortedTimeValuePairList = memSeries.getSortedTimeValuePairList();\n-    if (!(memSeries instanceof MemSeriesLazyMerger)) {\n-      switch (dataType) {\n-        case FLOAT:\n-          sortedTimeValuePairList.replaceAll(x -> new TimeValuePair(x.getTimestamp(),\n-              new TsFloat(\n-                  MathUtils.roundWithGivenPrecision(x.getValue().getFloat(), floatPrecision))));\n-          break;\n-        case DOUBLE:\n-          sortedTimeValuePairList.replaceAll(x -> new TimeValuePair(x.getTimestamp(),\n-              new TsDouble(\n-                  MathUtils.roundWithGivenPrecision(x.getValue().getDouble(), floatPrecision))));\n-          break;\n-        default:\n-          break;\n-      }\n+    mergeReader = new PriorityMergeReader(floatPrecision);\n+    chunkedReader = new PriorityMergeReader(floatPrecision);\n+    for (TVList pair : memSeries) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "180c0345f998a57f8ff38eabea610d87eeaee2d0"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2NTU3MQ==", "bodyText": "done", "url": "https://github.com/apache/iotdb/pull/753#discussion_r368265571", "createdAt": "2020-01-19T04:48:27Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/querycontext/ReadOnlyMemChunk.java", "diffHunk": "@@ -18,106 +18,69 @@\n  */\n package org.apache.iotdb.db.engine.querycontext;\n \n-import java.util.Collections;\n-import java.util.Iterator;\n+import java.io.IOException;\n import java.util.List;\n import java.util.Map;\n-import org.apache.iotdb.db.engine.memtable.MemSeriesLazyMerger;\n-import org.apache.iotdb.db.engine.memtable.TimeValuePairSorter;\n import org.apache.iotdb.db.query.reader.MemChunkLoader;\n-import org.apache.iotdb.db.utils.MathUtils;\n-import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.db.query.reader.universal.PriorityMergeReader;\n+import org.apache.iotdb.db.utils.datastructure.TVList;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.encoding.encoder.Encoder;\n import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n-import org.apache.iotdb.tsfile.utils.TsPrimitiveType.TsDouble;\n-import org.apache.iotdb.tsfile.utils.TsPrimitiveType.TsFloat;\n+import org.apache.iotdb.tsfile.read.IPointReader;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n \n //TODO: merge ReadOnlyMemChunk and WritableMemChunk and IWritableMemChunk\n-public class ReadOnlyMemChunk implements TimeValuePairSorter {\n+public class ReadOnlyMemChunk {\n \n-  private boolean initialized;\n   private String measurementUid;\n   private TSDataType dataType;\n-  private TimeValuePairSorter memSeries;\n-  private List<TimeValuePair> sortedTimeValuePairList;\n \n   Map<String, String> props;\n   private int floatPrecision = TSFileDescriptor.getInstance().getConfig().getFloatPrecision();\n+  private ChunkMetaData cachedMetaData;\n+\n+  private PriorityMergeReader mergeReader;\n+  private PriorityMergeReader chunkedReader;\n \n   /**\n    * init by TSDataType and TimeValuePairSorter.\n    */\n-  public ReadOnlyMemChunk(String measurementUid, TSDataType dataType, TimeValuePairSorter memSeries,\n-      Map<String, String> props) {\n+  public ReadOnlyMemChunk(String measurementUid, TSDataType dataType,\n+      List<TVList> memSeries, Map<String, String> props) throws IOException {\n     this.measurementUid = measurementUid;\n     this.dataType = dataType;\n-    this.memSeries = memSeries;\n-    this.initialized = false;\n     this.props = props;\n     if (props.containsKey(Encoder.MAX_POINT_NUMBER)) {\n       this.floatPrecision = Integer.parseInt(props.get(Encoder.MAX_POINT_NUMBER));\n     }\n-  }\n-\n-  private void checkInitialized() {\n-    if (!initialized) {\n-      init();\n-    }\n-  }\n-\n-  private void init() {\n-    sortedTimeValuePairList = memSeries.getSortedTimeValuePairList();\n-    if (!(memSeries instanceof MemSeriesLazyMerger)) {\n-      switch (dataType) {\n-        case FLOAT:\n-          sortedTimeValuePairList.replaceAll(x -> new TimeValuePair(x.getTimestamp(),\n-              new TsFloat(\n-                  MathUtils.roundWithGivenPrecision(x.getValue().getFloat(), floatPrecision))));\n-          break;\n-        case DOUBLE:\n-          sortedTimeValuePairList.replaceAll(x -> new TimeValuePair(x.getTimestamp(),\n-              new TsDouble(\n-                  MathUtils.roundWithGivenPrecision(x.getValue().getDouble(), floatPrecision))));\n-          break;\n-        default:\n-          break;\n-      }\n+    mergeReader = new PriorityMergeReader(floatPrecision);\n+    chunkedReader = new PriorityMergeReader(floatPrecision);\n+    for (TVList pair : memSeries) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2Mjk0Nw=="}, "originalCommit": {"oid": "180c0345f998a57f8ff38eabea610d87eeaee2d0"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTY2NjU1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwMzozMjowMFrOFfM_Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwMzozMjowMFrOFfM_Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2MzAxNA==", "bodyText": "replace this with List", "url": "https://github.com/apache/iotdb/pull/753#discussion_r368263014", "createdAt": "2020-01-19T03:32:00Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "diffHunk": "@@ -583,28 +587,28 @@ public String getStorageGroupName() {\n       String measurementId, TSDataType dataType, Map<String, String> props, QueryContext context) {\n     flushQueryLock.readLock().lock();\n     try {\n-      MemSeriesLazyMerger memSeriesLazyMerger = new MemSeriesLazyMerger();\n+      List<TVList> tvLists = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "180c0345f998a57f8ff38eabea610d87eeaee2d0"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTY2NzE0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/universal/PriorityMergeReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwMzozMzo1NFrOFfM_tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwNjoxMDo0OVrOFfNVQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2MzA5NA==", "bodyText": "If we use a List , this class should not be changed.\nis this a bug before?", "url": "https://github.com/apache/iotdb/pull/753#discussion_r368263094", "createdAt": "2020-01-19T03:33:54Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/reader/universal/PriorityMergeReader.java", "diffHunk": "@@ -42,6 +47,11 @@\n   public PriorityMergeReader() {\n   }\n \n+  public PriorityMergeReader(int floatPrecision) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "180c0345f998a57f8ff38eabea610d87eeaee2d0"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2ODYxMA==", "bodyText": "It's for formatting data in memory", "url": "https://github.com/apache/iotdb/pull/753#discussion_r368268610", "createdAt": "2020-01-19T06:10:49Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/query/reader/universal/PriorityMergeReader.java", "diffHunk": "@@ -42,6 +47,11 @@\n   public PriorityMergeReader() {\n   }\n \n+  public PriorityMergeReader(int floatPrecision) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2MzA5NA=="}, "originalCommit": {"oid": "180c0345f998a57f8ff38eabea610d87eeaee2d0"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTY2NzYzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/utils/datastructure/TVList.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwMzozNjowMlrOFfM__Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwNDo0OTo1MVrOFfNJjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2MzE2NQ==", "bodyText": "if (hasCachedPair || hasNextTimeValuePair) {\nhasCachedPair = false\nreturn cachedTimeValuePair\n} else {\nthrow new IOException(\"no next time value pair\");\n}", "url": "https://github.com/apache/iotdb/pull/753#discussion_r368263165", "createdAt": "2020-01-19T03:36:02Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/datastructure/TVList.java", "diffHunk": "@@ -452,11 +470,62 @@ void updateMinTimeAndSorted(long[] time, int start, int end) {\n     boolean inputSorted = true;\n     for (int i = start; i < end; i++) {\n       inPutMinTime = inPutMinTime <= time[i] ? inPutMinTime : time[i];\n-      if (inputSorted && i < length - 1 && time[i] > time[i+1]) {\n+      if (inputSorted && i < length - 1 && time[i] > time[i + 1]) {\n         inputSorted = false;\n       }\n     }\n     minTime = inPutMinTime < minTime ? inPutMinTime : minTime;\n     sorted = sorted && inputSorted && (size == 0 || inPutMinTime >= getTime(size - 1));\n   }\n+\n+  protected abstract TimeValuePair getTimeValuePair(int index, long time);\n+\n+  public IPointReader getIterator() {\n+    return new Ite();\n+  }\n+\n+  private class Ite implements IPointReader {\n+\n+    private TimeValuePair cachedTimeValuePair;\n+    private boolean hasCachedPair;\n+    private int cur;\n+\n+    @Override\n+    public boolean hasNextTimeValuePair() {\n+      if (hasCachedPair) {\n+        return true;\n+      }\n+\n+      while (cur < size) {\n+        long time = getTime(cur);\n+        if (time < getTimeOffset() || (cur + 1 < size() && (time == getTime(cur + 1)))) {\n+          cur++;\n+          continue;\n+        }\n+        cachedTimeValuePair = getTimeValuePair(cur, time);\n+        hasCachedPair = true;\n+        cur++;\n+        return true;\n+      }\n+      return hasCachedPair;\n+    }\n+\n+    @Override\n+    public TimeValuePair nextTimeValuePair() {\n+      hasCachedPair = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "180c0345f998a57f8ff38eabea610d87eeaee2d0"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2NTYxMw==", "bodyText": "done", "url": "https://github.com/apache/iotdb/pull/753#discussion_r368265613", "createdAt": "2020-01-19T04:49:51Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/datastructure/TVList.java", "diffHunk": "@@ -452,11 +470,62 @@ void updateMinTimeAndSorted(long[] time, int start, int end) {\n     boolean inputSorted = true;\n     for (int i = start; i < end; i++) {\n       inPutMinTime = inPutMinTime <= time[i] ? inPutMinTime : time[i];\n-      if (inputSorted && i < length - 1 && time[i] > time[i+1]) {\n+      if (inputSorted && i < length - 1 && time[i] > time[i + 1]) {\n         inputSorted = false;\n       }\n     }\n     minTime = inPutMinTime < minTime ? inPutMinTime : minTime;\n     sorted = sorted && inputSorted && (size == 0 || inPutMinTime >= getTime(size - 1));\n   }\n+\n+  protected abstract TimeValuePair getTimeValuePair(int index, long time);\n+\n+  public IPointReader getIterator() {\n+    return new Ite();\n+  }\n+\n+  private class Ite implements IPointReader {\n+\n+    private TimeValuePair cachedTimeValuePair;\n+    private boolean hasCachedPair;\n+    private int cur;\n+\n+    @Override\n+    public boolean hasNextTimeValuePair() {\n+      if (hasCachedPair) {\n+        return true;\n+      }\n+\n+      while (cur < size) {\n+        long time = getTime(cur);\n+        if (time < getTimeOffset() || (cur + 1 < size() && (time == getTime(cur + 1)))) {\n+          cur++;\n+          continue;\n+        }\n+        cachedTimeValuePair = getTimeValuePair(cur, time);\n+        hasCachedPair = true;\n+        cur++;\n+        return true;\n+      }\n+      return hasCachedPair;\n+    }\n+\n+    @Override\n+    public TimeValuePair nextTimeValuePair() {\n+      hasCachedPair = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2MzE2NQ=="}, "originalCommit": {"oid": "180c0345f998a57f8ff38eabea610d87eeaee2d0"}, "originalPosition": 184}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 348, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}