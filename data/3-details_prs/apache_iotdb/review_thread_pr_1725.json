{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg1MDEwNTcz", "number": 1725, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMzo0Mjo1MVrOEmW3ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjoxNzo1NFrOE8fB8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjU1OTc4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMzo0Mjo1MVrOHWVPww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNzozNDo1NFrOHWaQOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3ODgxOQ==", "bodyText": "put this out of the for-loop.\nAnd, set the size of the list as 3.", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493178819", "createdAt": "2020-09-23T03:42:51Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI2MDg1Nw==", "bodyText": "Fixed.", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493260857", "createdAt": "2020-09-23T07:34:54Z", "author": {"login": "Alima777"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3ODgxOQ=="}, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjU2MDUwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMzo0MzoyOFrOHWVQOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjo1Nzo0MVrOHWZAqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3ODkzNg==", "bodyText": "why adding \"?\nWhat will happen if a user storage group name is global", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493178936", "createdAt": "2020-09-23T03:43:28Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI0MDQ4OA==", "bodyText": "storageGroupName contains the seperator \".\", we add \" to see it as the whole.\nglobal is surrounded by \" too to keep consistence, and otherwise select * from root.stats.global will throw an exception as global is recognized as a keyword.", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493240488", "createdAt": "2020-09-23T06:57:41Z", "author": {"login": "Alima777"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3ODkzNg=="}, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjU2MTk0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMzo0NDoyNFrOHWVRGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNzozNTowNFrOHWaQjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3OTE2MA==", "bodyText": "claim the size of the arrayList size as 1", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493179160", "createdAt": "2020-09-23T03:44:24Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI2MDk0Mw==", "bodyText": "Fixed.", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493260943", "createdAt": "2020-09-23T07:35:04Z", "author": {"login": "Alima777"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3OTE2MA=="}, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjU2NDc0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMzo0NjowNFrOHWVSsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNzozNDoyNVrOHWaPDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3OTU2OA==", "bodyText": "are you sure RLE is ok?\nI think there are no two points having the same value... ( monotone increasing)", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493179568", "createdAt": "2020-09-23T03:46:04Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI2MDU1OQ==", "bodyText": "I reused the code before... I think TS_2DIFF is better.", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493260559", "createdAt": "2020-09-23T07:34:25Z", "author": {"login": "Alima777"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3OTU2OA=="}, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 245}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjU2NzEyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMzo0NzoyOVrOHWVT_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNzoyODo1N1rOHWaCFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3OTkwMw==", "bodyText": "can we give a null rather than Collections.emptyMap() ?", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493179903", "createdAt": "2020-09-23T03:47:29Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI1NzIzOA==", "bodyText": "Yes\uff01", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493257238", "createdAt": "2020-09-23T07:28:57Z", "author": {"login": "Alima777"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3OTkwMw=="}, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjgzNDA3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjowOTowN1rOHWXt6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNzowNToxNFrOHWZO-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIxOTMwNg==", "bodyText": "\uff1f\uff1f if so, why use for?\nand how about REQ_FAIL", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493219306", "createdAt": "2020-09-23T06:09:07Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());\n+    }\n   }\n \n-  void activate() {\n-    service = IoTDBThreadPoolFactory.newScheduledThreadPool(1,\n-        ThreadName.STAT_MONITOR.getName());\n-    service.scheduleAtFixedRate(\n-        new StatBackLoop(), 1, backLoopPeriod, TimeUnit.SECONDS);\n+  public void updateStatStorageGroupValue(String storageGroupName, int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap.get(storageGroupName);\n+    // update TOTAL_POINTS of each storage group\n+    cachedValueMap.computeIfPresent(monitorSeries.get(0),\n+        (key, oldValue) -> oldValue + successPointsNum);\n   }\n \n-  void clearIStatisticMap() {\n-    statisticMap.clear();\n+  public void updateStatGlobalValue(int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME);\n+    for (int i = 0; i < monitorSeries.size() - 1; i++) {\n+      // 0 -> TOTAL_POINTS, 1 -> REQ_SUCCESS, 2 -> REQ_FAIL", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI0NDE1NQ==", "bodyText": "I designed it for ... extensibility :D. Maybe we will add more metrics later...  I will fix it~\nREQ_FAIL is not calculated with the successful situation.", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493244155", "createdAt": "2020-09-23T07:05:14Z", "author": {"login": "Alima777"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());\n+    }\n   }\n \n-  void activate() {\n-    service = IoTDBThreadPoolFactory.newScheduledThreadPool(1,\n-        ThreadName.STAT_MONITOR.getName());\n-    service.scheduleAtFixedRate(\n-        new StatBackLoop(), 1, backLoopPeriod, TimeUnit.SECONDS);\n+  public void updateStatStorageGroupValue(String storageGroupName, int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap.get(storageGroupName);\n+    // update TOTAL_POINTS of each storage group\n+    cachedValueMap.computeIfPresent(monitorSeries.get(0),\n+        (key, oldValue) -> oldValue + successPointsNum);\n   }\n \n-  void clearIStatisticMap() {\n-    statisticMap.clear();\n+  public void updateStatGlobalValue(int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME);\n+    for (int i = 0; i < monitorSeries.size() - 1; i++) {\n+      // 0 -> TOTAL_POINTS, 1 -> REQ_SUCCESS, 2 -> REQ_FAIL", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIxOTMwNg=="}, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 269}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Njg0NzU0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjoxNDo0MVrOHWX2Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNzowNjo1NVrOHWZSOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyMTM4Ng==", "bodyText": "saveStatValue()?", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493221386", "createdAt": "2020-09-23T06:14:41Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());\n+    }\n   }\n \n-  void activate() {\n-    service = IoTDBThreadPoolFactory.newScheduledThreadPool(1,\n-        ThreadName.STAT_MONITOR.getName());\n-    service.scheduleAtFixedRate(\n-        new StatBackLoop(), 1, backLoopPeriod, TimeUnit.SECONDS);\n+  public void updateStatStorageGroupValue(String storageGroupName, int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap.get(storageGroupName);\n+    // update TOTAL_POINTS of each storage group\n+    cachedValueMap.computeIfPresent(monitorSeries.get(0),\n+        (key, oldValue) -> oldValue + successPointsNum);\n   }\n \n-  void clearIStatisticMap() {\n-    statisticMap.clear();\n+  public void updateStatGlobalValue(int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME);\n+    for (int i = 0; i < monitorSeries.size() - 1; i++) {\n+      // 0 -> TOTAL_POINTS, 1 -> REQ_SUCCESS, 2 -> REQ_FAIL\n+      switch (i) {\n+        case 0:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + successPointsNum);\n+          break;\n+        case 1:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + 1);\n+          break;\n+      }\n+    }\n   }\n \n-  public long getNumBackLoop() {\n-    return numBackLoop.get();\n+  public void updateFailedStatValue() {\n+    PartialPath failedSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME).get(2);\n+    cachedValueMap.computeIfPresent(failedSeries, (key, oldValue) -> oldValue + 1);\n   }\n \n   /**\n-   * register class which implemented IStatistic interface into statisticMap\n-   *\n-   * @param path the stat series prefix path, like root.stat.file.size\n-   * @param iStatistic instance of class which implemented IStatistic interface\n+   * Generate tsRecords for stat parameters and insert them into StorageEngine.\n    */\n-  public void registerStatistics(String path, IStatistic iStatistic) {\n-    synchronized (statisticMap) {\n-      logger.debug(\"Register {} to StatMonitor for statistics service\", path);\n-      this.statisticMap.put(path, iStatistic);\n+  public void cacheStatValue() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI0NDk4Ng==", "bodyText": "Fixed.", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493244986", "createdAt": "2020-09-23T07:06:55Z", "author": {"login": "Alima777"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());\n+    }\n   }\n \n-  void activate() {\n-    service = IoTDBThreadPoolFactory.newScheduledThreadPool(1,\n-        ThreadName.STAT_MONITOR.getName());\n-    service.scheduleAtFixedRate(\n-        new StatBackLoop(), 1, backLoopPeriod, TimeUnit.SECONDS);\n+  public void updateStatStorageGroupValue(String storageGroupName, int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap.get(storageGroupName);\n+    // update TOTAL_POINTS of each storage group\n+    cachedValueMap.computeIfPresent(monitorSeries.get(0),\n+        (key, oldValue) -> oldValue + successPointsNum);\n   }\n \n-  void clearIStatisticMap() {\n-    statisticMap.clear();\n+  public void updateStatGlobalValue(int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME);\n+    for (int i = 0; i < monitorSeries.size() - 1; i++) {\n+      // 0 -> TOTAL_POINTS, 1 -> REQ_SUCCESS, 2 -> REQ_FAIL\n+      switch (i) {\n+        case 0:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + successPointsNum);\n+          break;\n+        case 1:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + 1);\n+          break;\n+      }\n+    }\n   }\n \n-  public long getNumBackLoop() {\n-    return numBackLoop.get();\n+  public void updateFailedStatValue() {\n+    PartialPath failedSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME).get(2);\n+    cachedValueMap.computeIfPresent(failedSeries, (key, oldValue) -> oldValue + 1);\n   }\n \n   /**\n-   * register class which implemented IStatistic interface into statisticMap\n-   *\n-   * @param path the stat series prefix path, like root.stat.file.size\n-   * @param iStatistic instance of class which implemented IStatistic interface\n+   * Generate tsRecords for stat parameters and insert them into StorageEngine.\n    */\n-  public void registerStatistics(String path, IStatistic iStatistic) {\n-    synchronized (statisticMap) {\n-      logger.debug(\"Register {} to StatMonitor for statistics service\", path);\n-      this.statisticMap.put(path, iStatistic);\n+  public void cacheStatValue() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyMTM4Ng=="}, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 302}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Njg0OTU3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjoxNToyNlrOHWX3OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjoxNToyNlrOHWX3OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyMTY4OA==", "bodyText": "TSRecord should be refined, as we do not need to generate a String in TsRecord.", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493221688", "createdAt": "2020-09-23T06:15:26Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());\n+    }\n   }\n \n-  void activate() {\n-    service = IoTDBThreadPoolFactory.newScheduledThreadPool(1,\n-        ThreadName.STAT_MONITOR.getName());\n-    service.scheduleAtFixedRate(\n-        new StatBackLoop(), 1, backLoopPeriod, TimeUnit.SECONDS);\n+  public void updateStatStorageGroupValue(String storageGroupName, int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap.get(storageGroupName);\n+    // update TOTAL_POINTS of each storage group\n+    cachedValueMap.computeIfPresent(monitorSeries.get(0),\n+        (key, oldValue) -> oldValue + successPointsNum);\n   }\n \n-  void clearIStatisticMap() {\n-    statisticMap.clear();\n+  public void updateStatGlobalValue(int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME);\n+    for (int i = 0; i < monitorSeries.size() - 1; i++) {\n+      // 0 -> TOTAL_POINTS, 1 -> REQ_SUCCESS, 2 -> REQ_FAIL\n+      switch (i) {\n+        case 0:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + successPointsNum);\n+          break;\n+        case 1:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + 1);\n+          break;\n+      }\n+    }\n   }\n \n-  public long getNumBackLoop() {\n-    return numBackLoop.get();\n+  public void updateFailedStatValue() {\n+    PartialPath failedSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME).get(2);\n+    cachedValueMap.computeIfPresent(failedSeries, (key, oldValue) -> oldValue + 1);\n   }\n \n   /**\n-   * register class which implemented IStatistic interface into statisticMap\n-   *\n-   * @param path the stat series prefix path, like root.stat.file.size\n-   * @param iStatistic instance of class which implemented IStatistic interface\n+   * Generate tsRecords for stat parameters and insert them into StorageEngine.\n    */\n-  public void registerStatistics(String path, IStatistic iStatistic) {\n-    synchronized (statisticMap) {\n-      logger.debug(\"Register {} to StatMonitor for statistics service\", path);\n-      this.statisticMap.put(path, iStatistic);\n+  public void cacheStatValue() {\n+    StorageEngine storageEngine = StorageEngine.getInstance();\n+    long insertTime = System.currentTimeMillis();\n+    for (Entry<PartialPath, Long> cachedValue : cachedValueMap.entrySet()) {\n+      TSRecord tsRecord = new TSRecord(insertTime, cachedValue.getKey().getDevice());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 306}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Njg1MzI0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjoxNjo1NFrOHWX5ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNzozNTozMFrOHWaRnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyMjI0NA==", "bodyText": "and clear the data structures in memory", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493222244", "createdAt": "2020-09-23T06:16:54Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());\n+    }\n   }\n \n-  void activate() {\n-    service = IoTDBThreadPoolFactory.newScheduledThreadPool(1,\n-        ThreadName.STAT_MONITOR.getName());\n-    service.scheduleAtFixedRate(\n-        new StatBackLoop(), 1, backLoopPeriod, TimeUnit.SECONDS);\n+  public void updateStatStorageGroupValue(String storageGroupName, int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap.get(storageGroupName);\n+    // update TOTAL_POINTS of each storage group\n+    cachedValueMap.computeIfPresent(monitorSeries.get(0),\n+        (key, oldValue) -> oldValue + successPointsNum);\n   }\n \n-  void clearIStatisticMap() {\n-    statisticMap.clear();\n+  public void updateStatGlobalValue(int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME);\n+    for (int i = 0; i < monitorSeries.size() - 1; i++) {\n+      // 0 -> TOTAL_POINTS, 1 -> REQ_SUCCESS, 2 -> REQ_FAIL\n+      switch (i) {\n+        case 0:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + successPointsNum);\n+          break;\n+        case 1:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + 1);\n+          break;\n+      }\n+    }\n   }\n \n-  public long getNumBackLoop() {\n-    return numBackLoop.get();\n+  public void updateFailedStatValue() {\n+    PartialPath failedSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME).get(2);\n+    cachedValueMap.computeIfPresent(failedSeries, (key, oldValue) -> oldValue + 1);\n   }\n \n   /**\n-   * register class which implemented IStatistic interface into statisticMap\n-   *\n-   * @param path the stat series prefix path, like root.stat.file.size\n-   * @param iStatistic instance of class which implemented IStatistic interface\n+   * Generate tsRecords for stat parameters and insert them into StorageEngine.\n    */\n-  public void registerStatistics(String path, IStatistic iStatistic) {\n-    synchronized (statisticMap) {\n-      logger.debug(\"Register {} to StatMonitor for statistics service\", path);\n-      this.statisticMap.put(path, iStatistic);\n+  public void cacheStatValue() {\n+    StorageEngine storageEngine = StorageEngine.getInstance();\n+    long insertTime = System.currentTimeMillis();\n+    for (Entry<PartialPath, Long> cachedValue : cachedValueMap.entrySet()) {\n+      TSRecord tsRecord = new TSRecord(insertTime, cachedValue.getKey().getDevice());\n+      tsRecord.addTuple(\n+          new LongDataPoint(cachedValue.getKey().getMeasurement(), cachedValue.getValue()));\n+      try {\n+        storageEngine.insert(new InsertRowPlan(tsRecord));\n+      } catch (StorageEngineException | IllegalPathException e) {\n+        logger.error(\"Inserting stat points error.\", e);\n+      }\n     }\n   }\n \n-  /**\n-   * deregister statistics.\n-   */\n-  public void deregisterStatistics(String path) {\n-    logger.debug(\"Deregister {} in StatMonitor for stopping statistics service\", path);\n-    synchronized (statisticMap) {\n-      if (statisticMap.containsKey(path)) {\n-        statisticMap.put(path, null);\n+  public void recovery() {\n+    try {\n+      List<PartialPath> monitorSeries = mManager\n+          .getAllTimeseriesPath(new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY));\n+      for (PartialPath oneSeries : monitorSeries) {\n+        TimeValuePair timeValuePair = LastQueryExecutor\n+            .calculateLastPairForOneSeriesLocally(oneSeries, TSDataType.INT64, new QueryContext(\n+                    QueryResourceManager.getInstance().assignQueryId(true)),\n+                Collections.singleton(oneSeries.getMeasurement()));\n+        if (timeValuePair.getValue() != null) {\n+          cachedValueMap.put(oneSeries, timeValuePair.getValue().getLong());\n+        }\n       }\n+    } catch (MetadataException e) {\n+      logger.error(\"Can not get monitor series from mManager while recovering.\", e);\n+    } catch (StorageEngineException | IOException | QueryProcessException e) {\n+      logger.error(\"Load last value from disk error.\", e);\n     }\n   }\n \n-  /**\n-   * This function is not used and need to complete the query key concept.\n-   *\n-   * @return TSRecord, query statistics params\n-   */\n-  public Map<String, TSRecord> getOneStatisticsValue(String key) {\n-    // queryPath like fileNode seriesPath: root.stats.car1,\n-    // or StorageEngine seriesPath:StorageEngine\n-    String queryPath;\n-    if (key.contains(\"\\\\.\")) {\n-      queryPath =\n-          MonitorConstants.STAT_STORAGE_GROUP_PREFIX + MonitorConstants.MONITOR_PATH_SEPARATOR\n-              + key.replaceAll(\"\\\\.\", \"_\");\n-    } else {\n-      queryPath = key;\n-    }\n-    if (statisticMap.containsKey(queryPath)) {\n-      return statisticMap.get(queryPath).getAllStatisticsValue();\n-    } else {\n-      long currentTimeMillis = System.currentTimeMillis();\n-      HashMap<String, TSRecord> hashMap = new HashMap<>();\n-      TSRecord tsRecord = convertToTSRecord(\n-          MonitorConstants.initValues(MonitorConstants.FILENODE_PROCESSOR_CONST), queryPath,\n-          currentTimeMillis);\n-      hashMap.put(queryPath, tsRecord);\n-      return hashMap;\n-    }\n+  public void close() {\n+    config.setEnableStatMonitor(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 373}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI2MTIxMg==", "bodyText": "Fixed.", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493261212", "createdAt": "2020-09-23T07:35:30Z", "author": {"login": "Alima777"}, "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());\n+    }\n   }\n \n-  void activate() {\n-    service = IoTDBThreadPoolFactory.newScheduledThreadPool(1,\n-        ThreadName.STAT_MONITOR.getName());\n-    service.scheduleAtFixedRate(\n-        new StatBackLoop(), 1, backLoopPeriod, TimeUnit.SECONDS);\n+  public void updateStatStorageGroupValue(String storageGroupName, int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap.get(storageGroupName);\n+    // update TOTAL_POINTS of each storage group\n+    cachedValueMap.computeIfPresent(monitorSeries.get(0),\n+        (key, oldValue) -> oldValue + successPointsNum);\n   }\n \n-  void clearIStatisticMap() {\n-    statisticMap.clear();\n+  public void updateStatGlobalValue(int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME);\n+    for (int i = 0; i < monitorSeries.size() - 1; i++) {\n+      // 0 -> TOTAL_POINTS, 1 -> REQ_SUCCESS, 2 -> REQ_FAIL\n+      switch (i) {\n+        case 0:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + successPointsNum);\n+          break;\n+        case 1:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + 1);\n+          break;\n+      }\n+    }\n   }\n \n-  public long getNumBackLoop() {\n-    return numBackLoop.get();\n+  public void updateFailedStatValue() {\n+    PartialPath failedSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME).get(2);\n+    cachedValueMap.computeIfPresent(failedSeries, (key, oldValue) -> oldValue + 1);\n   }\n \n   /**\n-   * register class which implemented IStatistic interface into statisticMap\n-   *\n-   * @param path the stat series prefix path, like root.stat.file.size\n-   * @param iStatistic instance of class which implemented IStatistic interface\n+   * Generate tsRecords for stat parameters and insert them into StorageEngine.\n    */\n-  public void registerStatistics(String path, IStatistic iStatistic) {\n-    synchronized (statisticMap) {\n-      logger.debug(\"Register {} to StatMonitor for statistics service\", path);\n-      this.statisticMap.put(path, iStatistic);\n+  public void cacheStatValue() {\n+    StorageEngine storageEngine = StorageEngine.getInstance();\n+    long insertTime = System.currentTimeMillis();\n+    for (Entry<PartialPath, Long> cachedValue : cachedValueMap.entrySet()) {\n+      TSRecord tsRecord = new TSRecord(insertTime, cachedValue.getKey().getDevice());\n+      tsRecord.addTuple(\n+          new LongDataPoint(cachedValue.getKey().getMeasurement(), cachedValue.getValue()));\n+      try {\n+        storageEngine.insert(new InsertRowPlan(tsRecord));\n+      } catch (StorageEngineException | IllegalPathException e) {\n+        logger.error(\"Inserting stat points error.\", e);\n+      }\n     }\n   }\n \n-  /**\n-   * deregister statistics.\n-   */\n-  public void deregisterStatistics(String path) {\n-    logger.debug(\"Deregister {} in StatMonitor for stopping statistics service\", path);\n-    synchronized (statisticMap) {\n-      if (statisticMap.containsKey(path)) {\n-        statisticMap.put(path, null);\n+  public void recovery() {\n+    try {\n+      List<PartialPath> monitorSeries = mManager\n+          .getAllTimeseriesPath(new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY));\n+      for (PartialPath oneSeries : monitorSeries) {\n+        TimeValuePair timeValuePair = LastQueryExecutor\n+            .calculateLastPairForOneSeriesLocally(oneSeries, TSDataType.INT64, new QueryContext(\n+                    QueryResourceManager.getInstance().assignQueryId(true)),\n+                Collections.singleton(oneSeries.getMeasurement()));\n+        if (timeValuePair.getValue() != null) {\n+          cachedValueMap.put(oneSeries, timeValuePair.getValue().getLong());\n+        }\n       }\n+    } catch (MetadataException e) {\n+      logger.error(\"Can not get monitor series from mManager while recovering.\", e);\n+    } catch (StorageEngineException | IOException | QueryProcessException e) {\n+      logger.error(\"Load last value from disk error.\", e);\n     }\n   }\n \n-  /**\n-   * This function is not used and need to complete the query key concept.\n-   *\n-   * @return TSRecord, query statistics params\n-   */\n-  public Map<String, TSRecord> getOneStatisticsValue(String key) {\n-    // queryPath like fileNode seriesPath: root.stats.car1,\n-    // or StorageEngine seriesPath:StorageEngine\n-    String queryPath;\n-    if (key.contains(\"\\\\.\")) {\n-      queryPath =\n-          MonitorConstants.STAT_STORAGE_GROUP_PREFIX + MonitorConstants.MONITOR_PATH_SEPARATOR\n-              + key.replaceAll(\"\\\\.\", \"_\");\n-    } else {\n-      queryPath = key;\n-    }\n-    if (statisticMap.containsKey(queryPath)) {\n-      return statisticMap.get(queryPath).getAllStatisticsValue();\n-    } else {\n-      long currentTimeMillis = System.currentTimeMillis();\n-      HashMap<String, TSRecord> hashMap = new HashMap<>();\n-      TSRecord tsRecord = convertToTSRecord(\n-          MonitorConstants.initValues(MonitorConstants.FILENODE_PROCESSOR_CONST), queryPath,\n-          currentTimeMillis);\n-      hashMap.put(queryPath, tsRecord);\n-      return hashMap;\n-    }\n+  public void close() {\n+    config.setEnableStatMonitor(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyMjI0NA=="}, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 373}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Njg5ODE1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjozMzowNlrOHWYUOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjozMzowNlrOHWYUOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyOTExMw==", "bodyText": "have you tested the performance?\nI think maybe \"each tsfileProcessor records the results, and then reports to the SG processor (and then reports the the Storage Engine if needed)\" can reach a better performance.\nThe sacrifice is we can not get a real time stats.\nA solution is add an JMX interface to update the value immediately, (then the tsfileProcessors report the data immediately)", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493229113", "createdAt": "2020-09-23T06:33:06Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java", "diffHunk": "@@ -348,6 +352,9 @@ public void insert(InsertRowPlan insertRowPlan) throws StorageEngineException {\n     // TODO monitor: update statistics\n     try {\n       storageGroupProcessor.insert(insertRowPlan);\n+      if (config.isEnableStatMonitor()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjkwMDEwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjozMzo1NlrOHWYVdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjozMzo1NlrOHWYVdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyOTQzMA==", "bodyText": "remove", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493229430", "createdAt": "2020-09-23T06:33:56Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "diffHunk": "@@ -30,6 +30,7 @@\n import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n import org.apache.iotdb.db.exception.WriteProcessException;\n import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.monitor.StatMonitor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjkwMTI0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/flush/FlushManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjozNDoyMFrOHWYWIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwODoxMTozNVrOHWcFlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyOTYwMw==", "bodyText": "It is better to just flush the flushed SG.", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493229603", "createdAt": "2020-09-23T06:34:20Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/flush/FlushManager.java", "diffHunk": "@@ -93,6 +95,10 @@ public void runMayThrow() {\n             tsFileProcessor.getTsFileResource().getTsFile().getAbsolutePath());\n       }\n       registerTsFileProcessor(tsFileProcessor);\n+      // update stat monitor cache to system during each flush()\n+      if (IoTDBDescriptor.getInstance().getConfig().isEnableStatMonitor()) {\n+        StatMonitor.getInstance().cacheStatValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI5MDkwMw==", "bodyText": "Fixed.", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493290903", "createdAt": "2020-09-23T08:11:35Z", "author": {"login": "Alima777"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/flush/FlushManager.java", "diffHunk": "@@ -93,6 +95,10 @@ public void runMayThrow() {\n             tsFileProcessor.getTsFileResource().getTsFile().getAbsolutePath());\n       }\n       registerTsFileProcessor(tsFileProcessor);\n+      // update stat monitor cache to system during each flush()\n+      if (IoTDBDescriptor.getInstance().getConfig().isEnableStatMonitor()) {\n+        StatMonitor.getInstance().cacheStatValue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyOTYwMw=="}, "originalCommit": {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTQ5MzMxOnYy", "diffSide": "LEFT", "path": "docs/zh/UserGuide/Server/Config Manual.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMzowNDo0M1rOH2K09Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwODozMDoxNVrOH2RxYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU2MjU0OQ==", "bodyText": "Delete these configs in English doc?", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r526562549", "createdAt": "2020-11-19T03:04:43Z", "author": {"login": "HTHou"}, "path": "docs/zh/UserGuide/Server/Config Manual.md", "diffHunk": "@@ -181,15 +181,6 @@\n \n ### \u5f15\u64ce\u5c42\u914d\u7f6e\n \n-* back\\_loop\\_period\\_in\\_second\n-\n-|\u540d\u5b57| back\\_loop\\_period\\_in\\_second |\n-|:---:|:---|\n-|\u63cf\u8ff0| \u7cfb\u7edf\u7edf\u8ba1\u91cf\u89e6\u53d1\u7edf\u8ba1\u7684\u9891\u7387\uff0c\u5355\u4f4d\u4e3a\u79d2\u3002|\n-|\u7c7b\u578b|Int32|\n-|\u9ed8\u8ba4\u503c| 5 |\n-|\u6539\u540e\u751f\u6548\u65b9\u5f0f|\u91cd\u542f\u670d\u52a1\u5668\u751f\u6548|\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c43b4dc5db380591fa725fdba916690c6a901ea4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY3NjMyMg==", "bodyText": "Yeah~", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r526676322", "createdAt": "2020-11-19T08:30:15Z", "author": {"login": "Alima777"}, "path": "docs/zh/UserGuide/Server/Config Manual.md", "diffHunk": "@@ -181,15 +181,6 @@\n \n ### \u5f15\u64ce\u5c42\u914d\u7f6e\n \n-* back\\_loop\\_period\\_in\\_second\n-\n-|\u540d\u5b57| back\\_loop\\_period\\_in\\_second |\n-|:---:|:---|\n-|\u63cf\u8ff0| \u7cfb\u7edf\u7edf\u8ba1\u91cf\u89e6\u53d1\u7edf\u8ba1\u7684\u9891\u7387\uff0c\u5355\u4f4d\u4e3a\u79d2\u3002|\n-|\u7c7b\u578b|Int32|\n-|\u9ed8\u8ba4\u503c| 5 |\n-|\u6539\u540e\u751f\u6548\u65b9\u5f0f|\u91cd\u542f\u670d\u52a1\u5668\u751f\u6548|\n-", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU2MjU0OQ=="}, "originalCommit": {"oid": "c43b4dc5db380591fa725fdba916690c6a901ea4"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTQ5NTczOnYy", "diffSide": "RIGHT", "path": "docs/zh/UserGuide/System Tools/Monitor and Log Tools.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMzowNTo1NFrOH2K2OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwODozMDoyMFrOH2RxlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU2Mjg3Mg==", "bodyText": "Update english doc", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r526562872", "createdAt": "2020-11-19T03:05:54Z", "author": {"login": "HTHou"}, "path": "docs/zh/UserGuide/System Tools/Monitor and Log Tools.md", "diffHunk": "@@ -32,14 +32,21 @@\n #### JMX MBean\u76d1\u63a7\n \n \u901a\u8fc7\u4f7f\u7528JConsole\u5de5\u5177\u5e76\u4e0eJMX\u8fde\u63a5\uff0c\u60a8\u53ef\u4ee5\u67e5\u770b\u4e00\u4e9b\u7cfb\u7edf\u7edf\u8ba1\u4fe1\u606f\u548c\u53c2\u6570\u3002\n-\u672c\u8282\u63cf\u8ff0\u5982\u4f55\u4f7f\u7528JConsole\u7684\u201c Mbean\u201d\u9009\u9879\u5361\u6765\u76d1\u89c6IoTDB\u670d\u52a1\u8fdb\u7a0b\u6253\u5f00\u7684\u6587\u4ef6\u6570\uff0c\u6570\u636e\u6587\u4ef6\u7684\u5927\u5c0f\u7b49\u7b49\u3002 \u8fde\u63a5\u5230JMX\u540e\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7\u201c MBeans\u201d\u6807\u7b7e\u627e\u5230\u540d\u4e3a\u201c org.apache.iotdb.service\u201d\u7684\u201c MBean\u201d\uff0c\u5982\u4e0b\u56fe\u6240\u793a\u3002\n+\u672c\u8282\u63cf\u8ff0\u5982\u4f55\u4f7f\u7528JConsole\u7684 \"Mbean\" \u9009\u9879\u5361\u6765\u76d1\u89c6IoTDB\u7684\u4e00\u4e9b\u7cfb\u7edf\u914d\u7f6e\u3001\u5199\u5165\u6570\u636e\u7edf\u8ba1\u7b49\u7b49\u3002 \u8fde\u63a5\u5230JMX\u540e\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7 \"MBeans\" \u6807\u7b7e\u627e\u5230\u540d\u4e3a \"org.apache.iotdb.service\" \u7684 \"MBean\"\uff0c\u5982\u4e0b\u56fe\u6240\u793a\u3002\n \n-<img style=\"width:100%; max-width:800px; max-height:600px; margin-left:auto; margin-right:auto; display:block;\" src=\"https://user-images.githubusercontent.com/20263106/53316064-54aec080-3901-11e9-9a49-76563ac09192.png\">\n+<img style=\"width:100%; max-width:800px; max-height:600px; margin-left:auto; margin-right:auto; display:block;\" src=\"https://user-images.githubusercontent.com/34242296/92922876-16d4a700-f469-11ea-874d-dcf58d5bb1b3.png\"> <br>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c43b4dc5db380591fa725fdba916690c6a901ea4"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY3NjM3Mw==", "bodyText": "Fixed.", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r526676373", "createdAt": "2020-11-19T08:30:20Z", "author": {"login": "Alima777"}, "path": "docs/zh/UserGuide/System Tools/Monitor and Log Tools.md", "diffHunk": "@@ -32,14 +32,21 @@\n #### JMX MBean\u76d1\u63a7\n \n \u901a\u8fc7\u4f7f\u7528JConsole\u5de5\u5177\u5e76\u4e0eJMX\u8fde\u63a5\uff0c\u60a8\u53ef\u4ee5\u67e5\u770b\u4e00\u4e9b\u7cfb\u7edf\u7edf\u8ba1\u4fe1\u606f\u548c\u53c2\u6570\u3002\n-\u672c\u8282\u63cf\u8ff0\u5982\u4f55\u4f7f\u7528JConsole\u7684\u201c Mbean\u201d\u9009\u9879\u5361\u6765\u76d1\u89c6IoTDB\u670d\u52a1\u8fdb\u7a0b\u6253\u5f00\u7684\u6587\u4ef6\u6570\uff0c\u6570\u636e\u6587\u4ef6\u7684\u5927\u5c0f\u7b49\u7b49\u3002 \u8fde\u63a5\u5230JMX\u540e\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7\u201c MBeans\u201d\u6807\u7b7e\u627e\u5230\u540d\u4e3a\u201c org.apache.iotdb.service\u201d\u7684\u201c MBean\u201d\uff0c\u5982\u4e0b\u56fe\u6240\u793a\u3002\n+\u672c\u8282\u63cf\u8ff0\u5982\u4f55\u4f7f\u7528JConsole\u7684 \"Mbean\" \u9009\u9879\u5361\u6765\u76d1\u89c6IoTDB\u7684\u4e00\u4e9b\u7cfb\u7edf\u914d\u7f6e\u3001\u5199\u5165\u6570\u636e\u7edf\u8ba1\u7b49\u7b49\u3002 \u8fde\u63a5\u5230JMX\u540e\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7 \"MBeans\" \u6807\u7b7e\u627e\u5230\u540d\u4e3a \"org.apache.iotdb.service\" \u7684 \"MBean\"\uff0c\u5982\u4e0b\u56fe\u6240\u793a\u3002\n \n-<img style=\"width:100%; max-width:800px; max-height:600px; margin-left:auto; margin-right:auto; display:block;\" src=\"https://user-images.githubusercontent.com/20263106/53316064-54aec080-3901-11e9-9a49-76563ac09192.png\">\n+<img style=\"width:100%; max-width:800px; max-height:600px; margin-left:auto; margin-right:auto; display:block;\" src=\"https://user-images.githubusercontent.com/34242296/92922876-16d4a700-f469-11ea-874d-dcf58d5bb1b3.png\"> <br>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU2Mjg3Mg=="}, "originalCommit": {"oid": "c43b4dc5db380591fa725fdba916690c6a901ea4"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODUwNTg0OnYy", "diffSide": "RIGHT", "path": "docs/Development/ContributeGuide.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjowMzowOFrOH4nkdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjowMzowOFrOH4nkdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEzMDYxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Client\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0cUse Client for linux and WinClint for windows, you can start directly, need the parameter \"-h 127.0.0.1 -p 6667 -u root -pw root\"\n          \n          \n            \n            * Cli\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0cUse Cli for linux and WinCli for windows. You can start directly with the parameter \"-h 127.0.0.1 -p 6667 -u root -pw root\"", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r529130614", "createdAt": "2020-11-24T02:03:08Z", "author": {"login": "HTHou"}, "path": "docs/Development/ContributeGuide.md", "diffHunk": "@@ -102,7 +102,7 @@ You can go to jira to pick up the existing issue or create your own issue and ge\n Recommended Use Intellij idea. ```mvn clean package -DskipTests``` After putting ```antlr/target/generated-sources/antlr4``` and ```thrift/target/generated-sources/thrift``` marked as ```Source Root```\u3002 \n \n * Server main function\uff1a```server/src/main/java/org/apache/iotdb/db/service/IoTDB```\uff0cCan be started in debug mode\n-* Client\uff1a```client/src/main/java/org/apache/iotdb/client/```\uff0cUse Clinet for linux and WinClint for windows, you can start directly, need the parameter \"-h 127.0.0.1 -p 6667 -u root -pw root\"\n+* Client\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0cUse Client for linux and WinClint for windows, you can start directly, need the parameter \"-h 127.0.0.1 -p 6667 -u root -pw root\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a03cae1628621f39853b209e4521d6aefc507642"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODUxNTA1OnYy", "diffSide": "RIGHT", "path": "docs/zh/Development/ContributeGuide.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjowNDo1MFrOH4nq5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjoxNDoxMFrOH4oM9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEzMjI2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * \u5ba2\u6237\u7aef\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0clinux \u7528 Client\uff0cwindows \u7528 WinClint\uff0c\u53ef\u4ee5\u76f4\u63a5\u542f\u52a8\uff0c\u9700\u8981\u53c2\u6570\"-h 127.0.0.1 -p 6667 -u root -pw root\"\n          \n          \n            \n            * \u547d\u4ee4\u884c\u754c\u9762\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0clinux \u7528 Cli\uff0cwindows \u7528 WinCli\u53ef\u4ee5\u76f4\u63a5\u542f\u52a8\u3002\u542f\u52a8\u65f6\u4f7f\u7528\u53c2\u6570\"-h 127.0.0.1 -p 6667 -u root -pw root\"", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r529132261", "createdAt": "2020-11-24T02:04:50Z", "author": {"login": "HTHou"}, "path": "docs/zh/Development/ContributeGuide.md", "diffHunk": "@@ -118,7 +118,7 @@ import -> Maven -> Existing Maven Projects\n ## \u8c03\u8bd5\u4ee3\u7801\n \n * \u670d\u52a1\u5668\u4e3b\u51fd\u6570\uff1a```server/src/main/java/org/apache/iotdb/db/service/IoTDB```\uff0c\u53ef\u4ee5debug\u6a21\u5f0f\u542f\u52a8\n-* \u5ba2\u6237\u7aef\uff1a```client/src/main/java/org/apache/iotdb/client/```\uff0clinux \u7528 Clinet\uff0cwindows \u7528 WinClint\uff0c\u53ef\u4ee5\u76f4\u63a5\u542f\u52a8\uff0c\u9700\u8981\u53c2\u6570\"-h 127.0.0.1 -p 6667 -u root -pw root\"\n+* \u5ba2\u6237\u7aef\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0clinux \u7528 Client\uff0cwindows \u7528 WinClint\uff0c\u53ef\u4ee5\u76f4\u63a5\u542f\u52a8\uff0c\u9700\u8981\u53c2\u6570\"-h 127.0.0.1 -p 6667 -u root -pw root\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a03cae1628621f39853b209e4521d6aefc507642"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE0MDk4MA==", "bodyText": "Fixed.", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r529140980", "createdAt": "2020-11-24T02:14:10Z", "author": {"login": "Alima777"}, "path": "docs/zh/Development/ContributeGuide.md", "diffHunk": "@@ -118,7 +118,7 @@ import -> Maven -> Existing Maven Projects\n ## \u8c03\u8bd5\u4ee3\u7801\n \n * \u670d\u52a1\u5668\u4e3b\u51fd\u6570\uff1a```server/src/main/java/org/apache/iotdb/db/service/IoTDB```\uff0c\u53ef\u4ee5debug\u6a21\u5f0f\u542f\u52a8\n-* \u5ba2\u6237\u7aef\uff1a```client/src/main/java/org/apache/iotdb/client/```\uff0clinux \u7528 Clinet\uff0cwindows \u7528 WinClint\uff0c\u53ef\u4ee5\u76f4\u63a5\u542f\u52a8\uff0c\u9700\u8981\u53c2\u6570\"-h 127.0.0.1 -p 6667 -u root -pw root\"\n+* \u5ba2\u6237\u7aef\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0clinux \u7528 Client\uff0cwindows \u7528 WinClint\uff0c\u53ef\u4ee5\u76f4\u63a5\u542f\u52a8\uff0c\u9700\u8981\u53c2\u6570\"-h 127.0.0.1 -p 6667 -u root -pw root\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEzMjI2MQ=="}, "originalCommit": {"oid": "a03cae1628621f39853b209e4521d6aefc507642"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODU4NDE2OnYy", "diffSide": "RIGHT", "path": "docs/Development/ContributeGuide.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjoxNzo1NFrOH4oawg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjoxNzo1NFrOH4oawg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE0NDUxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Cli\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0cUse Cli for linux and WinCli for windows, you can start directly, need the parameter \"-h 127.0.0.1 -p 6667 -u root -pw root\"\n          \n          \n            \n            * Cli\uff1a```cli/src/main/java/org/apache/iotdb/cli/```, Use Cli for linux and WinCli for windows, you can start directly with the parameter \"-h 127.0.0.1 -p 6667 -u root -pw root\"", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r529144514", "createdAt": "2020-11-24T02:17:54Z", "author": {"login": "HTHou"}, "path": "docs/Development/ContributeGuide.md", "diffHunk": "@@ -102,7 +102,7 @@ You can go to jira to pick up the existing issue or create your own issue and ge\n Recommended Use Intellij idea. ```mvn clean package -DskipTests``` After putting ```antlr/target/generated-sources/antlr4``` and ```thrift/target/generated-sources/thrift``` marked as ```Source Root```\u3002 \n \n * Server main function\uff1a```server/src/main/java/org/apache/iotdb/db/service/IoTDB```\uff0cCan be started in debug mode\n-* Client\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0cUse Client for linux and WinClint for windows, you can start directly, need the parameter \"-h 127.0.0.1 -p 6667 -u root -pw root\"\n+* Cli\uff1a```cli/src/main/java/org/apache/iotdb/cli/```\uff0cUse Cli for linux and WinCli for windows, you can start directly, need the parameter \"-h 127.0.0.1 -p 6667 -u root -pw root\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09946ee13c2381d622bdf7986f4f65a0defab6fe"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 712, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}