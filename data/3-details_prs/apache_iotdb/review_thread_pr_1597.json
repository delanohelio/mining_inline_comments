{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzMTAxNzE5", "number": 1597, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDo1MzoxMVrOEXKFEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjoxOTozOVrOEXL0Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzE3ODQxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDo1MzoxMVrOG-ykRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDo1MzoxMVrOG-ykRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ5MzM4MA==", "bodyText": "Change back", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468493380", "createdAt": "2020-08-11T10:53:11Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -588,9 +591,9 @@\n   private int defaultFillInterval = -1;\n \n   /**\n-   * default TTL for storage groups that are not set TTL by statements, in ms\n-   * Notice: if this property is changed, previous created storage group which are not set TTL\n-   * will also be affected.\n+   * default TTL for storage groups that are not set TTL by statements, in ms Notice: if this\n+   * property is changed, previous created storage group which are not set TTL will also be\n+   * affected.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "894aec0236dc49746e6ddada8ec0b1dd8d549757"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzIwNjQ2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMTowMTo1OVrOG-y1pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMTowMTo1OVrOG-y1pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ5NzgyOA==", "bodyText": "It seems that you forgot to call it in IoTDBDescriptor", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468497828", "createdAt": "2020-08-11T11:01:59Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -1256,20 +1252,30 @@ public void setMergeFileStrategy(\n     this.mergeFileStrategy = mergeFileStrategy;\n   }\n \n-  public boolean isEnableVm() {\n-    return enableVm;\n+\n+  public TsFileManagementStrategy getTsFileManagementStrategy() {\n+    return tsFileManagementStrategy;\n+  }\n+\n+  public void setTsFileManagementStrategy(\n+      TsFileManagementStrategy tsFileManagementStrategy) {\n+    this.tsFileManagementStrategy = tsFileManagementStrategy;\n+  }\n+\n+  public int getMaxFileNumInEachLevel() {\n+    return maxFileNumInEachLevel;\n   }\n \n-  public void setEnableVm(boolean enableVm) {\n-    this.enableVm = enableVm;\n+  public void setMaxFileNumInEachLevel(int maxFileNumInEachLevel) {\n+    this.maxFileNumInEachLevel = maxFileNumInEachLevel;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "894aec0236dc49746e6ddada8ec0b1dd8d549757"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzI5NTg1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMTozMDo1OVrOG-zrPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMTozMDo1OVrOG-zrPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUxMTU0OQ==", "bodyText": "You should call closeStorageGroupCondition.notify() somewhere.", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468511549", "createdAt": "2020-08-11T11:30:59Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1182,6 +1179,13 @@ public void syncCloseAllWorkingTsFileProcessors() {\n                 (System.currentTimeMillis() - startTime) / 1000);\n           }\n         }\n+        while (hotCompactionMergeWorking) {\n+          closeStorageGroupCondition.wait(100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "894aec0236dc49746e6ddada8ec0b1dd8d549757"}, "originalPosition": 244}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzMwMzE3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMTozMzoxM1rOG-zvjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMTozMzoxM1rOG-zvjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUxMjY1NA==", "bodyText": "why we need to call logDeletion twice.", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468512654", "createdAt": "2020-08-11T11:33:13Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1376,6 +1384,7 @@ public void delete(String deviceId, String measurementId, long startTime, long e\n \n       // write log to impacted working TsFileProcessors\n       logDeletion(startTime, endTime, deviceId, measurementId);\n+      logDeletion(startTime, endTime, deviceId, measurementId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "894aec0236dc49746e6ddada8ec0b1dd8d549757"}, "originalPosition": 295}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzM5NzI5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/tsfilemanagement/TsFileManagement.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjowMTowN1rOG-0nkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjowMTowN1rOG-0nkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUyNjk5Mg==", "bodyText": "It's better to add some java doc for these abstract methods. It will be useful for someone else to implement another TsFileManagement.", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468526992", "createdAt": "2020-08-11T12:01:07Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/tsfilemanagement/TsFileManagement.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.tsfilemanagement;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupProcessor.CloseHotCompactionMergeCallBack;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+\n+public abstract class TsFileManagement {\n+\n+  protected String storageGroupName;\n+  protected String storageGroupDir;\n+\n+  public TsFileManagement(String storageGroupName, String storageGroupDir) {\n+    this.storageGroupName = storageGroupName;\n+    this.storageGroupDir = storageGroupDir;\n+  }\n+\n+  public abstract List<TsFileResource> getMergeTsFileList(boolean sequence);\n+\n+  public abstract List<TsFileResource> getTsFileList(boolean sequence);\n+\n+  public abstract Iterator<TsFileResource> getIterator(boolean sequence);\n+\n+  public abstract void remove(TsFileResource tsFileResource, boolean sequence);\n+\n+  public abstract void removeAll(List<TsFileResource> tsFileResourceList, boolean sequence);\n+\n+  public abstract void add(TsFileResource tsFileResource, boolean sequence);\n+\n+  public abstract void addAll(List<TsFileResource> tsFileResourceList, boolean sequence);\n+\n+  public abstract void addMerged(TsFileResource tsFileResource, boolean sequence);\n+\n+  public abstract void addMergedAll(List<TsFileResource> tsFileResourceList, boolean sequence);\n+\n+  public abstract boolean contains(TsFileResource tsFileResource, boolean sequence);\n+\n+  public abstract void clear();\n+\n+  public abstract boolean isEmpty(boolean sequence);\n+\n+  public abstract int size(boolean sequence);\n+\n+  public abstract void recover();\n+\n+  public abstract void forkCurrentFileList();\n+\n+  protected abstract void merge(ReadWriteLock hotCompactionMergeLock);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc9770b47fc2e28edfc868fb334074e27d701e24"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzQyNDcyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/tsfilemanagement/level/LevelTsFileManagement.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjowODozN1rOG-03wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjowODozN1rOG-03wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzMTEzNg==", "bodyText": "Why we need to iterate each level to delete vmMergeTsFiles? Cause, according to my understanding, they should be on the same level.", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468531136", "createdAt": "2020-08-11T12:08:37Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/tsfilemanagement/level/LevelTsFileManagement.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.tsfilemanagement.level;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.FILE_NAME_SEPARATOR;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.HOT_COMPACTION_LOG_NAME;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.SOURCE_NAME;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.TARGET_NAME;\n+import static org.apache.iotdb.tsfile.common.constant.TsFileConstant.TSFILE_SUFFIX;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.cache.ChunkMetadataCache;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.engine.tsfilemanagement.TsFileManagement;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogAnalyzer;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionUtils;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetadata;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.iotdb.tsfile.write.writer.RestorableTsFileIOWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class LevelTsFileManagement extends TsFileManagement {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(LevelTsFileManagement.class);\n+  private int maxLevelNum = IoTDBDescriptor.getInstance().getConfig().getMaxLevelNum();\n+  private final List<List<TsFileResource>> sequenceTsFileResources = new CopyOnWriteArrayList<>();\n+  private final List<List<TsFileResource>> unSequenceTsFileResources = new CopyOnWriteArrayList<>();\n+  private final List<List<TsFileResource>> forkedSequenceTsFileResources = new ArrayList<>();\n+  private final List<List<TsFileResource>> forkedUnSequenceTsFileResources = new ArrayList<>();\n+\n+  public LevelTsFileManagement(String storageGroupName, String storageGroupDir) {\n+    super(storageGroupName, storageGroupDir);\n+    clear();\n+  }\n+\n+  private void deleteLevelFiles(List<TsFileResource> vmMergeTsFiles) {\n+    logger.debug(\"{} [hot compaction] merge starts to delete file\", storageGroupName);\n+    for (TsFileResource vmMergeTsFile : vmMergeTsFiles) {\n+      deleteLevelFile(vmMergeTsFile);\n+    }\n+    for (int i = 0; i < maxLevelNum; i++) {\n+      sequenceTsFileResources.get(i).removeAll(vmMergeTsFiles);\n+      unSequenceTsFileResources.get(i).removeAll(vmMergeTsFiles);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc9770b47fc2e28edfc868fb334074e27d701e24"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzQyOTc4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/tsfilemanagement/level/LevelTsFileManagement.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjoxMDowN1rOG-062A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjoxMDowN1rOG-062A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzMTkyOA==", "bodyText": "It seems that we should use currMergeFiles instead of getTsFileList(sequence).", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468531928", "createdAt": "2020-08-11T12:10:07Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/tsfilemanagement/level/LevelTsFileManagement.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.tsfilemanagement.level;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.FILE_NAME_SEPARATOR;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.HOT_COMPACTION_LOG_NAME;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.SOURCE_NAME;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.TARGET_NAME;\n+import static org.apache.iotdb.tsfile.common.constant.TsFileConstant.TSFILE_SUFFIX;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.cache.ChunkMetadataCache;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.engine.tsfilemanagement.TsFileManagement;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogAnalyzer;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionUtils;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetadata;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.iotdb.tsfile.write.writer.RestorableTsFileIOWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class LevelTsFileManagement extends TsFileManagement {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(LevelTsFileManagement.class);\n+  private int maxLevelNum = IoTDBDescriptor.getInstance().getConfig().getMaxLevelNum();\n+  private final List<List<TsFileResource>> sequenceTsFileResources = new CopyOnWriteArrayList<>();\n+  private final List<List<TsFileResource>> unSequenceTsFileResources = new CopyOnWriteArrayList<>();\n+  private final List<List<TsFileResource>> forkedSequenceTsFileResources = new ArrayList<>();\n+  private final List<List<TsFileResource>> forkedUnSequenceTsFileResources = new ArrayList<>();\n+\n+  public LevelTsFileManagement(String storageGroupName, String storageGroupDir) {\n+    super(storageGroupName, storageGroupDir);\n+    clear();\n+  }\n+\n+  private void deleteLevelFiles(List<TsFileResource> vmMergeTsFiles) {\n+    logger.debug(\"{} [hot compaction] merge starts to delete file\", storageGroupName);\n+    for (TsFileResource vmMergeTsFile : vmMergeTsFiles) {\n+      deleteLevelFile(vmMergeTsFile);\n+    }\n+    for (int i = 0; i < maxLevelNum; i++) {\n+      sequenceTsFileResources.get(i).removeAll(vmMergeTsFiles);\n+      unSequenceTsFileResources.get(i).removeAll(vmMergeTsFiles);\n+    }\n+  }\n+\n+  private static void deleteLevelFile(TsFileResource seqFile) {\n+    seqFile.writeLock();\n+    try {\n+      ChunkMetadataCache.getInstance().remove(seqFile);\n+      FileReaderManager.getInstance().closeFileAndRemoveReader(seqFile.getTsFilePath());\n+      seqFile.setDeleted(true);\n+      if (seqFile.getTsFile().exists()) {\n+        Files.delete(seqFile.getTsFile().toPath());\n+      }\n+    } catch (Exception e) {\n+      logger.error(e.getMessage(), e);\n+    } finally {\n+      seqFile.writeUnlock();\n+    }\n+  }\n+\n+  private void flushAllFilesToLastLevel(List<List<TsFileResource>> currMergeFiles,\n+      HotCompactionLogger hotCompactionLogger, boolean sequence,\n+      ReadWriteLock hotCompactionMergeLock) throws IOException {\n+    TsFileResource sourceFile = currMergeFiles.get(0).get(0);\n+    File newTargetFile = createNewTsFileName(sourceFile.getTsFile(), maxLevelNum - 1);\n+    TsFileResource targetResource = new TsFileResource(newTargetFile);\n+    HotCompactionUtils.merge(targetResource, getTsFileList(sequence),\n+        storageGroupName, hotCompactionLogger, new HashSet<>(), sequence);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc9770b47fc2e28edfc868fb334074e27d701e24"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzQ0MjQ2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/tsfilemanagement/level/LevelTsFileManagement.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjoxMzo1NVrOG-1ChQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjoxMzo1NVrOG-1ChQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzMzg5Mw==", "bodyText": "change the parameter name. it can be either sequenceTsFileResources or unSequenceTsFileResources", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468533893", "createdAt": "2020-08-11T12:13:55Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/tsfilemanagement/level/LevelTsFileManagement.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.tsfilemanagement.level;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.FILE_NAME_SEPARATOR;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.HOT_COMPACTION_LOG_NAME;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.SOURCE_NAME;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.TARGET_NAME;\n+import static org.apache.iotdb.tsfile.common.constant.TsFileConstant.TSFILE_SUFFIX;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.cache.ChunkMetadataCache;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.engine.tsfilemanagement.TsFileManagement;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogAnalyzer;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionUtils;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetadata;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.iotdb.tsfile.write.writer.RestorableTsFileIOWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class LevelTsFileManagement extends TsFileManagement {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(LevelTsFileManagement.class);\n+  private int maxLevelNum = IoTDBDescriptor.getInstance().getConfig().getMaxLevelNum();\n+  private final List<List<TsFileResource>> sequenceTsFileResources = new CopyOnWriteArrayList<>();\n+  private final List<List<TsFileResource>> unSequenceTsFileResources = new CopyOnWriteArrayList<>();\n+  private final List<List<TsFileResource>> forkedSequenceTsFileResources = new ArrayList<>();\n+  private final List<List<TsFileResource>> forkedUnSequenceTsFileResources = new ArrayList<>();\n+\n+  public LevelTsFileManagement(String storageGroupName, String storageGroupDir) {\n+    super(storageGroupName, storageGroupDir);\n+    clear();\n+  }\n+\n+  private void deleteLevelFiles(List<TsFileResource> vmMergeTsFiles) {\n+    logger.debug(\"{} [hot compaction] merge starts to delete file\", storageGroupName);\n+    for (TsFileResource vmMergeTsFile : vmMergeTsFiles) {\n+      deleteLevelFile(vmMergeTsFile);\n+    }\n+    for (int i = 0; i < maxLevelNum; i++) {\n+      sequenceTsFileResources.get(i).removeAll(vmMergeTsFiles);\n+      unSequenceTsFileResources.get(i).removeAll(vmMergeTsFiles);\n+    }\n+  }\n+\n+  private static void deleteLevelFile(TsFileResource seqFile) {\n+    seqFile.writeLock();\n+    try {\n+      ChunkMetadataCache.getInstance().remove(seqFile);\n+      FileReaderManager.getInstance().closeFileAndRemoveReader(seqFile.getTsFilePath());\n+      seqFile.setDeleted(true);\n+      if (seqFile.getTsFile().exists()) {\n+        Files.delete(seqFile.getTsFile().toPath());\n+      }\n+    } catch (Exception e) {\n+      logger.error(e.getMessage(), e);\n+    } finally {\n+      seqFile.writeUnlock();\n+    }\n+  }\n+\n+  private void flushAllFilesToLastLevel(List<List<TsFileResource>> currMergeFiles,\n+      HotCompactionLogger hotCompactionLogger, boolean sequence,\n+      ReadWriteLock hotCompactionMergeLock) throws IOException {\n+    TsFileResource sourceFile = currMergeFiles.get(0).get(0);\n+    File newTargetFile = createNewTsFileName(sourceFile.getTsFile(), maxLevelNum - 1);\n+    TsFileResource targetResource = new TsFileResource(newTargetFile);\n+    HotCompactionUtils.merge(targetResource, getTsFileList(sequence),\n+        storageGroupName, hotCompactionLogger, new HashSet<>(), sequence);\n+    hotCompactionLogger.logFullMerge();\n+    hotCompactionLogger.logSequence(sequence);\n+    hotCompactionLogger.logFile(TARGET_NAME, newTargetFile);\n+    hotCompactionMergeLock.writeLock().lock();\n+    for (int i = 0; i < maxLevelNum - 1; i++) {\n+      deleteLevelFiles(currMergeFiles.get(i));\n+    }\n+    hotCompactionMergeLock.writeLock().unlock();\n+    hotCompactionLogger.logMergeFinish();\n+  }\n+\n+  @Override\n+  public List<TsFileResource> getMergeTsFileList(boolean sequence) {\n+    if (sequence) {\n+      return sequenceTsFileResources.get(maxLevelNum - 1);\n+    } else {\n+      return unSequenceTsFileResources.get(maxLevelNum - 1);\n+    }\n+  }\n+\n+  @Override\n+  public List<TsFileResource> getTsFileList(boolean sequence) {\n+    List<TsFileResource> result = new ArrayList<>();\n+    if (sequence) {\n+      for (int i = sequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result.addAll(sequenceTsFileResources.get(i));\n+      }\n+    } else {\n+      for (int i = unSequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result.addAll(unSequenceTsFileResources.get(i));\n+      }\n+    }\n+    return result;\n+  }\n+\n+  @Override\n+  public Iterator<TsFileResource> getIterator(boolean sequence) {\n+    return getTsFileList(sequence).iterator();\n+  }\n+\n+  @Override\n+  public void remove(TsFileResource tsFileResource, boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        sequenceTsFileResource.remove(tsFileResource);\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        unSequenceTsFileResource.remove(tsFileResource);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void removeAll(List<TsFileResource> tsFileResourceList, boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        sequenceTsFileResource.removeAll(tsFileResourceList);\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        unSequenceTsFileResource.removeAll(tsFileResourceList);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void add(TsFileResource tsFileResource, boolean sequence) {\n+    int level = getMergeLevel(tsFileResource.getTsFile());\n+    if (level <= maxLevelNum - 1) {\n+      if (sequence) {\n+        sequenceTsFileResources.get(level).add(tsFileResource);\n+      } else {\n+        unSequenceTsFileResources.get(level).add(tsFileResource);\n+      }\n+    } else {\n+      if (sequence) {\n+        sequenceTsFileResources.get(maxLevelNum).add(tsFileResource);\n+      } else {\n+        unSequenceTsFileResources.get(maxLevelNum).add(tsFileResource);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void addAll(List<TsFileResource> tsFileResourceList, boolean sequence) {\n+    for (TsFileResource tsFileResource : tsFileResourceList) {\n+      add(tsFileResource, sequence);\n+    }\n+  }\n+\n+  @Override\n+  public void addMerged(TsFileResource tsFileResource, boolean sequence) {\n+    if (sequence) {\n+      sequenceTsFileResources.get(maxLevelNum - 1).add(tsFileResource);\n+    } else {\n+      unSequenceTsFileResources.get(maxLevelNum - 1).add(tsFileResource);\n+    }\n+  }\n+\n+  @Override\n+  public void addMergedAll(List<TsFileResource> tsFileResourceList, boolean sequence) {\n+    if (sequence) {\n+      sequenceTsFileResources.get(maxLevelNum - 1).addAll(tsFileResourceList);\n+    } else {\n+      unSequenceTsFileResources.get(maxLevelNum - 1).addAll(tsFileResourceList);\n+    }\n+  }\n+\n+  @Override\n+  public boolean contains(TsFileResource tsFileResource, boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        if (sequenceTsFileResource.contains(tsFileResource)) {\n+          return true;\n+        }\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        if (unSequenceTsFileResource.contains(tsFileResource)) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public void clear() {\n+    sequenceTsFileResources.clear();\n+    for (int i = 0; i < maxLevelNum + 1; i++) {\n+      sequenceTsFileResources.add(new CopyOnWriteArrayList<>());\n+    }\n+    unSequenceTsFileResources.clear();\n+    for (int i = 0; i < maxLevelNum + 1; i++) {\n+      unSequenceTsFileResources.add(new CopyOnWriteArrayList<>());\n+    }\n+  }\n+\n+  @Override\n+  public boolean isEmpty(boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        if (!sequenceTsFileResource.isEmpty()) {\n+          return false;\n+        }\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        if (!unSequenceTsFileResource.isEmpty()) {\n+          return false;\n+        }\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int size(boolean sequence) {\n+    int result = 0;\n+    if (sequence) {\n+      for (int i = sequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result += sequenceTsFileResources.size();\n+      }\n+    } else {\n+      for (int i = unSequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result += unSequenceTsFileResources.size();\n+      }\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * recover files\n+   */\n+  @Override\n+  public void recover() {\n+    File logFile = FSFactoryProducer.getFSFactory()\n+        .getFile(storageGroupDir, storageGroupName + HOT_COMPACTION_LOG_NAME);\n+    try {\n+      if (logFile.exists()) {\n+        HotCompactionLogAnalyzer logAnalyzer = new HotCompactionLogAnalyzer(logFile);\n+        logAnalyzer.analyze();\n+        Set<String> deviceSet = logAnalyzer.getDeviceSet();\n+        List<File> sourceFileList = logAnalyzer.getSourceFiles();\n+        long offset = logAnalyzer.getOffset();\n+        File targetFile = logAnalyzer.getTargetFile();\n+        boolean isMergeFinished = logAnalyzer.isMergeFinished();\n+        boolean fullMerge = logAnalyzer.isFullMerge();\n+        boolean isSeq = logAnalyzer.isSeq();\n+        if (targetFile == null) {\n+          return;\n+        }\n+        if (fullMerge) {\n+          if (!isMergeFinished) {\n+            RestorableTsFileIOWriter writer = new RestorableTsFileIOWriter(targetFile);\n+            writer.getIOWriterOut().truncate(offset - 1);\n+            writer.close();\n+            HotCompactionUtils\n+                .merge(new TsFileResource(targetFile), getTsFileList(isSeq), storageGroupName,\n+                    new HotCompactionLogger(storageGroupDir, storageGroupName), deviceSet, isSeq);\n+            if (isSeq) {\n+              for (List<TsFileResource> currMergeFile : sequenceTsFileResources) {\n+                deleteLevelFiles(currMergeFile);\n+              }\n+            } else {\n+              for (List<TsFileResource> currMergeFile : unSequenceTsFileResources) {\n+                deleteLevelFiles(currMergeFile);\n+              }\n+            }\n+          }\n+        } else {\n+          TsFileResource targetResource = new TsFileResource(targetFile);\n+          RestorableTsFileIOWriter writer = new RestorableTsFileIOWriter(targetFile);\n+          if (sourceFileList.isEmpty()) {\n+            return;\n+          }\n+          int level = getMergeLevel(sourceFileList.get(0));\n+          if (!isMergeFinished) {\n+            if (deviceSet.isEmpty()) {\n+              Files.delete(targetFile.toPath());\n+            } else {\n+              writer.getIOWriterOut().truncate(offset - 1);\n+              writer.close();\n+              if (isSeq) {\n+                HotCompactionUtils\n+                    .merge(targetResource, sequenceTsFileResources.get(level),\n+                        storageGroupName,\n+                        new HotCompactionLogger(storageGroupDir, storageGroupName), deviceSet,\n+                        true);\n+                deleteLevelFiles(sequenceTsFileResources.get(level));\n+                sequenceTsFileResources.get(level + 1).add(targetResource);\n+              } else {\n+                HotCompactionUtils\n+                    .merge(targetResource, unSequenceTsFileResources.get(level),\n+                        storageGroupName,\n+                        new HotCompactionLogger(storageGroupDir, storageGroupName), deviceSet,\n+                        false);\n+                deleteLevelFiles(unSequenceTsFileResources.get(level));\n+                unSequenceTsFileResources.get(level + 1).add(targetResource);\n+              }\n+            }\n+          }\n+        }\n+      }\n+    } catch (IOException e) {\n+      logger.error(\"recover vm error \", e);\n+    } finally {\n+      if (logFile.exists()) {\n+        try {\n+          Files.delete(logFile.toPath());\n+        } catch (IOException e) {\n+          logger.error(\"delete vm log file error \", e);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void forkCurrentFileList() {\n+    forkTsFileList(forkedSequenceTsFileResources, sequenceTsFileResources);\n+    forkTsFileList(forkedUnSequenceTsFileResources, unSequenceTsFileResources);\n+  }\n+\n+  private void forkTsFileList(List<List<TsFileResource>> forkedSequenceTsFileResources,\n+      List<List<TsFileResource>> sequenceTsFileResources) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc9770b47fc2e28edfc868fb334074e27d701e24"}, "originalPosition": 371}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzQ2Mjk5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/tsfilemanagement/level/LevelTsFileManagement.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjoxOTozOVrOG-1Ouw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzowMzo1NlrOG-2x_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzNzAxOQ==", "bodyText": "sequenceTsFileResources' size is maxLevelNum + 1, so should the maxLevelNum - 1 be maxLevelNum?", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468537019", "createdAt": "2020-08-11T12:19:39Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/tsfilemanagement/level/LevelTsFileManagement.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.tsfilemanagement.level;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.FILE_NAME_SEPARATOR;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.HOT_COMPACTION_LOG_NAME;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.SOURCE_NAME;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.TARGET_NAME;\n+import static org.apache.iotdb.tsfile.common.constant.TsFileConstant.TSFILE_SUFFIX;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.cache.ChunkMetadataCache;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.engine.tsfilemanagement.TsFileManagement;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogAnalyzer;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionUtils;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetadata;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.iotdb.tsfile.write.writer.RestorableTsFileIOWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class LevelTsFileManagement extends TsFileManagement {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(LevelTsFileManagement.class);\n+  private int maxLevelNum = IoTDBDescriptor.getInstance().getConfig().getMaxLevelNum();\n+  private final List<List<TsFileResource>> sequenceTsFileResources = new CopyOnWriteArrayList<>();\n+  private final List<List<TsFileResource>> unSequenceTsFileResources = new CopyOnWriteArrayList<>();\n+  private final List<List<TsFileResource>> forkedSequenceTsFileResources = new ArrayList<>();\n+  private final List<List<TsFileResource>> forkedUnSequenceTsFileResources = new ArrayList<>();\n+\n+  public LevelTsFileManagement(String storageGroupName, String storageGroupDir) {\n+    super(storageGroupName, storageGroupDir);\n+    clear();\n+  }\n+\n+  private void deleteLevelFiles(List<TsFileResource> vmMergeTsFiles) {\n+    logger.debug(\"{} [hot compaction] merge starts to delete file\", storageGroupName);\n+    for (TsFileResource vmMergeTsFile : vmMergeTsFiles) {\n+      deleteLevelFile(vmMergeTsFile);\n+    }\n+    for (int i = 0; i < maxLevelNum; i++) {\n+      sequenceTsFileResources.get(i).removeAll(vmMergeTsFiles);\n+      unSequenceTsFileResources.get(i).removeAll(vmMergeTsFiles);\n+    }\n+  }\n+\n+  private static void deleteLevelFile(TsFileResource seqFile) {\n+    seqFile.writeLock();\n+    try {\n+      ChunkMetadataCache.getInstance().remove(seqFile);\n+      FileReaderManager.getInstance().closeFileAndRemoveReader(seqFile.getTsFilePath());\n+      seqFile.setDeleted(true);\n+      if (seqFile.getTsFile().exists()) {\n+        Files.delete(seqFile.getTsFile().toPath());\n+      }\n+    } catch (Exception e) {\n+      logger.error(e.getMessage(), e);\n+    } finally {\n+      seqFile.writeUnlock();\n+    }\n+  }\n+\n+  private void flushAllFilesToLastLevel(List<List<TsFileResource>> currMergeFiles,\n+      HotCompactionLogger hotCompactionLogger, boolean sequence,\n+      ReadWriteLock hotCompactionMergeLock) throws IOException {\n+    TsFileResource sourceFile = currMergeFiles.get(0).get(0);\n+    File newTargetFile = createNewTsFileName(sourceFile.getTsFile(), maxLevelNum - 1);\n+    TsFileResource targetResource = new TsFileResource(newTargetFile);\n+    HotCompactionUtils.merge(targetResource, getTsFileList(sequence),\n+        storageGroupName, hotCompactionLogger, new HashSet<>(), sequence);\n+    hotCompactionLogger.logFullMerge();\n+    hotCompactionLogger.logSequence(sequence);\n+    hotCompactionLogger.logFile(TARGET_NAME, newTargetFile);\n+    hotCompactionMergeLock.writeLock().lock();\n+    for (int i = 0; i < maxLevelNum - 1; i++) {\n+      deleteLevelFiles(currMergeFiles.get(i));\n+    }\n+    hotCompactionMergeLock.writeLock().unlock();\n+    hotCompactionLogger.logMergeFinish();\n+  }\n+\n+  @Override\n+  public List<TsFileResource> getMergeTsFileList(boolean sequence) {\n+    if (sequence) {\n+      return sequenceTsFileResources.get(maxLevelNum - 1);\n+    } else {\n+      return unSequenceTsFileResources.get(maxLevelNum - 1);\n+    }\n+  }\n+\n+  @Override\n+  public List<TsFileResource> getTsFileList(boolean sequence) {\n+    List<TsFileResource> result = new ArrayList<>();\n+    if (sequence) {\n+      for (int i = sequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result.addAll(sequenceTsFileResources.get(i));\n+      }\n+    } else {\n+      for (int i = unSequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result.addAll(unSequenceTsFileResources.get(i));\n+      }\n+    }\n+    return result;\n+  }\n+\n+  @Override\n+  public Iterator<TsFileResource> getIterator(boolean sequence) {\n+    return getTsFileList(sequence).iterator();\n+  }\n+\n+  @Override\n+  public void remove(TsFileResource tsFileResource, boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        sequenceTsFileResource.remove(tsFileResource);\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        unSequenceTsFileResource.remove(tsFileResource);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void removeAll(List<TsFileResource> tsFileResourceList, boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        sequenceTsFileResource.removeAll(tsFileResourceList);\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        unSequenceTsFileResource.removeAll(tsFileResourceList);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void add(TsFileResource tsFileResource, boolean sequence) {\n+    int level = getMergeLevel(tsFileResource.getTsFile());\n+    if (level <= maxLevelNum - 1) {\n+      if (sequence) {\n+        sequenceTsFileResources.get(level).add(tsFileResource);\n+      } else {\n+        unSequenceTsFileResources.get(level).add(tsFileResource);\n+      }\n+    } else {\n+      if (sequence) {\n+        sequenceTsFileResources.get(maxLevelNum).add(tsFileResource);\n+      } else {\n+        unSequenceTsFileResources.get(maxLevelNum).add(tsFileResource);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void addAll(List<TsFileResource> tsFileResourceList, boolean sequence) {\n+    for (TsFileResource tsFileResource : tsFileResourceList) {\n+      add(tsFileResource, sequence);\n+    }\n+  }\n+\n+  @Override\n+  public void addMerged(TsFileResource tsFileResource, boolean sequence) {\n+    if (sequence) {\n+      sequenceTsFileResources.get(maxLevelNum - 1).add(tsFileResource);\n+    } else {\n+      unSequenceTsFileResources.get(maxLevelNum - 1).add(tsFileResource);\n+    }\n+  }\n+\n+  @Override\n+  public void addMergedAll(List<TsFileResource> tsFileResourceList, boolean sequence) {\n+    if (sequence) {\n+      sequenceTsFileResources.get(maxLevelNum - 1).addAll(tsFileResourceList);\n+    } else {\n+      unSequenceTsFileResources.get(maxLevelNum - 1).addAll(tsFileResourceList);\n+    }\n+  }\n+\n+  @Override\n+  public boolean contains(TsFileResource tsFileResource, boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        if (sequenceTsFileResource.contains(tsFileResource)) {\n+          return true;\n+        }\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        if (unSequenceTsFileResource.contains(tsFileResource)) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public void clear() {\n+    sequenceTsFileResources.clear();\n+    for (int i = 0; i < maxLevelNum + 1; i++) {\n+      sequenceTsFileResources.add(new CopyOnWriteArrayList<>());\n+    }\n+    unSequenceTsFileResources.clear();\n+    for (int i = 0; i < maxLevelNum + 1; i++) {\n+      unSequenceTsFileResources.add(new CopyOnWriteArrayList<>());\n+    }\n+  }\n+\n+  @Override\n+  public boolean isEmpty(boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        if (!sequenceTsFileResource.isEmpty()) {\n+          return false;\n+        }\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        if (!unSequenceTsFileResource.isEmpty()) {\n+          return false;\n+        }\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int size(boolean sequence) {\n+    int result = 0;\n+    if (sequence) {\n+      for (int i = sequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result += sequenceTsFileResources.size();\n+      }\n+    } else {\n+      for (int i = unSequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result += unSequenceTsFileResources.size();\n+      }\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * recover files\n+   */\n+  @Override\n+  public void recover() {\n+    File logFile = FSFactoryProducer.getFSFactory()\n+        .getFile(storageGroupDir, storageGroupName + HOT_COMPACTION_LOG_NAME);\n+    try {\n+      if (logFile.exists()) {\n+        HotCompactionLogAnalyzer logAnalyzer = new HotCompactionLogAnalyzer(logFile);\n+        logAnalyzer.analyze();\n+        Set<String> deviceSet = logAnalyzer.getDeviceSet();\n+        List<File> sourceFileList = logAnalyzer.getSourceFiles();\n+        long offset = logAnalyzer.getOffset();\n+        File targetFile = logAnalyzer.getTargetFile();\n+        boolean isMergeFinished = logAnalyzer.isMergeFinished();\n+        boolean fullMerge = logAnalyzer.isFullMerge();\n+        boolean isSeq = logAnalyzer.isSeq();\n+        if (targetFile == null) {\n+          return;\n+        }\n+        if (fullMerge) {\n+          if (!isMergeFinished) {\n+            RestorableTsFileIOWriter writer = new RestorableTsFileIOWriter(targetFile);\n+            writer.getIOWriterOut().truncate(offset - 1);\n+            writer.close();\n+            HotCompactionUtils\n+                .merge(new TsFileResource(targetFile), getTsFileList(isSeq), storageGroupName,\n+                    new HotCompactionLogger(storageGroupDir, storageGroupName), deviceSet, isSeq);\n+            if (isSeq) {\n+              for (List<TsFileResource> currMergeFile : sequenceTsFileResources) {\n+                deleteLevelFiles(currMergeFile);\n+              }\n+            } else {\n+              for (List<TsFileResource> currMergeFile : unSequenceTsFileResources) {\n+                deleteLevelFiles(currMergeFile);\n+              }\n+            }\n+          }\n+        } else {\n+          TsFileResource targetResource = new TsFileResource(targetFile);\n+          RestorableTsFileIOWriter writer = new RestorableTsFileIOWriter(targetFile);\n+          if (sourceFileList.isEmpty()) {\n+            return;\n+          }\n+          int level = getMergeLevel(sourceFileList.get(0));\n+          if (!isMergeFinished) {\n+            if (deviceSet.isEmpty()) {\n+              Files.delete(targetFile.toPath());\n+            } else {\n+              writer.getIOWriterOut().truncate(offset - 1);\n+              writer.close();\n+              if (isSeq) {\n+                HotCompactionUtils\n+                    .merge(targetResource, sequenceTsFileResources.get(level),\n+                        storageGroupName,\n+                        new HotCompactionLogger(storageGroupDir, storageGroupName), deviceSet,\n+                        true);\n+                deleteLevelFiles(sequenceTsFileResources.get(level));\n+                sequenceTsFileResources.get(level + 1).add(targetResource);\n+              } else {\n+                HotCompactionUtils\n+                    .merge(targetResource, unSequenceTsFileResources.get(level),\n+                        storageGroupName,\n+                        new HotCompactionLogger(storageGroupDir, storageGroupName), deviceSet,\n+                        false);\n+                deleteLevelFiles(unSequenceTsFileResources.get(level));\n+                unSequenceTsFileResources.get(level + 1).add(targetResource);\n+              }\n+            }\n+          }\n+        }\n+      }\n+    } catch (IOException e) {\n+      logger.error(\"recover vm error \", e);\n+    } finally {\n+      if (logFile.exists()) {\n+        try {\n+          Files.delete(logFile.toPath());\n+        } catch (IOException e) {\n+          logger.error(\"delete vm log file error \", e);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void forkCurrentFileList() {\n+    forkTsFileList(forkedSequenceTsFileResources, sequenceTsFileResources);\n+    forkTsFileList(forkedUnSequenceTsFileResources, unSequenceTsFileResources);\n+  }\n+\n+  private void forkTsFileList(List<List<TsFileResource>> forkedSequenceTsFileResources,\n+      List<List<TsFileResource>> sequenceTsFileResources) {\n+    forkedSequenceTsFileResources.clear();\n+    for (int i = 0; i < maxLevelNum - 1; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc9770b47fc2e28edfc868fb334074e27d701e24"}, "originalPosition": 373}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU2MjQzMA==", "bodyText": "no, the maxLevelNum - 1 is the last level of hot compaction, and the maxLevelNum is for the all merge completed level", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468562430", "createdAt": "2020-08-11T13:03:56Z", "author": {"login": "zhanglingzhe0820"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/tsfilemanagement/level/LevelTsFileManagement.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.tsfilemanagement.level;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.FILE_NAME_SEPARATOR;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.HOT_COMPACTION_LOG_NAME;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.SOURCE_NAME;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.TARGET_NAME;\n+import static org.apache.iotdb.tsfile.common.constant.TsFileConstant.TSFILE_SUFFIX;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.cache.ChunkMetadataCache;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.engine.tsfilemanagement.TsFileManagement;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogAnalyzer;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionUtils;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetadata;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.iotdb.tsfile.write.writer.RestorableTsFileIOWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class LevelTsFileManagement extends TsFileManagement {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(LevelTsFileManagement.class);\n+  private int maxLevelNum = IoTDBDescriptor.getInstance().getConfig().getMaxLevelNum();\n+  private final List<List<TsFileResource>> sequenceTsFileResources = new CopyOnWriteArrayList<>();\n+  private final List<List<TsFileResource>> unSequenceTsFileResources = new CopyOnWriteArrayList<>();\n+  private final List<List<TsFileResource>> forkedSequenceTsFileResources = new ArrayList<>();\n+  private final List<List<TsFileResource>> forkedUnSequenceTsFileResources = new ArrayList<>();\n+\n+  public LevelTsFileManagement(String storageGroupName, String storageGroupDir) {\n+    super(storageGroupName, storageGroupDir);\n+    clear();\n+  }\n+\n+  private void deleteLevelFiles(List<TsFileResource> vmMergeTsFiles) {\n+    logger.debug(\"{} [hot compaction] merge starts to delete file\", storageGroupName);\n+    for (TsFileResource vmMergeTsFile : vmMergeTsFiles) {\n+      deleteLevelFile(vmMergeTsFile);\n+    }\n+    for (int i = 0; i < maxLevelNum; i++) {\n+      sequenceTsFileResources.get(i).removeAll(vmMergeTsFiles);\n+      unSequenceTsFileResources.get(i).removeAll(vmMergeTsFiles);\n+    }\n+  }\n+\n+  private static void deleteLevelFile(TsFileResource seqFile) {\n+    seqFile.writeLock();\n+    try {\n+      ChunkMetadataCache.getInstance().remove(seqFile);\n+      FileReaderManager.getInstance().closeFileAndRemoveReader(seqFile.getTsFilePath());\n+      seqFile.setDeleted(true);\n+      if (seqFile.getTsFile().exists()) {\n+        Files.delete(seqFile.getTsFile().toPath());\n+      }\n+    } catch (Exception e) {\n+      logger.error(e.getMessage(), e);\n+    } finally {\n+      seqFile.writeUnlock();\n+    }\n+  }\n+\n+  private void flushAllFilesToLastLevel(List<List<TsFileResource>> currMergeFiles,\n+      HotCompactionLogger hotCompactionLogger, boolean sequence,\n+      ReadWriteLock hotCompactionMergeLock) throws IOException {\n+    TsFileResource sourceFile = currMergeFiles.get(0).get(0);\n+    File newTargetFile = createNewTsFileName(sourceFile.getTsFile(), maxLevelNum - 1);\n+    TsFileResource targetResource = new TsFileResource(newTargetFile);\n+    HotCompactionUtils.merge(targetResource, getTsFileList(sequence),\n+        storageGroupName, hotCompactionLogger, new HashSet<>(), sequence);\n+    hotCompactionLogger.logFullMerge();\n+    hotCompactionLogger.logSequence(sequence);\n+    hotCompactionLogger.logFile(TARGET_NAME, newTargetFile);\n+    hotCompactionMergeLock.writeLock().lock();\n+    for (int i = 0; i < maxLevelNum - 1; i++) {\n+      deleteLevelFiles(currMergeFiles.get(i));\n+    }\n+    hotCompactionMergeLock.writeLock().unlock();\n+    hotCompactionLogger.logMergeFinish();\n+  }\n+\n+  @Override\n+  public List<TsFileResource> getMergeTsFileList(boolean sequence) {\n+    if (sequence) {\n+      return sequenceTsFileResources.get(maxLevelNum - 1);\n+    } else {\n+      return unSequenceTsFileResources.get(maxLevelNum - 1);\n+    }\n+  }\n+\n+  @Override\n+  public List<TsFileResource> getTsFileList(boolean sequence) {\n+    List<TsFileResource> result = new ArrayList<>();\n+    if (sequence) {\n+      for (int i = sequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result.addAll(sequenceTsFileResources.get(i));\n+      }\n+    } else {\n+      for (int i = unSequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result.addAll(unSequenceTsFileResources.get(i));\n+      }\n+    }\n+    return result;\n+  }\n+\n+  @Override\n+  public Iterator<TsFileResource> getIterator(boolean sequence) {\n+    return getTsFileList(sequence).iterator();\n+  }\n+\n+  @Override\n+  public void remove(TsFileResource tsFileResource, boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        sequenceTsFileResource.remove(tsFileResource);\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        unSequenceTsFileResource.remove(tsFileResource);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void removeAll(List<TsFileResource> tsFileResourceList, boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        sequenceTsFileResource.removeAll(tsFileResourceList);\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        unSequenceTsFileResource.removeAll(tsFileResourceList);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void add(TsFileResource tsFileResource, boolean sequence) {\n+    int level = getMergeLevel(tsFileResource.getTsFile());\n+    if (level <= maxLevelNum - 1) {\n+      if (sequence) {\n+        sequenceTsFileResources.get(level).add(tsFileResource);\n+      } else {\n+        unSequenceTsFileResources.get(level).add(tsFileResource);\n+      }\n+    } else {\n+      if (sequence) {\n+        sequenceTsFileResources.get(maxLevelNum).add(tsFileResource);\n+      } else {\n+        unSequenceTsFileResources.get(maxLevelNum).add(tsFileResource);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void addAll(List<TsFileResource> tsFileResourceList, boolean sequence) {\n+    for (TsFileResource tsFileResource : tsFileResourceList) {\n+      add(tsFileResource, sequence);\n+    }\n+  }\n+\n+  @Override\n+  public void addMerged(TsFileResource tsFileResource, boolean sequence) {\n+    if (sequence) {\n+      sequenceTsFileResources.get(maxLevelNum - 1).add(tsFileResource);\n+    } else {\n+      unSequenceTsFileResources.get(maxLevelNum - 1).add(tsFileResource);\n+    }\n+  }\n+\n+  @Override\n+  public void addMergedAll(List<TsFileResource> tsFileResourceList, boolean sequence) {\n+    if (sequence) {\n+      sequenceTsFileResources.get(maxLevelNum - 1).addAll(tsFileResourceList);\n+    } else {\n+      unSequenceTsFileResources.get(maxLevelNum - 1).addAll(tsFileResourceList);\n+    }\n+  }\n+\n+  @Override\n+  public boolean contains(TsFileResource tsFileResource, boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        if (sequenceTsFileResource.contains(tsFileResource)) {\n+          return true;\n+        }\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        if (unSequenceTsFileResource.contains(tsFileResource)) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public void clear() {\n+    sequenceTsFileResources.clear();\n+    for (int i = 0; i < maxLevelNum + 1; i++) {\n+      sequenceTsFileResources.add(new CopyOnWriteArrayList<>());\n+    }\n+    unSequenceTsFileResources.clear();\n+    for (int i = 0; i < maxLevelNum + 1; i++) {\n+      unSequenceTsFileResources.add(new CopyOnWriteArrayList<>());\n+    }\n+  }\n+\n+  @Override\n+  public boolean isEmpty(boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        if (!sequenceTsFileResource.isEmpty()) {\n+          return false;\n+        }\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        if (!unSequenceTsFileResource.isEmpty()) {\n+          return false;\n+        }\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int size(boolean sequence) {\n+    int result = 0;\n+    if (sequence) {\n+      for (int i = sequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result += sequenceTsFileResources.size();\n+      }\n+    } else {\n+      for (int i = unSequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result += unSequenceTsFileResources.size();\n+      }\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * recover files\n+   */\n+  @Override\n+  public void recover() {\n+    File logFile = FSFactoryProducer.getFSFactory()\n+        .getFile(storageGroupDir, storageGroupName + HOT_COMPACTION_LOG_NAME);\n+    try {\n+      if (logFile.exists()) {\n+        HotCompactionLogAnalyzer logAnalyzer = new HotCompactionLogAnalyzer(logFile);\n+        logAnalyzer.analyze();\n+        Set<String> deviceSet = logAnalyzer.getDeviceSet();\n+        List<File> sourceFileList = logAnalyzer.getSourceFiles();\n+        long offset = logAnalyzer.getOffset();\n+        File targetFile = logAnalyzer.getTargetFile();\n+        boolean isMergeFinished = logAnalyzer.isMergeFinished();\n+        boolean fullMerge = logAnalyzer.isFullMerge();\n+        boolean isSeq = logAnalyzer.isSeq();\n+        if (targetFile == null) {\n+          return;\n+        }\n+        if (fullMerge) {\n+          if (!isMergeFinished) {\n+            RestorableTsFileIOWriter writer = new RestorableTsFileIOWriter(targetFile);\n+            writer.getIOWriterOut().truncate(offset - 1);\n+            writer.close();\n+            HotCompactionUtils\n+                .merge(new TsFileResource(targetFile), getTsFileList(isSeq), storageGroupName,\n+                    new HotCompactionLogger(storageGroupDir, storageGroupName), deviceSet, isSeq);\n+            if (isSeq) {\n+              for (List<TsFileResource> currMergeFile : sequenceTsFileResources) {\n+                deleteLevelFiles(currMergeFile);\n+              }\n+            } else {\n+              for (List<TsFileResource> currMergeFile : unSequenceTsFileResources) {\n+                deleteLevelFiles(currMergeFile);\n+              }\n+            }\n+          }\n+        } else {\n+          TsFileResource targetResource = new TsFileResource(targetFile);\n+          RestorableTsFileIOWriter writer = new RestorableTsFileIOWriter(targetFile);\n+          if (sourceFileList.isEmpty()) {\n+            return;\n+          }\n+          int level = getMergeLevel(sourceFileList.get(0));\n+          if (!isMergeFinished) {\n+            if (deviceSet.isEmpty()) {\n+              Files.delete(targetFile.toPath());\n+            } else {\n+              writer.getIOWriterOut().truncate(offset - 1);\n+              writer.close();\n+              if (isSeq) {\n+                HotCompactionUtils\n+                    .merge(targetResource, sequenceTsFileResources.get(level),\n+                        storageGroupName,\n+                        new HotCompactionLogger(storageGroupDir, storageGroupName), deviceSet,\n+                        true);\n+                deleteLevelFiles(sequenceTsFileResources.get(level));\n+                sequenceTsFileResources.get(level + 1).add(targetResource);\n+              } else {\n+                HotCompactionUtils\n+                    .merge(targetResource, unSequenceTsFileResources.get(level),\n+                        storageGroupName,\n+                        new HotCompactionLogger(storageGroupDir, storageGroupName), deviceSet,\n+                        false);\n+                deleteLevelFiles(unSequenceTsFileResources.get(level));\n+                unSequenceTsFileResources.get(level + 1).add(targetResource);\n+              }\n+            }\n+          }\n+        }\n+      }\n+    } catch (IOException e) {\n+      logger.error(\"recover vm error \", e);\n+    } finally {\n+      if (logFile.exists()) {\n+        try {\n+          Files.delete(logFile.toPath());\n+        } catch (IOException e) {\n+          logger.error(\"delete vm log file error \", e);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void forkCurrentFileList() {\n+    forkTsFileList(forkedSequenceTsFileResources, sequenceTsFileResources);\n+    forkTsFileList(forkedUnSequenceTsFileResources, unSequenceTsFileResources);\n+  }\n+\n+  private void forkTsFileList(List<List<TsFileResource>> forkedSequenceTsFileResources,\n+      List<List<TsFileResource>> sequenceTsFileResources) {\n+    forkedSequenceTsFileResources.clear();\n+    for (int i = 0; i < maxLevelNum - 1; i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzNzAxOQ=="}, "originalCommit": {"oid": "dc9770b47fc2e28edfc868fb334074e27d701e24"}, "originalPosition": 373}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4631, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}