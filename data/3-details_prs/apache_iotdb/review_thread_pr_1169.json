{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1MDM4Njgx", "number": 1169, "reviewThreads": {"totalCount": 39, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODowNjoxNlrOD79InQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjoxMDowNFrOD-Skdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTk0MjA1OnYy", "diffSide": "RIGHT", "path": "jdbc/src/main/java/org/apache/iotdb/jdbc/Config.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODowNjoxNlrOGUmIJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMjowNzowOVrOGVJl0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0OTM4Mg==", "bodyText": "why set it as true?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r424249382", "createdAt": "2020-05-13T08:06:16Z", "author": {"login": "jixuan1989"}, "path": "jdbc/src/main/java/org/apache/iotdb/jdbc/Config.java", "diffHunk": "@@ -52,6 +52,6 @@ private Config(){}\n \n   public static final String JDBC_DRIVER_NAME = \"org.apache.iotdb.jdbc.IoTDBDriver\";\n \n-  public static boolean rpcThriftCompressionEnable = false;\n+  public static boolean rpcThriftCompressionEnable = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e884f7641b81b156068160b456f82f9bcfbb520"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgzMDQxOA==", "bodyText": "It is said in thrift that when the thrift structures are large and sent frequently, it will be overall better to enable compression, so I made the default compression true.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r424830418", "createdAt": "2020-05-14T02:07:09Z", "author": {"login": "jt2594838"}, "path": "jdbc/src/main/java/org/apache/iotdb/jdbc/Config.java", "diffHunk": "@@ -52,6 +52,6 @@ private Config(){}\n \n   public static final String JDBC_DRIVER_NAME = \"org.apache.iotdb.jdbc.IoTDBDriver\";\n \n-  public static boolean rpcThriftCompressionEnable = false;\n+  public static boolean rpcThriftCompressionEnable = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0OTM4Mg=="}, "originalCommit": {"oid": "0e884f7641b81b156068160b456f82f9bcfbb520"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTIxMjY0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMjowODozM1rOGWlnAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozMDowMlrOGXNq4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzODA0OA==", "bodyText": "Should we change rpcThriftCompressionEnable and other changed configs in server/src/assembly/resources/conf/iotdb-engine.property as well?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426338048", "createdAt": "2020-05-18T02:08:33Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -96,7 +96,7 @@\n   /**\n    * whether to use thrift compression.\n    */\n-  private boolean rpcThriftCompressionEnable = false;\n+  private boolean rpcThriftCompressionEnable = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76acdd59ee12c227464659f142056028167a988e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NDQwMQ==", "bodyText": "Someone questioned this change so I am waiting for further experimental reports. And I think it is okay as long as the config files and config classes are consistent separately.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426994401", "createdAt": "2020-05-19T02:30:02Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -96,7 +96,7 @@\n   /**\n    * whether to use thrift compression.\n    */\n-  private boolean rpcThriftCompressionEnable = false;\n+  private boolean rpcThriftCompressionEnable = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzODA0OA=="}, "originalCommit": {"oid": "76acdd59ee12c227464659f142056028167a988e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTUzMDE0OnYy", "diffSide": "RIGHT", "path": "session/src/main/java/org/apache/iotdb/session/Session.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjowNDo1NVrOGWokug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMTo0NjozMFrOGYHr6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4NjYxOA==", "bodyText": "there is a field enableRPCCompression, better to change it to true", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426386618", "createdAt": "2020-05-18T06:04:55Z", "author": {"login": "qiaojialin"}, "path": "session/src/main/java/org/apache/iotdb/session/Session.java", "diffHunk": "@@ -105,7 +107,7 @@ public Session(String host, int port, String username, String password, int fetc\n   }\n \n   public synchronized void open() throws IoTDBConnectionException {\n-    open(false, Config.DEFAULT_TIMEOUT_MS);\n+    open(true, Config.DEFAULT_TIMEOUT_MS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0NDkzOQ==", "bodyText": "changed", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427944939", "createdAt": "2020-05-20T11:46:30Z", "author": {"login": "jt2594838"}, "path": "session/src/main/java/org/apache/iotdb/session/Session.java", "diffHunk": "@@ -105,7 +107,7 @@ public Session(String host, int port, String username, String password, int fetc\n   }\n \n   public synchronized void open() throws IoTDBConnectionException {\n-    open(false, Config.DEFAULT_TIMEOUT_MS);\n+    open(true, Config.DEFAULT_TIMEOUT_MS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4NjYxOA=="}, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTgxNzc0OnYy", "diffSide": "RIGHT", "path": "service-rpc/src/main/thrift/cluster.thrift", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzo1MTo0MFrOGWrVGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozMTo1OFrOGXNtCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMTc3MA==", "bodyText": "Please don't forget to update the rpc-changelist.md file.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426431770", "createdAt": "2020-05-18T07:51:40Z", "author": {"login": "HTHou"}, "path": "service-rpc/src/main/thrift/cluster.thrift", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+include \"rpc.thrift\"\n+namespace java org.apache.iotdb.cluster.rpc.thrift\n+\n+typedef i32 int \n+typedef i16 short\n+typedef i64 long\n+\n+// leader -> follower\n+struct HeartBeatRequest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NDk1Mw==", "bodyText": "This is not the final version and since it is not used anywhere in master, it is not necessary to put it into the list now. I will add this to the list when the distributed version is ready.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426994953", "createdAt": "2020-05-19T02:31:58Z", "author": {"login": "jt2594838"}, "path": "service-rpc/src/main/thrift/cluster.thrift", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+include \"rpc.thrift\"\n+namespace java org.apache.iotdb.cluster.rpc.thrift\n+\n+typedef i32 int \n+typedef i16 short\n+typedef i64 long\n+\n+// leader -> follower\n+struct HeartBeatRequest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMTc3MA=="}, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTgzNzI3OnYy", "diffSide": "RIGHT", "path": "service-rpc/src/main/thrift/cluster.thrift", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzo1NzoxMFrOGWrhGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzo1NzoxMFrOGWrhGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzNDg0MA==", "bodyText": "format\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            // leader -> follower\n          \n          \n            \n            struct StartUpStatus {\n          \n          \n            \n             1: required long partitionInterval\n          \n          \n            \n             2: required int hashSalt\n          \n          \n            \n             3: required int replicationNumber\n          \n          \n            \n            }\n          \n          \n            \n            \n          \n          \n            \n            // leader -> follower\n          \n          \n            \n            struct StartUpStatus {\n          \n          \n            \n              1: required long partitionInterval\n          \n          \n            \n              2: required int hashSalt\n          \n          \n            \n              3: required int replicationNumber\n          \n          \n            \n            }", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426434840", "createdAt": "2020-05-18T07:57:10Z", "author": {"login": "HTHou"}, "path": "service-rpc/src/main/thrift/cluster.thrift", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+include \"rpc.thrift\"\n+namespace java org.apache.iotdb.cluster.rpc.thrift\n+\n+typedef i32 int \n+typedef i16 short\n+typedef i64 long\n+\n+// leader -> follower\n+struct HeartBeatRequest {\n+  1: required long term // leader's meta log\n+  2: required long commitLogIndex  // leader's meta log\n+  3: required long commitLogTerm\n+  4: required Node leader\n+  // if the leader does not know the follower's id, and require it reports to the leader, then true\n+  5: required bool requireIdentifier\n+  6: required bool regenerateIdentifier //if the leader finds the follower's id is conflicted,\n+  // then true\n+  // serialized partitionTable\n+  7: optional binary partitionTableBytes\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  8: optional Node header\n+}\n+\n+// follower -> leader\n+struct HeartBeatResponse {\n+  1: required long term\n+  2: optional long lastLogIndex // follower's meta log\n+  3: optional long lastLogTerm // follower's meta log\n+  // used to perform a catch up when necessary\n+  4: optional Node follower\n+  5: optional int followerIdentifier\n+  6: required bool requirePartitionTable\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+// node -> node\n+struct ElectionRequest {\n+  1: required long term\n+  2: required long lastLogTerm\n+  3: required long lastLogIndex\n+  4: required Node elector\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  5: optional Node header\n+  6: optional long dataLogLastIndex\n+  7: optional long dataLogLastTerm\n+}\n+\n+// leader -> follower\n+struct AppendEntryRequest {\n+  1: required long term // leader's\n+  2: required Node leader\n+  3: required long prevLogIndex\n+  4: required long prevLogTerm\n+  5: required long leaderCommit\n+  6: required binary entry // data\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+// leader -> follower\n+struct AppendEntriesRequest {\n+  1: required long term // leader's\n+  2: required Node leader\n+  3: required list<binary> entries // data\n+  4: required long prevLogIndex\n+  5: required long prevLogTerm\n+  6: required long leaderCommit\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+struct AddNodeResponse {\n+  // -1: accept to add new node or the node is already in this cluster, otherwise: fail to\n+  // add new node\n+  1: required int respNum\n+  2: optional binary partitionTableBytes\n+  3: optional CheckStatusResponse checkStatusResponse\n+}\n+\n+struct Node {\n+  1: required string ip\n+  2: required int metaPort\n+  3: required int nodeIdentifier\n+  4: required int dataPort\n+}\n+\n+// leader -> follower\n+struct StartUpStatus {\n+ 1: required long partitionInterval\n+ 2: required int hashSalt\n+ 3: required int replicationNumber\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTg0MDc0OnYy", "diffSide": "RIGHT", "path": "service-rpc/src/main/thrift/cluster.thrift", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzo1ODowNVrOGWrjSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzo1ODowNVrOGWrjSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzNTQwMA==", "bodyText": "format\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // follower -> leader\n          \n          \n            \n            struct CheckStatusResponse {\n          \n          \n            \n             1: required bool partitionalIntervalEquals\n          \n          \n            \n             2: required bool hashSaltEquals\n          \n          \n            \n             3: required bool replicationNumEquals\n          \n          \n            \n            }\n          \n          \n            \n            // follower -> leader\n          \n          \n            \n            struct CheckStatusResponse {\n          \n          \n            \n              1: required bool partitionalIntervalEquals\n          \n          \n            \n              2: required bool hashSaltEquals\n          \n          \n            \n              3: required bool replicationNumEquals\n          \n          \n            \n            }", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426435400", "createdAt": "2020-05-18T07:58:05Z", "author": {"login": "HTHou"}, "path": "service-rpc/src/main/thrift/cluster.thrift", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+include \"rpc.thrift\"\n+namespace java org.apache.iotdb.cluster.rpc.thrift\n+\n+typedef i32 int \n+typedef i16 short\n+typedef i64 long\n+\n+// leader -> follower\n+struct HeartBeatRequest {\n+  1: required long term // leader's meta log\n+  2: required long commitLogIndex  // leader's meta log\n+  3: required long commitLogTerm\n+  4: required Node leader\n+  // if the leader does not know the follower's id, and require it reports to the leader, then true\n+  5: required bool requireIdentifier\n+  6: required bool regenerateIdentifier //if the leader finds the follower's id is conflicted,\n+  // then true\n+  // serialized partitionTable\n+  7: optional binary partitionTableBytes\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  8: optional Node header\n+}\n+\n+// follower -> leader\n+struct HeartBeatResponse {\n+  1: required long term\n+  2: optional long lastLogIndex // follower's meta log\n+  3: optional long lastLogTerm // follower's meta log\n+  // used to perform a catch up when necessary\n+  4: optional Node follower\n+  5: optional int followerIdentifier\n+  6: required bool requirePartitionTable\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+// node -> node\n+struct ElectionRequest {\n+  1: required long term\n+  2: required long lastLogTerm\n+  3: required long lastLogIndex\n+  4: required Node elector\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  5: optional Node header\n+  6: optional long dataLogLastIndex\n+  7: optional long dataLogLastTerm\n+}\n+\n+// leader -> follower\n+struct AppendEntryRequest {\n+  1: required long term // leader's\n+  2: required Node leader\n+  3: required long prevLogIndex\n+  4: required long prevLogTerm\n+  5: required long leaderCommit\n+  6: required binary entry // data\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+// leader -> follower\n+struct AppendEntriesRequest {\n+  1: required long term // leader's\n+  2: required Node leader\n+  3: required list<binary> entries // data\n+  4: required long prevLogIndex\n+  5: required long prevLogTerm\n+  6: required long leaderCommit\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+struct AddNodeResponse {\n+  // -1: accept to add new node or the node is already in this cluster, otherwise: fail to\n+  // add new node\n+  1: required int respNum\n+  2: optional binary partitionTableBytes\n+  3: optional CheckStatusResponse checkStatusResponse\n+}\n+\n+struct Node {\n+  1: required string ip\n+  2: required int metaPort\n+  3: required int nodeIdentifier\n+  4: required int dataPort\n+}\n+\n+// leader -> follower\n+struct StartUpStatus {\n+ 1: required long partitionInterval\n+ 2: required int hashSalt\n+ 3: required int replicationNumber\n+}\n+\n+// follower -> leader\n+struct CheckStatusResponse {\n+ 1: required bool partitionalIntervalEquals\n+ 2: required bool hashSaltEquals\n+ 3: required bool replicationNumEquals\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTg0NTIzOnYy", "diffSide": "RIGHT", "path": "service-rpc/src/main/thrift/cluster.thrift", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzo1OTozMFrOGWrmSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzo1OTozMFrOGWrmSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzNjE3MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              **/\n          \n          \n            \n            \tHeartBeatResponse sendHeartbeat(1:HeartBeatRequest request);\n          \n          \n            \n              **/\n          \n          \n            \n              HeartBeatResponse sendHeartbeat(1:HeartBeatRequest request);", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426436170", "createdAt": "2020-05-18T07:59:30Z", "author": {"login": "HTHou"}, "path": "service-rpc/src/main/thrift/cluster.thrift", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+include \"rpc.thrift\"\n+namespace java org.apache.iotdb.cluster.rpc.thrift\n+\n+typedef i32 int \n+typedef i16 short\n+typedef i64 long\n+\n+// leader -> follower\n+struct HeartBeatRequest {\n+  1: required long term // leader's meta log\n+  2: required long commitLogIndex  // leader's meta log\n+  3: required long commitLogTerm\n+  4: required Node leader\n+  // if the leader does not know the follower's id, and require it reports to the leader, then true\n+  5: required bool requireIdentifier\n+  6: required bool regenerateIdentifier //if the leader finds the follower's id is conflicted,\n+  // then true\n+  // serialized partitionTable\n+  7: optional binary partitionTableBytes\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  8: optional Node header\n+}\n+\n+// follower -> leader\n+struct HeartBeatResponse {\n+  1: required long term\n+  2: optional long lastLogIndex // follower's meta log\n+  3: optional long lastLogTerm // follower's meta log\n+  // used to perform a catch up when necessary\n+  4: optional Node follower\n+  5: optional int followerIdentifier\n+  6: required bool requirePartitionTable\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+// node -> node\n+struct ElectionRequest {\n+  1: required long term\n+  2: required long lastLogTerm\n+  3: required long lastLogIndex\n+  4: required Node elector\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  5: optional Node header\n+  6: optional long dataLogLastIndex\n+  7: optional long dataLogLastTerm\n+}\n+\n+// leader -> follower\n+struct AppendEntryRequest {\n+  1: required long term // leader's\n+  2: required Node leader\n+  3: required long prevLogIndex\n+  4: required long prevLogTerm\n+  5: required long leaderCommit\n+  6: required binary entry // data\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+// leader -> follower\n+struct AppendEntriesRequest {\n+  1: required long term // leader's\n+  2: required Node leader\n+  3: required list<binary> entries // data\n+  4: required long prevLogIndex\n+  5: required long prevLogTerm\n+  6: required long leaderCommit\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+struct AddNodeResponse {\n+  // -1: accept to add new node or the node is already in this cluster, otherwise: fail to\n+  // add new node\n+  1: required int respNum\n+  2: optional binary partitionTableBytes\n+  3: optional CheckStatusResponse checkStatusResponse\n+}\n+\n+struct Node {\n+  1: required string ip\n+  2: required int metaPort\n+  3: required int nodeIdentifier\n+  4: required int dataPort\n+}\n+\n+// leader -> follower\n+struct StartUpStatus {\n+ 1: required long partitionInterval\n+ 2: required int hashSalt\n+ 3: required int replicationNumber\n+}\n+\n+// follower -> leader\n+struct CheckStatusResponse {\n+ 1: required bool partitionalIntervalEquals\n+ 2: required bool hashSaltEquals\n+ 3: required bool replicationNumEquals\n+}\n+\n+struct SendSnapshotRequest {\n+  1: required binary snapshotBytes\n+  // for data group\n+  2: optional Node header\n+}\n+\n+struct PullSnapshotRequest {\n+  1: required list<int> requiredSlots\n+  // for data group\n+  2: optional Node header\n+  // set to true if the previous holder has been removed from the cluster.\n+  // This will make the previous holder read-only so that different new\n+  // replicas can pull the same snapshot.\n+  3: required bool requireReadOnly\n+}\n+\n+struct PullSnapshotResp {\n+  1: optional map<int, binary> snapshotBytes\n+}\n+\n+struct ExecutNonQueryReq {\n+  1: required binary planBytes\n+  2: optional Node header\n+}\n+\n+struct PullSchemaRequest {\n+  1: required list<string> prefixPaths\n+  2: optional Node header\n+}\n+\n+struct PullSchemaResp {\n+  1: required binary schemaBytes\n+}\n+\n+struct SingleSeriesQueryRequest {\n+  1: required string path\n+  2: optional binary timeFilterBytes\n+  3: optional binary valueFilterBytes\n+  4: required long queryId\n+  5: required Node requester\n+  6: required Node header\n+  7: required int dataTypeOrdinal\n+  8: required set<string> deviceMeasurements\n+}\n+\n+struct PreviousFillRequest {\n+  1: required string path\n+  2: required long queryTime\n+  3: required long beforeRange\n+  4: required long queryId\n+  5: required Node requester\n+  6: required Node header\n+  7: required int dataTypeOrdinal\n+  8: required set<string> deviceMeasurements\n+}\n+\n+// the spec and load of a node, for query coordinating\n+struct TNodeStatus {\n+\n+}\n+\n+struct GetAggrResultRequest {\n+  1: required string path\n+  2: required list<string> aggregations\n+  3: required int dataTypeOrdinal\n+  4: optional binary timeFilterBytes\n+  5: required Node header\n+  6: required long queryId\n+  7: required Node requestor\n+  8: required set<string> deviceMeasurements\n+}\n+\n+struct GroupByRequest {\n+  1: required string path\n+  2: required int dataTypeOrdinal\n+  3: optional binary timeFilterBytes\n+  4: required long queryId\n+  5: required list<int> aggregationTypeOrdinals\n+  6: required Node header\n+  7: required Node requestor\n+  8: required set<string> deviceMeasurements\n+}\n+\n+service RaftService {\n+  /**\n+  * Leader will call this method to all followers to ensure its authority.\n+  * <br>For the receiver,\n+  * The method will check the authority of the leader.\n+  *\n+  * @param request information of the leader\n+  * @return if the leader is valid, HeartBeatResponse.term will set -1, and the follower will tell\n+  * leader its lastLogIndex; otherwise, the follower will tell the fake leader its term.\n+  **/\n+\tHeartBeatResponse sendHeartbeat(1:HeartBeatRequest request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTg1MDE3OnYy", "diffSide": "RIGHT", "path": "service-rpc/src/main/thrift/cluster.thrift", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODowMDo0N1rOGWrpQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODowMDo0N1rOGWrpQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzNjkzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n               /**\n          \n          \n            \n               * When a node is removed from the cluster, if it is not the meta leader, it cannot receive\n          \n          \n            \n               * the commit command by heartbeat since it has been removed, so the leader should tell it\n          \n          \n            \n               * directly that it is no longer in the cluster.\n          \n          \n            \n               **/\n          \n          \n            \n               void exile()\n          \n          \n            \n            \n          \n          \n            \n              /**\n          \n          \n            \n              * When a node is removed from the cluster, if it is not the meta leader, it cannot receive\n          \n          \n            \n              * the commit command by heartbeat since it has been removed, so the leader should tell it\n          \n          \n            \n              * directly that it is no longer in the cluster.\n          \n          \n            \n              **/\n          \n          \n            \n              void exile()", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426436931", "createdAt": "2020-05-18T08:00:47Z", "author": {"login": "HTHou"}, "path": "service-rpc/src/main/thrift/cluster.thrift", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+include \"rpc.thrift\"\n+namespace java org.apache.iotdb.cluster.rpc.thrift\n+\n+typedef i32 int \n+typedef i16 short\n+typedef i64 long\n+\n+// leader -> follower\n+struct HeartBeatRequest {\n+  1: required long term // leader's meta log\n+  2: required long commitLogIndex  // leader's meta log\n+  3: required long commitLogTerm\n+  4: required Node leader\n+  // if the leader does not know the follower's id, and require it reports to the leader, then true\n+  5: required bool requireIdentifier\n+  6: required bool regenerateIdentifier //if the leader finds the follower's id is conflicted,\n+  // then true\n+  // serialized partitionTable\n+  7: optional binary partitionTableBytes\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  8: optional Node header\n+}\n+\n+// follower -> leader\n+struct HeartBeatResponse {\n+  1: required long term\n+  2: optional long lastLogIndex // follower's meta log\n+  3: optional long lastLogTerm // follower's meta log\n+  // used to perform a catch up when necessary\n+  4: optional Node follower\n+  5: optional int followerIdentifier\n+  6: required bool requirePartitionTable\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+// node -> node\n+struct ElectionRequest {\n+  1: required long term\n+  2: required long lastLogTerm\n+  3: required long lastLogIndex\n+  4: required Node elector\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  5: optional Node header\n+  6: optional long dataLogLastIndex\n+  7: optional long dataLogLastTerm\n+}\n+\n+// leader -> follower\n+struct AppendEntryRequest {\n+  1: required long term // leader's\n+  2: required Node leader\n+  3: required long prevLogIndex\n+  4: required long prevLogTerm\n+  5: required long leaderCommit\n+  6: required binary entry // data\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+// leader -> follower\n+struct AppendEntriesRequest {\n+  1: required long term // leader's\n+  2: required Node leader\n+  3: required list<binary> entries // data\n+  4: required long prevLogIndex\n+  5: required long prevLogTerm\n+  6: required long leaderCommit\n+\n+  // because a data server may play many data groups members, this is used to identify which\n+  // member should process the request or response. Only used in data group communication.\n+  7: optional Node header\n+}\n+\n+struct AddNodeResponse {\n+  // -1: accept to add new node or the node is already in this cluster, otherwise: fail to\n+  // add new node\n+  1: required int respNum\n+  2: optional binary partitionTableBytes\n+  3: optional CheckStatusResponse checkStatusResponse\n+}\n+\n+struct Node {\n+  1: required string ip\n+  2: required int metaPort\n+  3: required int nodeIdentifier\n+  4: required int dataPort\n+}\n+\n+// leader -> follower\n+struct StartUpStatus {\n+ 1: required long partitionInterval\n+ 2: required int hashSalt\n+ 3: required int replicationNumber\n+}\n+\n+// follower -> leader\n+struct CheckStatusResponse {\n+ 1: required bool partitionalIntervalEquals\n+ 2: required bool hashSaltEquals\n+ 3: required bool replicationNumEquals\n+}\n+\n+struct SendSnapshotRequest {\n+  1: required binary snapshotBytes\n+  // for data group\n+  2: optional Node header\n+}\n+\n+struct PullSnapshotRequest {\n+  1: required list<int> requiredSlots\n+  // for data group\n+  2: optional Node header\n+  // set to true if the previous holder has been removed from the cluster.\n+  // This will make the previous holder read-only so that different new\n+  // replicas can pull the same snapshot.\n+  3: required bool requireReadOnly\n+}\n+\n+struct PullSnapshotResp {\n+  1: optional map<int, binary> snapshotBytes\n+}\n+\n+struct ExecutNonQueryReq {\n+  1: required binary planBytes\n+  2: optional Node header\n+}\n+\n+struct PullSchemaRequest {\n+  1: required list<string> prefixPaths\n+  2: optional Node header\n+}\n+\n+struct PullSchemaResp {\n+  1: required binary schemaBytes\n+}\n+\n+struct SingleSeriesQueryRequest {\n+  1: required string path\n+  2: optional binary timeFilterBytes\n+  3: optional binary valueFilterBytes\n+  4: required long queryId\n+  5: required Node requester\n+  6: required Node header\n+  7: required int dataTypeOrdinal\n+  8: required set<string> deviceMeasurements\n+}\n+\n+struct PreviousFillRequest {\n+  1: required string path\n+  2: required long queryTime\n+  3: required long beforeRange\n+  4: required long queryId\n+  5: required Node requester\n+  6: required Node header\n+  7: required int dataTypeOrdinal\n+  8: required set<string> deviceMeasurements\n+}\n+\n+// the spec and load of a node, for query coordinating\n+struct TNodeStatus {\n+\n+}\n+\n+struct GetAggrResultRequest {\n+  1: required string path\n+  2: required list<string> aggregations\n+  3: required int dataTypeOrdinal\n+  4: optional binary timeFilterBytes\n+  5: required Node header\n+  6: required long queryId\n+  7: required Node requestor\n+  8: required set<string> deviceMeasurements\n+}\n+\n+struct GroupByRequest {\n+  1: required string path\n+  2: required int dataTypeOrdinal\n+  3: optional binary timeFilterBytes\n+  4: required long queryId\n+  5: required list<int> aggregationTypeOrdinals\n+  6: required Node header\n+  7: required Node requestor\n+  8: required set<string> deviceMeasurements\n+}\n+\n+service RaftService {\n+  /**\n+  * Leader will call this method to all followers to ensure its authority.\n+  * <br>For the receiver,\n+  * The method will check the authority of the leader.\n+  *\n+  * @param request information of the leader\n+  * @return if the leader is valid, HeartBeatResponse.term will set -1, and the follower will tell\n+  * leader its lastLogIndex; otherwise, the follower will tell the fake leader its term.\n+  **/\n+\tHeartBeatResponse sendHeartbeat(1:HeartBeatRequest request);\n+\n+\t/**\n+  * If a node wants to be a leader, it'll call the method to other nodes to get a vote.\n+  * <br>For the receiver,\n+  * The method will check whether the node can be a leader.\n+  *\n+  * @param voteRequest a candidate that wants to be a leader.\n+  * @return -1 means agree, otherwise return the voter's term\n+  **/\n+  long startElection(1:ElectionRequest request);\n+\n+  /**\n+  * Leader will call this method to send a batch of entries to all followers.\n+  * <br>For the receiver,\n+  * The method will check the authority of the leader and if the local log is complete.\n+  * If the leader is valid and local log is complete, the follower will append these entries to local log.\n+  *\n+  * @param request entries that need to be appended and the information of the leader.\n+  * @return -1: agree, -2: log index mismatch , otherwise return the follower's term\n+  **/\n+  long appendEntries(1:AppendEntriesRequest request)\n+\n+  /**\n+  * Leader will call this method to send a entry to all followers.\n+  * <br>For the receiver,\n+  * The method will check the authority of the leader and if the local log is complete.\n+  * If the leader is valid and local log is complete, the follower will append the entry to local log.\n+  *\n+  * @param request entry that needs to be appended and the information of the leader.\n+  * @return -1: agree, -2: log index mismatch , otherwise return the follower's term\n+  **/\n+  long appendEntry(1:AppendEntryRequest request)\n+\n+  void sendSnapshot(1:SendSnapshotRequest request)\n+\n+  /**\n+  * Execute a binarized non-query PhysicalPlan\n+  **/\n+  rpc.TSStatus executeNonQueryPlan(1:ExecutNonQueryReq request)\n+\n+  /**\n+  * Ask the leader for its commit index, used to check whether the node has caught up with the\n+  * leader.\n+  **/\n+  long requestCommitIndex(1:Node header)\n+\n+  binary readFile(1:string filePath, 2:i64 offset, 3:i32 length)\n+}\n+\n+\n+\n+service TSDataService extends RaftService {\n+\n+  /**\n+  * Query a time series without value filter.\n+  * @return a readerId >= 0 if the query succeeds, otherwise the query fails\n+  * TODO-Cluster: support query multiple series in a request\n+  **/\n+  long querySingleSeries(1:SingleSeriesQueryRequest request)\n+\n+  /**\n+  * Fetch at max fetchSize time-value pairs using the resultSetId generated by querySingleSeries.\n+  * @return a ByteBuffer containing the serialized time-value pairs or an empty buffer if there\n+  * are not more results.\n+  **/\n+  binary fetchSingleSeries(1:Node header, 2:long readerId)\n+\n+   /**\n+   * Query a time series and generate an IReaderByTimestamp.\n+   * @return a readerId >= 0 if the query succeeds, otherwise the query fails\n+   **/\n+  long querySingleSeriesByTimestamp(1:SingleSeriesQueryRequest request)\n+\n+   /**\n+   * Fetch one value at given timestamp using the resultSetId generated by\n+   * querySingleSeriesByTimestamp.\n+   * @return a ByteBuffer containing the serialized value or an empty buffer if there\n+   * are not more results.\n+   **/\n+   binary fetchSingleSeriesByTimestamp(1:Node header, 2:long readerId, 3:long timestamp)\n+\n+  /**\n+  * Find the local query established for the remote query and release all its resource.\n+  **/\n+  void endQuery(1:Node header, 2:Node thisNode, 3:long queryId)\n+\n+  /**\n+  * Given path patterns (paths with wildcard), return all paths they match.\n+  **/\n+  list<string> getAllPaths(1:Node header, 2:list<string> path)\n+\n+  /**\n+   * Given path patterns (paths with wildcard), return all devices they match.\n+   **/\n+  set<string> getAllDevices(1:Node header, 2:list<string> path)\n+\n+  list<string> getNodeList(1:Node header, 2:string path, 3:int nodeLevel)\n+\n+  set<string> getChildNodePathInNextLevel(1: Node header, 2: string path)\n+\n+  binary getAllMeasurementSchema(1: Node header, 2: binary planBinary)\n+\n+\n+  list<binary> getAggrResult(1:GetAggrResultRequest request)\n+\n+  PullSnapshotResp pullSnapshot(1:PullSnapshotRequest request)\n+\n+  /**\n+  * Create a GroupByExecutor for a path, executing the given aggregations.\n+  * @return the executorId\n+  **/\n+  long getGroupByExecutor(1:GroupByRequest request)\n+\n+  /**\n+  * Fetch the group by result in the interval [startTime, endTime) from the given executor.\n+  * @return the serialized AggregationResults, each is the result of one of the previously\n+  * required aggregations, and their orders are the same.\n+  **/\n+  list<binary> getGroupByResult(1:Node header, 2:long executorId, 3:long startTime, 4:long endTime)\n+\n+\n+  /**\n+  * Pull all timeseries schemas prefixed by a given path.\n+  **/\n+  PullSchemaResp pullTimeSeriesSchema(1: PullSchemaRequest request)\n+\n+  /**\n+  * Perform a previous fill and return the timevalue pair in binary.\n+  **/\n+  binary previousFill(1: PreviousFillRequest request)\n+}\n+\n+service TSMetaService extends RaftService {\n+  /**\n+  * Node which is not leader will call this method to try to add itself into the cluster as a new node.\n+  * <br>For the receiver,\n+  * If the local node is leader, it'll check whether the cluster can add this new node;\n+  * otherwise, the local node will transfer the request to the leader.\n+  *\n+  * @param node a new node that needs to be added\n+  **/\n+  AddNodeResponse addNode(1: Node node, 2: StartUpStatus startUpStatus)\n+\n+  /**\n+  * Remove a node from the cluster. If the node is not in the cluster or the cluster size will\n+  * less than replication number, the request will be rejected.\n+  * return -1(RESPONSE_AGREE) or -3(RESPONSE_REJECT) or -9(RESPONSE_CLUSTER_TOO_SMALL)\n+  **/\n+  long removeNode(1: Node node)\n+\n+   /**\n+   * When a node is removed from the cluster, if it is not the meta leader, it cannot receive\n+   * the commit command by heartbeat since it has been removed, so the leader should tell it\n+   * directly that it is no longer in the cluster.\n+   **/\n+   void exile()\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 381}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTg3NzY2OnYy", "diffSide": "RIGHT", "path": "service-rpc/src/main/java/org/apache/iotdb/rpc/TSStatusCode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODowODoyN1rOGWr6eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozNToxNVrOGXNw1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0MTMzNw==", "bodyText": "It will be better if you update the docs/UserGuide/4-Client/7-Status Codes.md file as well.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426441337", "createdAt": "2020-05-18T08:08:27Z", "author": {"login": "HTHou"}, "path": "service-rpc/src/main/java/org/apache/iotdb/rpc/TSStatusCode.java", "diffHunk": "@@ -63,10 +63,18 @@\n   READ_ONLY_SYSTEM_ERROR(502),\n   DISK_SPACE_INSUFFICIENT_ERROR(503),\n   START_UP_ERROR(504),\n+\n   WRONG_LOGIN_PASSWORD_ERROR(600),\n   NOT_LOGIN_ERROR(601),\n   NO_PERMISSION_ERROR(602),\n   UNINITIALIZED_AUTH_ERROR(603),\n+\n+  PARTITION_NOT_READY(700),\n+  TIME_OUT(701),\n+  NO_LEADER(702),\n+  UNSUPPORTED_OPERATION(703),\n+  NODE_READ_ONLY(704),\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NTkyNA==", "bodyText": "The same as above: this will be added when the distributed version is fully ready.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426995924", "createdAt": "2020-05-19T02:35:15Z", "author": {"login": "jt2594838"}, "path": "service-rpc/src/main/java/org/apache/iotdb/rpc/TSStatusCode.java", "diffHunk": "@@ -63,10 +63,18 @@\n   READ_ONLY_SYSTEM_ERROR(502),\n   DISK_SPACE_INSUFFICIENT_ERROR(503),\n   START_UP_ERROR(504),\n+\n   WRONG_LOGIN_PASSWORD_ERROR(600),\n   NOT_LOGIN_ERROR(601),\n   NO_PERMISSION_ERROR(602),\n   UNINITIALIZED_AUTH_ERROR(603),\n+\n+  PARTITION_NOT_READY(700),\n+  TIME_OUT(701),\n+  NO_LEADER(702),\n+  UNSUPPORTED_OPERATION(703),\n+  NODE_READ_ONLY(704),\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0MTMzNw=="}, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTkyMTU0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/constant/SQLConstant.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODoyMDowMlrOGWsVlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozODowM1rOGXNz0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0ODI3Nw==", "bodyText": "There are some number conflicts.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426448277", "createdAt": "2020-05-18T08:20:02Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/constant/SQLConstant.java", "diffHunk": "@@ -138,6 +138,8 @@ private SQLConstant() {\n   public static final int TOK_COUNT_TIMESERIES = 77;\n   public static final int TOK_COUNT_NODE_TIMESERIES = 78;\n   public static final int TOK_COUNT_NODES = 79;\n+  public static final int TOK_LOAD_CONFIGURATION_GLOBAL = 80;\n+  public static final int TOK_LOAD_CONFIGURATION_LOCAL = 81;\n \n   public static final int TOK_METADATA_ALTER = 80;\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NjY4OA==", "bodyText": "fixed", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426996688", "createdAt": "2020-05-19T02:38:03Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/constant/SQLConstant.java", "diffHunk": "@@ -138,6 +138,8 @@ private SQLConstant() {\n   public static final int TOK_COUNT_TIMESERIES = 77;\n   public static final int TOK_COUNT_NODE_TIMESERIES = 78;\n   public static final int TOK_COUNT_NODES = 79;\n+  public static final int TOK_LOAD_CONFIGURATION_GLOBAL = 80;\n+  public static final int TOK_LOAD_CONFIGURATION_LOCAL = 81;\n \n   public static final int TOK_METADATA_ALTER = 80;\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0ODI3Nw=="}, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTk0MzQzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODoyNTo0MlrOGWsjHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozODo1MlrOGXN0sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ1MTc0Mg==", "bodyText": "There are a lot of format changes in this file. I don't think it's necessary.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426451742", "createdAt": "2020-05-18T08:25:42Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -163,7 +165,7 @@ public PlanExecutor() throws QueryProcessException {\n \n   @Override\n   public QueryDataSet processQuery(PhysicalPlan queryPlan, QueryContext context)\n-      throws IOException, StorageEngineException, QueryFilterOptimizationException,\n+          throws IOException, StorageEngineException, QueryFilterOptimizationException,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NjkxMw==", "bodyText": "Reformated.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426996913", "createdAt": "2020-05-19T02:38:52Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -163,7 +165,7 @@ public PlanExecutor() throws QueryProcessException {\n \n   @Override\n   public QueryDataSet processQuery(PhysicalPlan queryPlan, QueryContext context)\n-      throws IOException, StorageEngineException, QueryFilterOptimizationException,\n+          throws IOException, StorageEngineException, QueryFilterOptimizationException,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ1MTc0Mg=="}, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTk2MTkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/antlr4/org/apache/iotdb/db/qp/strategy/SqlBase.g4", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODozMDowMFrOGWsuVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjowNDo1NlrOGYjy0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ1NDYxNQ==", "bodyText": "any UT?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426454615", "createdAt": "2020-05-18T08:30:00Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/antlr4/org/apache/iotdb/db/qp/strategy/SqlBase.g4", "diffHunk": "@@ -74,7 +74,7 @@ statement\n     | SHOW DEVICES prefixPath? #showDevices\n     | COUNT TIMESERIES prefixPath? (GROUP BY LEVEL OPERATOR_EQ INT)? #countTimeseries\n     | COUNT NODES prefixPath LEVEL OPERATOR_EQ INT #countNodes\n-    | LOAD CONFIGURATION #loadConfigurationStatement\n+    | LOAD CONFIGURATION (MINUS GLOBAL)? #loadConfigurationStatement", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQwNTQ1Ng==", "bodyText": "In the distributed version, not here.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428405456", "createdAt": "2020-05-21T02:04:56Z", "author": {"login": "jt2594838"}, "path": "server/src/main/antlr4/org/apache/iotdb/db/qp/strategy/SqlBase.g4", "diffHunk": "@@ -74,7 +74,7 @@ statement\n     | SHOW DEVICES prefixPath? #showDevices\n     | COUNT TIMESERIES prefixPath? (GROUP BY LEVEL OPERATOR_EQ INT)? #countTimeseries\n     | COUNT NODES prefixPath LEVEL OPERATOR_EQ INT #countNodes\n-    | LOAD CONFIGURATION #loadConfigurationStatement\n+    | LOAD CONFIGURATION (MINUS GLOBAL)? #loadConfigurationStatement", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ1NDYxNQ=="}, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTk2MjkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/LocalGroupByExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODozMDoxM1rOGWsu6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozOToyNVrOGXN1Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ1NDc2MQ==", "bodyText": "Format\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  queryDataSource = QueryResourceManager.getInstance()\n          \n          \n            \n                      .getQueryDataSource(path, context, timeFilter);\n          \n          \n            \n                queryDataSource = QueryResourceManager.getInstance()\n          \n          \n            \n                    .getQueryDataSource(path, context, timeFilter);", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426454761", "createdAt": "2020-05-18T08:30:13Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/LocalGroupByExecutor.java", "diffHunk": "@@ -49,11 +49,13 @@\n   private List<AggregateResult> results = new ArrayList<>();\n   private TimeRange timeRange;\n \n+  private QueryDataSource queryDataSource;\n+\n   public LocalGroupByExecutor(Path path, Set<String> allSensors, TSDataType dataType,\n       QueryContext context, Filter timeFilter, TsFileFilter fileFilter)\n       throws StorageEngineException, QueryProcessException {\n-    QueryDataSource queryDataSource =\n-        QueryResourceManager.getInstance().getQueryDataSource(path, context, timeFilter);\n+      queryDataSource = QueryResourceManager.getInstance()\n+          .getQueryDataSource(path, context, timeFilter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NzAzMA==", "bodyText": "Reformated.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426997030", "createdAt": "2020-05-19T02:39:25Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/LocalGroupByExecutor.java", "diffHunk": "@@ -49,11 +49,13 @@\n   private List<AggregateResult> results = new ArrayList<>();\n   private TimeRange timeRange;\n \n+  private QueryDataSource queryDataSource;\n+\n   public LocalGroupByExecutor(Path path, Set<String> allSensors, TSDataType dataType,\n       QueryContext context, Filter timeFilter, TsFileFilter fileFilter)\n       throws StorageEngineException, QueryProcessException {\n-    QueryDataSource queryDataSource =\n-        QueryResourceManager.getInstance().getQueryDataSource(path, context, timeFilter);\n+      queryDataSource = QueryResourceManager.getInstance()\n+          .getQueryDataSource(path, context, timeFilter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ1NDc2MQ=="}, "originalCommit": {"oid": "425ec9dabebeda7ec9e0960ac5975dbbfb21d6de"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTM3NDA0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/auth/user/BasicUserManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjo0NzoyNFrOGXN89Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjowNzoxNVrOGYj1BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTAyOQ==", "bodyText": "use the lock field of this class. (writeLock)", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426999029", "createdAt": "2020-05-19T02:47:24Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/auth/user/BasicUserManager.java", "diffHunk": "@@ -310,4 +311,23 @@ public void setUserUseWaterMark(String username, boolean useWaterMark) throws Au\n       throw new AuthException(e);\n     }\n   }\n+\n+\n+  @Override\n+  public void replaceAllUsers(Map<String, User> users) throws AuthException {\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTA5Ng==", "bodyText": "@neuyilan", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426999096", "createdAt": "2020-05-19T02:47:40Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/auth/user/BasicUserManager.java", "diffHunk": "@@ -310,4 +311,23 @@ public void setUserUseWaterMark(String username, boolean useWaterMark) throws Au\n       throw new AuthException(e);\n     }\n   }\n+\n+\n+  @Override\n+  public void replaceAllUsers(Map<String, User> users) throws AuthException {\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTAyOQ=="}, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQwNjAyMA==", "bodyText": "That is a partitioned lock, which only applies to a certain key, not for the total replacement. See the explanation above I have made to qiaojialin, please.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428406020", "createdAt": "2020-05-21T02:07:15Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/auth/user/BasicUserManager.java", "diffHunk": "@@ -310,4 +311,23 @@ public void setUserUseWaterMark(String username, boolean useWaterMark) throws Au\n       throw new AuthException(e);\n     }\n   }\n+\n+\n+  @Override\n+  public void replaceAllUsers(Map<String, User> users) throws AuthException {\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTAyOQ=="}, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTM3NjkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/auth/user/BasicUserManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjo0OTowMVrOGXN-og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjowODo1M1rOGYj2Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTQ1OA==", "bodyText": "Not sure whether users having \"root\" user.\nIf it has, then initAdmin() in reset() is meaningless.\nIf it does not have, then you have to initAdmin() after this replacement.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r426999458", "createdAt": "2020-05-19T02:49:01Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/auth/user/BasicUserManager.java", "diffHunk": "@@ -310,4 +311,23 @@ public void setUserUseWaterMark(String username, boolean useWaterMark) throws Au\n       throw new AuthException(e);\n     }\n   }\n+\n+\n+  @Override\n+  public void replaceAllUsers(Map<String, User> users) throws AuthException {\n+    synchronized (this) {\n+      reset();\n+      userMap = users;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQwNjM3NA==", "bodyText": "It does not matter at all. The entire users shall be replaced with the new users, no matter what it used to be or the what the new users are.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428406374", "createdAt": "2020-05-21T02:08:53Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/auth/user/BasicUserManager.java", "diffHunk": "@@ -310,4 +311,23 @@ public void setUserUseWaterMark(String username, boolean useWaterMark) throws Au\n       throw new AuthException(e);\n     }\n   }\n+\n+\n+  @Override\n+  public void replaceAllUsers(Map<String, User> users) throws AuthException {\n+    synchronized (this) {\n+      reset();\n+      userMap = users;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTQ1OA=="}, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTQ1ODY2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/auth/role/BasicRoleManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMzo0MDoyN1rOGXOwFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjowOTozMlrOGYj2-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxMjExNw==", "bodyText": "The same to userManager.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427012117", "createdAt": "2020-05-19T03:40:27Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/auth/role/BasicRoleManager.java", "diffHunk": "@@ -167,4 +168,21 @@ public void reset() {\n     rtlist.sort(null);\n     return rtlist;\n   }\n+\n+  @Override\n+  public void replaceAllRoles(Map<String, Role> roles) throws AuthException {\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQwNjUyMg==", "bodyText": "See above.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428406522", "createdAt": "2020-05-21T02:09:32Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/auth/role/BasicRoleManager.java", "diffHunk": "@@ -167,4 +168,21 @@ public void reset() {\n     rtlist.sort(null);\n     return rtlist;\n   }\n+\n+  @Override\n+  public void replaceAllRoles(Map<String, Role> roles) throws AuthException {\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxMjExNw=="}, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MTY5ODM3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/auth/role/BasicRoleManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNTowMDoxNFrOGXkv1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMTo1MToxNlrOGYH1cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM3MjUwMQ==", "bodyText": "in other methods the lock is used, but here synchronized this object, is there a concurrent error when using accessor?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427372501", "createdAt": "2020-05-19T15:00:14Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/auth/role/BasicRoleManager.java", "diffHunk": "@@ -167,4 +168,21 @@ public void reset() {\n     rtlist.sort(null);\n     return rtlist;\n   }\n+\n+  @Override\n+  public void replaceAllRoles(Map<String, Role> roles) throws AuthException {\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0NzM3OA==", "bodyText": "No, when the function is called, the node will not serve other requests temporarily. This is only for the concurrent safety of calling the two methods.\nAnd, the lock used in other places is a HashLock and not applicable in this situation.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427947378", "createdAt": "2020-05-20T11:51:16Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/auth/role/BasicRoleManager.java", "diffHunk": "@@ -167,4 +168,21 @@ public void reset() {\n     rtlist.sort(null);\n     return rtlist;\n   }\n+\n+  @Override\n+  public void replaceAllRoles(Map<String, Role> roles) throws AuthException {\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM3MjUwMQ=="}, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MTcwMDg2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/auth/user/BasicUserManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNTowMDo0M1rOGXkxXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMTo1MTozMFrOGYH13Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM3Mjg5NA==", "bodyText": "the same with BasicRoleManager", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427372894", "createdAt": "2020-05-19T15:00:43Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/auth/user/BasicUserManager.java", "diffHunk": "@@ -310,4 +311,23 @@ public void setUserUseWaterMark(String username, boolean useWaterMark) throws Au\n       throw new AuthException(e);\n     }\n   }\n+\n+\n+  @Override\n+  public void replaceAllUsers(Map<String, User> users) throws AuthException {\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0NzQ4NQ==", "bodyText": "See above.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427947485", "createdAt": "2020-05-20T11:51:30Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/auth/user/BasicUserManager.java", "diffHunk": "@@ -310,4 +311,23 @@ public void setUserUseWaterMark(String username, boolean useWaterMark) throws Au\n       throw new AuthException(e);\n     }\n   }\n+\n+\n+  @Override\n+  public void replaceAllUsers(Map<String, User> users) throws AuthException {\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM3Mjg5NA=="}, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjMxMjExOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzoyNTozM1rOGXq4MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjoxMDoyOFrOGYj36Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3Mjk0NQ==", "bodyText": "why check null here? is there a bug before?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427472945", "createdAt": "2020-05-19T17:25:33Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -809,9 +808,10 @@ public void tryToUpdateInsertLastCache(InsertPlan plan, Long latestFlushedTime)\n       for (int i = 0; i < measurementList.length; i++) {\n         // Update cached last value with high priority\n         MNode measurementNode = node.getChild(measurementList[i]);\n-\n-        ((LeafMNode) measurementNode)\n-            .updateCachedLast(plan.composeTimeValuePair(i), true, latestFlushedTime);\n+        if (measurementNode != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQwNjc2MQ==", "bodyText": "It is because we do not always have MNodes and data on the same node together in the distributed version.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428406761", "createdAt": "2020-05-21T02:10:28Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -809,9 +808,10 @@ public void tryToUpdateInsertLastCache(InsertPlan plan, Long latestFlushedTime)\n       for (int i = 0; i < measurementList.length; i++) {\n         // Update cached last value with high priority\n         MNode measurementNode = node.getChild(measurementList[i]);\n-\n-        ((LeafMNode) measurementNode)\n-            .updateCachedLast(plan.composeTimeValuePair(i), true, latestFlushedTime);\n+        if (measurementNode != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3Mjk0NQ=="}, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjMyNjQ0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzoyODo1N1rOGXrA_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjoxMTozNlrOGYj4_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NTE5OA==", "bodyText": "Long partition, Long version", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427475198", "createdAt": "2020-05-19T17:28:57Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1776,6 +1803,22 @@ public void loadNewTsFile(TsFileResource newTsFileResource) throws LoadFileExcep\n     }\n   }\n \n+  /**\n+   * Set the version in \"partition\" to \"version\" if \"version\" is larger than the current version.\n+   * @param partition\n+   * @param version\n+   */\n+  public void setPartitionFileVersionToMax(long partition, long version) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQwNzAzOA==", "bodyText": "I do not see the point.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428407038", "createdAt": "2020-05-21T02:11:36Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1776,6 +1803,22 @@ public void loadNewTsFile(TsFileResource newTsFileResource) throws LoadFileExcep\n     }\n   }\n \n+  /**\n+   * Set the version in \"partition\" to \"version\" if \"version\" is larger than the current version.\n+   * @param partition\n+   * @param version\n+   */\n+  public void setPartitionFileVersionToMax(long partition, long version) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NTE5OA=="}, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzYyNzEyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/modification/ModificationFile.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMTowMTowNVrOGX3vsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMTo1Mjo0MVrOGYH4Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4Mzc2Mg==", "bodyText": "retry?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427683762", "createdAt": "2020-05-20T01:01:05Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/modification/ModificationFile.java", "diffHunk": "@@ -125,4 +133,34 @@ public void remove() throws IOException {\n     FSFactoryProducer.getFSFactory().getFile(filePath).delete();\n   }\n \n+  public boolean exists() {\n+    return new File(filePath).exists();\n+  }\n+\n+  /**\n+   * Create a hardlink for the modification file.\n+   * The hardlink with have a suffix like \".{sysTime}_{randomLong}\"\n+   * @return a new ModificationFile with its path changed to the hardlink, or null if the origin\n+   * file does not exist or the hardlink cannot be created.\n+   */\n+  public ModificationFile createHardlink() {\n+    if (!exists()) {\n+      return null;\n+    }\n+\n+    while (true) {\n+      String hardlinkSuffix = \".\" + System.currentTimeMillis() + \"_\" + random.nextLong();\n+      File hardlink = new File(filePath + hardlinkSuffix);\n+\n+      try {\n+        Files.createLink(Paths.get(hardlink.getAbsolutePath()), Paths.get(filePath));\n+        return new ModificationFile(hardlink.getAbsolutePath());\n+      } catch (FileAlreadyExistsException e) {\n+        // retry a different name if the file is already created", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0ODA4Mw==", "bodyText": "The name is generated randomly, so continuing is a retry.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427948083", "createdAt": "2020-05-20T11:52:41Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/modification/ModificationFile.java", "diffHunk": "@@ -125,4 +133,34 @@ public void remove() throws IOException {\n     FSFactoryProducer.getFSFactory().getFile(filePath).delete();\n   }\n \n+  public boolean exists() {\n+    return new File(filePath).exists();\n+  }\n+\n+  /**\n+   * Create a hardlink for the modification file.\n+   * The hardlink with have a suffix like \".{sysTime}_{randomLong}\"\n+   * @return a new ModificationFile with its path changed to the hardlink, or null if the origin\n+   * file does not exist or the hardlink cannot be created.\n+   */\n+  public ModificationFile createHardlink() {\n+    if (!exists()) {\n+      return null;\n+    }\n+\n+    while (true) {\n+      String hardlinkSuffix = \".\" + System.currentTimeMillis() + \"_\" + random.nextLong();\n+      File hardlink = new File(filePath + hardlinkSuffix);\n+\n+      try {\n+        Files.createLink(Paths.get(hardlink.getAbsolutePath()), Paths.get(filePath));\n+        return new ModificationFile(hardlink.getAbsolutePath());\n+      } catch (FileAlreadyExistsException e) {\n+        // retry a different name if the file is already created", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4Mzc2Mg=="}, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzcxMzkyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMTo1MTo0M1rOGX4jog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMzo0OToyNVrOGaNyGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NzA1OA==", "bodyText": "how do we handle if trylock failed? ignore?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427697058", "createdAt": "2020-05-20T01:51:43Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1875,35 +1918,52 @@ public void removeFullyOverlapFiles(TsFileResource resource) {\n     closeQueryLock.writeLock().lock();\n     try {\n       Iterator<TsFileResource> iterator = sequenceFileTreeSet.iterator();\n-      removeFullyOverlapFiles(resource, iterator);\n+      removeFullyOverlapFiles(resource, iterator, true);\n \n       iterator = unSequenceFileList.iterator();\n-      removeFullyOverlapFiles(resource, iterator);\n+      removeFullyOverlapFiles(resource, iterator, false);\n     } finally {\n       closeQueryLock.writeLock().unlock();\n       writeUnlock();\n     }\n   }\n \n-  private void removeFullyOverlapFiles(TsFileResource resource, Iterator<TsFileResource> iterator) {\n+  private void removeFullyOverlapFiles(TsFileResource newTsFile, Iterator<TsFileResource> iterator\n+      , boolean isSeq) {\n     while (iterator.hasNext()) {\n-      TsFileResource seqFile = iterator.next();\n-      if (resource.getHistoricalVersions().containsAll(seqFile.getHistoricalVersions())\n-          && !resource.getHistoricalVersions().equals(seqFile.getHistoricalVersions())\n-          && seqFile.getWriteQueryLock().writeLock().tryLock()) {\n+      TsFileResource existingTsFile = iterator.next();\n+      if (newTsFile.getHistoricalVersions().containsAll(existingTsFile.getHistoricalVersions())\n+          && !newTsFile.getHistoricalVersions().equals(existingTsFile.getHistoricalVersions())\n+          && existingTsFile.tryWriteLock()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0ODYxMA==", "bodyText": "Yes, and we will leave this for merge.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427948610", "createdAt": "2020-05-20T11:53:33Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1875,35 +1918,52 @@ public void removeFullyOverlapFiles(TsFileResource resource) {\n     closeQueryLock.writeLock().lock();\n     try {\n       Iterator<TsFileResource> iterator = sequenceFileTreeSet.iterator();\n-      removeFullyOverlapFiles(resource, iterator);\n+      removeFullyOverlapFiles(resource, iterator, true);\n \n       iterator = unSequenceFileList.iterator();\n-      removeFullyOverlapFiles(resource, iterator);\n+      removeFullyOverlapFiles(resource, iterator, false);\n     } finally {\n       closeQueryLock.writeLock().unlock();\n       writeUnlock();\n     }\n   }\n \n-  private void removeFullyOverlapFiles(TsFileResource resource, Iterator<TsFileResource> iterator) {\n+  private void removeFullyOverlapFiles(TsFileResource newTsFile, Iterator<TsFileResource> iterator\n+      , boolean isSeq) {\n     while (iterator.hasNext()) {\n-      TsFileResource seqFile = iterator.next();\n-      if (resource.getHistoricalVersions().containsAll(seqFile.getHistoricalVersions())\n-          && !resource.getHistoricalVersions().equals(seqFile.getHistoricalVersions())\n-          && seqFile.getWriteQueryLock().writeLock().tryLock()) {\n+      TsFileResource existingTsFile = iterator.next();\n+      if (newTsFile.getHistoricalVersions().containsAll(existingTsFile.getHistoricalVersions())\n+          && !newTsFile.getHistoricalVersions().equals(existingTsFile.getHistoricalVersions())\n+          && existingTsFile.tryWriteLock()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NzA1OA=="}, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTcxNjMwMw==", "bodyText": "where to leave the message?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r429716303", "createdAt": "2020-05-25T03:20:18Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1875,35 +1918,52 @@ public void removeFullyOverlapFiles(TsFileResource resource) {\n     closeQueryLock.writeLock().lock();\n     try {\n       Iterator<TsFileResource> iterator = sequenceFileTreeSet.iterator();\n-      removeFullyOverlapFiles(resource, iterator);\n+      removeFullyOverlapFiles(resource, iterator, true);\n \n       iterator = unSequenceFileList.iterator();\n-      removeFullyOverlapFiles(resource, iterator);\n+      removeFullyOverlapFiles(resource, iterator, false);\n     } finally {\n       closeQueryLock.writeLock().unlock();\n       writeUnlock();\n     }\n   }\n \n-  private void removeFullyOverlapFiles(TsFileResource resource, Iterator<TsFileResource> iterator) {\n+  private void removeFullyOverlapFiles(TsFileResource newTsFile, Iterator<TsFileResource> iterator\n+      , boolean isSeq) {\n     while (iterator.hasNext()) {\n-      TsFileResource seqFile = iterator.next();\n-      if (resource.getHistoricalVersions().containsAll(seqFile.getHistoricalVersions())\n-          && !resource.getHistoricalVersions().equals(seqFile.getHistoricalVersions())\n-          && seqFile.getWriteQueryLock().writeLock().tryLock()) {\n+      TsFileResource existingTsFile = iterator.next();\n+      if (newTsFile.getHistoricalVersions().containsAll(existingTsFile.getHistoricalVersions())\n+          && !newTsFile.getHistoricalVersions().equals(existingTsFile.getHistoricalVersions())\n+          && existingTsFile.tryWriteLock()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NzA1OA=="}, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE0MTk3Ng==", "bodyText": "comment added", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r430141976", "createdAt": "2020-05-26T03:49:25Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1875,35 +1918,52 @@ public void removeFullyOverlapFiles(TsFileResource resource) {\n     closeQueryLock.writeLock().lock();\n     try {\n       Iterator<TsFileResource> iterator = sequenceFileTreeSet.iterator();\n-      removeFullyOverlapFiles(resource, iterator);\n+      removeFullyOverlapFiles(resource, iterator, true);\n \n       iterator = unSequenceFileList.iterator();\n-      removeFullyOverlapFiles(resource, iterator);\n+      removeFullyOverlapFiles(resource, iterator, false);\n     } finally {\n       closeQueryLock.writeLock().unlock();\n       writeUnlock();\n     }\n   }\n \n-  private void removeFullyOverlapFiles(TsFileResource resource, Iterator<TsFileResource> iterator) {\n+  private void removeFullyOverlapFiles(TsFileResource newTsFile, Iterator<TsFileResource> iterator\n+      , boolean isSeq) {\n     while (iterator.hasNext()) {\n-      TsFileResource seqFile = iterator.next();\n-      if (resource.getHistoricalVersions().containsAll(seqFile.getHistoricalVersions())\n-          && !resource.getHistoricalVersions().equals(seqFile.getHistoricalVersions())\n-          && seqFile.getWriteQueryLock().writeLock().tryLock()) {\n+      TsFileResource existingTsFile = iterator.next();\n+      if (newTsFile.getHistoricalVersions().containsAll(existingTsFile.getHistoricalVersions())\n+          && !newTsFile.getHistoricalVersions().equals(existingTsFile.getHistoricalVersions())\n+          && existingTsFile.tryWriteLock()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NzA1OA=="}, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzcxNjY4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMTo1MzoyMlrOGX4lRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwMzozNDoxNFrOGZz7Yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NzQ3Ng==", "bodyText": "this may take a long time, better add javadoc", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427697476", "createdAt": "2020-05-20T01:53:22Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1875,35 +1918,52 @@ public void removeFullyOverlapFiles(TsFileResource resource) {\n     closeQueryLock.writeLock().lock();\n     try {\n       Iterator<TsFileResource> iterator = sequenceFileTreeSet.iterator();\n-      removeFullyOverlapFiles(resource, iterator);\n+      removeFullyOverlapFiles(resource, iterator, true);\n \n       iterator = unSequenceFileList.iterator();\n-      removeFullyOverlapFiles(resource, iterator);\n+      removeFullyOverlapFiles(resource, iterator, false);\n     } finally {\n       closeQueryLock.writeLock().unlock();\n       writeUnlock();\n     }\n   }\n \n-  private void removeFullyOverlapFiles(TsFileResource resource, Iterator<TsFileResource> iterator) {\n+  private void removeFullyOverlapFiles(TsFileResource newTsFile, Iterator<TsFileResource> iterator\n+      , boolean isSeq) {\n     while (iterator.hasNext()) {\n-      TsFileResource seqFile = iterator.next();\n-      if (resource.getHistoricalVersions().containsAll(seqFile.getHistoricalVersions())\n-          && !resource.getHistoricalVersions().equals(seqFile.getHistoricalVersions())\n-          && seqFile.getWriteQueryLock().writeLock().tryLock()) {\n+      TsFileResource existingTsFile = iterator.next();\n+      if (newTsFile.getHistoricalVersions().containsAll(existingTsFile.getHistoricalVersions())\n+          && !newTsFile.getHistoricalVersions().equals(existingTsFile.getHistoricalVersions())\n+          && existingTsFile.tryWriteLock()) {\n         try {\n-          iterator.remove();\n-          seqFile.remove();\n+          removeFullyOverlapFile(existingTsFile, iterator, isSeq);\n         } catch (Exception e) {\n           logger.error(\"Something gets wrong while removing FullyOverlapFiles \", e);\n           throw e;\n         } finally {\n-          seqFile.getWriteQueryLock().writeLock().unlock();\n+          existingTsFile.writeUnlock();\n         }\n       }\n     }\n   }\n \n+  private void removeFullyOverlapFile(TsFileResource tsFileResource, Iterator<TsFileResource> iterator\n+      , boolean isSeq) {\n+    if (!tsFileResource.isClosed()) {\n+      // also remove the TsFileProcessor if the overlapped file is not closed\n+      long timePartition = tsFileResource.getTimePartition();\n+      Map<Long, TsFileProcessor> fileProcessorMap = isSeq ? workSequenceTsFileProcessors :\n+          workUnsequenceTsFileProcessors;\n+      TsFileProcessor tsFileProcessor = fileProcessorMap.get(timePartition);\n+      if (tsFileProcessor != null && tsFileProcessor.getTsFileResource() == tsFileResource) {\n+        tsFileProcessor.syncClose();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0OTU4NQ==", "bodyText": "The process itself is a long-term process, so I do not see the point.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427949585", "createdAt": "2020-05-20T11:55:26Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1875,35 +1918,52 @@ public void removeFullyOverlapFiles(TsFileResource resource) {\n     closeQueryLock.writeLock().lock();\n     try {\n       Iterator<TsFileResource> iterator = sequenceFileTreeSet.iterator();\n-      removeFullyOverlapFiles(resource, iterator);\n+      removeFullyOverlapFiles(resource, iterator, true);\n \n       iterator = unSequenceFileList.iterator();\n-      removeFullyOverlapFiles(resource, iterator);\n+      removeFullyOverlapFiles(resource, iterator, false);\n     } finally {\n       closeQueryLock.writeLock().unlock();\n       writeUnlock();\n     }\n   }\n \n-  private void removeFullyOverlapFiles(TsFileResource resource, Iterator<TsFileResource> iterator) {\n+  private void removeFullyOverlapFiles(TsFileResource newTsFile, Iterator<TsFileResource> iterator\n+      , boolean isSeq) {\n     while (iterator.hasNext()) {\n-      TsFileResource seqFile = iterator.next();\n-      if (resource.getHistoricalVersions().containsAll(seqFile.getHistoricalVersions())\n-          && !resource.getHistoricalVersions().equals(seqFile.getHistoricalVersions())\n-          && seqFile.getWriteQueryLock().writeLock().tryLock()) {\n+      TsFileResource existingTsFile = iterator.next();\n+      if (newTsFile.getHistoricalVersions().containsAll(existingTsFile.getHistoricalVersions())\n+          && !newTsFile.getHistoricalVersions().equals(existingTsFile.getHistoricalVersions())\n+          && existingTsFile.tryWriteLock()) {\n         try {\n-          iterator.remove();\n-          seqFile.remove();\n+          removeFullyOverlapFile(existingTsFile, iterator, isSeq);\n         } catch (Exception e) {\n           logger.error(\"Something gets wrong while removing FullyOverlapFiles \", e);\n           throw e;\n         } finally {\n-          seqFile.getWriteQueryLock().writeLock().unlock();\n+          existingTsFile.writeUnlock();\n         }\n       }\n     }\n   }\n \n+  private void removeFullyOverlapFile(TsFileResource tsFileResource, Iterator<TsFileResource> iterator\n+      , boolean isSeq) {\n+    if (!tsFileResource.isClosed()) {\n+      // also remove the TsFileProcessor if the overlapped file is not closed\n+      long timePartition = tsFileResource.getTimePartition();\n+      Map<Long, TsFileProcessor> fileProcessorMap = isSeq ? workSequenceTsFileProcessors :\n+          workUnsequenceTsFileProcessors;\n+      TsFileProcessor tsFileProcessor = fileProcessorMap.get(timePartition);\n+      if (tsFileProcessor != null && tsFileProcessor.getTsFileResource() == tsFileResource) {\n+        tsFileProcessor.syncClose();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NzQ3Ng=="}, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTcxODM3MA==", "bodyText": "added", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r429718370", "createdAt": "2020-05-25T03:34:14Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1875,35 +1918,52 @@ public void removeFullyOverlapFiles(TsFileResource resource) {\n     closeQueryLock.writeLock().lock();\n     try {\n       Iterator<TsFileResource> iterator = sequenceFileTreeSet.iterator();\n-      removeFullyOverlapFiles(resource, iterator);\n+      removeFullyOverlapFiles(resource, iterator, true);\n \n       iterator = unSequenceFileList.iterator();\n-      removeFullyOverlapFiles(resource, iterator);\n+      removeFullyOverlapFiles(resource, iterator, false);\n     } finally {\n       closeQueryLock.writeLock().unlock();\n       writeUnlock();\n     }\n   }\n \n-  private void removeFullyOverlapFiles(TsFileResource resource, Iterator<TsFileResource> iterator) {\n+  private void removeFullyOverlapFiles(TsFileResource newTsFile, Iterator<TsFileResource> iterator\n+      , boolean isSeq) {\n     while (iterator.hasNext()) {\n-      TsFileResource seqFile = iterator.next();\n-      if (resource.getHistoricalVersions().containsAll(seqFile.getHistoricalVersions())\n-          && !resource.getHistoricalVersions().equals(seqFile.getHistoricalVersions())\n-          && seqFile.getWriteQueryLock().writeLock().tryLock()) {\n+      TsFileResource existingTsFile = iterator.next();\n+      if (newTsFile.getHistoricalVersions().containsAll(existingTsFile.getHistoricalVersions())\n+          && !newTsFile.getHistoricalVersions().equals(existingTsFile.getHistoricalVersions())\n+          && existingTsFile.tryWriteLock()) {\n         try {\n-          iterator.remove();\n-          seqFile.remove();\n+          removeFullyOverlapFile(existingTsFile, iterator, isSeq);\n         } catch (Exception e) {\n           logger.error(\"Something gets wrong while removing FullyOverlapFiles \", e);\n           throw e;\n         } finally {\n-          seqFile.getWriteQueryLock().writeLock().unlock();\n+          existingTsFile.writeUnlock();\n         }\n       }\n     }\n   }\n \n+  private void removeFullyOverlapFile(TsFileResource tsFileResource, Iterator<TsFileResource> iterator\n+      , boolean isSeq) {\n+    if (!tsFileResource.isClosed()) {\n+      // also remove the TsFileProcessor if the overlapped file is not closed\n+      long timePartition = tsFileResource.getTimePartition();\n+      Map<Long, TsFileProcessor> fileProcessorMap = isSeq ? workSequenceTsFileProcessors :\n+          workUnsequenceTsFileProcessors;\n+      TsFileProcessor tsFileProcessor = fileProcessorMap.get(timePartition);\n+      if (tsFileProcessor != null && tsFileProcessor.getTsFileResource() == tsFileResource) {\n+        tsFileProcessor.syncClose();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NzQ3Ng=="}, "originalCommit": {"oid": "495685e5bda7386e6f3551e3eba2d11a06c6ee6d"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzkwNDI5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMzo1NzozOVrOGX6aUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMTo1NzoxMlrOGYIBgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyNzQ0MA==", "bodyText": "it is obviously used...", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427727440", "createdAt": "2020-05-20T03:57:39Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -322,7 +323,13 @@ protected QueryDataSet processDataQuery(QueryPlan queryPlan, QueryContext contex\n     return queryDataSet;\n   }\n \n-  private QueryDataSet processShowQuery(ShowPlan showPlan)\n+  @SuppressWarnings(\"unused\")\n+  protected AlignByDeviceDataSet getAlignByDeviceDataSet(AlignByDevicePlan plan,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk1MDQ2NA==", "bodyText": "It is because one of the arguments is not used.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427950464", "createdAt": "2020-05-20T11:57:12Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -322,7 +323,13 @@ protected QueryDataSet processDataQuery(QueryPlan queryPlan, QueryContext contex\n     return queryDataSet;\n   }\n \n-  private QueryDataSet processShowQuery(ShowPlan showPlan)\n+  @SuppressWarnings(\"unused\")\n+  protected AlignByDeviceDataSet getAlignByDeviceDataSet(AlignByDevicePlan plan,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyNzQ0MA=="}, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTE2MTE0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMToxOToxNlrOGYG3Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjoxNDozNFrOGYj75g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkzMTM5NA==", "bodyText": "hard to understand the javadoc.\nA tsFileResource is attached to a tsFile,  what is the meaning of \"when IOTDB has the same close file policy as the local one\".", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427931394", "createdAt": "2020-05-20T11:19:16Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -2215,9 +2275,41 @@ public String getStorageGroupName() {\n     return storageGroupName;\n   }\n \n+  /**\n+   * Check if the data of \"tsFileResource\" all exist locally by comparing the historical versions\n+   * in the partition of \"partitionNumber\". This is available only when the IoTDB which generated\n+   * \"tsFileResource\" has the same close file policy as the local one.\n+   * If one of the version in \"tsFileResource\" equals to a version of a working file, false is\n+   * also returned because \"tsFileResource\" may have unwritten data of that file.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQwNzc4Mg==", "bodyText": "Please do not ignore the clause \"which generated 'tsFileResource' \".\nA TsFile is not always generated by the local IoTDB instance, and it may be generated by another IoTDB and is sent by the sync module or catch-up in the distributed version.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428407782", "createdAt": "2020-05-21T02:14:34Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -2215,9 +2275,41 @@ public String getStorageGroupName() {\n     return storageGroupName;\n   }\n \n+  /**\n+   * Check if the data of \"tsFileResource\" all exist locally by comparing the historical versions\n+   * in the partition of \"partitionNumber\". This is available only when the IoTDB which generated\n+   * \"tsFileResource\" has the same close file policy as the local one.\n+   * If one of the version in \"tsFileResource\" equals to a version of a working file, false is\n+   * also returned because \"tsFileResource\" may have unwritten data of that file.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkzMTM5NA=="}, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 251}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTI0ODAyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMTo0Nzo1MVrOGYHuoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjoyMjozN1rOGYkEFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0NTYzMw==", "bodyText": "I think we can mark this function as ForCluster, then the parameter tsFileResource  can be called remoteTsFileResource, and then the logic will be much easier to be understood.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427945633", "createdAt": "2020-05-20T11:47:51Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -2215,9 +2275,41 @@ public String getStorageGroupName() {\n     return storageGroupName;\n   }\n \n+  /**\n+   * Check if the data of \"tsFileResource\" all exist locally by comparing the historical versions\n+   * in the partition of \"partitionNumber\". This is available only when the IoTDB which generated\n+   * \"tsFileResource\" has the same close file policy as the local one.\n+   * If one of the version in \"tsFileResource\" equals to a version of a working file, false is\n+   * also returned because \"tsFileResource\" may have unwritten data of that file.\n+   * @param tsFileResource\n+   * @param partitionNum\n+   * @return true if the historicalVersions of \"tsFileResource\" is a subset of\n+   * partitionDirectFileVersions, or false if it is not a subset and it does not contain any\n+   * version of a working file\n+   */\n   public boolean isFileAlreadyExist(TsFileResource tsFileResource, long partitionNum) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQwOTg3OQ==", "bodyText": "That is its current usage indeed, but it does not mean what it is capable of.\nThe real functionality of this method is to check the existence of a TsFile under the consistency of the versions, and it just happened to serve the distributed module, which does not mean it is constrained only to that use.\nFor example, if we have an apple that is only for eating currently, we do not rename it to \"AppleThatIsOnlyForEating\", because we know that an apple is an apple and it may also be used to make apple juice or something different.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428409879", "createdAt": "2020-05-21T02:22:37Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -2215,9 +2275,41 @@ public String getStorageGroupName() {\n     return storageGroupName;\n   }\n \n+  /**\n+   * Check if the data of \"tsFileResource\" all exist locally by comparing the historical versions\n+   * in the partition of \"partitionNumber\". This is available only when the IoTDB which generated\n+   * \"tsFileResource\" has the same close file policy as the local one.\n+   * If one of the version in \"tsFileResource\" equals to a version of a working file, false is\n+   * also returned because \"tsFileResource\" may have unwritten data of that file.\n+   * @param tsFileResource\n+   * @param partitionNum\n+   * @return true if the historicalVersions of \"tsFileResource\" is a subset of\n+   * partitionDirectFileVersions, or false if it is not a subset and it does not contain any\n+   * version of a working file\n+   */\n   public boolean isFileAlreadyExist(TsFileResource tsFileResource, long partitionNum) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0NTYzMw=="}, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 258}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTI1OTQ4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileResource.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMTo1MToyNVrOGYH1wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwMzo0MjozOFrOGZ0AdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0NzQ1OA==", "bodyText": "IMPORTANT.\ndon't use the absolute path in a tsfileResource. Otherwise it will be very hard to help users solving online problems.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427947458", "createdAt": "2020-05-20T11:51:25Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileResource.java", "diffHunk": "@@ -241,6 +244,10 @@ public void serialize() throws IOException {\n           ReadWriteIOUtils.write(historicalVersion, outputStream);\n         }\n       }\n+\n+      if (modFile != null && modFile.exists()) {\n+        ReadWriteIOUtils.write(modFile.getFilePath(), outputStream);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxMDg2OA==", "bodyText": "Changed to relative path.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428410868", "createdAt": "2020-05-21T02:26:59Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileResource.java", "diffHunk": "@@ -241,6 +244,10 @@ public void serialize() throws IOException {\n           ReadWriteIOUtils.write(historicalVersion, outputStream);\n         }\n       }\n+\n+      if (modFile != null && modFile.exists()) {\n+        ReadWriteIOUtils.write(modFile.getFilePath(), outputStream);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0NzQ1OA=="}, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTcxOTY2OQ==", "bodyText": "have you submit your new codes?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r429719669", "createdAt": "2020-05-25T03:42:38Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileResource.java", "diffHunk": "@@ -241,6 +244,10 @@ public void serialize() throws IOException {\n           ReadWriteIOUtils.write(historicalVersion, outputStream);\n         }\n       }\n+\n+      if (modFile != null && modFile.exists()) {\n+        ReadWriteIOUtils.write(modFile.getFilePath(), outputStream);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0NzQ1OA=="}, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTI2MTIyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMTo1MjowM1rOGYH26g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjoyODozNlrOGYkJjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0Nzc1NA==", "bodyText": "will have", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427947754", "createdAt": "2020-05-20T11:52:03Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileResource.java", "diffHunk": "@@ -571,4 +603,56 @@ public long getTimePartitionWithCheck() throws PartitionViolationException {\n     }\n     return partitionId;\n   }\n+\n+  /**\n+   * Create a hardlink for the TsFile and modification file (if exists)\n+   * The hardlink with have a suffix like \".{sysTime}_{randomLong}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxMTI3OQ==", "bodyText": "Fixed.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428411279", "createdAt": "2020-05-21T02:28:36Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileResource.java", "diffHunk": "@@ -571,4 +603,56 @@ public long getTimePartitionWithCheck() throws PartitionViolationException {\n     }\n     return partitionId;\n   }\n+\n+  /**\n+   * Create a hardlink for the TsFile and modification file (if exists)\n+   * The hardlink with have a suffix like \".{sysTime}_{randomLong}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0Nzc1NA=="}, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTI2NDEyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileResource.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMTo1Mjo1MVrOGYH4rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwMzo0NzoyMFrOGZ0Dgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0ODIwNg==", "bodyText": "My another concern is, will the historicalVersion set be very large?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427948206", "createdAt": "2020-05-20T11:52:51Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileResource.java", "diffHunk": "@@ -571,4 +603,56 @@ public long getTimePartitionWithCheck() throws PartitionViolationException {\n     }\n     return partitionId;\n   }\n+\n+  /**\n+   * Create a hardlink for the TsFile and modification file (if exists)\n+   * The hardlink with have a suffix like \".{sysTime}_{randomLong}\"\n+   * @return a new TsFileResource with its file changed to the hardlink or null the hardlink\n+   * cannot be created.\n+   */\n+  public TsFileResource createHardlink() {\n+    if (!file.exists()) {\n+      return null;\n+    }\n+\n+    TsFileResource newResource;\n+    try {\n+      newResource = new TsFileResource(this);\n+    } catch (IOException e) {\n+      logger.error(\"Cannot create hardlink for {}\", file, e);\n+      return null;\n+    }\n+\n+    while (true) {\n+      String hardlinkSuffix = \".\" + System.currentTimeMillis() + \"_\" + random.nextLong();\n+      File hardlink = new File(file.getAbsolutePath() + hardlinkSuffix);\n+\n+      try {\n+        Files.createLink(Paths.get(hardlink.getAbsolutePath()), Paths.get(file.getAbsolutePath()));\n+        newResource.setFile(hardlink);\n+        if (modFile != null && modFile.exists()) {\n+          newResource.setModFile(modFile.createHardlink());\n+        }\n+        break;\n+      } catch (FileAlreadyExistsException e) {\n+        // retry a different name if the file is already created\n+      } catch (IOException e) {\n+        logger.error(\"Cannot create hardlink for {}\", file, e);\n+        return null;\n+      }\n+    }\n+    return newResource;\n+  }\n+\n+  public synchronized void setModFile(ModificationFile modFile) {\n+    this.modFile = modFile;\n+  }\n+\n+  public long getMaxVersion() {\n+    long maxVersion = 0;\n+    if (historicalVersions != null) {\n+      maxVersion = Collections.max(historicalVersions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxMTk3NA==", "bodyText": "How large could it be? A file of several hundred MBs will only have one version, which only takes 8 bytes. Even if several such files are merged into one file of several GBs, the version will not take more than 1 KB.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428411974", "createdAt": "2020-05-21T02:31:47Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileResource.java", "diffHunk": "@@ -571,4 +603,56 @@ public long getTimePartitionWithCheck() throws PartitionViolationException {\n     }\n     return partitionId;\n   }\n+\n+  /**\n+   * Create a hardlink for the TsFile and modification file (if exists)\n+   * The hardlink with have a suffix like \".{sysTime}_{randomLong}\"\n+   * @return a new TsFileResource with its file changed to the hardlink or null the hardlink\n+   * cannot be created.\n+   */\n+  public TsFileResource createHardlink() {\n+    if (!file.exists()) {\n+      return null;\n+    }\n+\n+    TsFileResource newResource;\n+    try {\n+      newResource = new TsFileResource(this);\n+    } catch (IOException e) {\n+      logger.error(\"Cannot create hardlink for {}\", file, e);\n+      return null;\n+    }\n+\n+    while (true) {\n+      String hardlinkSuffix = \".\" + System.currentTimeMillis() + \"_\" + random.nextLong();\n+      File hardlink = new File(file.getAbsolutePath() + hardlinkSuffix);\n+\n+      try {\n+        Files.createLink(Paths.get(hardlink.getAbsolutePath()), Paths.get(file.getAbsolutePath()));\n+        newResource.setFile(hardlink);\n+        if (modFile != null && modFile.exists()) {\n+          newResource.setModFile(modFile.createHardlink());\n+        }\n+        break;\n+      } catch (FileAlreadyExistsException e) {\n+        // retry a different name if the file is already created\n+      } catch (IOException e) {\n+        logger.error(\"Cannot create hardlink for {}\", file, e);\n+        return null;\n+      }\n+    }\n+    return newResource;\n+  }\n+\n+  public synchronized void setModFile(ModificationFile modFile) {\n+    this.modFile = modFile;\n+  }\n+\n+  public long getMaxVersion() {\n+    long maxVersion = 0;\n+    if (historicalVersions != null) {\n+      maxVersion = Collections.max(historicalVersions);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0ODIwNg=="}, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTcyMDQ1MQ==", "bodyText": "comment left in the source code.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r429720451", "createdAt": "2020-05-25T03:47:20Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileResource.java", "diffHunk": "@@ -571,4 +603,56 @@ public long getTimePartitionWithCheck() throws PartitionViolationException {\n     }\n     return partitionId;\n   }\n+\n+  /**\n+   * Create a hardlink for the TsFile and modification file (if exists)\n+   * The hardlink with have a suffix like \".{sysTime}_{randomLong}\"\n+   * @return a new TsFileResource with its file changed to the hardlink or null the hardlink\n+   * cannot be created.\n+   */\n+  public TsFileResource createHardlink() {\n+    if (!file.exists()) {\n+      return null;\n+    }\n+\n+    TsFileResource newResource;\n+    try {\n+      newResource = new TsFileResource(this);\n+    } catch (IOException e) {\n+      logger.error(\"Cannot create hardlink for {}\", file, e);\n+      return null;\n+    }\n+\n+    while (true) {\n+      String hardlinkSuffix = \".\" + System.currentTimeMillis() + \"_\" + random.nextLong();\n+      File hardlink = new File(file.getAbsolutePath() + hardlinkSuffix);\n+\n+      try {\n+        Files.createLink(Paths.get(hardlink.getAbsolutePath()), Paths.get(file.getAbsolutePath()));\n+        newResource.setFile(hardlink);\n+        if (modFile != null && modFile.exists()) {\n+          newResource.setModFile(modFile.createHardlink());\n+        }\n+        break;\n+      } catch (FileAlreadyExistsException e) {\n+        // retry a different name if the file is already created\n+      } catch (IOException e) {\n+        logger.error(\"Cannot create hardlink for {}\", file, e);\n+        return null;\n+      }\n+    }\n+    return newResource;\n+  }\n+\n+  public synchronized void setModFile(ModificationFile modFile) {\n+    this.modFile = modFile;\n+  }\n+\n+  public long getMaxVersion() {\n+    long maxVersion = 0;\n+    if (historicalVersions != null) {\n+      maxVersion = Collections.max(historicalVersions);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0ODIwNg=="}, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTI4OTc2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMjowMDo0M1rOGYIJFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwNjoyMDo0OFrOGZ124g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk1MjQwNA==", "bodyText": "How about if mRemoteSchemaCache  has no the path?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427952404", "createdAt": "2020-05-20T12:00:43Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -565,6 +605,14 @@ public TSDataType getSeriesType(String path) throws MetadataException {\n       if (path.equals(SQLConstant.RESERVED_TIME)) {\n         return TSDataType.INT64;\n       }\n+\n+      try {\n+        MeasurementSchema schema = mRemoteSchemaCache.get(path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxMjI2Mg==", "bodyText": "Then the path simply does not exist.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428412262", "createdAt": "2020-05-21T02:32:59Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -565,6 +605,14 @@ public TSDataType getSeriesType(String path) throws MetadataException {\n       if (path.equals(SQLConstant.RESERVED_TIME)) {\n         return TSDataType.INT64;\n       }\n+\n+      try {\n+        MeasurementSchema schema = mRemoteSchemaCache.get(path);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk1MjQwNA=="}, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTcyMTE0OA==", "bodyText": "The correct explanation should be added in the catch code block:\n        // if the mRemoteSchemaCache has no such a path, an IOException will be thrown.\n        // we ignore it to get the type from the local mtree.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r429721148", "createdAt": "2020-05-25T03:52:19Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -565,6 +605,14 @@ public TSDataType getSeriesType(String path) throws MetadataException {\n       if (path.equals(SQLConstant.RESERVED_TIME)) {\n         return TSDataType.INT64;\n       }\n+\n+      try {\n+        MeasurementSchema schema = mRemoteSchemaCache.get(path);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk1MjQwNA=="}, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTcyMTkxNw==", "bodyText": "By the way, why not check the local MTree before you check the remote?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r429721917", "createdAt": "2020-05-25T03:57:27Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -565,6 +605,14 @@ public TSDataType getSeriesType(String path) throws MetadataException {\n       if (path.equals(SQLConstant.RESERVED_TIME)) {\n         return TSDataType.INT64;\n       }\n+\n+      try {\n+        MeasurementSchema schema = mRemoteSchemaCache.get(path);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk1MjQwNA=="}, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc0NzA1Nw==", "bodyText": "It is okay, but I think it just repeats the code.\nGenerally, the chance that the schema is in the cache is much higher than that it is in the MTree because every node only stores a small part of the schemas, and checking the cache is much cheaper than searching the tree. I wonder where your suggestion comes from.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r429747057", "createdAt": "2020-05-25T06:09:34Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -565,6 +605,14 @@ public TSDataType getSeriesType(String path) throws MetadataException {\n       if (path.equals(SQLConstant.RESERVED_TIME)) {\n         return TSDataType.INT64;\n       }\n+\n+      try {\n+        MeasurementSchema schema = mRemoteSchemaCache.get(path);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk1MjQwNA=="}, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc0OTk4Ng==", "bodyText": "I think maybe we need to set the exception type as PathNotExist or PathNotFound in the mRemoteCache.. rather than IOException..", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r429749986", "createdAt": "2020-05-25T06:20:48Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -565,6 +605,14 @@ public TSDataType getSeriesType(String path) throws MetadataException {\n       if (path.equals(SQLConstant.RESERVED_TIME)) {\n         return TSDataType.INT64;\n       }\n+\n+      try {\n+        MeasurementSchema schema = mRemoteSchemaCache.get(path);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk1MjQwNA=="}, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTI5NDE2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMjowMjowOFrOGYIL5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjozNDoxM1rOGYkOZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk1MzEyNw==", "bodyText": "why retry?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427953127", "createdAt": "2020-05-20T12:02:08Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -813,12 +861,33 @@ private boolean match(String fullPath, String[] prefixNodes) {\n     }\n   }\n \n-  public MeasurementSchema getSeriesSchema(String device, String measuremnet)\n+  public MeasurementSchema getSeriesSchema(String device, String measurement)\n       throws MetadataException {\n     lock.readLock().lock();\n     try {\n       InternalMNode node = (InternalMNode) mtree.getNodeByPath(device);\n-      return ((LeafMNode) node.getChild(measuremnet)).getSchema();\n+      MNode leaf = node.getChild(measurement);\n+      if (leaf != null) {\n+        return ((LeafMNode) leaf).getSchema();\n+      } else {\n+        return mRemoteSchemaCache\n+            .get(device + IoTDBConstant.PATH_SEPARATOR + measurement);\n+      }\n+    } catch (PathNotExistException e) {\n+      try {\n+        MeasurementSchema measurementSchema = mRemoteSchemaCache", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxMjUxOA==", "bodyText": "Because a PathNotExistException could raise when the device node is not found.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428412518", "createdAt": "2020-05-21T02:34:13Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -813,12 +861,33 @@ private boolean match(String fullPath, String[] prefixNodes) {\n     }\n   }\n \n-  public MeasurementSchema getSeriesSchema(String device, String measuremnet)\n+  public MeasurementSchema getSeriesSchema(String device, String measurement)\n       throws MetadataException {\n     lock.readLock().lock();\n     try {\n       InternalMNode node = (InternalMNode) mtree.getNodeByPath(device);\n-      return ((LeafMNode) node.getChild(measuremnet)).getSchema();\n+      MNode leaf = node.getChild(measurement);\n+      if (leaf != null) {\n+        return ((LeafMNode) leaf).getSchema();\n+      } else {\n+        return mRemoteSchemaCache\n+            .get(device + IoTDBConstant.PATH_SEPARATOR + measurement);\n+      }\n+    } catch (PathNotExistException e) {\n+      try {\n+        MeasurementSchema measurementSchema = mRemoteSchemaCache", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk1MzEyNw=="}, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTMwNDU2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMjowNTozM1rOGYISqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjozNTo1MFrOGYkP9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk1NDg1OA==", "bodyText": "hard to understand...", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427954858", "createdAt": "2020-05-20T12:05:33Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -1405,4 +1501,17 @@ public void collectSeries(String startingPath, List<MeasurementSchema> timeserie\n       lock.readLock().unlock();\n     }\n   }\n+\n+  public void cacheSchema(String path, MeasurementSchema schema) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxMjkxOA==", "bodyText": "I think this is very straight forward: you cache the schema of the path into the MManager, just as the name tells you, nothing more nothing less.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428412918", "createdAt": "2020-05-21T02:35:50Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -1405,4 +1501,17 @@ public void collectSeries(String startingPath, List<MeasurementSchema> timeserie\n       lock.readLock().unlock();\n     }\n   }\n+\n+  public void cacheSchema(String path, MeasurementSchema schema) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk1NDg1OA=="}, "originalCommit": {"oid": "126a946cbaa220f108894020eb5ccdcc1c0698a7"}, "originalPosition": 250}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTM0MzUzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMjoxNjoxOFrOGYIq0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjozODoyOFrOGYkSmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk2MTA0MQ==", "bodyText": "What is the difference between showTimeseries and showTimeseriesWithIndex ?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427961041", "createdAt": "2020-05-20T12:16:18Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -523,6 +533,16 @@ private QueryDataSet getQueryDataSet(List<ShowTimeSeriesResult> timeseriesList)\n     return listDataSet;\n   }\n \n+  protected List<ShowTimeSeriesResult> showTimeseries(ShowTimeSeriesPlan plan)\n+      throws MetadataException {\n+    return MManager.getInstance().showTimeseries(plan);\n+  }\n+\n+  protected List<ShowTimeSeriesResult> showTimeseriesWithIndex(ShowTimeSeriesPlan plan)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxMzU5NA==", "bodyText": "Sorry, I may have rearranged these codes or changed the method privacy, but I am not the person who named this method.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428413594", "createdAt": "2020-05-21T02:38:28Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -523,6 +533,16 @@ private QueryDataSet getQueryDataSet(List<ShowTimeSeriesResult> timeseriesList)\n     return listDataSet;\n   }\n \n+  protected List<ShowTimeSeriesResult> showTimeseries(ShowTimeSeriesPlan plan)\n+      throws MetadataException {\n+    return MManager.getInstance().showTimeseries(plan);\n+  }\n+\n+  protected List<ShowTimeSeriesResult> showTimeseriesWithIndex(ShowTimeSeriesPlan plan)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk2MTA0MQ=="}, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTM2NjA1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMjoyMTo0OVrOGYI4YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjo0MDo1N1rOGYkVOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk2NDUxMg==", "bodyText": "why create such a method??\nwhy not let the user call lock and unlock method explicitly. @JackieTien97", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427964512", "createdAt": "2020-05-20T12:21:49Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -864,43 +888,78 @@ public void delete(Path path, long timestamp) throws QueryProcessException {\n \n   @Override\n   public void insert(InsertPlan insertPlan) throws QueryProcessException {\n-    MNode node = null;\n     try {\n       String[] measurementList = insertPlan.getMeasurements();\n       String deviceId = insertPlan.getDeviceId();\n-      node = mManager.getDeviceNodeWithAutoCreateAndReadLock(deviceId);\n       String[] strValues = insertPlan.getValues();\n-      MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n-\n-      for (int i = 0; i < measurementList.length; i++) {\n-        String measurement = measurementList[i];\n-        if (!node.hasChild(measurement)) {\n-          if (!IoTDBDescriptor.getInstance().getConfig().isAutoCreateSchemaEnabled()) {\n-            throw new PathNotExistException(deviceId + PATH_SEPARATOR + measurement);\n-          }\n-          TSDataType dataType = TypeInferenceUtils.getPredictedDataType(strValues[i]);\n-          Path path = new Path(deviceId, measurement);\n-          internalCreateTimeseries(path.toString(), dataType);\n-        }\n-        LeafMNode measurementNode = (LeafMNode) node.getChild(measurement);\n-        schemas[i] = measurementNode.getSchema();\n-        // reset measurement to common name instead of alias\n-        measurementList[i] = measurementNode.getName();\n-      }\n-\n-      insertPlan.setMeasurements(measurementList);\n+      MeasurementSchema[] schemas = getSeriesSchemas(measurementList, deviceId, strValues);\n       insertPlan.setSchemas(schemas);\n       StorageEngine.getInstance().insert(insertPlan);\n     } catch (StorageEngineException | MetadataException e) {\n       throw new QueryProcessException(e);\n+    }\n+  }\n+\n+  protected MeasurementSchema[] getSeriesSchemas(String[] measurementList, String deviceId,\n+      String[] strValues) throws MetadataException {\n+    MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n+\n+    MNode node = null;\n+    try {\n+      node = mManager.getDeviceNodeWithAutoCreateAndReadLock(deviceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk2NTMxNw==", "bodyText": "For example, if this try-catch throws some RuntimeException (which PathNotExistException can not catch), then the lock is not released..", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r427965317", "createdAt": "2020-05-20T12:23:00Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -864,43 +888,78 @@ public void delete(Path path, long timestamp) throws QueryProcessException {\n \n   @Override\n   public void insert(InsertPlan insertPlan) throws QueryProcessException {\n-    MNode node = null;\n     try {\n       String[] measurementList = insertPlan.getMeasurements();\n       String deviceId = insertPlan.getDeviceId();\n-      node = mManager.getDeviceNodeWithAutoCreateAndReadLock(deviceId);\n       String[] strValues = insertPlan.getValues();\n-      MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n-\n-      for (int i = 0; i < measurementList.length; i++) {\n-        String measurement = measurementList[i];\n-        if (!node.hasChild(measurement)) {\n-          if (!IoTDBDescriptor.getInstance().getConfig().isAutoCreateSchemaEnabled()) {\n-            throw new PathNotExistException(deviceId + PATH_SEPARATOR + measurement);\n-          }\n-          TSDataType dataType = TypeInferenceUtils.getPredictedDataType(strValues[i]);\n-          Path path = new Path(deviceId, measurement);\n-          internalCreateTimeseries(path.toString(), dataType);\n-        }\n-        LeafMNode measurementNode = (LeafMNode) node.getChild(measurement);\n-        schemas[i] = measurementNode.getSchema();\n-        // reset measurement to common name instead of alias\n-        measurementList[i] = measurementNode.getName();\n-      }\n-\n-      insertPlan.setMeasurements(measurementList);\n+      MeasurementSchema[] schemas = getSeriesSchemas(measurementList, deviceId, strValues);\n       insertPlan.setSchemas(schemas);\n       StorageEngine.getInstance().insert(insertPlan);\n     } catch (StorageEngineException | MetadataException e) {\n       throw new QueryProcessException(e);\n+    }\n+  }\n+\n+  protected MeasurementSchema[] getSeriesSchemas(String[] measurementList, String deviceId,\n+      String[] strValues) throws MetadataException {\n+    MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n+\n+    MNode node = null;\n+    try {\n+      node = mManager.getDeviceNodeWithAutoCreateAndReadLock(deviceId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk2NDUxMg=="}, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNDI2NQ==", "bodyText": "This is not introduced in this PR and I only rearranged the codes to reduce the complexity.\nI suggest you discuss with him directly or start an issue, but it is really not the concern of this PR.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428414265", "createdAt": "2020-05-21T02:40:57Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -864,43 +888,78 @@ public void delete(Path path, long timestamp) throws QueryProcessException {\n \n   @Override\n   public void insert(InsertPlan insertPlan) throws QueryProcessException {\n-    MNode node = null;\n     try {\n       String[] measurementList = insertPlan.getMeasurements();\n       String deviceId = insertPlan.getDeviceId();\n-      node = mManager.getDeviceNodeWithAutoCreateAndReadLock(deviceId);\n       String[] strValues = insertPlan.getValues();\n-      MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n-\n-      for (int i = 0; i < measurementList.length; i++) {\n-        String measurement = measurementList[i];\n-        if (!node.hasChild(measurement)) {\n-          if (!IoTDBDescriptor.getInstance().getConfig().isAutoCreateSchemaEnabled()) {\n-            throw new PathNotExistException(deviceId + PATH_SEPARATOR + measurement);\n-          }\n-          TSDataType dataType = TypeInferenceUtils.getPredictedDataType(strValues[i]);\n-          Path path = new Path(deviceId, measurement);\n-          internalCreateTimeseries(path.toString(), dataType);\n-        }\n-        LeafMNode measurementNode = (LeafMNode) node.getChild(measurement);\n-        schemas[i] = measurementNode.getSchema();\n-        // reset measurement to common name instead of alias\n-        measurementList[i] = measurementNode.getName();\n-      }\n-\n-      insertPlan.setMeasurements(measurementList);\n+      MeasurementSchema[] schemas = getSeriesSchemas(measurementList, deviceId, strValues);\n       insertPlan.setSchemas(schemas);\n       StorageEngine.getInstance().insert(insertPlan);\n     } catch (StorageEngineException | MetadataException e) {\n       throw new QueryProcessException(e);\n+    }\n+  }\n+\n+  protected MeasurementSchema[] getSeriesSchemas(String[] measurementList, String deviceId,\n+      String[] strValues) throws MetadataException {\n+    MeasurementSchema[] schemas = new MeasurementSchema[measurementList.length];\n+\n+    MNode node = null;\n+    try {\n+      node = mManager.getDeviceNodeWithAutoCreateAndReadLock(deviceId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk2NDUxMg=="}, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjM4NDE5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/sys/AuthorPlan.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNTo1OTo1NFrOGYS2Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjo0Mzo0MVrOGYkXwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNzc5OQ==", "bodyText": "if transformOperatorTypeToAuthorType is only used by setAuthorType(AuthorType.values()[transformOperatorTypeToAuthorType(operatorType)]);, why not set the returned type as AuthorType directly?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428127799", "createdAt": "2020-05-20T15:59:54Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/sys/AuthorPlan.java", "diffHunk": "@@ -125,6 +130,58 @@ public AuthorPlan(AuthorOperator.AuthorType authorType, String userName, String\n     }\n   }\n \n+  public AuthorPlan(OperatorType operatorType) throws IOException {\n+    super(false, operatorType);\n+    setAuthorType(AuthorType.values()[transformOperatorTypeToAuthorType(operatorType)]);\n+  }\n+\n+  private int transformOperatorTypeToAuthorType(OperatorType operatorType)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNDkxMw==", "bodyText": "I do not think this makes any difference.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428414913", "createdAt": "2020-05-21T02:43:41Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/sys/AuthorPlan.java", "diffHunk": "@@ -125,6 +130,58 @@ public AuthorPlan(AuthorOperator.AuthorType authorType, String userName, String\n     }\n   }\n \n+  public AuthorPlan(OperatorType operatorType) throws IOException {\n+    super(false, operatorType);\n+    setAuthorType(AuthorType.values()[transformOperatorTypeToAuthorType(operatorType)]);\n+  }\n+\n+  private int transformOperatorTypeToAuthorType(OperatorType operatorType)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNzc5OQ=="}, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjM5MzIwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjowMjowNlrOGYS8aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjo0NDoyMFrOGYkYZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyOTM4NA==", "bodyText": "format the code", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428129384", "createdAt": "2020-05-20T16:02:06Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java", "diffHunk": "@@ -201,7 +202,12 @@ public void enterRemoveFile(RemoveFileContext ctx) {\n   @Override\n   public void enterLoadConfigurationStatement(LoadConfigurationStatementContext ctx) {\n     super.enterLoadConfigurationStatement(ctx);\n-    initializedOperator = new LoadConfigurationOperator();\n+    if(ctx.GLOBAL()!=null){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNTA3OA==", "bodyText": "Formated.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428415078", "createdAt": "2020-05-21T02:44:20Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java", "diffHunk": "@@ -201,7 +202,12 @@ public void enterRemoveFile(RemoveFileContext ctx) {\n   @Override\n   public void enterLoadConfigurationStatement(LoadConfigurationStatementContext ctx) {\n     super.enterLoadConfigurationStatement(ctx);\n-    initializedOperator = new LoadConfigurationOperator();\n+    if(ctx.GLOBAL()!=null){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyOTM4NA=="}, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjM5OTU2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/ShowTimeSeriesResult.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjowMzo0MVrOGYTArQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjo0NjoxMVrOGYkaQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMDQ3Nw==", "bodyText": "== true?", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428130477", "createdAt": "2020-05-20T16:03:41Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/ShowTimeSeriesResult.java", "diffHunk": "@@ -68,4 +79,70 @@ public String getCompressor() {\n   public Map<String, String> getTagAndAttribute() {\n     return tagAndAttribute;\n   }\n+\n+  @Override\n+  public int compareTo(ShowTimeSeriesResult o) {\n+    return this.name.compareTo(o.name);\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    ShowTimeSeriesResult result = (ShowTimeSeriesResult) o;\n+    return Objects.equals(name, result.name);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(name);\n+  }\n+\n+  public void serialize(OutputStream outputStream) throws IOException {\n+    ReadWriteIOUtils.write(name, outputStream);\n+    ReadWriteIOUtils.write(alias != null, outputStream);\n+    if (alias != null) {\n+      ReadWriteIOUtils.write(alias, outputStream);\n+    }\n+    ReadWriteIOUtils.write(sgName, outputStream);\n+    ReadWriteIOUtils.write(dataType, outputStream);\n+    ReadWriteIOUtils.write(encoding, outputStream);\n+    ReadWriteIOUtils.write(compressor, outputStream);\n+\n+    ReadWriteIOUtils.write(tagAndAttribute != null, outputStream);\n+    if (tagAndAttribute != null) {\n+      ReadWriteIOUtils.write(tagAndAttribute.size(), outputStream);\n+      for (Entry<String, String> stringStringEntry : tagAndAttribute.entrySet()) {\n+        ReadWriteIOUtils.write(stringStringEntry.getKey(), outputStream);\n+        ReadWriteIOUtils.write(stringStringEntry.getValue(), outputStream);\n+      }\n+    }\n+  }\n+\n+  public static ShowTimeSeriesResult deserialize(ByteBuffer buffer) {\n+    ShowTimeSeriesResult result = new ShowTimeSeriesResult();\n+    result.name = ReadWriteIOUtils.readString(buffer);\n+    if (buffer.get() == 1) {\n+      result.alias = ReadWriteIOUtils.readString(buffer);\n+    }\n+    result.sgName = ReadWriteIOUtils.readString(buffer);\n+    result.dataType = ReadWriteIOUtils.readString(buffer);\n+    result.encoding = ReadWriteIOUtils.readString(buffer);\n+    result.compressor = ReadWriteIOUtils.readString(buffer);\n+\n+    if (buffer.get() == 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNTU1Mg==", "bodyText": "This is not C or C++, so integers are not comparable with booleans. Besides, there is no getBoolean in ByteBuffer.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428415552", "createdAt": "2020-05-21T02:46:11Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/ShowTimeSeriesResult.java", "diffHunk": "@@ -68,4 +79,70 @@ public String getCompressor() {\n   public Map<String, String> getTagAndAttribute() {\n     return tagAndAttribute;\n   }\n+\n+  @Override\n+  public int compareTo(ShowTimeSeriesResult o) {\n+    return this.name.compareTo(o.name);\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    ShowTimeSeriesResult result = (ShowTimeSeriesResult) o;\n+    return Objects.equals(name, result.name);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(name);\n+  }\n+\n+  public void serialize(OutputStream outputStream) throws IOException {\n+    ReadWriteIOUtils.write(name, outputStream);\n+    ReadWriteIOUtils.write(alias != null, outputStream);\n+    if (alias != null) {\n+      ReadWriteIOUtils.write(alias, outputStream);\n+    }\n+    ReadWriteIOUtils.write(sgName, outputStream);\n+    ReadWriteIOUtils.write(dataType, outputStream);\n+    ReadWriteIOUtils.write(encoding, outputStream);\n+    ReadWriteIOUtils.write(compressor, outputStream);\n+\n+    ReadWriteIOUtils.write(tagAndAttribute != null, outputStream);\n+    if (tagAndAttribute != null) {\n+      ReadWriteIOUtils.write(tagAndAttribute.size(), outputStream);\n+      for (Entry<String, String> stringStringEntry : tagAndAttribute.entrySet()) {\n+        ReadWriteIOUtils.write(stringStringEntry.getKey(), outputStream);\n+        ReadWriteIOUtils.write(stringStringEntry.getValue(), outputStream);\n+      }\n+    }\n+  }\n+\n+  public static ShowTimeSeriesResult deserialize(ByteBuffer buffer) {\n+    ShowTimeSeriesResult result = new ShowTimeSeriesResult();\n+    result.name = ReadWriteIOUtils.readString(buffer);\n+    if (buffer.get() == 1) {\n+      result.alias = ReadWriteIOUtils.readString(buffer);\n+    }\n+    result.sgName = ReadWriteIOUtils.readString(buffer);\n+    result.dataType = ReadWriteIOUtils.readString(buffer);\n+    result.encoding = ReadWriteIOUtils.readString(buffer);\n+    result.compressor = ReadWriteIOUtils.readString(buffer);\n+\n+    if (buffer.get() == 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMDQ3Nw=="}, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjQxMzk1OnYy", "diffSide": "RIGHT", "path": "service-rpc/src/main/java/org/apache/iotdb/rpc/TSStatusCode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjowNzowOVrOGYTJzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjo0ODo0MFrOGYkcmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMjgxNA==", "bodyText": "what for? maybe we need to separate the time_out between the single node and cluster.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428132814", "createdAt": "2020-05-20T16:07:09Z", "author": {"login": "jixuan1989"}, "path": "service-rpc/src/main/java/org/apache/iotdb/rpc/TSStatusCode.java", "diffHunk": "@@ -63,10 +63,19 @@\n   READ_ONLY_SYSTEM_ERROR(502),\n   DISK_SPACE_INSUFFICIENT_ERROR(503),\n   START_UP_ERROR(504),\n+\n   WRONG_LOGIN_PASSWORD_ERROR(600),\n   NOT_LOGIN_ERROR(601),\n   NO_PERMISSION_ERROR(602),\n   UNINITIALIZED_AUTH_ERROR(603),\n+\n+  // TODO-Cluster: update docs when ready to merge\n+  PARTITION_NOT_READY(700),\n+  TIME_OUT(701),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNjE1NA==", "bodyText": "What \"what for\"? These are error codes for the distributed version, and certainly, you will not have a node's communication time out with another node in the stand-alone version because there is only one node.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428416154", "createdAt": "2020-05-21T02:48:40Z", "author": {"login": "jt2594838"}, "path": "service-rpc/src/main/java/org/apache/iotdb/rpc/TSStatusCode.java", "diffHunk": "@@ -63,10 +63,19 @@\n   READ_ONLY_SYSTEM_ERROR(502),\n   DISK_SPACE_INSUFFICIENT_ERROR(503),\n   START_UP_ERROR(504),\n+\n   WRONG_LOGIN_PASSWORD_ERROR(600),\n   NOT_LOGIN_ERROR(601),\n   NO_PERMISSION_ERROR(602),\n   UNINITIALIZED_AUTH_ERROR(603),\n+\n+  // TODO-Cluster: update docs when ready to merge\n+  PARTITION_NOT_READY(700),\n+  TIME_OUT(701),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMjgxNA=="}, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjQyNTUwOnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/utils/ReadWriteIOUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjoxMDowNVrOGYTRWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjo1MDozOVrOGYkelw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzNDc0NA==", "bodyText": "How about merge this class and SerializeUtils.java", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428134744", "createdAt": "2020-05-20T16:10:05Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/utils/ReadWriteIOUtils.java", "diffHunk": "@@ -326,6 +326,15 @@ public static int write(ByteBuffer byteBuffer, OutputStream outputStream) throws\n     return len;\n   }\n \n+  /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNjY2Mw==", "bodyText": "Not necessary and burdensome. This one is mainly for primitive types or java built-in classes, and SerializeUtils is mainly for our customized classes.", "url": "https://github.com/apache/iotdb/pull/1169#discussion_r428416663", "createdAt": "2020-05-21T02:50:39Z", "author": {"login": "jt2594838"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/utils/ReadWriteIOUtils.java", "diffHunk": "@@ -326,6 +326,15 @@ public static int write(ByteBuffer byteBuffer, OutputStream outputStream) throws\n     return len;\n   }\n \n+  /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzNDc0NA=="}, "originalCommit": {"oid": "3fa666caabef2aaa9c8583fae74b871369d19b75"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4959, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}