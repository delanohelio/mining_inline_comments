{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3MTA3MzQy", "number": 1204, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjowNzoxNVrOD9nHyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwODowNTowM1rOEDJy0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTMwNjk3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/GroupByPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjowNzoxNVrOGXNUAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjowNzoxNVrOGXNUAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk4ODU0NQ==", "bodyText": "The GroupByPlan is actually GroupByTimePlan, so no need to add a byTime field, we can rename the class.", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426988545", "createdAt": "2020-05-19T02:07:15Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/GroupByPlan.java", "diffHunk": "@@ -33,6 +33,8 @@\n   // if it is left close and right open interval\n   private boolean leftCRightO = true;\n \n+  private boolean byTime = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTMyMzk2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjoxNzo1OVrOGXNeqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjoxNzo1OVrOGXNeqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MTI3Mg==", "bodyText": "Actually, we support path like this:  root.sg.d.\"s.1\"\ns.1 is measurement name", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426991272", "createdAt": "2020-05-19T02:17:59Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  private int level = -1;\n+  private boolean isByTime = false;\n+  protected long queryId;\n+  private GroupByEngineDataSet dataSet;\n+  private GroupByPlan groupByPlan;\n+  private QueryContext context;\n+\n+  private Map<Path, GroupByExecutor> pathExecutors = new HashMap<>();\n+  private Map<Path, List<Integer>> resultIndexes = new HashMap<>();\n+\n+  public GroupByLevelDataSet(QueryContext context, GroupByPlan plan, GroupByEngineDataSet dataSet)\n+    throws QueryProcessException, StorageEngineException, IOException {\n+    this.queryId = context.getQueryId();\n+    this.level = plan.getLevel();\n+    this.isByTime = plan.isByTime();\n+    this.dataSet = dataSet;\n+    this.paths = plan.getPaths();\n+    this.dataTypes = plan.getDataTypes();\n+    this.groupByPlan = plan;\n+    this.context = context;\n+\n+    logger.debug(\"paths \" + this.paths);\n+\n+    RowRecord record = new RowRecord(0);\n+    if (!isByTime) {\n+      initGroupBy();\n+      record = getRecordWithoutTimeInterval();\n+    } else {\n+      // get all records from GroupByDataSet, then we merge them to one record\n+      logger.debug(\"only group by level, paths:\" + groupByPlan.getPaths());\n+      while (dataSet != null && dataSet.hasNextWithoutConstraint()) {\n+        RowRecord curRecord = dataSet.nextWithoutConstraint();\n+        record = mergeRecords(curRecord, record);\n+      }\n+    }\n+\n+    // prepare final records\n+    // group by level\n+    // path -> count\n+    Map<String, Long> finalPaths = new TreeMap<String, Long>();\n+\n+    for (int j = 0; j < this.paths.size(); j++) {\n+      String[] tmpPath = this.paths.get(j).getFullPath().split(\"\\\\.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTMyNTM3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjoxODo1MFrOGXNfiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjoxODo1MFrOGXNfiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MTQ5OQ==", "bodyText": "add if (logger.isDebugEnabled())", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426991499", "createdAt": "2020-05-19T02:18:50Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  private int level = -1;\n+  private boolean isByTime = false;\n+  protected long queryId;\n+  private GroupByEngineDataSet dataSet;\n+  private GroupByPlan groupByPlan;\n+  private QueryContext context;\n+\n+  private Map<Path, GroupByExecutor> pathExecutors = new HashMap<>();\n+  private Map<Path, List<Integer>> resultIndexes = new HashMap<>();\n+\n+  public GroupByLevelDataSet(QueryContext context, GroupByPlan plan, GroupByEngineDataSet dataSet)\n+    throws QueryProcessException, StorageEngineException, IOException {\n+    this.queryId = context.getQueryId();\n+    this.level = plan.getLevel();\n+    this.isByTime = plan.isByTime();\n+    this.dataSet = dataSet;\n+    this.paths = plan.getPaths();\n+    this.dataTypes = plan.getDataTypes();\n+    this.groupByPlan = plan;\n+    this.context = context;\n+\n+    logger.debug(\"paths \" + this.paths);\n+\n+    RowRecord record = new RowRecord(0);\n+    if (!isByTime) {\n+      initGroupBy();\n+      record = getRecordWithoutTimeInterval();\n+    } else {\n+      // get all records from GroupByDataSet, then we merge them to one record\n+      logger.debug(\"only group by level, paths:\" + groupByPlan.getPaths());\n+      while (dataSet != null && dataSet.hasNextWithoutConstraint()) {\n+        RowRecord curRecord = dataSet.nextWithoutConstraint();\n+        record = mergeRecords(curRecord, record);\n+      }\n+    }\n+\n+    // prepare final records\n+    // group by level\n+    // path -> count\n+    Map<String, Long> finalPaths = new TreeMap<String, Long>();\n+\n+    for (int j = 0; j < this.paths.size(); j++) {\n+      String[] tmpPath = this.paths.get(j).getFullPath().split(\"\\\\.\");\n+\n+      String key;\n+      if (tmpPath.length <= level) {\n+        key = this.paths.get(j).getFullPath();\n+      } else {\n+        StringBuilder path = new StringBuilder();\n+        for (int k = 0; k <= level; k++) {\n+          if (k == 0) {\n+            path.append(tmpPath[k]);\n+          } else {\n+            path.append(\".\" + tmpPath[k]);\n+          }\n+        }\n+        key = path.toString();\n+      }\n+      logger.debug(\"records \" + record.getFields().toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTMyNzc0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjoyMDoyMlrOGXNhEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjoyMDoyMlrOGXNhEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MTg4OA==", "bodyText": "please add javadoc and an example", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426991888", "createdAt": "2020-05-19T02:20:22Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  private int level = -1;\n+  private boolean isByTime = false;\n+  protected long queryId;\n+  private GroupByEngineDataSet dataSet;\n+  private GroupByPlan groupByPlan;\n+  private QueryContext context;\n+\n+  private Map<Path, GroupByExecutor> pathExecutors = new HashMap<>();\n+  private Map<Path, List<Integer>> resultIndexes = new HashMap<>();\n+\n+  public GroupByLevelDataSet(QueryContext context, GroupByPlan plan, GroupByEngineDataSet dataSet)\n+    throws QueryProcessException, StorageEngineException, IOException {\n+    this.queryId = context.getQueryId();\n+    this.level = plan.getLevel();\n+    this.isByTime = plan.isByTime();\n+    this.dataSet = dataSet;\n+    this.paths = plan.getPaths();\n+    this.dataTypes = plan.getDataTypes();\n+    this.groupByPlan = plan;\n+    this.context = context;\n+\n+    logger.debug(\"paths \" + this.paths);\n+\n+    RowRecord record = new RowRecord(0);\n+    if (!isByTime) {\n+      initGroupBy();\n+      record = getRecordWithoutTimeInterval();\n+    } else {\n+      // get all records from GroupByDataSet, then we merge them to one record\n+      logger.debug(\"only group by level, paths:\" + groupByPlan.getPaths());\n+      while (dataSet != null && dataSet.hasNextWithoutConstraint()) {\n+        RowRecord curRecord = dataSet.nextWithoutConstraint();\n+        record = mergeRecords(curRecord, record);\n+      }\n+    }\n+\n+    // prepare final records\n+    // group by level\n+    // path -> count\n+    Map<String, Long> finalPaths = new TreeMap<String, Long>();\n+\n+    for (int j = 0; j < this.paths.size(); j++) {\n+      String[] tmpPath = this.paths.get(j).getFullPath().split(\"\\\\.\");\n+\n+      String key;\n+      if (tmpPath.length <= level) {\n+        key = this.paths.get(j).getFullPath();\n+      } else {\n+        StringBuilder path = new StringBuilder();\n+        for (int k = 0; k <= level; k++) {\n+          if (k == 0) {\n+            path.append(tmpPath[k]);\n+          } else {\n+            path.append(\".\" + tmpPath[k]);\n+          }\n+        }\n+        key = path.toString();\n+      }\n+      logger.debug(\"records \" + record.getFields().toString());\n+      finalPaths.put(key,\n+        record.getFields().get(j).getLongV()\n+          + finalPaths.getOrDefault(key, 0L));\n+    }\n+\n+    this.paths = Arrays.asList(new Path(COLUMN_COLUMN), new Path(COLUMN_COUNT));\n+    this.dataTypes = Arrays.asList(TSDataType.TEXT, TSDataType.TEXT);\n+\n+    for (Map.Entry<String, Long> entry : finalPaths.entrySet()) {\n+      RowRecord tmpRecord = new RowRecord(0);\n+      Field field = new Field(TSDataType.TEXT);\n+      field.setBinaryV(new Binary(entry.getKey()));\n+      logger.debug(\"rowRecord \" + entry.getKey());\n+      Field field1 = new Field(TSDataType.TEXT);\n+      field1.setBinaryV(new Binary(Long.toString(entry.getValue())));\n+      tmpRecord.addField(field);\n+      tmpRecord.addField(field1);\n+      records.add(tmpRecord);\n+      logger.info(tmpRecord.toString());\n+    }\n+  }\n+\n+  @Override\n+  protected boolean hasNextWithoutConstraint() throws IOException {\n+    return index < records.size();\n+  }\n+\n+  @Override\n+  protected RowRecord nextWithoutConstraint() {\n+    return records.get(index++);\n+  }\n+\n+  private void initGroupBy()\n+    throws QueryProcessException, StorageEngineException {\n+    // get all aggregation results, then we package them to one record\n+    for (int i = 0; i < paths.size(); i++) {\n+      Path path = paths.get(i);\n+      if (!pathExecutors.containsKey(path)) {\n+        //init GroupByExecutor\n+        pathExecutors.put(path,\n+          getGroupByExecutor(path, groupByPlan.getAllMeasurementsInDevice(path.getDevice()), dataTypes.get(i), this.context, null, null));\n+        resultIndexes.put(path, new ArrayList<>());\n+      } else {\n+        throw new QueryProcessException(\"duplicated path found, path:\" + path);\n+      }\n+      resultIndexes.get(path).add(i);\n+      AggregateResult aggrResult = AggregateResultFactory\n+        .getAggrResultByName(groupByPlan.getDeduplicatedAggregations().get(i), dataTypes.get(i));\n+      pathExecutors.get(path).addAggregateResult(aggrResult);\n+    }\n+  }\n+\n+  private GroupByExecutor getGroupByExecutor(Path path, Set<String> allSensors, TSDataType dataType,\n+                                             QueryContext context, Filter timeFilter, TsFileFilter fileFilter)\n+    throws StorageEngineException, QueryProcessException {\n+    return new LocalGroupByExecutor(path, allSensors, dataType, context, timeFilter, fileFilter);\n+  }\n+\n+  private RowRecord getRecordWithoutTimeInterval()\n+    throws IOException {\n+    RowRecord record = new RowRecord(0);\n+    AggregateResult[] fields = new AggregateResult[paths.size()];\n+\n+    try {\n+      for (Map.Entry<Path, GroupByExecutor> pathToExecutorEntry : pathExecutors.entrySet()) {\n+        GroupByExecutor executor = pathToExecutorEntry.getValue();\n+        List<AggregateResult> aggregations = executor.calcResult(Long.MIN_VALUE, Long.MAX_VALUE);\n+        for (int i = 0; i < aggregations.size(); i++) {\n+          int resultIndex = resultIndexes.get(pathToExecutorEntry.getKey()).get(i);\n+          fields[resultIndex] = aggregations.get(i);\n+        }\n+      }\n+    } catch (QueryProcessException e) {\n+      logger.error(\"GroupByWithoutValueFilterDataSet execute has error\", e);\n+      throw new IOException(e.getMessage(), e);\n+    }\n+\n+    for (AggregateResult res : fields) {\n+      if (res == null) {\n+        record.addField(null);\n+        continue;\n+      }\n+      record.addField(res.getResult(), res.getResultDataType());\n+    }\n+    return record;\n+  }\n+\n+  private RowRecord mergeRecords(RowRecord newRecord, RowRecord oldRecord) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTMzMzcyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjoyMzo1OFrOGXNkzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjoyMzo1OFrOGXNkzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5Mjg0Nw==", "bodyText": "initGroupByLevel?", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426992847", "createdAt": "2020-05-19T02:23:58Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  private int level = -1;\n+  private boolean isByTime = false;\n+  protected long queryId;\n+  private GroupByEngineDataSet dataSet;\n+  private GroupByPlan groupByPlan;\n+  private QueryContext context;\n+\n+  private Map<Path, GroupByExecutor> pathExecutors = new HashMap<>();\n+  private Map<Path, List<Integer>> resultIndexes = new HashMap<>();\n+\n+  public GroupByLevelDataSet(QueryContext context, GroupByPlan plan, GroupByEngineDataSet dataSet)\n+    throws QueryProcessException, StorageEngineException, IOException {\n+    this.queryId = context.getQueryId();\n+    this.level = plan.getLevel();\n+    this.isByTime = plan.isByTime();\n+    this.dataSet = dataSet;\n+    this.paths = plan.getPaths();\n+    this.dataTypes = plan.getDataTypes();\n+    this.groupByPlan = plan;\n+    this.context = context;\n+\n+    logger.debug(\"paths \" + this.paths);\n+\n+    RowRecord record = new RowRecord(0);\n+    if (!isByTime) {\n+      initGroupBy();\n+      record = getRecordWithoutTimeInterval();\n+    } else {\n+      // get all records from GroupByDataSet, then we merge them to one record\n+      logger.debug(\"only group by level, paths:\" + groupByPlan.getPaths());\n+      while (dataSet != null && dataSet.hasNextWithoutConstraint()) {\n+        RowRecord curRecord = dataSet.nextWithoutConstraint();\n+        record = mergeRecords(curRecord, record);\n+      }\n+    }\n+\n+    // prepare final records\n+    // group by level\n+    // path -> count\n+    Map<String, Long> finalPaths = new TreeMap<String, Long>();\n+\n+    for (int j = 0; j < this.paths.size(); j++) {\n+      String[] tmpPath = this.paths.get(j).getFullPath().split(\"\\\\.\");\n+\n+      String key;\n+      if (tmpPath.length <= level) {\n+        key = this.paths.get(j).getFullPath();\n+      } else {\n+        StringBuilder path = new StringBuilder();\n+        for (int k = 0; k <= level; k++) {\n+          if (k == 0) {\n+            path.append(tmpPath[k]);\n+          } else {\n+            path.append(\".\" + tmpPath[k]);\n+          }\n+        }\n+        key = path.toString();\n+      }\n+      logger.debug(\"records \" + record.getFields().toString());\n+      finalPaths.put(key,\n+        record.getFields().get(j).getLongV()\n+          + finalPaths.getOrDefault(key, 0L));\n+    }\n+\n+    this.paths = Arrays.asList(new Path(COLUMN_COLUMN), new Path(COLUMN_COUNT));\n+    this.dataTypes = Arrays.asList(TSDataType.TEXT, TSDataType.TEXT);\n+\n+    for (Map.Entry<String, Long> entry : finalPaths.entrySet()) {\n+      RowRecord tmpRecord = new RowRecord(0);\n+      Field field = new Field(TSDataType.TEXT);\n+      field.setBinaryV(new Binary(entry.getKey()));\n+      logger.debug(\"rowRecord \" + entry.getKey());\n+      Field field1 = new Field(TSDataType.TEXT);\n+      field1.setBinaryV(new Binary(Long.toString(entry.getValue())));\n+      tmpRecord.addField(field);\n+      tmpRecord.addField(field1);\n+      records.add(tmpRecord);\n+      logger.info(tmpRecord.toString());\n+    }\n+  }\n+\n+  @Override\n+  protected boolean hasNextWithoutConstraint() throws IOException {\n+    return index < records.size();\n+  }\n+\n+  @Override\n+  protected RowRecord nextWithoutConstraint() {\n+    return records.get(index++);\n+  }\n+\n+  private void initGroupBy()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTMzNDg5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/QueryRouter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjoyNDo1MlrOGXNlhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjoyOToxNlrOGXRltw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MzAzMA==", "bodyText": "check if debug enabled", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426993030", "createdAt": "2020-05-19T02:24:52Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/QueryRouter.java", "diffHunk": "@@ -113,34 +114,45 @@ protected AggregationExecutor getAggregationExecutor(AggregationPlan aggregation\n \n   @Override\n   public QueryDataSet groupBy(GroupByPlan groupByPlan, QueryContext context)\n-      throws QueryFilterOptimizationException, StorageEngineException, QueryProcessException {\n-    long unit = groupByPlan.getInterval();\n-    long slidingStep = groupByPlan.getSlidingStep();\n-    long startTime = groupByPlan.getStartTime();\n-    long endTime = groupByPlan.getEndTime();\n+    throws QueryFilterOptimizationException, StorageEngineException, QueryProcessException, IOException {\n+\n+    logger.debug(\"paths:\" + groupByPlan.getPaths() + \" level:\" + groupByPlan.getLevel() + \" byTime:\" + groupByPlan.isByTime());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxNQ==", "bodyText": "ok", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r427058615", "createdAt": "2020-05-19T06:29:16Z", "author": {"login": "mychaow"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/QueryRouter.java", "diffHunk": "@@ -113,34 +114,45 @@ protected AggregationExecutor getAggregationExecutor(AggregationPlan aggregation\n \n   @Override\n   public QueryDataSet groupBy(GroupByPlan groupByPlan, QueryContext context)\n-      throws QueryFilterOptimizationException, StorageEngineException, QueryProcessException {\n-    long unit = groupByPlan.getInterval();\n-    long slidingStep = groupByPlan.getSlidingStep();\n-    long startTime = groupByPlan.getStartTime();\n-    long endTime = groupByPlan.getEndTime();\n+    throws QueryFilterOptimizationException, StorageEngineException, QueryProcessException, IOException {\n+\n+    logger.debug(\"paths:\" + groupByPlan.getPaths() + \" level:\" + groupByPlan.getLevel() + \" byTime:\" + groupByPlan.isByTime());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MzAzMA=="}, "originalCommit": {"oid": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTM0NjQ2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozMToxOVrOGXNsZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozMToxOVrOGXNsZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NDc5MA==", "bodyText": "dataSet is not used as a global variable. Actually, level and isByTime could also be converted to local variables", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426994790", "createdAt": "2020-05-19T02:31:19Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  private int level = -1;\n+  private boolean isByTime = false;\n+  protected long queryId;\n+  private GroupByEngineDataSet dataSet;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTM1NzUyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozNjo1NlrOGXNysA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjoyMjo1M1rOGXRcAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NjQwMA==", "bodyText": "I think you'd better use logger.error instead of assertion, what do you think?", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426996400", "createdAt": "2020-05-19T02:36:56Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  private int level = -1;\n+  private boolean isByTime = false;\n+  protected long queryId;\n+  private GroupByEngineDataSet dataSet;\n+  private GroupByPlan groupByPlan;\n+  private QueryContext context;\n+\n+  private Map<Path, GroupByExecutor> pathExecutors = new HashMap<>();\n+  private Map<Path, List<Integer>> resultIndexes = new HashMap<>();\n+\n+  public GroupByLevelDataSet(QueryContext context, GroupByPlan plan, GroupByEngineDataSet dataSet)\n+    throws QueryProcessException, StorageEngineException, IOException {\n+    this.queryId = context.getQueryId();\n+    this.level = plan.getLevel();\n+    this.isByTime = plan.isByTime();\n+    this.dataSet = dataSet;\n+    this.paths = plan.getPaths();\n+    this.dataTypes = plan.getDataTypes();\n+    this.groupByPlan = plan;\n+    this.context = context;\n+\n+    logger.debug(\"paths \" + this.paths);\n+\n+    RowRecord record = new RowRecord(0);\n+    if (!isByTime) {\n+      initGroupBy();\n+      record = getRecordWithoutTimeInterval();\n+    } else {\n+      // get all records from GroupByDataSet, then we merge them to one record\n+      logger.debug(\"only group by level, paths:\" + groupByPlan.getPaths());\n+      while (dataSet != null && dataSet.hasNextWithoutConstraint()) {\n+        RowRecord curRecord = dataSet.nextWithoutConstraint();\n+        record = mergeRecords(curRecord, record);\n+      }\n+    }\n+\n+    // prepare final records\n+    // group by level\n+    // path -> count\n+    Map<String, Long> finalPaths = new TreeMap<String, Long>();\n+\n+    for (int j = 0; j < this.paths.size(); j++) {\n+      String[] tmpPath = this.paths.get(j).getFullPath().split(\"\\\\.\");\n+\n+      String key;\n+      if (tmpPath.length <= level) {\n+        key = this.paths.get(j).getFullPath();\n+      } else {\n+        StringBuilder path = new StringBuilder();\n+        for (int k = 0; k <= level; k++) {\n+          if (k == 0) {\n+            path.append(tmpPath[k]);\n+          } else {\n+            path.append(\".\" + tmpPath[k]);\n+          }\n+        }\n+        key = path.toString();\n+      }\n+      logger.debug(\"records \" + record.getFields().toString());\n+      finalPaths.put(key,\n+        record.getFields().get(j).getLongV()\n+          + finalPaths.getOrDefault(key, 0L));\n+    }\n+\n+    this.paths = Arrays.asList(new Path(COLUMN_COLUMN), new Path(COLUMN_COUNT));\n+    this.dataTypes = Arrays.asList(TSDataType.TEXT, TSDataType.TEXT);\n+\n+    for (Map.Entry<String, Long> entry : finalPaths.entrySet()) {\n+      RowRecord tmpRecord = new RowRecord(0);\n+      Field field = new Field(TSDataType.TEXT);\n+      field.setBinaryV(new Binary(entry.getKey()));\n+      logger.debug(\"rowRecord \" + entry.getKey());\n+      Field field1 = new Field(TSDataType.TEXT);\n+      field1.setBinaryV(new Binary(Long.toString(entry.getValue())));\n+      tmpRecord.addField(field);\n+      tmpRecord.addField(field1);\n+      records.add(tmpRecord);\n+      logger.info(tmpRecord.toString());\n+    }\n+  }\n+\n+  @Override\n+  protected boolean hasNextWithoutConstraint() throws IOException {\n+    return index < records.size();\n+  }\n+\n+  @Override\n+  protected RowRecord nextWithoutConstraint() {\n+    return records.get(index++);\n+  }\n+\n+  private void initGroupBy()\n+    throws QueryProcessException, StorageEngineException {\n+    // get all aggregation results, then we package them to one record\n+    for (int i = 0; i < paths.size(); i++) {\n+      Path path = paths.get(i);\n+      if (!pathExecutors.containsKey(path)) {\n+        //init GroupByExecutor\n+        pathExecutors.put(path,\n+          getGroupByExecutor(path, groupByPlan.getAllMeasurementsInDevice(path.getDevice()), dataTypes.get(i), this.context, null, null));\n+        resultIndexes.put(path, new ArrayList<>());\n+      } else {\n+        throw new QueryProcessException(\"duplicated path found, path:\" + path);\n+      }\n+      resultIndexes.get(path).add(i);\n+      AggregateResult aggrResult = AggregateResultFactory\n+        .getAggrResultByName(groupByPlan.getDeduplicatedAggregations().get(i), dataTypes.get(i));\n+      pathExecutors.get(path).addAggregateResult(aggrResult);\n+    }\n+  }\n+\n+  private GroupByExecutor getGroupByExecutor(Path path, Set<String> allSensors, TSDataType dataType,\n+                                             QueryContext context, Filter timeFilter, TsFileFilter fileFilter)\n+    throws StorageEngineException, QueryProcessException {\n+    return new LocalGroupByExecutor(path, allSensors, dataType, context, timeFilter, fileFilter);\n+  }\n+\n+  private RowRecord getRecordWithoutTimeInterval()\n+    throws IOException {\n+    RowRecord record = new RowRecord(0);\n+    AggregateResult[] fields = new AggregateResult[paths.size()];\n+\n+    try {\n+      for (Map.Entry<Path, GroupByExecutor> pathToExecutorEntry : pathExecutors.entrySet()) {\n+        GroupByExecutor executor = pathToExecutorEntry.getValue();\n+        List<AggregateResult> aggregations = executor.calcResult(Long.MIN_VALUE, Long.MAX_VALUE);\n+        for (int i = 0; i < aggregations.size(); i++) {\n+          int resultIndex = resultIndexes.get(pathToExecutorEntry.getKey()).get(i);\n+          fields[resultIndex] = aggregations.get(i);\n+        }\n+      }\n+    } catch (QueryProcessException e) {\n+      logger.error(\"GroupByWithoutValueFilterDataSet execute has error\", e);\n+      throw new IOException(e.getMessage(), e);\n+    }\n+\n+    for (AggregateResult res : fields) {\n+      if (res == null) {\n+        record.addField(null);\n+        continue;\n+      }\n+      record.addField(res.getResult(), res.getResultDataType());\n+    }\n+    return record;\n+  }\n+\n+  private RowRecord mergeRecords(RowRecord newRecord, RowRecord oldRecord) {\n+    if (oldRecord.getFields().isEmpty()) {\n+      oldRecord.setFields(newRecord.getFields());\n+    } else {\n+      assert oldRecord.getFields().size() == newRecord.getFields().size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MzQwMQ==", "bodyText": "ok, assert will help me found bug fastly. I can change it to error.", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r427053401", "createdAt": "2020-05-19T06:15:43Z", "author": {"login": "mychaow"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  private int level = -1;\n+  private boolean isByTime = false;\n+  protected long queryId;\n+  private GroupByEngineDataSet dataSet;\n+  private GroupByPlan groupByPlan;\n+  private QueryContext context;\n+\n+  private Map<Path, GroupByExecutor> pathExecutors = new HashMap<>();\n+  private Map<Path, List<Integer>> resultIndexes = new HashMap<>();\n+\n+  public GroupByLevelDataSet(QueryContext context, GroupByPlan plan, GroupByEngineDataSet dataSet)\n+    throws QueryProcessException, StorageEngineException, IOException {\n+    this.queryId = context.getQueryId();\n+    this.level = plan.getLevel();\n+    this.isByTime = plan.isByTime();\n+    this.dataSet = dataSet;\n+    this.paths = plan.getPaths();\n+    this.dataTypes = plan.getDataTypes();\n+    this.groupByPlan = plan;\n+    this.context = context;\n+\n+    logger.debug(\"paths \" + this.paths);\n+\n+    RowRecord record = new RowRecord(0);\n+    if (!isByTime) {\n+      initGroupBy();\n+      record = getRecordWithoutTimeInterval();\n+    } else {\n+      // get all records from GroupByDataSet, then we merge them to one record\n+      logger.debug(\"only group by level, paths:\" + groupByPlan.getPaths());\n+      while (dataSet != null && dataSet.hasNextWithoutConstraint()) {\n+        RowRecord curRecord = dataSet.nextWithoutConstraint();\n+        record = mergeRecords(curRecord, record);\n+      }\n+    }\n+\n+    // prepare final records\n+    // group by level\n+    // path -> count\n+    Map<String, Long> finalPaths = new TreeMap<String, Long>();\n+\n+    for (int j = 0; j < this.paths.size(); j++) {\n+      String[] tmpPath = this.paths.get(j).getFullPath().split(\"\\\\.\");\n+\n+      String key;\n+      if (tmpPath.length <= level) {\n+        key = this.paths.get(j).getFullPath();\n+      } else {\n+        StringBuilder path = new StringBuilder();\n+        for (int k = 0; k <= level; k++) {\n+          if (k == 0) {\n+            path.append(tmpPath[k]);\n+          } else {\n+            path.append(\".\" + tmpPath[k]);\n+          }\n+        }\n+        key = path.toString();\n+      }\n+      logger.debug(\"records \" + record.getFields().toString());\n+      finalPaths.put(key,\n+        record.getFields().get(j).getLongV()\n+          + finalPaths.getOrDefault(key, 0L));\n+    }\n+\n+    this.paths = Arrays.asList(new Path(COLUMN_COLUMN), new Path(COLUMN_COUNT));\n+    this.dataTypes = Arrays.asList(TSDataType.TEXT, TSDataType.TEXT);\n+\n+    for (Map.Entry<String, Long> entry : finalPaths.entrySet()) {\n+      RowRecord tmpRecord = new RowRecord(0);\n+      Field field = new Field(TSDataType.TEXT);\n+      field.setBinaryV(new Binary(entry.getKey()));\n+      logger.debug(\"rowRecord \" + entry.getKey());\n+      Field field1 = new Field(TSDataType.TEXT);\n+      field1.setBinaryV(new Binary(Long.toString(entry.getValue())));\n+      tmpRecord.addField(field);\n+      tmpRecord.addField(field1);\n+      records.add(tmpRecord);\n+      logger.info(tmpRecord.toString());\n+    }\n+  }\n+\n+  @Override\n+  protected boolean hasNextWithoutConstraint() throws IOException {\n+    return index < records.size();\n+  }\n+\n+  @Override\n+  protected RowRecord nextWithoutConstraint() {\n+    return records.get(index++);\n+  }\n+\n+  private void initGroupBy()\n+    throws QueryProcessException, StorageEngineException {\n+    // get all aggregation results, then we package them to one record\n+    for (int i = 0; i < paths.size(); i++) {\n+      Path path = paths.get(i);\n+      if (!pathExecutors.containsKey(path)) {\n+        //init GroupByExecutor\n+        pathExecutors.put(path,\n+          getGroupByExecutor(path, groupByPlan.getAllMeasurementsInDevice(path.getDevice()), dataTypes.get(i), this.context, null, null));\n+        resultIndexes.put(path, new ArrayList<>());\n+      } else {\n+        throw new QueryProcessException(\"duplicated path found, path:\" + path);\n+      }\n+      resultIndexes.get(path).add(i);\n+      AggregateResult aggrResult = AggregateResultFactory\n+        .getAggrResultByName(groupByPlan.getDeduplicatedAggregations().get(i), dataTypes.get(i));\n+      pathExecutors.get(path).addAggregateResult(aggrResult);\n+    }\n+  }\n+\n+  private GroupByExecutor getGroupByExecutor(Path path, Set<String> allSensors, TSDataType dataType,\n+                                             QueryContext context, Filter timeFilter, TsFileFilter fileFilter)\n+    throws StorageEngineException, QueryProcessException {\n+    return new LocalGroupByExecutor(path, allSensors, dataType, context, timeFilter, fileFilter);\n+  }\n+\n+  private RowRecord getRecordWithoutTimeInterval()\n+    throws IOException {\n+    RowRecord record = new RowRecord(0);\n+    AggregateResult[] fields = new AggregateResult[paths.size()];\n+\n+    try {\n+      for (Map.Entry<Path, GroupByExecutor> pathToExecutorEntry : pathExecutors.entrySet()) {\n+        GroupByExecutor executor = pathToExecutorEntry.getValue();\n+        List<AggregateResult> aggregations = executor.calcResult(Long.MIN_VALUE, Long.MAX_VALUE);\n+        for (int i = 0; i < aggregations.size(); i++) {\n+          int resultIndex = resultIndexes.get(pathToExecutorEntry.getKey()).get(i);\n+          fields[resultIndex] = aggregations.get(i);\n+        }\n+      }\n+    } catch (QueryProcessException e) {\n+      logger.error(\"GroupByWithoutValueFilterDataSet execute has error\", e);\n+      throw new IOException(e.getMessage(), e);\n+    }\n+\n+    for (AggregateResult res : fields) {\n+      if (res == null) {\n+        record.addField(null);\n+        continue;\n+      }\n+      record.addField(res.getResult(), res.getResultDataType());\n+    }\n+    return record;\n+  }\n+\n+  private RowRecord mergeRecords(RowRecord newRecord, RowRecord oldRecord) {\n+    if (oldRecord.getFields().isEmpty()) {\n+      oldRecord.setFields(newRecord.getFields());\n+    } else {\n+      assert oldRecord.getFields().size() == newRecord.getFields().size();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NjQwMA=="}, "originalCommit": {"oid": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1NjEyOA==", "bodyText": "And, I will maintain the User Guide docluments after merge.", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r427056128", "createdAt": "2020-05-19T06:22:53Z", "author": {"login": "mychaow"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  private int level = -1;\n+  private boolean isByTime = false;\n+  protected long queryId;\n+  private GroupByEngineDataSet dataSet;\n+  private GroupByPlan groupByPlan;\n+  private QueryContext context;\n+\n+  private Map<Path, GroupByExecutor> pathExecutors = new HashMap<>();\n+  private Map<Path, List<Integer>> resultIndexes = new HashMap<>();\n+\n+  public GroupByLevelDataSet(QueryContext context, GroupByPlan plan, GroupByEngineDataSet dataSet)\n+    throws QueryProcessException, StorageEngineException, IOException {\n+    this.queryId = context.getQueryId();\n+    this.level = plan.getLevel();\n+    this.isByTime = plan.isByTime();\n+    this.dataSet = dataSet;\n+    this.paths = plan.getPaths();\n+    this.dataTypes = plan.getDataTypes();\n+    this.groupByPlan = plan;\n+    this.context = context;\n+\n+    logger.debug(\"paths \" + this.paths);\n+\n+    RowRecord record = new RowRecord(0);\n+    if (!isByTime) {\n+      initGroupBy();\n+      record = getRecordWithoutTimeInterval();\n+    } else {\n+      // get all records from GroupByDataSet, then we merge them to one record\n+      logger.debug(\"only group by level, paths:\" + groupByPlan.getPaths());\n+      while (dataSet != null && dataSet.hasNextWithoutConstraint()) {\n+        RowRecord curRecord = dataSet.nextWithoutConstraint();\n+        record = mergeRecords(curRecord, record);\n+      }\n+    }\n+\n+    // prepare final records\n+    // group by level\n+    // path -> count\n+    Map<String, Long> finalPaths = new TreeMap<String, Long>();\n+\n+    for (int j = 0; j < this.paths.size(); j++) {\n+      String[] tmpPath = this.paths.get(j).getFullPath().split(\"\\\\.\");\n+\n+      String key;\n+      if (tmpPath.length <= level) {\n+        key = this.paths.get(j).getFullPath();\n+      } else {\n+        StringBuilder path = new StringBuilder();\n+        for (int k = 0; k <= level; k++) {\n+          if (k == 0) {\n+            path.append(tmpPath[k]);\n+          } else {\n+            path.append(\".\" + tmpPath[k]);\n+          }\n+        }\n+        key = path.toString();\n+      }\n+      logger.debug(\"records \" + record.getFields().toString());\n+      finalPaths.put(key,\n+        record.getFields().get(j).getLongV()\n+          + finalPaths.getOrDefault(key, 0L));\n+    }\n+\n+    this.paths = Arrays.asList(new Path(COLUMN_COLUMN), new Path(COLUMN_COUNT));\n+    this.dataTypes = Arrays.asList(TSDataType.TEXT, TSDataType.TEXT);\n+\n+    for (Map.Entry<String, Long> entry : finalPaths.entrySet()) {\n+      RowRecord tmpRecord = new RowRecord(0);\n+      Field field = new Field(TSDataType.TEXT);\n+      field.setBinaryV(new Binary(entry.getKey()));\n+      logger.debug(\"rowRecord \" + entry.getKey());\n+      Field field1 = new Field(TSDataType.TEXT);\n+      field1.setBinaryV(new Binary(Long.toString(entry.getValue())));\n+      tmpRecord.addField(field);\n+      tmpRecord.addField(field1);\n+      records.add(tmpRecord);\n+      logger.info(tmpRecord.toString());\n+    }\n+  }\n+\n+  @Override\n+  protected boolean hasNextWithoutConstraint() throws IOException {\n+    return index < records.size();\n+  }\n+\n+  @Override\n+  protected RowRecord nextWithoutConstraint() {\n+    return records.get(index++);\n+  }\n+\n+  private void initGroupBy()\n+    throws QueryProcessException, StorageEngineException {\n+    // get all aggregation results, then we package them to one record\n+    for (int i = 0; i < paths.size(); i++) {\n+      Path path = paths.get(i);\n+      if (!pathExecutors.containsKey(path)) {\n+        //init GroupByExecutor\n+        pathExecutors.put(path,\n+          getGroupByExecutor(path, groupByPlan.getAllMeasurementsInDevice(path.getDevice()), dataTypes.get(i), this.context, null, null));\n+        resultIndexes.put(path, new ArrayList<>());\n+      } else {\n+        throw new QueryProcessException(\"duplicated path found, path:\" + path);\n+      }\n+      resultIndexes.get(path).add(i);\n+      AggregateResult aggrResult = AggregateResultFactory\n+        .getAggrResultByName(groupByPlan.getDeduplicatedAggregations().get(i), dataTypes.get(i));\n+      pathExecutors.get(path).addAggregateResult(aggrResult);\n+    }\n+  }\n+\n+  private GroupByExecutor getGroupByExecutor(Path path, Set<String> allSensors, TSDataType dataType,\n+                                             QueryContext context, Filter timeFilter, TsFileFilter fileFilter)\n+    throws StorageEngineException, QueryProcessException {\n+    return new LocalGroupByExecutor(path, allSensors, dataType, context, timeFilter, fileFilter);\n+  }\n+\n+  private RowRecord getRecordWithoutTimeInterval()\n+    throws IOException {\n+    RowRecord record = new RowRecord(0);\n+    AggregateResult[] fields = new AggregateResult[paths.size()];\n+\n+    try {\n+      for (Map.Entry<Path, GroupByExecutor> pathToExecutorEntry : pathExecutors.entrySet()) {\n+        GroupByExecutor executor = pathToExecutorEntry.getValue();\n+        List<AggregateResult> aggregations = executor.calcResult(Long.MIN_VALUE, Long.MAX_VALUE);\n+        for (int i = 0; i < aggregations.size(); i++) {\n+          int resultIndex = resultIndexes.get(pathToExecutorEntry.getKey()).get(i);\n+          fields[resultIndex] = aggregations.get(i);\n+        }\n+      }\n+    } catch (QueryProcessException e) {\n+      logger.error(\"GroupByWithoutValueFilterDataSet execute has error\", e);\n+      throw new IOException(e.getMessage(), e);\n+    }\n+\n+    for (AggregateResult res : fields) {\n+      if (res == null) {\n+        record.addField(null);\n+        continue;\n+      }\n+      record.addField(res.getResult(), res.getResultDataType());\n+    }\n+    return record;\n+  }\n+\n+  private RowRecord mergeRecords(RowRecord newRecord, RowRecord oldRecord) {\n+    if (oldRecord.getFields().isEmpty()) {\n+      oldRecord.setFields(newRecord.getFields());\n+    } else {\n+      assert oldRecord.getFields().size() == newRecord.getFields().size();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NjQwMA=="}, "originalCommit": {"oid": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTM2MDE3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozODozOFrOGXN0ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozODozOFrOGXN0ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5Njg0Mg==", "bodyText": "since there is more than one group by, it's better to use full name.   GroupByLevel and GroupByTime", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426996842", "createdAt": "2020-05-19T02:38:38Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java", "diffHunk": "@@ -664,6 +668,7 @@ public void enterGroupByFillClause(SqlBaseParser.GroupByFillClauseContext ctx) {\n     super.enterGroupByFillClause(ctx);\n     queryOp.setGroupBy(true);\n     queryOp.setFill(true);\n+    queryOp.setGroupByTime(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTM3NTI5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjo0Nzo1NlrOGXN9qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjo0Nzo1NlrOGXN9qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTIwOQ==", "bodyText": "Replace this with an AggregationPlan", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r426999209", "createdAt": "2020-05-19T02:47:56Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  private int level = -1;\n+  private boolean isByTime = false;\n+  protected long queryId;\n+  private GroupByEngineDataSet dataSet;\n+  private GroupByPlan groupByPlan;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c18f4b65c8a4221c1fbf93f3c9fc3b9b458075a6"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NDg4MzMwOnYy", "diffSide": "RIGHT", "path": "docs/zh/UserGuide/5-Operation Manual/2-DML Data Manipulation Language.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwOTo1NDozM1rOGYEFBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwOTo1NDozM1rOGYEFBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg4NTgyOA==", "bodyText": "\u5e26\u65f6\u5e8f\u5206\u7ec4\u7684\u5206\u6bb5\u805a\u5408\u67e5\u8be2", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r427885828", "createdAt": "2020-05-20T09:54:33Z", "author": {"login": "qiaojialin"}, "path": "docs/zh/UserGuide/5-Operation Manual/2-DML Data Manipulation Language.md", "diffHunk": "@@ -295,6 +295,70 @@ SQL\u6267\u884c\u540e\u7684\u7ed3\u679c\u96c6\u5982\u4e0b\u6240\u793a\uff1a\n | 35     | 3                               |\n | 40     | 5                               |\n \n+### Down-Frequency Aggregate Query with Level Clause", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfc719dee08337eaffcb4a90ea950255ff25cc9f"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODA5OTE4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/GroupByFillTimePlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjowMjo1MlrOGYjw4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjowMjo1MlrOGYjw4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQwNDk2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class GroupByFillTimePlan extends GroupByTimePlan {\n          \n          \n            \n            public class GroupByTimeFillPlan extends GroupByTimePlan {", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r428404961", "createdAt": "2020-05-21T02:02:52Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/GroupByFillTimePlan.java", "diffHunk": "@@ -24,11 +24,11 @@\n \n import java.util.Map;\n \n-public class GroupByFillPlan extends GroupByPlan {\n+public class GroupByFillTimePlan extends GroupByTimePlan {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0103b4c72df9543419ae31f49929d54d623bfa3"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODEwNDA4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/crud/QueryOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjowNjowOFrOGYjz8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMjowNjowOFrOGYjz8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQwNTc0Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private boolean isGroupBy = false;\n          \n          \n            \n              private boolean isGroupByLevel = false;", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r428405746", "createdAt": "2020-05-21T02:06:08Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/crud/QueryOperator.java", "diffHunk": "@@ -42,6 +42,9 @@\n   private Map<TSDataType, IFill> fillTypes;\n   private boolean isFill = false;\n \n+  private boolean isGroupBy = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0103b4c72df9543419ae31f49929d54d623bfa3"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTExMzkzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwODoxOToxM1rOGZoNjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxMjoxOTo1NVrOGZpHKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyNjQxNA==", "bodyText": "The GroupByTimePlan extends AggregationPlan extends RawDataQueryPlan extends QueryPlan.\nThe paths in QueryPlan are not duplicated, here we should use plan.getDeduplicatedPath()\nBesides, please add some test for duplicated queries like\nselect count(s1), count(s1) from root.turbine1.d1 group by([1,10),2ms), level=2", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r429526414", "createdAt": "2020-05-23T08:19:13Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByTimePlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.db.utils.FilePathUtils;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  protected long queryId;\n+  private GroupByTimePlan groupByTimePlan;\n+  private QueryContext context;\n+\n+  private Map<Path, GroupByExecutor> pathExecutors = new HashMap<>();\n+  private Map<Path, List<Integer>> resultIndexes = new HashMap<>();\n+\n+  public GroupByLevelDataSet(QueryContext context, GroupByTimePlan plan, GroupByEngineDataSet dataSet)\n+    throws QueryProcessException, StorageEngineException, IOException {\n+    this.queryId = context.getQueryId();\n+    this.paths = plan.getPaths();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a1aafb4d7bb71538b9a874c833ef2a78fd734a7"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MTE2Mw==", "bodyText": "ok", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r429541163", "createdAt": "2020-05-23T12:19:55Z", "author": {"login": "mychaow"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByTimePlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.db.utils.FilePathUtils;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  protected long queryId;\n+  private GroupByTimePlan groupByTimePlan;\n+  private QueryContext context;\n+\n+  private Map<Path, GroupByExecutor> pathExecutors = new HashMap<>();\n+  private Map<Path, List<Integer>> resultIndexes = new HashMap<>();\n+\n+  public GroupByLevelDataSet(QueryContext context, GroupByTimePlan plan, GroupByEngineDataSet dataSet)\n+    throws QueryProcessException, StorageEngineException, IOException {\n+    this.queryId = context.getQueryId();\n+    this.paths = plan.getPaths();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyNjQxNA=="}, "originalCommit": {"oid": "9a1aafb4d7bb71538b9a874c833ef2a78fd734a7"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTEyNzcwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwODo0Nzo1MlrOGZoUbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwODo0Nzo1MlrOGZoUbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyODE3Mw==", "bodyText": "We need to maintain the time filter user, this implementation can not handle the following sql correctly\nselect count(*) from root where time < 5 group by level=2\nI suggest extending the AggregationExecutor to do this. It's more intuitive...", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r429528173", "createdAt": "2020-05-23T08:47:52Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByLevelDataSet.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByTimePlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.db.utils.FilePathUtils;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COLUMN;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_COUNT;\n+\n+public class GroupByLevelDataSet extends QueryDataSet {\n+\n+  private static final Logger logger = LoggerFactory\n+    .getLogger(GroupByLevelDataSet.class);\n+\n+  private List<RowRecord> records = new ArrayList<>();\n+  private int index = 0;\n+\n+  protected long queryId;\n+  private GroupByTimePlan groupByTimePlan;\n+  private QueryContext context;\n+\n+  private Map<Path, GroupByExecutor> pathExecutors = new HashMap<>();\n+  private Map<Path, List<Integer>> resultIndexes = new HashMap<>();\n+\n+  public GroupByLevelDataSet(QueryContext context, GroupByTimePlan plan, GroupByEngineDataSet dataSet)\n+    throws QueryProcessException, StorageEngineException, IOException {\n+    this.queryId = context.getQueryId();\n+    this.paths = plan.getPaths();\n+    this.dataTypes = plan.getDataTypes();\n+    this.groupByTimePlan = plan;\n+    this.context = context;\n+\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\"paths \" + this.paths + \" level:\" + plan.getLevel());\n+    }\n+\n+    Map<Integer, String> pathIndex = new HashMap<>();\n+    Map<String, Long> finalPaths = FilePathUtils.getPathByLevel(plan.getPaths(), plan.getLevel(), pathIndex);\n+\n+    if (!plan.isByTime()) {\n+      // does not has time interval,\n+      // so we could group by time interval [MIN_VALUE, MAX_VALUE] to get the total number\n+      initGroupByLevel();\n+      RowRecord record = mergeRecordByPath(getRecordWithoutTimeInterval(), finalPaths, pathIndex);\n+      if (record != null) {\n+        records.add(record);\n+      }\n+    } else {\n+      // get all records from GroupByDataSet, then we merge every record\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"only group by level, paths:\" + groupByTimePlan.getPaths());\n+      }\n+      while (dataSet != null && dataSet.hasNextWithoutConstraint()) {\n+        RowRecord curRecord = mergeRecordByPath(dataSet.nextWithoutConstraint(), finalPaths, pathIndex);\n+        if (curRecord != null) {\n+          records.add(curRecord);\n+        }\n+      }\n+    }\n+\n+    this.dataTypes = new ArrayList<>();\n+    this.paths = new ArrayList<>();\n+    for (int i = 0; i < finalPaths.size(); i++) {\n+      this.dataTypes.add(TSDataType.INT64);\n+    }\n+  }\n+\n+  @Override\n+  protected boolean hasNextWithoutConstraint() throws IOException {\n+    return index < records.size();\n+  }\n+\n+  @Override\n+  protected RowRecord nextWithoutConstraint() {\n+    return records.get(index++);\n+  }\n+\n+  private void initGroupByLevel()\n+    throws QueryProcessException, StorageEngineException {\n+    // get all aggregation results, then we package them to one record\n+    for (int i = 0; i < paths.size(); i++) {\n+      Path path = paths.get(i);\n+      if (!pathExecutors.containsKey(path)) {\n+        //init GroupByExecutor\n+        pathExecutors.put(path,\n+          getGroupByExecutor(path, groupByTimePlan.getAllMeasurementsInDevice(path.getDevice()), dataTypes.get(i), this.context, null, null));\n+        resultIndexes.put(path, new ArrayList<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a1aafb4d7bb71538b9a874c833ef2a78fd734a7"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDcxNzI1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/utils/FilePathUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDowMjoyN1rOGfoY-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDowMjoyN1rOGfoY-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyMDc5Mg==", "bodyText": "Hey, just like @qiaojialin said, you can reuse MetaUtils.getNodesName() method here~", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r435820792", "createdAt": "2020-06-05T10:02:27Z", "author": {"login": "Alima777"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/FilePathUtils.java", "diffHunk": "@@ -46,4 +54,82 @@ public static String regularizePath(String filePath){\n     return resource.getFile().getAbsolutePath().split(PATH_SPLIT_STRING);\n   }\n \n+  /**\n+   * get paths from group by level, like root.sg1.d2.s0, root.sg1.d1.s1\n+   * level=1, return [root.sg1, 0] and pathIndex turns to be [[0, root.sg1], [1, root.sg1]]\n+   * @param rawPaths\n+   * @param level\n+   * @param pathIndex\n+   * @return\n+   */\n+  public static Map<String, Long> getPathByLevel(List<Path> rawPaths, int level, Map<Integer, String> pathIndex) {\n+    // pathGroupByLevel -> count\n+    Map<String, Long> finalPaths = new TreeMap<>();\n+\n+    int i = 0;\n+    for (Path value : rawPaths) {\n+      String[] tmpPath = value.getFullPath().split(\"\\\\.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe790833a4927eb8877275b4fd6657eafc0d0290"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDc2NTIzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/QueryPlan.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDoxODo1MlrOGfo4AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDoxODo1MlrOGfo4AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODczNg==", "bodyText": "I think this level parameter shouldn't be inserted here in Queryplan which is the base class. Maybe groupByTimePlan or AggregationPlan is better.", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r435828736", "createdAt": "2020-06-05T10:18:52Z", "author": {"login": "Alima777"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/QueryPlan.java", "diffHunk": "@@ -36,6 +36,8 @@\n   private int rowLimit = 0;\n   private int rowOffset = 0;\n \n+  private int level = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe790833a4927eb8877275b4fd6657eafc0d0290"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDc4MTY2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDoyNDoyOFrOGfpCXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDoyNDoyOFrOGfpCXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgzMTM4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (plan.getOperatorType() == GROUPBYTIME) {\n          \n          \n            \n                    if (plan.getOperatorType() == OperatorType.GROUPBYTIME) {", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r435831388", "createdAt": "2020-06-05T10:24:28Z", "author": {"login": "Alima777"}, "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "diffHunk": "@@ -549,7 +540,7 @@ private TSExecuteStatementResp internalExecuteQueryStatement(String statement,\n         if (plan.getOperatorType() == OperatorType.FILL) {\n           throw new QueryProcessException(\"Fill doesn't support disable align clause.\");\n         }\n-        if (plan.getOperatorType() == OperatorType.GROUPBY) {\n+        if (plan.getOperatorType() == GROUPBYTIME) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe790833a4927eb8877275b4fd6657eafc0d0290"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzQxNjUwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByTimeDataSet.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwODowNTowM1rOGgCirQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwODowNTowM1rOGgCirQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0OTI2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class GroupByTimeDataSet extends QueryDataSet {\n          \n          \n            \n            // To process statement like, select count group by time interval, level = x\n          \n          \n            \n            public class GroupByTimeDataSet extends QueryDataSet {", "url": "https://github.com/apache/iotdb/pull/1204#discussion_r436249261", "createdAt": "2020-06-06T08:05:03Z", "author": {"login": "Alima777"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByTimeDataSet.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset.groupby;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.GroupByTimePlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.factory.AggregateResultFactory;\n+import org.apache.iotdb.db.query.filter.TsFileFilter;\n+import org.apache.iotdb.db.utils.FilePathUtils;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class GroupByTimeDataSet extends QueryDataSet {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9ff8cd7c8250f944cb0ad01b738578822e58028"}, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4988, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}