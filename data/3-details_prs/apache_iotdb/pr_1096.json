{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4NTcyNTE4", "number": 1096, "title": "[IOTDB-617] Support alter one time series's tag/attribute property", "bodyText": "Currently, we only support adding tag and attribute for one time series while creating it. We can't update it, drop it or add a new tag/attribute.\nSo, I want to add the alter syntax to improve the functionality of the tag management.\nI have supported the following five alter syntax:\nalter timeseries root.turbine.d1.s1 rename tag1 to newTag1\nalter timeseries root.turbine.d1.s1 set tag1=newV1\nalter timeseries root.turbine.d1.s1 drop tag1\nalter timeseries root.turbine.d1.s1 add TAG tag3=v3\nalter timeseries root.turbine.d1.s1 add ATTRIBUTE tag3=v3\n\n\nThe first one is used to change a tag/attribute key name.\nThe second one is used to change an existing tag/attribute's value, it will throw exception if the tag/attribute doesn't exist.\nThe third one is used to drop an existing tag/attribute if it exists.\nThe Fourth one is used to add a new tag, if it has existed, it will throw exception.\nThe fifth one is used to add a new attribute, if it has existed, it will throw exception.", "createdAt": "2020-04-24T14:07:30Z", "url": "https://github.com/apache/iotdb/pull/1096", "merged": true, "mergeCommit": {"oid": "8545fd7d958eaa6a1ff57f43a82bcf049a73d7b2"}, "closed": true, "closedAt": "2020-04-25T15:14:29Z", "author": {"login": "JackieTien97"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcayBTBgH2gAyNDA4NTcyNTE4OjNmNzY5MjI1MGJkMWE3NGQ3MmY1YWRiZWM5NTU5OWQxYzNiNzk2YTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcbHL5XAH2gAyNDA4NTcyNTE4OjAwN2RhNWQ1NzdlNTJmMTA1ZThhMGY1NWVhODVhYmJmYWRmYjhjNjI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3f7692250bd1a74d72f5adbec95599d1c3b796a9", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/3f7692250bd1a74d72f5adbec95599d1c3b796a9", "committedDate": "2020-04-24T14:04:47Z", "message": "alter tag"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da5a7d28b79749d9917c64b1a27071660a51f99d", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/da5a7d28b79749d9917c64b1a27071660a51f99d", "committedDate": "2020-04-25T03:53:00Z", "message": "changes to sonar"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/15963aa539b30d551726181c320fbdf02bca5241", "committedDate": "2020-04-25T03:56:54Z", "message": "resolve conflicts"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMzc1MTI4", "url": "https://github.com/apache/iotdb/pull/1096#pullrequestreview-400375128", "createdAt": "2020-04-25T09:08:50Z", "commit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "state": "APPROVED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOTowODo1MFrOGLy05w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOTozMDo1M1rOGLzDSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMDI2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static final String CHANGE_OFFSET = \"12\";\n          \n          \n            \n              public static final String SET_OFFSET = \"12\";", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415020263", "createdAt": "2020-04-25T09:08:50Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MetadataOperationType.java", "diffHunk": "@@ -29,4 +29,5 @@ private MetadataOperationType(){\n   public static final String SET_STORAGE_GROUP = \"2\";\n   public static final String SET_TTL = \"10\";\n   public static final String DELETE_STORAGE_GROUP = \"11\";\n+  public static final String CHANGE_OFFSET = \"12\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMTk2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n          \n          \n            \n              public void dropTagsOrAttributes(Set<String> keySet, String fullPath) throws MetadataException, IOException {", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415021968", "createdAt": "2020-04-25T09:18:31Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 603}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMjM5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            // tag key -> tag values", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415022393", "createdAt": "2020-04-25T09:21:06Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 617}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMjQzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  Map<String, String> deleteTag = new HashMap<>();\n          \n          \n            \n                  Map<String, String> deletedTags = new HashMap<>();", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415022437", "createdAt": "2020-04-25T09:21:18Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 618}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMjcyOQ==", "bodyText": "add javadoc\nremove the empty tag value and tag key", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415022729", "createdAt": "2020-04-25T09:23:13Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 637}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMjc4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void setTag(Map<String, String> alterMap, String fullPath)\n          \n          \n            \n              public void changeTagValue(Map<String, String> alterMap, String fullPath)", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415022780", "createdAt": "2020-04-25T09:23:41Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {\n+          tagIndex.get(key).remove(value);\n+          if (tagIndex.get(key).isEmpty()) {\n+            tagIndex.remove(key);\n+          }\n+        }\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setTag(Map<String, String> alterMap, String fullPath)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 649}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMjgzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  Map<String, String> beforeTagValue = new HashMap<>();\n          \n          \n            \n                  Map<String, String> oldTagValue = new HashMap<>();", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415022837", "createdAt": "2020-04-25T09:24:02Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {\n+          tagIndex.get(key).remove(value);\n+          if (tagIndex.get(key).isEmpty()) {\n+            tagIndex.remove(key);\n+          }\n+        }\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setTag(Map<String, String> alterMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      if (leafMNode.getOffset() < 0) {\n+        throw new MetadataException(\n+                String.format(\"TimeSeries [%s] does not have any tag/attribute.\", fullPath));\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+      Map<String, String> beforeTagValue = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 664}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMjg4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  Map<String, String> currentTagValue = new HashMap<>();\n          \n          \n            \n                  Map<String, String> newTagValue = new HashMap<>();", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415022885", "createdAt": "2020-04-25T09:24:15Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {\n+          tagIndex.get(key).remove(value);\n+          if (tagIndex.get(key).isEmpty()) {\n+            tagIndex.remove(key);\n+          }\n+        }\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setTag(Map<String, String> alterMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      if (leafMNode.getOffset() < 0) {\n+        throw new MetadataException(\n+                String.format(\"TimeSeries [%s] does not have any tag/attribute.\", fullPath));\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+      Map<String, String> beforeTagValue = new HashMap<>();\n+      Map<String, String> currentTagValue = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 665}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMzA4Mw==", "bodyText": "add some example...", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415023083", "createdAt": "2020-04-25T09:25:29Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {\n+          tagIndex.get(key).remove(value);\n+          if (tagIndex.get(key).isEmpty()) {\n+            tagIndex.remove(key);\n+          }\n+        }\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setTag(Map<String, String> alterMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      if (leafMNode.getOffset() < 0) {\n+        throw new MetadataException(\n+                String.format(\"TimeSeries [%s] does not have any tag/attribute.\", fullPath));\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+      Map<String, String> beforeTagValue = new HashMap<>();\n+      Map<String, String> currentTagValue = new HashMap<>();\n+      for (Entry<String, String> entry : alterMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // check tag map\n+        if (pair.left.containsKey(key)) {\n+          beforeTagValue.put(key, pair.left.get(key));\n+          currentTagValue.put(key, value);\n+          pair.left.put(key, value);\n+        } else if (pair.right.containsKey(key)) {\n+          // check attribute map\n+          pair.right.put(key, value);\n+        } else {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] does not have tag/attribute [%s].\", fullPath, key));\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : beforeTagValue.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 686}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMzExMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    tagIndex\n          \n          \n            \n                            .computeIfAbsent(key, k -> new HashMap<>())\n          \n          \n            \n                    tagIndex.computeIfAbsent(key, k -> new HashMap<>())", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415023113", "createdAt": "2020-04-25T09:25:53Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {\n+          tagIndex.get(key).remove(value);\n+          if (tagIndex.get(key).isEmpty()) {\n+            tagIndex.remove(key);\n+          }\n+        }\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setTag(Map<String, String> alterMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      if (leafMNode.getOffset() < 0) {\n+        throw new MetadataException(\n+                String.format(\"TimeSeries [%s] does not have any tag/attribute.\", fullPath));\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+      Map<String, String> beforeTagValue = new HashMap<>();\n+      Map<String, String> currentTagValue = new HashMap<>();\n+      for (Entry<String, String> entry : alterMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // check tag map\n+        if (pair.left.containsKey(key)) {\n+          beforeTagValue.put(key, pair.left.get(key));\n+          currentTagValue.put(key, value);\n+          pair.left.put(key, value);\n+        } else if (pair.right.containsKey(key)) {\n+          // check attribute map\n+          pair.right.put(key, value);\n+        } else {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] does not have tag/attribute [%s].\", fullPath, key));\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : beforeTagValue.entrySet()) {\n+        String key = entry.getKey();\n+        String beforeValue = entry.getValue();\n+        String currentValue = currentTagValue.get(key);\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(beforeValue).remove(leafMNode);\n+        tagIndex\n+                .computeIfAbsent(key, k -> new HashMap<>())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 693}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMzc5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String value = pair.left.remove(beforeName);\n          \n          \n            \n                    String oldTagvalue = pair.left.remove(beforeName);", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415023794", "createdAt": "2020-04-25T09:29:52Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {\n+          tagIndex.get(key).remove(value);\n+          if (tagIndex.get(key).isEmpty()) {\n+            tagIndex.remove(key);\n+          }\n+        }\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setTag(Map<String, String> alterMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      if (leafMNode.getOffset() < 0) {\n+        throw new MetadataException(\n+                String.format(\"TimeSeries [%s] does not have any tag/attribute.\", fullPath));\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+      Map<String, String> beforeTagValue = new HashMap<>();\n+      Map<String, String> currentTagValue = new HashMap<>();\n+      for (Entry<String, String> entry : alterMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // check tag map\n+        if (pair.left.containsKey(key)) {\n+          beforeTagValue.put(key, pair.left.get(key));\n+          currentTagValue.put(key, value);\n+          pair.left.put(key, value);\n+        } else if (pair.right.containsKey(key)) {\n+          // check attribute map\n+          pair.right.put(key, value);\n+        } else {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] does not have tag/attribute [%s].\", fullPath, key));\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : beforeTagValue.entrySet()) {\n+        String key = entry.getKey();\n+        String beforeValue = entry.getValue();\n+        String currentValue = currentTagValue.get(key);\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(beforeValue).remove(leafMNode);\n+        tagIndex\n+                .computeIfAbsent(key, k -> new HashMap<>())\n+                .computeIfAbsent(currentValue, k -> new HashSet<>())\n+                .add(leafMNode);\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void renameTag(String beforeName, String currentName, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      if (leafMNode.getOffset() < 0) {\n+        throw new MetadataException(\n+                String.format(\"TimeSeries [%s] does not have [%s] tag/attribute.\", fullPath, beforeName));\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      // current name has existed\n+      if (pair.left.containsKey(currentName) || pair.right.containsKey(currentName)) {\n+        throw new MetadataException(\n+                String.format(\n+                        \"TimeSeries [%s] already has a tag/attribute named [%s].\", fullPath, currentName));\n+      }\n+\n+      // check tag map\n+      if (pair.left.containsKey(beforeName)) {\n+        String value = pair.left.remove(beforeName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 727}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMzk0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void changeOffset(String path, long offset) throws IOException {\n          \n          \n            \n              public void setOffset(String path, long offset) throws IOException {", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415023944", "createdAt": "2020-04-25T09:30:53Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MLogWriter.java", "diffHunk": "@@ -115,6 +115,12 @@ public void setTTL(String storageGroup, long ttl) throws IOException {\n     writer.flush();\n   }\n \n+  public void changeOffset(String path, long offset) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15963aa539b30d551726181c320fbdf02bca5241"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d405613a98c80fd9c7fe5097d40bf4ab404efa7", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/5d405613a98c80fd9c7fe5097d40bf4ab404efa7", "committedDate": "2020-04-25T09:35:00Z", "message": "reformat code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b118f69052a5e2342b4e1131d610e1243e0ba0d", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/4b118f69052a5e2342b4e1131d610e1243e0ba0d", "committedDate": "2020-04-25T14:15:24Z", "message": "resolve conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b7842c7ea4b825904050d96c726016cc0dfd7b0", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/4b7842c7ea4b825904050d96c726016cc0dfd7b0", "committedDate": "2020-04-25T14:27:43Z", "message": "add javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "007da5d577e52f105e8a0f55ea85abbfadfb8c62", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/007da5d577e52f105e8a0f55ea85abbfadfb8c62", "committedDate": "2020-04-25T14:44:22Z", "message": "fix sonar"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2978, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}