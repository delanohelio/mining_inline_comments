{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyMDQ2OTMz", "number": 864, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQwMjozNjowM1rODkIUKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjo1MzoxMVrODkQWXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MjExNTYzOnYy", "diffSide": "LEFT", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReaderByTimestamp.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQwMjozNjowM1rOFwSNDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQwNzoyMzowM1rOFwVjKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE3NDIyMA==", "bodyText": "Why here delete this, if we can know from the chunk statistics that the chunk is not satisfied, we can just skip that chunk", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386174220", "createdAt": "2020-03-02T02:36:03Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReaderByTimestamp.java", "diffHunk": "@@ -63,24 +61,39 @@ public SeriesReaderByTimestamp(Path seriesPath, TSDataType dataType, QueryContex\n   }\n \n   private boolean hasNext(long timestamp) throws IOException {\n+\n+    /*\n+     * consume pages firstly\n+     */\n+    if (readPageData(timestamp)) {\n+      return true;\n+    }\n+\n+    /*\n+     * consume chunk secondly\n+     */\n     while (seriesReader.hasNextChunk()) {\n-      if (!satisfyTimeFilter(seriesReader.currentChunkStatistics())) {\n-        seriesReader.skipCurrentChunk();\n-        continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01144810075682d88b066e489f67371b87981024"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyOTAzNQ==", "bodyText": "I've made up for it", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386229035", "createdAt": "2020-03-02T07:23:03Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReaderByTimestamp.java", "diffHunk": "@@ -63,24 +61,39 @@ public SeriesReaderByTimestamp(Path seriesPath, TSDataType dataType, QueryContex\n   }\n \n   private boolean hasNext(long timestamp) throws IOException {\n+\n+    /*\n+     * consume pages firstly\n+     */\n+    if (readPageData(timestamp)) {\n+      return true;\n+    }\n+\n+    /*\n+     * consume chunk secondly\n+     */\n     while (seriesReader.hasNextChunk()) {\n-      if (!satisfyTimeFilter(seriesReader.currentChunkStatistics())) {\n-        seriesReader.skipCurrentChunk();\n-        continue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE3NDIyMA=="}, "originalCommit": {"oid": "01144810075682d88b066e489f67371b87981024"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MjE1MDk2OnYy", "diffSide": "LEFT", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQwMzowNzo1MVrOFwSioQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMTo1NToxNVrOFwc8gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE3OTc0NQ==", "bodyText": "It seems that if I keep calling hasNextChunk(), the firstChunkMetaData will move to next all the time.\nyou can add an if statement.\nif (firstChunkMetaData != null)\nreturn true;", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386179745", "createdAt": "2020-03-02T03:07:51Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReader.java", "diffHunk": "@@ -104,251 +130,274 @@ public SeriesReader(Path seriesPath, TSDataType dataType, QueryContext context,\n \n \n   public boolean hasNextChunk() throws IOException {\n-    if (hasCachedFirstChunkMetadata) {\n-      return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01144810075682d88b066e489f67371b87981024"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1MDIxMQ==", "bodyText": "fixed", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386350211", "createdAt": "2020-03-02T11:55:15Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReader.java", "diffHunk": "@@ -104,251 +130,274 @@ public SeriesReader(Path seriesPath, TSDataType dataType, QueryContext context,\n \n \n   public boolean hasNextChunk() throws IOException {\n-    if (hasCachedFirstChunkMetadata) {\n-      return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE3OTc0NQ=="}, "originalCommit": {"oid": "01144810075682d88b066e489f67371b87981024"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MjE4MjQwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQwMzozNToyMlrOFwS08g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMTo1NTo1NFrOFwc9mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE4NDQzNA==", "bodyText": "It's better name it GroupByTask", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386184434", "createdAt": "2020-03-02T03:35:22Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "diffHunk": "@@ -114,159 +105,202 @@ protected RowRecord nextWithoutConstraint() throws IOException {\n     }\n     hasCachedTimeInterval = false;\n     RowRecord record = new RowRecord(curStartTime);\n-    AggregateResult[] aggregateResultList = new AggregateResult[paths.size()];\n-    for (Map.Entry<Path, List<Integer>> entry : pathToAggrIndexesMap.entrySet()) {\n-      List<AggregateResult> aggregateResults;\n+    timeRange = new TimeRange(curStartTime, curEndTime - 1);\n+\n+    final AggregateResult[] fields = new AggregateResult[paths.size()];\n+    final List<Future> asyncResult = new ArrayList(pathExecutors.size());\n+\n+    for (Entry<Path, GroupByExecutor> executorEntry : pathExecutors.entrySet()) {\n+      asyncResult.add(QueryTaskPoolManager.getInstance().submit((Callable<?>) () -> {\n+        GroupByExecutor executor = executorEntry.getValue();\n+\n+        executor.resetAggregateResults();\n+        List<Pair<AggregateResult, Integer>> aggregations = executor.calcResult();\n+        for (int i = 0; i < aggregations.size(); i++) {\n+          fields[aggregations.get(i).right] = aggregations.get(i).left;\n+        }\n+        return null;\n+      }));\n+    }\n+    //waiting for data\n+    for (Future future : asyncResult) {\n       try {\n-        aggregateResults = nextIntervalAggregation(entry);\n-      } catch (QueryProcessException e) {\n+        future.get();\n+      } catch (Exception e) {\n+        logger.error(\"GroupByWithoutValueFilterDataSet execute has error,{}\", e);\n         throw new IOException(e);\n       }\n-      int index = 0;\n-      for (int i : entry.getValue()) {\n-        aggregateResultList[i] = aggregateResults.get(index);\n-        index++;\n-      }\n     }\n-    if (aggregateResultList.length == 0) {\n-      record.addField(new Field(null));\n-    } else {\n-      for (AggregateResult res : aggregateResultList) {\n-        record.addField(res.getResult(), res.getResultDataType());\n+\n+    for (AggregateResult res : fields) {\n+      if (res == null) {\n+        record.addField(new Field(null));\n+        continue;\n       }\n+      record.addField(res.getResult(), res.getResultDataType());\n     }\n     return record;\n   }\n \n-  /**\n-   * calculate the group by result of one series\n-   *\n-   * @param pathToAggrIndexes entry of path to aggregation indexes map\n-   */\n-  private List<AggregateResult> nextIntervalAggregation(Map.Entry<Path,\n-      List<Integer>> pathToAggrIndexes) throws IOException, QueryProcessException {\n-    List<AggregateResult> aggregateResultList = new ArrayList<>();\n-    List<Boolean> isCalculatedList = new ArrayList<>();\n-    List<Integer> indexList = pathToAggrIndexes.getValue();\n-\n-    int remainingToCalculate = indexList.size();\n-    TSDataType tsDataType = groupByPlan.getDeduplicatedDataTypes().get(indexList.get(0));\n-\n-    for (int index : indexList) {\n-      AggregateResult result = AggregateResultFactory\n-          .getAggrResultByName(groupByPlan.getDeduplicatedAggregations().get(index), tsDataType);\n-      aggregateResultList.add(result);\n-\n-      BatchData lastBatch = cachedBatchDataList.get(index);\n-\n-      calcBatchData(result, lastBatch);\n-      if (isEndCalc(result, lastBatch)) {\n-        isCalculatedList.add(true);\n-        remainingToCalculate--;\n-        if (remainingToCalculate == 0) {\n-          return aggregateResultList;\n+\n+  private class GroupByExecutor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a19dc1d55bf7898aad2e291541cb99f3f9475b"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyNzU0NA==", "bodyText": "no , i like executor", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386227544", "createdAt": "2020-03-02T07:18:00Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "diffHunk": "@@ -114,159 +105,202 @@ protected RowRecord nextWithoutConstraint() throws IOException {\n     }\n     hasCachedTimeInterval = false;\n     RowRecord record = new RowRecord(curStartTime);\n-    AggregateResult[] aggregateResultList = new AggregateResult[paths.size()];\n-    for (Map.Entry<Path, List<Integer>> entry : pathToAggrIndexesMap.entrySet()) {\n-      List<AggregateResult> aggregateResults;\n+    timeRange = new TimeRange(curStartTime, curEndTime - 1);\n+\n+    final AggregateResult[] fields = new AggregateResult[paths.size()];\n+    final List<Future> asyncResult = new ArrayList(pathExecutors.size());\n+\n+    for (Entry<Path, GroupByExecutor> executorEntry : pathExecutors.entrySet()) {\n+      asyncResult.add(QueryTaskPoolManager.getInstance().submit((Callable<?>) () -> {\n+        GroupByExecutor executor = executorEntry.getValue();\n+\n+        executor.resetAggregateResults();\n+        List<Pair<AggregateResult, Integer>> aggregations = executor.calcResult();\n+        for (int i = 0; i < aggregations.size(); i++) {\n+          fields[aggregations.get(i).right] = aggregations.get(i).left;\n+        }\n+        return null;\n+      }));\n+    }\n+    //waiting for data\n+    for (Future future : asyncResult) {\n       try {\n-        aggregateResults = nextIntervalAggregation(entry);\n-      } catch (QueryProcessException e) {\n+        future.get();\n+      } catch (Exception e) {\n+        logger.error(\"GroupByWithoutValueFilterDataSet execute has error,{}\", e);\n         throw new IOException(e);\n       }\n-      int index = 0;\n-      for (int i : entry.getValue()) {\n-        aggregateResultList[i] = aggregateResults.get(index);\n-        index++;\n-      }\n     }\n-    if (aggregateResultList.length == 0) {\n-      record.addField(new Field(null));\n-    } else {\n-      for (AggregateResult res : aggregateResultList) {\n-        record.addField(res.getResult(), res.getResultDataType());\n+\n+    for (AggregateResult res : fields) {\n+      if (res == null) {\n+        record.addField(new Field(null));\n+        continue;\n       }\n+      record.addField(res.getResult(), res.getResultDataType());\n     }\n     return record;\n   }\n \n-  /**\n-   * calculate the group by result of one series\n-   *\n-   * @param pathToAggrIndexes entry of path to aggregation indexes map\n-   */\n-  private List<AggregateResult> nextIntervalAggregation(Map.Entry<Path,\n-      List<Integer>> pathToAggrIndexes) throws IOException, QueryProcessException {\n-    List<AggregateResult> aggregateResultList = new ArrayList<>();\n-    List<Boolean> isCalculatedList = new ArrayList<>();\n-    List<Integer> indexList = pathToAggrIndexes.getValue();\n-\n-    int remainingToCalculate = indexList.size();\n-    TSDataType tsDataType = groupByPlan.getDeduplicatedDataTypes().get(indexList.get(0));\n-\n-    for (int index : indexList) {\n-      AggregateResult result = AggregateResultFactory\n-          .getAggrResultByName(groupByPlan.getDeduplicatedAggregations().get(index), tsDataType);\n-      aggregateResultList.add(result);\n-\n-      BatchData lastBatch = cachedBatchDataList.get(index);\n-\n-      calcBatchData(result, lastBatch);\n-      if (isEndCalc(result, lastBatch)) {\n-        isCalculatedList.add(true);\n-        remainingToCalculate--;\n-        if (remainingToCalculate == 0) {\n-          return aggregateResultList;\n+\n+  private class GroupByExecutor {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE4NDQzNA=="}, "originalCommit": {"oid": "d9a19dc1d55bf7898aad2e291541cb99f3f9475b"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1MDQ5MA==", "bodyText": "executor or task are all fine to me", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386350490", "createdAt": "2020-03-02T11:55:54Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "diffHunk": "@@ -114,159 +105,202 @@ protected RowRecord nextWithoutConstraint() throws IOException {\n     }\n     hasCachedTimeInterval = false;\n     RowRecord record = new RowRecord(curStartTime);\n-    AggregateResult[] aggregateResultList = new AggregateResult[paths.size()];\n-    for (Map.Entry<Path, List<Integer>> entry : pathToAggrIndexesMap.entrySet()) {\n-      List<AggregateResult> aggregateResults;\n+    timeRange = new TimeRange(curStartTime, curEndTime - 1);\n+\n+    final AggregateResult[] fields = new AggregateResult[paths.size()];\n+    final List<Future> asyncResult = new ArrayList(pathExecutors.size());\n+\n+    for (Entry<Path, GroupByExecutor> executorEntry : pathExecutors.entrySet()) {\n+      asyncResult.add(QueryTaskPoolManager.getInstance().submit((Callable<?>) () -> {\n+        GroupByExecutor executor = executorEntry.getValue();\n+\n+        executor.resetAggregateResults();\n+        List<Pair<AggregateResult, Integer>> aggregations = executor.calcResult();\n+        for (int i = 0; i < aggregations.size(); i++) {\n+          fields[aggregations.get(i).right] = aggregations.get(i).left;\n+        }\n+        return null;\n+      }));\n+    }\n+    //waiting for data\n+    for (Future future : asyncResult) {\n       try {\n-        aggregateResults = nextIntervalAggregation(entry);\n-      } catch (QueryProcessException e) {\n+        future.get();\n+      } catch (Exception e) {\n+        logger.error(\"GroupByWithoutValueFilterDataSet execute has error,{}\", e);\n         throw new IOException(e);\n       }\n-      int index = 0;\n-      for (int i : entry.getValue()) {\n-        aggregateResultList[i] = aggregateResults.get(index);\n-        index++;\n-      }\n     }\n-    if (aggregateResultList.length == 0) {\n-      record.addField(new Field(null));\n-    } else {\n-      for (AggregateResult res : aggregateResultList) {\n-        record.addField(res.getResult(), res.getResultDataType());\n+\n+    for (AggregateResult res : fields) {\n+      if (res == null) {\n+        record.addField(new Field(null));\n+        continue;\n       }\n+      record.addField(res.getResult(), res.getResultDataType());\n     }\n     return record;\n   }\n \n-  /**\n-   * calculate the group by result of one series\n-   *\n-   * @param pathToAggrIndexes entry of path to aggregation indexes map\n-   */\n-  private List<AggregateResult> nextIntervalAggregation(Map.Entry<Path,\n-      List<Integer>> pathToAggrIndexes) throws IOException, QueryProcessException {\n-    List<AggregateResult> aggregateResultList = new ArrayList<>();\n-    List<Boolean> isCalculatedList = new ArrayList<>();\n-    List<Integer> indexList = pathToAggrIndexes.getValue();\n-\n-    int remainingToCalculate = indexList.size();\n-    TSDataType tsDataType = groupByPlan.getDeduplicatedDataTypes().get(indexList.get(0));\n-\n-    for (int index : indexList) {\n-      AggregateResult result = AggregateResultFactory\n-          .getAggrResultByName(groupByPlan.getDeduplicatedAggregations().get(index), tsDataType);\n-      aggregateResultList.add(result);\n-\n-      BatchData lastBatch = cachedBatchDataList.get(index);\n-\n-      calcBatchData(result, lastBatch);\n-      if (isEndCalc(result, lastBatch)) {\n-        isCalculatedList.add(true);\n-        remainingToCalculate--;\n-        if (remainingToCalculate == 0) {\n-          return aggregateResultList;\n+\n+  private class GroupByExecutor {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE4NDQzNA=="}, "originalCommit": {"oid": "d9a19dc1d55bf7898aad2e291541cb99f3f9475b"}, "originalPosition": 207}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MjE5MDA0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQwMzo0MjoxMFrOFwS5aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQwNzoxNzoxM1rOFwVcrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE4NTU3Ng==", "bodyText": "No need to construct these two, if pathExecutors already has the path", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386185576", "createdAt": "2020-03-02T03:42:10Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "diffHunk": "@@ -64,45 +67,33 @@ public GroupByWithoutValueFilterDataSet(QueryContext context, GroupByPlan groupB\n       throws StorageEngineException {\n     super(context, groupByPlan);\n \n-    this.pathToAggrIndexesMap = new HashMap<>();\n-    this.aggregateReaders = new HashMap<>();\n-    this.cachedBatchDataList = new ArrayList<>();\n-    for (int i = 0; i < paths.size(); i++) {\n-      cachedBatchDataList.add(null);\n-    }\n     initGroupBy(context, groupByPlan);\n   }\n \n-  /**\n-   * init reader and aggregate function.\n-   */\n   private void initGroupBy(QueryContext context, GroupByPlan groupByPlan)\n       throws StorageEngineException {\n     IExpression expression = groupByPlan.getExpression();\n-    this.groupByPlan = groupByPlan;\n \n     Filter timeFilter = null;\n-    // init reader\n     if (expression != null) {\n       timeFilter = ((GlobalTimeExpression) expression).getFilter();\n     }\n \n     for (int i = 0; i < paths.size(); i++) {\n       Path path = paths.get(i);\n-      List<Integer> indexList = pathToAggrIndexesMap\n-          .computeIfAbsent(path, key -> new ArrayList<>());\n-      indexList.add(i);\n-      if (!aggregateReaders.containsKey(path)) {\n-\n-        QueryDataSource queryDataSource = QueryResourceManager.getInstance()\n-            .getQueryDataSource(path, context, timeFilter);\n-        // update filter by TTL\n-        timeFilter = queryDataSource.updateFilterUsingTTL(timeFilter);\n-\n-        IAggregateReader seriesReader = new SeriesAggregateReader(path, dataTypes.get(i), context,\n-            queryDataSource, timeFilter, null, null);\n-        aggregateReaders.put(path, seriesReader);\n-      }\n+\n+      QueryDataSource queryDataSource = QueryResourceManager.getInstance()\n+          .getQueryDataSource(path, context, timeFilter);\n+      // update filter by TTL\n+      timeFilter = queryDataSource.updateFilterUsingTTL(timeFilter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a19dc1d55bf7898aad2e291541cb99f3f9475b"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyNzM3Mw==", "bodyText": "done", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386227373", "createdAt": "2020-03-02T07:17:13Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "diffHunk": "@@ -64,45 +67,33 @@ public GroupByWithoutValueFilterDataSet(QueryContext context, GroupByPlan groupB\n       throws StorageEngineException {\n     super(context, groupByPlan);\n \n-    this.pathToAggrIndexesMap = new HashMap<>();\n-    this.aggregateReaders = new HashMap<>();\n-    this.cachedBatchDataList = new ArrayList<>();\n-    for (int i = 0; i < paths.size(); i++) {\n-      cachedBatchDataList.add(null);\n-    }\n     initGroupBy(context, groupByPlan);\n   }\n \n-  /**\n-   * init reader and aggregate function.\n-   */\n   private void initGroupBy(QueryContext context, GroupByPlan groupByPlan)\n       throws StorageEngineException {\n     IExpression expression = groupByPlan.getExpression();\n-    this.groupByPlan = groupByPlan;\n \n     Filter timeFilter = null;\n-    // init reader\n     if (expression != null) {\n       timeFilter = ((GlobalTimeExpression) expression).getFilter();\n     }\n \n     for (int i = 0; i < paths.size(); i++) {\n       Path path = paths.get(i);\n-      List<Integer> indexList = pathToAggrIndexesMap\n-          .computeIfAbsent(path, key -> new ArrayList<>());\n-      indexList.add(i);\n-      if (!aggregateReaders.containsKey(path)) {\n-\n-        QueryDataSource queryDataSource = QueryResourceManager.getInstance()\n-            .getQueryDataSource(path, context, timeFilter);\n-        // update filter by TTL\n-        timeFilter = queryDataSource.updateFilterUsingTTL(timeFilter);\n-\n-        IAggregateReader seriesReader = new SeriesAggregateReader(path, dataTypes.get(i), context,\n-            queryDataSource, timeFilter, null, null);\n-        aggregateReaders.put(path, seriesReader);\n-      }\n+\n+      QueryDataSource queryDataSource = QueryResourceManager.getInstance()\n+          .getQueryDataSource(path, context, timeFilter);\n+      // update filter by TTL\n+      timeFilter = queryDataSource.updateFilterUsingTTL(timeFilter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE4NTU3Ng=="}, "originalCommit": {"oid": "d9a19dc1d55bf7898aad2e291541cb99f3f9475b"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzIxNjUxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMTozNTowNFrOFwcbSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjo0OToxMlrOFweUJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MTcwNA==", "bodyText": "methods in this class could not be public", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386341704", "createdAt": "2020-03-02T11:35:04Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "diffHunk": "@@ -114,159 +97,194 @@ protected RowRecord nextWithoutConstraint() throws IOException {\n     }\n     hasCachedTimeInterval = false;\n     RowRecord record = new RowRecord(curStartTime);\n-    AggregateResult[] aggregateResultList = new AggregateResult[paths.size()];\n-    for (Map.Entry<Path, List<Integer>> entry : pathToAggrIndexesMap.entrySet()) {\n-      List<AggregateResult> aggregateResults;\n-      try {\n-        aggregateResults = nextIntervalAggregation(entry);\n-      } catch (QueryProcessException e) {\n-        throw new IOException(e);\n-      }\n-      int index = 0;\n-      for (int i : entry.getValue()) {\n-        aggregateResultList[i] = aggregateResults.get(index);\n-        index++;\n+    timeRange = new TimeRange(curStartTime, curEndTime - 1);\n+\n+    AggregateResult[] fields = new AggregateResult[paths.size()];\n+\n+    try {\n+      for (Entry<Path, GroupByExecutor> pathGroupByExecutorEntry : pathExecutors.entrySet()) {\n+        GroupByExecutor executor = pathGroupByExecutorEntry.getValue();\n+        executor.resetAggregateResults();\n+        List<Pair<AggregateResult, Integer>> aggregations = executor.calcResult();\n+        for (int i = 0; i < aggregations.size(); i++) {\n+          fields[aggregations.get(i).right] = aggregations.get(i).left;\n+        }\n       }\n+    } catch (QueryProcessException e) {\n+      logger.error(\"GroupByWithoutValueFilterDataSet execute has error,{}\", e);\n+      throw new IOException(e.getMessage(), e);\n     }\n-    if (aggregateResultList.length == 0) {\n-      record.addField(new Field(null));\n-    } else {\n-      for (AggregateResult res : aggregateResultList) {\n-        record.addField(res.getResult(), res.getResultDataType());\n+\n+    for (AggregateResult res : fields) {\n+      if (res == null) {\n+        record.addField(null);\n+        continue;\n       }\n+      record.addField(res.getResult(), res.getResultDataType());\n     }\n     return record;\n   }\n \n-  /**\n-   * calculate the group by result of one series\n-   *\n-   * @param pathToAggrIndexes entry of path to aggregation indexes map\n-   */\n-  private List<AggregateResult> nextIntervalAggregation(Map.Entry<Path,\n-      List<Integer>> pathToAggrIndexes) throws IOException, QueryProcessException {\n-    List<AggregateResult> aggregateResultList = new ArrayList<>();\n-    List<Boolean> isCalculatedList = new ArrayList<>();\n-    List<Integer> indexList = pathToAggrIndexes.getValue();\n-\n-    int remainingToCalculate = indexList.size();\n-    TSDataType tsDataType = groupByPlan.getDeduplicatedDataTypes().get(indexList.get(0));\n-\n-    for (int index : indexList) {\n-      AggregateResult result = AggregateResultFactory\n-          .getAggrResultByName(groupByPlan.getDeduplicatedAggregations().get(index), tsDataType);\n-      aggregateResultList.add(result);\n-\n-      BatchData lastBatch = cachedBatchDataList.get(index);\n-\n-      calcBatchData(result, lastBatch);\n-      if (isEndCalc(result, lastBatch)) {\n-        isCalculatedList.add(true);\n-        remainingToCalculate--;\n-        if (remainingToCalculate == 0) {\n-          return aggregateResultList;\n+  private class GroupByExecutor {\n+\n+    private IAggregateReader reader;\n+    private BatchData preCachedData;\n+    //<aggFunction - indexForRecord> of path\n+    private List<Pair<AggregateResult, Integer>> results = new ArrayList<>();\n+\n+    public GroupByExecutor(Path path, TSDataType dataType, QueryContext context, Filter timeFilter)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MjY0NA==", "bodyText": "fixed", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386372644", "createdAt": "2020-03-02T12:49:12Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "diffHunk": "@@ -114,159 +97,194 @@ protected RowRecord nextWithoutConstraint() throws IOException {\n     }\n     hasCachedTimeInterval = false;\n     RowRecord record = new RowRecord(curStartTime);\n-    AggregateResult[] aggregateResultList = new AggregateResult[paths.size()];\n-    for (Map.Entry<Path, List<Integer>> entry : pathToAggrIndexesMap.entrySet()) {\n-      List<AggregateResult> aggregateResults;\n-      try {\n-        aggregateResults = nextIntervalAggregation(entry);\n-      } catch (QueryProcessException e) {\n-        throw new IOException(e);\n-      }\n-      int index = 0;\n-      for (int i : entry.getValue()) {\n-        aggregateResultList[i] = aggregateResults.get(index);\n-        index++;\n+    timeRange = new TimeRange(curStartTime, curEndTime - 1);\n+\n+    AggregateResult[] fields = new AggregateResult[paths.size()];\n+\n+    try {\n+      for (Entry<Path, GroupByExecutor> pathGroupByExecutorEntry : pathExecutors.entrySet()) {\n+        GroupByExecutor executor = pathGroupByExecutorEntry.getValue();\n+        executor.resetAggregateResults();\n+        List<Pair<AggregateResult, Integer>> aggregations = executor.calcResult();\n+        for (int i = 0; i < aggregations.size(); i++) {\n+          fields[aggregations.get(i).right] = aggregations.get(i).left;\n+        }\n       }\n+    } catch (QueryProcessException e) {\n+      logger.error(\"GroupByWithoutValueFilterDataSet execute has error,{}\", e);\n+      throw new IOException(e.getMessage(), e);\n     }\n-    if (aggregateResultList.length == 0) {\n-      record.addField(new Field(null));\n-    } else {\n-      for (AggregateResult res : aggregateResultList) {\n-        record.addField(res.getResult(), res.getResultDataType());\n+\n+    for (AggregateResult res : fields) {\n+      if (res == null) {\n+        record.addField(null);\n+        continue;\n       }\n+      record.addField(res.getResult(), res.getResultDataType());\n     }\n     return record;\n   }\n \n-  /**\n-   * calculate the group by result of one series\n-   *\n-   * @param pathToAggrIndexes entry of path to aggregation indexes map\n-   */\n-  private List<AggregateResult> nextIntervalAggregation(Map.Entry<Path,\n-      List<Integer>> pathToAggrIndexes) throws IOException, QueryProcessException {\n-    List<AggregateResult> aggregateResultList = new ArrayList<>();\n-    List<Boolean> isCalculatedList = new ArrayList<>();\n-    List<Integer> indexList = pathToAggrIndexes.getValue();\n-\n-    int remainingToCalculate = indexList.size();\n-    TSDataType tsDataType = groupByPlan.getDeduplicatedDataTypes().get(indexList.get(0));\n-\n-    for (int index : indexList) {\n-      AggregateResult result = AggregateResultFactory\n-          .getAggrResultByName(groupByPlan.getDeduplicatedAggregations().get(index), tsDataType);\n-      aggregateResultList.add(result);\n-\n-      BatchData lastBatch = cachedBatchDataList.get(index);\n-\n-      calcBatchData(result, lastBatch);\n-      if (isEndCalc(result, lastBatch)) {\n-        isCalculatedList.add(true);\n-        remainingToCalculate--;\n-        if (remainingToCalculate == 0) {\n-          return aggregateResultList;\n+  private class GroupByExecutor {\n+\n+    private IAggregateReader reader;\n+    private BatchData preCachedData;\n+    //<aggFunction - indexForRecord> of path\n+    private List<Pair<AggregateResult, Integer>> results = new ArrayList<>();\n+\n+    public GroupByExecutor(Path path, TSDataType dataType, QueryContext context, Filter timeFilter)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MTcwNA=="}, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzIyMjQxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMTozNzoxMVrOFwceug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjo0NzowOFrOFweQiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MjU4Ng==", "bodyText": "This certainly initialize reader, but I think the comment should better be init GroupByExecutor", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386342586", "createdAt": "2020-03-02T11:37:11Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "diffHunk": "@@ -64,45 +63,29 @@ public GroupByWithoutValueFilterDataSet(QueryContext context, GroupByPlan groupB\n       throws StorageEngineException {\n     super(context, groupByPlan);\n \n-    this.pathToAggrIndexesMap = new HashMap<>();\n-    this.aggregateReaders = new HashMap<>();\n-    this.cachedBatchDataList = new ArrayList<>();\n-    for (int i = 0; i < paths.size(); i++) {\n-      cachedBatchDataList.add(null);\n-    }\n     initGroupBy(context, groupByPlan);\n   }\n \n-  /**\n-   * init reader and aggregate function.\n-   */\n   private void initGroupBy(QueryContext context, GroupByPlan groupByPlan)\n       throws StorageEngineException {\n     IExpression expression = groupByPlan.getExpression();\n-    this.groupByPlan = groupByPlan;\n \n     Filter timeFilter = null;\n-    // init reader\n     if (expression != null) {\n       timeFilter = ((GlobalTimeExpression) expression).getFilter();\n     }\n \n     for (int i = 0; i < paths.size(); i++) {\n       Path path = paths.get(i);\n-      List<Integer> indexList = pathToAggrIndexesMap\n-          .computeIfAbsent(path, key -> new ArrayList<>());\n-      indexList.add(i);\n-      if (!aggregateReaders.containsKey(path)) {\n-\n-        QueryDataSource queryDataSource = QueryResourceManager.getInstance()\n-            .getQueryDataSource(path, context, timeFilter);\n-        // update filter by TTL\n-        timeFilter = queryDataSource.updateFilterUsingTTL(timeFilter);\n-\n-        IAggregateReader seriesReader = new SeriesAggregateReader(path, dataTypes.get(i), context,\n-            queryDataSource, timeFilter, null, null);\n-        aggregateReaders.put(path, seriesReader);\n+      if (!pathExecutors.containsKey(path)) {\n+        //init reader", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MTcyMw==", "bodyText": "fixed", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386371723", "createdAt": "2020-03-02T12:47:08Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "diffHunk": "@@ -64,45 +63,29 @@ public GroupByWithoutValueFilterDataSet(QueryContext context, GroupByPlan groupB\n       throws StorageEngineException {\n     super(context, groupByPlan);\n \n-    this.pathToAggrIndexesMap = new HashMap<>();\n-    this.aggregateReaders = new HashMap<>();\n-    this.cachedBatchDataList = new ArrayList<>();\n-    for (int i = 0; i < paths.size(); i++) {\n-      cachedBatchDataList.add(null);\n-    }\n     initGroupBy(context, groupByPlan);\n   }\n \n-  /**\n-   * init reader and aggregate function.\n-   */\n   private void initGroupBy(QueryContext context, GroupByPlan groupByPlan)\n       throws StorageEngineException {\n     IExpression expression = groupByPlan.getExpression();\n-    this.groupByPlan = groupByPlan;\n \n     Filter timeFilter = null;\n-    // init reader\n     if (expression != null) {\n       timeFilter = ((GlobalTimeExpression) expression).getFilter();\n     }\n \n     for (int i = 0; i < paths.size(); i++) {\n       Path path = paths.get(i);\n-      List<Integer> indexList = pathToAggrIndexesMap\n-          .computeIfAbsent(path, key -> new ArrayList<>());\n-      indexList.add(i);\n-      if (!aggregateReaders.containsKey(path)) {\n-\n-        QueryDataSource queryDataSource = QueryResourceManager.getInstance()\n-            .getQueryDataSource(path, context, timeFilter);\n-        // update filter by TTL\n-        timeFilter = queryDataSource.updateFilterUsingTTL(timeFilter);\n-\n-        IAggregateReader seriesReader = new SeriesAggregateReader(path, dataTypes.get(i), context,\n-            queryDataSource, timeFilter, null, null);\n-        aggregateReaders.put(path, seriesReader);\n+      if (!pathExecutors.containsKey(path)) {\n+        //init reader", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MjU4Ng=="}, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzI2Njg3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMTo1MzoxN1rOFwc5WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjo0NTo0NFrOFweOKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0OTQwMQ==", "bodyText": "The template T of VersionPair is only used as IPageReader... I think it is not necessary to keep T. Instead, just use:\nprivate class VersionPair {\n\n    protected long version;\n    protected IPageReader pageReader;\n\n    public VersionPair(long version, IPageReader pageReader) {\n      this.version = version;\n      this.pageReader = pageReader;\n    }\n  }\n\nWhat do you think?", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386349401", "createdAt": "2020-03-02T11:53:17Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReader.java", "diffHunk": "@@ -55,26 +55,48 @@\n   private final Path seriesPath;\n   private final TSDataType dataType;\n   private final QueryContext context;\n+\n+  /*\n+   * There is at most one is not null between timeFilter and valueFilter\n+   *\n+   * timeFilter is pushed down to all pages (seq, unseq) without correctness problem\n+   *\n+   * valueFilter is pushed down to non-overlapped page only\n+   */\n   private final Filter timeFilter;\n   private final Filter valueFilter;\n \n+  /*\n+   * file cache\n+   */\n   private final List<TsFileResource> seqFileResource;\n   private final PriorityQueue<TsFileResource> unseqFileResource;\n \n+  /*\n+   * chunk cache\n+   */\n+  private ChunkMetaData firstChunkMetaData;\n   private final List<ChunkMetaData> seqChunkMetadatas = new LinkedList<>();\n   private final PriorityQueue<ChunkMetaData> unseqChunkMetadatas =\n       new PriorityQueue<>(Comparator.comparingLong(ChunkMetaData::getStartTime));\n \n-  private boolean hasCachedFirstChunkMetadata;\n-  private ChunkMetaData firstChunkMetaData;\n-\n-  private PriorityQueue<VersionPair<IPageReader>> overlappedPageReaders =\n+  /*\n+   * page cache\n+   */\n+  private VersionPair<IPageReader> firstPageReader;\n+  private PriorityQueue<VersionPair<IPageReader>> cachedPageReaders =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MTExNA==", "bodyText": "fixed", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386371114", "createdAt": "2020-03-02T12:45:44Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReader.java", "diffHunk": "@@ -55,26 +55,48 @@\n   private final Path seriesPath;\n   private final TSDataType dataType;\n   private final QueryContext context;\n+\n+  /*\n+   * There is at most one is not null between timeFilter and valueFilter\n+   *\n+   * timeFilter is pushed down to all pages (seq, unseq) without correctness problem\n+   *\n+   * valueFilter is pushed down to non-overlapped page only\n+   */\n   private final Filter timeFilter;\n   private final Filter valueFilter;\n \n+  /*\n+   * file cache\n+   */\n   private final List<TsFileResource> seqFileResource;\n   private final PriorityQueue<TsFileResource> unseqFileResource;\n \n+  /*\n+   * chunk cache\n+   */\n+  private ChunkMetaData firstChunkMetaData;\n   private final List<ChunkMetaData> seqChunkMetadatas = new LinkedList<>();\n   private final PriorityQueue<ChunkMetaData> unseqChunkMetadatas =\n       new PriorityQueue<>(Comparator.comparingLong(ChunkMetaData::getStartTime));\n \n-  private boolean hasCachedFirstChunkMetadata;\n-  private ChunkMetaData firstChunkMetaData;\n-\n-  private PriorityQueue<VersionPair<IPageReader>> overlappedPageReaders =\n+  /*\n+   * page cache\n+   */\n+  private VersionPair<IPageReader> firstPageReader;\n+  private PriorityQueue<VersionPair<IPageReader>> cachedPageReaders =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0OTQwMQ=="}, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzI3MDE1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMTo1NDoyM1rOFwc7NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjo0NTozN1rOFweN6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0OTg3Ng==", "bodyText": "The name is confusing... Rename the class VersionPair to VersionReaderPair? Or something like that.", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386349876", "createdAt": "2020-03-02T11:54:23Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReader.java", "diffHunk": "@@ -55,26 +55,48 @@\n   private final Path seriesPath;\n   private final TSDataType dataType;\n   private final QueryContext context;\n+\n+  /*\n+   * There is at most one is not null between timeFilter and valueFilter\n+   *\n+   * timeFilter is pushed down to all pages (seq, unseq) without correctness problem\n+   *\n+   * valueFilter is pushed down to non-overlapped page only\n+   */\n   private final Filter timeFilter;\n   private final Filter valueFilter;\n \n+  /*\n+   * file cache\n+   */\n   private final List<TsFileResource> seqFileResource;\n   private final PriorityQueue<TsFileResource> unseqFileResource;\n \n+  /*\n+   * chunk cache\n+   */\n+  private ChunkMetaData firstChunkMetaData;\n   private final List<ChunkMetaData> seqChunkMetadatas = new LinkedList<>();\n   private final PriorityQueue<ChunkMetaData> unseqChunkMetadatas =\n       new PriorityQueue<>(Comparator.comparingLong(ChunkMetaData::getStartTime));\n \n-  private boolean hasCachedFirstChunkMetadata;\n-  private ChunkMetaData firstChunkMetaData;\n-\n-  private PriorityQueue<VersionPair<IPageReader>> overlappedPageReaders =\n+  /*\n+   * page cache\n+   */\n+  private VersionPair<IPageReader> firstPageReader;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MTA1MQ==", "bodyText": "fixed", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386371051", "createdAt": "2020-03-02T12:45:37Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReader.java", "diffHunk": "@@ -55,26 +55,48 @@\n   private final Path seriesPath;\n   private final TSDataType dataType;\n   private final QueryContext context;\n+\n+  /*\n+   * There is at most one is not null between timeFilter and valueFilter\n+   *\n+   * timeFilter is pushed down to all pages (seq, unseq) without correctness problem\n+   *\n+   * valueFilter is pushed down to non-overlapped page only\n+   */\n   private final Filter timeFilter;\n   private final Filter valueFilter;\n \n+  /*\n+   * file cache\n+   */\n   private final List<TsFileResource> seqFileResource;\n   private final PriorityQueue<TsFileResource> unseqFileResource;\n \n+  /*\n+   * chunk cache\n+   */\n+  private ChunkMetaData firstChunkMetaData;\n   private final List<ChunkMetaData> seqChunkMetadatas = new LinkedList<>();\n   private final PriorityQueue<ChunkMetaData> unseqChunkMetadatas =\n       new PriorityQueue<>(Comparator.comparingLong(ChunkMetaData::getStartTime));\n \n-  private boolean hasCachedFirstChunkMetadata;\n-  private ChunkMetaData firstChunkMetaData;\n-\n-  private PriorityQueue<VersionPair<IPageReader>> overlappedPageReaders =\n+  /*\n+   * page cache\n+   */\n+  private VersionPair<IPageReader> firstPageReader;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0OTg3Ng=="}, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzI4MTYzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMTo1ODoyOVrOFwdB5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjo0NTozMlrOFweNxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1MTU4OA==", "bodyText": "Codes like this in the class obey Law of Demeter a lot. I suggest adding methods getStatistics() and  getAllSatisfiedPageData() in the inner class VersionPair", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386351588", "createdAt": "2020-03-02T11:58:29Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReader.java", "diffHunk": "@@ -104,251 +126,305 @@ public SeriesReader(Path seriesPath, TSDataType dataType, QueryContext context,\n \n \n   public boolean hasNextChunk() throws IOException {\n-    if (hasCachedFirstChunkMetadata) {\n+\n+    if (!cachedPageReaders.isEmpty() || firstPageReader != null || mergeReader\n+        .hasNextTimeValuePair()) {\n+      throw new IOException(\"all cached pages should be consumed first\");\n+    }\n+\n+    if (firstChunkMetaData != null) {\n       return true;\n     }\n+\n     // init first chunk metadata whose startTime is minimum\n-    tryToInitFirstChunk();\n+    tryToUnpackAllOverlappedFilesToChunkMetadatas();\n \n-    return hasCachedFirstChunkMetadata;\n+    return firstChunkMetaData != null;\n   }\n \n-  /**\n-   * Because seq data and unseq data intersect, the minimum startTime taken from two files at a time\n-   * is used as the reference time to start reading data\n-   */\n-  private void tryToInitFirstChunk() throws IOException {\n-    tryToFillChunkMetadatas();\n-    hasCachedFirstChunkMetadata = true;\n-    if (!seqChunkMetadatas.isEmpty() && unseqChunkMetadatas.isEmpty()) {\n-      // only has seq\n-      firstChunkMetaData = seqChunkMetadatas.remove(0);\n-    } else if (seqChunkMetadatas.isEmpty() && !unseqChunkMetadatas.isEmpty()) {\n-      // only has unseq\n-      firstChunkMetaData = unseqChunkMetadatas.poll();\n-    } else if (!seqChunkMetadatas.isEmpty()) {\n-      // has seq and unseq\n-      if (seqChunkMetadatas.get(0).getStartTime() <= unseqChunkMetadatas.peek().getStartTime()) {\n-        firstChunkMetaData = seqChunkMetadatas.remove(0);\n-      } else {\n-        firstChunkMetaData = unseqChunkMetadatas.poll();\n-      }\n-    } else {\n-      // no seq nor unseq\n-      hasCachedFirstChunkMetadata = false;\n-    }\n-    tryToFillChunkMetadatas();\n-  }\n \n   public boolean isChunkOverlapped() {\n     Statistics chunkStatistics = firstChunkMetaData.getStatistics();\n-    return mergeReader.hasNextTimeValuePair()\n-        || (!seqChunkMetadatas.isEmpty()\n-        && chunkStatistics.getEndTime() >= seqChunkMetadatas.get(0).getStartTime())\n-        || (!unseqChunkMetadatas.isEmpty()\n-        && chunkStatistics.getEndTime() >= unseqChunkMetadatas.peek().getStartTime());\n+    return !seqChunkMetadatas.isEmpty()\n+        && chunkStatistics.getEndTime() >= seqChunkMetadatas.get(0).getStartTime()\n+        || !unseqChunkMetadatas.isEmpty()\n+        && chunkStatistics.getEndTime() >= unseqChunkMetadatas.peek().getStartTime();\n   }\n \n   public Statistics currentChunkStatistics() {\n     return firstChunkMetaData.getStatistics();\n   }\n \n   public void skipCurrentChunk() {\n-    hasCachedFirstChunkMetadata = false;\n     firstChunkMetaData = null;\n   }\n \n   /**\n-   * This method should be called after hasNxtChunk\n-   * @return\n-   * @throws IOException\n+   * This method should be called after hasNextChunk() until no next page,\n+   * make sure that all overlapped pages are consumed\n    */\n   public boolean hasNextPage() throws IOException {\n-    if (!overlappedPageReaders.isEmpty()) {\n+\n+    /*\n+     * has overlapped data before\n+     */\n+    if (hasCachedNextOverlappedPage) {\n       return true;\n+    } else if (mergeReader.hasNextTimeValuePair()) {\n+      if (hasNextOverlappedPage()) {\n+        cachedBatchData = nextOverlappedPage();\n+        if (cachedBatchData != null && cachedBatchData.hasCurrent()) {\n+          hasCachedNextOverlappedPage = true;\n+          return true;\n+        }\n+      }\n     }\n \n-    fillOverlappedPageReaders();\n+    if (firstPageReader != null) {\n+      return true;\n+    }\n \n-    return !overlappedPageReaders.isEmpty();\n+    /*\n+     * construct first page reader\n+     */\n+    if (firstChunkMetaData != null) {\n+      /*\n+       * try to unpack all overlapped ChunkMetadata to cachedPageReaders\n+       */\n+      unpackAllOverlappedChunkMetadataToCachedPageReaders(firstChunkMetaData.getEndTime());\n+    } else {\n+      /*\n+       * first chunk metadata is already unpacked, consume cached pages\n+       */\n+      if (!cachedPageReaders.isEmpty()) {\n+        firstPageReader = cachedPageReaders.poll();\n+      }\n+    }\n+\n+    if (firstPageReader != null && !cachedPageReaders.isEmpty() &&\n+        firstPageReader.data.getStatistics().getEndTime() >=", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MTAxNA==", "bodyText": "fixed", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386371014", "createdAt": "2020-03-02T12:45:32Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReader.java", "diffHunk": "@@ -104,251 +126,305 @@ public SeriesReader(Path seriesPath, TSDataType dataType, QueryContext context,\n \n \n   public boolean hasNextChunk() throws IOException {\n-    if (hasCachedFirstChunkMetadata) {\n+\n+    if (!cachedPageReaders.isEmpty() || firstPageReader != null || mergeReader\n+        .hasNextTimeValuePair()) {\n+      throw new IOException(\"all cached pages should be consumed first\");\n+    }\n+\n+    if (firstChunkMetaData != null) {\n       return true;\n     }\n+\n     // init first chunk metadata whose startTime is minimum\n-    tryToInitFirstChunk();\n+    tryToUnpackAllOverlappedFilesToChunkMetadatas();\n \n-    return hasCachedFirstChunkMetadata;\n+    return firstChunkMetaData != null;\n   }\n \n-  /**\n-   * Because seq data and unseq data intersect, the minimum startTime taken from two files at a time\n-   * is used as the reference time to start reading data\n-   */\n-  private void tryToInitFirstChunk() throws IOException {\n-    tryToFillChunkMetadatas();\n-    hasCachedFirstChunkMetadata = true;\n-    if (!seqChunkMetadatas.isEmpty() && unseqChunkMetadatas.isEmpty()) {\n-      // only has seq\n-      firstChunkMetaData = seqChunkMetadatas.remove(0);\n-    } else if (seqChunkMetadatas.isEmpty() && !unseqChunkMetadatas.isEmpty()) {\n-      // only has unseq\n-      firstChunkMetaData = unseqChunkMetadatas.poll();\n-    } else if (!seqChunkMetadatas.isEmpty()) {\n-      // has seq and unseq\n-      if (seqChunkMetadatas.get(0).getStartTime() <= unseqChunkMetadatas.peek().getStartTime()) {\n-        firstChunkMetaData = seqChunkMetadatas.remove(0);\n-      } else {\n-        firstChunkMetaData = unseqChunkMetadatas.poll();\n-      }\n-    } else {\n-      // no seq nor unseq\n-      hasCachedFirstChunkMetadata = false;\n-    }\n-    tryToFillChunkMetadatas();\n-  }\n \n   public boolean isChunkOverlapped() {\n     Statistics chunkStatistics = firstChunkMetaData.getStatistics();\n-    return mergeReader.hasNextTimeValuePair()\n-        || (!seqChunkMetadatas.isEmpty()\n-        && chunkStatistics.getEndTime() >= seqChunkMetadatas.get(0).getStartTime())\n-        || (!unseqChunkMetadatas.isEmpty()\n-        && chunkStatistics.getEndTime() >= unseqChunkMetadatas.peek().getStartTime());\n+    return !seqChunkMetadatas.isEmpty()\n+        && chunkStatistics.getEndTime() >= seqChunkMetadatas.get(0).getStartTime()\n+        || !unseqChunkMetadatas.isEmpty()\n+        && chunkStatistics.getEndTime() >= unseqChunkMetadatas.peek().getStartTime();\n   }\n \n   public Statistics currentChunkStatistics() {\n     return firstChunkMetaData.getStatistics();\n   }\n \n   public void skipCurrentChunk() {\n-    hasCachedFirstChunkMetadata = false;\n     firstChunkMetaData = null;\n   }\n \n   /**\n-   * This method should be called after hasNxtChunk\n-   * @return\n-   * @throws IOException\n+   * This method should be called after hasNextChunk() until no next page,\n+   * make sure that all overlapped pages are consumed\n    */\n   public boolean hasNextPage() throws IOException {\n-    if (!overlappedPageReaders.isEmpty()) {\n+\n+    /*\n+     * has overlapped data before\n+     */\n+    if (hasCachedNextOverlappedPage) {\n       return true;\n+    } else if (mergeReader.hasNextTimeValuePair()) {\n+      if (hasNextOverlappedPage()) {\n+        cachedBatchData = nextOverlappedPage();\n+        if (cachedBatchData != null && cachedBatchData.hasCurrent()) {\n+          hasCachedNextOverlappedPage = true;\n+          return true;\n+        }\n+      }\n     }\n \n-    fillOverlappedPageReaders();\n+    if (firstPageReader != null) {\n+      return true;\n+    }\n \n-    return !overlappedPageReaders.isEmpty();\n+    /*\n+     * construct first page reader\n+     */\n+    if (firstChunkMetaData != null) {\n+      /*\n+       * try to unpack all overlapped ChunkMetadata to cachedPageReaders\n+       */\n+      unpackAllOverlappedChunkMetadataToCachedPageReaders(firstChunkMetaData.getEndTime());\n+    } else {\n+      /*\n+       * first chunk metadata is already unpacked, consume cached pages\n+       */\n+      if (!cachedPageReaders.isEmpty()) {\n+        firstPageReader = cachedPageReaders.poll();\n+      }\n+    }\n+\n+    if (firstPageReader != null && !cachedPageReaders.isEmpty() &&\n+        firstPageReader.data.getStatistics().getEndTime() >=", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1MTU4OA=="}, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzI4OTUwOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBCloseIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjowMTozMlrOFwdGnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjozNzo0MlrOFweAiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1Mjc5Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {\n          \n          \n            \n                  for (String sql : TestConstant.create_sql) {\n          \n      \n    \n    \n  \n\nAnd all the same appearance in this test class : )", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386352796", "createdAt": "2020-03-02T12:01:32Z", "author": {"login": "samperson1997"}, "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBCloseIT.java", "diffHunk": "@@ -85,7 +86,7 @@ private static void insertData()\n             .getConnection(Config.IOTDB_URL_PREFIX + \"127.0.0.1:6667/\", \"root\", \"root\");\n          Statement statement = connection.createStatement()) {\n \n-      for (String sql : Constant.create_sql) {\n+      for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2NzYyNA==", "bodyText": "fixed", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386367624", "createdAt": "2020-03-02T12:37:42Z", "author": {"login": "qiaojialin"}, "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBCloseIT.java", "diffHunk": "@@ -85,7 +86,7 @@ private static void insertData()\n             .getConnection(Config.IOTDB_URL_PREFIX + \"127.0.0.1:6667/\", \"root\", \"root\");\n          Statement statement = connection.createStatement()) {\n \n-      for (String sql : Constant.create_sql) {\n+      for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1Mjc5Ng=="}, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzI5MDMxOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBEngineTimeGeneratorIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjowMTo0OFrOFwdHFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjozNzozOFrOFweAaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1MjkxOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {\n          \n          \n            \n                  for (String sql : TestConstant.create_sql) {\n          \n      \n    \n    \n  \n\nAnd all the same appearance in this test class : )", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386352918", "createdAt": "2020-03-02T12:01:48Z", "author": {"login": "samperson1997"}, "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBEngineTimeGeneratorIT.java", "diffHunk": "@@ -100,7 +101,7 @@ private static void insertData() throws ClassNotFoundException, SQLException {\n         Statement statement = connection.createStatement()) {\n \n       // create storage group and measurement\n-      for (String sql : Constant.create_sql) {\n+      for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2NzU5Mw==", "bodyText": "fixed", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386367593", "createdAt": "2020-03-02T12:37:38Z", "author": {"login": "qiaojialin"}, "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBEngineTimeGeneratorIT.java", "diffHunk": "@@ -100,7 +101,7 @@ private static void insertData() throws ClassNotFoundException, SQLException {\n         Statement statement = connection.createStatement()) {\n \n       // create storage group and measurement\n-      for (String sql : Constant.create_sql) {\n+      for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1MjkxOA=="}, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzI5NjY3OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBLargeDataIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjowNDoyM1rOFwdLGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjozNzozM1rOFweATQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1Mzk0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {\n          \n          \n            \n                  for (String sql : TestConstant.create_sql) {\n          \n      \n    \n    \n  \n\nAnd all the same appearance in this test class : )", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386353947", "createdAt": "2020-03-02T12:04:23Z", "author": {"login": "samperson1997"}, "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBLargeDataIT.java", "diffHunk": "@@ -89,7 +90,7 @@ private static void insertData()\n         .getConnection(Config.IOTDB_URL_PREFIX + \"127.0.0.1:6667/\", \"root\", \"root\");\r\n         Statement statement = connection.createStatement()) {\r\n \r\n-      for (String sql : Constant.create_sql) {\r\n+      for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2NzU2NQ==", "bodyText": "fixed", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386367565", "createdAt": "2020-03-02T12:37:33Z", "author": {"login": "qiaojialin"}, "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBLargeDataIT.java", "diffHunk": "@@ -89,7 +90,7 @@ private static void insertData()\n         .getConnection(Config.IOTDB_URL_PREFIX + \"127.0.0.1:6667/\", \"root\", \"root\");\r\n         Statement statement = connection.createStatement()) {\r\n \r\n-      for (String sql : Constant.create_sql) {\r\n+      for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1Mzk0Nw=="}, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzI5Nzg0OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBMultiSeriesIT.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjowNDo1MVrOFwdL2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjozNzoyN1rOFweAHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1NDEzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static boolean testFlag = org.apache.iotdb.db.constant.TestConstant.testFlag;\n          \n          \n            \n              private static boolean testFlag = TestConstant.testFlag;\n          \n      \n    \n    \n  \n\nAnd all the same appearance in this test class : )", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386354138", "createdAt": "2020-03-02T12:04:51Z", "author": {"login": "samperson1997"}, "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBMultiSeriesIT.java", "diffHunk": "@@ -43,7 +44,7 @@\n  */\r\n public class IoTDBMultiSeriesIT {\r\n \r\n-  private static boolean testFlag = Constant.testFlag;\r\n+  private static boolean testFlag = org.apache.iotdb.db.constant.TestConstant.testFlag;\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1NTAzNQ==", "bodyText": "And also in other test classes...", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386355035", "createdAt": "2020-03-02T12:06:53Z", "author": {"login": "samperson1997"}, "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBMultiSeriesIT.java", "diffHunk": "@@ -43,7 +44,7 @@\n  */\r\n public class IoTDBMultiSeriesIT {\r\n \r\n-  private static boolean testFlag = Constant.testFlag;\r\n+  private static boolean testFlag = org.apache.iotdb.db.constant.TestConstant.testFlag;\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1NDEzOA=="}, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2NzUxNg==", "bodyText": "fixed", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386367516", "createdAt": "2020-03-02T12:37:27Z", "author": {"login": "qiaojialin"}, "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBMultiSeriesIT.java", "diffHunk": "@@ -43,7 +44,7 @@\n  */\r\n public class IoTDBMultiSeriesIT {\r\n \r\n-  private static boolean testFlag = Constant.testFlag;\r\n+  private static boolean testFlag = org.apache.iotdb.db.constant.TestConstant.testFlag;\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1NDEzOA=="}, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzM5NDM0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjo0MDoyOFrOFweFXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMzo1NzowOFrOFwgXgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2ODg2Mw==", "bodyText": "no need to use {},just\nlogger.error(\"GroupByWithoutValueFilterDataSet execute has error \", e);", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386368863", "createdAt": "2020-03-02T12:40:28Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "diffHunk": "@@ -114,159 +97,194 @@ protected RowRecord nextWithoutConstraint() throws IOException {\n     }\n     hasCachedTimeInterval = false;\n     RowRecord record = new RowRecord(curStartTime);\n-    AggregateResult[] aggregateResultList = new AggregateResult[paths.size()];\n-    for (Map.Entry<Path, List<Integer>> entry : pathToAggrIndexesMap.entrySet()) {\n-      List<AggregateResult> aggregateResults;\n-      try {\n-        aggregateResults = nextIntervalAggregation(entry);\n-      } catch (QueryProcessException e) {\n-        throw new IOException(e);\n-      }\n-      int index = 0;\n-      for (int i : entry.getValue()) {\n-        aggregateResultList[i] = aggregateResults.get(index);\n-        index++;\n+    timeRange = new TimeRange(curStartTime, curEndTime - 1);\n+\n+    AggregateResult[] fields = new AggregateResult[paths.size()];\n+\n+    try {\n+      for (Entry<Path, GroupByExecutor> pathGroupByExecutorEntry : pathExecutors.entrySet()) {\n+        GroupByExecutor executor = pathGroupByExecutorEntry.getValue();\n+        executor.resetAggregateResults();\n+        List<Pair<AggregateResult, Integer>> aggregations = executor.calcResult();\n+        for (int i = 0; i < aggregations.size(); i++) {\n+          fields[aggregations.get(i).right] = aggregations.get(i).left;\n+        }\n       }\n+    } catch (QueryProcessException e) {\n+      logger.error(\"GroupByWithoutValueFilterDataSet execute has error,{}\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQwNjI3NQ==", "bodyText": "fixed", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386406275", "createdAt": "2020-03-02T13:57:08Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "diffHunk": "@@ -114,159 +97,194 @@ protected RowRecord nextWithoutConstraint() throws IOException {\n     }\n     hasCachedTimeInterval = false;\n     RowRecord record = new RowRecord(curStartTime);\n-    AggregateResult[] aggregateResultList = new AggregateResult[paths.size()];\n-    for (Map.Entry<Path, List<Integer>> entry : pathToAggrIndexesMap.entrySet()) {\n-      List<AggregateResult> aggregateResults;\n-      try {\n-        aggregateResults = nextIntervalAggregation(entry);\n-      } catch (QueryProcessException e) {\n-        throw new IOException(e);\n-      }\n-      int index = 0;\n-      for (int i : entry.getValue()) {\n-        aggregateResultList[i] = aggregateResults.get(index);\n-        index++;\n+    timeRange = new TimeRange(curStartTime, curEndTime - 1);\n+\n+    AggregateResult[] fields = new AggregateResult[paths.size()];\n+\n+    try {\n+      for (Entry<Path, GroupByExecutor> pathGroupByExecutorEntry : pathExecutors.entrySet()) {\n+        GroupByExecutor executor = pathGroupByExecutorEntry.getValue();\n+        executor.resetAggregateResults();\n+        List<Pair<AggregateResult, Integer>> aggregations = executor.calcResult();\n+        for (int i = 0; i < aggregations.size(); i++) {\n+          fields[aggregations.get(i).right] = aggregations.get(i).left;\n+        }\n       }\n+    } catch (QueryProcessException e) {\n+      logger.error(\"GroupByWithoutValueFilterDataSet execute has error,{}\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2ODg2Mw=="}, "originalCommit": {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzQxOTc2OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBMultiStatementsIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjo0OToyNFrOFweUcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMzo1NjoyNlrOFwgV3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MjcyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {\n          \n          \n            \n                  for (String sql : TestConstant.create_sql) {", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386372722", "createdAt": "2020-03-02T12:49:24Z", "author": {"login": "JackieTien97"}, "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBMultiStatementsIT.java", "diffHunk": "@@ -85,7 +86,7 @@ private static void insertData()\n             .getConnection(Config.IOTDB_URL_PREFIX + \"127.0.0.1:6667/\", \"root\", \"root\");\n          Statement statement = connection.createStatement()) {\n \n-      for (String sql : Constant.create_sql) {\n+      for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5cf8b25bf191ef062e036a1efc9fe8821b33bd"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQwNTg1Mg==", "bodyText": "fixed", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386405852", "createdAt": "2020-03-02T13:56:26Z", "author": {"login": "qiaojialin"}, "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBMultiStatementsIT.java", "diffHunk": "@@ -85,7 +86,7 @@ private static void insertData()\n             .getConnection(Config.IOTDB_URL_PREFIX + \"127.0.0.1:6667/\", \"root\", \"root\");\n          Statement statement = connection.createStatement()) {\n \n-      for (String sql : Constant.create_sql) {\n+      for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MjcyMg=="}, "originalCommit": {"oid": "8f5cf8b25bf191ef062e036a1efc9fe8821b33bd"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzQyMTIwOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBMultiStatementsIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjo0OTo1NVrOFweVXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjo0OTo1NVrOFweVXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3Mjk1Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    builder.append(resultSet1.getString(org.apache.iotdb.db.constant.TestConstant.TIMESTAMP_STR))\n          \n          \n            \n                    builder.append(resultSet1.getString(TestConstant.TIMESTAMP_STR))", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386372956", "createdAt": "2020-03-02T12:49:55Z", "author": {"login": "JackieTien97"}, "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBMultiStatementsIT.java", "diffHunk": "@@ -138,7 +139,7 @@ public void selectAllTest() throws ClassNotFoundException {\n       int cnt1 = 0;\n       while (resultSet1.next() && cnt1 < 5) {\n         StringBuilder builder = new StringBuilder();\n-        builder.append(resultSet1.getString(Constant.TIMESTAMP_STR))\n+        builder.append(resultSet1.getString(org.apache.iotdb.db.constant.TestConstant.TIMESTAMP_STR))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5cf8b25bf191ef062e036a1efc9fe8821b33bd"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzQyMjAxOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBMultiStatementsIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjo1MDoxMVrOFweV2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjo1MDoxMVrOFweV2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MzA4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    builder.append(resultSet2.getString(org.apache.iotdb.db.constant.TestConstant.TIMESTAMP_STR))\n          \n          \n            \n                    builder.append(resultSet2.getString(TestConstant.TIMESTAMP_STR))", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386373081", "createdAt": "2020-03-02T12:50:11Z", "author": {"login": "JackieTien97"}, "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBMultiStatementsIT.java", "diffHunk": "@@ -154,7 +155,7 @@ public void selectAllTest() throws ClassNotFoundException {\n       int cnt2 = 0;\n       while (resultSet2.next()) {\n         StringBuilder builder = new StringBuilder();\n-        builder.append(resultSet2.getString(Constant.TIMESTAMP_STR))\n+        builder.append(resultSet2.getString(org.apache.iotdb.db.constant.TestConstant.TIMESTAMP_STR))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5cf8b25bf191ef062e036a1efc9fe8821b33bd"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzQzMTk3OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/tools/IoTDBWatermarkTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjo1MzoxMVrOFwebqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjo1MzoxMVrOFwebqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3NDU3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static String filePath1 = org.apache.iotdb.db.constant.TestConstant.BASE_OUTPUT_PATH.concat(\"watermarked_query_result.csv\");\n          \n          \n            \n              private static String filePath2 = org.apache.iotdb.db.constant.TestConstant.BASE_OUTPUT_PATH.concat(\"notWatermarked_query_result.csv\");\n          \n          \n            \n              private static String filePath1 = TestConstant.BASE_OUTPUT_PATH.concat(\"watermarked_query_result.csv\");\n          \n          \n            \n              private static String filePath2 = TestConstant.BASE_OUTPUT_PATH.concat(\"notWatermarked_query_result.csv\");", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386374571", "createdAt": "2020-03-02T12:53:11Z", "author": {"login": "JackieTien97"}, "path": "server/src/test/java/org/apache/iotdb/db/tools/IoTDBWatermarkTest.java", "diffHunk": "@@ -48,8 +45,8 @@\n  */\n public class IoTDBWatermarkTest {\n \n-  private static String filePath1 = TestConstant.BASE_OUTPUT_PATH.concat(\"watermarked_query_result.csv\");\n-  private static String filePath2 = TestConstant.BASE_OUTPUT_PATH.concat(\"notWatermarked_query_result.csv\");\n+  private static String filePath1 = org.apache.iotdb.db.constant.TestConstant.BASE_OUTPUT_PATH.concat(\"watermarked_query_result.csv\");\n+  private static String filePath2 = org.apache.iotdb.db.constant.TestConstant.BASE_OUTPUT_PATH.concat(\"notWatermarked_query_result.csv\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2843e8cd200311702bbdcce8ed7ca0919dae5e3c"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 260, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}