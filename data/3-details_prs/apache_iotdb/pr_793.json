{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0MDM2ODY5", "number": 793, "title": "[IOTDB-274] Refactor MManager", "bodyText": "Refactor codes of MManager\n\nRemove PTree, PropertyPlan and MGraph\nUnify the parameter of methods by using String path as the main parameter\nSimplify the caches in MManager\nRemove and refactor duplicated methods, and rename some functions\nRefactor metadata related exceptions\nRefactor MNode to a abstract class and add specific nodes\nMove MMTree related methods in PlanExecutor into MManager and make methods in MTree package-private\nAdd java doc", "createdAt": "2020-02-12T01:14:05Z", "url": "https://github.com/apache/iotdb/pull/793", "merged": true, "mergeCommit": {"oid": "1969b54dad5a804d2f0af021e913eddb96705192"}, "closed": true, "closedAt": "2020-02-23T10:07:19Z", "author": {"login": "samperson1997"}, "timelineItems": {"totalCount": 62, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcC6WeBAH2gAyMzc0MDM2ODY5OjE0ZTliNmNmNTUyNGEzZGJjYmY4ODI5ZWM4MDQzNjE0MTE2YmI4ODc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcHDsxNAH2gAyMzc0MDM2ODY5OmE0ZGZhMWFlZTJjODY5OTM2ODVkNzRjNjM5YTE1OGQxNTMyYWFmMWY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "14e9b6cf5524a3dbcbf8829ec8043614116bb887", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/14e9b6cf5524a3dbcbf8829ec8043614116bb887", "committedDate": "2020-02-10T10:12:58Z", "message": "Refactor metadata related exception"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cbca114807d1fef922e0ab97223aab7a6e7760cb", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/cbca114807d1fef922e0ab97223aab7a6e7760cb", "committedDate": "2020-02-10T12:00:00Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "991545cf37635061db046bbd57d3eb203a85fca6", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/991545cf37635061db046bbd57d3eb203a85fca6", "committedDate": "2020-02-10T15:03:06Z", "message": "Remove MGraph"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6de0c93c7907f28c87bb610271c29cab7920b59a", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/6de0c93c7907f28c87bb610271c29cab7920b59a", "committedDate": "2020-02-11T00:32:16Z", "message": "Fix IT tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5d8864174c3addf8453d0bbdcf6e5dca58fb695", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/b5d8864174c3addf8453d0bbdcf6e5dca58fb695", "committedDate": "2020-02-11T03:13:34Z", "message": "Remove PTree and PropertyPlan"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5edb054f69589d9c8ff3a9f968b52a7950a8cff", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/e5edb054f69589d9c8ff3a9f968b52a7950a8cff", "committedDate": "2020-02-11T12:03:24Z", "message": "Add java doc for MNode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6db29645b31c4b7d8a2ac7aea4168a47ecc1c692", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/6db29645b31c4b7d8a2ac7aea4168a47ecc1c692", "committedDate": "2020-02-12T01:12:47Z", "message": "Add java doc for MNode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62e757d1563d78c46df762657383be1568af70bb", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/62e757d1563d78c46df762657383be1568af70bb", "committedDate": "2020-02-12T04:18:46Z", "message": "Refactor all paths in `Path` to `String` in MManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43d0062f3a4a20568df969d8eeb8db497ad3110e", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/43d0062f3a4a20568df969d8eeb8db497ad3110e", "committedDate": "2020-02-12T06:33:27Z", "message": "Refactor some exception"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56147c00375a6d8ae75a7d573191ee593e4ded21", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/56147c00375a6d8ae75a7d573191ee593e4ded21", "committedDate": "2020-02-12T07:16:24Z", "message": "Delete duplicated with check methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25dc27840f8fd757786817521fb0d6cf2e8c85b4", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/25dc27840f8fd757786817521fb0d6cf2e8c85b4", "committedDate": "2020-02-12T07:44:14Z", "message": "Merge remote-tracking branch 'upstream/new_series_reader' into mmanager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fcae0caee6ed5773beb11d0e206d231d3153c69b", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/fcae0caee6ed5773beb11d0e206d231d3153c69b", "committedDate": "2020-02-12T12:40:55Z", "message": "Remove checkAndGetDataTypeCache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5deb23f6c7ee3aecc60d68c113eb5aea22202c29", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/5deb23f6c7ee3aecc60d68c113eb5aea22202c29", "committedDate": "2020-02-12T15:51:29Z", "message": "Rename some functions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea7574810d79300b3916d2420fc68c1da6f495de", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/ea7574810d79300b3916d2420fc68c1da6f495de", "committedDate": "2020-02-13T06:24:03Z", "message": "Rename and refactor some functions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2f242fda70fd95931f2a4b43fc5426f74510f07", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/f2f242fda70fd95931f2a4b43fc5426f74510f07", "committedDate": "2020-02-13T06:25:59Z", "message": "Reverse some format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17f30ea2c8a7509f08f63b9dd5ecc7cf710f5b31", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/17f30ea2c8a7509f08f63b9dd5ecc7cf710f5b31", "committedDate": "2020-02-13T13:39:06Z", "message": "Merge remote-tracking branch 'upstream/new_series_reader' into mmanager\n\n# Conflicts:\n#\tserver/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java\n#\tserver/src/main/java/org/apache/iotdb/db/qp/strategy/PhysicalGenerator.java\n#\tserver/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java\n#\tserver/src/test/java/org/apache/iotdb/db/qp/plan/PhysicalPlanTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b82629f5ebd58abb0df365c9c427ebbe3b26283", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/9b82629f5ebd58abb0df365c9c427ebbe3b26283", "committedDate": "2020-02-13T13:59:30Z", "message": "Merge with new_series_reader"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15149ceb182cd4c85a8823f395bba1d5ba156e58", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/15149ceb182cd4c85a8823f395bba1d5ba156e58", "committedDate": "2020-02-13T14:01:27Z", "message": "Merge with new_series_reader and rename some functions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68fb24d0458b723a8151364a62ec6f736862c2a7", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/68fb24d0458b723a8151364a62ec6f736862c2a7", "committedDate": "2020-02-14T03:49:05Z", "message": "Fix TTL test (according to new_cluster branch)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fb410006edf4cfd8c44264e9c3d4d81ee1a9142", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/9fb410006edf4cfd8c44264e9c3d4d81ee1a9142", "committedDate": "2020-02-14T06:40:47Z", "message": "Fix code smells"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NzQ4OTU1", "url": "https://github.com/apache/iotdb/pull/793#pullrequestreview-358748955", "createdAt": "2020-02-14T07:17:13Z", "commit": {"oid": "9fb410006edf4cfd8c44264e9c3d4d81ee1a9142"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNzoxNzoxM1rOFptbxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwODowNTo0NVrOFpuSxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MDMyNQ==", "bodyText": "what is Root not exist?  StorageGroup not exist?", "url": "https://github.com/apache/iotdb/pull/793#discussion_r379280325", "createdAt": "2020-02-14T07:17:13Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/exception/metadata/RootNotExistException.java", "diffHunk": "@@ -15,16 +15,16 @@\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n+ *\n  */\n \n-package org.apache.iotdb.db.exception.storageGroup;\n+package org.apache.iotdb.db.exception.metadata;\n \n-public class StorageGroupPathException extends StorageGroupException {\n+public class RootNotExistException extends MetadataException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb410006edf4cfd8c44264e9c3d4d81ee1a9142"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4NDMwNA==", "bodyText": "what is this field for?", "url": "https://github.com/apache/iotdb/pull/793#discussion_r379284304", "createdAt": "2020-02-14T07:31:19Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "diffHunk": "@@ -36,29 +36,47 @@\n \n   private static final long serialVersionUID = -770028375899514063L;\n \n-  // The name of the MNode\n+  /**\n+   * Name of the MNode\n+   */\n   private String name;\n-  // Whether current node is a leaf in the Metadata Tree\n+\n+  /**\n+   * Whether current node is a leaf in the Metadata Tree\n+   */\n   private boolean isLeaf;\n-  // Whether current node is Storage group in the Metadata Tree\n+\n+  /**\n+   * Whether current node is Storage group in the Metadata Tree\n+   */\n   private boolean isStorageGroup;\n-  // Map for the schema in this storage group\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n   private Map<String, MeasurementSchema> schemaMap;\n+\n   private Map<String, Integer> numSchemaMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb410006edf4cfd8c44264e9c3d4d81ee1a9142"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4ODc1OQ==", "bodyText": "Rename this class to ConcatOptimizerTest", "url": "https://github.com/apache/iotdb/pull/793#discussion_r379288759", "createdAt": "2020-02-14T07:47:05Z", "author": {"login": "qiaojialin"}, "path": "server/src/test/java/org/apache/iotdb/db/qp/plan/TestConcatOptimizer.java", "diffHunk": "@@ -52,7 +52,7 @@\n   public void before() throws MetadataException, PathException {\n     processor = new Planner();\n     MManager.getInstance().init();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb410006edf4cfd8c44264e9c3d4d81ee1a9142"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI5NDQwNg==", "bodyText": "I don't understant this method... This is not only a get function, it also changes the tree structure.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r379294406", "createdAt": "2020-02-14T08:05:45Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +52,127 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n+  /**\n+   * dummy node is used for the default param of traverse methods\n+   */\n+  private MNode dummyNode;\n \n   MTree(String rootName) {\n     this.root = new MNode(rootName, null, false);\n+    this.dummyNode = new MNode(\"dummy\", null, false);\n   }\n \n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n-   */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n+   * Add timeseries path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n+      throw new IllegalPathException(path);\n     }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+    MNode cur = getParent(nodeNames);\n+    String storageGroupName = cur.getStorageGroupName();\n \n     MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n     if (props != null && !props.isEmpty()) {\n       leaf.getSchema().setProps(props);\n     }\n-    leaf.setDataFileName(levelPath);\n+    leaf.setStorageGroupName(storageGroupName);\n     if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n+      throw new PathAlreadyExistException(cur.getFullPath());\n     }\n     cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n   /**\n-   * function for adding deviceId\n+   * Add device to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n+   *\n+   * @param deviceId device id\n    */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+  MNode addDevice(String deviceId) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(deviceId);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n+      throw new IllegalPathException(deviceId);\n     }\n-    MNode cur = getRoot();\n+    MNode cur = root;\n     for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n+      if (!cur.hasChildWithKey(nodeNames[i])) {\n         cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n       }\n       cur = cur.getChild(nodeNames[i]);\n     }\n     return cur;\n   }\n \n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n+  /**\n+   * Get nodes parent\n+   *\n+   * @param nodeNames node names\n+   */\n+  private MNode getParent(String[] nodeNames) throws MetadataException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb410006edf4cfd8c44264e9c3d4d81ee1a9142"}, "originalPosition": 128}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb48c8ecb2094c615e2d71c2157cc845ad5a34ce", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/bb48c8ecb2094c615e2d71c2157cc845ad5a34ce", "committedDate": "2020-02-14T12:45:25Z", "message": "Fix some code reviews"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7d12ae37476f832686c4e583da70f200f9adf45", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/d7d12ae37476f832686c4e583da70f200f9adf45", "committedDate": "2020-02-15T06:58:57Z", "message": "Refactor MNode to some specific nodes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e63aa2d9bf4d5221b0b3970dee45301621ca0151", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/e63aa2d9bf4d5221b0b3970dee45301621ca0151", "committedDate": "2020-02-15T08:15:44Z", "message": "Move MMTree related methods in PlanExecutor into MManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc267f1f22d02e9f67fa6f72739ecbe7a8d3c3c5", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/fc267f1f22d02e9f67fa6f72739ecbe7a8d3c3c5", "committedDate": "2020-02-15T12:41:23Z", "message": "Change MNode method to isNodeType"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f73c0bd04debaa5d6817f91d1f7ef611dcb96201", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/f73c0bd04debaa5d6817f91d1f7ef611dcb96201", "committedDate": "2020-02-15T13:47:18Z", "message": "Refactor of StorageEngine"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e0fffc53ec9d167e590a2cbe825e6b913f812be", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/5e0fffc53ec9d167e590a2cbe825e6b913f812be", "committedDate": "2020-02-15T14:22:14Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "481453b8ed95f1a30ca81ffa42490e9fc786acc6", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/481453b8ed95f1a30ca81ffa42490e9fc786acc6", "committedDate": "2020-02-15T15:17:09Z", "message": "Fix getChildren method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c8e29136522e34e8716fc706d892787b0a5e669", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/8c8e29136522e34e8716fc706d892787b0a5e669", "committedDate": "2020-02-17T02:43:49Z", "message": "Refactor deletePath and getAllPath"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8352b0f78144f50a7c01a83c606c83dfde45dd8c", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/8352b0f78144f50a7c01a83c606c83dfde45dd8c", "committedDate": "2020-02-18T02:23:27Z", "message": "Merge remote-tracking branch 'upstream/new_series_reader' into mmanager\n\n# Conflicts:\n#\tserver/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java\n#\tserver/src/main/java/org/apache/iotdb/db/qp/strategy/PhysicalGenerator.java\n#\tserver/src/main/java/org/apache/iotdb/db/query/timegenerator/EngineNodeConstructor.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/00a4cadcc9957c8226ae6e45931d3575d62d6884", "committedDate": "2020-02-18T03:05:59Z", "message": "Solve conflict"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMDQ2OTE2", "url": "https://github.com/apache/iotdb/pull/793#pullrequestreview-360046916", "createdAt": "2020-02-18T03:05:11Z", "commit": {"oid": "8c8e29136522e34e8716fc706d892787b0a5e669"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwMzowNToxMVrOFqz4gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOTozMjo1OFrOFq7H5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQzNDU2Mg==", "bodyText": "cache path.split to avoid splitting twice", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380434562", "createdAt": "2020-02-18T03:05:11Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MetaUtils.java", "diffHunk": "@@ -18,27 +18,33 @@\n  */\n package org.apache.iotdb.db.metadata;\n \n-public class MetaUtils {\n-  public static String[] getNodeNames(String path, String separator) {\n+import static org.apache.iotdb.db.conf.IoTDBConstant.PATH_WILDCARD;\n+\n+class MetaUtils {\n+\n+  private static final String PATH_SEPARATOR = \"\\\\.\";\n+\n+  private MetaUtils() {\n+\n+  }\n+\n+  static String[] getNodeNames(String path) {\n     String[] nodeNames;\n-    path = path.trim();\n     if (path.contains(\"\\\"\") || path.contains(\"\\'\")) {\n-      String[] deviceAndMeasurement;\n-      if (path.contains(\"\\\"\")) {\n-        deviceAndMeasurement = path.split(\"\\\"\");\n-      } else {\n-        deviceAndMeasurement = path.split(\"\\'\");\n-      }\n-      String device = deviceAndMeasurement[0];\n-      String measurement = deviceAndMeasurement[1];\n-      String[] deviceNodeName = device.split(separator);\n+      path = path.trim().replace(\"\\'\", \"\\\"\");\n+      String measurement = path.split(\"\\\"\")[1];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c8e29136522e34e8716fc706d892787b0a5e669"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ4OTYzMA==", "bodyText": "use a StorageGroupMNode, move this method into it", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380489630", "createdAt": "2020-02-18T07:04:37Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;\n+\n+  /**\n+   * Column's Schema for one timeseries represented by current node if current node is one leaf\n+   */\n+  MeasurementSchema schema;\n+\n+  Map<String, MNode> children;\n+\n+  MNodeType nodeType;\n+\n+  /**\n+   * when the data in a storage group is older than dataTTL, it is considered invalid and will be\n+   * eventually removed. only set at storage group level.\n+   */\n+  private long dataTTL = Long.MAX_VALUE;\n+\n+  /**\n+   * Constructor of MNode.\n+   */\n+  public MNode(String name, MNode parent) {\n+    this.setName(name);\n+    this.parent = parent;\n+  }\n+\n+  abstract public boolean isNodeType(MNodeType nodeType);\n+\n+  /**\n+   * Set storage group\n+   */\n+  public void setStorageGroup() {\n+    nodeType = MNodeType.STORAGE_GROUP_MNODE;\n+    schemaMap = new HashMap<>();\n+  }\n+\n+  public Map<String, MeasurementSchema> getSchemaMap() {\n+    return schemaMap;\n+  }\n+\n+  /**\n+   * check whether the MNode has children\n+   */\n+  abstract public boolean hasChildren();\n+\n+  /**\n+   * check whether the MNode has child with the given key\n+   *\n+   * @param key key\n+   */\n+  abstract public boolean hasChildWithKey(String key);\n+\n+  /**\n+   * add the given key to given child MNode\n+   *\n+   * @param key key\n+   * @param child child MNode\n+   */\n+  abstract public void addChild(String key, MNode child);\n+\n+  /**\n+   * delete key from given child MNode\n+   *\n+   * @param key key\n+   */\n+  abstract public void deleteChild(String key);\n+\n+  /**\n+   * get the child MNode under the given key.\n+   *\n+   * @param key key\n+   */\n+  abstract public MNode getChild(String key);\n+\n+  /**\n+   * get the count of all leaves whose ancestor is current node\n+   */\n+  abstract public int getLeafCount();\n+\n+  /**\n+   * get full path\n+   */\n+  public String getFullPath() {\n+    if (fullPath != null) {\n+      return fullPath;\n+    }\n+    StringBuilder builder = new StringBuilder(name);\n+    MNode curr = this;\n+    while (curr.parent != null) {\n+      curr = curr.parent;\n+      builder.insert(0, IoTDBConstant.PATH_SEPARATOR).insert(0, curr.name);\n+    }\n+    return fullPath = builder.toString();\n+  }\n+\n+  public String getStorageGroupName() {\n+    return storageGroupName;\n+  }\n+\n+  public void setStorageGroupName(String storageGroupName) {\n+    this.storageGroupName = storageGroupName;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return this.getName();\n+  }\n+\n+  public MeasurementSchema getSchema() {\n+    return schema;\n+  }\n+\n+  public MNode getParent() {\n+    return parent;\n+  }\n+\n+  abstract public Map<String, MNode> getChildren();\n+\n+  public String getName() {\n+    return name;\n+  }\n+\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public long getDataTTL() {\n+    return dataTTL;\n+  }\n+\n+  public void setDataTTL(long dataTTL) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ4OTY5OA==", "bodyText": "add props map", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380489698", "createdAt": "2020-02-18T07:04:56Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public class LeafMNode extends MNode {\n+\n+  private static final long serialVersionUID = -1199657856921206435L;\n+\n+  public LeafMNode(String name, MNode parent) {\n+    super(name, parent);\n+  }\n+\n+  public LeafMNode(String name, MNode parent, TSDataType dataType, TSEncoding encoding,\n+      CompressionType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwMTY3OA==", "bodyText": "if we use Class type to distinguish the types, this method could be removed", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380501678", "createdAt": "2020-02-18T07:43:35Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;\n+\n+  /**\n+   * Column's Schema for one timeseries represented by current node if current node is one leaf\n+   */\n+  MeasurementSchema schema;\n+\n+  Map<String, MNode> children;\n+\n+  MNodeType nodeType;\n+\n+  /**\n+   * when the data in a storage group is older than dataTTL, it is considered invalid and will be\n+   * eventually removed. only set at storage group level.\n+   */\n+  private long dataTTL = Long.MAX_VALUE;\n+\n+  /**\n+   * Constructor of MNode.\n+   */\n+  public MNode(String name, MNode parent) {\n+    this.setName(name);\n+    this.parent = parent;\n+  }\n+\n+  abstract public boolean isNodeType(MNodeType nodeType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwMTg1MA==", "bodyText": "the nodeType could be retained, add a getter", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380501850", "createdAt": "2020-02-18T07:44:04Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;\n+\n+  /**\n+   * Column's Schema for one timeseries represented by current node if current node is one leaf\n+   */\n+  MeasurementSchema schema;\n+\n+  Map<String, MNode> children;\n+\n+  MNodeType nodeType;\n+\n+  /**\n+   * when the data in a storage group is older than dataTTL, it is considered invalid and will be\n+   * eventually removed. only set at storage group level.\n+   */\n+  private long dataTTL = Long.MAX_VALUE;\n+\n+  /**\n+   * Constructor of MNode.\n+   */\n+  public MNode(String name, MNode parent) {\n+    this.setName(name);\n+    this.parent = parent;\n+  }\n+\n+  abstract public boolean isNodeType(MNodeType nodeType);\n+\n+  /**\n+   * Set storage group\n+   */\n+  public void setStorageGroup() {\n+    nodeType = MNodeType.STORAGE_GROUP_MNODE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwMzg4OA==", "bodyText": "move this to StorageGroupMNode", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380503888", "createdAt": "2020-02-18T07:49:34Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;\n+\n+  /**\n+   * Column's Schema for one timeseries represented by current node if current node is one leaf\n+   */\n+  MeasurementSchema schema;\n+\n+  Map<String, MNode> children;\n+\n+  MNodeType nodeType;\n+\n+  /**\n+   * when the data in a storage group is older than dataTTL, it is considered invalid and will be\n+   * eventually removed. only set at storage group level.\n+   */\n+  private long dataTTL = Long.MAX_VALUE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwMzk0Mw==", "bodyText": "move this to LeafNode", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380503943", "createdAt": "2020-02-18T07:49:43Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;\n+\n+  /**\n+   * Column's Schema for one timeseries represented by current node if current node is one leaf\n+   */\n+  MeasurementSchema schema;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwNDc4OQ==", "bodyText": "move this to LeafNode. I wonder if this will occupy much memory.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380504789", "createdAt": "2020-02-18T07:51:43Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwNTEyNg==", "bodyText": "move this to StorageGroupMNode", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380505126", "createdAt": "2020-02-18T07:52:42Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNDcwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param key key\n          \n          \n            \n               * @param key the queried child name", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380534706", "createdAt": "2020-02-18T09:00:09Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public class InternalMNode extends MNode {\n+\n+  private static final long serialVersionUID = 7999036474525817732L;\n+\n+  public InternalMNode(String name, MNode parent) {\n+    super(name, parent);\n+    this.nodeType = MNodeType.INTERNAL_MNODE;\n+    this.children = new LinkedHashMap<>();\n+  }\n+\n+  @Override\n+  public boolean isNodeType(MNodeType nodeType) {\n+    return this.nodeType.equals(nodeType);\n+  }\n+\n+  /**\n+   * check whether the MNode has children\n+   */\n+  @Override\n+  public boolean hasChildren() {\n+    return true;\n+  }\n+\n+  /**\n+   * check whether the MNode has child with the given key\n+   *\n+   * @param key key\n+   */\n+  @Override\n+  public boolean hasChildWithKey(String key) {\n+    return this.children.containsKey(key);\n+  }\n+\n+  /**\n+   * add the given key to given child MNode\n+   *\n+   * @param key key\n+   * @param child child MNode\n+   */\n+  @Override\n+  public void addChild(String key, MNode child) {\n+    this.children.put(key, child);\n+  }\n+\n+  /**\n+   * delete key from given child MNode\n+   *\n+   * @param key key\n+   */\n+  @Override\n+  public void deleteChild(String key) {\n+    children.remove(key);\n+  }\n+\n+  /**\n+   * get the child MNode under the given key.\n+   *\n+   * @param key key", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNTAwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param key key\n          \n          \n            \n               * @param key deleted child name", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380535004", "createdAt": "2020-02-18T09:00:41Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public class InternalMNode extends MNode {\n+\n+  private static final long serialVersionUID = 7999036474525817732L;\n+\n+  public InternalMNode(String name, MNode parent) {\n+    super(name, parent);\n+    this.nodeType = MNodeType.INTERNAL_MNODE;\n+    this.children = new LinkedHashMap<>();\n+  }\n+\n+  @Override\n+  public boolean isNodeType(MNodeType nodeType) {\n+    return this.nodeType.equals(nodeType);\n+  }\n+\n+  /**\n+   * check whether the MNode has children\n+   */\n+  @Override\n+  public boolean hasChildren() {\n+    return true;\n+  }\n+\n+  /**\n+   * check whether the MNode has child with the given key\n+   *\n+   * @param key key\n+   */\n+  @Override\n+  public boolean hasChildWithKey(String key) {\n+    return this.children.containsKey(key);\n+  }\n+\n+  /**\n+   * add the given key to given child MNode\n+   *\n+   * @param key key\n+   * @param child child MNode\n+   */\n+  @Override\n+  public void addChild(String key, MNode child) {\n+    this.children.put(key, child);\n+  }\n+\n+  /**\n+   * delete key from given child MNode\n+   *\n+   * @param key key", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDgwMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              MNode addPath(String path) throws MetadataException {\n          \n          \n            \n              MNode addInternalPath(String path) throws MetadataException {", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380540800", "createdAt": "2020-02-18T09:11:40Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MTAyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n          \n          \n            \n               * Add an interval path to MTree. This is only used for automatically creating schema", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380541020", "createdAt": "2020-02-18T09:12:05Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MjgzNw==", "bodyText": "I wonder why this method exists, could this be replaced by addPath(String path, TSDataType dataType, TSEncoding encoding, CompressionType compressor, Map<String, String> props)?", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380542837", "createdAt": "2020-02-18T09:15:23Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDgwMA=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0ODI0Ng==", "bodyText": "I find that isPathExist(MNode node, String path) is only used in isPathExist(String path). So, the node must be a dummyNode. Then, we could init the cur = root without this check. And I really do not get why we need a dummyNode. It's better to remove it.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380548246", "createdAt": "2020-02-18T09:24:43Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n+      throw new IllegalPathException(path);\n+    }\n     MNode cur = root;\n-    int i = 0;\n-    while (i < nodeNames.length - 1) {\n-      String nodeName = nodeNames[i];\n-      if (cur.getName().equals(nodeName)) {\n-        i++;\n-        nodeName = nodeNames[i];\n-        if (cur.hasChild(nodeName)) {\n-          cur = cur.getChild(nodeName);\n-        } else {\n-          return false;\n-        }\n-      } else {\n-        return false;\n+    for (int i = 1; i < nodeNames.length; i++) {\n+      if (!cur.hasChildWithKey(nodeNames[i])) {\n+        cur.addChild(nodeNames[i], new InternalMNode(nodeNames[i], cur));\n       }\n+      cur = cur.getChild(nodeNames[i]);\n     }\n-    return cur.getName().equals(nodeNames[i]);\n+    return cur;\n+  }\n+\n+  /**\n+   * Check whether the given path exists\n+   *\n+   * @param path not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   */\n+  boolean isPathExist(String path) {\n+    return isPathExist(dummyNode, path);\n   }\n \n   /**\n-   * function for checking whether the given path exists under the given mNode.\n+   * Check whether the given path exists under the given MNode\n    */\n-  boolean isPathExist(MNode node, String path) {\n-    String[] nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n-    if (nodeNames.length < 1) {\n-      return true;\n-    }\n-    if (!node.hasChild(nodeNames[0])) {\n-      return false;\n+  private boolean isPathExist(MNode node, String path) {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    MNode cur;\n+    if (node.equals(dummyNode)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0OTI5Nw==", "bodyText": "The other unclear thing is,   I add a path to MTree, which MNode this method returns to me? It's better to return void", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380549297", "createdAt": "2020-02-18T09:26:33Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDgwMA=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1MDQyMg==", "bodyText": "is the path a full path that starts from the root? add javadoc", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380550422", "createdAt": "2020-02-18T09:28:15Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n+      throw new IllegalPathException(path);\n+    }\n     MNode cur = root;\n-    int i = 0;\n-    while (i < nodeNames.length - 1) {\n-      String nodeName = nodeNames[i];\n-      if (cur.getName().equals(nodeName)) {\n-        i++;\n-        nodeName = nodeNames[i];\n-        if (cur.hasChild(nodeName)) {\n-          cur = cur.getChild(nodeName);\n-        } else {\n-          return false;\n-        }\n-      } else {\n-        return false;\n+    for (int i = 1; i < nodeNames.length; i++) {\n+      if (!cur.hasChildWithKey(nodeNames[i])) {\n+        cur.addChild(nodeNames[i], new InternalMNode(nodeNames[i], cur));\n       }\n+      cur = cur.getChild(nodeNames[i]);\n     }\n-    return cur.getName().equals(nodeNames[i]);\n+    return cur;\n+  }\n+\n+  /**\n+   * Check whether the given path exists\n+   *\n+   * @param path not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   */\n+  boolean isPathExist(String path) {\n+    return isPathExist(dummyNode, path);\n   }\n \n   /**\n-   * function for checking whether the given path exists under the given mNode.\n+   * Check whether the given path exists under the given MNode\n    */\n-  boolean isPathExist(MNode node, String path) {\n-    String[] nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n-    if (nodeNames.length < 1) {\n-      return true;\n-    }\n-    if (!node.hasChild(nodeNames[0])) {\n-      return false;\n+  private boolean isPathExist(MNode node, String path) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1MDkyMQ==", "bodyText": "if the path is from root, we could start from i = 1", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380550921", "createdAt": "2020-02-18T09:29:03Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n+      throw new IllegalPathException(path);\n+    }\n     MNode cur = root;\n-    int i = 0;\n-    while (i < nodeNames.length - 1) {\n-      String nodeName = nodeNames[i];\n-      if (cur.getName().equals(nodeName)) {\n-        i++;\n-        nodeName = nodeNames[i];\n-        if (cur.hasChild(nodeName)) {\n-          cur = cur.getChild(nodeName);\n-        } else {\n-          return false;\n-        }\n-      } else {\n-        return false;\n+    for (int i = 1; i < nodeNames.length; i++) {\n+      if (!cur.hasChildWithKey(nodeNames[i])) {\n+        cur.addChild(nodeNames[i], new InternalMNode(nodeNames[i], cur));\n       }\n+      cur = cur.getChild(nodeNames[i]);\n     }\n-    return cur.getName().equals(nodeNames[i]);\n+    return cur;\n+  }\n+\n+  /**\n+   * Check whether the given path exists\n+   *\n+   * @param path not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   */\n+  boolean isPathExist(String path) {\n+    return isPathExist(dummyNode, path);\n   }\n \n   /**\n-   * function for checking whether the given path exists under the given mNode.\n+   * Check whether the given path exists under the given MNode\n    */\n-  boolean isPathExist(MNode node, String path) {\n-    String[] nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n-    if (nodeNames.length < 1) {\n-      return true;\n-    }\n-    if (!node.hasChild(nodeNames[0])) {\n-      return false;\n+  private boolean isPathExist(MNode node, String path) {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    MNode cur;\n+    if (node.equals(dummyNode)) {\n+      cur = root;\n+    } else {\n+      cur = node.getChild(nodeNames[0]);\n+      if (!node.hasChildWithKey(nodeNames[0])) {\n+        return false;\n+      }\n     }\n-    MNode cur = node.getChild(nodeNames[0]);\n-\n     int i = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1MTUxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              abstract public boolean hasChildWithKey(String key);\n          \n          \n            \n              abstract public boolean hasChild(String childName);", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380551514", "createdAt": "2020-02-18T09:30:08Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;\n+\n+  /**\n+   * Column's Schema for one timeseries represented by current node if current node is one leaf\n+   */\n+  MeasurementSchema schema;\n+\n+  Map<String, MNode> children;\n+\n+  MNodeType nodeType;\n+\n+  /**\n+   * when the data in a storage group is older than dataTTL, it is considered invalid and will be\n+   * eventually removed. only set at storage group level.\n+   */\n+  private long dataTTL = Long.MAX_VALUE;\n+\n+  /**\n+   * Constructor of MNode.\n+   */\n+  public MNode(String name, MNode parent) {\n+    this.setName(name);\n+    this.parent = parent;\n+  }\n+\n+  abstract public boolean isNodeType(MNodeType nodeType);\n+\n+  /**\n+   * Set storage group\n+   */\n+  public void setStorageGroup() {\n+    nodeType = MNodeType.STORAGE_GROUP_MNODE;\n+    schemaMap = new HashMap<>();\n+  }\n+\n+  public Map<String, MeasurementSchema> getSchemaMap() {\n+    return schemaMap;\n+  }\n+\n+  /**\n+   * check whether the MNode has children\n+   */\n+  abstract public boolean hasChildren();\n+\n+  /**\n+   * check whether the MNode has child with the given key\n+   *\n+   * @param key key\n+   */\n+  abstract public boolean hasChildWithKey(String key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1MzE4OA==", "bodyText": "if we start from root and check if nodeName[0] is root, then, we do not need this check in this while", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380553188", "createdAt": "2020-02-18T09:32:58Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n+      throw new IllegalPathException(path);\n+    }\n     MNode cur = root;\n-    int i = 0;\n-    while (i < nodeNames.length - 1) {\n-      String nodeName = nodeNames[i];\n-      if (cur.getName().equals(nodeName)) {\n-        i++;\n-        nodeName = nodeNames[i];\n-        if (cur.hasChild(nodeName)) {\n-          cur = cur.getChild(nodeName);\n-        } else {\n-          return false;\n-        }\n-      } else {\n-        return false;\n+    for (int i = 1; i < nodeNames.length; i++) {\n+      if (!cur.hasChildWithKey(nodeNames[i])) {\n+        cur.addChild(nodeNames[i], new InternalMNode(nodeNames[i], cur));\n       }\n+      cur = cur.getChild(nodeNames[i]);\n     }\n-    return cur.getName().equals(nodeNames[i]);\n+    return cur;\n+  }\n+\n+  /**\n+   * Check whether the given path exists\n+   *\n+   * @param path not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   */\n+  boolean isPathExist(String path) {\n+    return isPathExist(dummyNode, path);\n   }\n \n   /**\n-   * function for checking whether the given path exists under the given mNode.\n+   * Check whether the given path exists under the given MNode\n    */\n-  boolean isPathExist(MNode node, String path) {\n-    String[] nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n-    if (nodeNames.length < 1) {\n-      return true;\n-    }\n-    if (!node.hasChild(nodeNames[0])) {\n-      return false;\n+  private boolean isPathExist(MNode node, String path) {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    MNode cur;\n+    if (node.equals(dummyNode)) {\n+      cur = root;\n+    } else {\n+      cur = node.getChild(nodeNames[0]);\n+      if (!node.hasChildWithKey(nodeNames[0])) {\n+        return false;\n+      }\n     }\n-    MNode cur = node.getChild(nodeNames[0]);\n-\n     int i = 0;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n       if (cur.getName().equals(nodeName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 232}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38fa1e1aeb19bf5852ebfe6b6507a6e3befacfad", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/38fa1e1aeb19bf5852ebfe6b6507a6e3befacfad", "committedDate": "2020-02-18T10:09:59Z", "message": "Merge remote-tracking branch 'upstream/new_series_reader' into mmanager\n\n# Conflicts:\n#\tserver/src/main/java/org/apache/iotdb/db/query/timegenerator/ServerTimeGenerator.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2029fe5fb2377a4e0a7bb30c9bbce99ba9214840", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/2029fe5fb2377a4e0a7bb30c9bbce99ba9214840", "committedDate": "2020-02-18T12:48:07Z", "message": "Solve conflict and fix some review suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11483daf61c4db8282ea16269bb60fa8003c410e", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/11483daf61c4db8282ea16269bb60fa8003c410e", "committedDate": "2020-02-19T03:07:15Z", "message": "Add StorageGroupMNode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91aeabe1669987fc7b5642c70786b74eb71e8528", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/91aeabe1669987fc7b5642c70786b74eb71e8528", "committedDate": "2020-02-19T05:15:47Z", "message": "Move storage group name into StorageGroupMNode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cd68b47387718bbd1fb10c1a5ca01413beed206", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/9cd68b47387718bbd1fb10c1a5ca01413beed206", "committedDate": "2020-02-19T09:23:13Z", "message": "refactor MTree"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwODY1NDk1", "url": "https://github.com/apache/iotdb/pull/793#pullrequestreview-360865495", "createdAt": "2020-02-19T06:22:55Z", "commit": {"oid": "91aeabe1669987fc7b5642c70786b74eb71e8528"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwNjoyMjo1NVrOFrcTeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwNjoyMzoyMlrOFrcT8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5NjgyNg==", "bodyText": "If InternalMNode and StorageGroupMNode all return true, then this function is not needed. We could use instance of LeafMNode to check this", "url": "https://github.com/apache/iotdb/pull/793#discussion_r381096826", "createdAt": "2020-02-19T06:22:55Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public class InternalMNode extends MNode {\n+\n+  private static final long serialVersionUID = 7999036474525817732L;\n+\n+  private Map<String, MNode> children;\n+\n+  public InternalMNode(String name, MNode parent) {\n+    super(name, parent);\n+    this.children = new LinkedHashMap<>();\n+  }\n+\n+  /**\n+   * check whether the MNode has children\n+   */\n+  @Override\n+  public boolean hasChildren() {\n+    return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91aeabe1669987fc7b5642c70786b74eb71e8528"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5Njk0NA==", "bodyText": "why we need a serialVersionUID?", "url": "https://github.com/apache/iotdb/pull/793#discussion_r381096944", "createdAt": "2020-02-19T06:23:22Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/StorageGroupMNode.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public class StorageGroupMNode extends InternalMNode {\n+\n+  private static final long serialVersionUID = 7999036474525817732L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91aeabe1669987fc7b5642c70786b74eb71e8528"}, "originalPosition": 31}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9cd68b47387718bbd1fb10c1a5ca01413beed206", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/9cd68b47387718bbd1fb10c1a5ca01413beed206", "committedDate": "2020-02-19T09:23:13Z", "message": "refactor MTree"}, "afterCommit": {"oid": "9ca8dd2dbdf98f2015d04f2b03fc16b47d4963a3", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/9ca8dd2dbdf98f2015d04f2b03fc16b47d4963a3", "committedDate": "2020-02-19T09:47:27Z", "message": "Remove hasChildren() method"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9ca8dd2dbdf98f2015d04f2b03fc16b47d4963a3", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/9ca8dd2dbdf98f2015d04f2b03fc16b47d4963a3", "committedDate": "2020-02-19T09:47:27Z", "message": "Remove hasChildren() method"}, "afterCommit": {"oid": "9cd68b47387718bbd1fb10c1a5ca01413beed206", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/9cd68b47387718bbd1fb10c1a5ca01413beed206", "committedDate": "2020-02-19T09:23:13Z", "message": "refactor MTree"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c99b58bcfc9eacf657ae6bb9fc552e14f574f9f5", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/c99b58bcfc9eacf657ae6bb9fc552e14f574f9f5", "committedDate": "2020-02-19T10:01:49Z", "message": "Remove hasChildren() method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e187bb36cb326f1ef753229a48508e4c2885e64e", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/e187bb36cb326f1ef753229a48508e4c2885e64e", "committedDate": "2020-02-19T10:12:36Z", "message": "Remove hasChildren() method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cbbb4fcb40bb6e59634158f6c33491506ab547c", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/3cbbb4fcb40bb6e59634158f6c33491506ab547c", "committedDate": "2020-02-19T14:14:18Z", "message": "Fix some code smells"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e1ba16d15fe2e28427ac29f1be421e3ce400b2f", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/2e1ba16d15fe2e28427ac29f1be421e3ce400b2f", "committedDate": "2020-02-20T02:29:30Z", "message": "Merge remote-tracking branch 'upstream/new_series_reader' into mmanager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1935518f1a4e748bf7ed827d01f50517e755c63", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/a1935518f1a4e748bf7ed827d01f50517e755c63", "committedDate": "2020-02-20T02:30:00Z", "message": "Rebase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecfda43a486cdd4b6a81aa0ba25ceea599e4e0d0", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/ecfda43a486cdd4b6a81aa0ba25ceea599e4e0d0", "committedDate": "2020-02-20T04:17:13Z", "message": "Delete some unused check in MManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "786a1f64ecbaf51753ae7e942c2b800ed9e695e8", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/786a1f64ecbaf51753ae7e942c2b800ed9e695e8", "committedDate": "2020-02-20T14:03:07Z", "message": "refactor mmanager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96e37936451efc22ad2b34ee202e06ee279c5fc5", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/96e37936451efc22ad2b34ee202e06ee279c5fc5", "committedDate": "2020-02-20T16:08:01Z", "message": "Fix bugs and code smells"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a223289d6d1bd46b8cf5777efa885058768ec1c", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/7a223289d6d1bd46b8cf5777efa885058768ec1c", "committedDate": "2020-02-20T16:13:14Z", "message": "Reverse test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a6723269b5b00531313abcc22dc004601d2a0e7", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/9a6723269b5b00531313abcc22dc004601d2a0e7", "committedDate": "2020-02-21T00:45:02Z", "message": "Fix tsfile WriteTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f94a863f773fb99996bd44c79c5ae3d6aae7ead", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/8f94a863f773fb99996bd44c79c5ae3d6aae7ead", "committedDate": "2020-02-21T01:55:54Z", "message": "update properties description"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f15da828888c81cbfb095164fab369b7b20ca9df", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/f15da828888c81cbfb095164fab369b7b20ca9df", "committedDate": "2020-02-21T01:58:10Z", "message": "change setStorageGroup to shouldSet"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bf500d93f8c9fc15fdf719c431608489fca9369", "author": {"user": null}, "url": "https://github.com/apache/iotdb/commit/7bf500d93f8c9fc15fdf719c431608489fca9369", "committedDate": "2020-02-21T01:58:30Z", "message": "move an error log to info log.(resourceLogger)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2852a1bfda1e121fe9561bf230d2a69b68bc8b3b", "author": {"user": null}, "url": "https://github.com/apache/iotdb/commit/2852a1bfda1e121fe9561bf230d2a69b68bc8b3b", "committedDate": "2020-02-21T01:58:30Z", "message": "enable mergeLog for checking why merging is hanged"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a08a10dc3d591a52cc204a838ab1b30b1707b0bf", "author": {"user": null}, "url": "https://github.com/apache/iotdb/commit/a08a10dc3d591a52cc204a838ab1b30b1707b0bf", "committedDate": "2020-02-21T01:58:30Z", "message": "try to set stoptime as 0 to accelerate MetrcsService close"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97e3331740caf4b5187e62b42829049323268c09", "author": {"user": null}, "url": "https://github.com/apache/iotdb/commit/97e3331740caf4b5187e62b42829049323268c09", "committedDate": "2020-02-21T01:58:30Z", "message": "try to solve the bug 'if the flushing thread is too fast, the tmpMemTable.wait() may never wakeup' in TsFileProcessor syncFlush()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b167175b0cb2663d007e12c25a8058de55107d1", "author": {"user": null}, "url": "https://github.com/apache/iotdb/commit/7b167175b0cb2663d007e12c25a8058de55107d1", "committedDate": "2020-02-21T01:58:30Z", "message": "try to solve the bug 'if the flushing thread is too fast, the tmpMemTable.wait() may never wakeup' in TsFileProcessor syncFlush() 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea1d3bb428a6acc3692ea718de99c4b7e27f1199", "author": {"user": null}, "url": "https://github.com/apache/iotdb/commit/ea1d3bb428a6acc3692ea718de99c4b7e27f1199", "committedDate": "2020-02-21T01:58:30Z", "message": "debug why 8181 is not closed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a5621368d262e5bdc183aae655024569b335eb1", "author": {"user": {"login": "samperson1997", "name": "Zesong Sun"}}, "url": "https://github.com/apache/iotdb/commit/2a5621368d262e5bdc183aae655024569b335eb1", "committedDate": "2020-02-21T02:24:56Z", "message": "Fix TSFHiveInputFormatTest.testGetSplits"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzc4NTYw", "url": "https://github.com/apache/iotdb/pull/793#pullrequestreview-362378560", "createdAt": "2020-02-21T03:20:45Z", "commit": {"oid": "2a5621368d262e5bdc183aae655024569b335eb1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "101149da4890f070db8fddc9efdcff7c4899d096", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/101149da4890f070db8fddc9efdcff7c4899d096", "committedDate": "2020-02-23T07:21:07Z", "message": "resolve conflict after merging master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4dfa1aee2c86993685d74c639a158d1532aaf1f", "author": {"user": {"login": "qiaojialin", "name": "Jialin Qiao"}}, "url": "https://github.com/apache/iotdb/commit/a4dfa1aee2c86993685d74c639a158d1532aaf1f", "committedDate": "2020-02-23T07:22:10Z", "message": "resolve confilct"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3324, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}