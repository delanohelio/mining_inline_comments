{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUzMTMwMDc1", "number": 1524, "reviewThreads": {"totalCount": 72, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjozMzoyNFrOERBmwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNjowMTo1NFrOE0cOvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjg3NTUzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjozMzoyNFrOG1gTiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzo1Mzo1NVrOG1jf-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1NzAwMA==", "bodyText": "Hi, according to previous design, checkBufferedArray is to be done by ArrayManager module.\nWhen TSP is asking for one array, it could call ArrayManager.getDataListByType (and it is the only interface for asking array). This method will check whether there are enough buffered arrays and return one if true; or apply an out of buffer array and return one if system module agrees; or return null if system module refuses to offer one.\nIn this way, TSP does not need to know whether the array is buffered or out of buffer. The management of arrays is responsibility of ArrayManager. What do you think?", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r458757000", "createdAt": "2020-07-22T12:33:24Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "diffHunk": "@@ -241,34 +272,91 @@ public void insertTablet(InsertTabletPlan insertTabletPlan, int start, int end,\n       workMemTable = MemTablePool.getInstance().getAvailableMemTable(this);\n     }\n \n-    // insert insertRowPlan to the work memtable\n-    try {\n-      workMemTable.insertTablet(insertTabletPlan, start, end);\n-      if (IoTDBDescriptor.getInstance().getConfig().isEnableWal()) {\n-        insertTabletPlan.setStart(start);\n-        insertTabletPlan.setEnd(end);\n-        getLogNode().write(insertTabletPlan);\n+    if (workMemTable.checkIfArrayIsEnough(insertTabletPlan)) {\n+      // insert insertRowPlan to the work memtable\n+      try {\n+        workMemTable.insertTablet(insertTabletPlan, start, end);\n+        if (IoTDBDescriptor.getInstance().getConfig().isEnableWal()) {\n+          insertTabletPlan.setStart(start);\n+          insertTabletPlan.setEnd(end);\n+          getLogNode().write(insertTabletPlan);\n+        }\n+      } catch (Exception e) {\n+        for (int i = start; i < end; i++) {\n+          results[i] = RpcUtils.getStatus(TSStatusCode.INTERNAL_SERVER_ERROR, e.getMessage());\n+        }\n+        throw new WriteProcessException(e);\n       }\n-    } catch (Exception e) {\n+  \n       for (int i = start; i < end; i++) {\n-        results[i] = RpcUtils.getStatus(TSStatusCode.INTERNAL_SERVER_ERROR, e.getMessage());\n+        results[i] = RpcUtils.SUCCESS_STATUS;\n+      }\n+  \n+      tsFileResource\n+          .updateStartTime(insertTabletPlan.getDeviceId(), insertTabletPlan.getTimes()[start]);\n+  \n+      //for sequence tsfile, we update the endTime only when the file is prepared to be closed.\n+      //for unsequence tsfile, we have to update the endTime for each insertion.\n+      if (!sequence) {\n+        tsFileResource\n+            .updateEndTime(\n+                insertTabletPlan.getDeviceId(), insertTabletPlan.getTimes()[end - 1]);\n       }\n-      throw new WriteProcessException(e);\n     }\n-\n-    for (int i = start; i < end; i++) {\n-      results[i] = RpcUtils.SUCCESS_STATUS;\n+    else {\n+      // if there are available buffered arrays in array pool\n+      boolean isbufferedArrayEnough = true;\n+      // TODO: isbufferedArrayEnough = checkBufferedArray();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db167a8c8d500b78369b8a269966496125d9867"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwNzAzNw==", "bodyText": "Hi, according to previous design, checkBufferedArray is to be done by ArrayManager module.\nWhen TSP is asking for one array, it could call ArrayManager.getDataListByType (and it is the only interface for asking array). This method will check whether there are enough buffered arrays and return one if true; or apply an out of buffer array and return one if system module agrees; or return null if system module refuses to offer one.\nIn this way, TSP does not need to know whether the array is buffered or out of buffer. The management of arrays is responsibility of ArrayManager. What do you think?\n\nYes, you are right. That's why I write TODO here. I'll fix it very soon. Thanks. :)", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r458807037", "createdAt": "2020-07-22T13:50:52Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "diffHunk": "@@ -241,34 +272,91 @@ public void insertTablet(InsertTabletPlan insertTabletPlan, int start, int end,\n       workMemTable = MemTablePool.getInstance().getAvailableMemTable(this);\n     }\n \n-    // insert insertRowPlan to the work memtable\n-    try {\n-      workMemTable.insertTablet(insertTabletPlan, start, end);\n-      if (IoTDBDescriptor.getInstance().getConfig().isEnableWal()) {\n-        insertTabletPlan.setStart(start);\n-        insertTabletPlan.setEnd(end);\n-        getLogNode().write(insertTabletPlan);\n+    if (workMemTable.checkIfArrayIsEnough(insertTabletPlan)) {\n+      // insert insertRowPlan to the work memtable\n+      try {\n+        workMemTable.insertTablet(insertTabletPlan, start, end);\n+        if (IoTDBDescriptor.getInstance().getConfig().isEnableWal()) {\n+          insertTabletPlan.setStart(start);\n+          insertTabletPlan.setEnd(end);\n+          getLogNode().write(insertTabletPlan);\n+        }\n+      } catch (Exception e) {\n+        for (int i = start; i < end; i++) {\n+          results[i] = RpcUtils.getStatus(TSStatusCode.INTERNAL_SERVER_ERROR, e.getMessage());\n+        }\n+        throw new WriteProcessException(e);\n       }\n-    } catch (Exception e) {\n+  \n       for (int i = start; i < end; i++) {\n-        results[i] = RpcUtils.getStatus(TSStatusCode.INTERNAL_SERVER_ERROR, e.getMessage());\n+        results[i] = RpcUtils.SUCCESS_STATUS;\n+      }\n+  \n+      tsFileResource\n+          .updateStartTime(insertTabletPlan.getDeviceId(), insertTabletPlan.getTimes()[start]);\n+  \n+      //for sequence tsfile, we update the endTime only when the file is prepared to be closed.\n+      //for unsequence tsfile, we have to update the endTime for each insertion.\n+      if (!sequence) {\n+        tsFileResource\n+            .updateEndTime(\n+                insertTabletPlan.getDeviceId(), insertTabletPlan.getTimes()[end - 1]);\n       }\n-      throw new WriteProcessException(e);\n     }\n-\n-    for (int i = start; i < end; i++) {\n-      results[i] = RpcUtils.SUCCESS_STATUS;\n+    else {\n+      // if there are available buffered arrays in array pool\n+      boolean isbufferedArrayEnough = true;\n+      // TODO: isbufferedArrayEnough = checkBufferedArray();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1NzAwMA=="}, "originalCommit": {"oid": "0db167a8c8d500b78369b8a269966496125d9867"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwOTMzNw==", "bodyText": "Take it easy!!!", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r458809337", "createdAt": "2020-07-22T13:53:55Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "diffHunk": "@@ -241,34 +272,91 @@ public void insertTablet(InsertTabletPlan insertTabletPlan, int start, int end,\n       workMemTable = MemTablePool.getInstance().getAvailableMemTable(this);\n     }\n \n-    // insert insertRowPlan to the work memtable\n-    try {\n-      workMemTable.insertTablet(insertTabletPlan, start, end);\n-      if (IoTDBDescriptor.getInstance().getConfig().isEnableWal()) {\n-        insertTabletPlan.setStart(start);\n-        insertTabletPlan.setEnd(end);\n-        getLogNode().write(insertTabletPlan);\n+    if (workMemTable.checkIfArrayIsEnough(insertTabletPlan)) {\n+      // insert insertRowPlan to the work memtable\n+      try {\n+        workMemTable.insertTablet(insertTabletPlan, start, end);\n+        if (IoTDBDescriptor.getInstance().getConfig().isEnableWal()) {\n+          insertTabletPlan.setStart(start);\n+          insertTabletPlan.setEnd(end);\n+          getLogNode().write(insertTabletPlan);\n+        }\n+      } catch (Exception e) {\n+        for (int i = start; i < end; i++) {\n+          results[i] = RpcUtils.getStatus(TSStatusCode.INTERNAL_SERVER_ERROR, e.getMessage());\n+        }\n+        throw new WriteProcessException(e);\n       }\n-    } catch (Exception e) {\n+  \n       for (int i = start; i < end; i++) {\n-        results[i] = RpcUtils.getStatus(TSStatusCode.INTERNAL_SERVER_ERROR, e.getMessage());\n+        results[i] = RpcUtils.SUCCESS_STATUS;\n+      }\n+  \n+      tsFileResource\n+          .updateStartTime(insertTabletPlan.getDeviceId(), insertTabletPlan.getTimes()[start]);\n+  \n+      //for sequence tsfile, we update the endTime only when the file is prepared to be closed.\n+      //for unsequence tsfile, we have to update the endTime for each insertion.\n+      if (!sequence) {\n+        tsFileResource\n+            .updateEndTime(\n+                insertTabletPlan.getDeviceId(), insertTabletPlan.getTimes()[end - 1]);\n       }\n-      throw new WriteProcessException(e);\n     }\n-\n-    for (int i = start; i < end; i++) {\n-      results[i] = RpcUtils.SUCCESS_STATUS;\n+    else {\n+      // if there are available buffered arrays in array pool\n+      boolean isbufferedArrayEnough = true;\n+      // TODO: isbufferedArrayEnough = checkBufferedArray();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1NzAwMA=="}, "originalCommit": {"oid": "0db167a8c8d500b78369b8a269966496125d9867"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NzE4MjgyOnYy", "diffSide": "RIGHT", "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQxNToxODoyOFrOG6ekmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQwNTowNTozNlrOG6iSPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk3MTQ4Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            reject_proportion=0.5\n          \n          \n            \n            flush_proportion=0.5", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r463971482", "createdAt": "2020-08-01T15:18:28Z", "author": {"login": "samperson1997"}, "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "diffHunk": "@@ -235,6 +235,9 @@ primitive_array_size=128\n # Ratio of memory allocated for buffered arrays, 0.8 by default\n buffered_arrays_memory_proportion=0.8\n \n+# Flush proportion for system, 0.5 by default\n+reject_proportion=0.5", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dffb5277988bc0895c838d81b299b500afdfe872"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAzMjMxNg==", "bodyText": "Thanks~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r464032316", "createdAt": "2020-08-02T05:05:36Z", "author": {"login": "HTHou"}, "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "diffHunk": "@@ -235,6 +235,9 @@ primitive_array_size=128\n # Ratio of memory allocated for buffered arrays, 0.8 by default\n buffered_arrays_memory_proportion=0.8\n \n+# Flush proportion for system, 0.5 by default\n+reject_proportion=0.5", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk3MTQ4Mg=="}, "originalCommit": {"oid": "dffb5277988bc0895c838d81b299b500afdfe872"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTg4MDI3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjo0NjozNVrOG-mdPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjo0NjozNVrOG-mdPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5NDk3NA==", "bodyText": "I will change this back later...", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r468294974", "createdAt": "2020-08-11T02:46:35Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -271,7 +271,7 @@\n   /**\n    * Is vm merge enable\n    */\n-  private boolean enableVm = true;\n+  private boolean enableVm = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab2b94eae7b56401d3c07dbca04206f8bed15e90"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNzEyOTI1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNToyODo1OVrOHAQ2TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMjo1MDoyN1rOHAlxMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzODA5Mg==", "bodyText": "This count may be not very accurate. If you want accurate count, consider synchronize. If you need performance and accept inaccurate count, this way is better.", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r470038092", "createdAt": "2020-08-13T15:28:59Z", "author": {"login": "SilverNarcissus"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java", "diffHunk": "@@ -609,6 +609,15 @@ public boolean isFileAlreadyExist(TsFileResource tsFileResource, String storageG\n     return processor != null && processor.isFileAlreadyExist(tsFileResource, partitionNum);\n   }\n \n+  public int countTsFileProcessors() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31fc4bbcf3070fc0d970896e41478a99468e4a32"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4MDg0OA==", "bodyText": "This method is no longer useful. I'll remove it in the next commit. :)", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r470380848", "createdAt": "2020-08-14T02:50:27Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java", "diffHunk": "@@ -609,6 +609,15 @@ public boolean isFileAlreadyExist(TsFileResource tsFileResource, String storageG\n     return processor != null && processor.isFileAlreadyExist(tsFileResource, partitionNum);\n   }\n \n+  public int countTsFileProcessors() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzODA5Mg=="}, "originalCommit": {"oid": "31fc4bbcf3070fc0d970896e41478a99468e4a32"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNzEzNjQ1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTozMDo0MFrOHAQ6xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwOToyNDo1MFrOHCLJcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzOTIzOQ==", "bodyText": "Need some comment here to show this class's function", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r470039239", "createdAt": "2020-08-13T15:30:40Z", "author": {"login": "SilverNarcissus"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import java.util.TreeSet;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.rescon.SystemInfo;\n+\n+public class StorageGroupInfo {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31fc4bbcf3070fc0d970896e41478a99468e4a32"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA0MTg0Mw==", "bodyText": "Fixed, thanks~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r472041843", "createdAt": "2020-08-18T09:24:50Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import java.util.TreeSet;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.rescon.SystemInfo;\n+\n+public class StorageGroupInfo {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzOTIzOQ=="}, "originalCommit": {"oid": "31fc4bbcf3070fc0d970896e41478a99468e4a32"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNzE0NzU4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessorInfo.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTozMzoyNVrOHARB1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwOToyNDo1OVrOHCLJ7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0MTA0Ng==", "bodyText": "Need some comment to show this class's function.", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r470041046", "createdAt": "2020-08-13T15:33:25Z", "author": {"login": "SilverNarcissus"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessorInfo.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+\n+public class TsFileProcessorInfo {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31fc4bbcf3070fc0d970896e41478a99468e4a32"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA0MTk2NQ==", "bodyText": "Fixed~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r472041965", "createdAt": "2020-08-18T09:24:59Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessorInfo.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+\n+public class TsFileProcessorInfo {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0MTA0Ng=="}, "originalCommit": {"oid": "31fc4bbcf3070fc0d970896e41478a99468e4a32"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNzE2MjI3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTozNjo1NFrOHARKyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwODo0NDo1OFrOHCJqgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0MzMzOQ==", "bodyText": "Use Integer.compare() rather than a - b;", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r470043339", "createdAt": "2020-08-13T15:36:54Z", "author": {"login": "SilverNarcissus"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.TreeMap;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.flush.FlushManager;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupInfo;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileProcessor;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SystemInfo {\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final Logger logger = LoggerFactory.getLogger(SystemInfo.class);\n+\n+  private long totalSgInfoMemCost;\n+  private long arrayPoolMemCost;\n+  private boolean rejected = false;\n+\n+  private TreeMap<StorageGroupInfo, Long> reportedSgMemCostMap = new TreeMap<>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31fc4bbcf3070fc0d970896e41478a99468e4a32"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAxNzUzOQ==", "bodyText": "Already fixed~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r472017539", "createdAt": "2020-08-18T08:44:58Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.TreeMap;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.flush.FlushManager;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupInfo;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileProcessor;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SystemInfo {\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final Logger logger = LoggerFactory.getLogger(SystemInfo.class);\n+\n+  private long totalSgInfoMemCost;\n+  private long arrayPoolMemCost;\n+  private boolean rejected = false;\n+\n+  private TreeMap<StorageGroupInfo, Long> reportedSgMemCostMap = new TreeMap<>(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0MzMzOQ=="}, "originalCommit": {"oid": "31fc4bbcf3070fc0d970896e41478a99468e4a32"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDI1MTgxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMToxMzo1NVrOHILfxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMjozMDoyNVrOHInbAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzOTAxNA==", "bodyText": "what is the reason of modifing the sgReportThreshold?", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r478339014", "createdAt": "2020-08-27T11:13:55Z", "author": {"login": "mychaow"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TreeSet;\n+\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.flush.FlushManager;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupInfo;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileProcessor;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SystemInfo {\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final Logger logger = LoggerFactory.getLogger(SystemInfo.class);\n+\n+  private long totalSgMemCost;\n+  private long arrayPoolMemCost;\n+  private boolean rejected = false;\n+\n+  private Map<StorageGroupInfo, Long> reportedSgMemCostMap = new HashMap<>();\n+\n+  private static final double FLUSH_PROPORTION = config.getFlushProportion();\n+  private static final double REJECT_PROPORTION = config.getRejectProportion();\n+\n+  /**\n+   * Report applying a new out of buffered array to system. Attention: It should be invoked before\n+   * applying new OOB array actually.\n+   *\n+   * @param dataType data type of array\n+   * @param size     size of array\n+   * @return Return true if it's agreed when memory is enough.\n+   */\n+  public synchronized boolean applyNewOOBArray(TSDataType dataType, int size) {\n+    // if current memory is enough\n+    if (arrayPoolMemCost + totalSgMemCost + dataType.getDataTypeSize() * size\n+        < config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+      arrayPoolMemCost += dataType.getDataTypeSize() * size;\n+      logger.debug(\"Current total mem cost is {}\", (arrayPoolMemCost + totalSgMemCost));\n+      rejected = false;\n+      return true;\n+    } else if (arrayPoolMemCost + totalSgMemCost + dataType.getDataTypeSize() * size\n+        < config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {\n+      arrayPoolMemCost += dataType.getDataTypeSize() * size;\n+      // invoke flush()\n+      logger.debug(\"Out of buffer arraies are too large, call for flushing. \"\n+          + \"Current total mem cost is {}\", (arrayPoolMemCost + totalSgMemCost));\n+      rejected = false;\n+      flush();\n+      return true;\n+    } else {\n+      logger.debug(\"Out of buffer arraies are too large, call for flushing \"\n+          + \"and change system to rejected status...Current total mem cost is {}\", \n+          (arrayPoolMemCost + totalSgMemCost));\n+      rejected = true;\n+      flush();\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Report current mem cost of storage group to system.\n+   *\n+   * @param storageGroupInfo storage group\n+   * @param delta mem cost\n+   */\n+  public synchronized void reportStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    long delta = storageGroupInfo.getSgMemCost() - \n+        reportedSgMemCostMap.getOrDefault(storageGroupInfo, 0L);\n+    totalSgMemCost += delta;\n+    logger.debug(\"Report Storage Group Status to system. \"\n+        + \"Current array pool mem cost is {}, sg mem cost is {}.\", arrayPoolMemCost,\n+        totalSgMemCost);\n+    reportedSgMemCostMap.put(storageGroupInfo, storageGroupInfo.getSgMemCost());\n+\n+    long newSgReportThreshold = calculateNewSgReportThreshold(storageGroupInfo);\n+    storageGroupInfo.setStorageGroupReportThreshold(newSgReportThreshold);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c4a98cc827e0c1fbad17b487dfcd433ed2aa6f"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc5NjU0Nw==", "bodyText": "We discussed with @jixuan1989 and @qiaojialin, and decided to set a dynamic sgReportThreshold in order to reduce the report frequency. There might be a better way to implement it because I found the current plan is not stable when insert TEXT data.", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r478796547", "createdAt": "2020-08-28T02:30:25Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TreeSet;\n+\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.flush.FlushManager;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupInfo;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileProcessor;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SystemInfo {\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final Logger logger = LoggerFactory.getLogger(SystemInfo.class);\n+\n+  private long totalSgMemCost;\n+  private long arrayPoolMemCost;\n+  private boolean rejected = false;\n+\n+  private Map<StorageGroupInfo, Long> reportedSgMemCostMap = new HashMap<>();\n+\n+  private static final double FLUSH_PROPORTION = config.getFlushProportion();\n+  private static final double REJECT_PROPORTION = config.getRejectProportion();\n+\n+  /**\n+   * Report applying a new out of buffered array to system. Attention: It should be invoked before\n+   * applying new OOB array actually.\n+   *\n+   * @param dataType data type of array\n+   * @param size     size of array\n+   * @return Return true if it's agreed when memory is enough.\n+   */\n+  public synchronized boolean applyNewOOBArray(TSDataType dataType, int size) {\n+    // if current memory is enough\n+    if (arrayPoolMemCost + totalSgMemCost + dataType.getDataTypeSize() * size\n+        < config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+      arrayPoolMemCost += dataType.getDataTypeSize() * size;\n+      logger.debug(\"Current total mem cost is {}\", (arrayPoolMemCost + totalSgMemCost));\n+      rejected = false;\n+      return true;\n+    } else if (arrayPoolMemCost + totalSgMemCost + dataType.getDataTypeSize() * size\n+        < config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {\n+      arrayPoolMemCost += dataType.getDataTypeSize() * size;\n+      // invoke flush()\n+      logger.debug(\"Out of buffer arraies are too large, call for flushing. \"\n+          + \"Current total mem cost is {}\", (arrayPoolMemCost + totalSgMemCost));\n+      rejected = false;\n+      flush();\n+      return true;\n+    } else {\n+      logger.debug(\"Out of buffer arraies are too large, call for flushing \"\n+          + \"and change system to rejected status...Current total mem cost is {}\", \n+          (arrayPoolMemCost + totalSgMemCost));\n+      rejected = true;\n+      flush();\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Report current mem cost of storage group to system.\n+   *\n+   * @param storageGroupInfo storage group\n+   * @param delta mem cost\n+   */\n+  public synchronized void reportStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    long delta = storageGroupInfo.getSgMemCost() - \n+        reportedSgMemCostMap.getOrDefault(storageGroupInfo, 0L);\n+    totalSgMemCost += delta;\n+    logger.debug(\"Report Storage Group Status to system. \"\n+        + \"Current array pool mem cost is {}, sg mem cost is {}.\", arrayPoolMemCost,\n+        totalSgMemCost);\n+    reportedSgMemCostMap.put(storageGroupInfo, storageGroupInfo.getSgMemCost());\n+\n+    long newSgReportThreshold = calculateNewSgReportThreshold(storageGroupInfo);\n+    storageGroupInfo.setStorageGroupReportThreshold(newSgReportThreshold);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzOTAxNA=="}, "originalCommit": {"oid": "75c4a98cc827e0c1fbad17b487dfcd433ed2aa6f"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzA2NTI1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMToyMTozNFrOHImYLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMjoyMzo0MlrOHInT-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc3OTQzOA==", "bodyText": "the maximum value is what?", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r478779438", "createdAt": "2020-08-28T01:21:34Z", "author": {"login": "mychaow"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TreeSet;\n+\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.flush.FlushManager;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupInfo;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileProcessor;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SystemInfo {\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final Logger logger = LoggerFactory.getLogger(SystemInfo.class);\n+\n+  private long totalSgMemCost;\n+  private long arrayPoolMemCost;\n+  private boolean rejected = false;\n+\n+  private Map<StorageGroupInfo, Long> reportedSgMemCostMap = new HashMap<>();\n+\n+  private static final double FLUSH_PROPORTION = config.getFlushProportion();\n+  private static final double REJECT_PROPORTION = config.getRejectProportion();\n+\n+  /**\n+   * Report applying a new out of buffered array to system. Attention: It should be invoked before\n+   * applying new OOB array actually.\n+   *\n+   * @param dataType data type of array\n+   * @param size     size of array\n+   * @return Return true if it's agreed when memory is enough.\n+   */\n+  public synchronized boolean applyNewOOBArray(TSDataType dataType, int size) {\n+    // if current memory is enough\n+    if (arrayPoolMemCost + totalSgMemCost + dataType.getDataTypeSize() * size\n+        < config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+      arrayPoolMemCost += dataType.getDataTypeSize() * size;\n+      logger.debug(\"Current total mem cost is {}\", (arrayPoolMemCost + totalSgMemCost));\n+      rejected = false;\n+      return true;\n+    } else if (arrayPoolMemCost + totalSgMemCost + dataType.getDataTypeSize() * size\n+        < config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {\n+      arrayPoolMemCost += dataType.getDataTypeSize() * size;\n+      // invoke flush()\n+      logger.debug(\"Out of buffer arraies are too large, call for flushing. \"\n+          + \"Current total mem cost is {}\", (arrayPoolMemCost + totalSgMemCost));\n+      rejected = false;\n+      flush();\n+      return true;\n+    } else {\n+      logger.debug(\"Out of buffer arraies are too large, call for flushing \"\n+          + \"and change system to rejected status...Current total mem cost is {}\", \n+          (arrayPoolMemCost + totalSgMemCost));\n+      rejected = true;\n+      flush();\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Report current mem cost of storage group to system.\n+   *\n+   * @param storageGroupInfo storage group\n+   * @param delta mem cost\n+   */\n+  public synchronized void reportStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    long delta = storageGroupInfo.getSgMemCost() - \n+        reportedSgMemCostMap.getOrDefault(storageGroupInfo, 0L);\n+    totalSgMemCost += delta;\n+    logger.debug(\"Report Storage Group Status to system. \"\n+        + \"Current array pool mem cost is {}, sg mem cost is {}.\", arrayPoolMemCost,\n+        totalSgMemCost);\n+    reportedSgMemCostMap.put(storageGroupInfo, storageGroupInfo.getSgMemCost());\n+\n+    long newSgReportThreshold = calculateNewSgReportThreshold(storageGroupInfo);\n+    storageGroupInfo.setStorageGroupReportThreshold(newSgReportThreshold);\n+    if (arrayPoolMemCost + totalSgMemCost\n+        >= config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+      logger.debug(\"The total storage group mem costs are too large, call for flushing. \"\n+          + \"Current sg cost is {}, array pool cost is {}\", totalSgMemCost, arrayPoolMemCost);\n+      flush();\n+    } \n+    if (arrayPoolMemCost + totalSgMemCost\n+        >= config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {\n+      logger.debug(\"Change system to reject status...\");\n+      rejected = true;\n+    }\n+  }\n+\n+  /**\n+   * Calculate new Sg report threshold. The maximum value is ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c4a98cc827e0c1fbad17b487dfcd433ed2aa6f"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc5NDc0NA==", "bodyText": "This part is what I'm fixing.\nReporting sg to systemInfo is only invoked when insert Text data. It's necessary to set a limit to sgReportThreshold, otherwise the sgReportThreshold will be too large and cause OOM.\nI'm trying to find a better way to limit the sgReportThreshold.", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r478794744", "createdAt": "2020-08-28T02:23:42Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TreeSet;\n+\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.flush.FlushManager;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupInfo;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileProcessor;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SystemInfo {\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final Logger logger = LoggerFactory.getLogger(SystemInfo.class);\n+\n+  private long totalSgMemCost;\n+  private long arrayPoolMemCost;\n+  private boolean rejected = false;\n+\n+  private Map<StorageGroupInfo, Long> reportedSgMemCostMap = new HashMap<>();\n+\n+  private static final double FLUSH_PROPORTION = config.getFlushProportion();\n+  private static final double REJECT_PROPORTION = config.getRejectProportion();\n+\n+  /**\n+   * Report applying a new out of buffered array to system. Attention: It should be invoked before\n+   * applying new OOB array actually.\n+   *\n+   * @param dataType data type of array\n+   * @param size     size of array\n+   * @return Return true if it's agreed when memory is enough.\n+   */\n+  public synchronized boolean applyNewOOBArray(TSDataType dataType, int size) {\n+    // if current memory is enough\n+    if (arrayPoolMemCost + totalSgMemCost + dataType.getDataTypeSize() * size\n+        < config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+      arrayPoolMemCost += dataType.getDataTypeSize() * size;\n+      logger.debug(\"Current total mem cost is {}\", (arrayPoolMemCost + totalSgMemCost));\n+      rejected = false;\n+      return true;\n+    } else if (arrayPoolMemCost + totalSgMemCost + dataType.getDataTypeSize() * size\n+        < config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {\n+      arrayPoolMemCost += dataType.getDataTypeSize() * size;\n+      // invoke flush()\n+      logger.debug(\"Out of buffer arraies are too large, call for flushing. \"\n+          + \"Current total mem cost is {}\", (arrayPoolMemCost + totalSgMemCost));\n+      rejected = false;\n+      flush();\n+      return true;\n+    } else {\n+      logger.debug(\"Out of buffer arraies are too large, call for flushing \"\n+          + \"and change system to rejected status...Current total mem cost is {}\", \n+          (arrayPoolMemCost + totalSgMemCost));\n+      rejected = true;\n+      flush();\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Report current mem cost of storage group to system.\n+   *\n+   * @param storageGroupInfo storage group\n+   * @param delta mem cost\n+   */\n+  public synchronized void reportStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    long delta = storageGroupInfo.getSgMemCost() - \n+        reportedSgMemCostMap.getOrDefault(storageGroupInfo, 0L);\n+    totalSgMemCost += delta;\n+    logger.debug(\"Report Storage Group Status to system. \"\n+        + \"Current array pool mem cost is {}, sg mem cost is {}.\", arrayPoolMemCost,\n+        totalSgMemCost);\n+    reportedSgMemCostMap.put(storageGroupInfo, storageGroupInfo.getSgMemCost());\n+\n+    long newSgReportThreshold = calculateNewSgReportThreshold(storageGroupInfo);\n+    storageGroupInfo.setStorageGroupReportThreshold(newSgReportThreshold);\n+    if (arrayPoolMemCost + totalSgMemCost\n+        >= config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+      logger.debug(\"The total storage group mem costs are too large, call for flushing. \"\n+          + \"Current sg cost is {}, array pool cost is {}\", totalSgMemCost, arrayPoolMemCost);\n+      flush();\n+    } \n+    if (arrayPoolMemCost + totalSgMemCost\n+        >= config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {\n+      logger.debug(\"Change system to reject status...\");\n+      rejected = true;\n+    }\n+  }\n+\n+  /**\n+   * Calculate new Sg report threshold. The maximum value is ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc3OTQzOA=="}, "originalCommit": {"oid": "75c4a98cc827e0c1fbad17b487dfcd433ed2aa6f"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzA3NTQ2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessorInfo.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMToyNzoxN1rOHImd9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzozMToxMVrOHIoTTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4MDkxNg==", "bodyText": "clear is thread safe? maybe several threads could call the clear()?", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r478780916", "createdAt": "2020-08-28T01:27:17Z", "author": {"login": "mychaow"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessorInfo.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+\n+/**\n+ * The TsFileProcessorInfo records the memory cost of this TsFileProcessor.\n+ */\n+public class TsFileProcessorInfo {\n+\n+  /**\n+   * Once tspInfo updated, report to storageGroupInfo that this TSP belongs to.\n+   */\n+  private StorageGroupInfo storageGroupInfo;\n+\n+  /**\n+   * The memory cost of the unsealed TsFileResources of this TSP\n+   */\n+  private long unsealedResourceMemCost;\n+  \n+  /**\n+   * The memory cost of TEXT data of this TSP\n+   */\n+  private long bytesMemCost;\n+\n+  /**\n+   * The memory cost of ChunkMetadata of this TSP\n+   */\n+  private long chunkMetadataMemCost;\n+\n+  /**\n+   * The memory cost of WAL of this TSP\n+   */\n+  private long walMemCost;\n+\n+  public TsFileProcessorInfo(StorageGroupInfo storageGroupInfo) {\n+    this.storageGroupInfo = storageGroupInfo;\n+    this.unsealedResourceMemCost = 0;\n+    this.bytesMemCost = 0;\n+    this.chunkMetadataMemCost = 0;\n+    this.walMemCost = IoTDBDescriptor.getInstance().getConfig().getWalBufferSize();\n+  }\n+\n+  public void addUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost += cost;\n+    storageGroupInfo.addUnsealedResourceMemCost(cost);\n+  }\n+\n+  public void addChunkMetadataMemCost(long cost) {\n+    chunkMetadataMemCost += cost;\n+    storageGroupInfo.addChunkMetadataMemCost(cost);\n+  }\n+\n+  public void addBytesMemCost(long cost) {\n+    bytesMemCost += cost;\n+    storageGroupInfo.addBytesMemCost(cost);\n+  }\n+\n+  /**\n+   * call this method when closing TSP\n+   */\n+  public void clear() {\n+    storageGroupInfo.resetUnsealedResourceMemCost(unsealedResourceMemCost);\n+    storageGroupInfo.resetChunkMetadataMemCost(chunkMetadataMemCost);\n+    storageGroupInfo.resetWalMemCost(walMemCost);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c4a98cc827e0c1fbad17b487dfcd433ed2aa6f"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwMDA4Mg==", "bodyText": "I think it's thread safe here, because this method only be called by flushOneMemTable in TSP and it be called by one thread only.", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r478800082", "createdAt": "2020-08-28T02:45:10Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessorInfo.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+\n+/**\n+ * The TsFileProcessorInfo records the memory cost of this TsFileProcessor.\n+ */\n+public class TsFileProcessorInfo {\n+\n+  /**\n+   * Once tspInfo updated, report to storageGroupInfo that this TSP belongs to.\n+   */\n+  private StorageGroupInfo storageGroupInfo;\n+\n+  /**\n+   * The memory cost of the unsealed TsFileResources of this TSP\n+   */\n+  private long unsealedResourceMemCost;\n+  \n+  /**\n+   * The memory cost of TEXT data of this TSP\n+   */\n+  private long bytesMemCost;\n+\n+  /**\n+   * The memory cost of ChunkMetadata of this TSP\n+   */\n+  private long chunkMetadataMemCost;\n+\n+  /**\n+   * The memory cost of WAL of this TSP\n+   */\n+  private long walMemCost;\n+\n+  public TsFileProcessorInfo(StorageGroupInfo storageGroupInfo) {\n+    this.storageGroupInfo = storageGroupInfo;\n+    this.unsealedResourceMemCost = 0;\n+    this.bytesMemCost = 0;\n+    this.chunkMetadataMemCost = 0;\n+    this.walMemCost = IoTDBDescriptor.getInstance().getConfig().getWalBufferSize();\n+  }\n+\n+  public void addUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost += cost;\n+    storageGroupInfo.addUnsealedResourceMemCost(cost);\n+  }\n+\n+  public void addChunkMetadataMemCost(long cost) {\n+    chunkMetadataMemCost += cost;\n+    storageGroupInfo.addChunkMetadataMemCost(cost);\n+  }\n+\n+  public void addBytesMemCost(long cost) {\n+    bytesMemCost += cost;\n+    storageGroupInfo.addBytesMemCost(cost);\n+  }\n+\n+  /**\n+   * call this method when closing TSP\n+   */\n+  public void clear() {\n+    storageGroupInfo.resetUnsealedResourceMemCost(unsealedResourceMemCost);\n+    storageGroupInfo.resetChunkMetadataMemCost(chunkMetadataMemCost);\n+    storageGroupInfo.resetWalMemCost(walMemCost);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4MDkxNg=="}, "originalCommit": {"oid": "75c4a98cc827e0c1fbad17b487dfcd433ed2aa6f"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwOTM5Ng==", "bodyText": "yes, one tsp clear is called only be one thread, but if  two TSPs are called clear(),  the storageGroupInfo.resetWalMemCost\uff08\uff09 maybe called by tow threads? and storageGroupInfo.resetWalMemCost is not thread safe.", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r478809396", "createdAt": "2020-08-28T03:24:51Z", "author": {"login": "mychaow"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessorInfo.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+\n+/**\n+ * The TsFileProcessorInfo records the memory cost of this TsFileProcessor.\n+ */\n+public class TsFileProcessorInfo {\n+\n+  /**\n+   * Once tspInfo updated, report to storageGroupInfo that this TSP belongs to.\n+   */\n+  private StorageGroupInfo storageGroupInfo;\n+\n+  /**\n+   * The memory cost of the unsealed TsFileResources of this TSP\n+   */\n+  private long unsealedResourceMemCost;\n+  \n+  /**\n+   * The memory cost of TEXT data of this TSP\n+   */\n+  private long bytesMemCost;\n+\n+  /**\n+   * The memory cost of ChunkMetadata of this TSP\n+   */\n+  private long chunkMetadataMemCost;\n+\n+  /**\n+   * The memory cost of WAL of this TSP\n+   */\n+  private long walMemCost;\n+\n+  public TsFileProcessorInfo(StorageGroupInfo storageGroupInfo) {\n+    this.storageGroupInfo = storageGroupInfo;\n+    this.unsealedResourceMemCost = 0;\n+    this.bytesMemCost = 0;\n+    this.chunkMetadataMemCost = 0;\n+    this.walMemCost = IoTDBDescriptor.getInstance().getConfig().getWalBufferSize();\n+  }\n+\n+  public void addUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost += cost;\n+    storageGroupInfo.addUnsealedResourceMemCost(cost);\n+  }\n+\n+  public void addChunkMetadataMemCost(long cost) {\n+    chunkMetadataMemCost += cost;\n+    storageGroupInfo.addChunkMetadataMemCost(cost);\n+  }\n+\n+  public void addBytesMemCost(long cost) {\n+    bytesMemCost += cost;\n+    storageGroupInfo.addBytesMemCost(cost);\n+  }\n+\n+  /**\n+   * call this method when closing TSP\n+   */\n+  public void clear() {\n+    storageGroupInfo.resetUnsealedResourceMemCost(unsealedResourceMemCost);\n+    storageGroupInfo.resetChunkMetadataMemCost(chunkMetadataMemCost);\n+    storageGroupInfo.resetWalMemCost(walMemCost);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4MDkxNg=="}, "originalCommit": {"oid": "75c4a98cc827e0c1fbad17b487dfcd433ed2aa6f"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMDk1OQ==", "bodyText": "You are right. storageGroupInfo.reset is not thread safe.\nI'll fix it soon. Thanks~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r478810959", "createdAt": "2020-08-28T03:31:11Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessorInfo.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+\n+/**\n+ * The TsFileProcessorInfo records the memory cost of this TsFileProcessor.\n+ */\n+public class TsFileProcessorInfo {\n+\n+  /**\n+   * Once tspInfo updated, report to storageGroupInfo that this TSP belongs to.\n+   */\n+  private StorageGroupInfo storageGroupInfo;\n+\n+  /**\n+   * The memory cost of the unsealed TsFileResources of this TSP\n+   */\n+  private long unsealedResourceMemCost;\n+  \n+  /**\n+   * The memory cost of TEXT data of this TSP\n+   */\n+  private long bytesMemCost;\n+\n+  /**\n+   * The memory cost of ChunkMetadata of this TSP\n+   */\n+  private long chunkMetadataMemCost;\n+\n+  /**\n+   * The memory cost of WAL of this TSP\n+   */\n+  private long walMemCost;\n+\n+  public TsFileProcessorInfo(StorageGroupInfo storageGroupInfo) {\n+    this.storageGroupInfo = storageGroupInfo;\n+    this.unsealedResourceMemCost = 0;\n+    this.bytesMemCost = 0;\n+    this.chunkMetadataMemCost = 0;\n+    this.walMemCost = IoTDBDescriptor.getInstance().getConfig().getWalBufferSize();\n+  }\n+\n+  public void addUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost += cost;\n+    storageGroupInfo.addUnsealedResourceMemCost(cost);\n+  }\n+\n+  public void addChunkMetadataMemCost(long cost) {\n+    chunkMetadataMemCost += cost;\n+    storageGroupInfo.addChunkMetadataMemCost(cost);\n+  }\n+\n+  public void addBytesMemCost(long cost) {\n+    bytesMemCost += cost;\n+    storageGroupInfo.addBytesMemCost(cost);\n+  }\n+\n+  /**\n+   * call this method when closing TSP\n+   */\n+  public void clear() {\n+    storageGroupInfo.resetUnsealedResourceMemCost(unsealedResourceMemCost);\n+    storageGroupInfo.resetChunkMetadataMemCost(chunkMetadataMemCost);\n+    storageGroupInfo.resetWalMemCost(walMemCost);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4MDkxNg=="}, "originalCommit": {"oid": "75c4a98cc827e0c1fbad17b487dfcd433ed2aa6f"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDQ0MTE3OnYy", "diffSide": "RIGHT", "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwODowNDo1NVrOHmVd0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo0NTozNVrOHm5eUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk1OTYzMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # If storage group increased more than this threshold, report to system. The default value is 16777216\n          \n          \n            \n            # If storage group increased more than this threshold (in byte), report to system. The default value is 16MB", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r509959632", "createdAt": "2020-10-22T08:04:55Z", "author": {"login": "samperson1997"}, "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "diffHunk": "@@ -232,14 +232,16 @@ write_read_free_memory_proportion=4:3:1:2\n primitive_array_size=32\n \n # Ratio of memory allocated for buffered arrays, 0.6 by default\n-buffered_arrays_memory_proportion=0.4\n+buffered_arrays_memory_proportion=0.6\n \n # Flush proportion for system, 0.5 by default\n flush_proportion=0.5\n \n # Reject proportion for system, 0.8 by default\n reject_proportion=0.8\n \n+# If storage group increased more than this threshold, report to system. The default value is 16777216", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f45e4388c655a6031124cf4ab79340b92ea4c3b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU0OTU4Ng==", "bodyText": "Fixed~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510549586", "createdAt": "2020-10-23T01:45:35Z", "author": {"login": "HTHou"}, "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "diffHunk": "@@ -232,14 +232,16 @@ write_read_free_memory_proportion=4:3:1:2\n primitive_array_size=32\n \n # Ratio of memory allocated for buffered arrays, 0.6 by default\n-buffered_arrays_memory_proportion=0.4\n+buffered_arrays_memory_proportion=0.6\n \n # Flush proportion for system, 0.5 by default\n flush_proportion=0.5\n \n # Reject proportion for system, 0.8 by default\n reject_proportion=0.8\n \n+# If storage group increased more than this threshold, report to system. The default value is 16777216", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk1OTYzMg=="}, "originalCommit": {"oid": "9f45e4388c655a6031124cf4ab79340b92ea4c3b"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODE1NzE1OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/utils/datastructure/LongTVListTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMToyNTo0NVrOHm5Muw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo0NTo1MVrOHm5ekA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU0NTA4Mw==", "bodyText": "no need to throw WriteProcessException in this test : )", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510545083", "createdAt": "2020-10-23T01:25:45Z", "author": {"login": "samperson1997"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/datastructure/LongTVListTest.java", "diffHunk": "@@ -30,7 +32,7 @@\n \n \n   @Test\n-  public void testLongTVList1() {\n+  public void testLongTVList1() throws WriteProcessException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU0OTY0OA==", "bodyText": "Fixed~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510549648", "createdAt": "2020-10-23T01:45:51Z", "author": {"login": "HTHou"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/datastructure/LongTVListTest.java", "diffHunk": "@@ -30,7 +32,7 @@\n \n \n   @Test\n-  public void testLongTVList1() {\n+  public void testLongTVList1() throws WriteProcessException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU0NTA4Mw=="}, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODE1NzM4OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/utils/datastructure/LongTVListTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMToyNTo1NVrOHm5M3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo0NjowMFrOHm5erQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU0NTExNg==", "bodyText": "remove unused import", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510545116", "createdAt": "2020-10-23T01:25:55Z", "author": {"login": "samperson1997"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/datastructure/LongTVListTest.java", "diffHunk": "@@ -21,6 +21,8 @@\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Random;\n+\n+import org.apache.iotdb.db.exception.WriteProcessException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU0OTY3Nw==", "bodyText": "Fix~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510549677", "createdAt": "2020-10-23T01:46:00Z", "author": {"login": "HTHou"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/datastructure/LongTVListTest.java", "diffHunk": "@@ -21,6 +21,8 @@\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Random;\n+\n+import org.apache.iotdb.db.exception.WriteProcessException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU0NTExNg=="}, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODE5MjIwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo0ODoyN1rOHm5g9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjoxMDoxNVrOHm506A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MDI2Mw==", "bodyText": "WriteProcessException could be removed in this class...", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510550263", "createdAt": "2020-10-23T01:48:27Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "diffHunk": "@@ -122,24 +130,24 @@ public void insertTablet(InsertTabletPlan insertTabletPlan, int start, int end)\n       throws WriteProcessException {\n     try {\n       write(insertTabletPlan, start, end);\n-      memSize += MemUtils.getRecordSize(insertTabletPlan, start, end);\n+      memSize += MemUtils.getRecordSize(insertTabletPlan, start, end, !enableMemControl);\n       totalPointsNum += (insertTabletPlan.getMeasurements().length - insertTabletPlan.getFailedMeasurementNumber())\n         * (end - start);\n     } catch (RuntimeException e) {\n-      throw new WriteProcessException(e.getMessage());\n+      throw new WriteProcessException(e);\n     }\n   }\n \n \n   @Override\n   public void write(String deviceId, String measurement, MeasurementSchema schema, long insertTime,\n-      Object objectValue) {\n+      Object objectValue) throws WriteProcessException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NTM2OA==", "bodyText": "Fixed~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510555368", "createdAt": "2020-10-23T02:10:15Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "diffHunk": "@@ -122,24 +130,24 @@ public void insertTablet(InsertTabletPlan insertTabletPlan, int start, int end)\n       throws WriteProcessException {\n     try {\n       write(insertTabletPlan, start, end);\n-      memSize += MemUtils.getRecordSize(insertTabletPlan, start, end);\n+      memSize += MemUtils.getRecordSize(insertTabletPlan, start, end, !enableMemControl);\n       totalPointsNum += (insertTabletPlan.getMeasurements().length - insertTabletPlan.getFailedMeasurementNumber())\n         * (end - start);\n     } catch (RuntimeException e) {\n-      throw new WriteProcessException(e.getMessage());\n+      throw new WriteProcessException(e);\n     }\n   }\n \n \n   @Override\n   public void write(String deviceId, String measurement, MeasurementSchema schema, long insertTime,\n-      Object objectValue) {\n+      Object objectValue) throws WriteProcessException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MDI2Mw=="}, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODE5MzU3OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/engine/memtable/PrimitiveMemTableTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo0OToxNFrOHm5hvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjoxMDozN1rOHm51UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MDQ2Mg==", "bodyText": "... so that all WriteProcessException in this test could be removed too", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510550462", "createdAt": "2020-10-23T01:49:14Z", "author": {"login": "samperson1997"}, "path": "server/src/test/java/org/apache/iotdb/db/engine/memtable/PrimitiveMemTableTest.java", "diffHunk": "@@ -49,7 +51,7 @@ public void setUp() {\n   }\n \n   @Test\n-  public void memSeriesSortIteratorTest() throws IOException {\n+  public void memSeriesSortIteratorTest() throws IOException, WriteProcessException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NTQ3Mw==", "bodyText": "Fixed~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510555473", "createdAt": "2020-10-23T02:10:37Z", "author": {"login": "HTHou"}, "path": "server/src/test/java/org/apache/iotdb/db/engine/memtable/PrimitiveMemTableTest.java", "diffHunk": "@@ -49,7 +51,7 @@ public void setUp() {\n   }\n \n   @Test\n-  public void memSeriesSortIteratorTest() throws IOException {\n+  public void memSeriesSortIteratorTest() throws IOException, WriteProcessException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MDQ2Mg=="}, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODE5NTg2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/IMemTable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo1MDozMlrOHm5jAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjoxMTo0MVrOHm52Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MDc4Nw==", "bodyText": "remove 3 WriteProcessException (one is in line 81)", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510550787", "createdAt": "2020-10-23T01:50:32Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/IMemTable.java", "diffHunk": "@@ -43,9 +43,9 @@\n   Map<String, Map<String, IWritableMemChunk>> getMemTableMap();\n \n   void write(String deviceId, String measurement, MeasurementSchema schema,\n-      long insertTime, Object objectValue);\n+      long insertTime, Object objectValue) throws WriteProcessException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NTc0Mw==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510555743", "createdAt": "2020-10-23T02:11:41Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/IMemTable.java", "diffHunk": "@@ -43,9 +43,9 @@\n   Map<String, Map<String, IWritableMemChunk>> getMemTableMap();\n \n   void write(String deviceId, String measurement, MeasurementSchema schema,\n-      long insertTime, Object objectValue);\n+      long insertTime, Object objectValue) throws WriteProcessException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MDc4Nw=="}, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODE5NzA1OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/engine/memtable/MemTableFlushTaskTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo1MToxOFrOHm5jvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjoxNDozMlrOHm54rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MDk3Mw==", "bodyText": "Remove WriteProcessException", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510550973", "createdAt": "2020-10-23T01:51:18Z", "author": {"login": "samperson1997"}, "path": "server/src/test/java/org/apache/iotdb/db/engine/memtable/MemTableFlushTaskTest.java", "diffHunk": "@@ -62,7 +63,7 @@ public void tearDown() throws Exception {\n   }\n \n   @Test\n-  public void testFlushMemTable() throws ExecutionException, InterruptedException, IOException {\n+  public void testFlushMemTable() throws ExecutionException, InterruptedException, IOException, WriteProcessException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NjMzMg==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510556332", "createdAt": "2020-10-23T02:14:32Z", "author": {"login": "HTHou"}, "path": "server/src/test/java/org/apache/iotdb/db/engine/memtable/MemTableFlushTaskTest.java", "diffHunk": "@@ -62,7 +63,7 @@ public void tearDown() throws Exception {\n   }\n \n   @Test\n-  public void testFlushMemTable() throws ExecutionException, InterruptedException, IOException {\n+  public void testFlushMemTable() throws ExecutionException, InterruptedException, IOException, WriteProcessException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MDk3Mw=="}, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODE5ODE0OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/engine/memtable/MemTableTestUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo1MTo1N1rOHm5kVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjoxNDozOVrOHm54yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MTEyNA==", "bodyText": "Remove WriteProcessException", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510551124", "createdAt": "2020-10-23T01:51:57Z", "author": {"login": "samperson1997"}, "path": "server/src/test/java/org/apache/iotdb/db/engine/memtable/MemTableTestUtils.java", "diffHunk": "@@ -40,7 +41,7 @@\n   }\n \n   public static void produceData(IMemTable iMemTable, long startTime, long endTime, String deviceId,\n-      String measurementId, TSDataType dataType) {\n+      String measurementId, TSDataType dataType) throws WriteProcessException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NjM2Mw==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510556363", "createdAt": "2020-10-23T02:14:39Z", "author": {"login": "HTHou"}, "path": "server/src/test/java/org/apache/iotdb/db/engine/memtable/MemTableTestUtils.java", "diffHunk": "@@ -40,7 +41,7 @@\n   }\n \n   public static void produceData(IMemTable iMemTable, long startTime, long endTime, String deviceId,\n-      String measurementId, TSDataType dataType) {\n+      String measurementId, TSDataType dataType) throws WriteProcessException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MTEyNA=="}, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODIwNzc0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo1Nzo0OVrOHm5p5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjoxNToxNlrOHm55bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MjU1MA==", "bodyText": "Remove WriteProcessException", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510552550", "createdAt": "2020-10-23T01:57:49Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "diffHunk": "@@ -100,15 +107,16 @@ private IWritableMemChunk createIfNotExistAndGet(String deviceId, String measure\n   protected abstract IWritableMemChunk genMemSeries(MeasurementSchema schema);\n \n   @Override\n-  public void insert(InsertRowPlan insertRowPlan) {\n+  public void insert(InsertRowPlan insertRowPlan) throws WriteProcessException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NjUyNA==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510556524", "createdAt": "2020-10-23T02:15:16Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "diffHunk": "@@ -100,15 +107,16 @@ private IWritableMemChunk createIfNotExistAndGet(String deviceId, String measure\n   protected abstract IWritableMemChunk genMemSeries(MeasurementSchema schema);\n \n   @Override\n-  public void insert(InsertRowPlan insertRowPlan) {\n+  public void insert(InsertRowPlan insertRowPlan) throws WriteProcessException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MjU1MA=="}, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODI0NjkyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/utils/MemUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjoyMjo1N1rOHm6AUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwMjowNjowM1rOHn-3uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1ODI5MA==", "bodyText": "Would modifying to this be better?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * If mem control enabled, do not get text data size here, the size will add to memtable\n          \n          \n            \n               * If mem control enabled, do not add text data size here, the size will add to memtable", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510558290", "createdAt": "2020-10-23T02:22:57Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/MemUtils.java", "diffHunk": "@@ -45,8 +45,11 @@ private MemUtils(){\n \n   /**\n    * function for getting the value size.\n+   * If mem control enabled, do not get text data size here, the size will add to memtable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY4NjU4NA==", "bodyText": "Yes, it's better. Fixed~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511686584", "createdAt": "2020-10-26T02:06:03Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/MemUtils.java", "diffHunk": "@@ -45,8 +45,11 @@ private MemUtils(){\n \n   /**\n    * function for getting the value size.\n+   * If mem control enabled, do not get text data size here, the size will add to memtable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1ODI5MA=="}, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODI0NzQ2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/utils/MemUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjoyMzoxNlrOHm6Anw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwMjowNjoxM1rOHn-34w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1ODM2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * If mem control enabled, do not get text data size here, the size will add to memtable\n          \n          \n            \n               * If mem control enabled, do not add text data size here, the size will add to memtable", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510558367", "createdAt": "2020-10-23T02:23:16Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/MemUtils.java", "diffHunk": "@@ -70,7 +73,12 @@ public static long getBinarySize(Binary value) {\n         .sizeOf(value.getValues());\n   }\n \n-  public static long getRecordSize(InsertTabletPlan insertTabletPlan, int start, int end) {\n+  /**\n+   * If mem control enabled, do not get text data size here, the size will add to memtable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY4NjYyNw==", "bodyText": "Fixed~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511686627", "createdAt": "2020-10-26T02:06:13Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/MemUtils.java", "diffHunk": "@@ -70,7 +73,12 @@ public static long getBinarySize(Binary value) {\n         .sizeOf(value.getValues());\n   }\n \n-  public static long getRecordSize(InsertTabletPlan insertTabletPlan, int start, int end) {\n+  /**\n+   * If mem control enabled, do not get text data size here, the size will add to memtable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1ODM2Nw=="}, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODI1NzcwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjoyOTo0OFrOHm6GnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwMjoxMDoyNFrOHn-63Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1OTkwMQ==", "bodyText": "indent is not correct", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510559901", "createdAt": "2020-10-23T02:29:48Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -529,23 +569,22 @@ private PartialPath deleteOneTimeseriesAndUpdateStatistics(PartialPath path)\n     removeFromTagInvertedIndex(pair.right);\n     PartialPath storageGroupPath = pair.left;\n \n-    // TODO: delete the path node and all its ancestors\n-    mNodeCache.clear();\n-    try {\n-      IoTDBConfigDynamicAdapter.getInstance().addOrDeleteTimeSeries(-1);\n-    } catch (ConfigAdjusterException e) {\n-      throw new MetadataException(e);\n-    }\n+      // update statistics in schemaDataTypeNumMap\n+      updateSchemaDataTypeNumMap(pair.right.getSchema().getType(), -1);\n+\n+      // TODO: delete the path node and all its ancestors\n+      mNodeCache.clear();\n \n-    if (config.isEnableParameterAdapter()) {\n-      PartialPath storageGroup = getStorageGroupPath(path);\n-      int size = seriesNumberInStorageGroups.get(storageGroup.getFullPath());\n-      seriesNumberInStorageGroups.put(storageGroup.getFullPath(), size - 1);\n-      if (size == maxSeriesNumberAmongStorageGroup) {\n-        seriesNumberInStorageGroups.values().stream().max(Integer::compareTo)\n-            .ifPresent(val -> maxSeriesNumberAmongStorageGroup = val);\n+      if (config.isEnableActiveTimeseriesCounter()) {\n+        PartialPath storageGroup = getStorageGroupPath(path);\n+        int size = seriesNumberInStorageGroups.get(storageGroup.getFullPath());\n+        seriesNumberInStorageGroups.put(storageGroup.getFullPath(), size - 1);\n+        totalSeriesNumber--;\n+        if (size == maxSeriesNumberAmongStorageGroup) {\n+          seriesNumberInStorageGroups.values().stream().max(Integer::compareTo)\n+              .ifPresent(val -> maxSeriesNumberAmongStorageGroup = val);\n+        }\n       }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY4NzM4OQ==", "bodyText": "Nice catch! Fixed~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511687389", "createdAt": "2020-10-26T02:10:24Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -529,23 +569,22 @@ private PartialPath deleteOneTimeseriesAndUpdateStatistics(PartialPath path)\n     removeFromTagInvertedIndex(pair.right);\n     PartialPath storageGroupPath = pair.left;\n \n-    // TODO: delete the path node and all its ancestors\n-    mNodeCache.clear();\n-    try {\n-      IoTDBConfigDynamicAdapter.getInstance().addOrDeleteTimeSeries(-1);\n-    } catch (ConfigAdjusterException e) {\n-      throw new MetadataException(e);\n-    }\n+      // update statistics in schemaDataTypeNumMap\n+      updateSchemaDataTypeNumMap(pair.right.getSchema().getType(), -1);\n+\n+      // TODO: delete the path node and all its ancestors\n+      mNodeCache.clear();\n \n-    if (config.isEnableParameterAdapter()) {\n-      PartialPath storageGroup = getStorageGroupPath(path);\n-      int size = seriesNumberInStorageGroups.get(storageGroup.getFullPath());\n-      seriesNumberInStorageGroups.put(storageGroup.getFullPath(), size - 1);\n-      if (size == maxSeriesNumberAmongStorageGroup) {\n-        seriesNumberInStorageGroups.values().stream().max(Integer::compareTo)\n-            .ifPresent(val -> maxSeriesNumberAmongStorageGroup = val);\n+      if (config.isEnableActiveTimeseriesCounter()) {\n+        PartialPath storageGroup = getStorageGroupPath(path);\n+        int size = seriesNumberInStorageGroups.get(storageGroup.getFullPath());\n+        seriesNumberInStorageGroups.put(storageGroup.getFullPath(), size - 1);\n+        totalSeriesNumber--;\n+        if (size == maxSeriesNumberAmongStorageGroup) {\n+          seriesNumberInStorageGroups.values().stream().max(Integer::compareTo)\n+              .ifPresent(val -> maxSeriesNumberAmongStorageGroup = val);\n+        }\n       }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1OTkwMQ=="}, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODI2MzM5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjozMzoyOVrOHm6J5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwMjowODozOFrOHn-5gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU2MDc0MA==", "bodyText": "to be consistent with maxSeriesNumberAmongStorageGroup and  totalSeriesNumber below\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private int reportedDataTypeTotalNum;\n          \n          \n            \n              private long reportedDataTypeTotalNum;", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r510560740", "createdAt": "2020-10-23T02:33:29Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -119,15 +118,41 @@\n   private RandomDeleteCache<PartialPath, MNode> mNodeCache;\n   // tag key -> tag value -> LeafMNode\n   private Map<String, Map<String, Set<MeasurementMNode>>> tagIndex = new HashMap<>();\n+\n+  // data type -> number\n+  private Map<TSDataType, Integer> schemaDataTypeNumMap = new ConcurrentHashMap<>();\n+  // reported total series number\n+  private int reportedDataTypeTotalNum;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY4NzA0Mw==", "bodyText": "Fixed~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511687043", "createdAt": "2020-10-26T02:08:38Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -119,15 +118,41 @@\n   private RandomDeleteCache<PartialPath, MNode> mNodeCache;\n   // tag key -> tag value -> LeafMNode\n   private Map<String, Map<String, Set<MeasurementMNode>>> tagIndex = new HashMap<>();\n+\n+  // data type -> number\n+  private Map<TSDataType, Integer> schemaDataTypeNumMap = new ConcurrentHashMap<>();\n+  // reported total series number\n+  private int reportedDataTypeTotalNum;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU2MDc0MA=="}, "originalCommit": {"oid": "e0efef2f57efdd987423ba3b5b7ccdc73d99603b"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjMyMDYzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/flush/FlushManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNzozNToyOVrOHoDfog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwOToxMDoxMVrOHoGa8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc2MjMzOA==", "bodyText": "Is this method used?", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511762338", "createdAt": "2020-10-26T07:35:29Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/flush/FlushManager.java", "diffHunk": "@@ -96,6 +96,13 @@ public void runMayThrow() {\n     }\n   }\n \n+  /**\n+   * get the current size of flush queue\n+   */\n+  public int getTsFileProcessorQueueSize() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgxMDI4OA==", "bodyText": "This method is no longer useful, I'll remove it.", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511810288", "createdAt": "2020-10-26T09:10:11Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/flush/FlushManager.java", "diffHunk": "@@ -96,6 +96,13 @@ public void runMayThrow() {\n     }\n   }\n \n+  /**\n+   * get the current size of flush queue\n+   */\n+  public int getTsFileProcessorQueueSize() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc2MjMzOA=="}, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjM0Mjk2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessorInfo.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNzo0MzozOVrOHoDsYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxMzozOTowNlrOHo8pJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc2NTYwMw==", "bodyText": "Have you fixed the concurrent issue? I think current implementation isn't thread safe", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511765603", "createdAt": "2020-10-26T07:43:39Z", "author": {"login": "SilverNarcissus"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessorInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+\n+/**\n+ * The TsFileProcessorInfo records the memory cost of this TsFileProcessor.\n+ */\n+public class TsFileProcessorInfo {\n+\n+  /**\n+   * Once tspInfo updated, report to storageGroupInfo that this TSP belongs to.\n+   */\n+  private StorageGroupInfo storageGroupInfo;\n+\n+  /**\n+   * The memory cost of the unsealed TsFileResources of this TSP\n+   */\n+  private long unsealedResourceMemCost;\n+  \n+  /**\n+   * The memory cost of memTable of this TSP\n+   */\n+  private long memTableCost;\n+\n+  /**\n+   * The memory cost of ChunkMetadata of this TSP\n+   */\n+  private long chunkMetadataMemCost;\n+\n+  /**\n+   * The memory cost of WAL of this TSP\n+   */\n+  private long walMemCost;\n+\n+  public TsFileProcessorInfo(StorageGroupInfo storageGroupInfo) {\n+    this.storageGroupInfo = storageGroupInfo;\n+    this.unsealedResourceMemCost = 0;\n+    this.memTableCost = 0;\n+    this.chunkMetadataMemCost = 0;\n+    this.walMemCost = IoTDBDescriptor.getInstance().getConfig().getWalBufferSize();\n+  }\n+\n+  public void addUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost += cost;\n+    storageGroupInfo.addUnsealedResourceMemCost(cost);\n+  }\n+\n+  public void addChunkMetadataMemCost(long cost) {\n+    chunkMetadataMemCost += cost;\n+    storageGroupInfo.addChunkMetadataMemCost(cost);\n+  }\n+\n+  public void addMemTableCost(long cost) {\n+    memTableCost += cost;\n+    storageGroupInfo.addMemTableCost(cost);\n+  }\n+\n+  /**\n+   * call this method when closing TSP\n+   */\n+  public void clear() {\n+    storageGroupInfo.resetUnsealedResourceMemCost(unsealedResourceMemCost);\n+    storageGroupInfo.resetChunkMetadataMemCost(chunkMetadataMemCost);\n+    storageGroupInfo.resetWalMemCost(walMemCost);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQ1NDc3NA==", "bodyText": "This method is only called by endFile() in TsFileProcessor. Can you let me know why it has a concurrent issue?", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r512454774", "createdAt": "2020-10-27T07:02:03Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessorInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+\n+/**\n+ * The TsFileProcessorInfo records the memory cost of this TsFileProcessor.\n+ */\n+public class TsFileProcessorInfo {\n+\n+  /**\n+   * Once tspInfo updated, report to storageGroupInfo that this TSP belongs to.\n+   */\n+  private StorageGroupInfo storageGroupInfo;\n+\n+  /**\n+   * The memory cost of the unsealed TsFileResources of this TSP\n+   */\n+  private long unsealedResourceMemCost;\n+  \n+  /**\n+   * The memory cost of memTable of this TSP\n+   */\n+  private long memTableCost;\n+\n+  /**\n+   * The memory cost of ChunkMetadata of this TSP\n+   */\n+  private long chunkMetadataMemCost;\n+\n+  /**\n+   * The memory cost of WAL of this TSP\n+   */\n+  private long walMemCost;\n+\n+  public TsFileProcessorInfo(StorageGroupInfo storageGroupInfo) {\n+    this.storageGroupInfo = storageGroupInfo;\n+    this.unsealedResourceMemCost = 0;\n+    this.memTableCost = 0;\n+    this.chunkMetadataMemCost = 0;\n+    this.walMemCost = IoTDBDescriptor.getInstance().getConfig().getWalBufferSize();\n+  }\n+\n+  public void addUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost += cost;\n+    storageGroupInfo.addUnsealedResourceMemCost(cost);\n+  }\n+\n+  public void addChunkMetadataMemCost(long cost) {\n+    chunkMetadataMemCost += cost;\n+    storageGroupInfo.addChunkMetadataMemCost(cost);\n+  }\n+\n+  public void addMemTableCost(long cost) {\n+    memTableCost += cost;\n+    storageGroupInfo.addMemTableCost(cost);\n+  }\n+\n+  /**\n+   * call this method when closing TSP\n+   */\n+  public void clear() {\n+    storageGroupInfo.resetUnsealedResourceMemCost(unsealedResourceMemCost);\n+    storageGroupInfo.resetChunkMetadataMemCost(chunkMetadataMemCost);\n+    storageGroupInfo.resetWalMemCost(walMemCost);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc2NTYwMw=="}, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQ1Njg3MA==", "bodyText": "If two tsfile Porcessor end their file concurrently. StorageGroupInfo.WalMemCost will be write concurrently. That's may cause a concurrent issue.", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r512456870", "createdAt": "2020-10-27T07:08:00Z", "author": {"login": "SilverNarcissus"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessorInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+\n+/**\n+ * The TsFileProcessorInfo records the memory cost of this TsFileProcessor.\n+ */\n+public class TsFileProcessorInfo {\n+\n+  /**\n+   * Once tspInfo updated, report to storageGroupInfo that this TSP belongs to.\n+   */\n+  private StorageGroupInfo storageGroupInfo;\n+\n+  /**\n+   * The memory cost of the unsealed TsFileResources of this TSP\n+   */\n+  private long unsealedResourceMemCost;\n+  \n+  /**\n+   * The memory cost of memTable of this TSP\n+   */\n+  private long memTableCost;\n+\n+  /**\n+   * The memory cost of ChunkMetadata of this TSP\n+   */\n+  private long chunkMetadataMemCost;\n+\n+  /**\n+   * The memory cost of WAL of this TSP\n+   */\n+  private long walMemCost;\n+\n+  public TsFileProcessorInfo(StorageGroupInfo storageGroupInfo) {\n+    this.storageGroupInfo = storageGroupInfo;\n+    this.unsealedResourceMemCost = 0;\n+    this.memTableCost = 0;\n+    this.chunkMetadataMemCost = 0;\n+    this.walMemCost = IoTDBDescriptor.getInstance().getConfig().getWalBufferSize();\n+  }\n+\n+  public void addUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost += cost;\n+    storageGroupInfo.addUnsealedResourceMemCost(cost);\n+  }\n+\n+  public void addChunkMetadataMemCost(long cost) {\n+    chunkMetadataMemCost += cost;\n+    storageGroupInfo.addChunkMetadataMemCost(cost);\n+  }\n+\n+  public void addMemTableCost(long cost) {\n+    memTableCost += cost;\n+    storageGroupInfo.addMemTableCost(cost);\n+  }\n+\n+  /**\n+   * call this method when closing TSP\n+   */\n+  public void clear() {\n+    storageGroupInfo.resetUnsealedResourceMemCost(unsealedResourceMemCost);\n+    storageGroupInfo.resetChunkMetadataMemCost(chunkMetadataMemCost);\n+    storageGroupInfo.resetWalMemCost(walMemCost);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc2NTYwMw=="}, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQ1Njk3OA==", "bodyText": "Same as UnsealedResourceMemCost and ChunkMetadataMemCost.", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r512456978", "createdAt": "2020-10-27T07:08:19Z", "author": {"login": "SilverNarcissus"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessorInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+\n+/**\n+ * The TsFileProcessorInfo records the memory cost of this TsFileProcessor.\n+ */\n+public class TsFileProcessorInfo {\n+\n+  /**\n+   * Once tspInfo updated, report to storageGroupInfo that this TSP belongs to.\n+   */\n+  private StorageGroupInfo storageGroupInfo;\n+\n+  /**\n+   * The memory cost of the unsealed TsFileResources of this TSP\n+   */\n+  private long unsealedResourceMemCost;\n+  \n+  /**\n+   * The memory cost of memTable of this TSP\n+   */\n+  private long memTableCost;\n+\n+  /**\n+   * The memory cost of ChunkMetadata of this TSP\n+   */\n+  private long chunkMetadataMemCost;\n+\n+  /**\n+   * The memory cost of WAL of this TSP\n+   */\n+  private long walMemCost;\n+\n+  public TsFileProcessorInfo(StorageGroupInfo storageGroupInfo) {\n+    this.storageGroupInfo = storageGroupInfo;\n+    this.unsealedResourceMemCost = 0;\n+    this.memTableCost = 0;\n+    this.chunkMetadataMemCost = 0;\n+    this.walMemCost = IoTDBDescriptor.getInstance().getConfig().getWalBufferSize();\n+  }\n+\n+  public void addUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost += cost;\n+    storageGroupInfo.addUnsealedResourceMemCost(cost);\n+  }\n+\n+  public void addChunkMetadataMemCost(long cost) {\n+    chunkMetadataMemCost += cost;\n+    storageGroupInfo.addChunkMetadataMemCost(cost);\n+  }\n+\n+  public void addMemTableCost(long cost) {\n+    memTableCost += cost;\n+    storageGroupInfo.addMemTableCost(cost);\n+  }\n+\n+  /**\n+   * call this method when closing TSP\n+   */\n+  public void clear() {\n+    storageGroupInfo.resetUnsealedResourceMemCost(unsealedResourceMemCost);\n+    storageGroupInfo.resetChunkMetadataMemCost(chunkMetadataMemCost);\n+    storageGroupInfo.resetWalMemCost(walMemCost);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc2NTYwMw=="}, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUwNTU0OQ==", "bodyText": "Thanks, makes sense~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r512505549", "createdAt": "2020-10-27T08:43:19Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessorInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+\n+/**\n+ * The TsFileProcessorInfo records the memory cost of this TsFileProcessor.\n+ */\n+public class TsFileProcessorInfo {\n+\n+  /**\n+   * Once tspInfo updated, report to storageGroupInfo that this TSP belongs to.\n+   */\n+  private StorageGroupInfo storageGroupInfo;\n+\n+  /**\n+   * The memory cost of the unsealed TsFileResources of this TSP\n+   */\n+  private long unsealedResourceMemCost;\n+  \n+  /**\n+   * The memory cost of memTable of this TSP\n+   */\n+  private long memTableCost;\n+\n+  /**\n+   * The memory cost of ChunkMetadata of this TSP\n+   */\n+  private long chunkMetadataMemCost;\n+\n+  /**\n+   * The memory cost of WAL of this TSP\n+   */\n+  private long walMemCost;\n+\n+  public TsFileProcessorInfo(StorageGroupInfo storageGroupInfo) {\n+    this.storageGroupInfo = storageGroupInfo;\n+    this.unsealedResourceMemCost = 0;\n+    this.memTableCost = 0;\n+    this.chunkMetadataMemCost = 0;\n+    this.walMemCost = IoTDBDescriptor.getInstance().getConfig().getWalBufferSize();\n+  }\n+\n+  public void addUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost += cost;\n+    storageGroupInfo.addUnsealedResourceMemCost(cost);\n+  }\n+\n+  public void addChunkMetadataMemCost(long cost) {\n+    chunkMetadataMemCost += cost;\n+    storageGroupInfo.addChunkMetadataMemCost(cost);\n+  }\n+\n+  public void addMemTableCost(long cost) {\n+    memTableCost += cost;\n+    storageGroupInfo.addMemTableCost(cost);\n+  }\n+\n+  /**\n+   * call this method when closing TSP\n+   */\n+  public void clear() {\n+    storageGroupInfo.resetUnsealedResourceMemCost(unsealedResourceMemCost);\n+    storageGroupInfo.resetChunkMetadataMemCost(chunkMetadataMemCost);\n+    storageGroupInfo.resetWalMemCost(walMemCost);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc2NTYwMw=="}, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5ODY2Mg==", "bodyText": "Fixed~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r512698662", "createdAt": "2020-10-27T13:39:06Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessorInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+\n+/**\n+ * The TsFileProcessorInfo records the memory cost of this TsFileProcessor.\n+ */\n+public class TsFileProcessorInfo {\n+\n+  /**\n+   * Once tspInfo updated, report to storageGroupInfo that this TSP belongs to.\n+   */\n+  private StorageGroupInfo storageGroupInfo;\n+\n+  /**\n+   * The memory cost of the unsealed TsFileResources of this TSP\n+   */\n+  private long unsealedResourceMemCost;\n+  \n+  /**\n+   * The memory cost of memTable of this TSP\n+   */\n+  private long memTableCost;\n+\n+  /**\n+   * The memory cost of ChunkMetadata of this TSP\n+   */\n+  private long chunkMetadataMemCost;\n+\n+  /**\n+   * The memory cost of WAL of this TSP\n+   */\n+  private long walMemCost;\n+\n+  public TsFileProcessorInfo(StorageGroupInfo storageGroupInfo) {\n+    this.storageGroupInfo = storageGroupInfo;\n+    this.unsealedResourceMemCost = 0;\n+    this.memTableCost = 0;\n+    this.chunkMetadataMemCost = 0;\n+    this.walMemCost = IoTDBDescriptor.getInstance().getConfig().getWalBufferSize();\n+  }\n+\n+  public void addUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost += cost;\n+    storageGroupInfo.addUnsealedResourceMemCost(cost);\n+  }\n+\n+  public void addChunkMetadataMemCost(long cost) {\n+    chunkMetadataMemCost += cost;\n+    storageGroupInfo.addChunkMetadataMemCost(cost);\n+  }\n+\n+  public void addMemTableCost(long cost) {\n+    memTableCost += cost;\n+    storageGroupInfo.addMemTableCost(cost);\n+  }\n+\n+  /**\n+   * call this method when closing TSP\n+   */\n+  public void clear() {\n+    storageGroupInfo.resetUnsealedResourceMemCost(unsealedResourceMemCost);\n+    storageGroupInfo.resetChunkMetadataMemCost(chunkMetadataMemCost);\n+    storageGroupInfo.resetWalMemCost(walMemCost);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc2NTYwMw=="}, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjM0NDE1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/IMemTable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNzo0NDowM1rOHoDtFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwOToxMzozMVrOHoGioQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc2NTc4Mg==", "bodyText": "Remove WriteProcessException", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511765782", "createdAt": "2020-10-26T07:44:03Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/IMemTable.java", "diffHunk": "@@ -45,7 +45,7 @@\n   void write(String deviceId, String measurement, MeasurementSchema schema,\n       long insertTime, Object objectValue);\n \n-  void write(InsertTabletPlan insertTabletPlan, int start, int end);\n+  void write(InsertTabletPlan insertTabletPlan, int start, int end) throws WriteProcessException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgxMjI1Nw==", "bodyText": "Fixed~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511812257", "createdAt": "2020-10-26T09:13:31Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/IMemTable.java", "diffHunk": "@@ -45,7 +45,7 @@\n   void write(String deviceId, String measurement, MeasurementSchema schema,\n       long insertTime, Object objectValue);\n \n-  void write(InsertTabletPlan insertTabletPlan, int start, int end);\n+  void write(InsertTabletPlan insertTabletPlan, int start, int end) throws WriteProcessException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc2NTc4Mg=="}, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjM0NjQ3OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/engine/memtable/PrimitiveMemTableTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNzo0NDo1NlrOHoDuew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwOToxMzo0NFrOHoGjGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc2NjEzOQ==", "bodyText": "Remove all WriteProcessException in this test (4 in functions and 1 in import)", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511766139", "createdAt": "2020-10-26T07:44:56Z", "author": {"login": "samperson1997"}, "path": "server/src/test/java/org/apache/iotdb/db/engine/memtable/PrimitiveMemTableTest.java", "diffHunk": "@@ -22,7 +22,9 @@\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.Random;\n+\n import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.exception.WriteProcessException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgxMjM3Ng==", "bodyText": "Thanks, fixed~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511812376", "createdAt": "2020-10-26T09:13:44Z", "author": {"login": "HTHou"}, "path": "server/src/test/java/org/apache/iotdb/db/engine/memtable/PrimitiveMemTableTest.java", "diffHunk": "@@ -22,7 +22,9 @@\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.Random;\n+\n import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.exception.WriteProcessException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc2NjEzOQ=="}, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjQzNTE1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwODoxNDozNFrOHoEjEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMzo0NDoyMlrOHoQIug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc3OTYwMg==", "bodyText": "\"1.1\" should be a static final constant and have a descriptive name", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511779602", "createdAt": "2020-10-26T08:14:34Z", "author": {"login": "SilverNarcissus"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -608,13 +644,28 @@ public void deleteStorageGroups(List<PartialPath> storageGroups) throws Metadata\n           logWriter.deleteStorageGroup(storageGroup.getFullPath());\n         }\n       }\n-    } catch (ConfigAdjusterException e) {\n-      throw new MetadataException(e);\n     } catch (IOException e) {\n       throw new MetadataException(e.getMessage());\n     }\n   }\n \n+  /**\n+   * update statistics in schemaDataTypeNumMap\n+   *\n+   * @param type data type\n+   * @param num 1 for creating timeseries and -1 for deleting timeseries\n+   */\n+  private void updateSchemaDataTypeNumMap(TSDataType type, int num) {\n+    schemaDataTypeNumMap.put(type, schemaDataTypeNumMap.getOrDefault(type, 0) + num);\n+    schemaDataTypeNumMap.put(TSDataType.INT64,\n+        schemaDataTypeNumMap.getOrDefault(TSDataType.INT64, 0) + num);\n+    int currentDataTypeTotalNum = schemaDataTypeNumMap.values().size();\n+    if (num > 0 && currentDataTypeTotalNum >= reportedDataTypeTotalNum * 1.1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2OTQ2Ng==", "bodyText": "Fixed~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511969466", "createdAt": "2020-10-26T13:44:22Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -608,13 +644,28 @@ public void deleteStorageGroups(List<PartialPath> storageGroups) throws Metadata\n           logWriter.deleteStorageGroup(storageGroup.getFullPath());\n         }\n       }\n-    } catch (ConfigAdjusterException e) {\n-      throw new MetadataException(e);\n     } catch (IOException e) {\n       throw new MetadataException(e.getMessage());\n     }\n   }\n \n+  /**\n+   * update statistics in schemaDataTypeNumMap\n+   *\n+   * @param type data type\n+   * @param num 1 for creating timeseries and -1 for deleting timeseries\n+   */\n+  private void updateSchemaDataTypeNumMap(TSDataType type, int num) {\n+    schemaDataTypeNumMap.put(type, schemaDataTypeNumMap.getOrDefault(type, 0) + num);\n+    schemaDataTypeNumMap.put(TSDataType.INT64,\n+        schemaDataTypeNumMap.getOrDefault(TSDataType.INT64, 0) + num);\n+    int currentDataTypeTotalNum = schemaDataTypeNumMap.values().size();\n+    if (num > 0 && currentDataTypeTotalNum >= reportedDataTypeTotalNum * 1.1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc3OTYwMg=="}, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 283}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjQ2MjY2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/rescon/PrimitiveArrayManager.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwODoyMjo0NlrOHoEzaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMzo0NDoxMFrOHoQIIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc4Mzc4NA==", "bodyText": "We may not get here, so we should return null and add some comments", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511783784", "createdAt": "2020-10-26T08:22:46Z", "author": {"login": "SilverNarcissus"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/PrimitiveArrayManager.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Manage all primitive data list in memory, including get and release operation.\n+ */\n+public class PrimitiveArrayManager {\n+\n+  /**\n+   * data type -> ArrayDeque<Array>\n+   */\n+  private static final Map<TSDataType, ArrayDeque<Object>> bufferedArraysMap = new EnumMap<>(\n+      TSDataType.class);\n+\n+  /**\n+   * data type -> current number of buffered arrays\n+   */\n+  private static final Map<TSDataType, Integer> bufferedArraysNumMap = new EnumMap<>(\n+      TSDataType.class);\n+\n+  /**\n+   * data type -> ratio of data type in schema, which could be seen as recommended ratio\n+   */\n+  private static final Map<TSDataType, Double> bufferedArraysNumRatio = new EnumMap<>(\n+      TSDataType.class);\n+\n+  private static final Logger logger = LoggerFactory.getLogger(PrimitiveArrayManager.class);\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+\n+  public static final int ARRAY_SIZE = config.getPrimitiveArraySize();\n+\n+  /**\n+   * threshold total size of arrays for all data types\n+   */\n+  private static final double BUFFERED_ARRAY_SIZE_THRESHOLD =\n+      config.getAllocateMemoryForWrite() * config.getBufferedArraysMemoryProportion();\n+\n+  /**\n+   * total size of buffered arrays\n+   */\n+  private static AtomicInteger bufferedArraysSize = new AtomicInteger();\n+\n+  /**\n+   * total size of out of buffer arrays\n+   */\n+  private static AtomicInteger outOfBufferArraysSize = new AtomicInteger();\n+\n+  static {\n+    bufferedArraysMap.put(TSDataType.BOOLEAN, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.INT32, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.INT64, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.FLOAT, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.DOUBLE, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.TEXT, new ArrayDeque<>());\n+  }\n+\n+  private PrimitiveArrayManager() {\n+  }\n+\n+  /**\n+   * Get primitive data lists according to type\n+   *\n+   * @param dataType data type\n+   * @return an array\n+   */\n+  public static Object getDataListByType(TSDataType dataType) {\n+    // check buffered array num\n+    if (bufferedArraysSize.get() + ARRAY_SIZE * dataType.getDataTypeSize()\n+        > BUFFERED_ARRAY_SIZE_THRESHOLD) {\n+      // return an out of buffer array\n+      outOfBufferArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+      return getDataList(dataType);\n+    }\n+\n+    synchronized (bufferedArraysMap.get(dataType)) {\n+      // return a buffered array\n+      bufferedArraysNumMap.put(dataType, bufferedArraysNumMap.getOrDefault(dataType, 0) + 1);\n+      bufferedArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+      Object dataArray = bufferedArraysMap.get(dataType).poll();\n+      if (dataArray != null) {\n+        return dataArray;\n+      }\n+    }\n+    return getDataList(dataType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5ODk1OQ==", "bodyText": "It's my fault .... Could you please help add some comments @HTHou ? This return statement should not reached..", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511798959", "createdAt": "2020-10-26T08:50:37Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/PrimitiveArrayManager.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Manage all primitive data list in memory, including get and release operation.\n+ */\n+public class PrimitiveArrayManager {\n+\n+  /**\n+   * data type -> ArrayDeque<Array>\n+   */\n+  private static final Map<TSDataType, ArrayDeque<Object>> bufferedArraysMap = new EnumMap<>(\n+      TSDataType.class);\n+\n+  /**\n+   * data type -> current number of buffered arrays\n+   */\n+  private static final Map<TSDataType, Integer> bufferedArraysNumMap = new EnumMap<>(\n+      TSDataType.class);\n+\n+  /**\n+   * data type -> ratio of data type in schema, which could be seen as recommended ratio\n+   */\n+  private static final Map<TSDataType, Double> bufferedArraysNumRatio = new EnumMap<>(\n+      TSDataType.class);\n+\n+  private static final Logger logger = LoggerFactory.getLogger(PrimitiveArrayManager.class);\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+\n+  public static final int ARRAY_SIZE = config.getPrimitiveArraySize();\n+\n+  /**\n+   * threshold total size of arrays for all data types\n+   */\n+  private static final double BUFFERED_ARRAY_SIZE_THRESHOLD =\n+      config.getAllocateMemoryForWrite() * config.getBufferedArraysMemoryProportion();\n+\n+  /**\n+   * total size of buffered arrays\n+   */\n+  private static AtomicInteger bufferedArraysSize = new AtomicInteger();\n+\n+  /**\n+   * total size of out of buffer arrays\n+   */\n+  private static AtomicInteger outOfBufferArraysSize = new AtomicInteger();\n+\n+  static {\n+    bufferedArraysMap.put(TSDataType.BOOLEAN, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.INT32, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.INT64, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.FLOAT, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.DOUBLE, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.TEXT, new ArrayDeque<>());\n+  }\n+\n+  private PrimitiveArrayManager() {\n+  }\n+\n+  /**\n+   * Get primitive data lists according to type\n+   *\n+   * @param dataType data type\n+   * @return an array\n+   */\n+  public static Object getDataListByType(TSDataType dataType) {\n+    // check buffered array num\n+    if (bufferedArraysSize.get() + ARRAY_SIZE * dataType.getDataTypeSize()\n+        > BUFFERED_ARRAY_SIZE_THRESHOLD) {\n+      // return an out of buffer array\n+      outOfBufferArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+      return getDataList(dataType);\n+    }\n+\n+    synchronized (bufferedArraysMap.get(dataType)) {\n+      // return a buffered array\n+      bufferedArraysNumMap.put(dataType, bufferedArraysNumMap.getOrDefault(dataType, 0) + 1);\n+      bufferedArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+      Object dataArray = bufferedArraysMap.get(dataType).poll();\n+      if (dataArray != null) {\n+        return dataArray;\n+      }\n+    }\n+    return getDataList(dataType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc4Mzc4NA=="}, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMzcwNw==", "bodyText": "It's my fault .... Could you please help add some comments @HTHou ? This return statement should not reached..\n\nSure, Let me fix it.", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511803707", "createdAt": "2020-10-26T08:58:56Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/PrimitiveArrayManager.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Manage all primitive data list in memory, including get and release operation.\n+ */\n+public class PrimitiveArrayManager {\n+\n+  /**\n+   * data type -> ArrayDeque<Array>\n+   */\n+  private static final Map<TSDataType, ArrayDeque<Object>> bufferedArraysMap = new EnumMap<>(\n+      TSDataType.class);\n+\n+  /**\n+   * data type -> current number of buffered arrays\n+   */\n+  private static final Map<TSDataType, Integer> bufferedArraysNumMap = new EnumMap<>(\n+      TSDataType.class);\n+\n+  /**\n+   * data type -> ratio of data type in schema, which could be seen as recommended ratio\n+   */\n+  private static final Map<TSDataType, Double> bufferedArraysNumRatio = new EnumMap<>(\n+      TSDataType.class);\n+\n+  private static final Logger logger = LoggerFactory.getLogger(PrimitiveArrayManager.class);\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+\n+  public static final int ARRAY_SIZE = config.getPrimitiveArraySize();\n+\n+  /**\n+   * threshold total size of arrays for all data types\n+   */\n+  private static final double BUFFERED_ARRAY_SIZE_THRESHOLD =\n+      config.getAllocateMemoryForWrite() * config.getBufferedArraysMemoryProportion();\n+\n+  /**\n+   * total size of buffered arrays\n+   */\n+  private static AtomicInteger bufferedArraysSize = new AtomicInteger();\n+\n+  /**\n+   * total size of out of buffer arrays\n+   */\n+  private static AtomicInteger outOfBufferArraysSize = new AtomicInteger();\n+\n+  static {\n+    bufferedArraysMap.put(TSDataType.BOOLEAN, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.INT32, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.INT64, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.FLOAT, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.DOUBLE, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.TEXT, new ArrayDeque<>());\n+  }\n+\n+  private PrimitiveArrayManager() {\n+  }\n+\n+  /**\n+   * Get primitive data lists according to type\n+   *\n+   * @param dataType data type\n+   * @return an array\n+   */\n+  public static Object getDataListByType(TSDataType dataType) {\n+    // check buffered array num\n+    if (bufferedArraysSize.get() + ARRAY_SIZE * dataType.getDataTypeSize()\n+        > BUFFERED_ARRAY_SIZE_THRESHOLD) {\n+      // return an out of buffer array\n+      outOfBufferArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+      return getDataList(dataType);\n+    }\n+\n+    synchronized (bufferedArraysMap.get(dataType)) {\n+      // return a buffered array\n+      bufferedArraysNumMap.put(dataType, bufferedArraysNumMap.getOrDefault(dataType, 0) + 1);\n+      bufferedArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+      Object dataArray = bufferedArraysMap.get(dataType).poll();\n+      if (dataArray != null) {\n+        return dataArray;\n+      }\n+    }\n+    return getDataList(dataType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc4Mzc4NA=="}, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2OTMxNA==", "bodyText": "I'm confused why should it return null here. If change it, the tests will failed...", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511969314", "createdAt": "2020-10-26T13:44:10Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/PrimitiveArrayManager.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Manage all primitive data list in memory, including get and release operation.\n+ */\n+public class PrimitiveArrayManager {\n+\n+  /**\n+   * data type -> ArrayDeque<Array>\n+   */\n+  private static final Map<TSDataType, ArrayDeque<Object>> bufferedArraysMap = new EnumMap<>(\n+      TSDataType.class);\n+\n+  /**\n+   * data type -> current number of buffered arrays\n+   */\n+  private static final Map<TSDataType, Integer> bufferedArraysNumMap = new EnumMap<>(\n+      TSDataType.class);\n+\n+  /**\n+   * data type -> ratio of data type in schema, which could be seen as recommended ratio\n+   */\n+  private static final Map<TSDataType, Double> bufferedArraysNumRatio = new EnumMap<>(\n+      TSDataType.class);\n+\n+  private static final Logger logger = LoggerFactory.getLogger(PrimitiveArrayManager.class);\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+\n+  public static final int ARRAY_SIZE = config.getPrimitiveArraySize();\n+\n+  /**\n+   * threshold total size of arrays for all data types\n+   */\n+  private static final double BUFFERED_ARRAY_SIZE_THRESHOLD =\n+      config.getAllocateMemoryForWrite() * config.getBufferedArraysMemoryProportion();\n+\n+  /**\n+   * total size of buffered arrays\n+   */\n+  private static AtomicInteger bufferedArraysSize = new AtomicInteger();\n+\n+  /**\n+   * total size of out of buffer arrays\n+   */\n+  private static AtomicInteger outOfBufferArraysSize = new AtomicInteger();\n+\n+  static {\n+    bufferedArraysMap.put(TSDataType.BOOLEAN, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.INT32, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.INT64, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.FLOAT, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.DOUBLE, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.TEXT, new ArrayDeque<>());\n+  }\n+\n+  private PrimitiveArrayManager() {\n+  }\n+\n+  /**\n+   * Get primitive data lists according to type\n+   *\n+   * @param dataType data type\n+   * @return an array\n+   */\n+  public static Object getDataListByType(TSDataType dataType) {\n+    // check buffered array num\n+    if (bufferedArraysSize.get() + ARRAY_SIZE * dataType.getDataTypeSize()\n+        > BUFFERED_ARRAY_SIZE_THRESHOLD) {\n+      // return an out of buffer array\n+      outOfBufferArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+      return getDataList(dataType);\n+    }\n+\n+    synchronized (bufferedArraysMap.get(dataType)) {\n+      // return a buffered array\n+      bufferedArraysNumMap.put(dataType, bufferedArraysNumMap.getOrDefault(dataType, 0) + 1);\n+      bufferedArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+      Object dataArray = bufferedArraysMap.get(dataType).poll();\n+      if (dataArray != null) {\n+        return dataArray;\n+      }\n+    }\n+    return getDataList(dataType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc4Mzc4NA=="}, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjUxODY4OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/enums/TSDataType.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwODozODo0OFrOHoFUnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxMzozODo0NFrOHo8oHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5MjI4Nw==", "bodyText": "Reference's length is 8 bytes. Or 16 bytes exactly (Java objects head length)", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511792287", "createdAt": "2020-10-26T08:38:48Z", "author": {"login": "SilverNarcissus"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/enums/TSDataType.java", "diffHunk": "@@ -98,6 +99,23 @@ public short serialize() {\n     return enumToByte();\r\n   }\r\n \r\n+  public int getDataTypeSize() {\r\n+    switch (this) {\r\n+      case BOOLEAN:\r\n+        return 1;\r\n+      case INT32:\r\n+      case FLOAT:\r\n+        // For text: return the size of reference here\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2MTM4Nw==", "bodyText": "This method is for calculating the array sizes in array pool. For text data, it should return the reference size of a Binary object. And the actual size of the Binary object won't be considered here.\nSo, should it return 8?", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511961387", "createdAt": "2020-10-26T13:32:59Z", "author": {"login": "HTHou"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/enums/TSDataType.java", "diffHunk": "@@ -98,6 +99,23 @@ public short serialize() {\n     return enumToByte();\r\n   }\r\n \r\n+  public int getDataTypeSize() {\r\n+    switch (this) {\r\n+      case BOOLEAN:\r\n+        return 1;\r\n+      case INT32:\r\n+      case FLOAT:\r\n+        // For text: return the size of reference here\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5MjI4Nw=="}, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQ1NjAwNQ==", "bodyText": "Yes, In 64-bit machine, it should return 8", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r512456005", "createdAt": "2020-10-27T07:05:30Z", "author": {"login": "SilverNarcissus"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/enums/TSDataType.java", "diffHunk": "@@ -98,6 +99,23 @@ public short serialize() {\n     return enumToByte();\r\n   }\r\n \r\n+  public int getDataTypeSize() {\r\n+    switch (this) {\r\n+      case BOOLEAN:\r\n+        return 1;\r\n+      case INT32:\r\n+      case FLOAT:\r\n+        // For text: return the size of reference here\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5MjI4Nw=="}, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUwNTkzNg==", "bodyText": "Thanks, update soon~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r512505936", "createdAt": "2020-10-27T08:43:56Z", "author": {"login": "HTHou"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/enums/TSDataType.java", "diffHunk": "@@ -98,6 +99,23 @@ public short serialize() {\n     return enumToByte();\r\n   }\r\n \r\n+  public int getDataTypeSize() {\r\n+    switch (this) {\r\n+      case BOOLEAN:\r\n+        return 1;\r\n+      case INT32:\r\n+      case FLOAT:\r\n+        // For text: return the size of reference here\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5MjI4Nw=="}, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5ODM5OA==", "bodyText": "Fixed~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r512698398", "createdAt": "2020-10-27T13:38:44Z", "author": {"login": "HTHou"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/enums/TSDataType.java", "diffHunk": "@@ -98,6 +99,23 @@ public short serialize() {\n     return enumToByte();\r\n   }\r\n \r\n+  public int getDataTypeSize() {\r\n+    switch (this) {\r\n+      case BOOLEAN:\r\n+        return 1;\r\n+      case INT32:\r\n+      case FLOAT:\r\n+        // For text: return the size of reference here\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5MjI4Nw=="}, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjU1NDU4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessorInfo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwODo0ODoyOFrOHoFpvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwOToxNjozMFrOHoGp0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5NzY5NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                this.unsealedResourceMemCost = 0;\n          \n          \n            \n                this.memTableCost = 0;\n          \n          \n            \n                this.chunkMetadataMemCost = 0;\n          \n          \n            \n                this.unsealedResourceMemCost = 0L;\n          \n          \n            \n                this.memTableCost = 0L;\n          \n          \n            \n                this.chunkMetadataMemCost = 0L;", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511797694", "createdAt": "2020-10-26T08:48:28Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessorInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+\n+/**\n+ * The TsFileProcessorInfo records the memory cost of this TsFileProcessor.\n+ */\n+public class TsFileProcessorInfo {\n+\n+  /**\n+   * Once tspInfo updated, report to storageGroupInfo that this TSP belongs to.\n+   */\n+  private StorageGroupInfo storageGroupInfo;\n+\n+  /**\n+   * The memory cost of the unsealed TsFileResources of this TSP\n+   */\n+  private long unsealedResourceMemCost;\n+  \n+  /**\n+   * The memory cost of memTable of this TSP\n+   */\n+  private long memTableCost;\n+\n+  /**\n+   * The memory cost of ChunkMetadata of this TSP\n+   */\n+  private long chunkMetadataMemCost;\n+\n+  /**\n+   * The memory cost of WAL of this TSP\n+   */\n+  private long walMemCost;\n+\n+  public TsFileProcessorInfo(StorageGroupInfo storageGroupInfo) {\n+    this.storageGroupInfo = storageGroupInfo;\n+    this.unsealedResourceMemCost = 0;\n+    this.memTableCost = 0;\n+    this.chunkMetadataMemCost = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgxNDA5Nw==", "bodyText": "Fixed~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r511814097", "createdAt": "2020-10-26T09:16:30Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessorInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+\n+/**\n+ * The TsFileProcessorInfo records the memory cost of this TsFileProcessor.\n+ */\n+public class TsFileProcessorInfo {\n+\n+  /**\n+   * Once tspInfo updated, report to storageGroupInfo that this TSP belongs to.\n+   */\n+  private StorageGroupInfo storageGroupInfo;\n+\n+  /**\n+   * The memory cost of the unsealed TsFileResources of this TSP\n+   */\n+  private long unsealedResourceMemCost;\n+  \n+  /**\n+   * The memory cost of memTable of this TSP\n+   */\n+  private long memTableCost;\n+\n+  /**\n+   * The memory cost of ChunkMetadata of this TSP\n+   */\n+  private long chunkMetadataMemCost;\n+\n+  /**\n+   * The memory cost of WAL of this TSP\n+   */\n+  private long walMemCost;\n+\n+  public TsFileProcessorInfo(StorageGroupInfo storageGroupInfo) {\n+    this.storageGroupInfo = storageGroupInfo;\n+    this.unsealedResourceMemCost = 0;\n+    this.memTableCost = 0;\n+    this.chunkMetadataMemCost = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5NzY5NA=="}, "originalCommit": {"oid": "fe7c76d49e8f0d99c18de037a22fe13fc2a188e1"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTA3MDAyOnYy", "diffSide": "RIGHT", "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMjowNTowMlrOHrujiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMTo1NjowMFrOHr0PJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMzU3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            write_read_mtree_free_memory_proportion=4:3:1:2\n          \n          \n            \n            write_read_schema_free_memory_proportion=4:3:1:2", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515613579", "createdAt": "2020-11-01T12:05:02Z", "author": {"login": "qiaojialin"}, "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "diffHunk": "@@ -218,24 +218,28 @@ mtree_snapshot_threshold_time=3600\n ### Memory Control Configuration\n ####################\n \n-# This adapter could adjust the system memory to avoid OOM.\n-# It will refuse to create time series or add storage groups under high system load.\n-#\n-# Attention!!!\n-# If disable this parameter, you need to set some parameters according to your system load:\n-# Normal scenario: 1-50 storage groups. <100k devices, <10M time series\n-# memtable_size_threshold = tsfile_size_threshold = IoTDB memory allocation in byte / 2 / num of storage group / 4\n-# Make sure the total num of time series in system * primitive_array_size * 16 <= IoTDB memory allocation in byte / 2 / 4\n-# you could reduce the primitive_array_size in very high workload.\n-enable_parameter_adapter=true\n-\n-# Memory Allocation Ratio: Write, Read, and Free Memory.\n-# The parameter form is a:b:c, where a, b and c are integers. for example: 1:1:1 , 6:3:1\n-write_read_free_memory_proportion=6:3:1\n+# Whether to enable memory control\n+enable_mem_control=true\n+\n+# Memory Allocation Ratio: Write, Read, MTree and Free Memory.\n+# The parameter form is a:b:c:d, where a, b, c and d are integers. for example: 1:1:1:1 , 6:2:1:1\n+write_read_mtree_free_memory_proportion=4:3:1:2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcwNjY2Mg==", "bodyText": "Fixed~", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515706662", "createdAt": "2020-11-02T01:56:00Z", "author": {"login": "HTHou"}, "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "diffHunk": "@@ -218,24 +218,28 @@ mtree_snapshot_threshold_time=3600\n ### Memory Control Configuration\n ####################\n \n-# This adapter could adjust the system memory to avoid OOM.\n-# It will refuse to create time series or add storage groups under high system load.\n-#\n-# Attention!!!\n-# If disable this parameter, you need to set some parameters according to your system load:\n-# Normal scenario: 1-50 storage groups. <100k devices, <10M time series\n-# memtable_size_threshold = tsfile_size_threshold = IoTDB memory allocation in byte / 2 / num of storage group / 4\n-# Make sure the total num of time series in system * primitive_array_size * 16 <= IoTDB memory allocation in byte / 2 / 4\n-# you could reduce the primitive_array_size in very high workload.\n-enable_parameter_adapter=true\n-\n-# Memory Allocation Ratio: Write, Read, and Free Memory.\n-# The parameter form is a:b:c, where a, b and c are integers. for example: 1:1:1 , 6:3:1\n-write_read_free_memory_proportion=6:3:1\n+# Whether to enable memory control\n+enable_mem_control=true\n+\n+# Memory Allocation Ratio: Write, Read, MTree and Free Memory.\n+# The parameter form is a:b:c:d, where a, b, c and d are integers. for example: 1:1:1:1 , 6:2:1:1\n+write_read_mtree_free_memory_proportion=4:3:1:2", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMzU3OQ=="}, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTA3MTQ4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMjowNjo1MlrOHrukOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMTo1OToxMFrOHr0RKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMzc1Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private double flushProportion = 0.5;\n          \n          \n            \n              private double flushProportion = 0.3;", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515613752", "createdAt": "2020-11-01T12:06:52Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -138,9 +142,24 @@\n   private volatile int maxQueryDeduplicatedPathNum = 1000;\n \n   /**\n-   * Is dynamic parameter adapter enable.\n+   * Ratio of memory allocated for buffered arrays\n+   */\n+  private double bufferedArraysMemoryProportion = 0.6;\n+\n+  /**\n+   * Flush proportion for system\n    */\n-  private boolean enableParameterAdapter = true;\n+  private double flushProportion = 0.5;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcwNzE3OA==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515707178", "createdAt": "2020-11-02T01:59:10Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -138,9 +142,24 @@\n   private volatile int maxQueryDeduplicatedPathNum = 1000;\n \n   /**\n-   * Is dynamic parameter adapter enable.\n+   * Ratio of memory allocated for buffered arrays\n+   */\n+  private double bufferedArraysMemoryProportion = 0.6;\n+\n+  /**\n+   * Flush proportion for system\n    */\n-  private boolean enableParameterAdapter = true;\n+  private double flushProportion = 0.5;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMzc1Mg=="}, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTIwNDUxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxNDo0NToyNFrOHrvm0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjowMzoyMlrOHr0T0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzMDgwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              protected boolean enableMemControl = false;\n          \n          \n            \n              protected boolean enableMemControl = true;", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515630802", "createdAt": "2020-11-01T14:45:24Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "diffHunk": "@@ -56,6 +56,13 @@\n \n   private long memSize = 0;\n \n+  protected boolean enableMemControl = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcwNzg1OA==", "bodyText": "The initial value is false here because we should calculate the text data size when recover memtable.\nA comment added.", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515707858", "createdAt": "2020-11-02T02:03:22Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "diffHunk": "@@ -56,6 +56,13 @@\n \n   private long memSize = 0;\n \n+  protected boolean enableMemControl = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzMDgwMg=="}, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTIxMzY5OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/ChunkMetadata.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxNDo1Njo1MVrOHrvrZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxNDo1Njo1MVrOHrvrZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzMTk3Mg==", "bodyText": "for a FloatStatistics, there exist 5 float fields", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515631972", "createdAt": "2020-11-01T14:56:51Z", "author": {"login": "qiaojialin"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/ChunkMetadata.java", "diffHunk": "@@ -259,6 +259,11 @@ public long calculateRamSize() {\n         .calculateRamSize();\n   }\n \n+  public static long calculateRamSize(String measurementId, TSDataType dataType) {\n+    return CHUNK_METADATA_FIXED_RAM_SIZE + RamUsageEstimator.sizeOf(measurementId) + Statistics\n+        .getStatsByType(dataType).calculateRamSize();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTIxNTIxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/writelog/node/ExclusiveWriteLogNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxNDo1ODo1NFrOHrvsJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjowNzo1NVrOHr0XHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzMjE2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      \"Log cannot fit into buffer, please increase wal_buffer_size or please increase the JVM memory\", e);\n          \n          \n            \n                      \"Log cannot fit into the buffer, please increase wal_buffer_size\", e);", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515632167", "createdAt": "2020-11-01T14:58:54Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/writelog/node/ExclusiveWriteLogNode.java", "diffHunk": "@@ -89,8 +89,7 @@ public void write(PhysicalPlan plan) throws IOException {\n       }\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-          \"Log cannot fit into buffer, if you don't enable Dynamic Parameter Adapter, please increase wal_buffer_size;\"\n-              + \"otherwise, please increase the JVM memory\", e);\n+          \"Log cannot fit into buffer, please increase wal_buffer_size or please increase the JVM memory\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcwODcwMw==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515708703", "createdAt": "2020-11-02T02:07:55Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/writelog/node/ExclusiveWriteLogNode.java", "diffHunk": "@@ -89,8 +89,7 @@ public void write(PhysicalPlan plan) throws IOException {\n       }\n     } catch (BufferOverflowException e) {\n       throw new IOException(\n-          \"Log cannot fit into buffer, if you don't enable Dynamic Parameter Adapter, please increase wal_buffer_size;\"\n-              + \"otherwise, please increase the JVM memory\", e);\n+          \"Log cannot fit into buffer, please increase wal_buffer_size or please increase the JVM memory\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzMjE2Nw=="}, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTIxNjA3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/utils/datastructure/TVList.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxNDo1OTo0MlrOHrvsjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjoxMDowOVrOHr0Ylw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzMjI2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    PrimitiveArrayManager.ARRAY_SIZE * TSDataType.INT64.getDataTypeSize();\n          \n          \n            \n                    PrimitiveArrayManager.ARRAY_SIZE * 8;", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515632269", "createdAt": "2020-11-01T14:59:42Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/datastructure/TVList.java", "diffHunk": "@@ -494,6 +477,17 @@ public IPointReader getIterator(int floatPrecision, TSEncoding encoding) {\n     return new Ite(floatPrecision, encoding);\n   }\n \n+  public static long tvListArrayMemSize(TSDataType type) {\n+    long size = 0;\n+    // time size\n+    size +=\n+        PrimitiveArrayManager.ARRAY_SIZE * TSDataType.INT64.getDataTypeSize();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcwOTA3OQ==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515709079", "createdAt": "2020-11-02T02:10:09Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/datastructure/TVList.java", "diffHunk": "@@ -494,6 +477,17 @@ public IPointReader getIterator(int floatPrecision, TSEncoding encoding) {\n     return new Ite(floatPrecision, encoding);\n   }\n \n+  public static long tvListArrayMemSize(TSDataType type) {\n+    long size = 0;\n+    // time size\n+    size +=\n+        PrimitiveArrayManager.ARRAY_SIZE * TSDataType.INT64.getDataTypeSize();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzMjI2OQ=="}, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTIxODE5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/utils/datastructure/TVList.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxNTowMTo1NFrOHrvthg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjoxNjowM1rOHr0c5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzMjUxOA==", "bodyText": "Is this right?  If the ARRAY_SIZE is 128, and current TVList size is 129 (contains two array), then even add one data point, this returns false", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515632518", "createdAt": "2020-11-01T15:01:54Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/datastructure/TVList.java", "diffHunk": "@@ -275,11 +249,18 @@ protected void clearSortedTime() {\n   protected void checkExpansion() {\n     if ((size % ARRAY_SIZE) == 0) {\n       expandValues();\n-      timestamps.add(\n-          (long[]) PrimitiveArrayPool.getInstance().getPrimitiveDataListByType(TSDataType.INT64));\n+      timestamps.add((long[]) getDataListByType(TSDataType.INT64));\n     }\n   }\n \n+  protected Object getDataListByType(TSDataType dataType) {\n+    return PrimitiveArrayManager.getDataListByType(dataType);\n+  }\n+\n+  public boolean checkIfDataListIsEnough(int lengthToBeAdded) {\n+    return size + lengthToBeAdded < ARRAY_SIZE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxMDE4MQ==", "bodyText": "Yes, make sense. This is a bug exactly.....", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515710181", "createdAt": "2020-11-02T02:16:03Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/datastructure/TVList.java", "diffHunk": "@@ -275,11 +249,18 @@ protected void clearSortedTime() {\n   protected void checkExpansion() {\n     if ((size % ARRAY_SIZE) == 0) {\n       expandValues();\n-      timestamps.add(\n-          (long[]) PrimitiveArrayPool.getInstance().getPrimitiveDataListByType(TSDataType.INT64));\n+      timestamps.add((long[]) getDataListByType(TSDataType.INT64));\n     }\n   }\n \n+  protected Object getDataListByType(TSDataType dataType) {\n+    return PrimitiveArrayManager.getDataListByType(dataType);\n+  }\n+\n+  public boolean checkIfDataListIsEnough(int lengthToBeAdded) {\n+    return size + lengthToBeAdded < ARRAY_SIZE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzMjUxOA=="}, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTIxOTUwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/utils/datastructure/TVList.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxNTowMzozM1rOHrvuIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjoxOTozN1rOHr0fdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzMjY3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              protected Object getDataListByType(TSDataType dataType) {\n          \n          \n            \n              protected Object getPrimitiveArraysByType(TSDataType dataType) {", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515632672", "createdAt": "2020-11-01T15:03:33Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/datastructure/TVList.java", "diffHunk": "@@ -275,11 +249,18 @@ protected void clearSortedTime() {\n   protected void checkExpansion() {\n     if ((size % ARRAY_SIZE) == 0) {\n       expandValues();\n-      timestamps.add(\n-          (long[]) PrimitiveArrayPool.getInstance().getPrimitiveDataListByType(TSDataType.INT64));\n+      timestamps.add((long[]) getDataListByType(TSDataType.INT64));\n     }\n   }\n \n+  protected Object getDataListByType(TSDataType dataType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxMDgzNw==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515710837", "createdAt": "2020-11-02T02:19:37Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/datastructure/TVList.java", "diffHunk": "@@ -275,11 +249,18 @@ protected void clearSortedTime() {\n   protected void checkExpansion() {\n     if ((size % ARRAY_SIZE) == 0) {\n       expandValues();\n-      timestamps.add(\n-          (long[]) PrimitiveArrayPool.getInstance().getPrimitiveDataListByType(TSDataType.INT64));\n+      timestamps.add((long[]) getDataListByType(TSDataType.INT64));\n     }\n   }\n \n+  protected Object getDataListByType(TSDataType dataType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzMjY3Mg=="}, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTIxOTcwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/utils/datastructure/TVList.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxNTowMzo1MlrOHrvuOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjoxOTo1M1rOHr0frg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzMjY5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return PrimitiveArrayManager.getDataListByType(dataType);\n          \n          \n            \n                return PrimitiveArrayManager.getPrimitiveArraysByType(dataType);", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515632699", "createdAt": "2020-11-01T15:03:52Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/datastructure/TVList.java", "diffHunk": "@@ -275,11 +249,18 @@ protected void clearSortedTime() {\n   protected void checkExpansion() {\n     if ((size % ARRAY_SIZE) == 0) {\n       expandValues();\n-      timestamps.add(\n-          (long[]) PrimitiveArrayPool.getInstance().getPrimitiveDataListByType(TSDataType.INT64));\n+      timestamps.add((long[]) getDataListByType(TSDataType.INT64));\n     }\n   }\n \n+  protected Object getDataListByType(TSDataType dataType) {\n+    return PrimitiveArrayManager.getDataListByType(dataType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxMDg5NA==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515710894", "createdAt": "2020-11-02T02:19:53Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/datastructure/TVList.java", "diffHunk": "@@ -275,11 +249,18 @@ protected void clearSortedTime() {\n   protected void checkExpansion() {\n     if ((size % ARRAY_SIZE) == 0) {\n       expandValues();\n-      timestamps.add(\n-          (long[]) PrimitiveArrayPool.getInstance().getPrimitiveDataListByType(TSDataType.INT64));\n+      timestamps.add((long[]) getDataListByType(TSDataType.INT64));\n     }\n   }\n \n+  protected Object getDataListByType(TSDataType dataType) {\n+    return PrimitiveArrayManager.getDataListByType(dataType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzMjY5OQ=="}, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTIyODA0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/rescon/PrimitiveArrayManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxNToxMjozN1rOHrvybA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjoyMjowOVrOHr0hMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzMzc3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static Object getDataList(TSDataType dataType) {\n          \n          \n            \n              private static Object createPrimitiveArray(TSDataType dataType) {", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515633772", "createdAt": "2020-11-01T15:12:37Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/PrimitiveArrayManager.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Manage all primitive data list in memory, including get and release operation.\n+ */\n+public class PrimitiveArrayManager {\n+\n+  /**\n+   * data type -> ArrayDeque<Array>\n+   */\n+  private static final Map<TSDataType, ArrayDeque<Object>> bufferedArraysMap = new EnumMap<>(\n+      TSDataType.class);\n+\n+  /**\n+   * data type -> current number of buffered arrays\n+   */\n+  private static final Map<TSDataType, Integer> bufferedArraysNumMap = new EnumMap<>(\n+      TSDataType.class);\n+\n+  /**\n+   * data type -> ratio of data type in schema, which could be seen as recommended ratio\n+   */\n+  private static final Map<TSDataType, Double> bufferedArraysNumRatio = new EnumMap<>(\n+      TSDataType.class);\n+\n+  private static final Logger logger = LoggerFactory.getLogger(PrimitiveArrayManager.class);\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+\n+  public static final int ARRAY_SIZE = config.getPrimitiveArraySize();\n+\n+  /**\n+   * threshold total size of arrays for all data types\n+   */\n+  private static final double BUFFERED_ARRAY_SIZE_THRESHOLD =\n+      config.getAllocateMemoryForWrite() * config.getBufferedArraysMemoryProportion();\n+\n+  /**\n+   * total size of buffered arrays\n+   */\n+  private static AtomicInteger bufferedArraysSize = new AtomicInteger();\n+\n+  /**\n+   * total size of out of buffer arrays\n+   */\n+  private static AtomicInteger outOfBufferArraysSize = new AtomicInteger();\n+\n+  static {\n+    bufferedArraysMap.put(TSDataType.BOOLEAN, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.INT32, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.INT64, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.FLOAT, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.DOUBLE, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.TEXT, new ArrayDeque<>());\n+  }\n+\n+  private PrimitiveArrayManager() {\n+  }\n+\n+  /**\n+   * Get primitive data lists according to type\n+   *\n+   * @param dataType data type\n+   * @return an array\n+   */\n+  public static Object getDataListByType(TSDataType dataType) {\n+    // check buffered array num (to avoid entering synchronized block every time)\n+    if (bufferedArraysSize.get() + ARRAY_SIZE * dataType.getDataTypeSize()\n+        > BUFFERED_ARRAY_SIZE_THRESHOLD) {\n+      // return an out of buffer array\n+      outOfBufferArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+      return getDataList(dataType);\n+    }\n+\n+    synchronized (bufferedArraysMap.get(dataType)) {\n+      // return a buffered array\n+      bufferedArraysNumMap.put(dataType, bufferedArraysNumMap.getOrDefault(dataType, 0) + 1);\n+      bufferedArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+      Object dataArray = bufferedArraysMap.get(dataType).poll();\n+      if (dataArray != null) {\n+        return dataArray;\n+      }\n+    }\n+\n+    // if no buffered array is returned, return an out of buffer array\n+    outOfBufferArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+    return getDataList(dataType);\n+  }\n+\n+  private static Object getDataList(TSDataType dataType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxMTI4MA==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515711280", "createdAt": "2020-11-02T02:22:09Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/PrimitiveArrayManager.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Manage all primitive data list in memory, including get and release operation.\n+ */\n+public class PrimitiveArrayManager {\n+\n+  /**\n+   * data type -> ArrayDeque<Array>\n+   */\n+  private static final Map<TSDataType, ArrayDeque<Object>> bufferedArraysMap = new EnumMap<>(\n+      TSDataType.class);\n+\n+  /**\n+   * data type -> current number of buffered arrays\n+   */\n+  private static final Map<TSDataType, Integer> bufferedArraysNumMap = new EnumMap<>(\n+      TSDataType.class);\n+\n+  /**\n+   * data type -> ratio of data type in schema, which could be seen as recommended ratio\n+   */\n+  private static final Map<TSDataType, Double> bufferedArraysNumRatio = new EnumMap<>(\n+      TSDataType.class);\n+\n+  private static final Logger logger = LoggerFactory.getLogger(PrimitiveArrayManager.class);\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+\n+  public static final int ARRAY_SIZE = config.getPrimitiveArraySize();\n+\n+  /**\n+   * threshold total size of arrays for all data types\n+   */\n+  private static final double BUFFERED_ARRAY_SIZE_THRESHOLD =\n+      config.getAllocateMemoryForWrite() * config.getBufferedArraysMemoryProportion();\n+\n+  /**\n+   * total size of buffered arrays\n+   */\n+  private static AtomicInteger bufferedArraysSize = new AtomicInteger();\n+\n+  /**\n+   * total size of out of buffer arrays\n+   */\n+  private static AtomicInteger outOfBufferArraysSize = new AtomicInteger();\n+\n+  static {\n+    bufferedArraysMap.put(TSDataType.BOOLEAN, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.INT32, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.INT64, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.FLOAT, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.DOUBLE, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.TEXT, new ArrayDeque<>());\n+  }\n+\n+  private PrimitiveArrayManager() {\n+  }\n+\n+  /**\n+   * Get primitive data lists according to type\n+   *\n+   * @param dataType data type\n+   * @return an array\n+   */\n+  public static Object getDataListByType(TSDataType dataType) {\n+    // check buffered array num (to avoid entering synchronized block every time)\n+    if (bufferedArraysSize.get() + ARRAY_SIZE * dataType.getDataTypeSize()\n+        > BUFFERED_ARRAY_SIZE_THRESHOLD) {\n+      // return an out of buffer array\n+      outOfBufferArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+      return getDataList(dataType);\n+    }\n+\n+    synchronized (bufferedArraysMap.get(dataType)) {\n+      // return a buffered array\n+      bufferedArraysNumMap.put(dataType, bufferedArraysNumMap.getOrDefault(dataType, 0) + 1);\n+      bufferedArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+      Object dataArray = bufferedArraysMap.get(dataType).poll();\n+      if (dataArray != null) {\n+        return dataArray;\n+      }\n+    }\n+\n+    // if no buffered array is returned, return an out of buffer array\n+    outOfBufferArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+    return getDataList(dataType);\n+  }\n+\n+  private static Object getDataList(TSDataType dataType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzMzc3Mg=="}, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTIyODI5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/rescon/PrimitiveArrayManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxNToxMjo1NVrOHrvyjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjoyMjo1MVrOHr0hoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzMzgwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static synchronized Object getDataListsByType(TSDataType dataType, int size) {\n          \n          \n            \n              public static synchronized Object generateDataListsByType(TSDataType dataType, int size) {", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515633806", "createdAt": "2020-11-01T15:12:55Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/PrimitiveArrayManager.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Manage all primitive data list in memory, including get and release operation.\n+ */\n+public class PrimitiveArrayManager {\n+\n+  /**\n+   * data type -> ArrayDeque<Array>\n+   */\n+  private static final Map<TSDataType, ArrayDeque<Object>> bufferedArraysMap = new EnumMap<>(\n+      TSDataType.class);\n+\n+  /**\n+   * data type -> current number of buffered arrays\n+   */\n+  private static final Map<TSDataType, Integer> bufferedArraysNumMap = new EnumMap<>(\n+      TSDataType.class);\n+\n+  /**\n+   * data type -> ratio of data type in schema, which could be seen as recommended ratio\n+   */\n+  private static final Map<TSDataType, Double> bufferedArraysNumRatio = new EnumMap<>(\n+      TSDataType.class);\n+\n+  private static final Logger logger = LoggerFactory.getLogger(PrimitiveArrayManager.class);\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+\n+  public static final int ARRAY_SIZE = config.getPrimitiveArraySize();\n+\n+  /**\n+   * threshold total size of arrays for all data types\n+   */\n+  private static final double BUFFERED_ARRAY_SIZE_THRESHOLD =\n+      config.getAllocateMemoryForWrite() * config.getBufferedArraysMemoryProportion();\n+\n+  /**\n+   * total size of buffered arrays\n+   */\n+  private static AtomicInteger bufferedArraysSize = new AtomicInteger();\n+\n+  /**\n+   * total size of out of buffer arrays\n+   */\n+  private static AtomicInteger outOfBufferArraysSize = new AtomicInteger();\n+\n+  static {\n+    bufferedArraysMap.put(TSDataType.BOOLEAN, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.INT32, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.INT64, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.FLOAT, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.DOUBLE, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.TEXT, new ArrayDeque<>());\n+  }\n+\n+  private PrimitiveArrayManager() {\n+  }\n+\n+  /**\n+   * Get primitive data lists according to type\n+   *\n+   * @param dataType data type\n+   * @return an array\n+   */\n+  public static Object getDataListByType(TSDataType dataType) {\n+    // check buffered array num (to avoid entering synchronized block every time)\n+    if (bufferedArraysSize.get() + ARRAY_SIZE * dataType.getDataTypeSize()\n+        > BUFFERED_ARRAY_SIZE_THRESHOLD) {\n+      // return an out of buffer array\n+      outOfBufferArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+      return getDataList(dataType);\n+    }\n+\n+    synchronized (bufferedArraysMap.get(dataType)) {\n+      // return a buffered array\n+      bufferedArraysNumMap.put(dataType, bufferedArraysNumMap.getOrDefault(dataType, 0) + 1);\n+      bufferedArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+      Object dataArray = bufferedArraysMap.get(dataType).poll();\n+      if (dataArray != null) {\n+        return dataArray;\n+      }\n+    }\n+\n+    // if no buffered array is returned, return an out of buffer array\n+    outOfBufferArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+    return getDataList(dataType);\n+  }\n+\n+  private static Object getDataList(TSDataType dataType) {\n+    Object dataArray;\n+    switch (dataType) {\n+      case BOOLEAN:\n+        dataArray = new boolean[ARRAY_SIZE];\n+        break;\n+      case INT32:\n+        dataArray = new int[ARRAY_SIZE];\n+        break;\n+      case INT64:\n+        dataArray = new long[ARRAY_SIZE];\n+        break;\n+      case FLOAT:\n+        dataArray = new float[ARRAY_SIZE];\n+        break;\n+      case DOUBLE:\n+        dataArray = new double[ARRAY_SIZE];\n+        break;\n+      case TEXT:\n+        dataArray = new Binary[ARRAY_SIZE];\n+        break;\n+      default:\n+        throw new UnSupportedDataTypeException(dataType.toString());\n+    }\n+\n+    return dataArray;\n+  }\n+\n+  /**\n+   * Get primitive data lists according to data type and size\n+   *\n+   * @param dataType data type\n+   * @param size     needed capacity\n+   * @return an array of primitive data arrays\n+   */\n+  public static synchronized Object getDataListsByType(TSDataType dataType, int size) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxMTM5Mg==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515711392", "createdAt": "2020-11-02T02:22:51Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/PrimitiveArrayManager.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Manage all primitive data list in memory, including get and release operation.\n+ */\n+public class PrimitiveArrayManager {\n+\n+  /**\n+   * data type -> ArrayDeque<Array>\n+   */\n+  private static final Map<TSDataType, ArrayDeque<Object>> bufferedArraysMap = new EnumMap<>(\n+      TSDataType.class);\n+\n+  /**\n+   * data type -> current number of buffered arrays\n+   */\n+  private static final Map<TSDataType, Integer> bufferedArraysNumMap = new EnumMap<>(\n+      TSDataType.class);\n+\n+  /**\n+   * data type -> ratio of data type in schema, which could be seen as recommended ratio\n+   */\n+  private static final Map<TSDataType, Double> bufferedArraysNumRatio = new EnumMap<>(\n+      TSDataType.class);\n+\n+  private static final Logger logger = LoggerFactory.getLogger(PrimitiveArrayManager.class);\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+\n+  public static final int ARRAY_SIZE = config.getPrimitiveArraySize();\n+\n+  /**\n+   * threshold total size of arrays for all data types\n+   */\n+  private static final double BUFFERED_ARRAY_SIZE_THRESHOLD =\n+      config.getAllocateMemoryForWrite() * config.getBufferedArraysMemoryProportion();\n+\n+  /**\n+   * total size of buffered arrays\n+   */\n+  private static AtomicInteger bufferedArraysSize = new AtomicInteger();\n+\n+  /**\n+   * total size of out of buffer arrays\n+   */\n+  private static AtomicInteger outOfBufferArraysSize = new AtomicInteger();\n+\n+  static {\n+    bufferedArraysMap.put(TSDataType.BOOLEAN, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.INT32, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.INT64, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.FLOAT, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.DOUBLE, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.TEXT, new ArrayDeque<>());\n+  }\n+\n+  private PrimitiveArrayManager() {\n+  }\n+\n+  /**\n+   * Get primitive data lists according to type\n+   *\n+   * @param dataType data type\n+   * @return an array\n+   */\n+  public static Object getDataListByType(TSDataType dataType) {\n+    // check buffered array num (to avoid entering synchronized block every time)\n+    if (bufferedArraysSize.get() + ARRAY_SIZE * dataType.getDataTypeSize()\n+        > BUFFERED_ARRAY_SIZE_THRESHOLD) {\n+      // return an out of buffer array\n+      outOfBufferArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+      return getDataList(dataType);\n+    }\n+\n+    synchronized (bufferedArraysMap.get(dataType)) {\n+      // return a buffered array\n+      bufferedArraysNumMap.put(dataType, bufferedArraysNumMap.getOrDefault(dataType, 0) + 1);\n+      bufferedArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+      Object dataArray = bufferedArraysMap.get(dataType).poll();\n+      if (dataArray != null) {\n+        return dataArray;\n+      }\n+    }\n+\n+    // if no buffered array is returned, return an out of buffer array\n+    outOfBufferArraysSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+    return getDataList(dataType);\n+  }\n+\n+  private static Object getDataList(TSDataType dataType) {\n+    Object dataArray;\n+    switch (dataType) {\n+      case BOOLEAN:\n+        dataArray = new boolean[ARRAY_SIZE];\n+        break;\n+      case INT32:\n+        dataArray = new int[ARRAY_SIZE];\n+        break;\n+      case INT64:\n+        dataArray = new long[ARRAY_SIZE];\n+        break;\n+      case FLOAT:\n+        dataArray = new float[ARRAY_SIZE];\n+        break;\n+      case DOUBLE:\n+        dataArray = new double[ARRAY_SIZE];\n+        break;\n+      case TEXT:\n+        dataArray = new Binary[ARRAY_SIZE];\n+        break;\n+      default:\n+        throw new UnSupportedDataTypeException(dataType.toString());\n+    }\n+\n+    return dataArray;\n+  }\n+\n+  /**\n+   * Get primitive data lists according to data type and size\n+   *\n+   * @param dataType data type\n+   * @param size     needed capacity\n+   * @return an array of primitive data arrays\n+   */\n+  public static synchronized Object getDataListsByType(TSDataType dataType, int size) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzMzgwNg=="}, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTIzNTc1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxNToyMTowM1rOHrv2EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjoyNDowNlrOHr0iZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzNDcwNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void resetUnsealedResourceMemCost(long cost) {\n          \n          \n            \n              public void releaseUnsealedResourceMemCost(long cost) {", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515634705", "createdAt": "2020-11-01T15:21:03Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.rescon.SystemInfo;\n+\n+/**\n+ * The storageGroupInfo records the total memory cost of the Storage Group.\n+ */\n+public class StorageGroupInfo {\n+\n+  private StorageGroupProcessor storageGroupProcessor;\n+\n+  /**\n+   * The total memory cost of the unsealed TsFileResources in this SG\n+   */\n+  private AtomicLong unsealedResourceMemCost;\n+\n+  /**\n+   * The total memtable memory cost in this SG\n+   */\n+  private AtomicLong memTableCost;\n+\n+  /**\n+   * The total memory cost of ChunkMetadata in this SG\n+   */\n+  private AtomicLong chunkMetadataMemCost;\n+\n+  /**\n+   * The total memory cost of WALs in this SG\n+   */\n+  private AtomicLong walMemCost;\n+\n+  /**\n+   * The threshold of reporting it's size to SystemInfo\n+   */\n+  private long storageGroupSizeReportThreshold = \n+      IoTDBDescriptor.getInstance().getConfig().getStorageGroupSizeReportThreshold();\n+\n+  private long lastReportedSize = 0L;\n+\n+  /**\n+   * A set of all unclosed TsFileProcessors in this SG\n+   */\n+  private Set<TsFileProcessor> reportedTsps = new HashSet<>();\n+\n+  public StorageGroupInfo(StorageGroupProcessor storageGroupProcessor) {\n+    this.storageGroupProcessor = storageGroupProcessor;\n+    unsealedResourceMemCost = new AtomicLong();\n+    memTableCost = new AtomicLong();\n+    chunkMetadataMemCost = new AtomicLong();\n+    walMemCost = new AtomicLong();\n+  }\n+\n+  public StorageGroupProcessor getStorageGroupProcessor() {\n+    return storageGroupProcessor;\n+  }\n+\n+  /**\n+   * When create a new TsFileProcessor, call this method to report it\n+   */\n+  public void reportTsFileProcessorInfo(TsFileProcessor tsFileProcessor) {\n+    if (reportedTsps.add(tsFileProcessor)) {\n+      walMemCost.getAndAdd(IoTDBDescriptor.getInstance().getConfig().getWalBufferSize());\n+    }\n+  }\n+\n+  public void addUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost.getAndAdd(cost);\n+  }\n+\n+  public void addChunkMetadataMemCost(long cost) {\n+    chunkMetadataMemCost.getAndAdd(cost);\n+  }\n+\n+  public void addMemTableCost(long cost) {\n+    memTableCost.getAndAdd(cost);\n+  }\n+\n+  /**\n+   * called by TSPInfo when closing a TSP\n+   */\n+  public void resetUnsealedResourceMemCost(long cost) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxMTU4OQ==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515711589", "createdAt": "2020-11-02T02:24:06Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.rescon.SystemInfo;\n+\n+/**\n+ * The storageGroupInfo records the total memory cost of the Storage Group.\n+ */\n+public class StorageGroupInfo {\n+\n+  private StorageGroupProcessor storageGroupProcessor;\n+\n+  /**\n+   * The total memory cost of the unsealed TsFileResources in this SG\n+   */\n+  private AtomicLong unsealedResourceMemCost;\n+\n+  /**\n+   * The total memtable memory cost in this SG\n+   */\n+  private AtomicLong memTableCost;\n+\n+  /**\n+   * The total memory cost of ChunkMetadata in this SG\n+   */\n+  private AtomicLong chunkMetadataMemCost;\n+\n+  /**\n+   * The total memory cost of WALs in this SG\n+   */\n+  private AtomicLong walMemCost;\n+\n+  /**\n+   * The threshold of reporting it's size to SystemInfo\n+   */\n+  private long storageGroupSizeReportThreshold = \n+      IoTDBDescriptor.getInstance().getConfig().getStorageGroupSizeReportThreshold();\n+\n+  private long lastReportedSize = 0L;\n+\n+  /**\n+   * A set of all unclosed TsFileProcessors in this SG\n+   */\n+  private Set<TsFileProcessor> reportedTsps = new HashSet<>();\n+\n+  public StorageGroupInfo(StorageGroupProcessor storageGroupProcessor) {\n+    this.storageGroupProcessor = storageGroupProcessor;\n+    unsealedResourceMemCost = new AtomicLong();\n+    memTableCost = new AtomicLong();\n+    chunkMetadataMemCost = new AtomicLong();\n+    walMemCost = new AtomicLong();\n+  }\n+\n+  public StorageGroupProcessor getStorageGroupProcessor() {\n+    return storageGroupProcessor;\n+  }\n+\n+  /**\n+   * When create a new TsFileProcessor, call this method to report it\n+   */\n+  public void reportTsFileProcessorInfo(TsFileProcessor tsFileProcessor) {\n+    if (reportedTsps.add(tsFileProcessor)) {\n+      walMemCost.getAndAdd(IoTDBDescriptor.getInstance().getConfig().getWalBufferSize());\n+    }\n+  }\n+\n+  public void addUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost.getAndAdd(cost);\n+  }\n+\n+  public void addChunkMetadataMemCost(long cost) {\n+    chunkMetadataMemCost.getAndAdd(cost);\n+  }\n+\n+  public void addMemTableCost(long cost) {\n+    memTableCost.getAndAdd(cost);\n+  }\n+\n+  /**\n+   * called by TSPInfo when closing a TSP\n+   */\n+  public void resetUnsealedResourceMemCost(long cost) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzNDcwNQ=="}, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTIzNjMyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxNToyMTo0NFrOHrv2Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjoyNjoxOVrOHr0kAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzNDc3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void resetChunkMetadataMemCost(long cost) {\n          \n          \n            \n              public void releaseChunkMetadataMemCost(long cost) {", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515634779", "createdAt": "2020-11-01T15:21:44Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.rescon.SystemInfo;\n+\n+/**\n+ * The storageGroupInfo records the total memory cost of the Storage Group.\n+ */\n+public class StorageGroupInfo {\n+\n+  private StorageGroupProcessor storageGroupProcessor;\n+\n+  /**\n+   * The total memory cost of the unsealed TsFileResources in this SG\n+   */\n+  private AtomicLong unsealedResourceMemCost;\n+\n+  /**\n+   * The total memtable memory cost in this SG\n+   */\n+  private AtomicLong memTableCost;\n+\n+  /**\n+   * The total memory cost of ChunkMetadata in this SG\n+   */\n+  private AtomicLong chunkMetadataMemCost;\n+\n+  /**\n+   * The total memory cost of WALs in this SG\n+   */\n+  private AtomicLong walMemCost;\n+\n+  /**\n+   * The threshold of reporting it's size to SystemInfo\n+   */\n+  private long storageGroupSizeReportThreshold = \n+      IoTDBDescriptor.getInstance().getConfig().getStorageGroupSizeReportThreshold();\n+\n+  private long lastReportedSize = 0L;\n+\n+  /**\n+   * A set of all unclosed TsFileProcessors in this SG\n+   */\n+  private Set<TsFileProcessor> reportedTsps = new HashSet<>();\n+\n+  public StorageGroupInfo(StorageGroupProcessor storageGroupProcessor) {\n+    this.storageGroupProcessor = storageGroupProcessor;\n+    unsealedResourceMemCost = new AtomicLong();\n+    memTableCost = new AtomicLong();\n+    chunkMetadataMemCost = new AtomicLong();\n+    walMemCost = new AtomicLong();\n+  }\n+\n+  public StorageGroupProcessor getStorageGroupProcessor() {\n+    return storageGroupProcessor;\n+  }\n+\n+  /**\n+   * When create a new TsFileProcessor, call this method to report it\n+   */\n+  public void reportTsFileProcessorInfo(TsFileProcessor tsFileProcessor) {\n+    if (reportedTsps.add(tsFileProcessor)) {\n+      walMemCost.getAndAdd(IoTDBDescriptor.getInstance().getConfig().getWalBufferSize());\n+    }\n+  }\n+\n+  public void addUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost.getAndAdd(cost);\n+  }\n+\n+  public void addChunkMetadataMemCost(long cost) {\n+    chunkMetadataMemCost.getAndAdd(cost);\n+  }\n+\n+  public void addMemTableCost(long cost) {\n+    memTableCost.getAndAdd(cost);\n+  }\n+\n+  /**\n+   * called by TSPInfo when closing a TSP\n+   */\n+  public void resetUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost.getAndAdd(-cost);\n+  }\n+\n+  /**\n+   * called by TSPInfo when closing a TSP\n+   */\n+  public void resetChunkMetadataMemCost(long cost) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxMjAwMA==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515712000", "createdAt": "2020-11-02T02:26:19Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.rescon.SystemInfo;\n+\n+/**\n+ * The storageGroupInfo records the total memory cost of the Storage Group.\n+ */\n+public class StorageGroupInfo {\n+\n+  private StorageGroupProcessor storageGroupProcessor;\n+\n+  /**\n+   * The total memory cost of the unsealed TsFileResources in this SG\n+   */\n+  private AtomicLong unsealedResourceMemCost;\n+\n+  /**\n+   * The total memtable memory cost in this SG\n+   */\n+  private AtomicLong memTableCost;\n+\n+  /**\n+   * The total memory cost of ChunkMetadata in this SG\n+   */\n+  private AtomicLong chunkMetadataMemCost;\n+\n+  /**\n+   * The total memory cost of WALs in this SG\n+   */\n+  private AtomicLong walMemCost;\n+\n+  /**\n+   * The threshold of reporting it's size to SystemInfo\n+   */\n+  private long storageGroupSizeReportThreshold = \n+      IoTDBDescriptor.getInstance().getConfig().getStorageGroupSizeReportThreshold();\n+\n+  private long lastReportedSize = 0L;\n+\n+  /**\n+   * A set of all unclosed TsFileProcessors in this SG\n+   */\n+  private Set<TsFileProcessor> reportedTsps = new HashSet<>();\n+\n+  public StorageGroupInfo(StorageGroupProcessor storageGroupProcessor) {\n+    this.storageGroupProcessor = storageGroupProcessor;\n+    unsealedResourceMemCost = new AtomicLong();\n+    memTableCost = new AtomicLong();\n+    chunkMetadataMemCost = new AtomicLong();\n+    walMemCost = new AtomicLong();\n+  }\n+\n+  public StorageGroupProcessor getStorageGroupProcessor() {\n+    return storageGroupProcessor;\n+  }\n+\n+  /**\n+   * When create a new TsFileProcessor, call this method to report it\n+   */\n+  public void reportTsFileProcessorInfo(TsFileProcessor tsFileProcessor) {\n+    if (reportedTsps.add(tsFileProcessor)) {\n+      walMemCost.getAndAdd(IoTDBDescriptor.getInstance().getConfig().getWalBufferSize());\n+    }\n+  }\n+\n+  public void addUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost.getAndAdd(cost);\n+  }\n+\n+  public void addChunkMetadataMemCost(long cost) {\n+    chunkMetadataMemCost.getAndAdd(cost);\n+  }\n+\n+  public void addMemTableCost(long cost) {\n+    memTableCost.getAndAdd(cost);\n+  }\n+\n+  /**\n+   * called by TSPInfo when closing a TSP\n+   */\n+  public void resetUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost.getAndAdd(-cost);\n+  }\n+\n+  /**\n+   * called by TSPInfo when closing a TSP\n+   */\n+  public void resetChunkMetadataMemCost(long cost) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzNDc3OQ=="}, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTIzODUxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxNToyNDoxM1rOHrv3fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjo0Njo0MFrOHr0zDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzNTA3MA==", "bodyText": "why only this cost impact the lastReportedSize?", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515635070", "createdAt": "2020-11-01T15:24:13Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.rescon.SystemInfo;\n+\n+/**\n+ * The storageGroupInfo records the total memory cost of the Storage Group.\n+ */\n+public class StorageGroupInfo {\n+\n+  private StorageGroupProcessor storageGroupProcessor;\n+\n+  /**\n+   * The total memory cost of the unsealed TsFileResources in this SG\n+   */\n+  private AtomicLong unsealedResourceMemCost;\n+\n+  /**\n+   * The total memtable memory cost in this SG\n+   */\n+  private AtomicLong memTableCost;\n+\n+  /**\n+   * The total memory cost of ChunkMetadata in this SG\n+   */\n+  private AtomicLong chunkMetadataMemCost;\n+\n+  /**\n+   * The total memory cost of WALs in this SG\n+   */\n+  private AtomicLong walMemCost;\n+\n+  /**\n+   * The threshold of reporting it's size to SystemInfo\n+   */\n+  private long storageGroupSizeReportThreshold = \n+      IoTDBDescriptor.getInstance().getConfig().getStorageGroupSizeReportThreshold();\n+\n+  private long lastReportedSize = 0L;\n+\n+  /**\n+   * A set of all unclosed TsFileProcessors in this SG\n+   */\n+  private Set<TsFileProcessor> reportedTsps = new HashSet<>();\n+\n+  public StorageGroupInfo(StorageGroupProcessor storageGroupProcessor) {\n+    this.storageGroupProcessor = storageGroupProcessor;\n+    unsealedResourceMemCost = new AtomicLong();\n+    memTableCost = new AtomicLong();\n+    chunkMetadataMemCost = new AtomicLong();\n+    walMemCost = new AtomicLong();\n+  }\n+\n+  public StorageGroupProcessor getStorageGroupProcessor() {\n+    return storageGroupProcessor;\n+  }\n+\n+  /**\n+   * When create a new TsFileProcessor, call this method to report it\n+   */\n+  public void reportTsFileProcessorInfo(TsFileProcessor tsFileProcessor) {\n+    if (reportedTsps.add(tsFileProcessor)) {\n+      walMemCost.getAndAdd(IoTDBDescriptor.getInstance().getConfig().getWalBufferSize());\n+    }\n+  }\n+\n+  public void addUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost.getAndAdd(cost);\n+  }\n+\n+  public void addChunkMetadataMemCost(long cost) {\n+    chunkMetadataMemCost.getAndAdd(cost);\n+  }\n+\n+  public void addMemTableCost(long cost) {\n+    memTableCost.getAndAdd(cost);\n+  }\n+\n+  /**\n+   * called by TSPInfo when closing a TSP\n+   */\n+  public void resetUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost.getAndAdd(-cost);\n+  }\n+\n+  /**\n+   * called by TSPInfo when closing a TSP\n+   */\n+  public void resetChunkMetadataMemCost(long cost) {\n+    chunkMetadataMemCost.getAndAdd(-cost);\n+  }\n+\n+  /**\n+   * called by TSPInfo when a memTable flushed\n+   */\n+  public void resetMemTableCost(long cost) {\n+    memTableCost.getAndAdd(-cost);\n+    lastReportedSize -= cost;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNTg1Mw==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515715853", "createdAt": "2020-11-02T02:46:40Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.rescon.SystemInfo;\n+\n+/**\n+ * The storageGroupInfo records the total memory cost of the Storage Group.\n+ */\n+public class StorageGroupInfo {\n+\n+  private StorageGroupProcessor storageGroupProcessor;\n+\n+  /**\n+   * The total memory cost of the unsealed TsFileResources in this SG\n+   */\n+  private AtomicLong unsealedResourceMemCost;\n+\n+  /**\n+   * The total memtable memory cost in this SG\n+   */\n+  private AtomicLong memTableCost;\n+\n+  /**\n+   * The total memory cost of ChunkMetadata in this SG\n+   */\n+  private AtomicLong chunkMetadataMemCost;\n+\n+  /**\n+   * The total memory cost of WALs in this SG\n+   */\n+  private AtomicLong walMemCost;\n+\n+  /**\n+   * The threshold of reporting it's size to SystemInfo\n+   */\n+  private long storageGroupSizeReportThreshold = \n+      IoTDBDescriptor.getInstance().getConfig().getStorageGroupSizeReportThreshold();\n+\n+  private long lastReportedSize = 0L;\n+\n+  /**\n+   * A set of all unclosed TsFileProcessors in this SG\n+   */\n+  private Set<TsFileProcessor> reportedTsps = new HashSet<>();\n+\n+  public StorageGroupInfo(StorageGroupProcessor storageGroupProcessor) {\n+    this.storageGroupProcessor = storageGroupProcessor;\n+    unsealedResourceMemCost = new AtomicLong();\n+    memTableCost = new AtomicLong();\n+    chunkMetadataMemCost = new AtomicLong();\n+    walMemCost = new AtomicLong();\n+  }\n+\n+  public StorageGroupProcessor getStorageGroupProcessor() {\n+    return storageGroupProcessor;\n+  }\n+\n+  /**\n+   * When create a new TsFileProcessor, call this method to report it\n+   */\n+  public void reportTsFileProcessorInfo(TsFileProcessor tsFileProcessor) {\n+    if (reportedTsps.add(tsFileProcessor)) {\n+      walMemCost.getAndAdd(IoTDBDescriptor.getInstance().getConfig().getWalBufferSize());\n+    }\n+  }\n+\n+  public void addUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost.getAndAdd(cost);\n+  }\n+\n+  public void addChunkMetadataMemCost(long cost) {\n+    chunkMetadataMemCost.getAndAdd(cost);\n+  }\n+\n+  public void addMemTableCost(long cost) {\n+    memTableCost.getAndAdd(cost);\n+  }\n+\n+  /**\n+   * called by TSPInfo when closing a TSP\n+   */\n+  public void resetUnsealedResourceMemCost(long cost) {\n+    unsealedResourceMemCost.getAndAdd(-cost);\n+  }\n+\n+  /**\n+   * called by TSPInfo when closing a TSP\n+   */\n+  public void resetChunkMetadataMemCost(long cost) {\n+    chunkMetadataMemCost.getAndAdd(-cost);\n+  }\n+\n+  /**\n+   * called by TSPInfo when a memTable flushed\n+   */\n+  public void resetMemTableCost(long cost) {\n+    memTableCost.getAndAdd(-cost);\n+    lastReportedSize -= cost;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzNTA3MA=="}, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTIzOTIzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxNToyNDo1NFrOHrv30Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjoyOTo1MVrOHr0mnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzNTE1Mw==", "bodyText": "do we need four AtomicLongs?", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515635153", "createdAt": "2020-11-01T15:24:54Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.rescon.SystemInfo;\n+\n+/**\n+ * The storageGroupInfo records the total memory cost of the Storage Group.\n+ */\n+public class StorageGroupInfo {\n+\n+  private StorageGroupProcessor storageGroupProcessor;\n+\n+  /**\n+   * The total memory cost of the unsealed TsFileResources in this SG\n+   */\n+  private AtomicLong unsealedResourceMemCost;\n+\n+  /**\n+   * The total memtable memory cost in this SG\n+   */\n+  private AtomicLong memTableCost;\n+\n+  /**\n+   * The total memory cost of ChunkMetadata in this SG\n+   */\n+  private AtomicLong chunkMetadataMemCost;\n+\n+  /**\n+   * The total memory cost of WALs in this SG\n+   */\n+  private AtomicLong walMemCost;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxMjY3MQ==", "bodyText": "Yes, it is not necessary to use four costs here.  This four AtomicLongs can be merged into to one.", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515712671", "createdAt": "2020-11-02T02:29:51Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.rescon.SystemInfo;\n+\n+/**\n+ * The storageGroupInfo records the total memory cost of the Storage Group.\n+ */\n+public class StorageGroupInfo {\n+\n+  private StorageGroupProcessor storageGroupProcessor;\n+\n+  /**\n+   * The total memory cost of the unsealed TsFileResources in this SG\n+   */\n+  private AtomicLong unsealedResourceMemCost;\n+\n+  /**\n+   * The total memtable memory cost in this SG\n+   */\n+  private AtomicLong memTableCost;\n+\n+  /**\n+   * The total memory cost of ChunkMetadata in this SG\n+   */\n+  private AtomicLong chunkMetadataMemCost;\n+\n+  /**\n+   * The total memory cost of WALs in this SG\n+   */\n+  private AtomicLong walMemCost;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzNTE1Mw=="}, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTI0MjE3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxNToyODozMFrOHrv5Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjo1Njo1MVrOHr066g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzNTUxOQ==", "bodyText": "add a parameter in config file?", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515635519", "createdAt": "2020-11-01T15:28:30Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -121,15 +120,37 @@\n   private RandomDeleteCache<PartialPath, MNode> mNodeCache;\n   // tag key -> tag value -> LeafMNode\n   private Map<String, Map<String, Set<MeasurementMNode>>> tagIndex = new HashMap<>();\n-  // storage group name -> the series number\n-  private Map<String, Integer> seriesNumberInStorageGroups = new HashMap<>();\n-  private long maxSeriesNumberAmongStorageGroup;\n+\n+  // data type -> number\n+  private Map<TSDataType, Integer> schemaDataTypeNumMap = new ConcurrentHashMap<>();\n+  // reported total series number\n+  private long reportedDataTypeTotalNum;\n+  private long totalSeriesNumber = 0L;\n   private boolean initialized;\n+  protected static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+\n   private File logFile;\n   private ScheduledExecutorService timedCreateMTreeSnapshotThread;\n \n+  /**\n+   * threshold total size of MTree\n+   */\n+  private static final long MTREE_SIZE_THRESHOLD = config.getAllocateMemoryForMTree();\n+\n+  private boolean allowToCreateNewSeries = true;\n+\n+  private static final int ESTIMATED_SERIES_SIZE = 300;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNzg2Ng==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515717866", "createdAt": "2020-11-02T02:56:51Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -121,15 +120,37 @@\n   private RandomDeleteCache<PartialPath, MNode> mNodeCache;\n   // tag key -> tag value -> LeafMNode\n   private Map<String, Map<String, Set<MeasurementMNode>>> tagIndex = new HashMap<>();\n-  // storage group name -> the series number\n-  private Map<String, Integer> seriesNumberInStorageGroups = new HashMap<>();\n-  private long maxSeriesNumberAmongStorageGroup;\n+\n+  // data type -> number\n+  private Map<TSDataType, Integer> schemaDataTypeNumMap = new ConcurrentHashMap<>();\n+  // reported total series number\n+  private long reportedDataTypeTotalNum;\n+  private long totalSeriesNumber = 0L;\n   private boolean initialized;\n+  protected static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+\n   private File logFile;\n   private ScheduledExecutorService timedCreateMTreeSnapshotThread;\n \n+  /**\n+   * threshold total size of MTree\n+   */\n+  private static final long MTREE_SIZE_THRESHOLD = config.getAllocateMemoryForMTree();\n+\n+  private boolean allowToCreateNewSeries = true;\n+\n+  private static final int ESTIMATED_SERIES_SIZE = 300;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzNTUxOQ=="}, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTI0NDAwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxNTozMDoxN1rOHrv6Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjo1Nzo1MFrOHr07sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzNTc1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      + \"please increase memory\");\n          \n          \n            \n                      + \"please increase MAX_HEAP_SIZE in iotdb-env.sh/bat and restart\");", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515635755", "createdAt": "2020-11-01T15:30:17Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -359,6 +377,10 @@ public void createTimeseries(CreateTimeSeriesPlan plan) throws MetadataException\n \n   @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws MetadataException {\n+    if (!allowToCreateNewSeries) {\n+      throw new MetadataException(\"IoTDB system load is too large to create timeseries, \"\n+          + \"please increase memory\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxODA2NQ==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515718065", "createdAt": "2020-11-02T02:57:50Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -359,6 +377,10 @@ public void createTimeseries(CreateTimeSeriesPlan plan) throws MetadataException\n \n   @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n   public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws MetadataException {\n+    if (!allowToCreateNewSeries) {\n+      throw new MetadataException(\"IoTDB system load is too large to create timeseries, \"\n+          + \"please increase memory\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzNTc1NQ=="}, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTI0NzE3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxNTozNDoyM1rOHrv72g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjo1OTo0NVrOHr09BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzNjE4Ng==", "bodyText": "use sg name?  will the StorageGroupInfo be changed?", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515636186", "createdAt": "2020-11-01T15:34:23Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.flush.FlushManager;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupInfo;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SystemInfo {\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final Logger logger = LoggerFactory.getLogger(SystemInfo.class);\n+\n+  private long totalSgMemCost;\n+  private volatile boolean rejected = false;\n+\n+  private Map<StorageGroupInfo, Long> reportedSgMemCostMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxODQwNA==", "bodyText": "I use the StorageGroupInfo as a reference here, it's useful when getting tsp to be flushed.", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515718404", "createdAt": "2020-11-02T02:59:45Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.flush.FlushManager;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupInfo;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SystemInfo {\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final Logger logger = LoggerFactory.getLogger(SystemInfo.class);\n+\n+  private long totalSgMemCost;\n+  private volatile boolean rejected = false;\n+\n+  private Map<StorageGroupInfo, Long> reportedSgMemCostMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYzNjE4Ng=="}, "originalCommit": {"oid": "da98fb206b66e25186ac979e209d087cc33de845"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjE0MzYwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNTo1OTo1MVrOHr3Iuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNTo1OTo1MVrOHr3Iuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1NDE3MQ==", "bodyText": "memoryCost", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515754171", "createdAt": "2020-11-02T05:59:51Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.rescon.SystemInfo;\n+\n+/**\n+ * The storageGroupInfo records the total memory cost of the Storage Group.\n+ */\n+public class StorageGroupInfo {\n+\n+  private StorageGroupProcessor storageGroupProcessor;\n+\n+  /**\n+   * The total Storage group memory cost\n+   */\n+  private AtomicLong memTableCost;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85a0eee2db3d1440dffd94829557f6c573264f4"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjE1MDkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNjowNDoxM1rOHr3M5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNjowNDoxM1rOHr3M5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1NTIzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void reportTsFileProcessorInfo(TsFileProcessor tsFileProcessor) {\n          \n          \n            \n              public void initTsFileProcessorInfo(TsFileProcessor tsFileProcessor) {", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515755238", "createdAt": "2020-11-02T06:04:13Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupInfo.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.engine.storagegroup;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.rescon.SystemInfo;\n+\n+/**\n+ * The storageGroupInfo records the total memory cost of the Storage Group.\n+ */\n+public class StorageGroupInfo {\n+\n+  private StorageGroupProcessor storageGroupProcessor;\n+\n+  /**\n+   * The total Storage group memory cost\n+   */\n+  private AtomicLong memTableCost;\n+\n+  /**\n+   * The threshold of reporting it's size to SystemInfo\n+   */\n+  private long storageGroupSizeReportThreshold = \n+      IoTDBDescriptor.getInstance().getConfig().getStorageGroupSizeReportThreshold();\n+\n+  private long lastReportedSize = 0L;\n+\n+  /**\n+   * A set of all unclosed TsFileProcessors in this SG\n+   */\n+  private Set<TsFileProcessor> reportedTsps = new HashSet<>();\n+\n+  public StorageGroupInfo(StorageGroupProcessor storageGroupProcessor) {\n+    this.storageGroupProcessor = storageGroupProcessor;\n+    memTableCost = new AtomicLong();\n+  }\n+\n+  public StorageGroupProcessor getStorageGroupProcessor() {\n+    return storageGroupProcessor;\n+  }\n+\n+  /**\n+   * When create a new TsFileProcessor, call this method to report it\n+   */\n+  public void reportTsFileProcessorInfo(TsFileProcessor tsFileProcessor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85a0eee2db3d1440dffd94829557f6c573264f4"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjE2NDk1OnYy", "diffSide": "RIGHT", "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNjoxMTozOVrOHr3Uuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNjoyMzo0NlrOHr3hdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1NzI0Mw==", "bodyText": "add  comment for this parameter", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515757243", "createdAt": "2020-11-02T06:11:39Z", "author": {"login": "jixuan1989"}, "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "diffHunk": "@@ -179,7 +179,7 @@ tsfile_size_threshold=536870912\n # When a memTable's size (in byte) exceeds this, the memtable is flushed to disk. The default threshold is 1 GB.\n memtable_size_threshold=1073741824\n \n-avg_series_point_number_threshold=100000\n+avg_series_point_number_threshold=10000", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85a0eee2db3d1440dffd94829557f6c573264f4"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc2MDUwMQ==", "bodyText": "sure", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515760501", "createdAt": "2020-11-02T06:23:46Z", "author": {"login": "HTHou"}, "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "diffHunk": "@@ -179,7 +179,7 @@ tsfile_size_threshold=536870912\n # When a memTable's size (in byte) exceeds this, the memtable is flushed to disk. The default threshold is 1 GB.\n memtable_size_threshold=1073741824\n \n-avg_series_point_number_threshold=100000\n+avg_series_point_number_threshold=10000", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1NzI0Mw=="}, "originalCommit": {"oid": "d85a0eee2db3d1440dffd94829557f6c573264f4"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjE2ODQxOnYy", "diffSide": "RIGHT", "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNjoxMzo0MFrOHr3Wzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNjoyMzozNVrOHr3hTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1Nzc3NA==", "bodyText": "0.8 of total memory? or write_memory?", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515757774", "createdAt": "2020-11-02T06:13:40Z", "author": {"login": "jixuan1989"}, "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "diffHunk": "@@ -218,28 +218,35 @@ mtree_snapshot_threshold_time=3600\n ### Memory Control Configuration\n ####################\n \n-# This adapter could adjust the system memory to avoid OOM.\n-# It will refuse to create time series or add storage groups under high system load.\n-#\n-# Attention!!!\n-# If disable this parameter, you need to set some parameters according to your system load:\n-# Normal scenario: 1-50 storage groups. <100k devices, <10M time series\n-# memtable_size_threshold = tsfile_size_threshold = IoTDB memory allocation in byte / 2 / num of storage group / 4\n-# Make sure the total num of time series in system * primitive_array_size * 16 <= IoTDB memory allocation in byte / 2 / 4\n-# you could reduce the primitive_array_size in very high workload.\n-enable_parameter_adapter=true\n-\n-# Memory Allocation Ratio: Write, Read, and Free Memory.\n-# The parameter form is a:b:c, where a, b and c are integers. for example: 1:1:1 , 6:3:1\n-write_read_free_memory_proportion=6:3:1\n+# Whether to enable memory control\n+enable_mem_control=true\n+\n+# Memory Allocation Ratio: Write, Read, Schema and Free Memory.\n+# The parameter form is a:b:c:d, where a, b, c and d are integers. for example: 1:1:1:1 , 6:2:1:1\n+write_read_schema_free_memory_proportion=4:3:1:2\n \n # primitive array size (length of each array) in array pool\n primitive_array_size=128\n \n+# Ratio of memory allocated for buffered arrays, 0.8 by default\n+buffered_arrays_memory_proportion=0.8", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85a0eee2db3d1440dffd94829557f6c573264f4"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc2MDQ2Mw==", "bodyText": "0.8 of write memory", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515760463", "createdAt": "2020-11-02T06:23:35Z", "author": {"login": "HTHou"}, "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "diffHunk": "@@ -218,28 +218,35 @@ mtree_snapshot_threshold_time=3600\n ### Memory Control Configuration\n ####################\n \n-# This adapter could adjust the system memory to avoid OOM.\n-# It will refuse to create time series or add storage groups under high system load.\n-#\n-# Attention!!!\n-# If disable this parameter, you need to set some parameters according to your system load:\n-# Normal scenario: 1-50 storage groups. <100k devices, <10M time series\n-# memtable_size_threshold = tsfile_size_threshold = IoTDB memory allocation in byte / 2 / num of storage group / 4\n-# Make sure the total num of time series in system * primitive_array_size * 16 <= IoTDB memory allocation in byte / 2 / 4\n-# you could reduce the primitive_array_size in very high workload.\n-enable_parameter_adapter=true\n-\n-# Memory Allocation Ratio: Write, Read, and Free Memory.\n-# The parameter form is a:b:c, where a, b and c are integers. for example: 1:1:1 , 6:3:1\n-write_read_free_memory_proportion=6:3:1\n+# Whether to enable memory control\n+enable_mem_control=true\n+\n+# Memory Allocation Ratio: Write, Read, Schema and Free Memory.\n+# The parameter form is a:b:c:d, where a, b, c and d are integers. for example: 1:1:1:1 , 6:2:1:1\n+write_read_schema_free_memory_proportion=4:3:1:2\n \n # primitive array size (length of each array) in array pool\n primitive_array_size=128\n \n+# Ratio of memory allocated for buffered arrays, 0.8 by default\n+buffered_arrays_memory_proportion=0.8", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1Nzc3NA=="}, "originalCommit": {"oid": "d85a0eee2db3d1440dffd94829557f6c573264f4"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjE3MDUyOnYy", "diffSide": "RIGHT", "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNjoxNDo0NVrOHr3YCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNjo0MjoyNlrOHr32YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1ODA4OA==", "bodyText": "comment is  not clear.", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515758088", "createdAt": "2020-11-02T06:14:45Z", "author": {"login": "jixuan1989"}, "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "diffHunk": "@@ -218,28 +218,35 @@ mtree_snapshot_threshold_time=3600\n ### Memory Control Configuration\n ####################\n \n-# This adapter could adjust the system memory to avoid OOM.\n-# It will refuse to create time series or add storage groups under high system load.\n-#\n-# Attention!!!\n-# If disable this parameter, you need to set some parameters according to your system load:\n-# Normal scenario: 1-50 storage groups. <100k devices, <10M time series\n-# memtable_size_threshold = tsfile_size_threshold = IoTDB memory allocation in byte / 2 / num of storage group / 4\n-# Make sure the total num of time series in system * primitive_array_size * 16 <= IoTDB memory allocation in byte / 2 / 4\n-# you could reduce the primitive_array_size in very high workload.\n-enable_parameter_adapter=true\n-\n-# Memory Allocation Ratio: Write, Read, and Free Memory.\n-# The parameter form is a:b:c, where a, b and c are integers. for example: 1:1:1 , 6:3:1\n-write_read_free_memory_proportion=6:3:1\n+# Whether to enable memory control\n+enable_mem_control=true\n+\n+# Memory Allocation Ratio: Write, Read, Schema and Free Memory.\n+# The parameter form is a:b:c:d, where a, b, c and d are integers. for example: 1:1:1:1 , 6:2:1:1\n+write_read_schema_free_memory_proportion=4:3:1:2\n \n # primitive array size (length of each array) in array pool\n primitive_array_size=128\n \n+# Ratio of memory allocated for buffered arrays, 0.8 by default\n+buffered_arrays_memory_proportion=0.8\n+\n+# Flush proportion for system, 0.3 by default\n+flush_proportion=0.3\n+\n+# Reject proportion for system, 0.8 by default\n+reject_proportion=0.8\n+\n+# If storage group increased more than this threshold, report to system. The default value is 16MB", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85a0eee2db3d1440dffd94829557f6c573264f4"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc2NTg1Nw==", "bodyText": "Comment enriched", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515765857", "createdAt": "2020-11-02T06:42:26Z", "author": {"login": "HTHou"}, "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "diffHunk": "@@ -218,28 +218,35 @@ mtree_snapshot_threshold_time=3600\n ### Memory Control Configuration\n ####################\n \n-# This adapter could adjust the system memory to avoid OOM.\n-# It will refuse to create time series or add storage groups under high system load.\n-#\n-# Attention!!!\n-# If disable this parameter, you need to set some parameters according to your system load:\n-# Normal scenario: 1-50 storage groups. <100k devices, <10M time series\n-# memtable_size_threshold = tsfile_size_threshold = IoTDB memory allocation in byte / 2 / num of storage group / 4\n-# Make sure the total num of time series in system * primitive_array_size * 16 <= IoTDB memory allocation in byte / 2 / 4\n-# you could reduce the primitive_array_size in very high workload.\n-enable_parameter_adapter=true\n-\n-# Memory Allocation Ratio: Write, Read, and Free Memory.\n-# The parameter form is a:b:c, where a, b and c are integers. for example: 1:1:1 , 6:3:1\n-write_read_free_memory_proportion=6:3:1\n+# Whether to enable memory control\n+enable_mem_control=true\n+\n+# Memory Allocation Ratio: Write, Read, Schema and Free Memory.\n+# The parameter form is a:b:c:d, where a, b, c and d are integers. for example: 1:1:1:1 , 6:2:1:1\n+write_read_schema_free_memory_proportion=4:3:1:2\n \n # primitive array size (length of each array) in array pool\n primitive_array_size=128\n \n+# Ratio of memory allocated for buffered arrays, 0.8 by default\n+buffered_arrays_memory_proportion=0.8\n+\n+# Flush proportion for system, 0.3 by default\n+flush_proportion=0.3\n+\n+# Reject proportion for system, 0.8 by default\n+reject_proportion=0.8\n+\n+# If storage group increased more than this threshold, report to system. The default value is 16MB", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1ODA4OA=="}, "originalCommit": {"oid": "d85a0eee2db3d1440dffd94829557f6c573264f4"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjE4MzIxOnYy", "diffSide": "RIGHT", "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNjoyMTo0NFrOHr3fZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNjo0MTo0MVrOHr31eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1OTk3Mw==", "bodyText": "unit", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515759973", "createdAt": "2020-11-02T06:21:44Z", "author": {"login": "jixuan1989"}, "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "diffHunk": "@@ -218,28 +218,35 @@ mtree_snapshot_threshold_time=3600\n ### Memory Control Configuration\n ####################\n \n-# This adapter could adjust the system memory to avoid OOM.\n-# It will refuse to create time series or add storage groups under high system load.\n-#\n-# Attention!!!\n-# If disable this parameter, you need to set some parameters according to your system load:\n-# Normal scenario: 1-50 storage groups. <100k devices, <10M time series\n-# memtable_size_threshold = tsfile_size_threshold = IoTDB memory allocation in byte / 2 / num of storage group / 4\n-# Make sure the total num of time series in system * primitive_array_size * 16 <= IoTDB memory allocation in byte / 2 / 4\n-# you could reduce the primitive_array_size in very high workload.\n-enable_parameter_adapter=true\n-\n-# Memory Allocation Ratio: Write, Read, and Free Memory.\n-# The parameter form is a:b:c, where a, b and c are integers. for example: 1:1:1 , 6:3:1\n-write_read_free_memory_proportion=6:3:1\n+# Whether to enable memory control\n+enable_mem_control=true\n+\n+# Memory Allocation Ratio: Write, Read, Schema and Free Memory.\n+# The parameter form is a:b:c:d, where a, b, c and d are integers. for example: 1:1:1:1 , 6:2:1:1\n+write_read_schema_free_memory_proportion=4:3:1:2\n \n # primitive array size (length of each array) in array pool\n primitive_array_size=128\n \n+# Ratio of memory allocated for buffered arrays, 0.8 by default\n+buffered_arrays_memory_proportion=0.8\n+\n+# Flush proportion for system, 0.3 by default\n+flush_proportion=0.3\n+\n+# Reject proportion for system, 0.8 by default\n+reject_proportion=0.8\n+\n+# If storage group increased more than this threshold, report to system. The default value is 16MB\n+storage_group_report_threshold=16777216\n+\n # allowed max numbers of deduplicated path in one query\n # it's just an advised value, the real limitation will be the smaller one between this and the one we calculated\n max_deduplicated_path_num=1000\n \n+# estimated metadata size of one timeseries in Mtree\n+estimated_series_size=300", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85a0eee2db3d1440dffd94829557f6c573264f4"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc2NTYyNg==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515765626", "createdAt": "2020-11-02T06:41:41Z", "author": {"login": "HTHou"}, "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "diffHunk": "@@ -218,28 +218,35 @@ mtree_snapshot_threshold_time=3600\n ### Memory Control Configuration\n ####################\n \n-# This adapter could adjust the system memory to avoid OOM.\n-# It will refuse to create time series or add storage groups under high system load.\n-#\n-# Attention!!!\n-# If disable this parameter, you need to set some parameters according to your system load:\n-# Normal scenario: 1-50 storage groups. <100k devices, <10M time series\n-# memtable_size_threshold = tsfile_size_threshold = IoTDB memory allocation in byte / 2 / num of storage group / 4\n-# Make sure the total num of time series in system * primitive_array_size * 16 <= IoTDB memory allocation in byte / 2 / 4\n-# you could reduce the primitive_array_size in very high workload.\n-enable_parameter_adapter=true\n-\n-# Memory Allocation Ratio: Write, Read, and Free Memory.\n-# The parameter form is a:b:c, where a, b and c are integers. for example: 1:1:1 , 6:3:1\n-write_read_free_memory_proportion=6:3:1\n+# Whether to enable memory control\n+enable_mem_control=true\n+\n+# Memory Allocation Ratio: Write, Read, Schema and Free Memory.\n+# The parameter form is a:b:c:d, where a, b, c and d are integers. for example: 1:1:1:1 , 6:2:1:1\n+write_read_schema_free_memory_proportion=4:3:1:2\n \n # primitive array size (length of each array) in array pool\n primitive_array_size=128\n \n+# Ratio of memory allocated for buffered arrays, 0.8 by default\n+buffered_arrays_memory_proportion=0.8\n+\n+# Flush proportion for system, 0.3 by default\n+flush_proportion=0.3\n+\n+# Reject proportion for system, 0.8 by default\n+reject_proportion=0.8\n+\n+# If storage group increased more than this threshold, report to system. The default value is 16MB\n+storage_group_report_threshold=16777216\n+\n # allowed max numbers of deduplicated path in one query\n # it's just an advised value, the real limitation will be the smaller one between this and the one we calculated\n max_deduplicated_path_num=1000\n \n+# estimated metadata size of one timeseries in Mtree\n+estimated_series_size=300", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1OTk3Mw=="}, "originalCommit": {"oid": "d85a0eee2db3d1440dffd94829557f6c573264f4"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjI2ODkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzowNTo0OVrOHr4QlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzowNTo0OVrOHr4QlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc3MjU2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public boolean checkIfNeedStartNewChunk(String deviceId, String measurement) {\n          \n          \n            \n              public boolean checkIfChunkDoesNotExist(String deviceId, String measurement) {", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515772565", "createdAt": "2020-11-02T07:05:49Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "diffHunk": "@@ -159,6 +171,21 @@ public void write(InsertTabletPlan insertTabletPlan, int start, int end) {\n     }\n   }\n \n+  @Override\n+  public boolean checkIfNeedStartNewChunk(String deviceId, String measurement) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60ca098c18fea40c3d38e39135d4103f73a3c73"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjI4MDY2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoxMToyNVrOHr4XLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoxMToyNVrOHr4XLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc3NDI1Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                logger.debug(\"Report Storage Group Status to system. \"\n          \n          \n            \n                      + \"Current sg mem cost is {}, delta is {}.\", totalSgMemCost, delta);\n          \n          \n            \n                logger.debug(\"Report Storage Group Status to the system. \"\n          \n          \n            \n                      + \"After adding {}, current sg mem cost is {}.\", delta, totalSgMemCost);", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515774253", "createdAt": "2020-11-02T07:11:25Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.flush.FlushManager;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupInfo;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SystemInfo {\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final Logger logger = LoggerFactory.getLogger(SystemInfo.class);\n+\n+  private long totalSgMemCost;\n+  private volatile boolean rejected = false;\n+\n+  private Map<StorageGroupInfo, Long> reportedSgMemCostMap = new HashMap<>();\n+\n+  private static final double FLUSH_PROPORTION = config.getFlushProportion();\n+  private static final double REJECT_PROPORTION = config.getRejectProportion();\n+\n+  /**\n+   * Report current mem cost of storage group to system.\n+   *\n+   * @param storageGroupInfo storage group\n+   */\n+  public synchronized void reportStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    long delta = storageGroupInfo.getSgMemCost() -\n+        reportedSgMemCostMap.getOrDefault(storageGroupInfo, 0L);\n+    totalSgMemCost += delta;\n+    logger.debug(\"Report Storage Group Status to system. \"\n+          + \"Current sg mem cost is {}, delta is {}.\", totalSgMemCost, delta);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60ca098c18fea40c3d38e39135d4103f73a3c73"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjI4ODM1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoxNDozM1rOHr4boA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoxNDozM1rOHr4boA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc3NTM5Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n          \n          \n            \n                if (totalSgMemCost >= config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515775392", "createdAt": "2020-11-02T07:14:33Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.flush.FlushManager;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupInfo;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SystemInfo {\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final Logger logger = LoggerFactory.getLogger(SystemInfo.class);\n+\n+  private long totalSgMemCost;\n+  private volatile boolean rejected = false;\n+\n+  private Map<StorageGroupInfo, Long> reportedSgMemCostMap = new HashMap<>();\n+\n+  private static final double FLUSH_PROPORTION = config.getFlushProportion();\n+  private static final double REJECT_PROPORTION = config.getRejectProportion();\n+\n+  /**\n+   * Report current mem cost of storage group to system.\n+   *\n+   * @param storageGroupInfo storage group\n+   */\n+  public synchronized void reportStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    long delta = storageGroupInfo.getSgMemCost() -\n+        reportedSgMemCostMap.getOrDefault(storageGroupInfo, 0L);\n+    totalSgMemCost += delta;\n+    logger.debug(\"Report Storage Group Status to system. \"\n+          + \"Current sg mem cost is {}, delta is {}.\", totalSgMemCost, delta);\n+    reportedSgMemCostMap.put(storageGroupInfo, storageGroupInfo.getSgMemCost());\n+    storageGroupInfo.setLastReportedSize(storageGroupInfo.getSgMemCost());\n+    if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60ca098c18fea40c3d38e39135d4103f73a3c73"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjI4ODc3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoxNDo0M1rOHr4b3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoxNDo0M1rOHr4b3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc3NTQ1Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {\n          \n          \n            \n                if (totalSgMemCost >= config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515775452", "createdAt": "2020-11-02T07:14:43Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.flush.FlushManager;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupInfo;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SystemInfo {\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final Logger logger = LoggerFactory.getLogger(SystemInfo.class);\n+\n+  private long totalSgMemCost;\n+  private volatile boolean rejected = false;\n+\n+  private Map<StorageGroupInfo, Long> reportedSgMemCostMap = new HashMap<>();\n+\n+  private static final double FLUSH_PROPORTION = config.getFlushProportion();\n+  private static final double REJECT_PROPORTION = config.getRejectProportion();\n+\n+  /**\n+   * Report current mem cost of storage group to system.\n+   *\n+   * @param storageGroupInfo storage group\n+   */\n+  public synchronized void reportStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    long delta = storageGroupInfo.getSgMemCost() -\n+        reportedSgMemCostMap.getOrDefault(storageGroupInfo, 0L);\n+    totalSgMemCost += delta;\n+    logger.debug(\"Report Storage Group Status to system. \"\n+          + \"Current sg mem cost is {}, delta is {}.\", totalSgMemCost, delta);\n+    reportedSgMemCostMap.put(storageGroupInfo, storageGroupInfo.getSgMemCost());\n+    storageGroupInfo.setLastReportedSize(storageGroupInfo.getSgMemCost());\n+    if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+      logger.debug(\"The total storage group mem costs are too large, call for flushing. \"\n+          + \"Current sg cost is {}\", totalSgMemCost);\n+      flush();\n+    }\n+    if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60ca098c18fea40c3d38e39135d4103f73a3c73"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjI4OTQyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoxNTowMFrOHr4cPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoxNTowMFrOHr4cPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc3NTU1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  logger.debug(\"Change system to reject status...\");\n          \n          \n            \n                  logger.info(\"Change system to reject status...\");\n          \n      \n    \n    \n  \n\nAdd current memory info", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515775551", "createdAt": "2020-11-02T07:15:00Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.flush.FlushManager;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupInfo;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SystemInfo {\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final Logger logger = LoggerFactory.getLogger(SystemInfo.class);\n+\n+  private long totalSgMemCost;\n+  private volatile boolean rejected = false;\n+\n+  private Map<StorageGroupInfo, Long> reportedSgMemCostMap = new HashMap<>();\n+\n+  private static final double FLUSH_PROPORTION = config.getFlushProportion();\n+  private static final double REJECT_PROPORTION = config.getRejectProportion();\n+\n+  /**\n+   * Report current mem cost of storage group to system.\n+   *\n+   * @param storageGroupInfo storage group\n+   */\n+  public synchronized void reportStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    long delta = storageGroupInfo.getSgMemCost() -\n+        reportedSgMemCostMap.getOrDefault(storageGroupInfo, 0L);\n+    totalSgMemCost += delta;\n+    logger.debug(\"Report Storage Group Status to system. \"\n+          + \"Current sg mem cost is {}, delta is {}.\", totalSgMemCost, delta);\n+    reportedSgMemCostMap.put(storageGroupInfo, storageGroupInfo.getSgMemCost());\n+    storageGroupInfo.setLastReportedSize(storageGroupInfo.getSgMemCost());\n+    if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+      logger.debug(\"The total storage group mem costs are too large, call for flushing. \"\n+          + \"Current sg cost is {}\", totalSgMemCost);\n+      flush();\n+    }\n+    if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {\n+      logger.debug(\"Change system to reject status...\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60ca098c18fea40c3d38e39135d4103f73a3c73"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjI5ODYzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoxOTozM1rOHr4h7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoxOTozM1rOHr4h7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc3NzAwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (getTotalMemCost() < config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {\n          \n          \n            \n                  if (totalSgMemCost < config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515777007", "createdAt": "2020-11-02T07:19:33Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.flush.FlushManager;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupInfo;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SystemInfo {\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final Logger logger = LoggerFactory.getLogger(SystemInfo.class);\n+\n+  private long totalSgMemCost;\n+  private volatile boolean rejected = false;\n+\n+  private Map<StorageGroupInfo, Long> reportedSgMemCostMap = new HashMap<>();\n+\n+  private static final double FLUSH_PROPORTION = config.getFlushProportion();\n+  private static final double REJECT_PROPORTION = config.getRejectProportion();\n+\n+  /**\n+   * Report current mem cost of storage group to system.\n+   *\n+   * @param storageGroupInfo storage group\n+   */\n+  public synchronized void reportStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    long delta = storageGroupInfo.getSgMemCost() -\n+        reportedSgMemCostMap.getOrDefault(storageGroupInfo, 0L);\n+    totalSgMemCost += delta;\n+    logger.debug(\"Report Storage Group Status to system. \"\n+          + \"Current sg mem cost is {}, delta is {}.\", totalSgMemCost, delta);\n+    reportedSgMemCostMap.put(storageGroupInfo, storageGroupInfo.getSgMemCost());\n+    storageGroupInfo.setLastReportedSize(storageGroupInfo.getSgMemCost());\n+    if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+      logger.debug(\"The total storage group mem costs are too large, call for flushing. \"\n+          + \"Current sg cost is {}\", totalSgMemCost);\n+      flush();\n+    }\n+    if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {\n+      logger.debug(\"Change system to reject status...\");\n+      rejected = true;\n+    }\n+  }\n+\n+  /**\n+   * Report resetting the mem cost of sg to system. It will be invoked after closing file.\n+   *\n+   * @param storageGroupInfo storage group\n+   */\n+  public synchronized void resetStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    if (reportedSgMemCostMap.containsKey(storageGroupInfo)) {\n+      this.totalSgMemCost -= reportedSgMemCostMap.get(storageGroupInfo)\n+          - storageGroupInfo.getSgMemCost();\n+      storageGroupInfo.setLastReportedSize(storageGroupInfo.getSgMemCost());\n+      if (getTotalMemCost() > config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+        logger.debug(\"Some sg memery released, call flush.\");\n+        logCost();\n+        forceFlush();\n+      }\n+      if (getTotalMemCost() < config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60ca098c18fea40c3d38e39135d4103f73a3c73"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjI5ODk4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoxOTo0MVrOHr4iJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoxOTo0MVrOHr4iJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc3NzA2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (getTotalMemCost() > config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n          \n          \n            \n                  if (totalSgMemCost > config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515777060", "createdAt": "2020-11-02T07:19:41Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.flush.FlushManager;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupInfo;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SystemInfo {\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final Logger logger = LoggerFactory.getLogger(SystemInfo.class);\n+\n+  private long totalSgMemCost;\n+  private volatile boolean rejected = false;\n+\n+  private Map<StorageGroupInfo, Long> reportedSgMemCostMap = new HashMap<>();\n+\n+  private static final double FLUSH_PROPORTION = config.getFlushProportion();\n+  private static final double REJECT_PROPORTION = config.getRejectProportion();\n+\n+  /**\n+   * Report current mem cost of storage group to system.\n+   *\n+   * @param storageGroupInfo storage group\n+   */\n+  public synchronized void reportStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    long delta = storageGroupInfo.getSgMemCost() -\n+        reportedSgMemCostMap.getOrDefault(storageGroupInfo, 0L);\n+    totalSgMemCost += delta;\n+    logger.debug(\"Report Storage Group Status to system. \"\n+          + \"Current sg mem cost is {}, delta is {}.\", totalSgMemCost, delta);\n+    reportedSgMemCostMap.put(storageGroupInfo, storageGroupInfo.getSgMemCost());\n+    storageGroupInfo.setLastReportedSize(storageGroupInfo.getSgMemCost());\n+    if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+      logger.debug(\"The total storage group mem costs are too large, call for flushing. \"\n+          + \"Current sg cost is {}\", totalSgMemCost);\n+      flush();\n+    }\n+    if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {\n+      logger.debug(\"Change system to reject status...\");\n+      rejected = true;\n+    }\n+  }\n+\n+  /**\n+   * Report resetting the mem cost of sg to system. It will be invoked after closing file.\n+   *\n+   * @param storageGroupInfo storage group\n+   */\n+  public synchronized void resetStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    if (reportedSgMemCostMap.containsKey(storageGroupInfo)) {\n+      this.totalSgMemCost -= reportedSgMemCostMap.get(storageGroupInfo)\n+          - storageGroupInfo.getSgMemCost();\n+      storageGroupInfo.setLastReportedSize(storageGroupInfo.getSgMemCost());\n+      if (getTotalMemCost() > config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60ca098c18fea40c3d38e39135d4103f73a3c73"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjI5OTk3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoyMDowNlrOHr4itw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoyMDowNlrOHr4itw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc3NzIwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Some sg memery released, set system to normal status.\");\n          \n          \n            \n                    logger.debug(\"Some sg memory released, set system to normal status.\");", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515777207", "createdAt": "2020-11-02T07:20:06Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.flush.FlushManager;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupInfo;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SystemInfo {\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final Logger logger = LoggerFactory.getLogger(SystemInfo.class);\n+\n+  private long totalSgMemCost;\n+  private volatile boolean rejected = false;\n+\n+  private Map<StorageGroupInfo, Long> reportedSgMemCostMap = new HashMap<>();\n+\n+  private static final double FLUSH_PROPORTION = config.getFlushProportion();\n+  private static final double REJECT_PROPORTION = config.getRejectProportion();\n+\n+  /**\n+   * Report current mem cost of storage group to system.\n+   *\n+   * @param storageGroupInfo storage group\n+   */\n+  public synchronized void reportStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    long delta = storageGroupInfo.getSgMemCost() -\n+        reportedSgMemCostMap.getOrDefault(storageGroupInfo, 0L);\n+    totalSgMemCost += delta;\n+    logger.debug(\"Report Storage Group Status to system. \"\n+          + \"Current sg mem cost is {}, delta is {}.\", totalSgMemCost, delta);\n+    reportedSgMemCostMap.put(storageGroupInfo, storageGroupInfo.getSgMemCost());\n+    storageGroupInfo.setLastReportedSize(storageGroupInfo.getSgMemCost());\n+    if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+      logger.debug(\"The total storage group mem costs are too large, call for flushing. \"\n+          + \"Current sg cost is {}\", totalSgMemCost);\n+      flush();\n+    }\n+    if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {\n+      logger.debug(\"Change system to reject status...\");\n+      rejected = true;\n+    }\n+  }\n+\n+  /**\n+   * Report resetting the mem cost of sg to system. It will be invoked after closing file.\n+   *\n+   * @param storageGroupInfo storage group\n+   */\n+  public synchronized void resetStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    if (reportedSgMemCostMap.containsKey(storageGroupInfo)) {\n+      this.totalSgMemCost -= reportedSgMemCostMap.get(storageGroupInfo)\n+          - storageGroupInfo.getSgMemCost();\n+      storageGroupInfo.setLastReportedSize(storageGroupInfo.getSgMemCost());\n+      if (getTotalMemCost() > config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+        logger.debug(\"Some sg memery released, call flush.\");\n+        logCost();\n+        forceFlush();\n+      }\n+      if (getTotalMemCost() < config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {\n+        logger.debug(\"Some sg memery released, set system to normal status.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60ca098c18fea40c3d38e39135d4103f73a3c73"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjMwMDc1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoyMDoxNVrOHr4jHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoyMDoxNVrOHr4jHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc3NzMwOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.warn(\"Some sg memery released, but system is still in reject status.\");\n          \n          \n            \n                    logger.warn(\"Some sg memory released, but system is still in reject status.\");", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515777309", "createdAt": "2020-11-02T07:20:15Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.flush.FlushManager;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupInfo;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SystemInfo {\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final Logger logger = LoggerFactory.getLogger(SystemInfo.class);\n+\n+  private long totalSgMemCost;\n+  private volatile boolean rejected = false;\n+\n+  private Map<StorageGroupInfo, Long> reportedSgMemCostMap = new HashMap<>();\n+\n+  private static final double FLUSH_PROPORTION = config.getFlushProportion();\n+  private static final double REJECT_PROPORTION = config.getRejectProportion();\n+\n+  /**\n+   * Report current mem cost of storage group to system.\n+   *\n+   * @param storageGroupInfo storage group\n+   */\n+  public synchronized void reportStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    long delta = storageGroupInfo.getSgMemCost() -\n+        reportedSgMemCostMap.getOrDefault(storageGroupInfo, 0L);\n+    totalSgMemCost += delta;\n+    logger.debug(\"Report Storage Group Status to system. \"\n+          + \"Current sg mem cost is {}, delta is {}.\", totalSgMemCost, delta);\n+    reportedSgMemCostMap.put(storageGroupInfo, storageGroupInfo.getSgMemCost());\n+    storageGroupInfo.setLastReportedSize(storageGroupInfo.getSgMemCost());\n+    if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+      logger.debug(\"The total storage group mem costs are too large, call for flushing. \"\n+          + \"Current sg cost is {}\", totalSgMemCost);\n+      flush();\n+    }\n+    if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {\n+      logger.debug(\"Change system to reject status...\");\n+      rejected = true;\n+    }\n+  }\n+\n+  /**\n+   * Report resetting the mem cost of sg to system. It will be invoked after closing file.\n+   *\n+   * @param storageGroupInfo storage group\n+   */\n+  public synchronized void resetStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    if (reportedSgMemCostMap.containsKey(storageGroupInfo)) {\n+      this.totalSgMemCost -= reportedSgMemCostMap.get(storageGroupInfo)\n+          - storageGroupInfo.getSgMemCost();\n+      storageGroupInfo.setLastReportedSize(storageGroupInfo.getSgMemCost());\n+      if (getTotalMemCost() > config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+        logger.debug(\"Some sg memery released, call flush.\");\n+        logCost();\n+        forceFlush();\n+      }\n+      if (getTotalMemCost() < config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {\n+        logger.debug(\"Some sg memery released, set system to normal status.\");\n+        logCost();\n+        rejected = false;\n+      } else {\n+        logger.warn(\"Some sg memery released, but system is still in reject status.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60ca098c18fea40c3d38e39135d4103f73a3c73"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjMwMTQ4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoyMDozNVrOHr4jlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoyMDozNVrOHr4jlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc3NzQyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Some sg memery released, call flush.\");\n          \n          \n            \n                    logger.debug(\"Some sg memory released, call flush.\");", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515777428", "createdAt": "2020-11-02T07:20:35Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.flush.FlushManager;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupInfo;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SystemInfo {\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final Logger logger = LoggerFactory.getLogger(SystemInfo.class);\n+\n+  private long totalSgMemCost;\n+  private volatile boolean rejected = false;\n+\n+  private Map<StorageGroupInfo, Long> reportedSgMemCostMap = new HashMap<>();\n+\n+  private static final double FLUSH_PROPORTION = config.getFlushProportion();\n+  private static final double REJECT_PROPORTION = config.getRejectProportion();\n+\n+  /**\n+   * Report current mem cost of storage group to system.\n+   *\n+   * @param storageGroupInfo storage group\n+   */\n+  public synchronized void reportStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    long delta = storageGroupInfo.getSgMemCost() -\n+        reportedSgMemCostMap.getOrDefault(storageGroupInfo, 0L);\n+    totalSgMemCost += delta;\n+    logger.debug(\"Report Storage Group Status to system. \"\n+          + \"Current sg mem cost is {}, delta is {}.\", totalSgMemCost, delta);\n+    reportedSgMemCostMap.put(storageGroupInfo, storageGroupInfo.getSgMemCost());\n+    storageGroupInfo.setLastReportedSize(storageGroupInfo.getSgMemCost());\n+    if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+      logger.debug(\"The total storage group mem costs are too large, call for flushing. \"\n+          + \"Current sg cost is {}\", totalSgMemCost);\n+      flush();\n+    }\n+    if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {\n+      logger.debug(\"Change system to reject status...\");\n+      rejected = true;\n+    }\n+  }\n+\n+  /**\n+   * Report resetting the mem cost of sg to system. It will be invoked after closing file.\n+   *\n+   * @param storageGroupInfo storage group\n+   */\n+  public synchronized void resetStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    if (reportedSgMemCostMap.containsKey(storageGroupInfo)) {\n+      this.totalSgMemCost -= reportedSgMemCostMap.get(storageGroupInfo)\n+          - storageGroupInfo.getSgMemCost();\n+      storageGroupInfo.setLastReportedSize(storageGroupInfo.getSgMemCost());\n+      if (getTotalMemCost() > config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+        logger.debug(\"Some sg memery released, call flush.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60ca098c18fea40c3d38e39135d4103f73a3c73"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjMwMzA4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoyMToyM1rOHr4kgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoyMToyM1rOHr4kgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc3NzY2Ng==", "bodyText": "if you only use !enableMemControl, why not call it disableMemControl", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515777666", "createdAt": "2020-11-02T07:21:23Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "diffHunk": "@@ -56,6 +56,17 @@\n \n   private long memSize = 0;\n \n+  /**\n+   * The initial value is false because we should calculate the text data size when recover\n+   * memTable!!\n+   */\n+  protected boolean enableMemControl = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60ca098c18fea40c3d38e39135d4103f73a3c73"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjMwNDUyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoyMTo1OFrOHr4lWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzoyMTo1OFrOHr4lWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc3Nzg4Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private void logCost() {\n          \n          \n            \n              private void logCurrentTotalSGMemory() {", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515777882", "createdAt": "2020-11-02T07:21:58Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/SystemInfo.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.flush.FlushManager;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupInfo;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SystemInfo {\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final Logger logger = LoggerFactory.getLogger(SystemInfo.class);\n+\n+  private long totalSgMemCost;\n+  private volatile boolean rejected = false;\n+\n+  private Map<StorageGroupInfo, Long> reportedSgMemCostMap = new HashMap<>();\n+\n+  private static final double FLUSH_PROPORTION = config.getFlushProportion();\n+  private static final double REJECT_PROPORTION = config.getRejectProportion();\n+\n+  /**\n+   * Report current mem cost of storage group to system.\n+   *\n+   * @param storageGroupInfo storage group\n+   */\n+  public synchronized void reportStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    long delta = storageGroupInfo.getSgMemCost() -\n+        reportedSgMemCostMap.getOrDefault(storageGroupInfo, 0L);\n+    totalSgMemCost += delta;\n+    logger.debug(\"Report Storage Group Status to system. \"\n+          + \"Current sg mem cost is {}, delta is {}.\", totalSgMemCost, delta);\n+    reportedSgMemCostMap.put(storageGroupInfo, storageGroupInfo.getSgMemCost());\n+    storageGroupInfo.setLastReportedSize(storageGroupInfo.getSgMemCost());\n+    if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+      logger.debug(\"The total storage group mem costs are too large, call for flushing. \"\n+          + \"Current sg cost is {}\", totalSgMemCost);\n+      flush();\n+    }\n+    if (getTotalMemCost() >= config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {\n+      logger.debug(\"Change system to reject status...\");\n+      rejected = true;\n+    }\n+  }\n+\n+  /**\n+   * Report resetting the mem cost of sg to system. It will be invoked after closing file.\n+   *\n+   * @param storageGroupInfo storage group\n+   */\n+  public synchronized void resetStorageGroupStatus(StorageGroupInfo storageGroupInfo) {\n+    if (reportedSgMemCostMap.containsKey(storageGroupInfo)) {\n+      this.totalSgMemCost -= reportedSgMemCostMap.get(storageGroupInfo)\n+          - storageGroupInfo.getSgMemCost();\n+      storageGroupInfo.setLastReportedSize(storageGroupInfo.getSgMemCost());\n+      if (getTotalMemCost() > config.getAllocateMemoryForWrite() * FLUSH_PROPORTION) {\n+        logger.debug(\"Some sg memery released, call flush.\");\n+        logCost();\n+        forceFlush();\n+      }\n+      if (getTotalMemCost() < config.getAllocateMemoryForWrite() * REJECT_PROPORTION) {\n+        logger.debug(\"Some sg memery released, set system to normal status.\");\n+        logCost();\n+        rejected = false;\n+      } else {\n+        logger.warn(\"Some sg memery released, but system is still in reject status.\");\n+        logCost();\n+        rejected = true;\n+      }\n+      reportedSgMemCostMap.put(storageGroupInfo, storageGroupInfo.getSgMemCost());\n+    }\n+  }\n+\n+  private void logCost() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60ca098c18fea40c3d38e39135d4103f73a3c73"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjYzNDIyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/IMemTable.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOTowNzoyOFrOHr7nZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOTowNzoyOFrOHr7nZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgyNzU1Nw==", "bodyText": "add javadoc: must guarantee the device exists in the workmemtable", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r515827557", "createdAt": "2020-11-02T09:07:28Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/IMemTable.java", "diffHunk": "@@ -121,6 +132,21 @@ ReadOnlyMemChunk query(String deviceId, String measurement, TSDataType dataType,\n \n   void release();\n \n+  /**\n+   * only used when mem control enabled\n+   */\n+  boolean checkIfNeedStartNewChunk(String deviceId, String measurement);\n+\n+  /**\n+   * only used when mem control enabled\n+   */\n+  int getCurrentTVListSize(String deviceId, String measurement);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60ca098c18fea40c3d38e39135d4103f73a3c73"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDE0Mjk3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/rescon/PrimitiveArrayManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNTo0MDo1OFrOHsJ0Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNTo0MDo1OFrOHsJ0Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2MDE5MA==", "bodyText": "why synchronized", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r516060190", "createdAt": "2020-11-02T15:40:58Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/rescon/PrimitiveArrayManager.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.rescon;\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Manage all primitive data list in memory, including get and release operation.\n+ */\n+public class PrimitiveArrayManager {\n+\n+  /**\n+   * data type -> ArrayDeque<Array>\n+   */\n+  private static final Map<TSDataType, ArrayDeque<Object>> bufferedArraysMap = new EnumMap<>(\n+      TSDataType.class);\n+\n+  /**\n+   * data type -> current number of buffered arrays\n+   */\n+  private static final Map<TSDataType, Integer> bufferedArraysNumMap = new EnumMap<>(\n+      TSDataType.class);\n+\n+  /**\n+   * data type -> ratio of data type in schema, which could be seen as recommended ratio\n+   */\n+  private static final Map<TSDataType, Double> bufferedArraysNumRatio = new EnumMap<>(\n+      TSDataType.class);\n+  private static int currentDataTypeTotalNum = 0;\n+\n+  private static final Logger logger = LoggerFactory.getLogger(PrimitiveArrayManager.class);\n+\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+\n+  public static final int ARRAY_SIZE = config.getPrimitiveArraySize();\n+\n+  /**\n+   * threshold total size of arrays for all data types\n+   */\n+  private static final double BUFFERED_ARRAY_SIZE_THRESHOLD =\n+      config.getAllocateMemoryForWrite() * config.getBufferedArraysMemoryProportion();\n+\n+  /**\n+   * total size of buffered arrays\n+   */\n+  private static AtomicLong bufferedArraysRamSize = new AtomicLong();\n+\n+  /**\n+   * total size of out of buffer arrays\n+   */\n+  private static AtomicLong outOfBufferArraysRamSize = new AtomicLong();\n+\n+  static {\n+    bufferedArraysMap.put(TSDataType.BOOLEAN, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.INT32, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.INT64, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.FLOAT, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.DOUBLE, new ArrayDeque<>());\n+    bufferedArraysMap.put(TSDataType.TEXT, new ArrayDeque<>());\n+  }\n+\n+  private PrimitiveArrayManager() {\n+    logger.info(\"BufferedArraySizeThreshold is {}\", BUFFERED_ARRAY_SIZE_THRESHOLD);\n+  }\n+\n+  /**\n+   * Get primitive data lists according to type\n+   *\n+   * @param dataType data type\n+   * @return an array\n+   */\n+  public static Object getPrimitiveArraysByType(TSDataType dataType) {\n+    // check memory of buffered array, if already full, generate OOB\n+    if (bufferedArraysRamSize.get() + ARRAY_SIZE * dataType.getDataTypeSize()\n+        > BUFFERED_ARRAY_SIZE_THRESHOLD) {\n+      // return an out of buffer array\n+      outOfBufferArraysRamSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+      return createPrimitiveArray(dataType);\n+    }\n+\n+    synchronized (bufferedArraysMap.get(dataType)) {\n+      // try to get a buffered array\n+      Object dataArray = bufferedArraysMap.get(dataType).poll();\n+      if (dataArray != null) {\n+        return dataArray;\n+      }\n+      // no buffered array, create one\n+      bufferedArraysNumMap.put(dataType, bufferedArraysNumMap.getOrDefault(dataType, 0) + 1);\n+      bufferedArraysRamSize.addAndGet(ARRAY_SIZE * dataType.getDataTypeSize());\n+    }\n+\n+    return createPrimitiveArray(dataType);\n+  }\n+\n+  private static Object createPrimitiveArray(TSDataType dataType) {\n+    Object dataArray;\n+    switch (dataType) {\n+      case BOOLEAN:\n+        dataArray = new boolean[ARRAY_SIZE];\n+        break;\n+      case INT32:\n+        dataArray = new int[ARRAY_SIZE];\n+        break;\n+      case INT64:\n+        dataArray = new long[ARRAY_SIZE];\n+        break;\n+      case FLOAT:\n+        dataArray = new float[ARRAY_SIZE];\n+        break;\n+      case DOUBLE:\n+        dataArray = new double[ARRAY_SIZE];\n+        break;\n+      case TEXT:\n+        dataArray = new Binary[ARRAY_SIZE];\n+        break;\n+      default:\n+        throw new UnSupportedDataTypeException(dataType.toString());\n+    }\n+\n+    return dataArray;\n+  }\n+\n+  /**\n+   * Get primitive data lists according to data type and size, only for TVList's sorting\n+   *\n+   * @param dataType data type\n+   * @param size     needed capacity\n+   * @return an array of primitive data arrays\n+   */\n+  public static synchronized Object createDataListsByType(TSDataType dataType, int size) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e53f49e4ab1c68e6277d343b91d03c37e0159fc"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDE2MDk3OnYy", "diffSide": "LEFT", "path": "server/src/main/java/org/apache/iotdb/db/utils/datastructure/BinaryTVList.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNTo0NDo1MVrOHsJ_Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMjoxNzoxMlrOHsePAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2MzA3OA==", "bodyText": "now, sorted timestamps use new memory? no OOM danger?", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r516063078", "createdAt": "2020-11-02T15:44:51Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/datastructure/BinaryTVList.java", "diffHunk": "@@ -120,9 +119,6 @@ void clearValue() {\n   @Override\n   void clearSortedValue() {\n     if (sortedValues != null) {\n-      for (Binary[] dataArray : sortedValues) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e53f49e4ab1c68e6277d343b91d03c37e0159fc"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NDc1Mg==", "bodyText": "The memory usage of sorting arrays is not considered in writing memory now. That why I changed the default writing memory size from 60% -> 40% of JVM heap size.\nI added some comments to class TVList.", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r516394752", "createdAt": "2020-11-03T02:17:12Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/datastructure/BinaryTVList.java", "diffHunk": "@@ -120,9 +119,6 @@ void clearValue() {\n   @Override\n   void clearSortedValue() {\n     if (sortedValues != null) {\n-      for (Binary[] dataArray : sortedValues) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2MzA3OA=="}, "originalCommit": {"oid": "9e53f49e4ab1c68e6277d343b91d03c37e0159fc"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDIzNjU2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNjowMToxNVrOHsKvBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMjoxMjowM1rOHseKqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA3NTI3MA==", "bodyText": "concurrency problem?", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r516075270", "createdAt": "2020-11-02T16:01:15Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -394,14 +411,13 @@ public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws Meta\n         }\n       }\n \n-      // update statistics\n-      if (config.isEnableParameterAdapter()) {\n-        int size = seriesNumberInStorageGroups.get(storageGroupPath.getFullPath());\n-        seriesNumberInStorageGroups.put(storageGroupPath.getFullPath(), size + 1);\n-        if (size + 1 > maxSeriesNumberAmongStorageGroup) {\n-          maxSeriesNumberAmongStorageGroup = size + 1L;\n-        }\n+      // update statistics and schemaDataTypeNumMap\n+      totalSeriesNumber++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e53f49e4ab1c68e6277d343b91d03c37e0159fc"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5MzY0Mg==", "bodyText": "Changed it to AtomicLong.", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r516393642", "createdAt": "2020-11-03T02:12:03Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -394,14 +411,13 @@ public void createTimeseries(CreateTimeSeriesPlan plan, long offset) throws Meta\n         }\n       }\n \n-      // update statistics\n-      if (config.isEnableParameterAdapter()) {\n-        int size = seriesNumberInStorageGroups.get(storageGroupPath.getFullPath());\n-        seriesNumberInStorageGroups.put(storageGroupPath.getFullPath(), size + 1);\n-        if (size + 1 > maxSeriesNumberAmongStorageGroup) {\n-          maxSeriesNumberAmongStorageGroup = size + 1L;\n-        }\n+      // update statistics and schemaDataTypeNumMap\n+      totalSeriesNumber++;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA3NTI3MA=="}, "originalCommit": {"oid": "9e53f49e4ab1c68e6277d343b91d03c37e0159fc"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDIzOTMzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNjowMTo1NFrOHsKwvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMjoxMTowOVrOHseJ-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA3NTcxMA==", "bodyText": "how about set currentDataTypeTotalNum as a field?", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r516075710", "createdAt": "2020-11-02T16:01:54Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -589,39 +580,58 @@ public void setStorageGroup(PartialPath storageGroup) throws MetadataException {\n   public void deleteStorageGroups(List<PartialPath> storageGroups) throws MetadataException {\n     try {\n       for (PartialPath storageGroup : storageGroups) {\n-\n+        totalSeriesNumber -= mtree.getAllTimeseriesCount(storageGroup);\n         // clear cached MNode\n+        if (!allowToCreateNewSeries && \n+            totalSeriesNumber * ESTIMATED_SERIES_SIZE < MTREE_SIZE_THRESHOLD) {\n+          logger.info(\"Current series number {} come back to normal level\", totalSeriesNumber);\n+          allowToCreateNewSeries = true;\n+        }\n         mNodeCache.clear();\n \n         // try to delete storage group\n         List<MeasurementMNode> leafMNodes = mtree.deleteStorageGroup(storageGroup);\n         for (MeasurementMNode leafMNode : leafMNodes) {\n           removeFromTagInvertedIndex(leafMNode);\n+          // update statistics in schemaDataTypeNumMap\n+          updateSchemaDataTypeNumMap(leafMNode.getSchema().getType(), -1);\n         }\n \n-        if (config.isEnableParameterAdapter()) {\n-          IoTDBConfigDynamicAdapter.getInstance().addOrDeleteStorageGroup(-1);\n-          int size = seriesNumberInStorageGroups.get(storageGroup.getFullPath());\n-          IoTDBConfigDynamicAdapter.getInstance().addOrDeleteTimeSeries(size * -1);\n-          ActiveTimeSeriesCounter.getInstance().delete(storageGroup.getFullPath());\n-          seriesNumberInStorageGroups.remove(storageGroup.getFullPath());\n-          if (size == maxSeriesNumberAmongStorageGroup) {\n-            maxSeriesNumberAmongStorageGroup =\n-                seriesNumberInStorageGroups.values().stream().max(Integer::compareTo).orElse(0);\n-          }\n-        }\n         // if success\n         if (!isRecovering) {\n           logWriter.deleteStorageGroup(storageGroup.getFullPath());\n         }\n       }\n-    } catch (ConfigAdjusterException e) {\n-      throw new MetadataException(e);\n     } catch (IOException e) {\n       throw new MetadataException(e.getMessage());\n     }\n   }\n \n+  /**\n+   * update statistics in schemaDataTypeNumMap\n+   *\n+   * @param type data type\n+   * @param num  1 for creating timeseries and -1 for deleting timeseries\n+   */\n+  private synchronized void updateSchemaDataTypeNumMap(TSDataType type, int num) {\n+    // add an array of the series type\n+    schemaDataTypeNumMap.put(type, schemaDataTypeNumMap.getOrDefault(type, 0) + num);\n+    // add an array of time\n+    schemaDataTypeNumMap.put(TSDataType.INT64,\n+        schemaDataTypeNumMap.getOrDefault(TSDataType.INT64, 0) + num);\n+\n+    int currentDataTypeTotalNum = 0;\n+    for (int typeSize : schemaDataTypeNumMap.values()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e53f49e4ab1c68e6277d343b91d03c37e0159fc"}, "originalPosition": 377}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5MzQ2Nw==", "bodyText": "This number can be get from totalSeriesNumber * 2. The calculation should be removed.", "url": "https://github.com/apache/iotdb/pull/1524#discussion_r516393467", "createdAt": "2020-11-03T02:11:09Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -589,39 +580,58 @@ public void setStorageGroup(PartialPath storageGroup) throws MetadataException {\n   public void deleteStorageGroups(List<PartialPath> storageGroups) throws MetadataException {\n     try {\n       for (PartialPath storageGroup : storageGroups) {\n-\n+        totalSeriesNumber -= mtree.getAllTimeseriesCount(storageGroup);\n         // clear cached MNode\n+        if (!allowToCreateNewSeries && \n+            totalSeriesNumber * ESTIMATED_SERIES_SIZE < MTREE_SIZE_THRESHOLD) {\n+          logger.info(\"Current series number {} come back to normal level\", totalSeriesNumber);\n+          allowToCreateNewSeries = true;\n+        }\n         mNodeCache.clear();\n \n         // try to delete storage group\n         List<MeasurementMNode> leafMNodes = mtree.deleteStorageGroup(storageGroup);\n         for (MeasurementMNode leafMNode : leafMNodes) {\n           removeFromTagInvertedIndex(leafMNode);\n+          // update statistics in schemaDataTypeNumMap\n+          updateSchemaDataTypeNumMap(leafMNode.getSchema().getType(), -1);\n         }\n \n-        if (config.isEnableParameterAdapter()) {\n-          IoTDBConfigDynamicAdapter.getInstance().addOrDeleteStorageGroup(-1);\n-          int size = seriesNumberInStorageGroups.get(storageGroup.getFullPath());\n-          IoTDBConfigDynamicAdapter.getInstance().addOrDeleteTimeSeries(size * -1);\n-          ActiveTimeSeriesCounter.getInstance().delete(storageGroup.getFullPath());\n-          seriesNumberInStorageGroups.remove(storageGroup.getFullPath());\n-          if (size == maxSeriesNumberAmongStorageGroup) {\n-            maxSeriesNumberAmongStorageGroup =\n-                seriesNumberInStorageGroups.values().stream().max(Integer::compareTo).orElse(0);\n-          }\n-        }\n         // if success\n         if (!isRecovering) {\n           logWriter.deleteStorageGroup(storageGroup.getFullPath());\n         }\n       }\n-    } catch (ConfigAdjusterException e) {\n-      throw new MetadataException(e);\n     } catch (IOException e) {\n       throw new MetadataException(e.getMessage());\n     }\n   }\n \n+  /**\n+   * update statistics in schemaDataTypeNumMap\n+   *\n+   * @param type data type\n+   * @param num  1 for creating timeseries and -1 for deleting timeseries\n+   */\n+  private synchronized void updateSchemaDataTypeNumMap(TSDataType type, int num) {\n+    // add an array of the series type\n+    schemaDataTypeNumMap.put(type, schemaDataTypeNumMap.getOrDefault(type, 0) + num);\n+    // add an array of time\n+    schemaDataTypeNumMap.put(TSDataType.INT64,\n+        schemaDataTypeNumMap.getOrDefault(TSDataType.INT64, 0) + num);\n+\n+    int currentDataTypeTotalNum = 0;\n+    for (int typeSize : schemaDataTypeNumMap.values()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA3NTcxMA=="}, "originalCommit": {"oid": "9e53f49e4ab1c68e6277d343b91d03c37e0159fc"}, "originalPosition": 377}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4742, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}