{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA0MDE1Nzgx", "number": 1828, "reviewThreads": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNTozNTowNVrOEwmj1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNjo0OToxNlrOFIC1ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Mzk4ODcxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/exception/UDFRegistrationException.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNTozNTowNVrOHmRPNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNTozNTowNVrOHmRPNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg5MDM1Ng==", "bodyText": "I recommend to make UDFRegistrationException extend StorageEngineException. In this way, we don't need to change that many files.", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r509890356", "createdAt": "2020-10-22T05:35:05Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/exception/UDFRegistrationException.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.exception;\r\n+\r\n+import org.apache.iotdb.rpc.TSStatusCode;\r\n+\r\n+public class UDFRegistrationException extends IoTDBException {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e26deab9fbfd5f1d5b590309b617509282f97a16"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTUzNDc2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFLogWriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMjoyMDozMlrOIBXgww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMjoyMDozMlrOIBXgww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODMwNDcwNw==", "bodyText": "The type of these two should better be byte.", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r538304707", "createdAt": "2020-12-08T12:20:32Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFLogWriter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.service;\r\n+\r\n+import java.io.BufferedWriter;\r\n+import java.io.File;\r\n+import java.io.FileWriter;\r\n+import java.io.IOException;\r\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\r\n+\r\n+public class UDFLogWriter {\r\n+\r\n+  public static final Short REGISTER_TYPE = 0;\r\n+  public static final Short DEREGISTER_TYPE = 1;\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32f4156e79ab2e8930e09e4a5c9a6b8bb5d19b48"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTU1Nzg4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMjoyNToyMFrOIBXu9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMjowODowOFrOIB-38A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODMwODM0Mw==", "bodyText": "There will be a lineSeparator after data[2], you should trim it", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r538308343", "createdAt": "2020-12-08T12:25:20Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.service;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.File;\r\n+import java.io.FileReader;\r\n+import java.io.IOException;\r\n+import java.lang.reflect.InvocationTargetException;\r\n+import java.net.URL;\r\n+import java.net.URLClassLoader;\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.Map.Entry;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+import org.apache.commons.io.FileUtils;\r\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\r\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\r\n+import org.apache.iotdb.db.exception.StartupException;\r\n+import org.apache.iotdb.db.exception.UDFRegistrationException;\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.db.query.udf.api.UDF;\r\n+import org.apache.iotdb.db.query.udf.core.context.UDFContext;\r\n+import org.apache.iotdb.db.service.IService;\r\n+import org.apache.iotdb.db.service.ServiceType;\r\n+import org.apache.iotdb.db.utils.TestOnly;\r\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+public class UDFRegistrationService implements IService {\r\n+\r\n+  private static final Logger logger = LoggerFactory.getLogger(UDFRegistrationService.class);\r\n+\r\n+  private static final String ULOG_FILE_DIR =\r\n+      IoTDBDescriptor.getInstance().getConfig().getSystemDir()\r\n+          + File.separator + \"udf\" + File.separator;\r\n+  private static final String LOG_FILE_NAME = ULOG_FILE_DIR + \"ulog.txt\";\r\n+  private static final String TEMPORARY_LOG_FILE_NAME = LOG_FILE_NAME + \".tmp\";\r\n+\r\n+  private final ConcurrentHashMap<String, UDFRegistrationInformation> registrationInformation;\r\n+\r\n+  private final ReentrantReadWriteLock lock;\r\n+  private UDFLogWriter temporaryLogWriter;\r\n+\r\n+  private final String libRoot;\r\n+\r\n+  private URLClassLoader udfClassLoader;\r\n+\r\n+  private UDFRegistrationService() {\r\n+    registrationInformation = new ConcurrentHashMap<>();\r\n+    lock = new ReentrantReadWriteLock();\r\n+    libRoot = parseLibRoot();\r\n+  }\r\n+\r\n+  private String parseLibRoot() {\r\n+    String jarPath = (new File(\r\n+        getClass().getProtectionDomain().getCodeSource().getLocation().getPath()))\r\n+        .getAbsolutePath();\r\n+    int lastIndex = jarPath.lastIndexOf(File.separatorChar);\r\n+    String libPath = jarPath.substring(0, lastIndex + 1);\r\n+    logger.info(\"System lib root: {}\", libPath);\r\n+    return libPath;\r\n+  }\r\n+\r\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\r\n+  public void register(String functionName, String className, boolean isTemporary,\r\n+      boolean writeToTemporaryLogFile) throws UDFRegistrationException {\r\n+    UDFRegistrationInformation information = registrationInformation.get(functionName);\r\n+    if (information != null) {\r\n+      if (information.getClassName().equals(className)) {\r\n+        String errorMessage;\r\n+        if (information.isTemporary() == isTemporary) {\r\n+          errorMessage = String\r\n+              .format(\"UDF %s(%s) has already been registered successfully.\",\r\n+                  functionName, className);\r\n+        } else {\r\n+          errorMessage = String.format(\r\n+              \"Failed to register %sTEMPORARY UDF %s(%s), because a %sTEMPORARY UDF %s(%s) with the same function name and the class name has already been registered.\",\r\n+              isTemporary ? \"\" : \"non-\", functionName, className,\r\n+              information.isTemporary() ? \"\" : \"non-\", information.getFunctionName(),\r\n+              information.getClassName());\r\n+        }\r\n+        logger.warn(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage);\r\n+      } else {\r\n+        String errorMessage = String.format(\r\n+            \"Failed to register UDF %s(%s), because a UDF %s(%s) with the same function name but a different class name has already been registered.\",\r\n+            functionName, className,\r\n+            information.getFunctionName(), information.getClassName());\r\n+        logger.warn(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage);\r\n+      }\r\n+    }\r\n+\r\n+    Class<?> functionClass;\r\n+    try {\r\n+      udfClassLoader = getUDFClassLoader();\r\n+      functionClass = Class.forName(className, true, udfClassLoader);\r\n+      functionClass.getDeclaredConstructor().newInstance();\r\n+    } catch (IOException | InstantiationException | InvocationTargetException | NoSuchMethodException | IllegalAccessException | ClassNotFoundException e) {\r\n+      String errorMessage = String.format(\r\n+          \"Failed to register UDF %s(%s), because its instance can not be constructed successfully. Exception: %s\",\r\n+          functionName, className, e.toString());\r\n+      logger.warn(errorMessage);\r\n+      throw new UDFRegistrationException(errorMessage);\r\n+    }\r\n+\r\n+    registrationInformation.put(functionName,\r\n+        new UDFRegistrationInformation(functionName, className, functionClass, isTemporary));\r\n+\r\n+    if (writeToTemporaryLogFile && !isTemporary) {\r\n+      try {\r\n+        appendRegistrationLog(functionName, className);\r\n+      } catch (IOException e) {\r\n+        registrationInformation.remove(functionName);\r\n+        String errorMessage = String\r\n+            .format(\"Failed to append UDF log when registering UDF %s(%s), because %s\",\r\n+                functionName, className, e.toString());\r\n+        logger.error(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage, e);\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  private URLClassLoader getUDFClassLoader() throws IOException {\r\n+    Collection<File> files = FileUtils\r\n+        .listFiles(SystemFileFactory.INSTANCE.getFile(libRoot), null, true);\r\n+    URL[] urls = FileUtils.toURLs(files.toArray(new File[0]));\r\n+    return new URLClassLoader(urls);\r\n+  }\r\n+\r\n+  public void deregister(String functionName) throws UDFRegistrationException {\r\n+    UDFRegistrationInformation information = registrationInformation.remove(functionName);\r\n+    if (information == null) {\r\n+      String errorMessage = String.format(\"UDF %s does not exist.\", functionName);\r\n+      logger.warn(errorMessage);\r\n+      throw new UDFRegistrationException(errorMessage);\r\n+    }\r\n+\r\n+    if (!information.isTemporary()) {\r\n+      try {\r\n+        appendDeregistrationLog(functionName);\r\n+      } catch (IOException e) {\r\n+        registrationInformation.put(functionName, information);\r\n+        String errorMessage = String\r\n+            .format(\"Failed to append UDF log when deregistering UDF %s, because %s\",\r\n+                functionName, e.toString());\r\n+        logger.error(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage, e);\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  private void appendRegistrationLog(String functionName, String className) throws IOException {\r\n+    lock.writeLock().lock();\r\n+    try {\r\n+      temporaryLogWriter.register(functionName, className);\r\n+    } finally {\r\n+      lock.writeLock().unlock();\r\n+    }\r\n+  }\r\n+\r\n+  private void appendDeregistrationLog(String functionName) throws IOException {\r\n+    lock.writeLock().lock();\r\n+    try {\r\n+      temporaryLogWriter.deregister(functionName);\r\n+    } finally {\r\n+      lock.writeLock().unlock();\r\n+    }\r\n+  }\r\n+\r\n+  public UDF reflect(UDFContext context) throws QueryProcessException {\r\n+    UDFRegistrationInformation information = registrationInformation.get(context.getName());\r\n+    if (information == null) {\r\n+      String errorMessage = String\r\n+          .format(\"Failed to reflect UDF instance, because UDF %s has not been registered.\",\r\n+              context.getName());\r\n+      logger.warn(errorMessage);\r\n+      throw new QueryProcessException(errorMessage);\r\n+    }\r\n+\r\n+    Thread.currentThread().setContextClassLoader(udfClassLoader);\r\n+    try {\r\n+      return (UDF) information.getFunctionClass().getDeclaredConstructor().newInstance();\r\n+    } catch (InstantiationException | InvocationTargetException | NoSuchMethodException | IllegalAccessException e) {\r\n+      String errorMessage = String.format(\"Failed to reflect UDF %s(%s) instance, because %s\",\r\n+          context.getName(), information.getClassName(), e.toString());\r\n+      logger.warn(errorMessage);\r\n+      throw new QueryProcessException(errorMessage);\r\n+    }\r\n+  }\r\n+\r\n+  public UDFRegistrationInformation[] getRegistrationInformation() {\r\n+    return registrationInformation.values().toArray(new UDFRegistrationInformation[0]);\r\n+  }\r\n+\r\n+  @Override\r\n+  public void start() throws StartupException {\r\n+    try {\r\n+      makeDirIfNecessary();\r\n+      doRecovery();\r\n+      temporaryLogWriter = new UDFLogWriter(TEMPORARY_LOG_FILE_NAME);\r\n+    } catch (Exception e) {\r\n+      throw new StartupException(e);\r\n+    }\r\n+  }\r\n+\r\n+  private void makeDirIfNecessary() throws IOException {\r\n+    File file = SystemFileFactory.INSTANCE.getFile(ULOG_FILE_DIR);\r\n+    if (file.exists() && file.isDirectory()) {\r\n+      return;\r\n+    }\r\n+    FileUtils.forceMkdir(file);\r\n+  }\r\n+\r\n+  private void doRecovery() throws IOException {\r\n+    File logFile = SystemFileFactory.INSTANCE.getFile(LOG_FILE_NAME);\r\n+    File temporaryLogFile = SystemFileFactory.INSTANCE.getFile(TEMPORARY_LOG_FILE_NAME);\r\n+\r\n+    if (temporaryLogFile.exists()) {\r\n+      if (logFile.exists()) {\r\n+        FileUtils.deleteQuietly(logFile);\r\n+      }\r\n+      recoveryFromLogFile(temporaryLogFile);\r\n+    } else if (logFile.exists()) {\r\n+      recoveryFromLogFile(logFile);\r\n+      FSFactoryProducer.getFSFactory().moveFile(logFile, temporaryLogFile);\r\n+    }\r\n+  }\r\n+\r\n+  private void recoveryFromLogFile(File logFile) throws IOException {\r\n+    HashMap<String, String> recoveredUDFs = new HashMap<>();\r\n+\r\n+    try (BufferedReader reader = new BufferedReader(new FileReader(logFile))) {\r\n+      String line;\r\n+      while ((line = reader.readLine()) != null) {\r\n+        String[] data = line.split(\",\");\r\n+        short type = Short.parseShort(data[0]);\r\n+        if (type == UDFLogWriter.REGISTER_TYPE) {\r\n+          recoveredUDFs.put(data[1], data[2]);\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32f4156e79ab2e8930e09e4a5c9a6b8bb5d19b48"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0OTYxNg==", "bodyText": "The return value of readLine() method is not including any line-termination characters, so I think my implementation here is ok :D", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r538949616", "createdAt": "2020-12-09T02:08:08Z", "author": {"login": "SteveYurongSu"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.service;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.File;\r\n+import java.io.FileReader;\r\n+import java.io.IOException;\r\n+import java.lang.reflect.InvocationTargetException;\r\n+import java.net.URL;\r\n+import java.net.URLClassLoader;\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.Map.Entry;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+import org.apache.commons.io.FileUtils;\r\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\r\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\r\n+import org.apache.iotdb.db.exception.StartupException;\r\n+import org.apache.iotdb.db.exception.UDFRegistrationException;\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.db.query.udf.api.UDF;\r\n+import org.apache.iotdb.db.query.udf.core.context.UDFContext;\r\n+import org.apache.iotdb.db.service.IService;\r\n+import org.apache.iotdb.db.service.ServiceType;\r\n+import org.apache.iotdb.db.utils.TestOnly;\r\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+public class UDFRegistrationService implements IService {\r\n+\r\n+  private static final Logger logger = LoggerFactory.getLogger(UDFRegistrationService.class);\r\n+\r\n+  private static final String ULOG_FILE_DIR =\r\n+      IoTDBDescriptor.getInstance().getConfig().getSystemDir()\r\n+          + File.separator + \"udf\" + File.separator;\r\n+  private static final String LOG_FILE_NAME = ULOG_FILE_DIR + \"ulog.txt\";\r\n+  private static final String TEMPORARY_LOG_FILE_NAME = LOG_FILE_NAME + \".tmp\";\r\n+\r\n+  private final ConcurrentHashMap<String, UDFRegistrationInformation> registrationInformation;\r\n+\r\n+  private final ReentrantReadWriteLock lock;\r\n+  private UDFLogWriter temporaryLogWriter;\r\n+\r\n+  private final String libRoot;\r\n+\r\n+  private URLClassLoader udfClassLoader;\r\n+\r\n+  private UDFRegistrationService() {\r\n+    registrationInformation = new ConcurrentHashMap<>();\r\n+    lock = new ReentrantReadWriteLock();\r\n+    libRoot = parseLibRoot();\r\n+  }\r\n+\r\n+  private String parseLibRoot() {\r\n+    String jarPath = (new File(\r\n+        getClass().getProtectionDomain().getCodeSource().getLocation().getPath()))\r\n+        .getAbsolutePath();\r\n+    int lastIndex = jarPath.lastIndexOf(File.separatorChar);\r\n+    String libPath = jarPath.substring(0, lastIndex + 1);\r\n+    logger.info(\"System lib root: {}\", libPath);\r\n+    return libPath;\r\n+  }\r\n+\r\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\r\n+  public void register(String functionName, String className, boolean isTemporary,\r\n+      boolean writeToTemporaryLogFile) throws UDFRegistrationException {\r\n+    UDFRegistrationInformation information = registrationInformation.get(functionName);\r\n+    if (information != null) {\r\n+      if (information.getClassName().equals(className)) {\r\n+        String errorMessage;\r\n+        if (information.isTemporary() == isTemporary) {\r\n+          errorMessage = String\r\n+              .format(\"UDF %s(%s) has already been registered successfully.\",\r\n+                  functionName, className);\r\n+        } else {\r\n+          errorMessage = String.format(\r\n+              \"Failed to register %sTEMPORARY UDF %s(%s), because a %sTEMPORARY UDF %s(%s) with the same function name and the class name has already been registered.\",\r\n+              isTemporary ? \"\" : \"non-\", functionName, className,\r\n+              information.isTemporary() ? \"\" : \"non-\", information.getFunctionName(),\r\n+              information.getClassName());\r\n+        }\r\n+        logger.warn(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage);\r\n+      } else {\r\n+        String errorMessage = String.format(\r\n+            \"Failed to register UDF %s(%s), because a UDF %s(%s) with the same function name but a different class name has already been registered.\",\r\n+            functionName, className,\r\n+            information.getFunctionName(), information.getClassName());\r\n+        logger.warn(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage);\r\n+      }\r\n+    }\r\n+\r\n+    Class<?> functionClass;\r\n+    try {\r\n+      udfClassLoader = getUDFClassLoader();\r\n+      functionClass = Class.forName(className, true, udfClassLoader);\r\n+      functionClass.getDeclaredConstructor().newInstance();\r\n+    } catch (IOException | InstantiationException | InvocationTargetException | NoSuchMethodException | IllegalAccessException | ClassNotFoundException e) {\r\n+      String errorMessage = String.format(\r\n+          \"Failed to register UDF %s(%s), because its instance can not be constructed successfully. Exception: %s\",\r\n+          functionName, className, e.toString());\r\n+      logger.warn(errorMessage);\r\n+      throw new UDFRegistrationException(errorMessage);\r\n+    }\r\n+\r\n+    registrationInformation.put(functionName,\r\n+        new UDFRegistrationInformation(functionName, className, functionClass, isTemporary));\r\n+\r\n+    if (writeToTemporaryLogFile && !isTemporary) {\r\n+      try {\r\n+        appendRegistrationLog(functionName, className);\r\n+      } catch (IOException e) {\r\n+        registrationInformation.remove(functionName);\r\n+        String errorMessage = String\r\n+            .format(\"Failed to append UDF log when registering UDF %s(%s), because %s\",\r\n+                functionName, className, e.toString());\r\n+        logger.error(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage, e);\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  private URLClassLoader getUDFClassLoader() throws IOException {\r\n+    Collection<File> files = FileUtils\r\n+        .listFiles(SystemFileFactory.INSTANCE.getFile(libRoot), null, true);\r\n+    URL[] urls = FileUtils.toURLs(files.toArray(new File[0]));\r\n+    return new URLClassLoader(urls);\r\n+  }\r\n+\r\n+  public void deregister(String functionName) throws UDFRegistrationException {\r\n+    UDFRegistrationInformation information = registrationInformation.remove(functionName);\r\n+    if (information == null) {\r\n+      String errorMessage = String.format(\"UDF %s does not exist.\", functionName);\r\n+      logger.warn(errorMessage);\r\n+      throw new UDFRegistrationException(errorMessage);\r\n+    }\r\n+\r\n+    if (!information.isTemporary()) {\r\n+      try {\r\n+        appendDeregistrationLog(functionName);\r\n+      } catch (IOException e) {\r\n+        registrationInformation.put(functionName, information);\r\n+        String errorMessage = String\r\n+            .format(\"Failed to append UDF log when deregistering UDF %s, because %s\",\r\n+                functionName, e.toString());\r\n+        logger.error(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage, e);\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  private void appendRegistrationLog(String functionName, String className) throws IOException {\r\n+    lock.writeLock().lock();\r\n+    try {\r\n+      temporaryLogWriter.register(functionName, className);\r\n+    } finally {\r\n+      lock.writeLock().unlock();\r\n+    }\r\n+  }\r\n+\r\n+  private void appendDeregistrationLog(String functionName) throws IOException {\r\n+    lock.writeLock().lock();\r\n+    try {\r\n+      temporaryLogWriter.deregister(functionName);\r\n+    } finally {\r\n+      lock.writeLock().unlock();\r\n+    }\r\n+  }\r\n+\r\n+  public UDF reflect(UDFContext context) throws QueryProcessException {\r\n+    UDFRegistrationInformation information = registrationInformation.get(context.getName());\r\n+    if (information == null) {\r\n+      String errorMessage = String\r\n+          .format(\"Failed to reflect UDF instance, because UDF %s has not been registered.\",\r\n+              context.getName());\r\n+      logger.warn(errorMessage);\r\n+      throw new QueryProcessException(errorMessage);\r\n+    }\r\n+\r\n+    Thread.currentThread().setContextClassLoader(udfClassLoader);\r\n+    try {\r\n+      return (UDF) information.getFunctionClass().getDeclaredConstructor().newInstance();\r\n+    } catch (InstantiationException | InvocationTargetException | NoSuchMethodException | IllegalAccessException e) {\r\n+      String errorMessage = String.format(\"Failed to reflect UDF %s(%s) instance, because %s\",\r\n+          context.getName(), information.getClassName(), e.toString());\r\n+      logger.warn(errorMessage);\r\n+      throw new QueryProcessException(errorMessage);\r\n+    }\r\n+  }\r\n+\r\n+  public UDFRegistrationInformation[] getRegistrationInformation() {\r\n+    return registrationInformation.values().toArray(new UDFRegistrationInformation[0]);\r\n+  }\r\n+\r\n+  @Override\r\n+  public void start() throws StartupException {\r\n+    try {\r\n+      makeDirIfNecessary();\r\n+      doRecovery();\r\n+      temporaryLogWriter = new UDFLogWriter(TEMPORARY_LOG_FILE_NAME);\r\n+    } catch (Exception e) {\r\n+      throw new StartupException(e);\r\n+    }\r\n+  }\r\n+\r\n+  private void makeDirIfNecessary() throws IOException {\r\n+    File file = SystemFileFactory.INSTANCE.getFile(ULOG_FILE_DIR);\r\n+    if (file.exists() && file.isDirectory()) {\r\n+      return;\r\n+    }\r\n+    FileUtils.forceMkdir(file);\r\n+  }\r\n+\r\n+  private void doRecovery() throws IOException {\r\n+    File logFile = SystemFileFactory.INSTANCE.getFile(LOG_FILE_NAME);\r\n+    File temporaryLogFile = SystemFileFactory.INSTANCE.getFile(TEMPORARY_LOG_FILE_NAME);\r\n+\r\n+    if (temporaryLogFile.exists()) {\r\n+      if (logFile.exists()) {\r\n+        FileUtils.deleteQuietly(logFile);\r\n+      }\r\n+      recoveryFromLogFile(temporaryLogFile);\r\n+    } else if (logFile.exists()) {\r\n+      recoveryFromLogFile(logFile);\r\n+      FSFactoryProducer.getFSFactory().moveFile(logFile, temporaryLogFile);\r\n+    }\r\n+  }\r\n+\r\n+  private void recoveryFromLogFile(File logFile) throws IOException {\r\n+    HashMap<String, String> recoveredUDFs = new HashMap<>();\r\n+\r\n+    try (BufferedReader reader = new BufferedReader(new FileReader(logFile))) {\r\n+      String line;\r\n+      while ((line = reader.readLine()) != null) {\r\n+        String[] data = line.split(\",\");\r\n+        short type = Short.parseShort(data[0]);\r\n+        if (type == UDFLogWriter.REGISTER_TYPE) {\r\n+          recoveredUDFs.put(data[1], data[2]);\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODMwODM0Mw=="}, "originalCommit": {"oid": "32f4156e79ab2e8930e09e4a5c9a6b8bb5d19b48"}, "originalPosition": 259}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTU4MzcyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMjozMDoxOFrOIBX-yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNzozODo1NlrOIG3xfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODMxMjM5Mg==", "bodyText": "It seems that you don't need to new this UDF instance here", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r538312392", "createdAt": "2020-12-08T12:30:18Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.service;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.File;\r\n+import java.io.FileReader;\r\n+import java.io.IOException;\r\n+import java.lang.reflect.InvocationTargetException;\r\n+import java.net.URL;\r\n+import java.net.URLClassLoader;\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.Map.Entry;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+import org.apache.commons.io.FileUtils;\r\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\r\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\r\n+import org.apache.iotdb.db.exception.StartupException;\r\n+import org.apache.iotdb.db.exception.UDFRegistrationException;\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.db.query.udf.api.UDF;\r\n+import org.apache.iotdb.db.query.udf.core.context.UDFContext;\r\n+import org.apache.iotdb.db.service.IService;\r\n+import org.apache.iotdb.db.service.ServiceType;\r\n+import org.apache.iotdb.db.utils.TestOnly;\r\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+public class UDFRegistrationService implements IService {\r\n+\r\n+  private static final Logger logger = LoggerFactory.getLogger(UDFRegistrationService.class);\r\n+\r\n+  private static final String ULOG_FILE_DIR =\r\n+      IoTDBDescriptor.getInstance().getConfig().getSystemDir()\r\n+          + File.separator + \"udf\" + File.separator;\r\n+  private static final String LOG_FILE_NAME = ULOG_FILE_DIR + \"ulog.txt\";\r\n+  private static final String TEMPORARY_LOG_FILE_NAME = LOG_FILE_NAME + \".tmp\";\r\n+\r\n+  private final ConcurrentHashMap<String, UDFRegistrationInformation> registrationInformation;\r\n+\r\n+  private final ReentrantReadWriteLock lock;\r\n+  private UDFLogWriter temporaryLogWriter;\r\n+\r\n+  private final String libRoot;\r\n+\r\n+  private URLClassLoader udfClassLoader;\r\n+\r\n+  private UDFRegistrationService() {\r\n+    registrationInformation = new ConcurrentHashMap<>();\r\n+    lock = new ReentrantReadWriteLock();\r\n+    libRoot = parseLibRoot();\r\n+  }\r\n+\r\n+  private String parseLibRoot() {\r\n+    String jarPath = (new File(\r\n+        getClass().getProtectionDomain().getCodeSource().getLocation().getPath()))\r\n+        .getAbsolutePath();\r\n+    int lastIndex = jarPath.lastIndexOf(File.separatorChar);\r\n+    String libPath = jarPath.substring(0, lastIndex + 1);\r\n+    logger.info(\"System lib root: {}\", libPath);\r\n+    return libPath;\r\n+  }\r\n+\r\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\r\n+  public void register(String functionName, String className, boolean isTemporary,\r\n+      boolean writeToTemporaryLogFile) throws UDFRegistrationException {\r\n+    UDFRegistrationInformation information = registrationInformation.get(functionName);\r\n+    if (information != null) {\r\n+      if (information.getClassName().equals(className)) {\r\n+        String errorMessage;\r\n+        if (information.isTemporary() == isTemporary) {\r\n+          errorMessage = String\r\n+              .format(\"UDF %s(%s) has already been registered successfully.\",\r\n+                  functionName, className);\r\n+        } else {\r\n+          errorMessage = String.format(\r\n+              \"Failed to register %sTEMPORARY UDF %s(%s), because a %sTEMPORARY UDF %s(%s) with the same function name and the class name has already been registered.\",\r\n+              isTemporary ? \"\" : \"non-\", functionName, className,\r\n+              information.isTemporary() ? \"\" : \"non-\", information.getFunctionName(),\r\n+              information.getClassName());\r\n+        }\r\n+        logger.warn(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage);\r\n+      } else {\r\n+        String errorMessage = String.format(\r\n+            \"Failed to register UDF %s(%s), because a UDF %s(%s) with the same function name but a different class name has already been registered.\",\r\n+            functionName, className,\r\n+            information.getFunctionName(), information.getClassName());\r\n+        logger.warn(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage);\r\n+      }\r\n+    }\r\n+\r\n+    Class<?> functionClass;\r\n+    try {\r\n+      udfClassLoader = getUDFClassLoader();\r\n+      functionClass = Class.forName(className, true, udfClassLoader);\r\n+      functionClass.getDeclaredConstructor().newInstance();\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32f4156e79ab2e8930e09e4a5c9a6b8bb5d19b48"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1MzIxNg==", "bodyText": "Yes, it's not necessary. I just want to make sure the instantiation process is fine, should I remove the code?", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r538953216", "createdAt": "2020-12-09T02:18:11Z", "author": {"login": "SteveYurongSu"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.service;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.File;\r\n+import java.io.FileReader;\r\n+import java.io.IOException;\r\n+import java.lang.reflect.InvocationTargetException;\r\n+import java.net.URL;\r\n+import java.net.URLClassLoader;\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.Map.Entry;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+import org.apache.commons.io.FileUtils;\r\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\r\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\r\n+import org.apache.iotdb.db.exception.StartupException;\r\n+import org.apache.iotdb.db.exception.UDFRegistrationException;\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.db.query.udf.api.UDF;\r\n+import org.apache.iotdb.db.query.udf.core.context.UDFContext;\r\n+import org.apache.iotdb.db.service.IService;\r\n+import org.apache.iotdb.db.service.ServiceType;\r\n+import org.apache.iotdb.db.utils.TestOnly;\r\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+public class UDFRegistrationService implements IService {\r\n+\r\n+  private static final Logger logger = LoggerFactory.getLogger(UDFRegistrationService.class);\r\n+\r\n+  private static final String ULOG_FILE_DIR =\r\n+      IoTDBDescriptor.getInstance().getConfig().getSystemDir()\r\n+          + File.separator + \"udf\" + File.separator;\r\n+  private static final String LOG_FILE_NAME = ULOG_FILE_DIR + \"ulog.txt\";\r\n+  private static final String TEMPORARY_LOG_FILE_NAME = LOG_FILE_NAME + \".tmp\";\r\n+\r\n+  private final ConcurrentHashMap<String, UDFRegistrationInformation> registrationInformation;\r\n+\r\n+  private final ReentrantReadWriteLock lock;\r\n+  private UDFLogWriter temporaryLogWriter;\r\n+\r\n+  private final String libRoot;\r\n+\r\n+  private URLClassLoader udfClassLoader;\r\n+\r\n+  private UDFRegistrationService() {\r\n+    registrationInformation = new ConcurrentHashMap<>();\r\n+    lock = new ReentrantReadWriteLock();\r\n+    libRoot = parseLibRoot();\r\n+  }\r\n+\r\n+  private String parseLibRoot() {\r\n+    String jarPath = (new File(\r\n+        getClass().getProtectionDomain().getCodeSource().getLocation().getPath()))\r\n+        .getAbsolutePath();\r\n+    int lastIndex = jarPath.lastIndexOf(File.separatorChar);\r\n+    String libPath = jarPath.substring(0, lastIndex + 1);\r\n+    logger.info(\"System lib root: {}\", libPath);\r\n+    return libPath;\r\n+  }\r\n+\r\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\r\n+  public void register(String functionName, String className, boolean isTemporary,\r\n+      boolean writeToTemporaryLogFile) throws UDFRegistrationException {\r\n+    UDFRegistrationInformation information = registrationInformation.get(functionName);\r\n+    if (information != null) {\r\n+      if (information.getClassName().equals(className)) {\r\n+        String errorMessage;\r\n+        if (information.isTemporary() == isTemporary) {\r\n+          errorMessage = String\r\n+              .format(\"UDF %s(%s) has already been registered successfully.\",\r\n+                  functionName, className);\r\n+        } else {\r\n+          errorMessage = String.format(\r\n+              \"Failed to register %sTEMPORARY UDF %s(%s), because a %sTEMPORARY UDF %s(%s) with the same function name and the class name has already been registered.\",\r\n+              isTemporary ? \"\" : \"non-\", functionName, className,\r\n+              information.isTemporary() ? \"\" : \"non-\", information.getFunctionName(),\r\n+              information.getClassName());\r\n+        }\r\n+        logger.warn(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage);\r\n+      } else {\r\n+        String errorMessage = String.format(\r\n+            \"Failed to register UDF %s(%s), because a UDF %s(%s) with the same function name but a different class name has already been registered.\",\r\n+            functionName, className,\r\n+            information.getFunctionName(), information.getClassName());\r\n+        logger.warn(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage);\r\n+      }\r\n+    }\r\n+\r\n+    Class<?> functionClass;\r\n+    try {\r\n+      udfClassLoader = getUDFClassLoader();\r\n+      functionClass = Class.forName(className, true, udfClassLoader);\r\n+      functionClass.getDeclaredConstructor().newInstance();\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODMxMjM5Mg=="}, "originalCommit": {"oid": "32f4156e79ab2e8930e09e4a5c9a6b8bb5d19b48"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA3NjE1OA==", "bodyText": "it's necessary to delete, or use the findClass method", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r544076158", "createdAt": "2020-12-16T07:38:56Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.service;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.File;\r\n+import java.io.FileReader;\r\n+import java.io.IOException;\r\n+import java.lang.reflect.InvocationTargetException;\r\n+import java.net.URL;\r\n+import java.net.URLClassLoader;\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.Map.Entry;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+import org.apache.commons.io.FileUtils;\r\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\r\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\r\n+import org.apache.iotdb.db.exception.StartupException;\r\n+import org.apache.iotdb.db.exception.UDFRegistrationException;\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.db.query.udf.api.UDF;\r\n+import org.apache.iotdb.db.query.udf.core.context.UDFContext;\r\n+import org.apache.iotdb.db.service.IService;\r\n+import org.apache.iotdb.db.service.ServiceType;\r\n+import org.apache.iotdb.db.utils.TestOnly;\r\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+public class UDFRegistrationService implements IService {\r\n+\r\n+  private static final Logger logger = LoggerFactory.getLogger(UDFRegistrationService.class);\r\n+\r\n+  private static final String ULOG_FILE_DIR =\r\n+      IoTDBDescriptor.getInstance().getConfig().getSystemDir()\r\n+          + File.separator + \"udf\" + File.separator;\r\n+  private static final String LOG_FILE_NAME = ULOG_FILE_DIR + \"ulog.txt\";\r\n+  private static final String TEMPORARY_LOG_FILE_NAME = LOG_FILE_NAME + \".tmp\";\r\n+\r\n+  private final ConcurrentHashMap<String, UDFRegistrationInformation> registrationInformation;\r\n+\r\n+  private final ReentrantReadWriteLock lock;\r\n+  private UDFLogWriter temporaryLogWriter;\r\n+\r\n+  private final String libRoot;\r\n+\r\n+  private URLClassLoader udfClassLoader;\r\n+\r\n+  private UDFRegistrationService() {\r\n+    registrationInformation = new ConcurrentHashMap<>();\r\n+    lock = new ReentrantReadWriteLock();\r\n+    libRoot = parseLibRoot();\r\n+  }\r\n+\r\n+  private String parseLibRoot() {\r\n+    String jarPath = (new File(\r\n+        getClass().getProtectionDomain().getCodeSource().getLocation().getPath()))\r\n+        .getAbsolutePath();\r\n+    int lastIndex = jarPath.lastIndexOf(File.separatorChar);\r\n+    String libPath = jarPath.substring(0, lastIndex + 1);\r\n+    logger.info(\"System lib root: {}\", libPath);\r\n+    return libPath;\r\n+  }\r\n+\r\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\r\n+  public void register(String functionName, String className, boolean isTemporary,\r\n+      boolean writeToTemporaryLogFile) throws UDFRegistrationException {\r\n+    UDFRegistrationInformation information = registrationInformation.get(functionName);\r\n+    if (information != null) {\r\n+      if (information.getClassName().equals(className)) {\r\n+        String errorMessage;\r\n+        if (information.isTemporary() == isTemporary) {\r\n+          errorMessage = String\r\n+              .format(\"UDF %s(%s) has already been registered successfully.\",\r\n+                  functionName, className);\r\n+        } else {\r\n+          errorMessage = String.format(\r\n+              \"Failed to register %sTEMPORARY UDF %s(%s), because a %sTEMPORARY UDF %s(%s) with the same function name and the class name has already been registered.\",\r\n+              isTemporary ? \"\" : \"non-\", functionName, className,\r\n+              information.isTemporary() ? \"\" : \"non-\", information.getFunctionName(),\r\n+              information.getClassName());\r\n+        }\r\n+        logger.warn(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage);\r\n+      } else {\r\n+        String errorMessage = String.format(\r\n+            \"Failed to register UDF %s(%s), because a UDF %s(%s) with the same function name but a different class name has already been registered.\",\r\n+            functionName, className,\r\n+            information.getFunctionName(), information.getClassName());\r\n+        logger.warn(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage);\r\n+      }\r\n+    }\r\n+\r\n+    Class<?> functionClass;\r\n+    try {\r\n+      udfClassLoader = getUDFClassLoader();\r\n+      functionClass = Class.forName(className, true, udfClassLoader);\r\n+      functionClass.getDeclaredConstructor().newInstance();\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODMxMjM5Mg=="}, "originalCommit": {"oid": "32f4156e79ab2e8930e09e4a5c9a6b8bb5d19b48"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTc0MzUwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMjo1ODoyMlrOIBZjjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMjo1MjowMlrOIB_1jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODMzODE4OA==", "bodyText": "You shouldn't create a new URLClassLoader each time register function is called. Instead, you can init the URLClassLoader in the constructor of UDFRegistrationService and call the addURL function to add the new class.", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r538338188", "createdAt": "2020-12-08T12:58:22Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.service;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.File;\r\n+import java.io.FileReader;\r\n+import java.io.IOException;\r\n+import java.lang.reflect.InvocationTargetException;\r\n+import java.net.URL;\r\n+import java.net.URLClassLoader;\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.Map.Entry;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+import org.apache.commons.io.FileUtils;\r\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\r\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\r\n+import org.apache.iotdb.db.exception.StartupException;\r\n+import org.apache.iotdb.db.exception.UDFRegistrationException;\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.db.query.udf.api.UDF;\r\n+import org.apache.iotdb.db.query.udf.core.context.UDFContext;\r\n+import org.apache.iotdb.db.service.IService;\r\n+import org.apache.iotdb.db.service.ServiceType;\r\n+import org.apache.iotdb.db.utils.TestOnly;\r\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+public class UDFRegistrationService implements IService {\r\n+\r\n+  private static final Logger logger = LoggerFactory.getLogger(UDFRegistrationService.class);\r\n+\r\n+  private static final String ULOG_FILE_DIR =\r\n+      IoTDBDescriptor.getInstance().getConfig().getSystemDir()\r\n+          + File.separator + \"udf\" + File.separator;\r\n+  private static final String LOG_FILE_NAME = ULOG_FILE_DIR + \"ulog.txt\";\r\n+  private static final String TEMPORARY_LOG_FILE_NAME = LOG_FILE_NAME + \".tmp\";\r\n+\r\n+  private final ConcurrentHashMap<String, UDFRegistrationInformation> registrationInformation;\r\n+\r\n+  private final ReentrantReadWriteLock lock;\r\n+  private UDFLogWriter temporaryLogWriter;\r\n+\r\n+  private final String libRoot;\r\n+\r\n+  private URLClassLoader udfClassLoader;\r\n+\r\n+  private UDFRegistrationService() {\r\n+    registrationInformation = new ConcurrentHashMap<>();\r\n+    lock = new ReentrantReadWriteLock();\r\n+    libRoot = parseLibRoot();\r\n+  }\r\n+\r\n+  private String parseLibRoot() {\r\n+    String jarPath = (new File(\r\n+        getClass().getProtectionDomain().getCodeSource().getLocation().getPath()))\r\n+        .getAbsolutePath();\r\n+    int lastIndex = jarPath.lastIndexOf(File.separatorChar);\r\n+    String libPath = jarPath.substring(0, lastIndex + 1);\r\n+    logger.info(\"System lib root: {}\", libPath);\r\n+    return libPath;\r\n+  }\r\n+\r\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\r\n+  public void register(String functionName, String className, boolean isTemporary,\r\n+      boolean writeToTemporaryLogFile) throws UDFRegistrationException {\r\n+    UDFRegistrationInformation information = registrationInformation.get(functionName);\r\n+    if (information != null) {\r\n+      if (information.getClassName().equals(className)) {\r\n+        String errorMessage;\r\n+        if (information.isTemporary() == isTemporary) {\r\n+          errorMessage = String\r\n+              .format(\"UDF %s(%s) has already been registered successfully.\",\r\n+                  functionName, className);\r\n+        } else {\r\n+          errorMessage = String.format(\r\n+              \"Failed to register %sTEMPORARY UDF %s(%s), because a %sTEMPORARY UDF %s(%s) with the same function name and the class name has already been registered.\",\r\n+              isTemporary ? \"\" : \"non-\", functionName, className,\r\n+              information.isTemporary() ? \"\" : \"non-\", information.getFunctionName(),\r\n+              information.getClassName());\r\n+        }\r\n+        logger.warn(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage);\r\n+      } else {\r\n+        String errorMessage = String.format(\r\n+            \"Failed to register UDF %s(%s), because a UDF %s(%s) with the same function name but a different class name has already been registered.\",\r\n+            functionName, className,\r\n+            information.getFunctionName(), information.getClassName());\r\n+        logger.warn(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage);\r\n+      }\r\n+    }\r\n+\r\n+    Class<?> functionClass;\r\n+    try {\r\n+      udfClassLoader = getUDFClassLoader();\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32f4156e79ab2e8930e09e4a5c9a6b8bb5d19b48"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MDE5Ng==", "bodyText": "It seems that the addURL method is protected and all URLs should be determined before the construction of class URLClassLoader. I don't know if there's a more elegant way :)", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r538960196", "createdAt": "2020-12-09T02:37:07Z", "author": {"login": "SteveYurongSu"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.service;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.File;\r\n+import java.io.FileReader;\r\n+import java.io.IOException;\r\n+import java.lang.reflect.InvocationTargetException;\r\n+import java.net.URL;\r\n+import java.net.URLClassLoader;\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.Map.Entry;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+import org.apache.commons.io.FileUtils;\r\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\r\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\r\n+import org.apache.iotdb.db.exception.StartupException;\r\n+import org.apache.iotdb.db.exception.UDFRegistrationException;\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.db.query.udf.api.UDF;\r\n+import org.apache.iotdb.db.query.udf.core.context.UDFContext;\r\n+import org.apache.iotdb.db.service.IService;\r\n+import org.apache.iotdb.db.service.ServiceType;\r\n+import org.apache.iotdb.db.utils.TestOnly;\r\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+public class UDFRegistrationService implements IService {\r\n+\r\n+  private static final Logger logger = LoggerFactory.getLogger(UDFRegistrationService.class);\r\n+\r\n+  private static final String ULOG_FILE_DIR =\r\n+      IoTDBDescriptor.getInstance().getConfig().getSystemDir()\r\n+          + File.separator + \"udf\" + File.separator;\r\n+  private static final String LOG_FILE_NAME = ULOG_FILE_DIR + \"ulog.txt\";\r\n+  private static final String TEMPORARY_LOG_FILE_NAME = LOG_FILE_NAME + \".tmp\";\r\n+\r\n+  private final ConcurrentHashMap<String, UDFRegistrationInformation> registrationInformation;\r\n+\r\n+  private final ReentrantReadWriteLock lock;\r\n+  private UDFLogWriter temporaryLogWriter;\r\n+\r\n+  private final String libRoot;\r\n+\r\n+  private URLClassLoader udfClassLoader;\r\n+\r\n+  private UDFRegistrationService() {\r\n+    registrationInformation = new ConcurrentHashMap<>();\r\n+    lock = new ReentrantReadWriteLock();\r\n+    libRoot = parseLibRoot();\r\n+  }\r\n+\r\n+  private String parseLibRoot() {\r\n+    String jarPath = (new File(\r\n+        getClass().getProtectionDomain().getCodeSource().getLocation().getPath()))\r\n+        .getAbsolutePath();\r\n+    int lastIndex = jarPath.lastIndexOf(File.separatorChar);\r\n+    String libPath = jarPath.substring(0, lastIndex + 1);\r\n+    logger.info(\"System lib root: {}\", libPath);\r\n+    return libPath;\r\n+  }\r\n+\r\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\r\n+  public void register(String functionName, String className, boolean isTemporary,\r\n+      boolean writeToTemporaryLogFile) throws UDFRegistrationException {\r\n+    UDFRegistrationInformation information = registrationInformation.get(functionName);\r\n+    if (information != null) {\r\n+      if (information.getClassName().equals(className)) {\r\n+        String errorMessage;\r\n+        if (information.isTemporary() == isTemporary) {\r\n+          errorMessage = String\r\n+              .format(\"UDF %s(%s) has already been registered successfully.\",\r\n+                  functionName, className);\r\n+        } else {\r\n+          errorMessage = String.format(\r\n+              \"Failed to register %sTEMPORARY UDF %s(%s), because a %sTEMPORARY UDF %s(%s) with the same function name and the class name has already been registered.\",\r\n+              isTemporary ? \"\" : \"non-\", functionName, className,\r\n+              information.isTemporary() ? \"\" : \"non-\", information.getFunctionName(),\r\n+              information.getClassName());\r\n+        }\r\n+        logger.warn(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage);\r\n+      } else {\r\n+        String errorMessage = String.format(\r\n+            \"Failed to register UDF %s(%s), because a UDF %s(%s) with the same function name but a different class name has already been registered.\",\r\n+            functionName, className,\r\n+            information.getFunctionName(), information.getClassName());\r\n+        logger.warn(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage);\r\n+      }\r\n+    }\r\n+\r\n+    Class<?> functionClass;\r\n+    try {\r\n+      udfClassLoader = getUDFClassLoader();\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODMzODE4OA=="}, "originalCommit": {"oid": "32f4156e79ab2e8930e09e4a5c9a6b8bb5d19b48"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2NTM4OA==", "bodyText": "Maybe I can extend the class URLClassLoader to solve the problem. Let me have a try.", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r538965388", "createdAt": "2020-12-09T02:52:02Z", "author": {"login": "SteveYurongSu"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.service;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.File;\r\n+import java.io.FileReader;\r\n+import java.io.IOException;\r\n+import java.lang.reflect.InvocationTargetException;\r\n+import java.net.URL;\r\n+import java.net.URLClassLoader;\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.Map.Entry;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+import org.apache.commons.io.FileUtils;\r\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\r\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\r\n+import org.apache.iotdb.db.exception.StartupException;\r\n+import org.apache.iotdb.db.exception.UDFRegistrationException;\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.db.query.udf.api.UDF;\r\n+import org.apache.iotdb.db.query.udf.core.context.UDFContext;\r\n+import org.apache.iotdb.db.service.IService;\r\n+import org.apache.iotdb.db.service.ServiceType;\r\n+import org.apache.iotdb.db.utils.TestOnly;\r\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+public class UDFRegistrationService implements IService {\r\n+\r\n+  private static final Logger logger = LoggerFactory.getLogger(UDFRegistrationService.class);\r\n+\r\n+  private static final String ULOG_FILE_DIR =\r\n+      IoTDBDescriptor.getInstance().getConfig().getSystemDir()\r\n+          + File.separator + \"udf\" + File.separator;\r\n+  private static final String LOG_FILE_NAME = ULOG_FILE_DIR + \"ulog.txt\";\r\n+  private static final String TEMPORARY_LOG_FILE_NAME = LOG_FILE_NAME + \".tmp\";\r\n+\r\n+  private final ConcurrentHashMap<String, UDFRegistrationInformation> registrationInformation;\r\n+\r\n+  private final ReentrantReadWriteLock lock;\r\n+  private UDFLogWriter temporaryLogWriter;\r\n+\r\n+  private final String libRoot;\r\n+\r\n+  private URLClassLoader udfClassLoader;\r\n+\r\n+  private UDFRegistrationService() {\r\n+    registrationInformation = new ConcurrentHashMap<>();\r\n+    lock = new ReentrantReadWriteLock();\r\n+    libRoot = parseLibRoot();\r\n+  }\r\n+\r\n+  private String parseLibRoot() {\r\n+    String jarPath = (new File(\r\n+        getClass().getProtectionDomain().getCodeSource().getLocation().getPath()))\r\n+        .getAbsolutePath();\r\n+    int lastIndex = jarPath.lastIndexOf(File.separatorChar);\r\n+    String libPath = jarPath.substring(0, lastIndex + 1);\r\n+    logger.info(\"System lib root: {}\", libPath);\r\n+    return libPath;\r\n+  }\r\n+\r\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\r\n+  public void register(String functionName, String className, boolean isTemporary,\r\n+      boolean writeToTemporaryLogFile) throws UDFRegistrationException {\r\n+    UDFRegistrationInformation information = registrationInformation.get(functionName);\r\n+    if (information != null) {\r\n+      if (information.getClassName().equals(className)) {\r\n+        String errorMessage;\r\n+        if (information.isTemporary() == isTemporary) {\r\n+          errorMessage = String\r\n+              .format(\"UDF %s(%s) has already been registered successfully.\",\r\n+                  functionName, className);\r\n+        } else {\r\n+          errorMessage = String.format(\r\n+              \"Failed to register %sTEMPORARY UDF %s(%s), because a %sTEMPORARY UDF %s(%s) with the same function name and the class name has already been registered.\",\r\n+              isTemporary ? \"\" : \"non-\", functionName, className,\r\n+              information.isTemporary() ? \"\" : \"non-\", information.getFunctionName(),\r\n+              information.getClassName());\r\n+        }\r\n+        logger.warn(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage);\r\n+      } else {\r\n+        String errorMessage = String.format(\r\n+            \"Failed to register UDF %s(%s), because a UDF %s(%s) with the same function name but a different class name has already been registered.\",\r\n+            functionName, className,\r\n+            information.getFunctionName(), information.getClassName());\r\n+        logger.warn(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage);\r\n+      }\r\n+    }\r\n+\r\n+    Class<?> functionClass;\r\n+    try {\r\n+      udfClassLoader = getUDFClassLoader();\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODMzODE4OA=="}, "originalCommit": {"oid": "32f4156e79ab2e8930e09e4a5c9a6b8bb5d19b48"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTc1NTIxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMzowMDoyMFrOIBZrKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMzowMDoyMFrOIBZrKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODM0MDEzNw==", "bodyText": "There may be a resource leak here.\nI think you should unload the corresponding class in the URLClassLoader when the deregister function is called.", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r538340137", "createdAt": "2020-12-08T13:00:20Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.service;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.File;\r\n+import java.io.FileReader;\r\n+import java.io.IOException;\r\n+import java.lang.reflect.InvocationTargetException;\r\n+import java.net.URL;\r\n+import java.net.URLClassLoader;\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.Map.Entry;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+import org.apache.commons.io.FileUtils;\r\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\r\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\r\n+import org.apache.iotdb.db.exception.StartupException;\r\n+import org.apache.iotdb.db.exception.UDFRegistrationException;\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.db.query.udf.api.UDF;\r\n+import org.apache.iotdb.db.query.udf.core.context.UDFContext;\r\n+import org.apache.iotdb.db.service.IService;\r\n+import org.apache.iotdb.db.service.ServiceType;\r\n+import org.apache.iotdb.db.utils.TestOnly;\r\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+public class UDFRegistrationService implements IService {\r\n+\r\n+  private static final Logger logger = LoggerFactory.getLogger(UDFRegistrationService.class);\r\n+\r\n+  private static final String ULOG_FILE_DIR =\r\n+      IoTDBDescriptor.getInstance().getConfig().getSystemDir()\r\n+          + File.separator + \"udf\" + File.separator;\r\n+  private static final String LOG_FILE_NAME = ULOG_FILE_DIR + \"ulog.txt\";\r\n+  private static final String TEMPORARY_LOG_FILE_NAME = LOG_FILE_NAME + \".tmp\";\r\n+\r\n+  private final ConcurrentHashMap<String, UDFRegistrationInformation> registrationInformation;\r\n+\r\n+  private final ReentrantReadWriteLock lock;\r\n+  private UDFLogWriter temporaryLogWriter;\r\n+\r\n+  private final String libRoot;\r\n+\r\n+  private URLClassLoader udfClassLoader;\r\n+\r\n+  private UDFRegistrationService() {\r\n+    registrationInformation = new ConcurrentHashMap<>();\r\n+    lock = new ReentrantReadWriteLock();\r\n+    libRoot = parseLibRoot();\r\n+  }\r\n+\r\n+  private String parseLibRoot() {\r\n+    String jarPath = (new File(\r\n+        getClass().getProtectionDomain().getCodeSource().getLocation().getPath()))\r\n+        .getAbsolutePath();\r\n+    int lastIndex = jarPath.lastIndexOf(File.separatorChar);\r\n+    String libPath = jarPath.substring(0, lastIndex + 1);\r\n+    logger.info(\"System lib root: {}\", libPath);\r\n+    return libPath;\r\n+  }\r\n+\r\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\r\n+  public void register(String functionName, String className, boolean isTemporary,\r\n+      boolean writeToTemporaryLogFile) throws UDFRegistrationException {\r\n+    UDFRegistrationInformation information = registrationInformation.get(functionName);\r\n+    if (information != null) {\r\n+      if (information.getClassName().equals(className)) {\r\n+        String errorMessage;\r\n+        if (information.isTemporary() == isTemporary) {\r\n+          errorMessage = String\r\n+              .format(\"UDF %s(%s) has already been registered successfully.\",\r\n+                  functionName, className);\r\n+        } else {\r\n+          errorMessage = String.format(\r\n+              \"Failed to register %sTEMPORARY UDF %s(%s), because a %sTEMPORARY UDF %s(%s) with the same function name and the class name has already been registered.\",\r\n+              isTemporary ? \"\" : \"non-\", functionName, className,\r\n+              information.isTemporary() ? \"\" : \"non-\", information.getFunctionName(),\r\n+              information.getClassName());\r\n+        }\r\n+        logger.warn(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage);\r\n+      } else {\r\n+        String errorMessage = String.format(\r\n+            \"Failed to register UDF %s(%s), because a UDF %s(%s) with the same function name but a different class name has already been registered.\",\r\n+            functionName, className,\r\n+            information.getFunctionName(), information.getClassName());\r\n+        logger.warn(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage);\r\n+      }\r\n+    }\r\n+\r\n+    Class<?> functionClass;\r\n+    try {\r\n+      udfClassLoader = getUDFClassLoader();\r\n+      functionClass = Class.forName(className, true, udfClassLoader);\r\n+      functionClass.getDeclaredConstructor().newInstance();\r\n+    } catch (IOException | InstantiationException | InvocationTargetException | NoSuchMethodException | IllegalAccessException | ClassNotFoundException e) {\r\n+      String errorMessage = String.format(\r\n+          \"Failed to register UDF %s(%s), because its instance can not be constructed successfully. Exception: %s\",\r\n+          functionName, className, e.toString());\r\n+      logger.warn(errorMessage);\r\n+      throw new UDFRegistrationException(errorMessage);\r\n+    }\r\n+\r\n+    registrationInformation.put(functionName,\r\n+        new UDFRegistrationInformation(functionName, className, functionClass, isTemporary));\r\n+\r\n+    if (writeToTemporaryLogFile && !isTemporary) {\r\n+      try {\r\n+        appendRegistrationLog(functionName, className);\r\n+      } catch (IOException e) {\r\n+        registrationInformation.remove(functionName);\r\n+        String errorMessage = String\r\n+            .format(\"Failed to append UDF log when registering UDF %s(%s), because %s\",\r\n+                functionName, className, e.toString());\r\n+        logger.error(errorMessage);\r\n+        throw new UDFRegistrationException(errorMessage, e);\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  private URLClassLoader getUDFClassLoader() throws IOException {\r\n+    Collection<File> files = FileUtils\r\n+        .listFiles(SystemFileFactory.INSTANCE.getFile(libRoot), null, true);\r\n+    URL[] urls = FileUtils.toURLs(files.toArray(new File[0]));\r\n+    return new URLClassLoader(urls);\r\n+  }\r\n+\r\n+  public void deregister(String functionName) throws UDFRegistrationException {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32f4156e79ab2e8930e09e4a5c9a6b8bb5d19b48"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDQ1MzYwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/constant/DatetimeUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNzowOToyNVrOICFmuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNzowOToyNVrOICFmuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1OTg5OQ==", "bodyText": "What if I input a string like \"12dfuckay\", it's an illegal input, i think you should throw an execption.", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r539059899", "createdAt": "2020-12-09T07:09:25Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/constant/DatetimeUtils.java", "diffHunk": "@@ -477,6 +477,46 @@ public static long convertDatetimeStrToLong(String str, ZoneOffset offset, int d\n     return getInstantWithPrecision(str, timestampPrecision);\n   }\n \n+  /**\n+   * convert duration string to time value.\n+   *\n+   * @param duration represent duration string like: 12d8m9ns, 1y1mo, etc.\n+   * @return time in milliseconds, microseconds, or nanoseconds depending on the profile\n+   */\n+  public static long convertDurationStrToLong(String duration) {\n+    String timestampPrecision = IoTDBDescriptor.getInstance().getConfig().getTimestampPrecision();\n+    return convertDurationStrToLong(duration, timestampPrecision);\n+  }\n+\n+  /**\n+   * convert duration string to time value.\n+   *\n+   * @param duration represent duration string like: 12d8m9ns, 1y1mo, etc.\n+   * @return time in milliseconds, microseconds, or nanoseconds depending on the profile\n+   */\n+  public static long convertDurationStrToLong(String duration, String timestampPrecision) {\n+    long total = 0;\n+    long temp = 0;\n+    for (int i = 0; i < duration.length(); i++) {\n+      char ch = duration.charAt(i);\n+      if (Character.isDigit(ch)) {\n+        temp *= 10;\n+        temp += (ch - '0');\n+      } else {\n+        String unit = duration.charAt(i) + \"\";\n+        // This is to identify units with two letters.\n+        if (i + 1 < duration.length() && !Character.isDigit(duration.charAt(i + 1))) {\n+          i++;\n+          unit += duration.charAt(i);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1f6ec0f1937089aa8435a733087282d79a2a97a"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDQ1NzA4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/constant/SQLConstant.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNzoxMDo0MFrOICFo2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNzoxMDo0MFrOICFo2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA2MDQ0Mg==", "bodyText": "It's better to add the number instead of changing the previous ones.", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r539060442", "createdAt": "2020-12-09T07:10:40Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/constant/SQLConstant.java", "diffHunk": "@@ -155,8 +155,12 @@ private SQLConstant() {\n   public static final int TOK_CREATE_SCHEMA_SNAPSHOT = 89;\n   public static final int TOK_TRACING = 91;\n \n-  public static final int TOK_COUNT_DEVICES = 92;\n-  public static final int TOK_COUNT_STORAGE_GROUP = 93;\n+  public static final int TOK_FUNCTION_CREATE = 92;\n+  public static final int TOK_FUNCTION_DROP = 93;\n+  public static final int TOK_SHOW_FUNCTIONS = 94;\n+\n+  public static final int TOK_COUNT_DEVICES = 95;\n+  public static final int TOK_COUNT_STORAGE_GROUP = 96;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1f6ec0f1937089aa8435a733087282d79a2a97a"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDcxNTQwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/DirectAlignByTimeDataSet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODoxODo1NVrOICH6BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODoxODo1NVrOICH6BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NzYwNA==", "bodyText": "The function in this interface is same as DirectNonAlignDataSet, shall we combine them to one?", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r539097604", "createdAt": "2020-12-09T08:18:55Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/DirectAlignByTimeDataSet.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.dataset;\r\n+\r\n+import java.io.IOException;\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.db.tools.watermark.WatermarkEncoder;\r\n+import org.apache.iotdb.service.rpc.thrift.TSQueryDataSet;\r\n+\r\n+public interface DirectAlignByTimeDataSet {\r\n+\r\n+  int FLAG = 0x01;\r\n+\r\n+  TSQueryDataSet fillBuffer(int fetchSize, WatermarkEncoder encoder)\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1f6ec0f1937089aa8435a733087282d79a2a97a"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzMwMDMxOnYy", "diffSide": "RIGHT", "path": "docs/UserGuide/Operation Manual/UDF User Defined Function.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMTo1Mjo0MlrOIFM-6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMTo1Mjo0MlrOIFM-6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMyNjUwNw==", "bodyText": "You'd better check why we need tsfile after adding server.", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r542326507", "createdAt": "2020-12-14T11:52:42Z", "author": {"login": "qiaojialin"}, "path": "docs/UserGuide/Operation Manual/UDF User Defined Function.md", "diffHunk": "@@ -0,0 +1,416 @@\n+<!--\n+\n+    Licensed to the Apache Software Foundation (ASF) under one\n+    or more contributor license agreements.  See the NOTICE file\n+    distributed with this work for additional information\n+    regarding copyright ownership.  The ASF licenses this file\n+    to you under the Apache License, Version 2.0 (the\n+    \"License\"); you may not use this file except in compliance\n+    with the License.  You may obtain a copy of the License at\n+    \n+        http://www.apache.org/licenses/LICENSE-2.0\n+    \n+    Unless required by applicable law or agreed to in writing,\n+    software distributed under the License is distributed on an\n+    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+    KIND, either express or implied.  See the License for the\n+    specific language governing permissions and limitations\n+    under the License.\n+\n+-->\n+\n+\n+\n+# UDF (User Defined Function)\n+\n+IoTDB provides a variety of built-in functions to meet your computing needs, and you can also create user defined functions to meet more computing needs. \n+\n+This document describes how to write, register and use a UDF.\n+\n+\n+\n+## UDF Types\n+\n+In IoTDB, you can expand two types of UDF:\n+\n+| UDF Class                                           | Description                                                  |\n+| --------------------------------------------------- | ------------------------------------------------------------ |\n+| UDTF\uff08User Defined Timeseries Generating Function\uff09 | This type of function can take **multiple** time series as input, and output **one** time series, which can have any number of data points. |\n+| UDAF\uff08User Defined Aggregation Function\uff09           | Under development, please stay tuned.                        |\n+\n+\n+\n+## UDF Development Dependencies\n+\n+If you use [Maven](http://search.maven.org/), you can search for the development dependencies listed below from the [Maven repository](http://search.maven.org/) . Please note that you must select the same dependency version as the target IoTDB server version for development.\n+\n+``` xml\n+<dependency>\n+  <groupId>org.apache.iotdb</groupId>\n+  <artifactId>iotdb-server</artifactId>\n+  <version>0.12.0-SNAPSHOT</version>\n+  <scope>provided</scope>\n+</dependency>\n+<dependency>\n+  <groupId>org.apache.iotdb</groupId>\n+  <artifactId>tsfile</artifactId>\n+  <version>0.12.0-SNAPSHOT</version>\n+  <scope>provided</scope>\n+</dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzMwNzcyOnYy", "diffSide": "RIGHT", "path": "docs/UserGuide/Operation Manual/UDF User Defined Function.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMTo1NDozOFrOIFNDKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMTo1NDozOFrOIFNDKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMyNzU5NQ==", "bodyText": "it's better to throw an exception when registered", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r542327595", "createdAt": "2020-12-14T11:54:38Z", "author": {"login": "qiaojialin"}, "path": "docs/UserGuide/Operation Manual/UDF User Defined Function.md", "diffHunk": "@@ -0,0 +1,416 @@\n+<!--\n+\n+    Licensed to the Apache Software Foundation (ASF) under one\n+    or more contributor license agreements.  See the NOTICE file\n+    distributed with this work for additional information\n+    regarding copyright ownership.  The ASF licenses this file\n+    to you under the Apache License, Version 2.0 (the\n+    \"License\"); you may not use this file except in compliance\n+    with the License.  You may obtain a copy of the License at\n+    \n+        http://www.apache.org/licenses/LICENSE-2.0\n+    \n+    Unless required by applicable law or agreed to in writing,\n+    software distributed under the License is distributed on an\n+    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+    KIND, either express or implied.  See the License for the\n+    specific language governing permissions and limitations\n+    under the License.\n+\n+-->\n+\n+\n+\n+# UDF (User Defined Function)\n+\n+IoTDB provides a variety of built-in functions to meet your computing needs, and you can also create user defined functions to meet more computing needs. \n+\n+This document describes how to write, register and use a UDF.\n+\n+\n+\n+## UDF Types\n+\n+In IoTDB, you can expand two types of UDF:\n+\n+| UDF Class                                           | Description                                                  |\n+| --------------------------------------------------- | ------------------------------------------------------------ |\n+| UDTF\uff08User Defined Timeseries Generating Function\uff09 | This type of function can take **multiple** time series as input, and output **one** time series, which can have any number of data points. |\n+| UDAF\uff08User Defined Aggregation Function\uff09           | Under development, please stay tuned.                        |\n+\n+\n+\n+## UDF Development Dependencies\n+\n+If you use [Maven](http://search.maven.org/), you can search for the development dependencies listed below from the [Maven repository](http://search.maven.org/) . Please note that you must select the same dependency version as the target IoTDB server version for development.\n+\n+``` xml\n+<dependency>\n+  <groupId>org.apache.iotdb</groupId>\n+  <artifactId>iotdb-server</artifactId>\n+  <version>0.12.0-SNAPSHOT</version>\n+  <scope>provided</scope>\n+</dependency>\n+<dependency>\n+  <groupId>org.apache.iotdb</groupId>\n+  <artifactId>tsfile</artifactId>\n+  <version>0.12.0-SNAPSHOT</version>\n+  <scope>provided</scope>\n+</dependency>\n+```\n+\n+\n+\n+## UDTF\uff08User Defined Timeseries Generating Function\uff09\n+\n+To write a UDTF,  you need to inherit the `org.apache.iotdb.db.query.udf.api.UDTF` class, and at least implement the `beforeStart` method and a `transform` method.\n+\n+The following table shows all the interfaces available for user implementation. \n+\n+| Interface definition                                         | Description                                                  | Required to Implement                                 |\n+| :----------------------------------------------------------- | :----------------------------------------------------------- | ----------------------------------------------------- |\n+| `void beforeStart(UDFParameters parameters, UDTFConfigurations configurations) throws Exception` | The initialization method to call the user-defined initialization behavior before a UDTF processes the input data. Every time a user executes a UDTF query, the framework will construct a new UDF instance, and `beforeStart` will be called. | Required                                              |\n+| `void beforeDestroy() `                                      | This method is called by the framework after the last input data is processed, and will only be called once in the life cycle of each UDF instance. | Optional                                              |\n+| `void transform(Row row, PointCollector collector) throws Exception` | This method is called by the framework. This data processing method will be called when you choose to use the `RowByRowAccessStrategy` strategy (set in `beforeStart`) to consume raw data. Input data is passed in by `Row`, and the transformation result should be output by `PointCollector`. You need to call the data collection method provided by `collector`  to determine the output data. | Required to implement at least one `transform` method |\n+| `void transform(RowWindow rowWindow, PointCollector collector) throws Exception` | This method is called by the framework. This data processing method will be called when you choose to use the `SlidingSizeWindowAccessStrategy` or `SlidingTimeWindowAccessStrategy` strategy (set in `beforeStart`) to consume raw data. Input data is passed in by `RowWindow`, and the transformation result should be output by `PointCollector`. You need to call the data collection method provided by `collector`  to determine the output data. | Required to implement at least one `transform` method |\n+\n+Note that every time the framework executes a UDTF query, a new UDF instance will be constructed. When the query ends, the corresponding instance will be destroyed. Therefore, the internal data of the instances in different UDTF queries (even in the same SQL statement) are isolated. You can maintain some state data in the UDTF without considering the influence of concurrency and other factors.\n+\n+The usage of each interface will be described in detail below.\n+\n+\n+\n+### `void beforeStart(UDFParameters parameters, UDTFConfigurations configurations) throws Exception`\n+\n+This method is mainly used to customize UDTF. In this method, the user can do the following things:\n+\n+1. Use UDFParameters to get the time series paths and parse key-value pair attributes entered by the user.\n+2. Set the strategy to access the raw data and set the output data type in UDTFConfigurations.\n+3. Create resources, such as establishing external connections, opening files, etc.\n+\n+\n+\n+\n+#### `UDFParameters`\n+\n+`UDFParameters` is used to parse UDF parameters in SQL statements (the part in parentheses after the UDF function name in SQL). The input parameters have two parts. The first part is the paths (measurements) of the time series that the UDF needs to process, and the second part is the key-value pair attributes for customization. Only the second part can be empty.\n+\n+\n+Example\uff1a\n+\n+``` sql\n+SELECT UDF(s1, s2, 'key1'='iotdb', 'key2'='123.45') FROM root.sg.d;\n+```\n+\n+Usage\uff1a\n+\n+``` java\n+void beforeStart(UDFParameters parameters, UDTFConfigurations configurations) throws Exception {\n+  // parameters\n+\tfor (PartialPath path : parameters.getPaths()) {\n+  \t// do something\n+  }\n+  String stringValue = parameters.getString(\"key1\"); // iotdb\n+  Float floatValue = parameters.getFloat(\"key2\"); // 123.45\n+  Double doubleValue = parameters.getDouble(\"key3\"); // null\n+  int intValue = parameters.getIntOrDefault(\"key4\", 678); // 678\n+  // do something\n+  \n+  // configurations\n+  // ...\n+}\n+```\n+\n+\n+\n+####  `UDTFConfigurations`\n+\n+You must use `UDTFConfigurations` to specify the strategy used by UDF to access raw data and the type of output sequence.\n+\n+Usage\uff1a\n+\n+``` java\n+void beforeStart(UDFParameters parameters, UDTFConfigurations configurations) throws Exception {\n+  // parameters\n+  // ...\n+  \n+  // configurations\n+  configurations\n+    .setAccessStrategy(new RowByRowAccessStrategy())\n+    .setOutputDataType(TSDataType.INT32);\n+}\n+```\n+\n+The `setAccessStrategy` method is used to set the UDF's strategy for accessing the raw data, and the `setOutputDataType` method is used to set the data type of the output sequence.\n+\n+\n+\n+##### `setAccessStrategy`\n+\n+Note that the raw data access strategy you set here determines which `transform` method the framework will call. Please implement the `transform` method corresponding to the raw data access strategy. Of course, you can also dynamically decide which strategy to set based on the attribute parameters parsed by `UDFParameters`. Therefore, two `transform` methods are also allowed to be implemented in one UDF.\n+\n+The following are the strategies you can set:\n+\n+| Interface definition              | Description                                                  | The `transform` Method to Call                               |\n+| :-------------------------------- | :----------------------------------------------------------- | ------------------------------------------------------------ |\n+| `RowByRowAccessStrategy`          | Process raw data row by row. The framework calls the `transform` method once for each row of raw data input. When UDF has only one input sequence, a row of input is one data point in the input sequence. When UDF has multiple input sequences, one row of input is a result record of the raw query (aligned by time) on these input sequences. (In a row, there may be a column with a value of `null`, but not all of them are `null`) | `void transform(Row row, PointCollector collector) throws Exception` |\n+| `SlidingTimeWindowAccessStrategy` | Process a batch of data in a fixed time interval each time. We call the container of a data batch a window. The framework calls the `transform` method once for each raw data input window. There may be multiple rows of data in a window, and each row is a result record of the raw query (aligned by time) on these input sequences. (In a row, there may be a column with a value of `null`, but not all of them are `null`) | `void transform(RowWindow rowWindow, PointCollector collector) throws Exception` |\n+| `SlidingSizeWindowAccessStrategy`    | The raw data is processed batch by batch, and each batch contains a fixed number of raw data rows (except the last batch). We call the container of a data batch a window. The framework calls the `transform` method once for each raw data input window. There may be multiple rows of data in a window, and each row is a result record of the raw query (aligned by time) on these input sequences. (In a row, there may be a column with a value of `null`, but not all of them are `null`) | `void transform(RowWindow rowWindow, PointCollector collector) throws Exception` |\n+\n+\n+\n+`RowByRowAccessStrategy`: The construction of `RowByRowAccessStrategy` does not require any parameters.\n+\n+\n+\n+`SlidingTimeWindowAccessStrategy`: `SlidingTimeWindowAccessStrategy` has many constructors, you can pass 3 types of parameters to them:\n+\n+- Parameter 1: The display window on the time axis\n+- Parameter 2: Time interval for dividing the time axis (should be positive)\n+- Parameter 3: Time sliding step (not required to be greater than or equal to the time interval, but must be a positive number)\n+\n+The first type of parameters are optional. If the parameters are not provided, the beginning time of the display window will be set to the same as the minimum timestamp of the query result set, and the ending time of the display window will be set to the same as the maximum timestamp of the query result set.\n+\n+The sliding step parameter is also optional. If the parameter is not provided, the sliding step will be set to the same as the time interval for dividing the time axis.\n+\n+The relationship between the three types of parameters can be seen in the figure below. Please see the Javadoc for more details. \n+\n+<div style=\"text-align: center;\"><img style=\"width:100%; max-width:800px; max-height:600px; margin-left:auto; margin-right:auto; display:block;\" src=\"https://user-images.githubusercontent.com/30497621/99787878-47b51480-2b5b-11eb-8ed3-84088c5c30f7.png\"></div>\n+\n+Note that the actual time interval of some of the last time windows may be less than the specified time interval parameter. In addition, there may be cases where the number of data rows in some time windows is 0. In these cases, the framework will also call the `transform` method for the empty windows.\n+\n+\n+\n+`SlidingSizeWindowAccessStrategy`:  `SlidingSizeWindowAccessStrategy` has many constructors, you can pass 2 types of parameters to them:\n+\n+* Parameter 1: Window size. This parameter specifies the number of data rows contained in a data processing window. Note that the number of data rows in some of the last time windows may be less than the specified number of data rows.\n+* Parameter 2: Sliding step. This parameter means the number of rows between the first point of the next window and the first point of the current window. (This parameter is not required to be greater than or equal to the window size, but must be a positive number)\n+\n+The sliding step parameter is optional. If the parameter is not provided, the sliding step will be set to the same as the window size.\n+\n+Please see the Javadoc for more details. \n+\n+\n+\n+##### `setOutputDataType`\n+\n+Note that the type of output sequence you set here determines the type of data that the `PointCollector` can actually receive in the `transform` method. The relationship between the output data type set in `setOutputDataType` and the actual data output type that `PointCollector` can receive is as follows:\n+\n+| Output Data Type Set in `setOutputDataType` | Data Type that `PointCollector` Can Receive                  |\n+| :------------------------------------------ | :----------------------------------------------------------- |\n+| `INT32`                                     | `int`                                                        |\n+| `INT64`                                     | `long`                                                       |\n+| `FLOAT`                                     | `float`                                                      |\n+| `DOUBLE`                                    | `double`                                                     |\n+| `BOOLEAN`                                   | `boolean`                                                    |\n+| `TEXT`                                      | `java.lang.String` and `org.apache.iotdb.tsfile.utils.Binary` |\n+\n+\n+\n+### `void beforeDestroy() `\n+\n+The method for terminating a UDF.\n+\n+This method is called by the framework. For a UDF instance, `beforeDestroy` will be called after the last record is processed. In the entire life cycle of the instance, `beforeDestroy` will only be called once.\n+\n+\n+\n+### `void transform(Row row, PointCollector collector) throws Exception`\n+\n+You need to implement this method when you specify the strategy of UDF to read the original data as `RowByRowAccessStrategy`.\n+\n+This method processes the raw data one row at a time. The raw data is input from `Row` and output by `PointCollector`. You can output any number of data points in one `transform` method call. It should be noted that the type of output data points must be the same as you set in the `beforeStart` method, and the timestamps of output data points must be strictly monotonically increasing.\n+\n+The following is a complete UDF example that implements the `void transform(Row row, PointCollector collector) throws Exception` method. It is an adder that receives two columns of time series as input. When two data points in a row are not `null`, this UDF will output the algebraic sum of these two data points.\n+\n+``` java\n+import org.apache.iotdb.db.query.udf.api.UDTF;\n+import org.apache.iotdb.db.query.udf.api.access.Row;\n+import org.apache.iotdb.db.query.udf.api.collector.PointCollector;\n+import org.apache.iotdb.db.query.udf.api.customizer.config.UDTFConfigurations;\n+import org.apache.iotdb.db.query.udf.api.customizer.parameter.UDFParameters;\n+import org.apache.iotdb.db.query.udf.api.customizer.strategy.RowByRowAccessStrategy;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+\n+public class Adder implements UDTF {\n+\n+  @Override\n+  public void beforeStart(UDFParameters parameters, UDTFConfigurations configurations) {\n+    configurations\n+        .setOutputDataType(TSDataType.INT64)\n+        .setAccessStrategy(new RowByRowAccessStrategy());\n+  }\n+\n+  @Override\n+  public void transform(Row row, PointCollector collector) throws Exception {\n+    if (row.isNull(0) || row.isNull(1)) {\n+      return;\n+    }\n+    collector.putLong(row.getTime(), row.getLong(0) + row.getLong(1));\n+  }\n+}\n+```\n+\n+\n+\n+### `void transform(RowWindow rowWindow, PointCollector collector) throws Exception`\n+\n+You need to implement this method when you specify the strategy of UDF to read the original data as `SlidingTimeWindowAccessStrategy` or `SlidingSizeWindowAccessStrategy`.\n+\n+This method processes a batch of data in a fixed number of rows or a fixed time interval each time, and we call the container containing this batch of data a window. The raw data is input from `RowWindow` and output by `PointCollector`. `RowWindow` can help you access a batch of `Row`, it provides a set of interfaces for random access and iterative access to this batch of `Row`. You can output any number of data points in one `transform` method call. It should be noted that the type of output data points must be the same as you set in the `beforeStart` method, and the timestamps of output data points must be strictly monotonically increasing.\n+\n+Below is a complete UDF example that implements the `void transform(RowWindow rowWindow, PointCollector collector) throws Exception` method. It is a counter that receives any number of time series as input, and its function is to count and output the number of data rows in each time window within a specified time range.\n+\n+```java\n+import java.io.IOException;\n+import org.apache.iotdb.db.query.udf.api.UDTF;\n+import org.apache.iotdb.db.query.udf.api.access.RowWindow;\n+import org.apache.iotdb.db.query.udf.api.collector.PointCollector;\n+import org.apache.iotdb.db.query.udf.api.customizer.config.UDTFConfigurations;\n+import org.apache.iotdb.db.query.udf.api.customizer.parameter.UDFParameters;\n+import org.apache.iotdb.db.query.udf.api.customizer.strategy.SlidingTimeWindowAccessStrategy;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+\n+public class Counter implements UDTF {\n+\n+  @Override\n+  public void beforeStart(UDFParameters parameters, UDTFConfigurations configurations) {\n+    configurations\n+        .setOutputDataType(TSDataType.INT32)\n+        .setAccessStrategy(new SlidingTimeWindowAccessStrategy(\n+            parameters.getLong(\"time_interval\"),\n+            parameters.getLong(\"sliding_step\"),\n+            parameters.getLong(\"display_window_begin\"),\n+            parameters.getLong(\"display_window_end\")));\n+  }\n+\n+  @Override\n+  public void transform(RowWindow rowWindow, PointCollector collector) {\n+    if (rowWindow.windowSize() != 0) {\n+      collector.putInt(rowWindow.getRow(0).getTime(), rowWindow.windowSize());\n+    }\n+  }\n+}\n+```\n+\n+\n+\n+## Maven Project Example\n+\n+If you use Maven, you can build your own UDF project referring to our **udf-example** module. You can find the project [here](https://github.com/apache/iotdb/tree/master/example/udf).\n+\n+\n+\n+## UDF Registration\n+\n+The process of registering a UDF in IoTDB is as follows:\n+\n+1. Implement a complete UDF class, assuming the full class name of this class is `org.apache.iotdb.udf.ExampleUDTF`.\n+2. Package your project into a JAR. If you use Maven to manage your project, you can refer to the Maven project example above.\n+3. Place the JAR package in the directory `iotdb-server-0.12.0-SNAPSHOT/lib` .\n+4. Register the UDF with the SQL statement, assuming that the name given to the UDF is `example`.\n+\n+The following shows the SQL syntax of how to register a UDF.\n+\n+```sql\n+CREATE FUNCTION <UDF-NAME> AS <UDF-CLASS-FULL-PATHNAME>\n+```\n+\n+Here is an example:\n+\n+```sql\n+CREATE FUNCTION example AS \"org.apache.iotdb.udf.ExampleUDTF\"\n+```\n+\n+Since UDF instances are dynamically loaded through reflection technology, you do not need to restart the server during the UDF registration process.\n+\n+Note: Please ensure that the function name given to the UDF is different from all built-in function names. A UDF with the same name as a built-in function can be registered, but cannot be called.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 327}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzMzOTg4OnYy", "diffSide": "RIGHT", "path": "docs/UserGuide/Operation Manual/UDF User Defined Function.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjowMzoxN1rOIFNVjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjowMzoxN1rOIFNVjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMzMjMwMw==", "bodyText": "'example' looks strange, using my-udf is better..", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r542332303", "createdAt": "2020-12-14T12:03:17Z", "author": {"login": "qiaojialin"}, "path": "docs/UserGuide/Operation Manual/UDF User Defined Function.md", "diffHunk": "@@ -0,0 +1,416 @@\n+<!--\n+\n+    Licensed to the Apache Software Foundation (ASF) under one\n+    or more contributor license agreements.  See the NOTICE file\n+    distributed with this work for additional information\n+    regarding copyright ownership.  The ASF licenses this file\n+    to you under the Apache License, Version 2.0 (the\n+    \"License\"); you may not use this file except in compliance\n+    with the License.  You may obtain a copy of the License at\n+    \n+        http://www.apache.org/licenses/LICENSE-2.0\n+    \n+    Unless required by applicable law or agreed to in writing,\n+    software distributed under the License is distributed on an\n+    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+    KIND, either express or implied.  See the License for the\n+    specific language governing permissions and limitations\n+    under the License.\n+\n+-->\n+\n+\n+\n+# UDF (User Defined Function)\n+\n+IoTDB provides a variety of built-in functions to meet your computing needs, and you can also create user defined functions to meet more computing needs. \n+\n+This document describes how to write, register and use a UDF.\n+\n+\n+\n+## UDF Types\n+\n+In IoTDB, you can expand two types of UDF:\n+\n+| UDF Class                                           | Description                                                  |\n+| --------------------------------------------------- | ------------------------------------------------------------ |\n+| UDTF\uff08User Defined Timeseries Generating Function\uff09 | This type of function can take **multiple** time series as input, and output **one** time series, which can have any number of data points. |\n+| UDAF\uff08User Defined Aggregation Function\uff09           | Under development, please stay tuned.                        |\n+\n+\n+\n+## UDF Development Dependencies\n+\n+If you use [Maven](http://search.maven.org/), you can search for the development dependencies listed below from the [Maven repository](http://search.maven.org/) . Please note that you must select the same dependency version as the target IoTDB server version for development.\n+\n+``` xml\n+<dependency>\n+  <groupId>org.apache.iotdb</groupId>\n+  <artifactId>iotdb-server</artifactId>\n+  <version>0.12.0-SNAPSHOT</version>\n+  <scope>provided</scope>\n+</dependency>\n+<dependency>\n+  <groupId>org.apache.iotdb</groupId>\n+  <artifactId>tsfile</artifactId>\n+  <version>0.12.0-SNAPSHOT</version>\n+  <scope>provided</scope>\n+</dependency>\n+```\n+\n+\n+\n+## UDTF\uff08User Defined Timeseries Generating Function\uff09\n+\n+To write a UDTF,  you need to inherit the `org.apache.iotdb.db.query.udf.api.UDTF` class, and at least implement the `beforeStart` method and a `transform` method.\n+\n+The following table shows all the interfaces available for user implementation. \n+\n+| Interface definition                                         | Description                                                  | Required to Implement                                 |\n+| :----------------------------------------------------------- | :----------------------------------------------------------- | ----------------------------------------------------- |\n+| `void beforeStart(UDFParameters parameters, UDTFConfigurations configurations) throws Exception` | The initialization method to call the user-defined initialization behavior before a UDTF processes the input data. Every time a user executes a UDTF query, the framework will construct a new UDF instance, and `beforeStart` will be called. | Required                                              |\n+| `void beforeDestroy() `                                      | This method is called by the framework after the last input data is processed, and will only be called once in the life cycle of each UDF instance. | Optional                                              |\n+| `void transform(Row row, PointCollector collector) throws Exception` | This method is called by the framework. This data processing method will be called when you choose to use the `RowByRowAccessStrategy` strategy (set in `beforeStart`) to consume raw data. Input data is passed in by `Row`, and the transformation result should be output by `PointCollector`. You need to call the data collection method provided by `collector`  to determine the output data. | Required to implement at least one `transform` method |\n+| `void transform(RowWindow rowWindow, PointCollector collector) throws Exception` | This method is called by the framework. This data processing method will be called when you choose to use the `SlidingSizeWindowAccessStrategy` or `SlidingTimeWindowAccessStrategy` strategy (set in `beforeStart`) to consume raw data. Input data is passed in by `RowWindow`, and the transformation result should be output by `PointCollector`. You need to call the data collection method provided by `collector`  to determine the output data. | Required to implement at least one `transform` method |\n+\n+Note that every time the framework executes a UDTF query, a new UDF instance will be constructed. When the query ends, the corresponding instance will be destroyed. Therefore, the internal data of the instances in different UDTF queries (even in the same SQL statement) are isolated. You can maintain some state data in the UDTF without considering the influence of concurrency and other factors.\n+\n+The usage of each interface will be described in detail below.\n+\n+\n+\n+### `void beforeStart(UDFParameters parameters, UDTFConfigurations configurations) throws Exception`\n+\n+This method is mainly used to customize UDTF. In this method, the user can do the following things:\n+\n+1. Use UDFParameters to get the time series paths and parse key-value pair attributes entered by the user.\n+2. Set the strategy to access the raw data and set the output data type in UDTFConfigurations.\n+3. Create resources, such as establishing external connections, opening files, etc.\n+\n+\n+\n+\n+#### `UDFParameters`\n+\n+`UDFParameters` is used to parse UDF parameters in SQL statements (the part in parentheses after the UDF function name in SQL). The input parameters have two parts. The first part is the paths (measurements) of the time series that the UDF needs to process, and the second part is the key-value pair attributes for customization. Only the second part can be empty.\n+\n+\n+Example\uff1a\n+\n+``` sql\n+SELECT UDF(s1, s2, 'key1'='iotdb', 'key2'='123.45') FROM root.sg.d;\n+```\n+\n+Usage\uff1a\n+\n+``` java\n+void beforeStart(UDFParameters parameters, UDTFConfigurations configurations) throws Exception {\n+  // parameters\n+\tfor (PartialPath path : parameters.getPaths()) {\n+  \t// do something\n+  }\n+  String stringValue = parameters.getString(\"key1\"); // iotdb\n+  Float floatValue = parameters.getFloat(\"key2\"); // 123.45\n+  Double doubleValue = parameters.getDouble(\"key3\"); // null\n+  int intValue = parameters.getIntOrDefault(\"key4\", 678); // 678\n+  // do something\n+  \n+  // configurations\n+  // ...\n+}\n+```\n+\n+\n+\n+####  `UDTFConfigurations`\n+\n+You must use `UDTFConfigurations` to specify the strategy used by UDF to access raw data and the type of output sequence.\n+\n+Usage\uff1a\n+\n+``` java\n+void beforeStart(UDFParameters parameters, UDTFConfigurations configurations) throws Exception {\n+  // parameters\n+  // ...\n+  \n+  // configurations\n+  configurations\n+    .setAccessStrategy(new RowByRowAccessStrategy())\n+    .setOutputDataType(TSDataType.INT32);\n+}\n+```\n+\n+The `setAccessStrategy` method is used to set the UDF's strategy for accessing the raw data, and the `setOutputDataType` method is used to set the data type of the output sequence.\n+\n+\n+\n+##### `setAccessStrategy`\n+\n+Note that the raw data access strategy you set here determines which `transform` method the framework will call. Please implement the `transform` method corresponding to the raw data access strategy. Of course, you can also dynamically decide which strategy to set based on the attribute parameters parsed by `UDFParameters`. Therefore, two `transform` methods are also allowed to be implemented in one UDF.\n+\n+The following are the strategies you can set:\n+\n+| Interface definition              | Description                                                  | The `transform` Method to Call                               |\n+| :-------------------------------- | :----------------------------------------------------------- | ------------------------------------------------------------ |\n+| `RowByRowAccessStrategy`          | Process raw data row by row. The framework calls the `transform` method once for each row of raw data input. When UDF has only one input sequence, a row of input is one data point in the input sequence. When UDF has multiple input sequences, one row of input is a result record of the raw query (aligned by time) on these input sequences. (In a row, there may be a column with a value of `null`, but not all of them are `null`) | `void transform(Row row, PointCollector collector) throws Exception` |\n+| `SlidingTimeWindowAccessStrategy` | Process a batch of data in a fixed time interval each time. We call the container of a data batch a window. The framework calls the `transform` method once for each raw data input window. There may be multiple rows of data in a window, and each row is a result record of the raw query (aligned by time) on these input sequences. (In a row, there may be a column with a value of `null`, but not all of them are `null`) | `void transform(RowWindow rowWindow, PointCollector collector) throws Exception` |\n+| `SlidingSizeWindowAccessStrategy`    | The raw data is processed batch by batch, and each batch contains a fixed number of raw data rows (except the last batch). We call the container of a data batch a window. The framework calls the `transform` method once for each raw data input window. There may be multiple rows of data in a window, and each row is a result record of the raw query (aligned by time) on these input sequences. (In a row, there may be a column with a value of `null`, but not all of them are `null`) | `void transform(RowWindow rowWindow, PointCollector collector) throws Exception` |\n+\n+\n+\n+`RowByRowAccessStrategy`: The construction of `RowByRowAccessStrategy` does not require any parameters.\n+\n+\n+\n+`SlidingTimeWindowAccessStrategy`: `SlidingTimeWindowAccessStrategy` has many constructors, you can pass 3 types of parameters to them:\n+\n+- Parameter 1: The display window on the time axis\n+- Parameter 2: Time interval for dividing the time axis (should be positive)\n+- Parameter 3: Time sliding step (not required to be greater than or equal to the time interval, but must be a positive number)\n+\n+The first type of parameters are optional. If the parameters are not provided, the beginning time of the display window will be set to the same as the minimum timestamp of the query result set, and the ending time of the display window will be set to the same as the maximum timestamp of the query result set.\n+\n+The sliding step parameter is also optional. If the parameter is not provided, the sliding step will be set to the same as the time interval for dividing the time axis.\n+\n+The relationship between the three types of parameters can be seen in the figure below. Please see the Javadoc for more details. \n+\n+<div style=\"text-align: center;\"><img style=\"width:100%; max-width:800px; max-height:600px; margin-left:auto; margin-right:auto; display:block;\" src=\"https://user-images.githubusercontent.com/30497621/99787878-47b51480-2b5b-11eb-8ed3-84088c5c30f7.png\"></div>\n+\n+Note that the actual time interval of some of the last time windows may be less than the specified time interval parameter. In addition, there may be cases where the number of data rows in some time windows is 0. In these cases, the framework will also call the `transform` method for the empty windows.\n+\n+\n+\n+`SlidingSizeWindowAccessStrategy`:  `SlidingSizeWindowAccessStrategy` has many constructors, you can pass 2 types of parameters to them:\n+\n+* Parameter 1: Window size. This parameter specifies the number of data rows contained in a data processing window. Note that the number of data rows in some of the last time windows may be less than the specified number of data rows.\n+* Parameter 2: Sliding step. This parameter means the number of rows between the first point of the next window and the first point of the current window. (This parameter is not required to be greater than or equal to the window size, but must be a positive number)\n+\n+The sliding step parameter is optional. If the parameter is not provided, the sliding step will be set to the same as the window size.\n+\n+Please see the Javadoc for more details. \n+\n+\n+\n+##### `setOutputDataType`\n+\n+Note that the type of output sequence you set here determines the type of data that the `PointCollector` can actually receive in the `transform` method. The relationship between the output data type set in `setOutputDataType` and the actual data output type that `PointCollector` can receive is as follows:\n+\n+| Output Data Type Set in `setOutputDataType` | Data Type that `PointCollector` Can Receive                  |\n+| :------------------------------------------ | :----------------------------------------------------------- |\n+| `INT32`                                     | `int`                                                        |\n+| `INT64`                                     | `long`                                                       |\n+| `FLOAT`                                     | `float`                                                      |\n+| `DOUBLE`                                    | `double`                                                     |\n+| `BOOLEAN`                                   | `boolean`                                                    |\n+| `TEXT`                                      | `java.lang.String` and `org.apache.iotdb.tsfile.utils.Binary` |\n+\n+\n+\n+### `void beforeDestroy() `\n+\n+The method for terminating a UDF.\n+\n+This method is called by the framework. For a UDF instance, `beforeDestroy` will be called after the last record is processed. In the entire life cycle of the instance, `beforeDestroy` will only be called once.\n+\n+\n+\n+### `void transform(Row row, PointCollector collector) throws Exception`\n+\n+You need to implement this method when you specify the strategy of UDF to read the original data as `RowByRowAccessStrategy`.\n+\n+This method processes the raw data one row at a time. The raw data is input from `Row` and output by `PointCollector`. You can output any number of data points in one `transform` method call. It should be noted that the type of output data points must be the same as you set in the `beforeStart` method, and the timestamps of output data points must be strictly monotonically increasing.\n+\n+The following is a complete UDF example that implements the `void transform(Row row, PointCollector collector) throws Exception` method. It is an adder that receives two columns of time series as input. When two data points in a row are not `null`, this UDF will output the algebraic sum of these two data points.\n+\n+``` java\n+import org.apache.iotdb.db.query.udf.api.UDTF;\n+import org.apache.iotdb.db.query.udf.api.access.Row;\n+import org.apache.iotdb.db.query.udf.api.collector.PointCollector;\n+import org.apache.iotdb.db.query.udf.api.customizer.config.UDTFConfigurations;\n+import org.apache.iotdb.db.query.udf.api.customizer.parameter.UDFParameters;\n+import org.apache.iotdb.db.query.udf.api.customizer.strategy.RowByRowAccessStrategy;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+\n+public class Adder implements UDTF {\n+\n+  @Override\n+  public void beforeStart(UDFParameters parameters, UDTFConfigurations configurations) {\n+    configurations\n+        .setOutputDataType(TSDataType.INT64)\n+        .setAccessStrategy(new RowByRowAccessStrategy());\n+  }\n+\n+  @Override\n+  public void transform(Row row, PointCollector collector) throws Exception {\n+    if (row.isNull(0) || row.isNull(1)) {\n+      return;\n+    }\n+    collector.putLong(row.getTime(), row.getLong(0) + row.getLong(1));\n+  }\n+}\n+```\n+\n+\n+\n+### `void transform(RowWindow rowWindow, PointCollector collector) throws Exception`\n+\n+You need to implement this method when you specify the strategy of UDF to read the original data as `SlidingTimeWindowAccessStrategy` or `SlidingSizeWindowAccessStrategy`.\n+\n+This method processes a batch of data in a fixed number of rows or a fixed time interval each time, and we call the container containing this batch of data a window. The raw data is input from `RowWindow` and output by `PointCollector`. `RowWindow` can help you access a batch of `Row`, it provides a set of interfaces for random access and iterative access to this batch of `Row`. You can output any number of data points in one `transform` method call. It should be noted that the type of output data points must be the same as you set in the `beforeStart` method, and the timestamps of output data points must be strictly monotonically increasing.\n+\n+Below is a complete UDF example that implements the `void transform(RowWindow rowWindow, PointCollector collector) throws Exception` method. It is a counter that receives any number of time series as input, and its function is to count and output the number of data rows in each time window within a specified time range.\n+\n+```java\n+import java.io.IOException;\n+import org.apache.iotdb.db.query.udf.api.UDTF;\n+import org.apache.iotdb.db.query.udf.api.access.RowWindow;\n+import org.apache.iotdb.db.query.udf.api.collector.PointCollector;\n+import org.apache.iotdb.db.query.udf.api.customizer.config.UDTFConfigurations;\n+import org.apache.iotdb.db.query.udf.api.customizer.parameter.UDFParameters;\n+import org.apache.iotdb.db.query.udf.api.customizer.strategy.SlidingTimeWindowAccessStrategy;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+\n+public class Counter implements UDTF {\n+\n+  @Override\n+  public void beforeStart(UDFParameters parameters, UDTFConfigurations configurations) {\n+    configurations\n+        .setOutputDataType(TSDataType.INT32)\n+        .setAccessStrategy(new SlidingTimeWindowAccessStrategy(\n+            parameters.getLong(\"time_interval\"),\n+            parameters.getLong(\"sliding_step\"),\n+            parameters.getLong(\"display_window_begin\"),\n+            parameters.getLong(\"display_window_end\")));\n+  }\n+\n+  @Override\n+  public void transform(RowWindow rowWindow, PointCollector collector) {\n+    if (rowWindow.windowSize() != 0) {\n+      collector.putInt(rowWindow.getRow(0).getTime(), rowWindow.windowSize());\n+    }\n+  }\n+}\n+```\n+\n+\n+\n+## Maven Project Example\n+\n+If you use Maven, you can build your own UDF project referring to our **udf-example** module. You can find the project [here](https://github.com/apache/iotdb/tree/master/example/udf).\n+\n+\n+\n+## UDF Registration\n+\n+The process of registering a UDF in IoTDB is as follows:\n+\n+1. Implement a complete UDF class, assuming the full class name of this class is `org.apache.iotdb.udf.ExampleUDTF`.\n+2. Package your project into a JAR. If you use Maven to manage your project, you can refer to the Maven project example above.\n+3. Place the JAR package in the directory `iotdb-server-0.12.0-SNAPSHOT/lib` .\n+4. Register the UDF with the SQL statement, assuming that the name given to the UDF is `example`.\n+\n+The following shows the SQL syntax of how to register a UDF.\n+\n+```sql\n+CREATE FUNCTION <UDF-NAME> AS <UDF-CLASS-FULL-PATHNAME>\n+```\n+\n+Here is an example:\n+\n+```sql\n+CREATE FUNCTION example AS \"org.apache.iotdb.udf.ExampleUDTF\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 322}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzM3OTI5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConstant.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjoxNDoxNFrOIFNrvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjoxNDoxNFrOIFNrvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMzNzk4Mg==", "bodyText": "this is not used", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r542337982", "createdAt": "2020-12-14T12:14:14Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConstant.java", "diffHunk": "@@ -86,6 +86,10 @@ private IoTDBConstant() {\n   public static final String COLUMN_CANCELLED = \"cancelled\";\n   public static final String COLUMN_DONE = \"done\";\n \n+  public static final String COLUMN_FUNCTION_NAME = \"UDF name\";\n+  public static final String COLUMN_FUNCTION_CLASS = \"class name\";\n+  public static final String COLUMN_FUNCTION_TEMPORARY = \"temporary\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzQwNTQ1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjoyMTowNVrOIFN6LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjoyMTo0NVrOIFN7jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM0MTY3Ng==", "bodyText": "You allocate 0.2 of read memory to udf, how does query perceive this?", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r542341676", "createdAt": "2020-12-14T12:21:05Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -760,6 +760,28 @@\n   // the authorizer provider class which extends BasicAuthorizer\n   private String authorizerProvider = \"org.apache.iotdb.db.auth.authorizer.LocalFileAuthorizer\";\n \n+  /**\n+   * Used to estimate the memory usage of text fields in a UDF query. It is recommended to set this\n+   * value to be slightly larger than the average length of all text records.\n+   */\n+  private int udfInitialByteArrayLengthForMemoryControl = 48;\n+\n+  /**\n+   * How much memory may be used in ONE UDF query (in MB).\n+   * <p>\n+   * The upper limit is 20% of allocated memory for read.\n+   * <p>\n+   * udfMemoryBudgetInMB = udfReaderMemoryBudgetInMB + udfTransformerMemoryBudgetInMB +\n+   * udfCollectorMemoryBudgetInMB\n+   */\n+  private float udfMemoryBudgetInMB = (float) Math.min(300f, 0.2 * allocateMemoryForRead);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM0MjAzMA==", "bodyText": "maybe you need to change chunkmeta_chunk_timeseriesmeta_free_memory_proportion", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r542342030", "createdAt": "2020-12-14T12:21:45Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -760,6 +760,28 @@\n   // the authorizer provider class which extends BasicAuthorizer\n   private String authorizerProvider = \"org.apache.iotdb.db.auth.authorizer.LocalFileAuthorizer\";\n \n+  /**\n+   * Used to estimate the memory usage of text fields in a UDF query. It is recommended to set this\n+   * value to be slightly larger than the average length of all text records.\n+   */\n+  private int udfInitialByteArrayLengthForMemoryControl = 48;\n+\n+  /**\n+   * How much memory may be used in ONE UDF query (in MB).\n+   * <p>\n+   * The upper limit is 20% of allocated memory for read.\n+   * <p>\n+   * udfMemoryBudgetInMB = udfReaderMemoryBudgetInMB + udfTransformerMemoryBudgetInMB +\n+   * udfCollectorMemoryBudgetInMB\n+   */\n+  private float udfMemoryBudgetInMB = (float) Math.min(300f, 0.2 * allocateMemoryForRead);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM0MTY3Ng=="}, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzQxMTU2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/exception/UDFRegistrationException.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjoyMjoyOFrOIFN9Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjoyMjoyOFrOIFN9Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM0MjQ5MQ==", "bodyText": "extends QueryProcessException?", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r542342491", "createdAt": "2020-12-14T12:22:28Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/exception/UDFRegistrationException.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.exception;\r\n+\r\n+public class UDFRegistrationException extends StorageEngineException {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzQ1MjE0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/constant/DatetimeUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjozMzoxOFrOIFOUIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjozMzoxOFrOIFOUIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM0ODMyMQ==", "bodyText": "merge master and the mo is supported", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r542348321", "createdAt": "2020-12-14T12:33:18Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/constant/DatetimeUtils.java", "diffHunk": "@@ -477,6 +477,46 @@ public static long convertDatetimeStrToLong(String str, ZoneOffset offset, int d\n     return getInstantWithPrecision(str, timestampPrecision);\n   }\n \n+  /**\n+   * convert duration string to time value.\n+   *\n+   * @param duration represent duration string like: 12d8m9ns, 1y1mo, etc.\n+   * @return time in milliseconds, microseconds, or nanoseconds depending on the profile\n+   */\n+  public static long convertDurationStrToLong(String duration) {\n+    String timestampPrecision = IoTDBDescriptor.getInstance().getConfig().getTimestampPrecision();\n+    return convertDurationStrToLong(duration, timestampPrecision);\n+  }\n+\n+  /**\n+   * convert duration string to time value.\n+   *\n+   * @param duration represent duration string like: 12d8m9ns, 1y1mo, etc.\n+   * @return time in milliseconds, microseconds, or nanoseconds depending on the profile\n+   */\n+  public static long convertDurationStrToLong(String duration, String timestampPrecision) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzQ4MDU0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjo0MDoxNlrOIFOkFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjo0MDoxNlrOIFOkFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MjQwNA==", "bodyText": "remove this", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r542352404", "createdAt": "2020-12-14T12:40:16Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -668,6 +697,33 @@ private QueryDataSet processShowFlushTaskInfo() {\n     return listDataSet;\n   }\n \n+  private QueryDataSet processShowFunctions(ShowFunctionsPlan showPlan) {\n+    ListDataSet listDataSet = new ListDataSet(\n+        Arrays.asList(\n+            new PartialPath(COLUMN_FUNCTION_NAME, false),\n+            new PartialPath(COLUMN_FUNCTION_CLASS, false)\n+            // new PartialPath(COLUMN_FUNCTION_TEMPORARY, false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzQ4MTI2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjo0MDoyOFrOIFOkfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjo0MDoyOFrOIFOkfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MjUwOQ==", "bodyText": "remove or add", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r542352509", "createdAt": "2020-12-14T12:40:28Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -668,6 +697,33 @@ private QueryDataSet processShowFlushTaskInfo() {\n     return listDataSet;\n   }\n \n+  private QueryDataSet processShowFunctions(ShowFunctionsPlan showPlan) {\n+    ListDataSet listDataSet = new ListDataSet(\n+        Arrays.asList(\n+            new PartialPath(COLUMN_FUNCTION_NAME, false),\n+            new PartialPath(COLUMN_FUNCTION_CLASS, false)\n+            // new PartialPath(COLUMN_FUNCTION_TEMPORARY, false)\n+        ),\n+        Arrays.asList(\n+            TSDataType.TEXT,\n+            TSDataType.TEXT\n+            // TSDataType.BOOLEAN", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzQ4MjMzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjo0MDo0N1rOIFOlGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjo0MDo0N1rOIFOlGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MjY2NQ==", "bodyText": "same", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r542352665", "createdAt": "2020-12-14T12:40:47Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -668,6 +697,33 @@ private QueryDataSet processShowFlushTaskInfo() {\n     return listDataSet;\n   }\n \n+  private QueryDataSet processShowFunctions(ShowFunctionsPlan showPlan) {\n+    ListDataSet listDataSet = new ListDataSet(\n+        Arrays.asList(\n+            new PartialPath(COLUMN_FUNCTION_NAME, false),\n+            new PartialPath(COLUMN_FUNCTION_CLASS, false)\n+            // new PartialPath(COLUMN_FUNCTION_TEMPORARY, false)\n+        ),\n+        Arrays.asList(\n+            TSDataType.TEXT,\n+            TSDataType.TEXT\n+            // TSDataType.BOOLEAN\n+        )\n+    );\n+    for (UDFRegistrationInformation info : UDFRegistrationService.getInstance()\n+        .getRegistrationInformation()) {\n+      if (showPlan.showTemporary() && !info.isTemporary()) {\n+        continue;\n+      }\n+      RowRecord rowRecord = new RowRecord(0); // ignore timestamp\n+      rowRecord.addField(Binary.valueOf(info.getFunctionName()), TSDataType.TEXT);\n+      rowRecord.addField(Binary.valueOf(info.getClassName()), TSDataType.TEXT);\n+      // rowRecord.addField(info.isTemporary(), TSDataType.BOOLEAN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzYwOTU5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/udf/api/access/RowIterator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzoxMTozMVrOIFPuDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzoxMTozMVrOIFPuDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3MTM0Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Resets the iteration.\n          \n          \n            \n               * Reset the iteration.", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r542371342", "createdAt": "2020-12-14T13:11:31Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/api/access/RowIterator.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.api.access;\r\n+\r\n+import java.io.IOException;\r\n+\r\n+public interface RowIterator {\r\n+\r\n+  /**\r\n+   * Returns {@code true} if the iteration has more rows.\r\n+   *\r\n+   * @return {@code true} if the iteration has more rows\r\n+   */\r\n+  boolean hasNextRow();\r\n+\r\n+  /**\r\n+   * Returns the next row in the iteration.\r\n+   * <p>\r\n+   * Note that the Row instance returned by this method each time is the same instance. In other\r\n+   * words, calling {@code next()} will only change the member variables inside the Row instance,\r\n+   * but will not generate a new Row instance.\r\n+   *\r\n+   * @return the next element in the iteration\r\n+   * @throws IOException if any I/O errors occur\r\n+   */\r\n+  Row next() throws IOException;\r\n+\r\n+  /**\r\n+   * Resets the iteration.\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzYxNDUzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/udf/api/customizer/config/UDFConfigurations.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzoxMjozMFrOIFPwzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzoxMjozMFrOIFPwzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3MjA0NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public abstract class UDFConfigurations {\n          \n          \n            \n            public abstract class AbstractUDFConfigurations {", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r542372045", "createdAt": "2020-12-14T13:12:30Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/api/customizer/config/UDFConfigurations.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.api.customizer.config;\r\n+\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\r\n+\r\n+public abstract class UDFConfigurations {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzY0NzkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzoyMDowMVrOIFQDyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNzo0MjozOFrOIG34cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NjkwNQ==", "bodyText": "The if-else could be eliminated since the error message is generated according to information.isTemporary()", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r542376905", "createdAt": "2020-12-14T13:20:01Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.service;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.File;\r\n+import java.io.FileReader;\r\n+import java.io.IOException;\r\n+import java.lang.reflect.InvocationTargetException;\r\n+import java.util.HashMap;\r\n+import java.util.Map.Entry;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+import org.apache.commons.io.FileUtils;\r\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\r\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\r\n+import org.apache.iotdb.db.exception.StartupException;\r\n+import org.apache.iotdb.db.exception.UDFRegistrationException;\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.db.query.udf.api.UDF;\r\n+import org.apache.iotdb.db.query.udf.core.context.UDFContext;\r\n+import org.apache.iotdb.db.service.IService;\r\n+import org.apache.iotdb.db.service.ServiceType;\r\n+import org.apache.iotdb.db.utils.TestOnly;\r\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+public class UDFRegistrationService implements IService {\r\n+\r\n+  private static final Logger logger = LoggerFactory.getLogger(UDFRegistrationService.class);\r\n+\r\n+  private static final String ULOG_FILE_DIR =\r\n+      IoTDBDescriptor.getInstance().getConfig().getSystemDir()\r\n+          + File.separator + \"udf\" + File.separator;\r\n+  private static final String LOG_FILE_NAME = ULOG_FILE_DIR + \"ulog.txt\";\r\n+  private static final String TEMPORARY_LOG_FILE_NAME = LOG_FILE_NAME + \".tmp\";\r\n+\r\n+  private final ConcurrentHashMap<String, UDFRegistrationInformation> registrationInformation;\r\n+\r\n+  private final ReentrantReadWriteLock lock;\r\n+  private UDFLogWriter temporaryLogWriter;\r\n+\r\n+  private UDFClassLoader udfClassLoader;\r\n+\r\n+  private UDFRegistrationService() {\r\n+    registrationInformation = new ConcurrentHashMap<>();\r\n+    lock = new ReentrantReadWriteLock();\r\n+  }\r\n+\r\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\r\n+  public void register(String functionName, String className, boolean isTemporary,\r\n+      boolean writeToTemporaryLogFile) throws UDFRegistrationException {\r\n+    UDFRegistrationInformation information = registrationInformation.get(functionName);\r\n+    if (information != null) {\r\n+      if (information.getClassName().equals(className)) {\r\n+        String errorMessage;\r\n+        if (information.isTemporary() == isTemporary) {\r\n+          errorMessage = String\r\n+              .format(\"UDF %s(%s) has already been registered successfully.\",\r\n+                  functionName, className);\r\n+        } else {\r\n+          errorMessage = String.format(\r\n+              \"Failed to register %sTEMPORARY UDF %s(%s), because a %sTEMPORARY UDF %s(%s) with the same function name and the class name has already been registered.\",\r\n+              isTemporary ? \"\" : \"non-\", functionName, className,\r\n+              information.isTemporary() ? \"\" : \"non-\", information.getFunctionName(),\r\n+              information.getClassName());\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA3NzkzOQ==", "bodyText": "+1 \uff0cor use a uniform error description prefix", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r544077939", "createdAt": "2020-12-16T07:42:38Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.service;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.File;\r\n+import java.io.FileReader;\r\n+import java.io.IOException;\r\n+import java.lang.reflect.InvocationTargetException;\r\n+import java.util.HashMap;\r\n+import java.util.Map.Entry;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+import org.apache.commons.io.FileUtils;\r\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\r\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\r\n+import org.apache.iotdb.db.exception.StartupException;\r\n+import org.apache.iotdb.db.exception.UDFRegistrationException;\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.db.query.udf.api.UDF;\r\n+import org.apache.iotdb.db.query.udf.core.context.UDFContext;\r\n+import org.apache.iotdb.db.service.IService;\r\n+import org.apache.iotdb.db.service.ServiceType;\r\n+import org.apache.iotdb.db.utils.TestOnly;\r\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+public class UDFRegistrationService implements IService {\r\n+\r\n+  private static final Logger logger = LoggerFactory.getLogger(UDFRegistrationService.class);\r\n+\r\n+  private static final String ULOG_FILE_DIR =\r\n+      IoTDBDescriptor.getInstance().getConfig().getSystemDir()\r\n+          + File.separator + \"udf\" + File.separator;\r\n+  private static final String LOG_FILE_NAME = ULOG_FILE_DIR + \"ulog.txt\";\r\n+  private static final String TEMPORARY_LOG_FILE_NAME = LOG_FILE_NAME + \".tmp\";\r\n+\r\n+  private final ConcurrentHashMap<String, UDFRegistrationInformation> registrationInformation;\r\n+\r\n+  private final ReentrantReadWriteLock lock;\r\n+  private UDFLogWriter temporaryLogWriter;\r\n+\r\n+  private UDFClassLoader udfClassLoader;\r\n+\r\n+  private UDFRegistrationService() {\r\n+    registrationInformation = new ConcurrentHashMap<>();\r\n+    lock = new ReentrantReadWriteLock();\r\n+  }\r\n+\r\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\r\n+  public void register(String functionName, String className, boolean isTemporary,\r\n+      boolean writeToTemporaryLogFile) throws UDFRegistrationException {\r\n+    UDFRegistrationInformation information = registrationInformation.get(functionName);\r\n+    if (information != null) {\r\n+      if (information.getClassName().equals(className)) {\r\n+        String errorMessage;\r\n+        if (information.isTemporary() == isTemporary) {\r\n+          errorMessage = String\r\n+              .format(\"UDF %s(%s) has already been registered successfully.\",\r\n+                  functionName, className);\r\n+        } else {\r\n+          errorMessage = String.format(\r\n+              \"Failed to register %sTEMPORARY UDF %s(%s), because a %sTEMPORARY UDF %s(%s) with the same function name and the class name has already been registered.\",\r\n+              isTemporary ? \"\" : \"non-\", functionName, className,\r\n+              information.isTemporary() ? \"\" : \"non-\", information.getFunctionName(),\r\n+              information.getClassName());\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NjkwNQ=="}, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMjQxNTIzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/UDTFPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNzoxNToxMVrOIF8OWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNzoxNToxMVrOIF8OWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEwMDUwNw==", "bodyText": "add some example and javadoc", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r543100507", "createdAt": "2020-12-15T07:15:11Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/UDTFPlan.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.qp.physical.crud;\r\n+\r\n+import java.time.ZoneId;\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.db.qp.logical.Operator;\r\n+import org.apache.iotdb.db.query.udf.core.context.UDFContext;\r\n+import org.apache.iotdb.db.query.udf.core.executor.UDTFExecutor;\r\n+\r\n+public class UDTFPlan extends RawDataQueryPlan implements UDFPlan {\r\n+\r\n+  protected final ZoneId zoneId;\r\n+\r\n+  protected Map<String, UDTFExecutor> columnName2Executor = new HashMap<>();\r\n+  protected Map<Integer, UDTFExecutor> originalOutputColumnIndex2Executor = new HashMap<>();\r\n+\r\n+  protected List<String> datasetOutputColumnIndex2UdfColumnName = new ArrayList<>();\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMjQzNjQ0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFClassLoader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNzoyMTowMVrOIF8ZwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNzoyMTowMVrOIF8ZwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEwMzQyNA==", "bodyText": "It is recommended to use a URLClassLoader for each UDF, manage with HashMap, and close the corresponding URLClassLoader when the user uninstalls the UDF", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r543103424", "createdAt": "2020-12-15T07:21:01Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFClassLoader.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.service;\r\n+\r\n+import java.io.File;\r\n+import java.io.IOException;\r\n+import java.net.URL;\r\n+import java.net.URLClassLoader;\r\n+import java.util.HashSet;\r\n+import java.util.Set;\r\n+import org.apache.commons.io.FileUtils;\r\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\r\n+\r\n+public class UDFClassLoader extends URLClassLoader {\r\n+\r\n+  private final String libRoot;\r\n+  private final Set<File> fileSet;\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMjQ0ODQ0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/UDFPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNzoyNDoyMVrOIF8gPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNzoyNDoyMVrOIF8gPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEwNTA4NQ==", "bodyText": "Add some javadoc, I do not know which should be called first", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r543105085", "createdAt": "2020-12-15T07:24:21Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/UDFPlan.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.qp.physical.crud;\r\n+\r\n+import java.util.List;\r\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.db.query.udf.core.context.UDFContext;\r\n+\r\n+public interface UDFPlan {\r\n+\r\n+  void constructUdfExecutors(List<UDFContext> udfContexts)\r\n+      throws QueryProcessException, MetadataException;\r\n+\r\n+  void initializeUdfExecutor(long queryId, float collectorMemoryBudgetInMb)\r\n+      throws QueryProcessException;\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMzQ3MjgyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/udf/core/reader/LayerPointReader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMToxNjoyNFrOIGFyUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMToxNjoyNFrOIGFyUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI1NzE3MA==", "bodyText": "check this method", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r543257170", "createdAt": "2020-12-15T11:16:24Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/core/reader/LayerPointReader.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.core.reader;\r\n+\r\n+import java.io.IOException;\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\r\n+import org.apache.iotdb.tsfile.utils.Binary;\r\n+\r\n+public interface LayerPointReader {\r\n+\r\n+  boolean next() throws QueryProcessException, IOException;\r\n+\r\n+  void readyForNext();\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMzY4NjA4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/udf/api/customizer/strategy/SlidingSizeWindowAccessStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMjowODozMVrOIGHtDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMjowODozMVrOIGHtDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI4ODU5MQ==", "bodyText": "The 'between' looks strange.\nFor example, 1,2,3,4,5 is a window, 6,7,8,9,10 is a window. number of rows between 1 and 6 is 4 or 5?", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r543288591", "createdAt": "2020-12-15T12:08:31Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/api/customizer/strategy/SlidingSizeWindowAccessStrategy.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.api.customizer.strategy;\r\n+\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.db.query.udf.api.UDTF;\r\n+import org.apache.iotdb.db.query.udf.api.access.RowWindow;\r\n+import org.apache.iotdb.db.query.udf.api.collector.PointCollector;\r\n+import org.apache.iotdb.db.query.udf.api.customizer.config.UDTFConfigurations;\r\n+import org.apache.iotdb.db.query.udf.api.customizer.parameter.UDFParameters;\r\n+\r\n+/**\r\n+ * Used in {@link UDTF#beforeStart(UDFParameters, UDTFConfigurations)}.\r\n+ * <p>\r\n+ * When the access strategy of a UDTF is set to an instance of this class, the method {@link\r\n+ * UDTF#transform(RowWindow, PointCollector)} of the UDTF will be called to transform the original\r\n+ * data. You need to override the method in your own UDTF class.\r\n+ * <p>\r\n+ * Sliding size window is a kind of size-based window. Except for the last call, each call of the\r\n+ * method {@link UDTF#transform(RowWindow, PointCollector)} processes a window with {@code\r\n+ * windowSize} rows (aligned by time) of the original data and can generate any number of data\r\n+ * points.\r\n+ * <p>\r\n+ * Sample code:\r\n+ * <pre>{@code\r\n+ * @Override\r\n+ * public void beforeStart(UDFParameters parameters, UDTFConfigurations configurations) {\r\n+ *   configurations\r\n+ *       .setOutputDataType(TSDataType.INT32)\r\n+ *       .setAccessStrategy(new SlidingSizeWindowAccessStrategy(10000)); // window size\r\n+ * }</pre>\r\n+ *\r\n+ * @see UDTF\r\n+ * @see UDTFConfigurations\r\n+ */\r\n+public class SlidingSizeWindowAccessStrategy implements AccessStrategy {\r\n+\r\n+  private final int windowSize;\r\n+  private final int slidingStep;\r\n+\r\n+  /**\r\n+   * Constructor. You need to specify the number of rows in each sliding size window (except for the\r\n+   * last window) and the sliding step to the next window.\r\n+   *\r\n+   * @param windowSize  the number of rows in each sliding size window (0 < windowSize)\r\n+   * @param slidingStep the number of rows between the first point of the next window and the first\r\n+   *                    point of the current window (0 < slidingStep)\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMzczMDEyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFClassLoader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMjoxOTozMFrOIGIHSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMjoxOTozMFrOIGIHSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI5NTMwNQ==", "bodyText": "add a javadoc to explain why the fileSet only expands", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r543295305", "createdAt": "2020-12-15T12:19:30Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFClassLoader.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.service;\r\n+\r\n+import java.io.File;\r\n+import java.io.IOException;\r\n+import java.net.URL;\r\n+import java.net.URLClassLoader;\r\n+import java.util.HashSet;\r\n+import java.util.Set;\r\n+import org.apache.commons.io.FileUtils;\r\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\r\n+\r\n+public class UDFClassLoader extends URLClassLoader {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxODQwOTU1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/udf/core/context/UDFContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNjowMzoyN1rOIGzVAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNjowMzoyN1rOIGzVAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAwMzMyOQ==", "bodyText": "LinkedHashMap", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r544003329", "createdAt": "2020-12-16T06:03:27Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/core/context/UDFContext.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.core.context;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\r\n+import org.apache.iotdb.db.metadata.PartialPath;\r\n+import org.apache.iotdb.db.service.IoTDB;\r\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\r\n+\r\n+public class UDFContext {\r\n+\r\n+  private final String name;\r\n+  private final Map<String, String> attributes;\r\n+  private final List<String> attributeKeysInOriginalOrder;\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxODQyNzk0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/udf/core/context/UDFContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNjowNzoxMlrOIGzgWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNjowNzoxMlrOIGzgWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAwNjIzMw==", "bodyText": "javadoc", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r544006233", "createdAt": "2020-12-16T06:07:12Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/core/context/UDFContext.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.core.context;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\r\n+import org.apache.iotdb.db.metadata.PartialPath;\r\n+import org.apache.iotdb.db.service.IoTDB;\r\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\r\n+\r\n+public class UDFContext {\r\n+\r\n+  private final String name;\r\n+  private final Map<String, String> attributes;\r\n+  private final List<String> attributeKeysInOriginalOrder;\r\n+\r\n+  private List<PartialPath> paths;\r\n+  private List<TSDataType> dataTypes;\r\n+\r\n+  private String columnParameterPart;\r\n+  private String column;\r\n+\r\n+  public UDFContext(String name) {\r\n+    this.name = name;\r\n+    attributes = new HashMap<>();\r\n+    attributeKeysInOriginalOrder = new ArrayList<>();\r\n+    paths = new ArrayList<>();\r\n+  }\r\n+\r\n+  public UDFContext(String name, Map<String, String> attributes,\r\n+      List<String> attributeKeysInOriginalOrder, List<PartialPath> paths) {\r\n+    this.name = name;\r\n+    this.attributes = attributes;\r\n+    this.attributeKeysInOriginalOrder = attributeKeysInOriginalOrder;\r\n+    this.paths = paths;\r\n+  }\r\n+\r\n+  public void addAttribute(String key, String value) {\r\n+    attributes.put(key, value);\r\n+    attributeKeysInOriginalOrder.add(key);\r\n+  }\r\n+\r\n+  public void addPath(PartialPath path) {\r\n+    paths.add(path);\r\n+  }\r\n+\r\n+  public void setPaths(List<PartialPath> paths) {\r\n+    this.paths = paths;\r\n+  }\r\n+\r\n+  public String getName() {\r\n+    return name;\r\n+  }\r\n+\r\n+  public Map<String, String> getAttributes() {\r\n+    return attributes;\r\n+  }\r\n+\r\n+  public List<String> getAttributeKeysInOriginalOrder() {\r\n+    return attributeKeysInOriginalOrder;\r\n+  }\r\n+\r\n+  public List<PartialPath> getPaths() {\r\n+    return paths;\r\n+  }\r\n+\r\n+  public List<TSDataType> getDataTypes() throws MetadataException {\r\n+    if (dataTypes == null) {\r\n+      dataTypes = new ArrayList<>();\r\n+      for (PartialPath path : paths) {\r\n+        dataTypes.add(IoTDB.metaManager.getSeriesType(path));\r\n+      }\r\n+    }\r\n+    return dataTypes;\r\n+  }\r\n+\r\n+  public String getColumnName() {\r\n+    if (column == null) {\r\n+      column = name + \"(\" + getColumnNameParameterPart() + \")\";\r\n+    }\r\n+    return column;\r\n+  }\r\n+\r\n+  private String getColumnNameParameterPart() {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzYzODUzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMzoyMDoxNVrOIHi3wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMzoyMDoxNVrOIHi3wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc4MjI3Mw==", "bodyText": "register(UDFRegistrationInformation info, boolean writeToLog)", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r544782273", "createdAt": "2020-12-17T03:20:15Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.service;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.File;\r\n+import java.io.FileReader;\r\n+import java.io.IOException;\r\n+import java.lang.reflect.InvocationTargetException;\r\n+import java.util.HashMap;\r\n+import java.util.Map.Entry;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+import org.apache.commons.io.FileUtils;\r\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\r\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\r\n+import org.apache.iotdb.db.exception.StartupException;\r\n+import org.apache.iotdb.db.exception.UDFRegistrationException;\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.db.query.udf.api.UDF;\r\n+import org.apache.iotdb.db.query.udf.core.context.UDFContext;\r\n+import org.apache.iotdb.db.service.IService;\r\n+import org.apache.iotdb.db.service.ServiceType;\r\n+import org.apache.iotdb.db.utils.TestOnly;\r\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+public class UDFRegistrationService implements IService {\r\n+\r\n+  private static final Logger logger = LoggerFactory.getLogger(UDFRegistrationService.class);\r\n+\r\n+  private static final String ULOG_FILE_DIR =\r\n+      IoTDBDescriptor.getInstance().getConfig().getSystemDir()\r\n+          + File.separator + \"udf\" + File.separator;\r\n+  private static final String LOG_FILE_NAME = ULOG_FILE_DIR + \"ulog.txt\";\r\n+  private static final String TEMPORARY_LOG_FILE_NAME = LOG_FILE_NAME + \".tmp\";\r\n+\r\n+  private final ConcurrentHashMap<String, UDFRegistrationInformation> registrationInformation;\r\n+\r\n+  private final ReentrantReadWriteLock lock;\r\n+  private UDFLogWriter temporaryLogWriter;\r\n+\r\n+  private UDFClassLoader udfClassLoader;\r\n+\r\n+  private UDFRegistrationService() {\r\n+    registrationInformation = new ConcurrentHashMap<>();\r\n+    lock = new ReentrantReadWriteLock();\r\n+  }\r\n+\r\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\r\n+  public void register(String functionName, String className, boolean isTemporary,\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzcwNTA4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/sys/DropFunctionPlan.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMzo0ODoyNVrOIHjaww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwNzo0NTozOVrOIKY6Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc5MTIzNQ==", "bodyText": "canBeSplit ?", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r544791235", "createdAt": "2020-12-17T03:48:25Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/sys/DropFunctionPlan.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.qp.physical.sys;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.List;\r\n+import org.apache.iotdb.db.metadata.PartialPath;\r\n+import org.apache.iotdb.db.qp.logical.Operator.OperatorType;\r\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\r\n+\r\n+public class DropFunctionPlan extends PhysicalPlan {\r\n+\r\n+  private final String udfName;\r\n+\r\n+  public DropFunctionPlan(String udfName) {\r\n+    super(false, OperatorType.DROP_FUNCTION);\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzc2NDc5NA==", "bodyText": "The field canBeSplit  is useless, maybe it can be removed..", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r547764794", "createdAt": "2020-12-23T07:45:39Z", "author": {"login": "SteveYurongSu"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/sys/DropFunctionPlan.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.qp.physical.sys;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.List;\r\n+import org.apache.iotdb.db.metadata.PartialPath;\r\n+import org.apache.iotdb.db.qp.logical.Operator.OperatorType;\r\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\r\n+\r\n+public class DropFunctionPlan extends PhysicalPlan {\r\n+\r\n+  private final String udfName;\r\n+\r\n+  public DropFunctionPlan(String udfName) {\r\n+    super(false, OperatorType.DROP_FUNCTION);\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc5MTIzNQ=="}, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzk4OTA1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/PhysicalGenerator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNTo1MDowMFrOIHlvjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNTo1MDowMFrOIHlvjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgyOTMyNQ==", "bodyText": "use if( queryOperator.hasUdf())  to remove redundant judgments", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r544829325", "createdAt": "2020-12-17T05:50:00Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/PhysicalGenerator.java", "diffHunk": "@@ -397,7 +419,13 @@ private PhysicalPlan transformQuery(QueryOperator queryOperator, int fetchSize)\n     } else if (queryOperator.getIndexType() != null) {\n       queryPlan = new QueryIndexPlan();\n     } else {\n-      queryPlan = new RawDataQueryPlan();\n+      queryPlan = queryOperator.hasUdf()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNDQ2Njc2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoyMzoxNlrOIHp0bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoyMzoxNlrOIHp0bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5NjEwOA==", "bodyText": "rename?", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r544896108", "createdAt": "2020-12-17T08:23:16Z", "author": {"login": "SteveYurongSu"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/service/UDFRegistrationService.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.service;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.File;\r\n+import java.io.FileReader;\r\n+import java.io.IOException;\r\n+import java.lang.reflect.InvocationTargetException;\r\n+import java.util.HashMap;\r\n+import java.util.Map.Entry;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+import org.apache.commons.io.FileUtils;\r\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\r\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\r\n+import org.apache.iotdb.db.exception.StartupException;\r\n+import org.apache.iotdb.db.exception.UDFRegistrationException;\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.db.query.udf.api.UDF;\r\n+import org.apache.iotdb.db.query.udf.core.context.UDFContext;\r\n+import org.apache.iotdb.db.service.IService;\r\n+import org.apache.iotdb.db.service.ServiceType;\r\n+import org.apache.iotdb.db.utils.TestOnly;\r\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+public class UDFRegistrationService implements IService {\r\n+\r\n+  private static final Logger logger = LoggerFactory.getLogger(UDFRegistrationService.class);\r\n+\r\n+  private static final String ULOG_FILE_DIR =\r\n+      IoTDBDescriptor.getInstance().getConfig().getSystemDir()\r\n+          + File.separator + \"udf\" + File.separator;\r\n+  private static final String LOG_FILE_NAME = ULOG_FILE_DIR + \"ulog.txt\";\r\n+  private static final String TEMPORARY_LOG_FILE_NAME = LOG_FILE_NAME + \".tmp\";\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzOTc5NDUwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/udf/core/executor/UDTFExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNjo0OToxNlrOIJwS6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNjo0OToxNlrOIJwS6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA5OTM3MQ==", "bodyText": "Pay attention to the errors, such as when ArrayIndexOutOfBoundsException occurs, will only hint Msg: 500: 1", "url": "https://github.com/apache/iotdb/pull/1828#discussion_r547099371", "createdAt": "2020-12-22T06:49:16Z", "author": {"login": "liutaohua"}, "path": "server/src/main/java/org/apache/iotdb/db/query/udf/core/executor/UDTFExecutor.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+\r\n+package org.apache.iotdb.db.query.udf.core.executor;\r\n+\r\n+import java.time.ZoneId;\r\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\r\n+import org.apache.iotdb.db.query.udf.api.UDTF;\r\n+import org.apache.iotdb.db.query.udf.api.access.Row;\r\n+import org.apache.iotdb.db.query.udf.api.access.RowWindow;\r\n+import org.apache.iotdb.db.query.udf.api.customizer.config.UDTFConfigurations;\r\n+import org.apache.iotdb.db.query.udf.api.customizer.parameter.UDFParameters;\r\n+import org.apache.iotdb.db.query.udf.core.context.UDFContext;\r\n+import org.apache.iotdb.db.query.udf.datastructure.tv.ElasticSerializableTVList;\r\n+import org.apache.iotdb.db.query.udf.service.UDFRegistrationService;\r\n+\r\n+public class UDTFExecutor {\r\n+\r\n+  protected final UDFContext context;\r\n+  protected UDTFConfigurations configurations;\r\n+  protected UDTF udtf;\r\n+  protected ElasticSerializableTVList collector;\r\n+\r\n+  public UDTFExecutor(UDFContext context, ZoneId zoneId) throws QueryProcessException {\r\n+    this.context = context;\r\n+    configurations = new UDTFConfigurations(zoneId);\r\n+    udtf = (UDTF) UDFRegistrationService.getInstance().reflect(context);\r\n+    try {\r\n+      udtf.beforeStart(new UDFParameters(context.getPaths(), context.getAttributes()),\r\n+          configurations);\r\n+    } catch (Exception e) {\r\n+      throw new QueryProcessException(e.getMessage());\r\n+    }\r\n+    configurations.check();\r\n+  }\r\n+\r\n+  public void initCollector(long queryId, float collectorMemoryBudgetInMB)\r\n+      throws QueryProcessException {\r\n+    collector = ElasticSerializableTVList\r\n+        .newElasticSerializableTVList(configurations.getOutputDataType(), queryId,\r\n+            collectorMemoryBudgetInMB, 1);\r\n+  }\r\n+\r\n+  public void execute(Row row) throws QueryProcessException {\r\n+    try {\r\n+      udtf.transform(row, collector);\r\n+    } catch (Exception e) {\r\n+      throw new QueryProcessException(e.getMessage());\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008822867e475e80b3e7f4f4bc62b9d7b0db4ab6"}, "originalPosition": 64}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 637, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}