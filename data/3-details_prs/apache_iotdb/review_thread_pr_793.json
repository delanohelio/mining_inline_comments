{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0MDM2ODY5", "number": 793, "reviewThreads": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNzoxNzoxM1rODfzCDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwNjoyMzoyMlrODg87Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjY4NTU4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/exception/metadata/RootNotExistException.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNzoxNzoxM1rOFptbxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMjozOTo1MlrOFrAzzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MDMyNQ==", "bodyText": "what is Root not exist?  StorageGroup not exist?", "url": "https://github.com/apache/iotdb/pull/793#discussion_r379280325", "createdAt": "2020-02-14T07:17:13Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/exception/metadata/RootNotExistException.java", "diffHunk": "@@ -15,16 +15,16 @@\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n+ *\n  */\n \n-package org.apache.iotdb.db.exception.storageGroup;\n+package org.apache.iotdb.db.exception.metadata;\n \n-public class StorageGroupPathException extends StorageGroupException {\n+public class RootNotExistException extends MetadataException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb410006edf4cfd8c44264e9c3d4d81ee1a9142"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMwMjQ5NQ==", "bodyText": "This method used to call StorageGroupPathException because it shows the storage group doesn't exist, but in the cluster branch, it is renamed to be thrown when the root node is wrong. For example when users enter rooot.vehicle.d0, he will get this error.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r379302495", "createdAt": "2020-02-14T08:29:04Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/exception/metadata/RootNotExistException.java", "diffHunk": "@@ -15,16 +15,16 @@\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n+ *\n  */\n \n-package org.apache.iotdb.db.exception.storageGroup;\n+package org.apache.iotdb.db.exception.metadata;\n \n-public class StorageGroupPathException extends StorageGroupException {\n+public class RootNotExistException extends MetadataException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MDMyNQ=="}, "originalCommit": {"oid": "9fb410006edf4cfd8c44264e9c3d4d81ee1a9142"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQzMzUzMA==", "bodyText": "Incorrect root exception", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380433530", "createdAt": "2020-02-18T02:59:56Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/exception/metadata/RootNotExistException.java", "diffHunk": "@@ -15,16 +15,16 @@\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n+ *\n  */\n \n-package org.apache.iotdb.db.exception.storageGroup;\n+package org.apache.iotdb.db.exception.metadata;\n \n-public class StorageGroupPathException extends StorageGroupException {\n+public class RootNotExistException extends MetadataException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MDMyNQ=="}, "originalCommit": {"oid": "9fb410006edf4cfd8c44264e9c3d4d81ee1a9142"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY0NjM1MA==", "bodyText": "Renamed", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380646350", "createdAt": "2020-02-18T12:39:52Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/exception/metadata/RootNotExistException.java", "diffHunk": "@@ -15,16 +15,16 @@\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n  * under the License.\n+ *\n  */\n \n-package org.apache.iotdb.db.exception.storageGroup;\n+package org.apache.iotdb.db.exception.metadata;\n \n-public class StorageGroupPathException extends StorageGroupException {\n+public class RootNotExistException extends MetadataException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MDMyNQ=="}, "originalCommit": {"oid": "9fb410006edf4cfd8c44264e9c3d4d81ee1a9142"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjcxMTU0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNzozMToxOVrOFptrUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwODozMzo0N1rOFpu5SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4NDMwNA==", "bodyText": "what is this field for?", "url": "https://github.com/apache/iotdb/pull/793#discussion_r379284304", "createdAt": "2020-02-14T07:31:19Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "diffHunk": "@@ -36,29 +36,47 @@\n \n   private static final long serialVersionUID = -770028375899514063L;\n \n-  // The name of the MNode\n+  /**\n+   * Name of the MNode\n+   */\n   private String name;\n-  // Whether current node is a leaf in the Metadata Tree\n+\n+  /**\n+   * Whether current node is a leaf in the Metadata Tree\n+   */\n   private boolean isLeaf;\n-  // Whether current node is Storage group in the Metadata Tree\n+\n+  /**\n+   * Whether current node is Storage group in the Metadata Tree\n+   */\n   private boolean isStorageGroup;\n-  // Map for the schema in this storage group\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n   private Map<String, MeasurementSchema> schemaMap;\n+\n   private Map<String, Integer> numSchemaMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb410006edf4cfd8c44264e9c3d4d81ee1a9142"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMwNDI2NA==", "bodyText": "It was used for addPath and deletePath in MManager... but is truly useless now. Deleted.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r379304264", "createdAt": "2020-02-14T08:33:47Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "diffHunk": "@@ -36,29 +36,47 @@\n \n   private static final long serialVersionUID = -770028375899514063L;\n \n-  // The name of the MNode\n+  /**\n+   * Name of the MNode\n+   */\n   private String name;\n-  // Whether current node is a leaf in the Metadata Tree\n+\n+  /**\n+   * Whether current node is a leaf in the Metadata Tree\n+   */\n   private boolean isLeaf;\n-  // Whether current node is Storage group in the Metadata Tree\n+\n+  /**\n+   * Whether current node is Storage group in the Metadata Tree\n+   */\n   private boolean isStorageGroup;\n-  // Map for the schema in this storage group\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n   private Map<String, MeasurementSchema> schemaMap;\n+\n   private Map<String, Integer> numSchemaMap;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4NDMwNA=="}, "originalCommit": {"oid": "9fb410006edf4cfd8c44264e9c3d4d81ee1a9142"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0Njc0MTI4OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/iotdb/db/qp/plan/TestConcatOptimizer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNzo0NzowNVrOFpt8tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwODozNTowM1rOFpu7Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4ODc1OQ==", "bodyText": "Rename this class to ConcatOptimizerTest", "url": "https://github.com/apache/iotdb/pull/793#discussion_r379288759", "createdAt": "2020-02-14T07:47:05Z", "author": {"login": "qiaojialin"}, "path": "server/src/test/java/org/apache/iotdb/db/qp/plan/TestConcatOptimizer.java", "diffHunk": "@@ -52,7 +52,7 @@\n   public void before() throws MetadataException, PathException {\n     processor = new Planner();\n     MManager.getInstance().init();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb410006edf4cfd8c44264e9c3d4d81ee1a9142"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMwNDczOA==", "bodyText": "Fixed.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r379304738", "createdAt": "2020-02-14T08:35:03Z", "author": {"login": "samperson1997"}, "path": "server/src/test/java/org/apache/iotdb/db/qp/plan/TestConcatOptimizer.java", "diffHunk": "@@ -52,7 +52,7 @@\n   public void before() throws MetadataException, PathException {\n     processor = new Planner();\n     MManager.getInstance().init();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4ODc1OQ=="}, "originalCommit": {"oid": "9fb410006edf4cfd8c44264e9c3d4d81ee1a9142"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0Njc3Nzg4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwODowNTo0NVrOFpuSxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMzowMzo1OFrOFp16tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI5NDQwNg==", "bodyText": "I don't understant this method... This is not only a get function, it also changes the tree structure.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r379294406", "createdAt": "2020-02-14T08:05:45Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +52,127 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n+  /**\n+   * dummy node is used for the default param of traverse methods\n+   */\n+  private MNode dummyNode;\n \n   MTree(String rootName) {\n     this.root = new MNode(rootName, null, false);\n+    this.dummyNode = new MNode(\"dummy\", null, false);\n   }\n \n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n-   */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n+   * Add timeseries path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n+      throw new IllegalPathException(path);\n     }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+    MNode cur = getParent(nodeNames);\n+    String storageGroupName = cur.getStorageGroupName();\n \n     MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n     if (props != null && !props.isEmpty()) {\n       leaf.getSchema().setProps(props);\n     }\n-    leaf.setDataFileName(levelPath);\n+    leaf.setStorageGroupName(storageGroupName);\n     if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n+      throw new PathAlreadyExistException(cur.getFullPath());\n     }\n     cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n   /**\n-   * function for adding deviceId\n+   * Add device to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n+   *\n+   * @param deviceId device id\n    */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+  MNode addDevice(String deviceId) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(deviceId);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n+      throw new IllegalPathException(deviceId);\n     }\n-    MNode cur = getRoot();\n+    MNode cur = root;\n     for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n+      if (!cur.hasChildWithKey(nodeNames[i])) {\n         cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n       }\n       cur = cur.getChild(nodeNames[i]);\n     }\n     return cur;\n   }\n \n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n+  /**\n+   * Get nodes parent\n+   *\n+   * @param nodeNames node names\n+   */\n+  private MNode getParent(String[] nodeNames) throws MetadataException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fb410006edf4cfd8c44264e9c3d4d81ee1a9142"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQxOTMxOQ==", "bodyText": "Actually I don't think it changes the tree structure, for it only addChild when current node doesn't have child with the node name (!cur.hasChildWithKey(nodeName)). But I combine codes in this method into the addPath method to avoid misunderstandings of parent.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r379419319", "createdAt": "2020-02-14T13:03:58Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +52,127 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n+  /**\n+   * dummy node is used for the default param of traverse methods\n+   */\n+  private MNode dummyNode;\n \n   MTree(String rootName) {\n     this.root = new MNode(rootName, null, false);\n+    this.dummyNode = new MNode(\"dummy\", null, false);\n   }\n \n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n-   */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n+   * Add timeseries path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n+      throw new IllegalPathException(path);\n     }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+    MNode cur = getParent(nodeNames);\n+    String storageGroupName = cur.getStorageGroupName();\n \n     MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n     if (props != null && !props.isEmpty()) {\n       leaf.getSchema().setProps(props);\n     }\n-    leaf.setDataFileName(levelPath);\n+    leaf.setStorageGroupName(storageGroupName);\n     if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n+      throw new PathAlreadyExistException(cur.getFullPath());\n     }\n     cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n   /**\n-   * function for adding deviceId\n+   * Add device to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n+   *\n+   * @param deviceId device id\n    */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+  MNode addDevice(String deviceId) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(deviceId);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n+      throw new IllegalPathException(deviceId);\n     }\n-    MNode cur = getRoot();\n+    MNode cur = root;\n     for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n+      if (!cur.hasChildWithKey(nodeNames[i])) {\n         cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n       }\n       cur = cur.getChild(nodeNames[i]);\n     }\n     return cur;\n   }\n \n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n+  /**\n+   * Get nodes parent\n+   *\n+   * @param nodeNames node names\n+   */\n+  private MNode getParent(String[] nodeNames) throws MetadataException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI5NDQwNg=="}, "originalCommit": {"oid": "9fb410006edf4cfd8c44264e9c3d4d81ee1a9142"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NDU1NzI4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MetaUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwMzowNToxMVrOFqz4gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMjo0MDoxMlrOFrA0cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQzNDU2Mg==", "bodyText": "cache path.split to avoid splitting twice", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380434562", "createdAt": "2020-02-18T03:05:11Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MetaUtils.java", "diffHunk": "@@ -18,27 +18,33 @@\n  */\n package org.apache.iotdb.db.metadata;\n \n-public class MetaUtils {\n-  public static String[] getNodeNames(String path, String separator) {\n+import static org.apache.iotdb.db.conf.IoTDBConstant.PATH_WILDCARD;\n+\n+class MetaUtils {\n+\n+  private static final String PATH_SEPARATOR = \"\\\\.\";\n+\n+  private MetaUtils() {\n+\n+  }\n+\n+  static String[] getNodeNames(String path) {\n     String[] nodeNames;\n-    path = path.trim();\n     if (path.contains(\"\\\"\") || path.contains(\"\\'\")) {\n-      String[] deviceAndMeasurement;\n-      if (path.contains(\"\\\"\")) {\n-        deviceAndMeasurement = path.split(\"\\\"\");\n-      } else {\n-        deviceAndMeasurement = path.split(\"\\'\");\n-      }\n-      String device = deviceAndMeasurement[0];\n-      String measurement = deviceAndMeasurement[1];\n-      String[] deviceNodeName = device.split(separator);\n+      path = path.trim().replace(\"\\'\", \"\\\"\");\n+      String measurement = path.split(\"\\\"\")[1];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c8e29136522e34e8716fc706d892787b0a5e669"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY0NjUxMg==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380646512", "createdAt": "2020-02-18T12:40:12Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MetaUtils.java", "diffHunk": "@@ -18,27 +18,33 @@\n  */\n package org.apache.iotdb.db.metadata;\n \n-public class MetaUtils {\n-  public static String[] getNodeNames(String path, String separator) {\n+import static org.apache.iotdb.db.conf.IoTDBConstant.PATH_WILDCARD;\n+\n+class MetaUtils {\n+\n+  private static final String PATH_SEPARATOR = \"\\\\.\";\n+\n+  private MetaUtils() {\n+\n+  }\n+\n+  static String[] getNodeNames(String path) {\n     String[] nodeNames;\n-    path = path.trim();\n     if (path.contains(\"\\\"\") || path.contains(\"\\'\")) {\n-      String[] deviceAndMeasurement;\n-      if (path.contains(\"\\\"\")) {\n-        deviceAndMeasurement = path.split(\"\\\"\");\n-      } else {\n-        deviceAndMeasurement = path.split(\"\\'\");\n-      }\n-      String device = deviceAndMeasurement[0];\n-      String measurement = deviceAndMeasurement[1];\n-      String[] deviceNodeName = device.split(separator);\n+      path = path.trim().replace(\"\\'\", \"\\\"\");\n+      String measurement = path.split(\"\\\"\")[1];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQzNDU2Mg=="}, "originalCommit": {"oid": "8c8e29136522e34e8716fc706d892787b0a5e669"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NDkyNjA4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwNzowNDozN1rOFq3Png==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMjoyMDo1N1rOFrZGCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ4OTYzMA==", "bodyText": "use a StorageGroupMNode, move this method into it", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380489630", "createdAt": "2020-02-18T07:04:37Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;\n+\n+  /**\n+   * Column's Schema for one timeseries represented by current node if current node is one leaf\n+   */\n+  MeasurementSchema schema;\n+\n+  Map<String, MNode> children;\n+\n+  MNodeType nodeType;\n+\n+  /**\n+   * when the data in a storage group is older than dataTTL, it is considered invalid and will be\n+   * eventually removed. only set at storage group level.\n+   */\n+  private long dataTTL = Long.MAX_VALUE;\n+\n+  /**\n+   * Constructor of MNode.\n+   */\n+  public MNode(String name, MNode parent) {\n+    this.setName(name);\n+    this.parent = parent;\n+  }\n+\n+  abstract public boolean isNodeType(MNodeType nodeType);\n+\n+  /**\n+   * Set storage group\n+   */\n+  public void setStorageGroup() {\n+    nodeType = MNodeType.STORAGE_GROUP_MNODE;\n+    schemaMap = new HashMap<>();\n+  }\n+\n+  public Map<String, MeasurementSchema> getSchemaMap() {\n+    return schemaMap;\n+  }\n+\n+  /**\n+   * check whether the MNode has children\n+   */\n+  abstract public boolean hasChildren();\n+\n+  /**\n+   * check whether the MNode has child with the given key\n+   *\n+   * @param key key\n+   */\n+  abstract public boolean hasChildWithKey(String key);\n+\n+  /**\n+   * add the given key to given child MNode\n+   *\n+   * @param key key\n+   * @param child child MNode\n+   */\n+  abstract public void addChild(String key, MNode child);\n+\n+  /**\n+   * delete key from given child MNode\n+   *\n+   * @param key key\n+   */\n+  abstract public void deleteChild(String key);\n+\n+  /**\n+   * get the child MNode under the given key.\n+   *\n+   * @param key key\n+   */\n+  abstract public MNode getChild(String key);\n+\n+  /**\n+   * get the count of all leaves whose ancestor is current node\n+   */\n+  abstract public int getLeafCount();\n+\n+  /**\n+   * get full path\n+   */\n+  public String getFullPath() {\n+    if (fullPath != null) {\n+      return fullPath;\n+    }\n+    StringBuilder builder = new StringBuilder(name);\n+    MNode curr = this;\n+    while (curr.parent != null) {\n+      curr = curr.parent;\n+      builder.insert(0, IoTDBConstant.PATH_SEPARATOR).insert(0, curr.name);\n+    }\n+    return fullPath = builder.toString();\n+  }\n+\n+  public String getStorageGroupName() {\n+    return storageGroupName;\n+  }\n+\n+  public void setStorageGroupName(String storageGroupName) {\n+    this.storageGroupName = storageGroupName;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return this.getName();\n+  }\n+\n+  public MeasurementSchema getSchema() {\n+    return schema;\n+  }\n+\n+  public MNode getParent() {\n+    return parent;\n+  }\n+\n+  abstract public Map<String, MNode> getChildren();\n+\n+  public String getName() {\n+    return name;\n+  }\n+\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public long getDataTTL() {\n+    return dataTTL;\n+  }\n+\n+  public void setDataTTL(long dataTTL) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA0NDIzMg==", "bodyText": "Moved.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r381044232", "createdAt": "2020-02-19T02:20:57Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;\n+\n+  /**\n+   * Column's Schema for one timeseries represented by current node if current node is one leaf\n+   */\n+  MeasurementSchema schema;\n+\n+  Map<String, MNode> children;\n+\n+  MNodeType nodeType;\n+\n+  /**\n+   * when the data in a storage group is older than dataTTL, it is considered invalid and will be\n+   * eventually removed. only set at storage group level.\n+   */\n+  private long dataTTL = Long.MAX_VALUE;\n+\n+  /**\n+   * Constructor of MNode.\n+   */\n+  public MNode(String name, MNode parent) {\n+    this.setName(name);\n+    this.parent = parent;\n+  }\n+\n+  abstract public boolean isNodeType(MNodeType nodeType);\n+\n+  /**\n+   * Set storage group\n+   */\n+  public void setStorageGroup() {\n+    nodeType = MNodeType.STORAGE_GROUP_MNODE;\n+    schemaMap = new HashMap<>();\n+  }\n+\n+  public Map<String, MeasurementSchema> getSchemaMap() {\n+    return schemaMap;\n+  }\n+\n+  /**\n+   * check whether the MNode has children\n+   */\n+  abstract public boolean hasChildren();\n+\n+  /**\n+   * check whether the MNode has child with the given key\n+   *\n+   * @param key key\n+   */\n+  abstract public boolean hasChildWithKey(String key);\n+\n+  /**\n+   * add the given key to given child MNode\n+   *\n+   * @param key key\n+   * @param child child MNode\n+   */\n+  abstract public void addChild(String key, MNode child);\n+\n+  /**\n+   * delete key from given child MNode\n+   *\n+   * @param key key\n+   */\n+  abstract public void deleteChild(String key);\n+\n+  /**\n+   * get the child MNode under the given key.\n+   *\n+   * @param key key\n+   */\n+  abstract public MNode getChild(String key);\n+\n+  /**\n+   * get the count of all leaves whose ancestor is current node\n+   */\n+  abstract public int getLeafCount();\n+\n+  /**\n+   * get full path\n+   */\n+  public String getFullPath() {\n+    if (fullPath != null) {\n+      return fullPath;\n+    }\n+    StringBuilder builder = new StringBuilder(name);\n+    MNode curr = this;\n+    while (curr.parent != null) {\n+      curr = curr.parent;\n+      builder.insert(0, IoTDBConstant.PATH_SEPARATOR).insert(0, curr.name);\n+    }\n+    return fullPath = builder.toString();\n+  }\n+\n+  public String getStorageGroupName() {\n+    return storageGroupName;\n+  }\n+\n+  public void setStorageGroupName(String storageGroupName) {\n+    this.storageGroupName = storageGroupName;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return this.getName();\n+  }\n+\n+  public MeasurementSchema getSchema() {\n+    return schema;\n+  }\n+\n+  public MNode getParent() {\n+    return parent;\n+  }\n+\n+  abstract public Map<String, MNode> getChildren();\n+\n+  public String getName() {\n+    return name;\n+  }\n+\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public long getDataTTL() {\n+    return dataTTL;\n+  }\n+\n+  public void setDataTTL(long dataTTL) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ4OTYzMA=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NDkyNjUzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwNzowNDo1NlrOFq3P4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMjo0MDoyOFrOFrA06w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ4OTY5OA==", "bodyText": "add props map", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380489698", "createdAt": "2020-02-18T07:04:56Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public class LeafMNode extends MNode {\n+\n+  private static final long serialVersionUID = -1199657856921206435L;\n+\n+  public LeafMNode(String name, MNode parent) {\n+    super(name, parent);\n+  }\n+\n+  public LeafMNode(String name, MNode parent, TSDataType dataType, TSEncoding encoding,\n+      CompressionType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY0NjYzNQ==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380646635", "createdAt": "2020-02-18T12:40:28Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public class LeafMNode extends MNode {\n+\n+  private static final long serialVersionUID = -1199657856921206435L;\n+\n+  public LeafMNode(String name, MNode parent) {\n+    super(name, parent);\n+  }\n+\n+  public LeafMNode(String name, MNode parent, TSDataType dataType, TSEncoding encoding,\n+      CompressionType type) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ4OTY5OA=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTAwMzY5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwNzo0MzozNVrOFq3-rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMzowMzo0N1rOFrZtQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwMTY3OA==", "bodyText": "if we use Class type to distinguish the types, this method could be removed", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380501678", "createdAt": "2020-02-18T07:43:35Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;\n+\n+  /**\n+   * Column's Schema for one timeseries represented by current node if current node is one leaf\n+   */\n+  MeasurementSchema schema;\n+\n+  Map<String, MNode> children;\n+\n+  MNodeType nodeType;\n+\n+  /**\n+   * when the data in a storage group is older than dataTTL, it is considered invalid and will be\n+   * eventually removed. only set at storage group level.\n+   */\n+  private long dataTTL = Long.MAX_VALUE;\n+\n+  /**\n+   * Constructor of MNode.\n+   */\n+  public MNode(String name, MNode parent) {\n+    this.setName(name);\n+    this.parent = parent;\n+  }\n+\n+  abstract public boolean isNodeType(MNodeType nodeType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA1NDI3NQ==", "bodyText": "Removed.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r381054275", "createdAt": "2020-02-19T03:03:47Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;\n+\n+  /**\n+   * Column's Schema for one timeseries represented by current node if current node is one leaf\n+   */\n+  MeasurementSchema schema;\n+\n+  Map<String, MNode> children;\n+\n+  MNodeType nodeType;\n+\n+  /**\n+   * when the data in a storage group is older than dataTTL, it is considered invalid and will be\n+   * eventually removed. only set at storage group level.\n+   */\n+  private long dataTTL = Long.MAX_VALUE;\n+\n+  /**\n+   * Constructor of MNode.\n+   */\n+  public MNode(String name, MNode parent) {\n+    this.setName(name);\n+    this.parent = parent;\n+  }\n+\n+  abstract public boolean isNodeType(MNodeType nodeType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwMTY3OA=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTAwNDc3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwNzo0NDowNFrOFq3_Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMzowNDoxMVrOFrZtnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwMTg1MA==", "bodyText": "the nodeType could be retained, add a getter", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380501850", "createdAt": "2020-02-18T07:44:04Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;\n+\n+  /**\n+   * Column's Schema for one timeseries represented by current node if current node is one leaf\n+   */\n+  MeasurementSchema schema;\n+\n+  Map<String, MNode> children;\n+\n+  MNodeType nodeType;\n+\n+  /**\n+   * when the data in a storage group is older than dataTTL, it is considered invalid and will be\n+   * eventually removed. only set at storage group level.\n+   */\n+  private long dataTTL = Long.MAX_VALUE;\n+\n+  /**\n+   * Constructor of MNode.\n+   */\n+  public MNode(String name, MNode parent) {\n+    this.setName(name);\n+    this.parent = parent;\n+  }\n+\n+  abstract public boolean isNodeType(MNodeType nodeType);\n+\n+  /**\n+   * Set storage group\n+   */\n+  public void setStorageGroup() {\n+    nodeType = MNodeType.STORAGE_GROUP_MNODE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA1NDM2NA==", "bodyText": "If it is used in the future, I'd like to add it back.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r381054364", "createdAt": "2020-02-19T03:04:11Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;\n+\n+  /**\n+   * Column's Schema for one timeseries represented by current node if current node is one leaf\n+   */\n+  MeasurementSchema schema;\n+\n+  Map<String, MNode> children;\n+\n+  MNodeType nodeType;\n+\n+  /**\n+   * when the data in a storage group is older than dataTTL, it is considered invalid and will be\n+   * eventually removed. only set at storage group level.\n+   */\n+  private long dataTTL = Long.MAX_VALUE;\n+\n+  /**\n+   * Constructor of MNode.\n+   */\n+  public MNode(String name, MNode parent) {\n+    this.setName(name);\n+    this.parent = parent;\n+  }\n+\n+  abstract public boolean isNodeType(MNodeType nodeType);\n+\n+  /**\n+   * Set storage group\n+   */\n+  public void setStorageGroup() {\n+    nodeType = MNodeType.STORAGE_GROUP_MNODE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwMTg1MA=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTAxODMyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwNzo0OTozNFrOFq4HUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMjoyMjo1OVrOFrZH0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwMzg4OA==", "bodyText": "move this to StorageGroupMNode", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380503888", "createdAt": "2020-02-18T07:49:34Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;\n+\n+  /**\n+   * Column's Schema for one timeseries represented by current node if current node is one leaf\n+   */\n+  MeasurementSchema schema;\n+\n+  Map<String, MNode> children;\n+\n+  MNodeType nodeType;\n+\n+  /**\n+   * when the data in a storage group is older than dataTTL, it is considered invalid and will be\n+   * eventually removed. only set at storage group level.\n+   */\n+  private long dataTTL = Long.MAX_VALUE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA0NDY5MA==", "bodyText": "Moved.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r381044690", "createdAt": "2020-02-19T02:22:59Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;\n+\n+  /**\n+   * Column's Schema for one timeseries represented by current node if current node is one leaf\n+   */\n+  MeasurementSchema schema;\n+\n+  Map<String, MNode> children;\n+\n+  MNodeType nodeType;\n+\n+  /**\n+   * when the data in a storage group is older than dataTTL, it is considered invalid and will be\n+   * eventually removed. only set at storage group level.\n+   */\n+  private long dataTTL = Long.MAX_VALUE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwMzg4OA=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTAxODY3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwNzo0OTo0M1rOFq4Hhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMTo1MTo0NVrOFrYprg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwMzk0Mw==", "bodyText": "move this to LeafNode", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380503943", "createdAt": "2020-02-18T07:49:43Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;\n+\n+  /**\n+   * Column's Schema for one timeseries represented by current node if current node is one leaf\n+   */\n+  MeasurementSchema schema;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzNjk3NA==", "bodyText": "Moved.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r381036974", "createdAt": "2020-02-19T01:51:45Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;\n+\n+  /**\n+   * Column's Schema for one timeseries represented by current node if current node is one leaf\n+   */\n+  MeasurementSchema schema;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwMzk0Mw=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTAyNDU1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwNzo1MTo0M1rOFq4K1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMTo1OToxNFrOFrYxNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwNDc4OQ==", "bodyText": "move this to LeafNode. I wonder if this will occupy much memory.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380504789", "createdAt": "2020-02-18T07:51:43Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzODkwMQ==", "bodyText": "An internal node may also need this method. For example, the fullpath of node sg1 is root.sg1, and this could be used for setting storage group.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r381038901", "createdAt": "2020-02-19T01:59:14Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwNDc4OQ=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTAyNjcwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwNzo1Mjo0MlrOFq4MJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMzowNDoyMFrOFrZtrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwNTEyNg==", "bodyText": "move this to StorageGroupMNode", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380505126", "createdAt": "2020-02-18T07:52:42Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA1NDM4Mw==", "bodyText": "Moved.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r381054383", "createdAt": "2020-02-19T03:04:20Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwNTEyNg=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTIxNjIyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOTowMDowOVrOFq5_sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMjo0MTowOFrOFrA2LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNDcwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param key key\n          \n          \n            \n               * @param key the queried child name", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380534706", "createdAt": "2020-02-18T09:00:09Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public class InternalMNode extends MNode {\n+\n+  private static final long serialVersionUID = 7999036474525817732L;\n+\n+  public InternalMNode(String name, MNode parent) {\n+    super(name, parent);\n+    this.nodeType = MNodeType.INTERNAL_MNODE;\n+    this.children = new LinkedHashMap<>();\n+  }\n+\n+  @Override\n+  public boolean isNodeType(MNodeType nodeType) {\n+    return this.nodeType.equals(nodeType);\n+  }\n+\n+  /**\n+   * check whether the MNode has children\n+   */\n+  @Override\n+  public boolean hasChildren() {\n+    return true;\n+  }\n+\n+  /**\n+   * check whether the MNode has child with the given key\n+   *\n+   * @param key key\n+   */\n+  @Override\n+  public boolean hasChildWithKey(String key) {\n+    return this.children.containsKey(key);\n+  }\n+\n+  /**\n+   * add the given key to given child MNode\n+   *\n+   * @param key key\n+   * @param child child MNode\n+   */\n+  @Override\n+  public void addChild(String key, MNode child) {\n+    this.children.put(key, child);\n+  }\n+\n+  /**\n+   * delete key from given child MNode\n+   *\n+   * @param key key\n+   */\n+  @Override\n+  public void deleteChild(String key) {\n+    children.remove(key);\n+  }\n+\n+  /**\n+   * get the child MNode under the given key.\n+   *\n+   * @param key key", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY0Njk1Ng==", "bodyText": "Updated.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380646956", "createdAt": "2020-02-18T12:41:08Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public class InternalMNode extends MNode {\n+\n+  private static final long serialVersionUID = 7999036474525817732L;\n+\n+  public InternalMNode(String name, MNode parent) {\n+    super(name, parent);\n+    this.nodeType = MNodeType.INTERNAL_MNODE;\n+    this.children = new LinkedHashMap<>();\n+  }\n+\n+  @Override\n+  public boolean isNodeType(MNodeType nodeType) {\n+    return this.nodeType.equals(nodeType);\n+  }\n+\n+  /**\n+   * check whether the MNode has children\n+   */\n+  @Override\n+  public boolean hasChildren() {\n+    return true;\n+  }\n+\n+  /**\n+   * check whether the MNode has child with the given key\n+   *\n+   * @param key key\n+   */\n+  @Override\n+  public boolean hasChildWithKey(String key) {\n+    return this.children.containsKey(key);\n+  }\n+\n+  /**\n+   * add the given key to given child MNode\n+   *\n+   * @param key key\n+   * @param child child MNode\n+   */\n+  @Override\n+  public void addChild(String key, MNode child) {\n+    this.children.put(key, child);\n+  }\n+\n+  /**\n+   * delete key from given child MNode\n+   *\n+   * @param key key\n+   */\n+  @Override\n+  public void deleteChild(String key) {\n+    children.remove(key);\n+  }\n+\n+  /**\n+   * get the child MNode under the given key.\n+   *\n+   * @param key key", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNDcwNg=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTIxODAyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOTowMDo0MVrOFq6A3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMjo0MToxM1rOFrA2Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNTAwNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param key key\n          \n          \n            \n               * @param key deleted child name", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380535004", "createdAt": "2020-02-18T09:00:41Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public class InternalMNode extends MNode {\n+\n+  private static final long serialVersionUID = 7999036474525817732L;\n+\n+  public InternalMNode(String name, MNode parent) {\n+    super(name, parent);\n+    this.nodeType = MNodeType.INTERNAL_MNODE;\n+    this.children = new LinkedHashMap<>();\n+  }\n+\n+  @Override\n+  public boolean isNodeType(MNodeType nodeType) {\n+    return this.nodeType.equals(nodeType);\n+  }\n+\n+  /**\n+   * check whether the MNode has children\n+   */\n+  @Override\n+  public boolean hasChildren() {\n+    return true;\n+  }\n+\n+  /**\n+   * check whether the MNode has child with the given key\n+   *\n+   * @param key key\n+   */\n+  @Override\n+  public boolean hasChildWithKey(String key) {\n+    return this.children.containsKey(key);\n+  }\n+\n+  /**\n+   * add the given key to given child MNode\n+   *\n+   * @param key key\n+   * @param child child MNode\n+   */\n+  @Override\n+  public void addChild(String key, MNode child) {\n+    this.children.put(key, child);\n+  }\n+\n+  /**\n+   * delete key from given child MNode\n+   *\n+   * @param key key", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY0Njk4Mg==", "bodyText": "Updated.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380646982", "createdAt": "2020-02-18T12:41:13Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public class InternalMNode extends MNode {\n+\n+  private static final long serialVersionUID = 7999036474525817732L;\n+\n+  public InternalMNode(String name, MNode parent) {\n+    super(name, parent);\n+    this.nodeType = MNodeType.INTERNAL_MNODE;\n+    this.children = new LinkedHashMap<>();\n+  }\n+\n+  @Override\n+  public boolean isNodeType(MNodeType nodeType) {\n+    return this.nodeType.equals(nodeType);\n+  }\n+\n+  /**\n+   * check whether the MNode has children\n+   */\n+  @Override\n+  public boolean hasChildren() {\n+    return true;\n+  }\n+\n+  /**\n+   * check whether the MNode has child with the given key\n+   *\n+   * @param key key\n+   */\n+  @Override\n+  public boolean hasChildWithKey(String key) {\n+    return this.children.containsKey(key);\n+  }\n+\n+  /**\n+   * add the given key to given child MNode\n+   *\n+   * @param key key\n+   * @param child child MNode\n+   */\n+  @Override\n+  public void addChild(String key, MNode child) {\n+    this.children.put(key, child);\n+  }\n+\n+  /**\n+   * delete key from given child MNode\n+   *\n+   * @param key key", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNTAwNA=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTI1NDI4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOToxMTo0MFrOFq6XgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMjoxOTozM1rOFrZEtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDgwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              MNode addPath(String path) throws MetadataException {\n          \n          \n            \n              MNode addInternalPath(String path) throws MetadataException {", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380540800", "createdAt": "2020-02-18T09:11:40Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MjgzNw==", "bodyText": "I wonder why this method exists, could this be replaced by addPath(String path, TSDataType dataType, TSEncoding encoding, CompressionType compressor, Map<String, String> props)?", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380542837", "createdAt": "2020-02-18T09:15:23Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDgwMA=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0OTI5Nw==", "bodyText": "The other unclear thing is,   I add a path to MTree, which MNode this method returns to me? It's better to return void", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380549297", "createdAt": "2020-02-18T09:26:33Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDgwMA=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA0Mzg5NQ==", "bodyText": "This method is used for getNodeByPathFromCache, and I think it may omit some steps of addPath(String path, TSDataType dataType, TSEncoding encoding, CompressionType compressor, Map<String, String> props)... And in the getNodeByPathFromCache method, it needs the return value.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r381043895", "createdAt": "2020-02-19T02:19:33Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDgwMA=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTI1NTU5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOToxMjowNVrOFq6YXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMjo0MTozMVrOFrA2zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MTAyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n          \n          \n            \n               * Add an interval path to MTree. This is only used for automatically creating schema", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380541020", "createdAt": "2020-02-18T09:12:05Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY0NzExOQ==", "bodyText": "Updated.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380647119", "createdAt": "2020-02-18T12:41:31Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MTAyMA=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTMwMTM5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOToyNDo0M1rOFq60lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMjo0NTowMFrOFrA9MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0ODI0Ng==", "bodyText": "I find that isPathExist(MNode node, String path) is only used in isPathExist(String path). So, the node must be a dummyNode. Then, we could init the cur = root without this check. And I really do not get why we need a dummyNode. It's better to remove it.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380548246", "createdAt": "2020-02-18T09:24:43Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n+      throw new IllegalPathException(path);\n+    }\n     MNode cur = root;\n-    int i = 0;\n-    while (i < nodeNames.length - 1) {\n-      String nodeName = nodeNames[i];\n-      if (cur.getName().equals(nodeName)) {\n-        i++;\n-        nodeName = nodeNames[i];\n-        if (cur.hasChild(nodeName)) {\n-          cur = cur.getChild(nodeName);\n-        } else {\n-          return false;\n-        }\n-      } else {\n-        return false;\n+    for (int i = 1; i < nodeNames.length; i++) {\n+      if (!cur.hasChildWithKey(nodeNames[i])) {\n+        cur.addChild(nodeNames[i], new InternalMNode(nodeNames[i], cur));\n       }\n+      cur = cur.getChild(nodeNames[i]);\n     }\n-    return cur.getName().equals(nodeNames[i]);\n+    return cur;\n+  }\n+\n+  /**\n+   * Check whether the given path exists\n+   *\n+   * @param path not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   */\n+  boolean isPathExist(String path) {\n+    return isPathExist(dummyNode, path);\n   }\n \n   /**\n-   * function for checking whether the given path exists under the given mNode.\n+   * Check whether the given path exists under the given MNode\n    */\n-  boolean isPathExist(MNode node, String path) {\n-    String[] nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n-    if (nodeNames.length < 1) {\n-      return true;\n-    }\n-    if (!node.hasChild(nodeNames[0])) {\n-      return false;\n+  private boolean isPathExist(MNode node, String path) {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    MNode cur;\n+    if (node.equals(dummyNode)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY0ODc1Mg==", "bodyText": "I'm not sure whether this method will be used in the future, so I retained this method. It could be removed currently.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380648752", "createdAt": "2020-02-18T12:45:00Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n+      throw new IllegalPathException(path);\n+    }\n     MNode cur = root;\n-    int i = 0;\n-    while (i < nodeNames.length - 1) {\n-      String nodeName = nodeNames[i];\n-      if (cur.getName().equals(nodeName)) {\n-        i++;\n-        nodeName = nodeNames[i];\n-        if (cur.hasChild(nodeName)) {\n-          cur = cur.getChild(nodeName);\n-        } else {\n-          return false;\n-        }\n-      } else {\n-        return false;\n+    for (int i = 1; i < nodeNames.length; i++) {\n+      if (!cur.hasChildWithKey(nodeNames[i])) {\n+        cur.addChild(nodeNames[i], new InternalMNode(nodeNames[i], cur));\n       }\n+      cur = cur.getChild(nodeNames[i]);\n     }\n-    return cur.getName().equals(nodeNames[i]);\n+    return cur;\n+  }\n+\n+  /**\n+   * Check whether the given path exists\n+   *\n+   * @param path not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   */\n+  boolean isPathExist(String path) {\n+    return isPathExist(dummyNode, path);\n   }\n \n   /**\n-   * function for checking whether the given path exists under the given mNode.\n+   * Check whether the given path exists under the given MNode\n    */\n-  boolean isPathExist(MNode node, String path) {\n-    String[] nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n-    if (nodeNames.length < 1) {\n-      return true;\n-    }\n-    if (!node.hasChild(nodeNames[0])) {\n-      return false;\n+  private boolean isPathExist(MNode node, String path) {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    MNode cur;\n+    if (node.equals(dummyNode)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0ODI0Ng=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTMxNDcwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOToyODoxNVrOFq69Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMTozNzoxNVrOFrYayw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1MDQyMg==", "bodyText": "is the path a full path that starts from the root? add javadoc", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380550422", "createdAt": "2020-02-18T09:28:15Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n+      throw new IllegalPathException(path);\n+    }\n     MNode cur = root;\n-    int i = 0;\n-    while (i < nodeNames.length - 1) {\n-      String nodeName = nodeNames[i];\n-      if (cur.getName().equals(nodeName)) {\n-        i++;\n-        nodeName = nodeNames[i];\n-        if (cur.hasChild(nodeName)) {\n-          cur = cur.getChild(nodeName);\n-        } else {\n-          return false;\n-        }\n-      } else {\n-        return false;\n+    for (int i = 1; i < nodeNames.length; i++) {\n+      if (!cur.hasChildWithKey(nodeNames[i])) {\n+        cur.addChild(nodeNames[i], new InternalMNode(nodeNames[i], cur));\n       }\n+      cur = cur.getChild(nodeNames[i]);\n     }\n-    return cur.getName().equals(nodeNames[i]);\n+    return cur;\n+  }\n+\n+  /**\n+   * Check whether the given path exists\n+   *\n+   * @param path not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   */\n+  boolean isPathExist(String path) {\n+    return isPathExist(dummyNode, path);\n   }\n \n   /**\n-   * function for checking whether the given path exists under the given mNode.\n+   * Check whether the given path exists under the given MNode\n    */\n-  boolean isPathExist(MNode node, String path) {\n-    String[] nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n-    if (nodeNames.length < 1) {\n-      return true;\n-    }\n-    if (!node.hasChild(nodeNames[0])) {\n-      return false;\n+  private boolean isPathExist(MNode node, String path) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzMzE2Mw==", "bodyText": "Starts from the root. Javadoc added.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r381033163", "createdAt": "2020-02-19T01:37:15Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n+      throw new IllegalPathException(path);\n+    }\n     MNode cur = root;\n-    int i = 0;\n-    while (i < nodeNames.length - 1) {\n-      String nodeName = nodeNames[i];\n-      if (cur.getName().equals(nodeName)) {\n-        i++;\n-        nodeName = nodeNames[i];\n-        if (cur.hasChild(nodeName)) {\n-          cur = cur.getChild(nodeName);\n-        } else {\n-          return false;\n-        }\n-      } else {\n-        return false;\n+    for (int i = 1; i < nodeNames.length; i++) {\n+      if (!cur.hasChildWithKey(nodeNames[i])) {\n+        cur.addChild(nodeNames[i], new InternalMNode(nodeNames[i], cur));\n       }\n+      cur = cur.getChild(nodeNames[i]);\n     }\n-    return cur.getName().equals(nodeNames[i]);\n+    return cur;\n+  }\n+\n+  /**\n+   * Check whether the given path exists\n+   *\n+   * @param path not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   */\n+  boolean isPathExist(String path) {\n+    return isPathExist(dummyNode, path);\n   }\n \n   /**\n-   * function for checking whether the given path exists under the given mNode.\n+   * Check whether the given path exists under the given MNode\n    */\n-  boolean isPathExist(MNode node, String path) {\n-    String[] nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n-    if (nodeNames.length < 1) {\n-      return true;\n-    }\n-    if (!node.hasChild(nodeNames[0])) {\n-      return false;\n+  private boolean isPathExist(MNode node, String path) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1MDQyMg=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTMxNzY4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOToyOTowM1rOFq6_CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMTo0NTo0NFrOFrYjsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1MDkyMQ==", "bodyText": "if the path is from root, we could start from i = 1", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380550921", "createdAt": "2020-02-18T09:29:03Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n+      throw new IllegalPathException(path);\n+    }\n     MNode cur = root;\n-    int i = 0;\n-    while (i < nodeNames.length - 1) {\n-      String nodeName = nodeNames[i];\n-      if (cur.getName().equals(nodeName)) {\n-        i++;\n-        nodeName = nodeNames[i];\n-        if (cur.hasChild(nodeName)) {\n-          cur = cur.getChild(nodeName);\n-        } else {\n-          return false;\n-        }\n-      } else {\n-        return false;\n+    for (int i = 1; i < nodeNames.length; i++) {\n+      if (!cur.hasChildWithKey(nodeNames[i])) {\n+        cur.addChild(nodeNames[i], new InternalMNode(nodeNames[i], cur));\n       }\n+      cur = cur.getChild(nodeNames[i]);\n     }\n-    return cur.getName().equals(nodeNames[i]);\n+    return cur;\n+  }\n+\n+  /**\n+   * Check whether the given path exists\n+   *\n+   * @param path not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   */\n+  boolean isPathExist(String path) {\n+    return isPathExist(dummyNode, path);\n   }\n \n   /**\n-   * function for checking whether the given path exists under the given mNode.\n+   * Check whether the given path exists under the given MNode\n    */\n-  boolean isPathExist(MNode node, String path) {\n-    String[] nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n-    if (nodeNames.length < 1) {\n-      return true;\n-    }\n-    if (!node.hasChild(nodeNames[0])) {\n-      return false;\n+  private boolean isPathExist(MNode node, String path) {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    MNode cur;\n+    if (node.equals(dummyNode)) {\n+      cur = root;\n+    } else {\n+      cur = node.getChild(nodeNames[0]);\n+      if (!node.hasChildWithKey(nodeNames[0])) {\n+        return false;\n+      }\n     }\n-    MNode cur = node.getChild(nodeNames[0]);\n-\n     int i = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzNTQ0Mw==", "bodyText": "I rearranged the loop logic.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r381035443", "createdAt": "2020-02-19T01:45:44Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n+      throw new IllegalPathException(path);\n+    }\n     MNode cur = root;\n-    int i = 0;\n-    while (i < nodeNames.length - 1) {\n-      String nodeName = nodeNames[i];\n-      if (cur.getName().equals(nodeName)) {\n-        i++;\n-        nodeName = nodeNames[i];\n-        if (cur.hasChild(nodeName)) {\n-          cur = cur.getChild(nodeName);\n-        } else {\n-          return false;\n-        }\n-      } else {\n-        return false;\n+    for (int i = 1; i < nodeNames.length; i++) {\n+      if (!cur.hasChildWithKey(nodeNames[i])) {\n+        cur.addChild(nodeNames[i], new InternalMNode(nodeNames[i], cur));\n       }\n+      cur = cur.getChild(nodeNames[i]);\n     }\n-    return cur.getName().equals(nodeNames[i]);\n+    return cur;\n+  }\n+\n+  /**\n+   * Check whether the given path exists\n+   *\n+   * @param path not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   */\n+  boolean isPathExist(String path) {\n+    return isPathExist(dummyNode, path);\n   }\n \n   /**\n-   * function for checking whether the given path exists under the given mNode.\n+   * Check whether the given path exists under the given MNode\n    */\n-  boolean isPathExist(MNode node, String path) {\n-    String[] nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n-    if (nodeNames.length < 1) {\n-      return true;\n-    }\n-    if (!node.hasChild(nodeNames[0])) {\n-      return false;\n+  private boolean isPathExist(MNode node, String path) {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    MNode cur;\n+    if (node.equals(dummyNode)) {\n+      cur = root;\n+    } else {\n+      cur = node.getChild(nodeNames[0]);\n+      if (!node.hasChildWithKey(nodeNames[0])) {\n+        return false;\n+      }\n     }\n-    MNode cur = node.getChild(nodeNames[0]);\n-\n     int i = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1MDkyMQ=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTMyMTU5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOTozMDowOFrOFq7BWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMjo0NToxMVrOFrA9jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1MTUxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              abstract public boolean hasChildWithKey(String key);\n          \n          \n            \n              abstract public boolean hasChild(String childName);", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380551514", "createdAt": "2020-02-18T09:30:08Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;\n+\n+  /**\n+   * Column's Schema for one timeseries represented by current node if current node is one leaf\n+   */\n+  MeasurementSchema schema;\n+\n+  Map<String, MNode> children;\n+\n+  MNodeType nodeType;\n+\n+  /**\n+   * when the data in a storage group is older than dataTTL, it is considered invalid and will be\n+   * eventually removed. only set at storage group level.\n+   */\n+  private long dataTTL = Long.MAX_VALUE;\n+\n+  /**\n+   * Constructor of MNode.\n+   */\n+  public MNode(String name, MNode parent) {\n+    this.setName(name);\n+    this.parent = parent;\n+  }\n+\n+  abstract public boolean isNodeType(MNodeType nodeType);\n+\n+  /**\n+   * Set storage group\n+   */\n+  public void setStorageGroup() {\n+    nodeType = MNodeType.STORAGE_GROUP_MNODE;\n+    schemaMap = new HashMap<>();\n+  }\n+\n+  public Map<String, MeasurementSchema> getSchemaMap() {\n+    return schemaMap;\n+  }\n+\n+  /**\n+   * check whether the MNode has children\n+   */\n+  abstract public boolean hasChildren();\n+\n+  /**\n+   * check whether the MNode has child with the given key\n+   *\n+   * @param key key\n+   */\n+  abstract public boolean hasChildWithKey(String key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY0ODg0NA==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380648844", "createdAt": "2020-02-18T12:45:11Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public abstract class MNode implements Serializable {\n+\n+  private static final long serialVersionUID = -770028375899514063L;\n+\n+  /**\n+   * Name of the MNode\n+   */\n+  private String name;\n+\n+  /**\n+   * Map for the schema in this storage group\n+   */\n+  private Map<String, MeasurementSchema> schemaMap;\n+\n+  /**\n+   * Corresponding storage group name for current node\n+   */\n+  private String storageGroupName;\n+\n+  private MNode parent;\n+\n+  private String fullPath;\n+\n+  /**\n+   * Column's Schema for one timeseries represented by current node if current node is one leaf\n+   */\n+  MeasurementSchema schema;\n+\n+  Map<String, MNode> children;\n+\n+  MNodeType nodeType;\n+\n+  /**\n+   * when the data in a storage group is older than dataTTL, it is considered invalid and will be\n+   * eventually removed. only set at storage group level.\n+   */\n+  private long dataTTL = Long.MAX_VALUE;\n+\n+  /**\n+   * Constructor of MNode.\n+   */\n+  public MNode(String name, MNode parent) {\n+    this.setName(name);\n+    this.parent = parent;\n+  }\n+\n+  abstract public boolean isNodeType(MNodeType nodeType);\n+\n+  /**\n+   * Set storage group\n+   */\n+  public void setStorageGroup() {\n+    nodeType = MNodeType.STORAGE_GROUP_MNODE;\n+    schemaMap = new HashMap<>();\n+  }\n+\n+  public Map<String, MeasurementSchema> getSchemaMap() {\n+    return schemaMap;\n+  }\n+\n+  /**\n+   * check whether the MNode has children\n+   */\n+  abstract public boolean hasChildren();\n+\n+  /**\n+   * check whether the MNode has child with the given key\n+   *\n+   * @param key key\n+   */\n+  abstract public boolean hasChildWithKey(String key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1MTUxNA=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTMzMjUyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOTozMjo1OFrOFq7H5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMTo0NDo1NlrOFrYi1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1MzE4OA==", "bodyText": "if we start from root and check if nodeName[0] is root, then, we do not need this check in this while", "url": "https://github.com/apache/iotdb/pull/793#discussion_r380553188", "createdAt": "2020-02-18T09:32:58Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n+      throw new IllegalPathException(path);\n+    }\n     MNode cur = root;\n-    int i = 0;\n-    while (i < nodeNames.length - 1) {\n-      String nodeName = nodeNames[i];\n-      if (cur.getName().equals(nodeName)) {\n-        i++;\n-        nodeName = nodeNames[i];\n-        if (cur.hasChild(nodeName)) {\n-          cur = cur.getChild(nodeName);\n-        } else {\n-          return false;\n-        }\n-      } else {\n-        return false;\n+    for (int i = 1; i < nodeNames.length; i++) {\n+      if (!cur.hasChildWithKey(nodeNames[i])) {\n+        cur.addChild(nodeNames[i], new InternalMNode(nodeNames[i], cur));\n       }\n+      cur = cur.getChild(nodeNames[i]);\n     }\n-    return cur.getName().equals(nodeNames[i]);\n+    return cur;\n+  }\n+\n+  /**\n+   * Check whether the given path exists\n+   *\n+   * @param path not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   */\n+  boolean isPathExist(String path) {\n+    return isPathExist(dummyNode, path);\n   }\n \n   /**\n-   * function for checking whether the given path exists under the given mNode.\n+   * Check whether the given path exists under the given MNode\n    */\n-  boolean isPathExist(MNode node, String path) {\n-    String[] nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n-    if (nodeNames.length < 1) {\n-      return true;\n-    }\n-    if (!node.hasChild(nodeNames[0])) {\n-      return false;\n+  private boolean isPathExist(MNode node, String path) {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    MNode cur;\n+    if (node.equals(dummyNode)) {\n+      cur = root;\n+    } else {\n+      cur = node.getChild(nodeNames[0]);\n+      if (!node.hasChildWithKey(nodeNames[0])) {\n+        return false;\n+      }\n     }\n-    MNode cur = node.getChild(nodeNames[0]);\n-\n     int i = 0;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n       if (cur.getName().equals(nodeName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzNTIyMw==", "bodyText": "Removed.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r381035223", "createdAt": "2020-02-19T01:44:56Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MTree.java", "diffHunk": "@@ -50,131 +56,111 @@\n public class MTree implements Serializable {\n \n   private static final long serialVersionUID = -4200394435237291964L;\n-  private static final String PATH_SEPARATOR = \"\\\\.\";\n-  private static final String NO_CHILD_ERROR = \"Node [%s] doesn't have child named: [%s]\";\n-  private static final String NOT_LEAF_NODE = \"is NOT the leaf node\";\n   private MNode root;\n-\n-  MTree(String rootName) {\n-    this.root = new MNode(rootName, null, false);\n-  }\n-\n   /**\n-   * function for adding timeseries.It should check whether seriesPath exists.\n+   * dummy node is used for the default param of traverse methods\n    */\n-  void addTimeseriesPath(String timeseriesPath, TSDataType dataType, TSEncoding encoding,\n-      CompressionType compressor, Map<String, String> props) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(timeseriesPath, PATH_SEPARATOR);\n-    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", timeseriesPath);\n-    }\n-    MNode cur = findLeafParent(nodeNames);\n-    String levelPath = cur.getDataFileName();\n+  private MNode dummyNode;\n \n-    MNode leaf = new MNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding, compressor);\n-    if (props != null && !props.isEmpty()) {\n-      leaf.getSchema().setProps(props);\n-    }\n-    leaf.setDataFileName(levelPath);\n-    if (cur.isLeaf()) {\n-      throw new MTreePathException(timeseriesPath, \"can't be created\",\n-          String.format(\"node [%s] is left node\", cur.getName()));\n-    }\n-    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n+  MTree(String rootName) {\n+    this.root = new InternalMNode(rootName, null);\n+    this.dummyNode = new InternalMNode(\"dummy\", null);\n   }\n \n   /**\n-   * function for adding deviceId\n-   */\n-  MNode addDeviceId(String deviceId) throws PathException {\n-    String[] nodeNames = MetaUtils.getNodeNames(deviceId, PATH_SEPARATOR);\n+   * Add path\n+   *\n+   * @param path timeseries path\n+   * @param dataType data type\n+   * @param encoding encoding\n+   * @param compressor compressor\n+   * @param props props\n+   */\n+  void addPath(String path, TSDataType dataType, TSEncoding encoding,\n+      CompressionType compressor, Map<String, String> props) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n     if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n-      throw new MTreePathException(\"Timeseries\", deviceId);\n-    }\n-    MNode cur = getRoot();\n-    for (int i = 1; i < nodeNames.length; i++) {\n-      if (!cur.hasChild(nodeNames[i])) {\n-        cur.addChild(nodeNames[i], new MNode(nodeNames[i], cur, false));\n-      }\n-      cur = cur.getChild(nodeNames[i]);\n+      throw new IllegalPathException(path);\n     }\n-    return cur;\n-  }\n-\n-  private MNode findLeafParent(String[] nodeNames) throws PathException {\n     MNode cur = root;\n-    String levelPath = null;\n+    String storageGroupName = null;\n     int i = 1;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n-      if (cur.isStorageGroup()) {\n-        levelPath = cur.getDataFileName();\n+      if (cur.isNodeType(MNodeType.STORAGE_GROUP_MNODE)) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n-      if (!cur.hasChild(nodeName)) {\n-        if (cur.isLeaf()) {\n-          throw new MTreePathException(String.join(\",\", nodeNames), \"can't be created\",\n-              String.format(\"node [%s] is left node\", cur.getName()));\n+      if (!cur.hasChildWithKey(nodeName)) {\n+        if (cur.isNodeType(MNodeType.LEAF_MNODE)) {\n+          throw new PathAlreadyExistException(cur.getFullPath());\n         }\n-        cur.addChild(nodeName, new MNode(nodeName, cur, false));\n+        cur.addChild(nodeName, new InternalMNode(nodeName, cur));\n       }\n-      cur.setDataFileName(levelPath);\n+      cur.setStorageGroupName(storageGroupName);\n       cur = cur.getChild(nodeName);\n-      if (levelPath == null) {\n-        levelPath = cur.getDataFileName();\n+      if (storageGroupName == null) {\n+        storageGroupName = cur.getStorageGroupName();\n       }\n       i++;\n     }\n-    cur.setDataFileName(levelPath);\n-    return cur;\n+    cur.setStorageGroupName(storageGroupName);\n+    MNode leaf = new LeafMNode(nodeNames[nodeNames.length - 1], cur, dataType, encoding,\n+        compressor);\n+    leaf.getSchema().setProps(props);\n+    leaf.setStorageGroupName(cur.getStorageGroupName());\n+    cur.addChild(nodeNames[nodeNames.length - 1], leaf);\n   }\n \n-\n   /**\n-   * function for checking whether the given path exists.\n+   * Add path to MTree. This is available IF and ONLY IF creating schema automatically is enabled\n    *\n-   * @param path -seriesPath not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   * @param path device id\n    */\n-  boolean isPathExist(String path) {\n-    String[] nodeNames = nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n+  MNode addPath(String path) throws MetadataException {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    if (nodeNames.length <= 1 || !nodeNames[0].equals(root.getName())) {\n+      throw new IllegalPathException(path);\n+    }\n     MNode cur = root;\n-    int i = 0;\n-    while (i < nodeNames.length - 1) {\n-      String nodeName = nodeNames[i];\n-      if (cur.getName().equals(nodeName)) {\n-        i++;\n-        nodeName = nodeNames[i];\n-        if (cur.hasChild(nodeName)) {\n-          cur = cur.getChild(nodeName);\n-        } else {\n-          return false;\n-        }\n-      } else {\n-        return false;\n+    for (int i = 1; i < nodeNames.length; i++) {\n+      if (!cur.hasChildWithKey(nodeNames[i])) {\n+        cur.addChild(nodeNames[i], new InternalMNode(nodeNames[i], cur));\n       }\n+      cur = cur.getChild(nodeNames[i]);\n     }\n-    return cur.getName().equals(nodeNames[i]);\n+    return cur;\n+  }\n+\n+  /**\n+   * Check whether the given path exists\n+   *\n+   * @param path not necessarily the whole seriesPath (possibly a prefix of a sequence)\n+   */\n+  boolean isPathExist(String path) {\n+    return isPathExist(dummyNode, path);\n   }\n \n   /**\n-   * function for checking whether the given path exists under the given mNode.\n+   * Check whether the given path exists under the given MNode\n    */\n-  boolean isPathExist(MNode node, String path) {\n-    String[] nodeNames = MetaUtils.getNodeNames(path, PATH_SEPARATOR);\n-    if (nodeNames.length < 1) {\n-      return true;\n-    }\n-    if (!node.hasChild(nodeNames[0])) {\n-      return false;\n+  private boolean isPathExist(MNode node, String path) {\n+    String[] nodeNames = MetaUtils.getNodeNames(path);\n+    MNode cur;\n+    if (node.equals(dummyNode)) {\n+      cur = root;\n+    } else {\n+      cur = node.getChild(nodeNames[0]);\n+      if (!node.hasChildWithKey(nodeNames[0])) {\n+        return false;\n+      }\n     }\n-    MNode cur = node.getChild(nodeNames[0]);\n-\n     int i = 0;\n     while (i < nodeNames.length - 1) {\n       String nodeName = nodeNames[i];\n       if (cur.getName().equals(nodeName)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1MzE4OA=="}, "originalCommit": {"oid": "00a4cadcc9957c8226ae6e45931d3575d62d6884"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODc5MTYzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwNjoyMjo1NVrOFrcTeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwOTo0NzowMlrOFrha6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5NjgyNg==", "bodyText": "If InternalMNode and StorageGroupMNode all return true, then this function is not needed. We could use instance of LeafMNode to check this", "url": "https://github.com/apache/iotdb/pull/793#discussion_r381096826", "createdAt": "2020-02-19T06:22:55Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public class InternalMNode extends MNode {\n+\n+  private static final long serialVersionUID = 7999036474525817732L;\n+\n+  private Map<String, MNode> children;\n+\n+  public InternalMNode(String name, MNode parent) {\n+    super(name, parent);\n+    this.children = new LinkedHashMap<>();\n+  }\n+\n+  /**\n+   * check whether the MNode has children\n+   */\n+  @Override\n+  public boolean hasChildren() {\n+    return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91aeabe1669987fc7b5642c70786b74eb71e8528"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE4MDY1MA==", "bodyText": "Removed.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r381180650", "createdAt": "2020-02-19T09:47:02Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public class InternalMNode extends MNode {\n+\n+  private static final long serialVersionUID = 7999036474525817732L;\n+\n+  private Map<String, MNode> children;\n+\n+  public InternalMNode(String name, MNode parent) {\n+    super(name, parent);\n+    this.children = new LinkedHashMap<>();\n+  }\n+\n+  /**\n+   * check whether the MNode has children\n+   */\n+  @Override\n+  public boolean hasChildren() {\n+    return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5NjgyNg=="}, "originalCommit": {"oid": "91aeabe1669987fc7b5642c70786b74eb71e8528"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODc5MjQzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/StorageGroupMNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwNjoyMzoyMlrOFrcT8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwOTo0MDoxN1rOFrhKTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5Njk0NA==", "bodyText": "why we need a serialVersionUID?", "url": "https://github.com/apache/iotdb/pull/793#discussion_r381096944", "createdAt": "2020-02-19T06:23:22Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/StorageGroupMNode.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public class StorageGroupMNode extends InternalMNode {\n+\n+  private static final long serialVersionUID = 7999036474525817732L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91aeabe1669987fc7b5642c70786b74eb71e8528"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE3NjM5OQ==", "bodyText": "Because MNode implements Serializable interface and without a serialVersionUID field, any change to a class will make previously serialized versions unreadable.", "url": "https://github.com/apache/iotdb/pull/793#discussion_r381176399", "createdAt": "2020-02-19T09:40:17Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/StorageGroupMNode.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.metadata.mnode;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+/**\n+ * This class is the implementation of Metadata Node. One MNode instance represents one node in the\n+ * Metadata Tree\n+ */\n+public class StorageGroupMNode extends InternalMNode {\n+\n+  private static final long serialVersionUID = 7999036474525817732L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5Njk0NA=="}, "originalCommit": {"oid": "91aeabe1669987fc7b5642c70786b74eb71e8528"}, "originalPosition": 31}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 403, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}