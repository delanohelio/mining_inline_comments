{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyMjc2NjE3", "number": 934, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODoxNDo1MVrODqrryQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODoyMTozMlrODqr0aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDgyNTA1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODoxNDo1MVrOF6k_GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwOToyMToyNlrOF6nU1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2NzcwNA==", "bodyText": "Actually I think it's better to use String here so that you won't use getFullPath() when call this method ... What do you think?", "url": "https://github.com/apache/iotdb/pull/934#discussion_r396967704", "createdAt": "2020-03-24T08:14:51Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -548,13 +548,13 @@ public TSDataType getSeriesType(String path) throws MetadataException {\n \n \n   /**\n-   * Get all devices under given prefixPath.\n+   * Get all device nodes under given prefixPath.\n    *\n    * @param prefixPath a prefix of a full path. if the wildcard is not at the tail, then each\n    * wildcard can only match one level, otherwise it can match to the tail.\n-   * @return A HashSet instance which stores devices names with given prefixPath.\n+   * @return A list which stores device nodes with given prefixPath.\n    */\n-  public Set<String> getDevices(String prefixPath) throws MetadataException {\n+  public List<MNode> getDevices(String prefixPath) throws MetadataException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf1cfb9efb26cb81288fde31dfc6cf07d5f72d1"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk4NTM5Ng==", "bodyText": "If using String here, we have to find the node again by path string in AlignByDeviceDataSet. So storaging MNode directly here can reduce that process.", "url": "https://github.com/apache/iotdb/pull/934#discussion_r396985396", "createdAt": "2020-03-24T08:47:40Z", "author": {"login": "Alima777"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -548,13 +548,13 @@ public TSDataType getSeriesType(String path) throws MetadataException {\n \n \n   /**\n-   * Get all devices under given prefixPath.\n+   * Get all device nodes under given prefixPath.\n    *\n    * @param prefixPath a prefix of a full path. if the wildcard is not at the tail, then each\n    * wildcard can only match one level, otherwise it can match to the tail.\n-   * @return A HashSet instance which stores devices names with given prefixPath.\n+   * @return A list which stores device nodes with given prefixPath.\n    */\n-  public Set<String> getDevices(String prefixPath) throws MetadataException {\n+  public List<MNode> getDevices(String prefixPath) throws MetadataException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2NzcwNA=="}, "originalCommit": {"oid": "0cf1cfb9efb26cb81288fde31dfc6cf07d5f72d1"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk4OTk3MQ==", "bodyText": "Sure. I didn't figure out a better way either... Maybe we could keep this then : )", "url": "https://github.com/apache/iotdb/pull/934#discussion_r396989971", "createdAt": "2020-03-24T08:55:21Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -548,13 +548,13 @@ public TSDataType getSeriesType(String path) throws MetadataException {\n \n \n   /**\n-   * Get all devices under given prefixPath.\n+   * Get all device nodes under given prefixPath.\n    *\n    * @param prefixPath a prefix of a full path. if the wildcard is not at the tail, then each\n    * wildcard can only match one level, otherwise it can match to the tail.\n-   * @return A HashSet instance which stores devices names with given prefixPath.\n+   * @return A list which stores device nodes with given prefixPath.\n    */\n-  public Set<String> getDevices(String prefixPath) throws MetadataException {\n+  public List<MNode> getDevices(String prefixPath) throws MetadataException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2NzcwNA=="}, "originalCommit": {"oid": "0cf1cfb9efb26cb81288fde31dfc6cf07d5f72d1"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzAwNjAzOA==", "bodyText": "Actually It doesn't cost that much time finding device node. Like what you said, to keep the consistence with other methods, I deciced to change it to return List.", "url": "https://github.com/apache/iotdb/pull/934#discussion_r397006038", "createdAt": "2020-03-24T09:21:26Z", "author": {"login": "Alima777"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -548,13 +548,13 @@ public TSDataType getSeriesType(String path) throws MetadataException {\n \n \n   /**\n-   * Get all devices under given prefixPath.\n+   * Get all device nodes under given prefixPath.\n    *\n    * @param prefixPath a prefix of a full path. if the wildcard is not at the tail, then each\n    * wildcard can only match one level, otherwise it can match to the tail.\n-   * @return A HashSet instance which stores devices names with given prefixPath.\n+   * @return A list which stores device nodes with given prefixPath.\n    */\n-  public Set<String> getDevices(String prefixPath) throws MetadataException {\n+  public List<MNode> getDevices(String prefixPath) throws MetadataException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2NzcwNA=="}, "originalCommit": {"oid": "0cf1cfb9efb26cb81288fde31dfc6cf07d5f72d1"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDgzNDkyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/AlignByDeviceDataSet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODoxNzo1MFrOF6lFSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODo0OTozOFrOF6mIzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2OTI5MQ==", "bodyText": "Remove some useless imports", "url": "https://github.com/apache/iotdb/pull/934#discussion_r396969291", "createdAt": "2020-03-24T08:17:50Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/AlignByDeviceDataSet.java", "diffHunk": "@@ -21,12 +21,16 @@\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf1cfb9efb26cb81288fde31dfc6cf07d5f72d1"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk4NjU3NQ==", "bodyText": "Fixed.", "url": "https://github.com/apache/iotdb/pull/934#discussion_r396986575", "createdAt": "2020-03-24T08:49:38Z", "author": {"login": "Alima777"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/AlignByDeviceDataSet.java", "diffHunk": "@@ -21,12 +21,16 @@\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2OTI5MQ=="}, "originalCommit": {"oid": "0cf1cfb9efb26cb81288fde31dfc6cf07d5f72d1"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDg0NzE1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/AlignByDeviceDataSet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODoyMTozMlrOF6lM8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODo1MToxNFrOF6mMgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk3MTI1MA==", "bodyText": "try to extract the same process to avoid duplicated codes:\nString measurement = column;\n        if (dataSetType == DataSetType.GROUPBY || dataSetType == DataSetType.AGGREGATE) {\n          measurement = column.substring(column.indexOf('(') + 1, column.indexOf(')'));\n          if (measurementOfGivenDevice.contains(measurement)) {\n            executeAggregations.add(column.substring(0, column.indexOf('(')));\n          }\n        }\n        if (measurementOfGivenDevice.contains(measurement)) {\n          executeColumns.add(measurement);\n          executePaths.add(new Path(currentDevice.getFullPath(), measurement));\n          tsDataTypes.add(measurementDataTpeMap.get(measurement));\n        }\n\n(please first ensure codes above work : ) )", "url": "https://github.com/apache/iotdb/pull/934#discussion_r396971250", "createdAt": "2020-03-24T08:21:32Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/AlignByDeviceDataSet.java", "diffHunk": "@@ -116,25 +119,29 @@ protected boolean hasNextWithoutConstraint() throws IOException {\n \n     while (deviceIterator.hasNext()) {\n       currentDevice = deviceIterator.next();\n-      Set<String> measurementColumnsOfGivenDevice = deviceToMeasurementsMap\n-          .get(currentDevice);\n-      executeColumns = new ArrayList<>(measurementColumnsOfGivenDevice);\n-\n-      // extract paths and aggregations if exist from executeColumns\n+      // get all measurements of current device\n+      Set<String> measurementOfGivenDevice = currentDevice.getChildren().keySet();\n+      // extract paths and aggregations queried from all measurements\n+      // executeColumns is for calculating rowRecord\n+      executeColumns = new ArrayList<>();\n       List<Path> executePaths = new ArrayList<>();\n       List<TSDataType> tsDataTypes = new ArrayList<>();\n       List<String> executeAggregations = new ArrayList<>();\n-      for (String column : executeColumns) {\n+      for (String column : measurementDataTpeMap.keySet()) {\n         if (dataSetType == DataSetType.GROUPBY || dataSetType == DataSetType.AGGREGATE) {\n-          Path path = new Path(currentDevice,\n-              column.substring(column.indexOf('(') + 1, column.indexOf(')')));\n-          tsDataTypes.add(tsDataTypeMap.get(path));\n-          executePaths.add(path);\n-          executeAggregations.add(column.substring(0, column.indexOf('(')));\n+          String measurement = column.substring(column.indexOf('(') + 1, column.indexOf(')'));\n+          if (measurementOfGivenDevice.contains(measurement)){\n+            executeColumns.add(column);\n+            executePaths.add(new Path(currentDevice.getFullPath(), measurement));\n+            tsDataTypes.add(measurementDataTpeMap.get(column));\n+            executeAggregations.add(column.substring(0, column.indexOf('(')));\n+          }\n         } else {\n-          Path path = new Path(currentDevice, column);\n-          tsDataTypes.add(tsDataTypeMap.get(path));\n-          executePaths.add(path);\n+          if (measurementOfGivenDevice.contains(column)) {\n+            executeColumns.add(column);\n+            executePaths.add(new Path(currentDevice.getFullPath(), column));\n+            tsDataTypes.add(measurementDataTpeMap.get(column));\n+          }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf1cfb9efb26cb81288fde31dfc6cf07d5f72d1"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk4NzUyMA==", "bodyText": "Thank you! It's very helpful for me.", "url": "https://github.com/apache/iotdb/pull/934#discussion_r396987520", "createdAt": "2020-03-24T08:51:14Z", "author": {"login": "Alima777"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/AlignByDeviceDataSet.java", "diffHunk": "@@ -116,25 +119,29 @@ protected boolean hasNextWithoutConstraint() throws IOException {\n \n     while (deviceIterator.hasNext()) {\n       currentDevice = deviceIterator.next();\n-      Set<String> measurementColumnsOfGivenDevice = deviceToMeasurementsMap\n-          .get(currentDevice);\n-      executeColumns = new ArrayList<>(measurementColumnsOfGivenDevice);\n-\n-      // extract paths and aggregations if exist from executeColumns\n+      // get all measurements of current device\n+      Set<String> measurementOfGivenDevice = currentDevice.getChildren().keySet();\n+      // extract paths and aggregations queried from all measurements\n+      // executeColumns is for calculating rowRecord\n+      executeColumns = new ArrayList<>();\n       List<Path> executePaths = new ArrayList<>();\n       List<TSDataType> tsDataTypes = new ArrayList<>();\n       List<String> executeAggregations = new ArrayList<>();\n-      for (String column : executeColumns) {\n+      for (String column : measurementDataTpeMap.keySet()) {\n         if (dataSetType == DataSetType.GROUPBY || dataSetType == DataSetType.AGGREGATE) {\n-          Path path = new Path(currentDevice,\n-              column.substring(column.indexOf('(') + 1, column.indexOf(')')));\n-          tsDataTypes.add(tsDataTypeMap.get(path));\n-          executePaths.add(path);\n-          executeAggregations.add(column.substring(0, column.indexOf('(')));\n+          String measurement = column.substring(column.indexOf('(') + 1, column.indexOf(')'));\n+          if (measurementOfGivenDevice.contains(measurement)){\n+            executeColumns.add(column);\n+            executePaths.add(new Path(currentDevice.getFullPath(), measurement));\n+            tsDataTypes.add(measurementDataTpeMap.get(column));\n+            executeAggregations.add(column.substring(0, column.indexOf('(')));\n+          }\n         } else {\n-          Path path = new Path(currentDevice, column);\n-          tsDataTypes.add(tsDataTypeMap.get(path));\n-          executePaths.add(path);\n+          if (measurementOfGivenDevice.contains(column)) {\n+            executeColumns.add(column);\n+            executePaths.add(new Path(currentDevice.getFullPath(), column));\n+            tsDataTypes.add(measurementDataTpeMap.get(column));\n+          }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk3MTI1MA=="}, "originalCommit": {"oid": "0cf1cfb9efb26cb81288fde31dfc6cf07d5f72d1"}, "originalPosition": 106}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 150, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}