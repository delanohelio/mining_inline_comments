{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4NTE4MzQ2", "number": 1411, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMzowNzo1NlrOEL6QOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTo0MjozNFrOEOm9Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwOTI0MjE2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/writelog/recover/TsFileRecoverPerformer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMzowNzo1NlrOGtto5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMjowNToyMFrOGuVh6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4Njg1NQ==", "bodyText": "Update the comment according to new return type", "url": "https://github.com/apache/iotdb/pull/1411#discussion_r450586855", "createdAt": "2020-07-07T03:07:56Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/writelog/recover/TsFileRecoverPerformer.java", "diffHunk": "@@ -80,17 +104,33 @@ public TsFileRecoverPerformer(String logNodePrefix, VersionController versionCon\n    * @return a RestorableTsFileIOWriter if the file is not closed before crush, so this writer can", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c038c03ac86f60dfb3fe6f01b629f24621d4ef3e"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MDQyNg==", "bodyText": "fixed~", "url": "https://github.com/apache/iotdb/pull/1411#discussion_r451240426", "createdAt": "2020-07-08T02:05:20Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/writelog/recover/TsFileRecoverPerformer.java", "diffHunk": "@@ -80,17 +104,33 @@ public TsFileRecoverPerformer(String logNodePrefix, VersionController versionCon\n    * @return a RestorableTsFileIOWriter if the file is not closed before crush, so this writer can", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4Njg1NQ=="}, "originalCommit": {"oid": "c038c03ac86f60dfb3fe6f01b629f24621d4ef3e"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwOTUyMzIxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNjowNzowOFrOGtwSXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMjowNTozMlrOGuViJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYzMDIzNg==", "bodyText": "Will this unused method be used later?", "url": "https://github.com/apache/iotdb/pull/1411#discussion_r450630236", "createdAt": "2020-07-07T06:07:08Z", "author": {"login": "samperson1997"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "diffHunk": "@@ -540,6 +574,80 @@ private void releaseFlushedMemTable(IMemTable memTable) {\n     }\n   }\n \n+  /**\n+   * Construct the a new or get an existing TsFileSequenceReader of a TsFile.\n+   *\n+   * @return a TsFileSequenceReader\n+   */\n+  private TsFileSequenceReader getFileReader(TsFileResource tsFileResource) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b59aad15db90e8418e7d46d2601405d0d6b82fce"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MDQ4NA==", "bodyText": "fixed", "url": "https://github.com/apache/iotdb/pull/1411#discussion_r451240484", "createdAt": "2020-07-08T02:05:32Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "diffHunk": "@@ -540,6 +574,80 @@ private void releaseFlushedMemTable(IMemTable memTable) {\n     }\n   }\n \n+  /**\n+   * Construct the a new or get an existing TsFileSequenceReader of a TsFile.\n+   *\n+   * @return a TsFileSequenceReader\n+   */\n+  private TsFileSequenceReader getFileReader(TsFileResource tsFileResource) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYzMDIzNg=="}, "originalCommit": {"oid": "b59aad15db90e8418e7d46d2601405d0d6b82fce"}, "originalPosition": 209}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzUzMzM5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/flush/VmMergeUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTo0MToyOVrOGx2cQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTo0MToyOVrOGx2cQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyNTM3Nw==", "bodyText": "This method has a lot of duplicate lines and looks too complicated, it's better to do a refactor or split it to some small methods.", "url": "https://github.com/apache/iotdb/pull/1411#discussion_r454925377", "createdAt": "2020-07-15T09:41:29Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/flush/VmMergeUtils.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.flush;\n+\n+import static org.apache.iotdb.db.utils.MergeUtils.writeTVPair;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetadata;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Chunk;\n+import org.apache.iotdb.tsfile.read.reader.BatchDataIterator;\n+import org.apache.iotdb.tsfile.read.reader.IChunkReader;\n+import org.apache.iotdb.tsfile.read.reader.IPointReader;\n+import org.apache.iotdb.tsfile.read.reader.chunk.ChunkReaderByTimestamp;\n+import org.apache.iotdb.tsfile.utils.Pair;\n+import org.apache.iotdb.tsfile.write.chunk.ChunkWriterImpl;\n+import org.apache.iotdb.tsfile.write.chunk.IChunkWriter;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.iotdb.tsfile.write.writer.RestorableTsFileIOWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class VmMergeUtils {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(VmMergeUtils.class);\n+\n+  private VmMergeUtils() {\n+    throw new IllegalStateException(\"Utility class\");\n+  }\n+\n+  public static void fullMerge(RestorableTsFileIOWriter writer,\n+      List<List<RestorableTsFileIOWriter>> vmWriters, String storageGroup, VmLogger vmLogger,\n+      Set<String> devices, boolean sequence) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92546c40f40b26ff5532c1cbaf50cbd4a93ad041"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzUzNzMxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/flush/VmMergeUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTo0MjozNFrOGx2eug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTo0MjozNFrOGx2eug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyNjAxMA==", "bodyText": "Same as fullMerge", "url": "https://github.com/apache/iotdb/pull/1411#discussion_r454926010", "createdAt": "2020-07-15T09:42:34Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/flush/VmMergeUtils.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.flush;\n+\n+import static org.apache.iotdb.db.utils.MergeUtils.writeTVPair;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetadata;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Chunk;\n+import org.apache.iotdb.tsfile.read.reader.BatchDataIterator;\n+import org.apache.iotdb.tsfile.read.reader.IChunkReader;\n+import org.apache.iotdb.tsfile.read.reader.IPointReader;\n+import org.apache.iotdb.tsfile.read.reader.chunk.ChunkReaderByTimestamp;\n+import org.apache.iotdb.tsfile.utils.Pair;\n+import org.apache.iotdb.tsfile.write.chunk.ChunkWriterImpl;\n+import org.apache.iotdb.tsfile.write.chunk.IChunkWriter;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.iotdb.tsfile.write.writer.RestorableTsFileIOWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class VmMergeUtils {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(VmMergeUtils.class);\n+\n+  private VmMergeUtils() {\n+    throw new IllegalStateException(\"Utility class\");\n+  }\n+\n+  public static void fullMerge(RestorableTsFileIOWriter writer,\n+      List<List<RestorableTsFileIOWriter>> vmWriters, String storageGroup, VmLogger vmLogger,\n+      Set<String> devices, boolean sequence) throws IOException {\n+    Map<String, TsFileSequenceReader> tsFileSequenceReaderMap = new HashMap<>();\n+    Map<String, Map<String, MeasurementSchema>> deviceMeasurementMap = new HashMap<>();\n+\n+    for (List<RestorableTsFileIOWriter> subVmWriters : vmWriters) {\n+      fillDeviceMeasurementMap(devices, deviceMeasurementMap, subVmWriters);\n+    }\n+    if (!sequence) {\n+      for (Entry<String, Map<String, MeasurementSchema>> deviceMeasurementEntry : deviceMeasurementMap\n+          .entrySet()) {\n+        String deviceId = deviceMeasurementEntry.getKey();\n+        writer.startChunkGroup(deviceId);\n+        long maxVersion = Long.MIN_VALUE;\n+        for (Entry<String, MeasurementSchema> entry : deviceMeasurementEntry.getValue()\n+            .entrySet()) {\n+          String measurementId = entry.getKey();\n+          Map<Long, TimeValuePair> timeValuePairMap = new TreeMap<>();\n+          for (int i = vmWriters.size() - 1; i >= 0; i--) {\n+            maxVersion = writeUnseqChunk(writer, storageGroup, tsFileSequenceReaderMap, deviceId,\n+                maxVersion, entry,\n+                measurementId, timeValuePairMap, vmWriters.get(i));\n+          }\n+          IChunkWriter chunkWriter = new ChunkWriterImpl(entry.getValue());\n+          for (TimeValuePair timeValuePair : timeValuePairMap.values()) {\n+            writeTVPair(timeValuePair, chunkWriter);\n+          }\n+          chunkWriter.writeToFileWriter(writer);\n+        }\n+        writer.writeVersion(maxVersion);\n+        writer.endChunkGroup();\n+        if (vmLogger != null) {\n+          vmLogger.logDevice(deviceId, writer.getPos());\n+        }\n+      }\n+    } else {\n+      for (Entry<String, Map<String, MeasurementSchema>> deviceMeasurementEntry : deviceMeasurementMap\n+          .entrySet()) {\n+        String deviceId = deviceMeasurementEntry.getKey();\n+        writer.startChunkGroup(deviceId);\n+        for (Entry<String, MeasurementSchema> entry : deviceMeasurementEntry.getValue()\n+            .entrySet()) {\n+          String measurementId = entry.getKey();\n+          ChunkMetadata newChunkMetadata = null;\n+          Chunk newChunk = null;\n+          for (int i = vmWriters.size() - 1; i >= 0; i--) {\n+            Pair<ChunkMetadata, Chunk> chunkPair = writeSeqChunk(writer, storageGroup,\n+                tsFileSequenceReaderMap, deviceId, measurementId,\n+                vmWriters.get(i), newChunkMetadata, newChunk);\n+            newChunkMetadata = chunkPair.left;\n+            newChunk = chunkPair.right;\n+          }\n+          if (newChunkMetadata != null && newChunk != null) {\n+            writer.writeChunk(newChunk, newChunkMetadata);\n+          }\n+        }\n+        writer.endChunkGroup();\n+        if (vmLogger != null) {\n+          vmLogger.logDevice(deviceId, writer.getPos());\n+        }\n+      }\n+    }\n+\n+    for (TsFileSequenceReader reader : tsFileSequenceReaderMap.values()) {\n+      reader.close();\n+      logger.info(\"{} vm file close a reader\", reader.getFileName());\n+    }\n+    if (vmLogger != null) {\n+      vmLogger.close();\n+    }\n+  }\n+\n+  private static Pair<ChunkMetadata, Chunk> writeSeqChunk(RestorableTsFileIOWriter writer,\n+      String storageGroup,\n+      Map<String, TsFileSequenceReader> tsFileSequenceReaderMap, String deviceId,\n+      String measurementId,\n+      List<RestorableTsFileIOWriter> vmWriters, ChunkMetadata lastChunkMetadata, Chunk lastChunk)\n+      throws IOException {\n+    ChunkMetadata newChunkMetadata = lastChunkMetadata;\n+    Chunk newChunk = lastChunk;\n+    for (RestorableTsFileIOWriter vmWriter : vmWriters) {\n+      TsFileSequenceReader reader = buildReaderFromVmWriter(vmWriter,\n+          writer, tsFileSequenceReaderMap, storageGroup);\n+      if (reader == null || !vmWriter.getMetadatasForQuery().containsKey(deviceId)) {\n+        continue;\n+      }\n+      List<ChunkMetadata> chunkMetadataList = vmWriter.getMetadatasForQuery()\n+          .get(deviceId).get(measurementId);\n+      if (chunkMetadataList == null) {\n+        continue;\n+      }\n+      for (ChunkMetadata chunkMetadata : chunkMetadataList) {\n+        Chunk chunk = reader.readMemChunk(chunkMetadata);\n+        if (newChunkMetadata == null) {\n+          newChunkMetadata = chunkMetadata;\n+          newChunk = chunk;\n+        } else {\n+          newChunkMetadata.mergeChunkMetadata(chunkMetadata);\n+          newChunk.mergeChunk(chunk);\n+        }\n+      }\n+    }\n+    return new Pair<>(newChunkMetadata, newChunk);\n+  }\n+\n+  private static long writeUnseqChunk(RestorableTsFileIOWriter writer, String storageGroup,\n+      Map<String, TsFileSequenceReader> tsFileSequenceReaderMap, String deviceId, long maxVersion,\n+      Entry<String, MeasurementSchema> entry, String measurementId,\n+      Map<Long, TimeValuePair> timeValuePairMap, List<RestorableTsFileIOWriter> vmWriters)\n+      throws IOException {\n+    for (RestorableTsFileIOWriter vmWriter : vmWriters) {\n+      TsFileSequenceReader reader = buildReaderFromVmWriter(vmWriter,\n+          writer, tsFileSequenceReaderMap, storageGroup);\n+      if (reader == null) {\n+        continue;\n+      }\n+      List<ChunkMetadata> chunkMetadataList = vmWriter.getVisibleMetadataList(deviceId,\n+          measurementId, entry.getValue().getType());\n+      for (ChunkMetadata chunkMetadata : chunkMetadataList) {\n+        maxVersion = Math.max(chunkMetadata.getVersion(), maxVersion);\n+        IChunkReader chunkReader = new ChunkReaderByTimestamp(\n+            reader.readMemChunk(chunkMetadata));\n+        while (chunkReader.hasNextSatisfiedPage()) {\n+          IPointReader iPointReader = new BatchDataIterator(\n+              chunkReader.nextPageData());\n+          while (iPointReader.hasNextTimeValuePair()) {\n+            TimeValuePair timeValuePair = iPointReader.nextTimeValuePair();\n+            timeValuePairMap.put(timeValuePair.getTimestamp(), timeValuePair);\n+          }\n+        }\n+      }\n+    }\n+    return maxVersion;\n+  }\n+\n+  private static void fillDeviceMeasurementMap(Set<String> devices,\n+      Map<String, Map<String, MeasurementSchema>> deviceMeasurementMap,\n+      List<RestorableTsFileIOWriter> subVmWriters) {\n+    for (RestorableTsFileIOWriter vmWriter : subVmWriters) {\n+      vmWriter.makeMetadataVisible();\n+      Map<String, Map<String, List<ChunkMetadata>>> deviceMeasurementChunkMetadataMap = vmWriter\n+          .getMetadatasForQuery();\n+      // device, measurement -> chunk metadata list\n+      for (Entry<String, Map<String, List<ChunkMetadata>>> deviceEntry :\n+          deviceMeasurementChunkMetadataMap.entrySet()) {\n+        if (devices.contains(deviceEntry.getKey())) {\n+          continue;\n+        }\n+        Map<String, MeasurementSchema> measurementSchemaMap = deviceMeasurementMap\n+            .computeIfAbsent(deviceEntry.getKey(), k -> new HashMap<>());\n+\n+        // measurement, chunk metadata list\n+        for (Entry<String, List<ChunkMetadata>> measurementEntry : deviceEntry.getValue()\n+            .entrySet()) {\n+          measurementSchemaMap.computeIfAbsent(measurementEntry.getKey(), k ->\n+              new MeasurementSchema(k, measurementEntry.getValue().get(0).getDataType()));\n+        }\n+      }\n+    }\n+  }\n+\n+  public static void levelMerge(RestorableTsFileIOWriter writer,\n+      List<RestorableTsFileIOWriter> vmWriters, String storageGroup, VmLogger vmLogger,\n+      Set<String> devices, boolean sequence) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92546c40f40b26ff5532c1cbaf50cbd4a93ad041"}, "originalPosition": 219}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4827, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}