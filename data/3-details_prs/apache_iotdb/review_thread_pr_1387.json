{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2MzMyMDEy", "number": 1387, "reviewThreads": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjoxMjoyMFrOEG9-uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwOTowNzozMFrOEJbVBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzQyMzkyOnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjoxMjoyMFrOGmF0BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjoyMjoxNlrOGnIBWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NDMwOA==", "bodyText": "This should still be debug.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442594308", "createdAt": "2020-06-19T02:12:20Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1520,12 +1534,31 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && IoTDBDescriptor.getInstance().getConfig()\n+          .isAutoCreateSchemaEnabled()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = executeNonQuery(setStorageGroupPlan);\n+          if (setStorageGroupResult.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+            throw new MetadataException(\"Failed to set storage group \" + storageGroupName);\n+          }\n+          return executeNonQuery(plan);\n+        } catch (MetadataException e) {\n+          logger.info(\"Failed to set storage group of device id {}\", deviceId);\n+        }\n+      }\n+      logger.error(\"{}: Cannot found storage groups for {}\", name, plan);\n       return StatusUtils.NO_STORAGE_GROUP;\n     }\n-    logger.debug(\"{}: The data groups of {} are {}\", name, plan, planGroupMap);\n+    logger.error(\"{}: The data groups of {} are {}\", name, plan, planGroupMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3OTA2NA==", "bodyText": "Alright, I will revert.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443679064", "createdAt": "2020-06-22T16:22:16Z", "author": {"login": "Ring-k"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1520,12 +1534,31 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && IoTDBDescriptor.getInstance().getConfig()\n+          .isAutoCreateSchemaEnabled()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = executeNonQuery(setStorageGroupPlan);\n+          if (setStorageGroupResult.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+            throw new MetadataException(\"Failed to set storage group \" + storageGroupName);\n+          }\n+          return executeNonQuery(plan);\n+        } catch (MetadataException e) {\n+          logger.info(\"Failed to set storage group of device id {}\", deviceId);\n+        }\n+      }\n+      logger.error(\"{}: Cannot found storage groups for {}\", name, plan);\n       return StatusUtils.NO_STORAGE_GROUP;\n     }\n-    logger.debug(\"{}: The data groups of {} are {}\", name, plan, planGroupMap);\n+    logger.error(\"{}: The data groups of {} are {}\", name, plan, planGroupMap);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NDMwOA=="}, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzQzNjEwOnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjoyMDo0MFrOGmF7ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNzo0NjozN1rOGoGwhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NjE5Nw==", "bodyText": "I think we should add a specific status code like \"TSStatusCode.NO_TIMESERIES\", as this one is too abstract and we are not sure whether it is because of no metadata.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442596197", "createdAt": "2020-06-19T02:20:40Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1551,6 +1584,20 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n         subStatus = forwardPlan(entry.getKey(), entry.getValue());\n       }\n       if (subStatus.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        if (entry.getKey() instanceof InsertPlan\n+            && subStatus.getCode() == TSStatusCode.STORAGE_ENGINE_ERROR.getStatusCode()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcwNjk0OA==", "bodyText": "Thanks for your suggestion. The error code TIMESERIES_NOT_EXIST will be introduced.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444706948", "createdAt": "2020-06-24T07:46:37Z", "author": {"login": "Ring-k"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1551,6 +1584,20 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n         subStatus = forwardPlan(entry.getKey(), entry.getValue());\n       }\n       if (subStatus.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        if (entry.getKey() instanceof InsertPlan\n+            && subStatus.getCode() == TSStatusCode.STORAGE_ENGINE_ERROR.getStatusCode()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NjE5Nw=="}, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzQ0OTg1OnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjoyOTo1MlrOGmGD0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjoyOTo1MlrOGmGD0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5ODM1Mg==", "bodyText": "\"entry.getValue()\" is the data group you are going to send the plan to, and it may not be the group that should hold the metadata, so create timeseries plans should be forward to the group that should hold the metadata.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442598352", "createdAt": "2020-06-19T02:29:52Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1551,6 +1584,20 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n         subStatus = forwardPlan(entry.getKey(), entry.getValue());\n       }\n       if (subStatus.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        if (entry.getKey() instanceof InsertPlan\n+            && subStatus.getCode() == TSStatusCode.STORAGE_ENGINE_ERROR.getStatusCode()\n+            && IoTDBDescriptor.getInstance().getConfig().isAutoCreateSchemaEnabled()) {\n+          // try to create timeseries\n+          boolean hasCreate = autoCreateTimeseries((InsertPlan) entry.getKey(), entry.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzQ1ODk5OnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjozNTozMFrOGmGJJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjoyMjo0OFrOGnIClw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5OTcxOA==", "bodyText": "getting -> get\nI would suggest print something like \"{} and other {} paths\", seriesList.get(0), seriesList.size() - 1 instead of \"{}\", serieseList, in case that the list is too long.\nAnd if you want to print a list in a log, you can just use the list as a parameter and there is no need to wrap it with \"Arrays.toString(seriesList.toArray(new String[0]))\".", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442599718", "createdAt": "2020-06-19T02:35:30Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1569,6 +1616,70 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   * @param insertPlan, some of the timeseries in it are not created yet\n+   * @param partitionGroup\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan, PartitionGroup partitionGroup) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+\n+\n+  /**\n+   * To check which timeseries in the input list is unregistered\n+   * @param seriesList\n+   * @param partitionGroup\n+   * @return\n+   */\n+  List<String> getUnregisteredSeriesList(List<String> seriesList, PartitionGroup partitionGroup) {\n+    Set<String> unregistered = new HashSet<>();\n+    for (Node node : partitionGroup) {\n+      try {\n+        DataClient client = getDataClient(node);\n+        Map<String, Boolean> result = SyncClientAdaptor\n+            .getUnregisteredMeasurements(client, partitionGroup.getHeader(), seriesList);\n+        for (Map.Entry<String, Boolean> entry : result.entrySet()) {\n+          if (!entry.getValue()) {\n+            unregistered.add(entry.getKey());\n+          }\n+        }\n+      } catch (TException | IOException e) {\n+        logger.error(\"{}: cannot getting unregistered series list {} from {}\", name,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3OTM4Mw==", "bodyText": "Thanks for your suggestion. I will change that.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443679383", "createdAt": "2020-06-22T16:22:48Z", "author": {"login": "Ring-k"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1569,6 +1616,70 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   * @param insertPlan, some of the timeseries in it are not created yet\n+   * @param partitionGroup\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan, PartitionGroup partitionGroup) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+\n+\n+  /**\n+   * To check which timeseries in the input list is unregistered\n+   * @param seriesList\n+   * @param partitionGroup\n+   * @return\n+   */\n+  List<String> getUnregisteredSeriesList(List<String> seriesList, PartitionGroup partitionGroup) {\n+    Set<String> unregistered = new HashSet<>();\n+    for (Node node : partitionGroup) {\n+      try {\n+        DataClient client = getDataClient(node);\n+        Map<String, Boolean> result = SyncClientAdaptor\n+            .getUnregisteredMeasurements(client, partitionGroup.getHeader(), seriesList);\n+        for (Map.Entry<String, Boolean> entry : result.entrySet()) {\n+          if (!entry.getValue()) {\n+            unregistered.add(entry.getKey());\n+          }\n+        }\n+      } catch (TException | IOException e) {\n+        logger.error(\"{}: cannot getting unregistered series list {} from {}\", name,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5OTcxOA=="}, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzQ2NDk0OnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjozOToxMVrOGmGMgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjoxODozOFrOGnH4aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMDU3Ng==", "bodyText": "Please add a TODO here: \"TODO-Cluster: add executeNonQueryBatch()\", so we can cut the number of communications later.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442600576", "createdAt": "2020-06-19T02:39:11Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1569,6 +1616,70 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   * @param insertPlan, some of the timeseries in it are not created yet\n+   * @param partitionGroup\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan, PartitionGroup partitionGroup) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3Njc3Ng==", "bodyText": "Thanks for your reminding. I will add the comment.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443676776", "createdAt": "2020-06-22T16:18:38Z", "author": {"login": "Ring-k"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1569,6 +1616,70 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   * @param insertPlan, some of the timeseries in it are not created yet\n+   * @param partitionGroup\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan, PartitionGroup partitionGroup) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMDU3Ng=="}, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzQ2ODY2OnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjo0MTo0M1rOGmGO8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwODoxMDowMVrOGoHiVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMTIwMg==", "bodyText": "The schema may be auto-created concurrently, so I think the status code should be carefully checked, and if it says that the timeseries are already created, we should also return true.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442601202", "createdAt": "2020-06-19T02:41:43Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1569,6 +1616,70 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   * @param insertPlan, some of the timeseries in it are not created yet\n+   * @param partitionGroup\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan, PartitionGroup partitionGroup) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcxOTcwMg==", "bodyText": "Thanks for your suggestion. An extra condition will be added in the if clause to make sure of it.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444719702", "createdAt": "2020-06-24T08:10:01Z", "author": {"login": "Ring-k"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1569,6 +1616,70 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   * @param insertPlan, some of the timeseries in it are not created yet\n+   * @param partitionGroup\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan, PartitionGroup partitionGroup) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMTIwMg=="}, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzQ3OTQwOnYy", "diffSide": "RIGHT", "path": "service-rpc/src/main/thrift/cluster.thrift", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjo0ODoyM1rOGmGVWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjoyNDo1N1rOGnIH_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMjg0MQ==", "bodyText": "A suggestion about the interface design: I think the return type can be a list with the length of measurements because the sender clearly know what series it queries and the receiver need not send them back.\nAnother thing, I think \"measurement\" is not proper here, better just call them timeseries.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442602841", "createdAt": "2020-06-19T02:48:23Z", "author": {"login": "jt2594838"}, "path": "service-rpc/src/main/thrift/cluster.thrift", "diffHunk": "@@ -350,6 +350,8 @@ service TSDataService extends RaftService {\n \n   list<binary> getAggrResult(1:GetAggrResultRequest request)\n \n+  map<string, bool> isMeasurementsRegistered(1: Node header, 2: list<string> measurements)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY4MDc2Ng==", "bodyText": "I will change the interface, specifically, the return, to be a list f string, List<String>, which are  unregistered series.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443680766", "createdAt": "2020-06-22T16:24:57Z", "author": {"login": "Ring-k"}, "path": "service-rpc/src/main/thrift/cluster.thrift", "diffHunk": "@@ -350,6 +350,8 @@ service TSDataService extends RaftService {\n \n   list<binary> getAggrResult(1:GetAggrResultRequest request)\n \n+  map<string, bool> isMeasurementsRegistered(1: Node header, 2: list<string> measurements)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMjg0MQ=="}, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzUxODA5OnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMzoxNTozNVrOGmGtJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMjo1NzozM1rOGnXjSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwODkzMw==", "bodyText": "How about CreateTimeSeriesPlan? and other plans which can cause first check storage group exist or not ?", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442608933", "createdAt": "2020-06-19T03:15:35Z", "author": {"login": "neuyilan"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1520,12 +1534,31 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && IoTDBDescriptor.getInstance().getConfig()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzMzUxNA==", "bodyText": "The problem you mentioned refers to CreateTimeseriesPlan, InsertTimeseriesPlan, DeleteTimeseriesPlan and DeleteTimeseriesPlan. However, if storage group is not set when executing DeleteTimeseriesPlan and DeleteTimeseriesPlan, logically there's no necessity for the storage group to be created. As in the method executeNonQuery in MetaGroupMember, these two plans will trigger processNonPartitionDataPlan and processNonPartitionMetaPlan respectively. CreateTimeseriesPlan and InsertTimeseriesPlan are \"partitioned plans\". As a result, if storage group is not set for these 2 types, auto creation will be performed.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443933514", "createdAt": "2020-06-23T02:57:33Z", "author": {"login": "Ring-k"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1520,12 +1534,31 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && IoTDBDescriptor.getInstance().getConfig()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwODkzMw=="}, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTk4MjYzOnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMTo1MjoyMFrOGnWhGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNzoyODoxMVrOGoGM4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNjU3MA==", "bodyText": "Please resolve the conflicts.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443916570", "createdAt": "2020-06-23T01:52:20Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -1073,7 +1072,12 @@ public void pullTimeSeriesSchema(PullSchemaRequest request,\n \n   /**\n    * Create an IPointReader of \"path\" with \u201ctimeFilter\u201d and \"valueFilter\". A synchronization with\n+<<<<<<< HEAD\n+   * the leader will be performed first to preserve strong consistency. TODO-Cluster: also support\n+   * weak consistency\n+=======\n    * the leader will be performed according to consistency level\n+>>>>>>> origin/cluster_new", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c7b5079ddafe3212684986dcecdd877946e6029"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY5NzgyNQ==", "bodyText": "Thanks for your reminding.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444697825", "createdAt": "2020-06-24T07:28:11Z", "author": {"login": "Ring-k"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -1073,7 +1072,12 @@ public void pullTimeSeriesSchema(PullSchemaRequest request,\n \n   /**\n    * Create an IPointReader of \"path\" with \u201ctimeFilter\u201d and \"valueFilter\". A synchronization with\n+<<<<<<< HEAD\n+   * the leader will be performed first to preserve strong consistency. TODO-Cluster: also support\n+   * weak consistency\n+=======\n    * the leader will be performed according to consistency level\n+>>>>>>> origin/cluster_new", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNjU3MA=="}, "originalCommit": {"oid": "3c7b5079ddafe3212684986dcecdd877946e6029"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTk4NDgzOnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMTo1MzozOVrOGnWiZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNzozMToyM1rOGoGSyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNjkwMg==", "bodyText": "I think there is a method syncLeaderWithConsistencyCheck now, and that one should be used.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443916902", "createdAt": "2020-06-23T01:53:39Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -1610,6 +1623,34 @@ public void getAggrResult(GetAggrResultRequest request,\n     resultHandler.onComplete(resultBuffers);\n   }\n \n+  /**\n+   * Check if the given measurements are registered or not\n+   * @param header\n+   * @param timeseriesList\n+   * @param resultHandler\n+   * @throws TException\n+   */\n+  @Override\n+  public void getUnregisteredTimeseries(Node header, List<String> timeseriesList,\n+      AsyncMethodCallback<List<String>> resultHandler) throws TException {\n+    if (!syncLeader()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c7b5079ddafe3212684986dcecdd877946e6029"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY5OTMzNg==", "bodyText": "Thank you for your suggestion. The method syncLeaderWithConsistencyCheck will be used.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444699336", "createdAt": "2020-06-24T07:31:23Z", "author": {"login": "Ring-k"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -1610,6 +1623,34 @@ public void getAggrResult(GetAggrResultRequest request,\n     resultHandler.onComplete(resultBuffers);\n   }\n \n+  /**\n+   * Check if the given measurements are registered or not\n+   * @param header\n+   * @param timeseriesList\n+   * @param resultHandler\n+   * @throws TException\n+   */\n+  @Override\n+  public void getUnregisteredTimeseries(Node header, List<String> timeseriesList,\n+      AsyncMethodCallback<List<String>> resultHandler) throws TException {\n+    if (!syncLeader()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNjkwMg=="}, "originalCommit": {"oid": "3c7b5079ddafe3212684986dcecdd877946e6029"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTk4Nzc3OnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMTo1NToyNVrOGnWkUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNzozMzozNFrOGoGW2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNzM5NQ==", "bodyText": "Better add the seriesPath which triggers the exception into the message.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443917395", "createdAt": "2020-06-23T01:55:25Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -1610,6 +1623,34 @@ public void getAggrResult(GetAggrResultRequest request,\n     resultHandler.onComplete(resultBuffers);\n   }\n \n+  /**\n+   * Check if the given measurements are registered or not\n+   * @param header\n+   * @param timeseriesList\n+   * @param resultHandler\n+   * @throws TException\n+   */\n+  @Override\n+  public void getUnregisteredTimeseries(Node header, List<String> timeseriesList,\n+      AsyncMethodCallback<List<String>> resultHandler) throws TException {\n+    if (!syncLeader()) {\n+      resultHandler.onError(new LeaderUnknownException(getAllNodes()));\n+      return;\n+    }\n+    List<String> result = new ArrayList<>();\n+    for (String seriesPath : timeseriesList) {\n+      try {\n+        List<String> path = MManager.getInstance().getAllTimeseriesName(seriesPath);\n+        if (path.size() != 1) {\n+          throw new MetadataException(\"Size of the path is not 1.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c7b5079ddafe3212684986dcecdd877946e6029"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcwMDM3Nw==", "bodyText": "Thanks for your suggestion. The information of the series will be included.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444700377", "createdAt": "2020-06-24T07:33:34Z", "author": {"login": "Ring-k"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -1610,6 +1623,34 @@ public void getAggrResult(GetAggrResultRequest request,\n     resultHandler.onComplete(resultBuffers);\n   }\n \n+  /**\n+   * Check if the given measurements are registered or not\n+   * @param header\n+   * @param timeseriesList\n+   * @param resultHandler\n+   * @throws TException\n+   */\n+  @Override\n+  public void getUnregisteredTimeseries(Node header, List<String> timeseriesList,\n+      AsyncMethodCallback<List<String>> resultHandler) throws TException {\n+    if (!syncLeader()) {\n+      resultHandler.onError(new LeaderUnknownException(getAllNodes()));\n+      return;\n+    }\n+    List<String> result = new ArrayList<>();\n+    for (String seriesPath : timeseriesList) {\n+      try {\n+        List<String> path = MManager.getInstance().getAllTimeseriesName(seriesPath);\n+        if (path.size() != 1) {\n+          throw new MetadataException(\"Size of the path is not 1.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNzM5NQ=="}, "originalCommit": {"oid": "3c7b5079ddafe3212684986dcecdd877946e6029"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTk5MzkwOnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMTo1ODo1OFrOGnWoSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNzozNDo0M1rOGoGY-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxODQwOQ==", "bodyText": "Report the status code and its message in the exception.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443918409", "createdAt": "2020-06-23T01:58:58Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1530,9 +1544,29 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && ClusterDescriptor.getInstance().getConfig()\n+          .isEnableAutoCreateSchema()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = executeNonQuery(setStorageGroupPlan);\n+          if (setStorageGroupResult.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+            throw new MetadataException(\"Failed to set storage group \" + storageGroupName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c7b5079ddafe3212684986dcecdd877946e6029"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcwMDkyMw==", "bodyText": "Thanks for your suggestion. The status code will be included in the exception.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444700923", "createdAt": "2020-06-24T07:34:43Z", "author": {"login": "Ring-k"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1530,9 +1544,29 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && ClusterDescriptor.getInstance().getConfig()\n+          .isEnableAutoCreateSchema()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = executeNonQuery(setStorageGroupPlan);\n+          if (setStorageGroupResult.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+            throw new MetadataException(\"Failed to set storage group \" + storageGroupName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxODQwOQ=="}, "originalCommit": {"oid": "3c7b5079ddafe3212684986dcecdd877946e6029"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjYxOTUwOnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwNzoyMzo1OVrOGnchNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNzozODoyMFrOGoGf4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAxNDkwMQ==", "bodyText": "It seems that this function forwardPlan will only be used in processNonPartitionedDataPlan, which will be called only when the type of plan is DeletePlan or DeleteTimeSeriesPlan, so maybe these new code in this function will never be called?", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444014901", "createdAt": "2020-06-23T07:23:59Z", "author": {"login": "LebronAl"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1667,6 +1710,18 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n         status = forwardPlan(plan, partitionGroup);\n       }\n       if (status.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        if (plan instanceof InsertPlan", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2493bcc51d702b6be99b84b0fae53f140469d61b"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcwMjY4OA==", "bodyText": "You are right. Thanks for your reminding. These codes will be moved to TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap, PhysicalPlan plan).", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444702688", "createdAt": "2020-06-24T07:38:20Z", "author": {"login": "Ring-k"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1667,6 +1710,18 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n         status = forwardPlan(plan, partitionGroup);\n       }\n       if (status.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        if (plan instanceof InsertPlan", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAxNDkwMQ=="}, "originalCommit": {"oid": "2493bcc51d702b6be99b84b0fae53f140469d61b"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjY0MjgzOnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwNzozMTowOFrOGncvyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNzozOToxMFrOGoGhgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAxODYzMg==", "bodyText": "maybe you can use processNonPartitionedMetaPlan directly to avoid unnecessary judgement", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444018632", "createdAt": "2020-06-23T07:31:08Z", "author": {"login": "LebronAl"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1530,9 +1544,38 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && ClusterDescriptor.getInstance().getConfig()\n+          .isEnableAutoCreateSchema()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = executeNonQuery(setStorageGroupPlan);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2493bcc51d702b6be99b84b0fae53f140469d61b"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcwMzEwNQ==", "bodyText": "Good idea. Thanks for your suggestion.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444703105", "createdAt": "2020-06-24T07:39:10Z", "author": {"login": "Ring-k"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1530,9 +1544,38 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && ClusterDescriptor.getInstance().getConfig()\n+          .isEnableAutoCreateSchema()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = executeNonQuery(setStorageGroupPlan);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAxODYzMg=="}, "originalCommit": {"oid": "2493bcc51d702b6be99b84b0fae53f140469d61b"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjcwNjMwOnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwNzo0ODoyMlrOGndWnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDoyMTowNFrOGoUXiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAyODU3NQ==", "bodyText": "maybe you can use processPartitionedPlan directly to avoid unnecessary judgement", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444028575", "createdAt": "2020-06-23T07:48:22Z", "author": {"login": "LebronAl"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1684,6 +1739,77 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   *\n+   * @param insertPlan,    some of the timeseries in it are not created yet\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    String storageGroupName;\n+    try {\n+      storageGroupName = MetaUtils\n+          .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+              .getConfig().getDefaultStorageGroupLevel());\n+    } catch (MetadataException e) {\n+      logger.error(\"Failed to infer storage group from deviceId {}\", deviceId);\n+      return false;\n+    }\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    PartitionGroup partitionGroup = partitionTable.route(storageGroupName, 0);\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      // TODO-Cluster: add executeNonQueryBatch()\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2493bcc51d702b6be99b84b0fae53f140469d61b"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyOTkyOA==", "bodyText": "You are right. Thanks.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444929928", "createdAt": "2020-06-24T14:21:04Z", "author": {"login": "Ring-k"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1684,6 +1739,77 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   *\n+   * @param insertPlan,    some of the timeseries in it are not created yet\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    String storageGroupName;\n+    try {\n+      storageGroupName = MetaUtils\n+          .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+              .getConfig().getDefaultStorageGroupLevel());\n+    } catch (MetadataException e) {\n+      logger.error(\"Failed to infer storage group from deviceId {}\", deviceId);\n+      return false;\n+    }\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    PartitionGroup partitionGroup = partitionTable.route(storageGroupName, 0);\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      // TODO-Cluster: add executeNonQueryBatch()\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAyODU3NQ=="}, "originalCommit": {"oid": "2493bcc51d702b6be99b84b0fae53f140469d61b"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTQzNzgwOnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDoxMzozNVrOGoL3-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDoyMDo0N1rOGoUWpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MDc3Ng==", "bodyText": "It would be better to use e (preserve stack traces).", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444790776", "createdAt": "2020-06-24T10:13:35Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1530,9 +1544,39 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && ClusterDescriptor.getInstance().getConfig()\n+          .isEnableAutoCreateSchema()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = processNonPartitionedMetaPlan(setStorageGroupPlan);\n+          if (setStorageGroupResult.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode() &&\n+          setStorageGroupResult.getCode() != TSStatusCode.PATH_ALREADY_EXIST_ERROR.getStatusCode()) {\n+            throw new MetadataException(\n+                String.format(\"Status Code: %d, failed to set storage group \",\n+                    setStorageGroupResult.getCode(), storageGroupName)\n+            );\n+          }\n+          // try to create timeseries\n+          boolean isAutoCreateTimeseriesSuccess = autoCreateTimeseries((InsertPlan)plan);\n+          if(!isAutoCreateTimeseriesSuccess){\n+            throw new MetadataException(\n+                String.format(\"Failed to create timeseries from InsertPlan automatically.\")\n+            );\n+          }\n+          return executeNonQuery(plan);\n+        } catch (MetadataException e) {\n+          logger.error(\"Failed to set storage group or create timeseries, because {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyOTcwMA==", "bodyText": "Thanks for your suggestion.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444929700", "createdAt": "2020-06-24T14:20:47Z", "author": {"login": "Ring-k"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1530,9 +1544,39 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && ClusterDescriptor.getInstance().getConfig()\n+          .isEnableAutoCreateSchema()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = processNonPartitionedMetaPlan(setStorageGroupPlan);\n+          if (setStorageGroupResult.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode() &&\n+          setStorageGroupResult.getCode() != TSStatusCode.PATH_ALREADY_EXIST_ERROR.getStatusCode()) {\n+            throw new MetadataException(\n+                String.format(\"Status Code: %d, failed to set storage group \",\n+                    setStorageGroupResult.getCode(), storageGroupName)\n+            );\n+          }\n+          // try to create timeseries\n+          boolean isAutoCreateTimeseriesSuccess = autoCreateTimeseries((InsertPlan)plan);\n+          if(!isAutoCreateTimeseriesSuccess){\n+            throw new MetadataException(\n+                String.format(\"Failed to create timeseries from InsertPlan automatically.\")\n+            );\n+          }\n+          return executeNonQuery(plan);\n+        } catch (MetadataException e) {\n+          logger.error(\"Failed to set storage group or create timeseries, because {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MDc3Ng=="}, "originalCommit": {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTQ0OTUzOnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDoxNzoyOFrOGoL_mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDoyMDozMFrOGoUVxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MjcyOA==", "bodyText": "Please refactor this message like the former one to avoid printing too many seriesPaths.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444792728", "createdAt": "2020-06-24T10:17:28Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1684,6 +1743,77 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   *\n+   * @param insertPlan,    some of the timeseries in it are not created yet\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    String storageGroupName;\n+    try {\n+      storageGroupName = MetaUtils\n+          .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+              .getConfig().getDefaultStorageGroupLevel());\n+    } catch (MetadataException e) {\n+      logger.error(\"Failed to infer storage group from deviceId {}\", deviceId);\n+      return false;\n+    }\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    PartitionGroup partitionGroup = partitionTable.route(storageGroupName, 0);\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      // TODO-Cluster: add executeNonQueryBatch()\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * To check which timeseries in the input list is unregistered\n+   *\n+   * @param seriesList\n+   * @param partitionGroup\n+   * @return\n+   */\n+  List<String> getUnregisteredSeriesList(List<String> seriesList, PartitionGroup partitionGroup) {\n+    Set<String> unregistered = new HashSet<>();\n+    for (Node node : partitionGroup) {\n+      try {\n+        DataClient client = getDataClient(node);\n+        List<String> result = SyncClientAdaptor\n+            .getUnregisteredMeasurements(client, partitionGroup.getHeader(), seriesList);\n+        unregistered.addAll(result);\n+      } catch (TException | IOException e) {\n+        logger.error(\"{}: cannot getting unregistered {} and other {} paths from {}\", name,\n+            seriesList.get(0), seriesList.get(seriesList.size() - 1), node, e);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        logger.error(\"{}: getting unregistered series list {} is interrupted from {}\", name,\n+            Arrays.toString(seriesList.toArray(new String[0])), node, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyOTQ3Ng==", "bodyText": "Thanks for your reminding.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444929476", "createdAt": "2020-06-24T14:20:30Z", "author": {"login": "Ring-k"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1684,6 +1743,77 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   *\n+   * @param insertPlan,    some of the timeseries in it are not created yet\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    String storageGroupName;\n+    try {\n+      storageGroupName = MetaUtils\n+          .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+              .getConfig().getDefaultStorageGroupLevel());\n+    } catch (MetadataException e) {\n+      logger.error(\"Failed to infer storage group from deviceId {}\", deviceId);\n+      return false;\n+    }\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    PartitionGroup partitionGroup = partitionTable.route(storageGroupName, 0);\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      // TODO-Cluster: add executeNonQueryBatch()\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * To check which timeseries in the input list is unregistered\n+   *\n+   * @param seriesList\n+   * @param partitionGroup\n+   * @return\n+   */\n+  List<String> getUnregisteredSeriesList(List<String> seriesList, PartitionGroup partitionGroup) {\n+    Set<String> unregistered = new HashSet<>();\n+    for (Node node : partitionGroup) {\n+      try {\n+        DataClient client = getDataClient(node);\n+        List<String> result = SyncClientAdaptor\n+            .getUnregisteredMeasurements(client, partitionGroup.getHeader(), seriesList);\n+        unregistered.addAll(result);\n+      } catch (TException | IOException e) {\n+        logger.error(\"{}: cannot getting unregistered {} and other {} paths from {}\", name,\n+            seriesList.get(0), seriesList.get(seriesList.size() - 1), node, e);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        logger.error(\"{}: getting unregistered series list {} is interrupted from {}\", name,\n+            Arrays.toString(seriesList.toArray(new String[0])), node, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MjcyOA=="}, "originalCommit": {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTQ1NDE4OnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDoxODo1NlrOGoMCgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDoyMDoxOFrOGoUVLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MzQ3NA==", "bodyText": "I think you should break once a non-null result is returned, and I do not think using a Set is necessary.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444793474", "createdAt": "2020-06-24T10:18:56Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1684,6 +1743,77 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   *\n+   * @param insertPlan,    some of the timeseries in it are not created yet\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    String storageGroupName;\n+    try {\n+      storageGroupName = MetaUtils\n+          .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+              .getConfig().getDefaultStorageGroupLevel());\n+    } catch (MetadataException e) {\n+      logger.error(\"Failed to infer storage group from deviceId {}\", deviceId);\n+      return false;\n+    }\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    PartitionGroup partitionGroup = partitionTable.route(storageGroupName, 0);\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      // TODO-Cluster: add executeNonQueryBatch()\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * To check which timeseries in the input list is unregistered\n+   *\n+   * @param seriesList\n+   * @param partitionGroup\n+   * @return\n+   */\n+  List<String> getUnregisteredSeriesList(List<String> seriesList, PartitionGroup partitionGroup) {\n+    Set<String> unregistered = new HashSet<>();\n+    for (Node node : partitionGroup) {\n+      try {\n+        DataClient client = getDataClient(node);\n+        List<String> result = SyncClientAdaptor\n+            .getUnregisteredMeasurements(client, partitionGroup.getHeader(), seriesList);\n+        unregistered.addAll(result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyOTMyNA==", "bodyText": "You are right. Finishing the loop is not necessary.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444929324", "createdAt": "2020-06-24T14:20:18Z", "author": {"login": "Ring-k"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1684,6 +1743,77 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   *\n+   * @param insertPlan,    some of the timeseries in it are not created yet\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    String storageGroupName;\n+    try {\n+      storageGroupName = MetaUtils\n+          .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+              .getConfig().getDefaultStorageGroupLevel());\n+    } catch (MetadataException e) {\n+      logger.error(\"Failed to infer storage group from deviceId {}\", deviceId);\n+      return false;\n+    }\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    PartitionGroup partitionGroup = partitionTable.route(storageGroupName, 0);\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      // TODO-Cluster: add executeNonQueryBatch()\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * To check which timeseries in the input list is unregistered\n+   *\n+   * @param seriesList\n+   * @param partitionGroup\n+   * @return\n+   */\n+  List<String> getUnregisteredSeriesList(List<String> seriesList, PartitionGroup partitionGroup) {\n+    Set<String> unregistered = new HashSet<>();\n+    for (Node node : partitionGroup) {\n+      try {\n+        DataClient client = getDataClient(node);\n+        List<String> result = SyncClientAdaptor\n+            .getUnregisteredMeasurements(client, partitionGroup.getHeader(), seriesList);\n+        unregistered.addAll(result);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MzQ3NA=="}, "originalCommit": {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTQ2NjczOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDoyMjoyOVrOGoMKGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDoxOToyMFrOGoUShw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5NTQxNw==", "bodyText": "I suggest you just add a field of List in PathNotExistException, since concatenating a long string list is time-consuming.\nBesides, please perform a reformat.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444795417", "createdAt": "2020-06-24T10:22:29Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -914,8 +914,26 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       insertPlan.setSchemasAndTransferType(schemas);\n       StorageEngine.getInstance().insert(insertPlan);\n       if (insertPlan.getFailedMeasurements() != null) {\n-        throw new StorageEngineException(\n-            \"failed to insert points \" + insertPlan.getFailedMeasurements());\n+        // check if all path not exist exceptions\n+        List<String> failedPaths = new ArrayList<>(insertPlan.getFailedMeasurements().keySet());\n+        List<Exception> exceptions = new ArrayList<>(insertPlan.getFailedMeasurements().values());\n+        boolean isPathNotExistException = true;\n+        for(Exception e : exceptions){\n+          Exception curException = e;\n+          while(curException.getCause() != null){\n+            curException = (Exception) curException.getCause();\n+          }\n+          if(!(curException instanceof PathNotExistException)){\n+            isPathNotExistException = false;\n+            break;\n+          }\n+        }\n+        if(isPathNotExistException){\n+          throw new PathNotExistException(failedPaths.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyODY0Nw==", "bodyText": "An attribute is added in the PathNotExistExeption. Thanks for your suggestion.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444928647", "createdAt": "2020-06-24T14:19:20Z", "author": {"login": "Ring-k"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -914,8 +914,26 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       insertPlan.setSchemasAndTransferType(schemas);\n       StorageEngine.getInstance().insert(insertPlan);\n       if (insertPlan.getFailedMeasurements() != null) {\n-        throw new StorageEngineException(\n-            \"failed to insert points \" + insertPlan.getFailedMeasurements());\n+        // check if all path not exist exceptions\n+        List<String> failedPaths = new ArrayList<>(insertPlan.getFailedMeasurements().keySet());\n+        List<Exception> exceptions = new ArrayList<>(insertPlan.getFailedMeasurements().values());\n+        boolean isPathNotExistException = true;\n+        for(Exception e : exceptions){\n+          Exception curException = e;\n+          while(curException.getCause() != null){\n+            curException = (Exception) curException.getCause();\n+          }\n+          if(!(curException instanceof PathNotExistException)){\n+            isPathNotExistException = false;\n+            break;\n+          }\n+        }\n+        if(isPathNotExistException){\n+          throw new PathNotExistException(failedPaths.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5NTQxNw=="}, "originalCommit": {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTQ3MTg4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDoyMzo1N1rOGoMNMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDoxODozNlrOGoUQVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5NjIwOQ==", "bodyText": "You may just define this as a Throwable so you may avoid the typecast.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444796209", "createdAt": "2020-06-24T10:23:57Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -914,8 +914,26 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       insertPlan.setSchemasAndTransferType(schemas);\n       StorageEngine.getInstance().insert(insertPlan);\n       if (insertPlan.getFailedMeasurements() != null) {\n-        throw new StorageEngineException(\n-            \"failed to insert points \" + insertPlan.getFailedMeasurements());\n+        // check if all path not exist exceptions\n+        List<String> failedPaths = new ArrayList<>(insertPlan.getFailedMeasurements().keySet());\n+        List<Exception> exceptions = new ArrayList<>(insertPlan.getFailedMeasurements().values());\n+        boolean isPathNotExistException = true;\n+        for(Exception e : exceptions){\n+          Exception curException = e;\n+          while(curException.getCause() != null){\n+            curException = (Exception) curException.getCause();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyODA4NA==", "bodyText": "Thanks for yoru suggestion.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444928084", "createdAt": "2020-06-24T14:18:36Z", "author": {"login": "Ring-k"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -914,8 +914,26 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       insertPlan.setSchemasAndTransferType(schemas);\n       StorageEngine.getInstance().insert(insertPlan);\n       if (insertPlan.getFailedMeasurements() != null) {\n-        throw new StorageEngineException(\n-            \"failed to insert points \" + insertPlan.getFailedMeasurements());\n+        // check if all path not exist exceptions\n+        List<String> failedPaths = new ArrayList<>(insertPlan.getFailedMeasurements().keySet());\n+        List<Exception> exceptions = new ArrayList<>(insertPlan.getFailedMeasurements().values());\n+        boolean isPathNotExistException = true;\n+        for(Exception e : exceptions){\n+          Exception curException = e;\n+          while(curException.getCause() != null){\n+            curException = (Exception) curException.getCause();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5NjIwOQ=="}, "originalCommit": {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MzIwMzkwOnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwOTowNzozMFrOGp7wnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwOTozMjo0MVrOGp77Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyMzkwMw==", "bodyText": "Why change this?", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r446623903", "createdAt": "2020-06-28T09:07:30Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1586,7 +1586,7 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n           }\n           return executeNonQuery(plan);\n         } catch (MetadataException e) {\n-          logger.error(\"Failed to set storage group or create timeseries, because {}\", e);\n+          logger.error(String.format(\"Failed to set storage group or create timeseries, because %s\", e));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9ba68f83d885a4adde57ec6c9eb705ec49dd8d9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyNjYyMg==", "bodyText": "It was recognized as a bug according to rules of sonar, \"Fewer arguments provided (0) than placeholders specified (1) \".", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r446626622", "createdAt": "2020-06-28T09:32:41Z", "author": {"login": "Ring-k"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1586,7 +1586,7 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n           }\n           return executeNonQuery(plan);\n         } catch (MetadataException e) {\n-          logger.error(\"Failed to set storage group or create timeseries, because {}\", e);\n+          logger.error(String.format(\"Failed to set storage group or create timeseries, because %s\", e));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyMzkwMw=="}, "originalCommit": {"oid": "b9ba68f83d885a4adde57ec6c9eb705ec49dd8d9"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4795, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}