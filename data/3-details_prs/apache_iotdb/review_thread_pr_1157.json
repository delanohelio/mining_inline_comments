{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzOTE5OTc4", "number": 1157, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMjozMTo0N1rOD6EQDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMjozNDoxM1rOD6ERyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjEzNjQ3OnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/catchup/CatchUpTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMjozMTo0N1rOGRsNCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMzoxNjozMFrOGRs6HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwMzIwOA==", "bodyText": "It would be better to perform a binary search, but it is fine for now.", "url": "https://github.com/apache/iotdb/pull/1157#discussion_r421203208", "createdAt": "2020-05-07T02:31:47Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/catchup/CatchUpTask.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.catchup;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.cluster.log.logtypes.EmptyContentLog;\n+import org.apache.iotdb.cluster.rpc.thrift.AppendEntryRequest;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.cluster.rpc.thrift.RaftService.AsyncClient;\n+import org.apache.iotdb.cluster.server.NodeCharacter;\n+import org.apache.iotdb.cluster.server.Peer;\n+import org.apache.iotdb.cluster.server.RaftServer;\n+import org.apache.iotdb.cluster.server.handlers.caller.LogCatchUpHandler;\n+import org.apache.iotdb.cluster.server.member.RaftMember;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CatchUpTask implements Runnable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(LogCatchUpTask.class);\n+\n+  private Node node;\n+  private Peer peer;\n+  private RaftMember raftMember;\n+  private Snapshot snapshot;\n+  private List<Log> logs;\n+\n+\n+  public CatchUpTask(Node node, Peer peer, RaftMember raftMember) {\n+    this.node = node;\n+    this.peer = peer;\n+    this.raftMember = raftMember;\n+    this.logs = Collections.emptyList();\n+    this.snapshot = null;\n+  }\n+\n+  boolean checkMatchIndex() throws TException, InterruptedException {\n+    AppendEntryRequest request = new AppendEntryRequest();\n+    AtomicBoolean isMatch = new AtomicBoolean(false);\n+\n+    LogCatchUpHandler handler = new LogCatchUpHandler();\n+    handler.setAppendSucceed(isMatch);\n+    handler.setRaftMember(raftMember);\n+    handler.setFollower(node);\n+    if (raftMember.getHeader() != null) {\n+      request.setHeader(raftMember.getHeader());\n+    }\n+    request.setLeader(raftMember.getThisNode());\n+    // not update follower's commitIndex in order to append the log which index is matchIndex twice\n+    request.setLeaderCommit(-1);\n+    synchronized (raftMember.getLogManager()) {\n+      peer.setNextIndex(raftMember.getLogManager().getLastLogIndex());\n+      try {\n+        logs = raftMember.getLogManager().getEntries(\n+            Math.max(raftMember.getLogManager().getFirstIndex(), peer.getMatchIndex() + 1),\n+            peer.getNextIndex() + 1);\n+      } catch (Exception e) {\n+        logger.error(\"Unexpected error in logManager's getEntries during matchIndexCheck\", e);\n+      }\n+    }\n+\n+    int index = logs.size() - 1;\n+    EmptyContentLog emptyLog = new EmptyContentLog();\n+    while (index >= 0) {\n+      Log log = logs.get(index);\n+      emptyLog.setCurrLogIndex(log.getCurrLogIndex());\n+      emptyLog.setCurrLogTerm(log.getCurrLogTerm());\n+      synchronized (raftMember.getTerm()) {\n+        // make sure this node is still a leader\n+        if (raftMember.getCharacter() != NodeCharacter.LEADER) {\n+          logger.debug(\"Leadership is lost when doing a catch-up to {}, aborting\", node);\n+          break;\n+        }\n+        request.setTerm(raftMember.getTerm().get());\n+      }\n+      if (index > 0) {\n+        request.setPrevLogIndex(logs.get(index - 1).getCurrLogIndex());\n+        request.setPrevLogTerm(logs.get(index - 1).getCurrLogTerm());\n+      } else {\n+        request.setPrevLogIndex(log.getCurrLogIndex() - 1);\n+        try {\n+          request.setPrevLogTerm(raftMember.getLogManager().getTerm(log.getCurrLogIndex() - 1));\n+        } catch (Exception e) {\n+          logger.error(\"getTerm failed for newly append entries\", e);\n+        }\n+      }\n+\n+      handler.setLog(log);\n+      request.setEntry(emptyLog.serialize());\n+\n+      synchronized (isMatch) {\n+        AsyncClient client = raftMember.connectNode(node);\n+        if (client == null) {\n+          break;\n+        }\n+        client.appendEntry(request, handler);\n+        raftMember.getLastCatchUpResponseTime().put(node, System.currentTimeMillis());\n+        isMatch.wait(RaftServer.connectionTimeoutInMS);\n+      }\n+      if (isMatch.get()) {\n+        // if follower return RESPONSE.AGREE with this empty log, then start sending real logs from this emptyContentLog's index.\n+        // which means the log which index is matchIndex will be send twice, but at the first time it sent an empty log.\n+        logs.subList(0, index).clear();\n+        if (logger.isDebugEnabled()) {\n+          logger.debug(\"{} makes {} catch up with {} cached logs\", raftMember.getName(), node,\n+              logs.size());\n+        }\n+        return false;\n+      }\n+      index--;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "701f328eb1ed191f38482f1d192fb067d1ec3d5d"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxNDc0OA==", "bodyText": "Inconsistencies are generally rare, and there aren't many missing logs, so this may actually be enough. If a performance bottleneck occurs, I will modify here ~", "url": "https://github.com/apache/iotdb/pull/1157#discussion_r421214748", "createdAt": "2020-05-07T03:16:30Z", "author": {"login": "LebronAl"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/catchup/CatchUpTask.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.catchup;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.cluster.log.logtypes.EmptyContentLog;\n+import org.apache.iotdb.cluster.rpc.thrift.AppendEntryRequest;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.cluster.rpc.thrift.RaftService.AsyncClient;\n+import org.apache.iotdb.cluster.server.NodeCharacter;\n+import org.apache.iotdb.cluster.server.Peer;\n+import org.apache.iotdb.cluster.server.RaftServer;\n+import org.apache.iotdb.cluster.server.handlers.caller.LogCatchUpHandler;\n+import org.apache.iotdb.cluster.server.member.RaftMember;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CatchUpTask implements Runnable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(LogCatchUpTask.class);\n+\n+  private Node node;\n+  private Peer peer;\n+  private RaftMember raftMember;\n+  private Snapshot snapshot;\n+  private List<Log> logs;\n+\n+\n+  public CatchUpTask(Node node, Peer peer, RaftMember raftMember) {\n+    this.node = node;\n+    this.peer = peer;\n+    this.raftMember = raftMember;\n+    this.logs = Collections.emptyList();\n+    this.snapshot = null;\n+  }\n+\n+  boolean checkMatchIndex() throws TException, InterruptedException {\n+    AppendEntryRequest request = new AppendEntryRequest();\n+    AtomicBoolean isMatch = new AtomicBoolean(false);\n+\n+    LogCatchUpHandler handler = new LogCatchUpHandler();\n+    handler.setAppendSucceed(isMatch);\n+    handler.setRaftMember(raftMember);\n+    handler.setFollower(node);\n+    if (raftMember.getHeader() != null) {\n+      request.setHeader(raftMember.getHeader());\n+    }\n+    request.setLeader(raftMember.getThisNode());\n+    // not update follower's commitIndex in order to append the log which index is matchIndex twice\n+    request.setLeaderCommit(-1);\n+    synchronized (raftMember.getLogManager()) {\n+      peer.setNextIndex(raftMember.getLogManager().getLastLogIndex());\n+      try {\n+        logs = raftMember.getLogManager().getEntries(\n+            Math.max(raftMember.getLogManager().getFirstIndex(), peer.getMatchIndex() + 1),\n+            peer.getNextIndex() + 1);\n+      } catch (Exception e) {\n+        logger.error(\"Unexpected error in logManager's getEntries during matchIndexCheck\", e);\n+      }\n+    }\n+\n+    int index = logs.size() - 1;\n+    EmptyContentLog emptyLog = new EmptyContentLog();\n+    while (index >= 0) {\n+      Log log = logs.get(index);\n+      emptyLog.setCurrLogIndex(log.getCurrLogIndex());\n+      emptyLog.setCurrLogTerm(log.getCurrLogTerm());\n+      synchronized (raftMember.getTerm()) {\n+        // make sure this node is still a leader\n+        if (raftMember.getCharacter() != NodeCharacter.LEADER) {\n+          logger.debug(\"Leadership is lost when doing a catch-up to {}, aborting\", node);\n+          break;\n+        }\n+        request.setTerm(raftMember.getTerm().get());\n+      }\n+      if (index > 0) {\n+        request.setPrevLogIndex(logs.get(index - 1).getCurrLogIndex());\n+        request.setPrevLogTerm(logs.get(index - 1).getCurrLogTerm());\n+      } else {\n+        request.setPrevLogIndex(log.getCurrLogIndex() - 1);\n+        try {\n+          request.setPrevLogTerm(raftMember.getLogManager().getTerm(log.getCurrLogIndex() - 1));\n+        } catch (Exception e) {\n+          logger.error(\"getTerm failed for newly append entries\", e);\n+        }\n+      }\n+\n+      handler.setLog(log);\n+      request.setEntry(emptyLog.serialize());\n+\n+      synchronized (isMatch) {\n+        AsyncClient client = raftMember.connectNode(node);\n+        if (client == null) {\n+          break;\n+        }\n+        client.appendEntry(request, handler);\n+        raftMember.getLastCatchUpResponseTime().put(node, System.currentTimeMillis());\n+        isMatch.wait(RaftServer.connectionTimeoutInMS);\n+      }\n+      if (isMatch.get()) {\n+        // if follower return RESPONSE.AGREE with this empty log, then start sending real logs from this emptyContentLog's index.\n+        // which means the log which index is matchIndex will be send twice, but at the first time it sent an empty log.\n+        logs.subList(0, index).clear();\n+        if (logger.isDebugEnabled()) {\n+          logger.debug(\"{} makes {} catch up with {} cached logs\", raftMember.getName(), node,\n+              logs.size());\n+        }\n+        return false;\n+      }\n+      index--;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwMzIwOA=="}, "originalCommit": {"oid": "701f328eb1ed191f38482f1d192fb067d1ec3d5d"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjE0MDkxOnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/catchup/CatchUpTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMjozNDoxM1rOGRsPeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMzoyMDoyOFrOGRs-CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwMzgzMw==", "bodyText": "Batched log catch-up has been introduced, better to switch to better.", "url": "https://github.com/apache/iotdb/pull/1157#discussion_r421203833", "createdAt": "2020-05-07T02:34:13Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/catchup/CatchUpTask.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.catchup;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.cluster.log.logtypes.EmptyContentLog;\n+import org.apache.iotdb.cluster.rpc.thrift.AppendEntryRequest;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.cluster.rpc.thrift.RaftService.AsyncClient;\n+import org.apache.iotdb.cluster.server.NodeCharacter;\n+import org.apache.iotdb.cluster.server.Peer;\n+import org.apache.iotdb.cluster.server.RaftServer;\n+import org.apache.iotdb.cluster.server.handlers.caller.LogCatchUpHandler;\n+import org.apache.iotdb.cluster.server.member.RaftMember;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CatchUpTask implements Runnable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(LogCatchUpTask.class);\n+\n+  private Node node;\n+  private Peer peer;\n+  private RaftMember raftMember;\n+  private Snapshot snapshot;\n+  private List<Log> logs;\n+\n+\n+  public CatchUpTask(Node node, Peer peer, RaftMember raftMember) {\n+    this.node = node;\n+    this.peer = peer;\n+    this.raftMember = raftMember;\n+    this.logs = Collections.emptyList();\n+    this.snapshot = null;\n+  }\n+\n+  boolean checkMatchIndex() throws TException, InterruptedException {\n+    AppendEntryRequest request = new AppendEntryRequest();\n+    AtomicBoolean isMatch = new AtomicBoolean(false);\n+\n+    LogCatchUpHandler handler = new LogCatchUpHandler();\n+    handler.setAppendSucceed(isMatch);\n+    handler.setRaftMember(raftMember);\n+    handler.setFollower(node);\n+    if (raftMember.getHeader() != null) {\n+      request.setHeader(raftMember.getHeader());\n+    }\n+    request.setLeader(raftMember.getThisNode());\n+    // not update follower's commitIndex in order to append the log which index is matchIndex twice\n+    request.setLeaderCommit(-1);\n+    synchronized (raftMember.getLogManager()) {\n+      peer.setNextIndex(raftMember.getLogManager().getLastLogIndex());\n+      try {\n+        logs = raftMember.getLogManager().getEntries(\n+            Math.max(raftMember.getLogManager().getFirstIndex(), peer.getMatchIndex() + 1),\n+            peer.getNextIndex() + 1);\n+      } catch (Exception e) {\n+        logger.error(\"Unexpected error in logManager's getEntries during matchIndexCheck\", e);\n+      }\n+    }\n+\n+    int index = logs.size() - 1;\n+    EmptyContentLog emptyLog = new EmptyContentLog();\n+    while (index >= 0) {\n+      Log log = logs.get(index);\n+      emptyLog.setCurrLogIndex(log.getCurrLogIndex());\n+      emptyLog.setCurrLogTerm(log.getCurrLogTerm());\n+      synchronized (raftMember.getTerm()) {\n+        // make sure this node is still a leader\n+        if (raftMember.getCharacter() != NodeCharacter.LEADER) {\n+          logger.debug(\"Leadership is lost when doing a catch-up to {}, aborting\", node);\n+          break;\n+        }\n+        request.setTerm(raftMember.getTerm().get());\n+      }\n+      if (index > 0) {\n+        request.setPrevLogIndex(logs.get(index - 1).getCurrLogIndex());\n+        request.setPrevLogTerm(logs.get(index - 1).getCurrLogTerm());\n+      } else {\n+        request.setPrevLogIndex(log.getCurrLogIndex() - 1);\n+        try {\n+          request.setPrevLogTerm(raftMember.getLogManager().getTerm(log.getCurrLogIndex() - 1));\n+        } catch (Exception e) {\n+          logger.error(\"getTerm failed for newly append entries\", e);\n+        }\n+      }\n+\n+      handler.setLog(log);\n+      request.setEntry(emptyLog.serialize());\n+\n+      synchronized (isMatch) {\n+        AsyncClient client = raftMember.connectNode(node);\n+        if (client == null) {\n+          break;\n+        }\n+        client.appendEntry(request, handler);\n+        raftMember.getLastCatchUpResponseTime().put(node, System.currentTimeMillis());\n+        isMatch.wait(RaftServer.connectionTimeoutInMS);\n+      }\n+      if (isMatch.get()) {\n+        // if follower return RESPONSE.AGREE with this empty log, then start sending real logs from this emptyContentLog's index.\n+        // which means the log which index is matchIndex will be send twice, but at the first time it sent an empty log.\n+        logs.subList(0, index).clear();\n+        if (logger.isDebugEnabled()) {\n+          logger.debug(\"{} makes {} catch up with {} cached logs\", raftMember.getName(), node,\n+              logs.size());\n+        }\n+        return false;\n+      }\n+      index--;\n+    }\n+    try {\n+      raftMember.getLogManager().takeSnapshot();\n+    } catch (IOException e) {\n+      logger.error(\"Unexpected error when taking snapshot.\", e);\n+    }\n+    snapshot = raftMember.getLogManager().getSnapshot();\n+    if (logger.isDebugEnabled()) {\n+      logger\n+          .debug(\"{}: Logs in {} are too old, catch up with snapshot\", raftMember.getName(), node);\n+    }\n+    return true;\n+  }\n+\n+  public void run() {\n+    try {\n+      if (checkMatchIndex()) {\n+        SnapshotCatchUpTask task = new SnapshotCatchUpTask(logs, snapshot, node, raftMember);\n+        task.run();\n+      } else {\n+        LogCatchUpTask task = new LogCatchUpTask(logs, node, raftMember);\n+        task.run();\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "701f328eb1ed191f38482f1d192fb067d1ec3d5d"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxNTc1Mg==", "bodyText": "Batched log catch-up or not is only related to the configuration item, and the code here supports batched log catch-up if related configuration item has been set~", "url": "https://github.com/apache/iotdb/pull/1157#discussion_r421215752", "createdAt": "2020-05-07T03:20:28Z", "author": {"login": "LebronAl"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/catchup/CatchUpTask.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.catchup;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.cluster.log.logtypes.EmptyContentLog;\n+import org.apache.iotdb.cluster.rpc.thrift.AppendEntryRequest;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.cluster.rpc.thrift.RaftService.AsyncClient;\n+import org.apache.iotdb.cluster.server.NodeCharacter;\n+import org.apache.iotdb.cluster.server.Peer;\n+import org.apache.iotdb.cluster.server.RaftServer;\n+import org.apache.iotdb.cluster.server.handlers.caller.LogCatchUpHandler;\n+import org.apache.iotdb.cluster.server.member.RaftMember;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CatchUpTask implements Runnable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(LogCatchUpTask.class);\n+\n+  private Node node;\n+  private Peer peer;\n+  private RaftMember raftMember;\n+  private Snapshot snapshot;\n+  private List<Log> logs;\n+\n+\n+  public CatchUpTask(Node node, Peer peer, RaftMember raftMember) {\n+    this.node = node;\n+    this.peer = peer;\n+    this.raftMember = raftMember;\n+    this.logs = Collections.emptyList();\n+    this.snapshot = null;\n+  }\n+\n+  boolean checkMatchIndex() throws TException, InterruptedException {\n+    AppendEntryRequest request = new AppendEntryRequest();\n+    AtomicBoolean isMatch = new AtomicBoolean(false);\n+\n+    LogCatchUpHandler handler = new LogCatchUpHandler();\n+    handler.setAppendSucceed(isMatch);\n+    handler.setRaftMember(raftMember);\n+    handler.setFollower(node);\n+    if (raftMember.getHeader() != null) {\n+      request.setHeader(raftMember.getHeader());\n+    }\n+    request.setLeader(raftMember.getThisNode());\n+    // not update follower's commitIndex in order to append the log which index is matchIndex twice\n+    request.setLeaderCommit(-1);\n+    synchronized (raftMember.getLogManager()) {\n+      peer.setNextIndex(raftMember.getLogManager().getLastLogIndex());\n+      try {\n+        logs = raftMember.getLogManager().getEntries(\n+            Math.max(raftMember.getLogManager().getFirstIndex(), peer.getMatchIndex() + 1),\n+            peer.getNextIndex() + 1);\n+      } catch (Exception e) {\n+        logger.error(\"Unexpected error in logManager's getEntries during matchIndexCheck\", e);\n+      }\n+    }\n+\n+    int index = logs.size() - 1;\n+    EmptyContentLog emptyLog = new EmptyContentLog();\n+    while (index >= 0) {\n+      Log log = logs.get(index);\n+      emptyLog.setCurrLogIndex(log.getCurrLogIndex());\n+      emptyLog.setCurrLogTerm(log.getCurrLogTerm());\n+      synchronized (raftMember.getTerm()) {\n+        // make sure this node is still a leader\n+        if (raftMember.getCharacter() != NodeCharacter.LEADER) {\n+          logger.debug(\"Leadership is lost when doing a catch-up to {}, aborting\", node);\n+          break;\n+        }\n+        request.setTerm(raftMember.getTerm().get());\n+      }\n+      if (index > 0) {\n+        request.setPrevLogIndex(logs.get(index - 1).getCurrLogIndex());\n+        request.setPrevLogTerm(logs.get(index - 1).getCurrLogTerm());\n+      } else {\n+        request.setPrevLogIndex(log.getCurrLogIndex() - 1);\n+        try {\n+          request.setPrevLogTerm(raftMember.getLogManager().getTerm(log.getCurrLogIndex() - 1));\n+        } catch (Exception e) {\n+          logger.error(\"getTerm failed for newly append entries\", e);\n+        }\n+      }\n+\n+      handler.setLog(log);\n+      request.setEntry(emptyLog.serialize());\n+\n+      synchronized (isMatch) {\n+        AsyncClient client = raftMember.connectNode(node);\n+        if (client == null) {\n+          break;\n+        }\n+        client.appendEntry(request, handler);\n+        raftMember.getLastCatchUpResponseTime().put(node, System.currentTimeMillis());\n+        isMatch.wait(RaftServer.connectionTimeoutInMS);\n+      }\n+      if (isMatch.get()) {\n+        // if follower return RESPONSE.AGREE with this empty log, then start sending real logs from this emptyContentLog's index.\n+        // which means the log which index is matchIndex will be send twice, but at the first time it sent an empty log.\n+        logs.subList(0, index).clear();\n+        if (logger.isDebugEnabled()) {\n+          logger.debug(\"{} makes {} catch up with {} cached logs\", raftMember.getName(), node,\n+              logs.size());\n+        }\n+        return false;\n+      }\n+      index--;\n+    }\n+    try {\n+      raftMember.getLogManager().takeSnapshot();\n+    } catch (IOException e) {\n+      logger.error(\"Unexpected error when taking snapshot.\", e);\n+    }\n+    snapshot = raftMember.getLogManager().getSnapshot();\n+    if (logger.isDebugEnabled()) {\n+      logger\n+          .debug(\"{}: Logs in {} are too old, catch up with snapshot\", raftMember.getName(), node);\n+    }\n+    return true;\n+  }\n+\n+  public void run() {\n+    try {\n+      if (checkMatchIndex()) {\n+        SnapshotCatchUpTask task = new SnapshotCatchUpTask(logs, snapshot, node, raftMember);\n+        task.run();\n+      } else {\n+        LogCatchUpTask task = new LogCatchUpTask(logs, node, raftMember);\n+        task.run();\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwMzgzMw=="}, "originalCommit": {"oid": "701f328eb1ed191f38482f1d192fb067d1ec3d5d"}, "originalPosition": 156}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4945, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}