{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyNTExOTM3", "number": 738, "title": "[IOTDB-396] New query clause: disable align", "bodyText": "", "createdAt": "2020-01-14T08:42:06Z", "url": "https://github.com/apache/iotdb/pull/738", "merged": true, "mergeCommit": {"oid": "08346cc47911ba3430f904a1bdf8979f9f150ada"}, "closed": true, "closedAt": "2020-01-15T05:47:48Z", "author": {"login": "JackieTien97"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb2VjKPgH2gAyMzYyNTExOTM3OjliNThiMmY1OTNjY2U4Y2M0MjUxYzEyNzU0N2RmMmMxYTI1ZjQ3MGE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb6e49NAFqTM0Mjk5Nzg2MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9b58b2f593cce8cc4251c127547df2c1a25f470a", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/9b58b2f593cce8cc4251c127547df2c1a25f470a", "committedDate": "2020-01-02T08:33:15Z", "message": "disable align clause"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bb9271b4a9b6aa90babd85bba1e06635e2bc861", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/7bb9271b4a9b6aa90babd85bba1e06635e2bc861", "committedDate": "2020-01-03T07:16:48Z", "message": "disable align"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e2922db61878d899ff04c8bf7c72a7a3f8f480b", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/9e2922db61878d899ff04c8bf7c72a7a3f8f480b", "committedDate": "2020-01-03T08:48:41Z", "message": "fix a bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "618e0250bbdcd23f3f58acb0343ea7b515caf0c7", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/618e0250bbdcd23f3f58acb0343ea7b515caf0c7", "committedDate": "2020-01-03T12:34:37Z", "message": "merge master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bac8652dd9ab51a6c460caa54014b87081916326", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/bac8652dd9ab51a6c460caa54014b87081916326", "committedDate": "2020-01-06T02:36:30Z", "message": "fix a bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2b0295b409ebcdaa9bddf7f880424e053ff9a04", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/c2b0295b409ebcdaa9bddf7f880424e053ff9a04", "committedDate": "2020-01-06T04:58:14Z", "message": "Merge branch 'master' of https://github.com/apache/incubator-iotdb into new_query_interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b598149069779aa47cfe9ddd9214df9fb6028c0f", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/b598149069779aa47cfe9ddd9214df9fb6028c0f", "committedDate": "2020-01-06T05:06:56Z", "message": "merge master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cfc8145e4a6b4b83850ef2cb89451cfff15f585", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/9cfc8145e4a6b4b83850ef2cb89451cfff15f585", "committedDate": "2020-01-06T05:33:06Z", "message": "add license to new file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71179e60497b1be461ba5acaa6dbb39d389648c2", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/71179e60497b1be461ba5acaa6dbb39d389648c2", "committedDate": "2020-01-07T12:42:51Z", "message": "Merge branch 'master' of https://github.com/apache/incubator-iotdb into new_query_interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5251c276a61467f1cb639bafc1974c43ae7ef07a", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/5251c276a61467f1cb639bafc1974c43ae7ef07a", "committedDate": "2020-01-09T12:44:17Z", "message": "update disable align"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af597cd63d9e0a963fc7af8ad5840f5f21df39ca", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/af597cd63d9e0a963fc7af8ad5840f5f21df39ca", "committedDate": "2020-01-10T04:59:09Z", "message": "resolve conflict and fix bugs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd9cef9e0878937c8ce87de114e3485471fffcd6", "author": {"user": {"login": "HTHou", "name": "Haonan"}}, "url": "https://github.com/apache/iotdb/commit/cd9cef9e0878937c8ce87de114e3485471fffcd6", "committedDate": "2020-01-10T05:45:02Z", "message": "fix test errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be4b8af0d06f2cd58c162b3f147e9f9f0237309a", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/be4b8af0d06f2cd58c162b3f147e9f9f0237309a", "committedDate": "2020-01-14T07:56:03Z", "message": "s"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a52c63d5ab7be97bf4bdd009aa66c783a7f2b5ed", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/a52c63d5ab7be97bf4bdd009aa66c783a7f2b5ed", "committedDate": "2020-01-14T07:56:58Z", "message": "s"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f8d5701d0d8004ec41404cf91976912261591aa", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/8f8d5701d0d8004ec41404cf91976912261591aa", "committedDate": "2020-01-14T07:57:39Z", "message": "complete"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/3ee98df2f6659a55dd407a1e28d1ebadddf304b5", "committedDate": "2020-01-14T08:40:41Z", "message": "Disable align"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "415fa3f0c22f8bf9a3197aaea32f6e50179f2473", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/415fa3f0c22f8bf9a3197aaea32f6e50179f2473", "committedDate": "2020-01-14T09:09:06Z", "message": "Recover JDBC_EXAMPLE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d969808f81b365e4530721b74c4c7b496a05cfe8", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/d969808f81b365e4530721b74c4c7b496a05cfe8", "committedDate": "2020-01-14T11:46:09Z", "message": " re-interrupt the method while occurring InterruptedException"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMzc1MTA2", "url": "https://github.com/apache/iotdb/pull/738#pullrequestreview-342375106", "createdAt": "2020-01-14T09:03:26Z", "commit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwOTowMzoyNlrOFdQMVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxMTo1Mzo1OVrOFdU_lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIxODMyNw==", "bodyText": "If the timestamp is truly a \"0\", will it be translated into space? If so, I don't think it is reasonable.", "url": "https://github.com/apache/iotdb/pull/738#discussion_r366218327", "createdAt": "2020-01-14T09:03:26Z", "author": {"login": "jt2594838"}, "path": "client/src/main/java/org/apache/iotdb/client/AbstractClient.java", "diffHunk": "@@ -261,28 +270,46 @@ private static void printShow(int colCount, ResultSet res) throws SQLException {\n     println();\n   }\n \n-  private static void printRowData(boolean printTimestamp, ResultSet res, ZoneId zoneId,\n+  private static void printRowData(boolean printTimestamp, boolean align, ResultSet res, ZoneId zoneId,\n       ResultSetMetaData resultSetMetaData, int colCount)\n       throws SQLException {\n     if (displayCnt < maxPrintRowCount) { // NOTE displayCnt only works on queried data results\n       print(\"|\");\n-      if (printTimestamp) {\n-        printf(formatTime, formatDatetime(res.getLong(TIMESTAMP_STR), zoneId));\n-        for (int i = 2; i <= colCount; i++) {\n-          printColumnData(resultSetMetaData, res, i, zoneId);\n+      if (align) {\n+        if (printTimestamp) {\n+          printf(formatTime, formatDatetime(res.getLong(TIMESTAMP_STR), zoneId));\n+          for (int i = 2; i <= colCount; i++) {\n+            printColumnData(resultSetMetaData, align, res, i, zoneId);\n+          }\n+        } else {\n+          for (int i = 1; i <= colCount; i++) {\n+            printColumnData(resultSetMetaData, align, res, i, zoneId);\n+          }\n         }\n-      } else {\n-        for (int i = 1; i <= colCount; i++) {\n-          printf(formatValue, res.getString(i));\n+      }\n+      else {\n+        for (int i = 2; i <= colCount / 2 + 1; i++) {\n+          if (printTimestamp) {\n+            // timeLabel used for indicating the time column.\n+            String timeLabel = TIMESTAMP_STR + resultSetMetaData.getColumnLabel(2 * i - 2);\n+            if (res.getLong(timeLabel) == 0) {\n+              // blank space\n+              printf(formatTime, \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIxOTQ2Mw==", "bodyText": "These \"2\"s appear frequently, I suggest replace them with a constant and add a comment for the constant to explain what column is skipped.", "url": "https://github.com/apache/iotdb/pull/738#discussion_r366219463", "createdAt": "2020-01-14T09:06:10Z", "author": {"login": "jt2594838"}, "path": "client/src/main/java/org/apache/iotdb/client/AbstractClient.java", "diffHunk": "@@ -297,13 +324,24 @@ private static void printColumnData(ResultSetMetaData resultSetMetaData, ResultS\n         printf(formatValue, \"null\");\n         handleException(e);\n       }\n-    } else {\n+    } \n+    else if (align) {\n       if (i == 2 && resultSetMetaData.getColumnName(2).equals(GROUPBY_DEVICE_COLUMN_NAME)) {\n         printf(\"%\" + deviceColumnLength + \"s|\", res.getString(i));\n       } else {\n         printf(formatValue, res.getString(i));\n       }\n     }\n+    // for disable align clause\n+    else {\n+      if (res.getString(i * 2 - 2) == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIyNDEyMg==", "bodyText": "Why remove the license\uff1f", "url": "https://github.com/apache/iotdb/pull/738#discussion_r366224122", "createdAt": "2020-01-14T09:16:14Z", "author": {"login": "jt2594838"}, "path": "example/jdbc/src/main/java/org/apache/iotdb/JDBCExample.java", "diffHunk": "@@ -1,21 +1,3 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n package org.apache.iotdb;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIyNDcyOA==", "bodyText": "I don't think you should remove the old examples unless they are incorrect, you should only add the new ones.", "url": "https://github.com/apache/iotdb/pull/738#discussion_r366224728", "createdAt": "2020-01-14T09:17:42Z", "author": {"login": "jt2594838"}, "path": "example/jdbc/src/main/java/org/apache/iotdb/JDBCExample.java", "diffHunk": "@@ -31,23 +13,11 @@ public static void main(String[] args) throws ClassNotFoundException, SQLExcepti\n     Class.forName(\"org.apache.iotdb.jdbc.IoTDBDriver\");\n     try (Connection connection = DriverManager.getConnection(\"jdbc:iotdb://127.0.0.1:6667/\", \"root\", \"root\");\n          Statement statement = connection.createStatement()) {\n-      statement.execute(\"SET STORAGE GROUP TO root.sg1\");\n-      statement.execute(\"CREATE TIMESERIES root.sg1.d1.s1 WITH DATATYPE=INT64, ENCODING=RLE\");\n-      statement.execute(\"CREATE TIMESERIES root.sg1.d1.s2 WITH DATATYPE=INT64, ENCODING=RLE\");\n-      statement.execute(\"CREATE TIMESERIES root.sg1.d1.s3 WITH DATATYPE=INT64, ENCODING=RLE\");\n-\n-      for (int i = 0; i <= 100; i++) {\n-        statement.addBatch(\"insert into root.sg1.d1(timestamp, s1, s2, s3) values(\"+ i + \",\" + 1 + \",\" + 1 + \",\" + 1 + \")\");\n-      }\n-      statement.executeBatch();\n-      statement.clearBatch();\n-\n-      ResultSet resultSet = statement.executeQuery(\"select * from root where time <= 10\");\n-      outputResult(resultSet);\n-      resultSet = statement.executeQuery(\"select count(*) from root\");\n-      outputResult(resultSet);\n-      resultSet = statement.executeQuery(\"select count(*) from root where time >= 1 and time <= 100 group by ([0, 100], 20ms, 20ms)\");\n+      long startTime = System.currentTimeMillis();\n+      ResultSet resultSet = statement.executeQuery(\"select * from root where time < 100000000 disable align\");\n       outputResult(resultSet);\n+      long endTime = System.currentTimeMillis();\n+      System.out.println(\"Cost Time: \" + (endTime - startTime));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIyNTg5Mg==", "bodyText": "It would be better if you just make it a List of TsDataType, it is unnecessary to convert a string to TsDataType every time.", "url": "https://github.com/apache/iotdb/pull/738#discussion_r366225892", "createdAt": "2020-01-14T09:20:20Z", "author": {"login": "jt2594838"}, "path": "jdbc/src/main/java/org/apache/iotdb/jdbc/IoTDBNonAlignQueryResultSet.java", "diffHunk": "@@ -0,0 +1,1289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.jdbc;\n+\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.rpc.RpcUtils;\n+import org.apache.iotdb.service.rpc.thrift.*;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.BytesUtils;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.apache.thrift.TException;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.math.MathContext;\n+import java.net.URL;\n+import java.nio.ByteBuffer;\n+import java.sql.Date;\n+import java.sql.*;\n+import java.util.*;\n+\n+public class IoTDBNonAlignQueryResultSet implements ResultSet {\n+\n+  private static final String TIMESTAMP_STR = \"Time\";\n+  private static final int TIMESTAMP_STR_LENGTH = 4;\n+  private static final int START_INDEX = 2;\n+  private static final String VALUE_IS_NULL = \"The value got by %s (column name) is NULL.\";\n+  private static final String EMPTY_STR = \"\";\n+  private Statement statement = null;\n+  private String sql;\n+  private SQLWarning warningChain = null;\n+  private boolean isClosed = false;\n+  private TSIService.Iface client = null;\n+  private List<String> columnInfoList; // no deduplication\n+  private List<String> columnTypeList; // no deduplication\n+  private Map<String, Integer> columnInfoMap; // used because the server returns deduplicated columns\n+  private List<String> columnTypeDeduplicatedList; // deduplicated from columnTypeList", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIyNjU0Nw==", "bodyText": "\"Info\" is too ambiguous, just call it \"columnName\".", "url": "https://github.com/apache/iotdb/pull/738#discussion_r366226547", "createdAt": "2020-01-14T09:21:38Z", "author": {"login": "jt2594838"}, "path": "jdbc/src/main/java/org/apache/iotdb/jdbc/IoTDBNonAlignQueryResultSet.java", "diffHunk": "@@ -0,0 +1,1289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.jdbc;\n+\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.rpc.RpcUtils;\n+import org.apache.iotdb.service.rpc.thrift.*;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.BytesUtils;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.apache.thrift.TException;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.math.MathContext;\n+import java.net.URL;\n+import java.nio.ByteBuffer;\n+import java.sql.Date;\n+import java.sql.*;\n+import java.util.*;\n+\n+public class IoTDBNonAlignQueryResultSet implements ResultSet {\n+\n+  private static final String TIMESTAMP_STR = \"Time\";\n+  private static final int TIMESTAMP_STR_LENGTH = 4;\n+  private static final int START_INDEX = 2;\n+  private static final String VALUE_IS_NULL = \"The value got by %s (column name) is NULL.\";\n+  private static final String EMPTY_STR = \"\";\n+  private Statement statement = null;\n+  private String sql;\n+  private SQLWarning warningChain = null;\n+  private boolean isClosed = false;\n+  private TSIService.Iface client = null;\n+  private List<String> columnInfoList; // no deduplication", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIyNzM5MQ==", "bodyText": "It would be more clear to call it \"columnBufferPositionMap\" or \"columnOrdinalMap\" or something else.", "url": "https://github.com/apache/iotdb/pull/738#discussion_r366227391", "createdAt": "2020-01-14T09:23:29Z", "author": {"login": "jt2594838"}, "path": "jdbc/src/main/java/org/apache/iotdb/jdbc/IoTDBNonAlignQueryResultSet.java", "diffHunk": "@@ -0,0 +1,1289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.jdbc;\n+\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.rpc.RpcUtils;\n+import org.apache.iotdb.service.rpc.thrift.*;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.BytesUtils;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.apache.thrift.TException;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.math.MathContext;\n+import java.net.URL;\n+import java.nio.ByteBuffer;\n+import java.sql.Date;\n+import java.sql.*;\n+import java.util.*;\n+\n+public class IoTDBNonAlignQueryResultSet implements ResultSet {\n+\n+  private static final String TIMESTAMP_STR = \"Time\";\n+  private static final int TIMESTAMP_STR_LENGTH = 4;\n+  private static final int START_INDEX = 2;\n+  private static final String VALUE_IS_NULL = \"The value got by %s (column name) is NULL.\";\n+  private static final String EMPTY_STR = \"\";\n+  private Statement statement = null;\n+  private String sql;\n+  private SQLWarning warningChain = null;\n+  private boolean isClosed = false;\n+  private TSIService.Iface client = null;\n+  private List<String> columnInfoList; // no deduplication\n+  private List<String> columnTypeList; // no deduplication\n+  private Map<String, Integer> columnInfoMap; // used because the server returns deduplicated columns", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIyOTM2Mg==", "bodyText": "Always keep the stack trace unless you are sure the exception is minor.\nthrow new SQLException(\"Error occurs when connecting to server for close operation \", e);", "url": "https://github.com/apache/iotdb/pull/738#discussion_r366229362", "createdAt": "2020-01-14T09:27:33Z", "author": {"login": "jt2594838"}, "path": "jdbc/src/main/java/org/apache/iotdb/jdbc/IoTDBNonAlignQueryResultSet.java", "diffHunk": "@@ -0,0 +1,1289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.jdbc;\n+\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.rpc.RpcUtils;\n+import org.apache.iotdb.service.rpc.thrift.*;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.BytesUtils;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.apache.thrift.TException;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.math.MathContext;\n+import java.net.URL;\n+import java.nio.ByteBuffer;\n+import java.sql.Date;\n+import java.sql.*;\n+import java.util.*;\n+\n+public class IoTDBNonAlignQueryResultSet implements ResultSet {\n+\n+  private static final String TIMESTAMP_STR = \"Time\";\n+  private static final int TIMESTAMP_STR_LENGTH = 4;\n+  private static final int START_INDEX = 2;\n+  private static final String VALUE_IS_NULL = \"The value got by %s (column name) is NULL.\";\n+  private static final String EMPTY_STR = \"\";\n+  private Statement statement = null;\n+  private String sql;\n+  private SQLWarning warningChain = null;\n+  private boolean isClosed = false;\n+  private TSIService.Iface client = null;\n+  private List<String> columnInfoList; // no deduplication\n+  private List<String> columnTypeList; // no deduplication\n+  private Map<String, Integer> columnInfoMap; // used because the server returns deduplicated columns\n+  private List<String> columnTypeDeduplicatedList; // deduplicated from columnTypeList\n+  private int fetchSize;\n+  private boolean emptyResultSet = false;\n+\n+  private TSQueryNonAlignDataSet tsQueryNonAlignDataSet = null;\n+  private byte[][] times; // used for disable align\n+  private byte[][] values; // used to cache the current row record value\n+\n+  private long sessionId;\n+  private long queryId;\n+  private boolean ignoreTimeStamp = false;\n+\n+  public IoTDBNonAlignQueryResultSet() {\n+    // do nothing\n+  }\n+\n+  // for disable align clause\n+  public IoTDBNonAlignQueryResultSet(Statement statement, List<String> columnNameList,\n+                                     List<String> columnTypeList, boolean ignoreTimeStamp, TSIService.Iface client,\n+                                     String sql, long queryId, long sessionId, TSQueryNonAlignDataSet dataset)\n+          throws SQLException {\n+    this.statement = statement;\n+    this.fetchSize = statement.getFetchSize();\n+    this.columnTypeList = columnTypeList;\n+\n+    times = new byte[columnNameList.size()][Long.BYTES];\n+    values = new byte[columnNameList.size()][];\n+\n+    this.columnInfoList = new ArrayList<>();\n+    // deduplicate and map\n+    this.columnInfoMap = new HashMap<>();\n+    this.columnInfoMap.put(TIMESTAMP_STR, 1);\n+    this.columnTypeDeduplicatedList = new ArrayList<>();\n+    int index = START_INDEX;\n+    for (int i = 0; i < columnNameList.size(); i++) {\n+      String name = columnNameList.get(i);\n+      columnInfoList.add(TIMESTAMP_STR + name);\n+      columnInfoList.add(name);\n+      if (!columnInfoMap.containsKey(name)) {\n+        columnInfoMap.put(name, index++);\n+        columnTypeDeduplicatedList.add(columnTypeList.get(i));\n+      }\n+    }\n+\n+    this.ignoreTimeStamp = ignoreTimeStamp;\n+    this.client = client;\n+    this.sql = sql;\n+    this.queryId = queryId;\n+    this.tsQueryNonAlignDataSet = dataset;\n+    this.sessionId = sessionId;\n+  }\n+\n+  @Override\n+  public boolean isWrapperFor(Class<?> iface) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public <T> T unwrap(Class<T> iface) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public boolean absolute(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void afterLast() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void beforeFirst() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void cancelRowUpdates() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void clearWarnings() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void close() throws SQLException {\n+    if (isClosed) {\n+      return;\n+    }\n+    if (client != null) {\n+      try {\n+        TSCloseOperationReq closeReq = new TSCloseOperationReq(sessionId);\n+        closeReq.setQueryId(queryId);\n+        TSStatus closeResp = client.closeOperation(closeReq);\n+        RpcUtils.verifySuccess(closeResp);\n+      } catch (IoTDBRPCException e) {\n+        throw new SQLException(\"Error occurs for close opeation in server side becasuse \" + e);\n+      } catch (TException e) {\n+        throw new SQLException(\n+                \"Error occurs when connecting to server for close operation, becasue: \" + e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIzMDEzOA==", "bodyText": "These methods are duplicated with the aligned one, better to extract them into a base class like \"IoTDBResultSet\".", "url": "https://github.com/apache/iotdb/pull/738#discussion_r366230138", "createdAt": "2020-01-14T09:29:05Z", "author": {"login": "jt2594838"}, "path": "jdbc/src/main/java/org/apache/iotdb/jdbc/IoTDBNonAlignQueryResultSet.java", "diffHunk": "@@ -0,0 +1,1289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.jdbc;\n+\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.rpc.RpcUtils;\n+import org.apache.iotdb.service.rpc.thrift.*;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.BytesUtils;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.apache.thrift.TException;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.math.MathContext;\n+import java.net.URL;\n+import java.nio.ByteBuffer;\n+import java.sql.Date;\n+import java.sql.*;\n+import java.util.*;\n+\n+public class IoTDBNonAlignQueryResultSet implements ResultSet {\n+\n+  private static final String TIMESTAMP_STR = \"Time\";\n+  private static final int TIMESTAMP_STR_LENGTH = 4;\n+  private static final int START_INDEX = 2;\n+  private static final String VALUE_IS_NULL = \"The value got by %s (column name) is NULL.\";\n+  private static final String EMPTY_STR = \"\";\n+  private Statement statement = null;\n+  private String sql;\n+  private SQLWarning warningChain = null;\n+  private boolean isClosed = false;\n+  private TSIService.Iface client = null;\n+  private List<String> columnInfoList; // no deduplication\n+  private List<String> columnTypeList; // no deduplication\n+  private Map<String, Integer> columnInfoMap; // used because the server returns deduplicated columns\n+  private List<String> columnTypeDeduplicatedList; // deduplicated from columnTypeList\n+  private int fetchSize;\n+  private boolean emptyResultSet = false;\n+\n+  private TSQueryNonAlignDataSet tsQueryNonAlignDataSet = null;\n+  private byte[][] times; // used for disable align\n+  private byte[][] values; // used to cache the current row record value\n+\n+  private long sessionId;\n+  private long queryId;\n+  private boolean ignoreTimeStamp = false;\n+\n+  public IoTDBNonAlignQueryResultSet() {\n+    // do nothing\n+  }\n+\n+  // for disable align clause\n+  public IoTDBNonAlignQueryResultSet(Statement statement, List<String> columnNameList,\n+                                     List<String> columnTypeList, boolean ignoreTimeStamp, TSIService.Iface client,\n+                                     String sql, long queryId, long sessionId, TSQueryNonAlignDataSet dataset)\n+          throws SQLException {\n+    this.statement = statement;\n+    this.fetchSize = statement.getFetchSize();\n+    this.columnTypeList = columnTypeList;\n+\n+    times = new byte[columnNameList.size()][Long.BYTES];\n+    values = new byte[columnNameList.size()][];\n+\n+    this.columnInfoList = new ArrayList<>();\n+    // deduplicate and map\n+    this.columnInfoMap = new HashMap<>();\n+    this.columnInfoMap.put(TIMESTAMP_STR, 1);\n+    this.columnTypeDeduplicatedList = new ArrayList<>();\n+    int index = START_INDEX;\n+    for (int i = 0; i < columnNameList.size(); i++) {\n+      String name = columnNameList.get(i);\n+      columnInfoList.add(TIMESTAMP_STR + name);\n+      columnInfoList.add(name);\n+      if (!columnInfoMap.containsKey(name)) {\n+        columnInfoMap.put(name, index++);\n+        columnTypeDeduplicatedList.add(columnTypeList.get(i));\n+      }\n+    }\n+\n+    this.ignoreTimeStamp = ignoreTimeStamp;\n+    this.client = client;\n+    this.sql = sql;\n+    this.queryId = queryId;\n+    this.tsQueryNonAlignDataSet = dataset;\n+    this.sessionId = sessionId;\n+  }\n+\n+  @Override\n+  public boolean isWrapperFor(Class<?> iface) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public <T> T unwrap(Class<T> iface) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public boolean absolute(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void afterLast() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void beforeFirst() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void cancelRowUpdates() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void clearWarnings() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void close() throws SQLException {\n+    if (isClosed) {\n+      return;\n+    }\n+    if (client != null) {\n+      try {\n+        TSCloseOperationReq closeReq = new TSCloseOperationReq(sessionId);\n+        closeReq.setQueryId(queryId);\n+        TSStatus closeResp = client.closeOperation(closeReq);\n+        RpcUtils.verifySuccess(closeResp);\n+      } catch (IoTDBRPCException e) {\n+        throw new SQLException(\"Error occurs for close opeation in server side becasuse \" + e);\n+      } catch (TException e) {\n+        throw new SQLException(\n+                \"Error occurs when connecting to server for close operation, becasue: \" + e);\n+      }\n+    }\n+    client = null;\n+    isClosed = true;\n+  }\n+\n+\n+  @Override\n+  public void deleteRow() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public int findColumn(String columnName) {\n+    return columnInfoMap.get(columnName);\n+  }\n+\n+  @Override\n+  public boolean first() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI2NjE1Nw==", "bodyText": "I have to say, your current way of dealing with null values is not satisfactory, maybe a bitmap will help.", "url": "https://github.com/apache/iotdb/pull/738#discussion_r366266157", "createdAt": "2020-01-14T10:40:48Z", "author": {"login": "jt2594838"}, "path": "jdbc/src/main/java/org/apache/iotdb/jdbc/IoTDBNonAlignQueryResultSet.java", "diffHunk": "@@ -0,0 +1,1289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.jdbc;\n+\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.rpc.RpcUtils;\n+import org.apache.iotdb.service.rpc.thrift.*;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.BytesUtils;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.apache.thrift.TException;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.math.MathContext;\n+import java.net.URL;\n+import java.nio.ByteBuffer;\n+import java.sql.Date;\n+import java.sql.*;\n+import java.util.*;\n+\n+public class IoTDBNonAlignQueryResultSet implements ResultSet {\n+\n+  private static final String TIMESTAMP_STR = \"Time\";\n+  private static final int TIMESTAMP_STR_LENGTH = 4;\n+  private static final int START_INDEX = 2;\n+  private static final String VALUE_IS_NULL = \"The value got by %s (column name) is NULL.\";\n+  private static final String EMPTY_STR = \"\";\n+  private Statement statement = null;\n+  private String sql;\n+  private SQLWarning warningChain = null;\n+  private boolean isClosed = false;\n+  private TSIService.Iface client = null;\n+  private List<String> columnInfoList; // no deduplication\n+  private List<String> columnTypeList; // no deduplication\n+  private Map<String, Integer> columnInfoMap; // used because the server returns deduplicated columns\n+  private List<String> columnTypeDeduplicatedList; // deduplicated from columnTypeList\n+  private int fetchSize;\n+  private boolean emptyResultSet = false;\n+\n+  private TSQueryNonAlignDataSet tsQueryNonAlignDataSet = null;\n+  private byte[][] times; // used for disable align\n+  private byte[][] values; // used to cache the current row record value\n+\n+  private long sessionId;\n+  private long queryId;\n+  private boolean ignoreTimeStamp = false;\n+\n+  public IoTDBNonAlignQueryResultSet() {\n+    // do nothing\n+  }\n+\n+  // for disable align clause\n+  public IoTDBNonAlignQueryResultSet(Statement statement, List<String> columnNameList,\n+                                     List<String> columnTypeList, boolean ignoreTimeStamp, TSIService.Iface client,\n+                                     String sql, long queryId, long sessionId, TSQueryNonAlignDataSet dataset)\n+          throws SQLException {\n+    this.statement = statement;\n+    this.fetchSize = statement.getFetchSize();\n+    this.columnTypeList = columnTypeList;\n+\n+    times = new byte[columnNameList.size()][Long.BYTES];\n+    values = new byte[columnNameList.size()][];\n+\n+    this.columnInfoList = new ArrayList<>();\n+    // deduplicate and map\n+    this.columnInfoMap = new HashMap<>();\n+    this.columnInfoMap.put(TIMESTAMP_STR, 1);\n+    this.columnTypeDeduplicatedList = new ArrayList<>();\n+    int index = START_INDEX;\n+    for (int i = 0; i < columnNameList.size(); i++) {\n+      String name = columnNameList.get(i);\n+      columnInfoList.add(TIMESTAMP_STR + name);\n+      columnInfoList.add(name);\n+      if (!columnInfoMap.containsKey(name)) {\n+        columnInfoMap.put(name, index++);\n+        columnTypeDeduplicatedList.add(columnTypeList.get(i));\n+      }\n+    }\n+\n+    this.ignoreTimeStamp = ignoreTimeStamp;\n+    this.client = client;\n+    this.sql = sql;\n+    this.queryId = queryId;\n+    this.tsQueryNonAlignDataSet = dataset;\n+    this.sessionId = sessionId;\n+  }\n+\n+  @Override\n+  public boolean isWrapperFor(Class<?> iface) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public <T> T unwrap(Class<T> iface) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public boolean absolute(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void afterLast() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void beforeFirst() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void cancelRowUpdates() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void clearWarnings() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void close() throws SQLException {\n+    if (isClosed) {\n+      return;\n+    }\n+    if (client != null) {\n+      try {\n+        TSCloseOperationReq closeReq = new TSCloseOperationReq(sessionId);\n+        closeReq.setQueryId(queryId);\n+        TSStatus closeResp = client.closeOperation(closeReq);\n+        RpcUtils.verifySuccess(closeResp);\n+      } catch (IoTDBRPCException e) {\n+        throw new SQLException(\"Error occurs for close opeation in server side becasuse \" + e);\n+      } catch (TException e) {\n+        throw new SQLException(\n+                \"Error occurs when connecting to server for close operation, becasue: \" + e);\n+      }\n+    }\n+    client = null;\n+    isClosed = true;\n+  }\n+\n+\n+  @Override\n+  public void deleteRow() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public int findColumn(String columnName) {\n+    return columnInfoMap.get(columnName);\n+  }\n+\n+  @Override\n+  public boolean first() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Array getArray(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Array getArray(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public InputStream getAsciiStream(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public InputStream getAsciiStream(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public BigDecimal getBigDecimal(int columnIndex) throws SQLException {\n+    return getBigDecimal(findColumnNameByIndex(columnIndex));\n+  }\n+\n+  @Override\n+  public BigDecimal getBigDecimal(String columnName) throws SQLException {\n+    return new BigDecimal(Objects.requireNonNull(getValueByName(columnName)));\n+  }\n+\n+  @Override\n+  public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {\n+    MathContext mc = new MathContext(scale);\n+    return getBigDecimal(columnIndex).round(mc);\n+  }\n+\n+  @Override\n+  public BigDecimal getBigDecimal(String columnName, int scale) throws SQLException {\n+    return getBigDecimal(findColumn(columnName), scale);\n+  }\n+\n+  @Override\n+  public InputStream getBinaryStream(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public InputStream getBinaryStream(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Blob getBlob(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Blob getBlob(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int columnIndex) throws SQLException {\n+    return getBoolean(findColumnNameByIndex(columnIndex));\n+  }\n+\n+  @Override\n+  public boolean getBoolean(String columnName) throws SQLException {\n+    checkRecord();\n+    int index = columnInfoMap.get(columnName) - START_INDEX;\n+    if (values[index] != null) {\n+      return BytesUtils.bytesToBool(values[index]);\n+    }\n+    else {\n+      throw new SQLException(String.format(VALUE_IS_NULL, columnName));\n+    }\n+  }\n+\n+  @Override\n+  public byte getByte(int columnIndex) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public byte getByte(String columnName) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public byte[] getBytes(int columnIndex) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public byte[] getBytes(String columnName) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Reader getCharacterStream(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Reader getCharacterStream(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Clob getClob(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Clob getClob(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public int getConcurrency() {\n+    return ResultSet.CONCUR_READ_ONLY;\n+  }\n+\n+  @Override\n+  public String getCursorName() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Date getDate(int columnIndex) throws SQLException {\n+    return new Date(getLong(columnIndex));\n+  }\n+\n+  @Override\n+  public Date getDate(String columnName) throws SQLException {\n+    return getDate(findColumn(columnName));\n+  }\n+\n+  @Override\n+  public Date getDate(int arg0, Calendar arg1) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Date getDate(String arg0, Calendar arg1) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public double getDouble(int columnIndex) throws SQLException {\n+    return getDouble(findColumnNameByIndex(columnIndex));\n+  }\n+\n+  @Override\n+  public double getDouble(String columnName) throws SQLException {\n+    checkRecord();\n+    int index = columnInfoMap.get(columnName) - START_INDEX;\n+    if (values[index] != null) {\n+      return BytesUtils.bytesToDouble(values[index]);\n+    } else {\n+      throw new SQLException(String.format(VALUE_IS_NULL, columnName));\n+    }\n+  }\n+\n+  @Override\n+  public int getFetchDirection() throws SQLException {\n+    return ResultSet.FETCH_FORWARD;\n+  }\n+\n+  @Override\n+  public void setFetchDirection(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public int getFetchSize() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void setFetchSize(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public float getFloat(int columnIndex) throws SQLException {\n+    return getFloat(findColumnNameByIndex(columnIndex));\n+  }\n+\n+  @Override\n+  public float getFloat(String columnName) throws SQLException {\n+    checkRecord();\n+    int index = columnInfoMap.get(columnName) - START_INDEX;\n+    if (values[index] != null) {\n+      return BytesUtils.bytesToFloat(values[index]);\n+    } else {\n+      throw new SQLException(String.format(VALUE_IS_NULL, columnName));\n+    }\n+  }\n+\n+  @Override\n+  public int getHoldability() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public int getInt(int columnIndex) throws SQLException {\n+    return getInt(findColumnNameByIndex(columnIndex));\n+  }\n+\n+  @Override\n+  public int getInt(String columnName) throws SQLException {\n+    checkRecord();\n+    int index = columnInfoMap.get(columnName) - START_INDEX;\n+    if (values[index] != null) {\n+      return BytesUtils.bytesToInt(values[index]);\n+    } else {\n+      throw new SQLException(String.format(VALUE_IS_NULL, columnName));\n+    }\n+  }\n+\n+  @Override\n+  public long getLong(int columnIndex) throws SQLException {\n+    return getLong(findColumnNameByIndex(columnIndex));\n+  }\n+\n+  @Override\n+  public long getLong(String columnName) throws SQLException {\n+    checkRecord();\n+    if (columnName.startsWith(TIMESTAMP_STR)) {\n+      String column = columnName.substring(TIMESTAMP_STR_LENGTH);\n+      int index = columnInfoMap.get(column) - START_INDEX;\n+      return BytesUtils.bytesToLong(times[index]);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5"}, "originalPosition": 414}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI3MzE3Nw==", "bodyText": "You set times[i] and values[i] to null every time, so I can not see the point of if (times[i] == null).\nBy the way, I think it is not necessary to copy the data out of the ByteBuffer, you may just get the value from the origin ByteBuffer (except the text type). The following code explains how to do so in a simplified way.\nprivate int rowIndex;\n...\npublic long getLong(String columnName) {\n    int columnNum = positionOfColumn(columnName);\n    ByteBuffer buffer = tsQueryNonAlignDataSet.valueList.get(columnNum);\n    if (buffer.limit() < rowIndex * Long.BYTES) {\n        // report a null value\n    } else {\n        buffer.position(rowIndex * Long.BYTES);\n        return buffer.getLong();\n    }\n}\n\npublic void next() {\n  // check if the index of out all ranges\n  rowIndex ++;\n}", "url": "https://github.com/apache/iotdb/pull/738#discussion_r366273177", "createdAt": "2020-01-14T10:55:35Z", "author": {"login": "jt2594838"}, "path": "jdbc/src/main/java/org/apache/iotdb/jdbc/IoTDBNonAlignQueryResultSet.java", "diffHunk": "@@ -0,0 +1,1289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.jdbc;\n+\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.rpc.RpcUtils;\n+import org.apache.iotdb.service.rpc.thrift.*;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.BytesUtils;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.apache.thrift.TException;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.math.MathContext;\n+import java.net.URL;\n+import java.nio.ByteBuffer;\n+import java.sql.Date;\n+import java.sql.*;\n+import java.util.*;\n+\n+public class IoTDBNonAlignQueryResultSet implements ResultSet {\n+\n+  private static final String TIMESTAMP_STR = \"Time\";\n+  private static final int TIMESTAMP_STR_LENGTH = 4;\n+  private static final int START_INDEX = 2;\n+  private static final String VALUE_IS_NULL = \"The value got by %s (column name) is NULL.\";\n+  private static final String EMPTY_STR = \"\";\n+  private Statement statement = null;\n+  private String sql;\n+  private SQLWarning warningChain = null;\n+  private boolean isClosed = false;\n+  private TSIService.Iface client = null;\n+  private List<String> columnInfoList; // no deduplication\n+  private List<String> columnTypeList; // no deduplication\n+  private Map<String, Integer> columnInfoMap; // used because the server returns deduplicated columns\n+  private List<String> columnTypeDeduplicatedList; // deduplicated from columnTypeList\n+  private int fetchSize;\n+  private boolean emptyResultSet = false;\n+\n+  private TSQueryNonAlignDataSet tsQueryNonAlignDataSet = null;\n+  private byte[][] times; // used for disable align\n+  private byte[][] values; // used to cache the current row record value\n+\n+  private long sessionId;\n+  private long queryId;\n+  private boolean ignoreTimeStamp = false;\n+\n+  public IoTDBNonAlignQueryResultSet() {\n+    // do nothing\n+  }\n+\n+  // for disable align clause\n+  public IoTDBNonAlignQueryResultSet(Statement statement, List<String> columnNameList,\n+                                     List<String> columnTypeList, boolean ignoreTimeStamp, TSIService.Iface client,\n+                                     String sql, long queryId, long sessionId, TSQueryNonAlignDataSet dataset)\n+          throws SQLException {\n+    this.statement = statement;\n+    this.fetchSize = statement.getFetchSize();\n+    this.columnTypeList = columnTypeList;\n+\n+    times = new byte[columnNameList.size()][Long.BYTES];\n+    values = new byte[columnNameList.size()][];\n+\n+    this.columnInfoList = new ArrayList<>();\n+    // deduplicate and map\n+    this.columnInfoMap = new HashMap<>();\n+    this.columnInfoMap.put(TIMESTAMP_STR, 1);\n+    this.columnTypeDeduplicatedList = new ArrayList<>();\n+    int index = START_INDEX;\n+    for (int i = 0; i < columnNameList.size(); i++) {\n+      String name = columnNameList.get(i);\n+      columnInfoList.add(TIMESTAMP_STR + name);\n+      columnInfoList.add(name);\n+      if (!columnInfoMap.containsKey(name)) {\n+        columnInfoMap.put(name, index++);\n+        columnTypeDeduplicatedList.add(columnTypeList.get(i));\n+      }\n+    }\n+\n+    this.ignoreTimeStamp = ignoreTimeStamp;\n+    this.client = client;\n+    this.sql = sql;\n+    this.queryId = queryId;\n+    this.tsQueryNonAlignDataSet = dataset;\n+    this.sessionId = sessionId;\n+  }\n+\n+  @Override\n+  public boolean isWrapperFor(Class<?> iface) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public <T> T unwrap(Class<T> iface) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public boolean absolute(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void afterLast() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void beforeFirst() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void cancelRowUpdates() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void clearWarnings() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void close() throws SQLException {\n+    if (isClosed) {\n+      return;\n+    }\n+    if (client != null) {\n+      try {\n+        TSCloseOperationReq closeReq = new TSCloseOperationReq(sessionId);\n+        closeReq.setQueryId(queryId);\n+        TSStatus closeResp = client.closeOperation(closeReq);\n+        RpcUtils.verifySuccess(closeResp);\n+      } catch (IoTDBRPCException e) {\n+        throw new SQLException(\"Error occurs for close opeation in server side becasuse \" + e);\n+      } catch (TException e) {\n+        throw new SQLException(\n+                \"Error occurs when connecting to server for close operation, becasue: \" + e);\n+      }\n+    }\n+    client = null;\n+    isClosed = true;\n+  }\n+\n+\n+  @Override\n+  public void deleteRow() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public int findColumn(String columnName) {\n+    return columnInfoMap.get(columnName);\n+  }\n+\n+  @Override\n+  public boolean first() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Array getArray(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Array getArray(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public InputStream getAsciiStream(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public InputStream getAsciiStream(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public BigDecimal getBigDecimal(int columnIndex) throws SQLException {\n+    return getBigDecimal(findColumnNameByIndex(columnIndex));\n+  }\n+\n+  @Override\n+  public BigDecimal getBigDecimal(String columnName) throws SQLException {\n+    return new BigDecimal(Objects.requireNonNull(getValueByName(columnName)));\n+  }\n+\n+  @Override\n+  public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {\n+    MathContext mc = new MathContext(scale);\n+    return getBigDecimal(columnIndex).round(mc);\n+  }\n+\n+  @Override\n+  public BigDecimal getBigDecimal(String columnName, int scale) throws SQLException {\n+    return getBigDecimal(findColumn(columnName), scale);\n+  }\n+\n+  @Override\n+  public InputStream getBinaryStream(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public InputStream getBinaryStream(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Blob getBlob(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Blob getBlob(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int columnIndex) throws SQLException {\n+    return getBoolean(findColumnNameByIndex(columnIndex));\n+  }\n+\n+  @Override\n+  public boolean getBoolean(String columnName) throws SQLException {\n+    checkRecord();\n+    int index = columnInfoMap.get(columnName) - START_INDEX;\n+    if (values[index] != null) {\n+      return BytesUtils.bytesToBool(values[index]);\n+    }\n+    else {\n+      throw new SQLException(String.format(VALUE_IS_NULL, columnName));\n+    }\n+  }\n+\n+  @Override\n+  public byte getByte(int columnIndex) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public byte getByte(String columnName) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public byte[] getBytes(int columnIndex) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public byte[] getBytes(String columnName) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Reader getCharacterStream(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Reader getCharacterStream(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Clob getClob(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Clob getClob(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public int getConcurrency() {\n+    return ResultSet.CONCUR_READ_ONLY;\n+  }\n+\n+  @Override\n+  public String getCursorName() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Date getDate(int columnIndex) throws SQLException {\n+    return new Date(getLong(columnIndex));\n+  }\n+\n+  @Override\n+  public Date getDate(String columnName) throws SQLException {\n+    return getDate(findColumn(columnName));\n+  }\n+\n+  @Override\n+  public Date getDate(int arg0, Calendar arg1) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Date getDate(String arg0, Calendar arg1) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public double getDouble(int columnIndex) throws SQLException {\n+    return getDouble(findColumnNameByIndex(columnIndex));\n+  }\n+\n+  @Override\n+  public double getDouble(String columnName) throws SQLException {\n+    checkRecord();\n+    int index = columnInfoMap.get(columnName) - START_INDEX;\n+    if (values[index] != null) {\n+      return BytesUtils.bytesToDouble(values[index]);\n+    } else {\n+      throw new SQLException(String.format(VALUE_IS_NULL, columnName));\n+    }\n+  }\n+\n+  @Override\n+  public int getFetchDirection() throws SQLException {\n+    return ResultSet.FETCH_FORWARD;\n+  }\n+\n+  @Override\n+  public void setFetchDirection(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public int getFetchSize() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void setFetchSize(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public float getFloat(int columnIndex) throws SQLException {\n+    return getFloat(findColumnNameByIndex(columnIndex));\n+  }\n+\n+  @Override\n+  public float getFloat(String columnName) throws SQLException {\n+    checkRecord();\n+    int index = columnInfoMap.get(columnName) - START_INDEX;\n+    if (values[index] != null) {\n+      return BytesUtils.bytesToFloat(values[index]);\n+    } else {\n+      throw new SQLException(String.format(VALUE_IS_NULL, columnName));\n+    }\n+  }\n+\n+  @Override\n+  public int getHoldability() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public int getInt(int columnIndex) throws SQLException {\n+    return getInt(findColumnNameByIndex(columnIndex));\n+  }\n+\n+  @Override\n+  public int getInt(String columnName) throws SQLException {\n+    checkRecord();\n+    int index = columnInfoMap.get(columnName) - START_INDEX;\n+    if (values[index] != null) {\n+      return BytesUtils.bytesToInt(values[index]);\n+    } else {\n+      throw new SQLException(String.format(VALUE_IS_NULL, columnName));\n+    }\n+  }\n+\n+  @Override\n+  public long getLong(int columnIndex) throws SQLException {\n+    return getLong(findColumnNameByIndex(columnIndex));\n+  }\n+\n+  @Override\n+  public long getLong(String columnName) throws SQLException {\n+    checkRecord();\n+    if (columnName.startsWith(TIMESTAMP_STR)) {\n+      String column = columnName.substring(TIMESTAMP_STR_LENGTH);\n+      int index = columnInfoMap.get(column) - START_INDEX;\n+      return BytesUtils.bytesToLong(times[index]);\n+    }\n+    int index = columnInfoMap.get(columnName) - START_INDEX;\n+    if (values[index] != null) {\n+      return BytesUtils.bytesToLong(values[index]);\n+    } else {\n+      throw new SQLException(String.format(VALUE_IS_NULL, columnName));\n+    }\n+  }\n+\n+  @Override\n+  public ResultSetMetaData getMetaData() {\n+    return new IoTDBResultMetadata(columnInfoList, columnTypeList, false);\n+  }\n+\n+  @Override\n+  public Reader getNCharacterStream(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Reader getNCharacterStream(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public NClob getNClob(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public NClob getNClob(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public String getNString(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public String getNString(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Object getObject(int columnIndex) throws SQLException {\n+    return getObject(findColumnNameByIndex(columnIndex));\n+  }\n+\n+  @Override\n+  public Object getObject(String columnName) throws SQLException {\n+    return getValueByName(columnName);\n+  }\n+\n+  @Override\n+  public Object getObject(int arg0, Map<String, Class<?>> arg1) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Object getObject(String arg0, Map<String, Class<?>> arg1) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public <T> T getObject(int arg0, Class<T> arg1) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public <T> T getObject(String arg0, Class<T> arg1) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Ref getRef(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Ref getRef(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public int getRow() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public RowId getRowId(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public RowId getRowId(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public SQLXML getSQLXML(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public SQLXML getSQLXML(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public short getShort(int columnIndex) throws SQLException {\n+    return getShort(findColumnNameByIndex(columnIndex));\n+  }\n+\n+  @Override\n+  public short getShort(String columnName) throws SQLException {\n+    return Short.parseShort(Objects.requireNonNull(getValueByName(columnName)));\n+  }\n+\n+  @Override\n+  public Statement getStatement() {\n+    return this.statement;\n+  }\n+\n+  @Override\n+  public String getString(int columnIndex) throws SQLException {\n+    return getString(findColumnNameByIndex(columnIndex));\n+  }\n+\n+  @Override\n+  public String getString(String columnName) throws SQLException {\n+    return getValueByName(columnName);\n+  }\n+\n+  @Override\n+  public Time getTime(int columnIndex) throws SQLException {\n+    return new Time(getLong(columnIndex));\n+  }\n+\n+  @Override\n+  public Time getTime(String columnName) throws SQLException {\n+    return getTime(findColumn(columnName));\n+  }\n+\n+  @Override\n+  public Time getTime(int arg0, Calendar arg1) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Time getTime(String arg0, Calendar arg1) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Timestamp getTimestamp(int columnIndex) throws SQLException {\n+    return new Timestamp(getLong(columnIndex));\n+  }\n+\n+  @Override\n+  public Timestamp getTimestamp(String columnName) throws SQLException {\n+    return getTimestamp(findColumn(columnName));\n+  }\n+\n+  @Override\n+  public Timestamp getTimestamp(int arg0, Calendar arg1) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public Timestamp getTimestamp(String arg0, Calendar arg1) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public int getType() {\n+    return ResultSet.TYPE_FORWARD_ONLY;\n+  }\n+\n+  @Override\n+  public URL getURL(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public URL getURL(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public InputStream getUnicodeStream(int arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public InputStream getUnicodeStream(String arg0) throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public SQLWarning getWarnings() {\n+    return warningChain;\n+  }\n+\n+  @Override\n+  public void insertRow() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public boolean isAfterLast() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public boolean isBeforeFirst() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public boolean isClosed() {\n+    return isClosed;\n+  }\n+\n+  @Override\n+  public boolean isFirst() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public boolean isLast() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public boolean last() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void moveToCurrentRow() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public void moveToInsertRow() throws SQLException {\n+    throw new SQLException(Constant.METHOD_NOT_SUPPORTED);\n+  }\n+\n+  @Override\n+  public boolean next() throws SQLException {\n+    if (hasCachedResults()) {\n+      constructNonAlignOneRow();\n+      return true;\n+    }\n+    if (emptyResultSet) {\n+      return false;\n+    }\n+    if (fetchResults()) {\n+      constructNonAlignOneRow();\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+\n+  /**\n+   * @return true means has results\n+   */\n+  private boolean fetchResults() throws SQLException {\n+    TSFetchResultsReq req = new TSFetchResultsReq(sessionId, sql, fetchSize, queryId, false);\n+    try {\n+      TSFetchResultsResp resp = client.fetchResults(req);\n+\n+      try {\n+        RpcUtils.verifySuccess(resp.getStatus());\n+      } catch (IoTDBRPCException e) {\n+        throw new IoTDBSQLException(e.getMessage(), resp.getStatus());\n+      }\n+      if (!resp.hasResultSet) {\n+        emptyResultSet = true;\n+      } else {\n+        tsQueryNonAlignDataSet = resp.getNonAlignQueryDataSet();\n+        if (tsQueryNonAlignDataSet == null) {\n+          return false;\n+        }\n+      }\n+      return resp.hasResultSet;\n+    } catch (TException e) {\n+      throw new SQLException(\n+              \"Cannot fetch result from server, because of network connection: {} \", e);\n+    }\n+  }\n+\n+  private boolean hasCachedResults() {\n+    return (tsQueryNonAlignDataSet != null && hasTimesRemaining());\n+  }\n+\n+  // check if has times remaining for disable align clause\n+  private boolean hasTimesRemaining() {\n+    for (ByteBuffer time : tsQueryNonAlignDataSet.timeList) {\n+      if (time.hasRemaining()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private void constructNonAlignOneRow() {\n+    for (int i = 0; i < tsQueryNonAlignDataSet.timeList.size(); i++) {\n+      times[i] = null;\n+      values[i] = null;\n+      if (tsQueryNonAlignDataSet.timeList.get(i).remaining() >= Long.BYTES) {\n+        if (times[i] == null) {\n+          times[i] = new byte[Long.BYTES];\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5"}, "originalPosition": 729}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI3NjU2Mg==", "bodyText": "Always use \"{}\" for code blocks (even if it only contains a single line), as we obey the google code-style.", "url": "https://github.com/apache/iotdb/pull/738#discussion_r366276562", "createdAt": "2020-01-14T11:03:15Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/NonAlignEngineDataSet.java", "diffHunk": "@@ -0,0 +1,354 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset;\n+\n+import org.apache.iotdb.db.query.pool.QueryTaskPoolManager;\n+import org.apache.iotdb.db.query.reader.ManagedSeriesReader;\n+import org.apache.iotdb.db.tools.watermark.WatermarkEncoder;\n+import org.apache.iotdb.service.rpc.thrift.TSQueryNonAlignDataSet;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Pair;\n+import org.apache.iotdb.tsfile.utils.PublicBAOS;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicIntegerArray;\n+\n+public class NonAlignEngineDataSet extends QueryDataSet {\n+\n+  private static class ReadTask implements Runnable {\n+\n+    private final ManagedSeriesReader reader;\n+    private BlockingQueue<Pair<ByteBuffer, ByteBuffer>> blockingQueue;\n+    private WatermarkEncoder encoder;\n+    NonAlignEngineDataSet dataSet;\n+    private int index;\n+\n+\n+    public ReadTask(ManagedSeriesReader reader,\n+                    BlockingQueue<Pair<ByteBuffer, ByteBuffer>> blockingQueue,\n+                    WatermarkEncoder encoder, NonAlignEngineDataSet dataSet, int index) {\n+      this.reader = reader;\n+      this.blockingQueue = blockingQueue;\n+      this.encoder = encoder;\n+      this.dataSet = dataSet;\n+      this.index = index;\n+    }\n+\n+    @Override\n+    public void run() {\n+      PublicBAOS timeBAOS = new PublicBAOS();\n+      PublicBAOS valueBAOS = new PublicBAOS();\n+      try {\n+        synchronized (reader) {\n+          // if the task is submitted, there must be free space in the queue\n+          // so here we don't need to check whether the queue has free space\n+          // the reader has next batch\n+          if ((dataSet.cachedBatchData[index] != null && dataSet.cachedBatchData[index].hasCurrent())\n+                  || reader.hasNextBatch()) {\n+            BatchData batchData;\n+            if (dataSet.cachedBatchData[index] != null && dataSet.cachedBatchData[index].hasCurrent())\n+              batchData = dataSet.cachedBatchData[index];\n+            else\n+              batchData = reader.nextBatch();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI3OTY3NQ==", "bodyText": "This field is not necessary if you make ReadTask a non-static class.", "url": "https://github.com/apache/iotdb/pull/738#discussion_r366279675", "createdAt": "2020-01-14T11:10:45Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/NonAlignEngineDataSet.java", "diffHunk": "@@ -0,0 +1,354 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset;\n+\n+import org.apache.iotdb.db.query.pool.QueryTaskPoolManager;\n+import org.apache.iotdb.db.query.reader.ManagedSeriesReader;\n+import org.apache.iotdb.db.tools.watermark.WatermarkEncoder;\n+import org.apache.iotdb.service.rpc.thrift.TSQueryNonAlignDataSet;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Pair;\n+import org.apache.iotdb.tsfile.utils.PublicBAOS;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicIntegerArray;\n+\n+public class NonAlignEngineDataSet extends QueryDataSet {\n+\n+  private static class ReadTask implements Runnable {\n+\n+    private final ManagedSeriesReader reader;\n+    private BlockingQueue<Pair<ByteBuffer, ByteBuffer>> blockingQueue;\n+    private WatermarkEncoder encoder;\n+    NonAlignEngineDataSet dataSet;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI4MDczOA==", "bodyText": "You may just wrap the byte[] in the BAOS with ByteBuffer.wrap() as it does not seem you will reuse it.", "url": "https://github.com/apache/iotdb/pull/738#discussion_r366280738", "createdAt": "2020-01-14T11:13:24Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/NonAlignEngineDataSet.java", "diffHunk": "@@ -0,0 +1,354 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset;\n+\n+import org.apache.iotdb.db.query.pool.QueryTaskPoolManager;\n+import org.apache.iotdb.db.query.reader.ManagedSeriesReader;\n+import org.apache.iotdb.db.tools.watermark.WatermarkEncoder;\n+import org.apache.iotdb.service.rpc.thrift.TSQueryNonAlignDataSet;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Pair;\n+import org.apache.iotdb.tsfile.utils.PublicBAOS;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicIntegerArray;\n+\n+public class NonAlignEngineDataSet extends QueryDataSet {\n+\n+  private static class ReadTask implements Runnable {\n+\n+    private final ManagedSeriesReader reader;\n+    private BlockingQueue<Pair<ByteBuffer, ByteBuffer>> blockingQueue;\n+    private WatermarkEncoder encoder;\n+    NonAlignEngineDataSet dataSet;\n+    private int index;\n+\n+\n+    public ReadTask(ManagedSeriesReader reader,\n+                    BlockingQueue<Pair<ByteBuffer, ByteBuffer>> blockingQueue,\n+                    WatermarkEncoder encoder, NonAlignEngineDataSet dataSet, int index) {\n+      this.reader = reader;\n+      this.blockingQueue = blockingQueue;\n+      this.encoder = encoder;\n+      this.dataSet = dataSet;\n+      this.index = index;\n+    }\n+\n+    @Override\n+    public void run() {\n+      PublicBAOS timeBAOS = new PublicBAOS();\n+      PublicBAOS valueBAOS = new PublicBAOS();\n+      try {\n+        synchronized (reader) {\n+          // if the task is submitted, there must be free space in the queue\n+          // so here we don't need to check whether the queue has free space\n+          // the reader has next batch\n+          if ((dataSet.cachedBatchData[index] != null && dataSet.cachedBatchData[index].hasCurrent())\n+                  || reader.hasNextBatch()) {\n+            BatchData batchData;\n+            if (dataSet.cachedBatchData[index] != null && dataSet.cachedBatchData[index].hasCurrent())\n+              batchData = dataSet.cachedBatchData[index];\n+            else\n+              batchData = reader.nextBatch();\n+\n+            int rowCount = 0;\n+            while (rowCount < dataSet.fetchSize) {\n+\n+              if ((dataSet.limit > 0 && dataSet.alreadyReturnedRowNumArray.get(index) >= dataSet.limit)) {\n+                break;\n+              }\n+\n+              if (batchData != null && batchData.hasCurrent()) {\n+                if (dataSet.offsetArray.get(index) == 0) {\n+                  long time = batchData.currentTime();\n+                  ReadWriteIOUtils.write(time, timeBAOS);\n+                  TSDataType type = batchData.getDataType();\n+                  switch (type) {\n+                    case INT32:\n+                      int intValue = batchData.getInt();\n+                      if (encoder != null && encoder.needEncode(time)) {\n+                        intValue = encoder.encodeInt(intValue, time);\n+                      }\n+                      ReadWriteIOUtils.write(intValue, valueBAOS);\n+                      break;\n+                    case INT64:\n+                      long longValue = batchData.getLong();\n+                      if (encoder != null && encoder.needEncode(time)) {\n+                        longValue = encoder.encodeLong(longValue, time);\n+                      }\n+                      ReadWriteIOUtils.write(longValue, valueBAOS);\n+                      break;\n+                    case FLOAT:\n+                      float floatValue = batchData.getFloat();\n+                      if (encoder != null && encoder.needEncode(time)) {\n+                        floatValue = encoder.encodeFloat(floatValue, time);\n+                      }\n+                      ReadWriteIOUtils.write(floatValue, valueBAOS);\n+                      break;\n+                    case DOUBLE:\n+                      double doubleValue = batchData.getDouble();\n+                      if (encoder != null && encoder.needEncode(time)) {\n+                        doubleValue = encoder.encodeDouble(doubleValue, time);\n+                      }\n+                      ReadWriteIOUtils.write(doubleValue, valueBAOS);\n+                      break;\n+                    case BOOLEAN:\n+                      ReadWriteIOUtils.write(batchData.getBoolean(),\n+                              valueBAOS);\n+                      break;\n+                    case TEXT:\n+                      ReadWriteIOUtils\n+                              .write(batchData.getBinary(),\n+                                      valueBAOS);\n+                      break;\n+                    default:\n+                      throw new UnSupportedDataTypeException(\n+                              String.format(\"Data type %s is not supported.\", type));\n+                  }\n+                }\n+                batchData.next();\n+              }\n+              else {\n+                if (reader.hasNextBatch()) {\n+                  batchData = reader.nextBatch();\n+                  dataSet.cachedBatchData[index] = batchData;\n+                  continue;\n+                }\n+                else\n+                  break;\n+              }\n+              if (dataSet.offsetArray.get(index) == 0) {\n+                rowCount++;\n+                if (dataSet.limit > 0) {\n+                  dataSet.alreadyReturnedRowNumArray.incrementAndGet(index);\n+                }\n+              } else {\n+                dataSet.offsetArray.decrementAndGet(index);\n+              }\n+            }\n+            if (rowCount == 0) {\n+              blockingQueue.put(new Pair(null, null));\n+              // set the hasRemaining field in reader to false\n+              // tell the Consumer not to submit another task for this reader any more\n+              reader.setHasRemaining(false);\n+              // remove itself from the QueryTaskPoolManager\n+              reader.setManagedByQueryManager(false);\n+              return;\n+            }\n+\n+            ByteBuffer timeBuffer = ByteBuffer.allocate(timeBAOS.size());\n+            timeBuffer.put(timeBAOS.getBuf(), 0, timeBAOS.size());\n+            timeBuffer.flip();\n+            ByteBuffer valueBuffer = ByteBuffer.allocate(valueBAOS.size());\n+            valueBuffer.put(valueBAOS.getBuf(), 0, valueBAOS.size());\n+            valueBuffer.flip();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI4OTcyOQ==", "bodyText": "Is it necessary to use atomic objects? Will there be concurrent modifications on the same index? I thought all read tasks are working on different indexes.", "url": "https://github.com/apache/iotdb/pull/738#discussion_r366289729", "createdAt": "2020-01-14T11:36:18Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/NonAlignEngineDataSet.java", "diffHunk": "@@ -0,0 +1,354 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.dataset;\n+\n+import org.apache.iotdb.db.query.pool.QueryTaskPoolManager;\n+import org.apache.iotdb.db.query.reader.ManagedSeriesReader;\n+import org.apache.iotdb.db.tools.watermark.WatermarkEncoder;\n+import org.apache.iotdb.service.rpc.thrift.TSQueryNonAlignDataSet;\n+import org.apache.iotdb.tsfile.exception.write.UnSupportedDataTypeException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Pair;\n+import org.apache.iotdb.tsfile.utils.PublicBAOS;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicIntegerArray;\n+\n+public class NonAlignEngineDataSet extends QueryDataSet {\n+\n+  private static class ReadTask implements Runnable {\n+\n+    private final ManagedSeriesReader reader;\n+    private BlockingQueue<Pair<ByteBuffer, ByteBuffer>> blockingQueue;\n+    private WatermarkEncoder encoder;\n+    NonAlignEngineDataSet dataSet;\n+    private int index;\n+\n+\n+    public ReadTask(ManagedSeriesReader reader,\n+                    BlockingQueue<Pair<ByteBuffer, ByteBuffer>> blockingQueue,\n+                    WatermarkEncoder encoder, NonAlignEngineDataSet dataSet, int index) {\n+      this.reader = reader;\n+      this.blockingQueue = blockingQueue;\n+      this.encoder = encoder;\n+      this.dataSet = dataSet;\n+      this.index = index;\n+    }\n+\n+    @Override\n+    public void run() {\n+      PublicBAOS timeBAOS = new PublicBAOS();\n+      PublicBAOS valueBAOS = new PublicBAOS();\n+      try {\n+        synchronized (reader) {\n+          // if the task is submitted, there must be free space in the queue\n+          // so here we don't need to check whether the queue has free space\n+          // the reader has next batch\n+          if ((dataSet.cachedBatchData[index] != null && dataSet.cachedBatchData[index].hasCurrent())\n+                  || reader.hasNextBatch()) {\n+            BatchData batchData;\n+            if (dataSet.cachedBatchData[index] != null && dataSet.cachedBatchData[index].hasCurrent())\n+              batchData = dataSet.cachedBatchData[index];\n+            else\n+              batchData = reader.nextBatch();\n+\n+            int rowCount = 0;\n+            while (rowCount < dataSet.fetchSize) {\n+\n+              if ((dataSet.limit > 0 && dataSet.alreadyReturnedRowNumArray.get(index) >= dataSet.limit)) {\n+                break;\n+              }\n+\n+              if (batchData != null && batchData.hasCurrent()) {\n+                if (dataSet.offsetArray.get(index) == 0) {\n+                  long time = batchData.currentTime();\n+                  ReadWriteIOUtils.write(time, timeBAOS);\n+                  TSDataType type = batchData.getDataType();\n+                  switch (type) {\n+                    case INT32:\n+                      int intValue = batchData.getInt();\n+                      if (encoder != null && encoder.needEncode(time)) {\n+                        intValue = encoder.encodeInt(intValue, time);\n+                      }\n+                      ReadWriteIOUtils.write(intValue, valueBAOS);\n+                      break;\n+                    case INT64:\n+                      long longValue = batchData.getLong();\n+                      if (encoder != null && encoder.needEncode(time)) {\n+                        longValue = encoder.encodeLong(longValue, time);\n+                      }\n+                      ReadWriteIOUtils.write(longValue, valueBAOS);\n+                      break;\n+                    case FLOAT:\n+                      float floatValue = batchData.getFloat();\n+                      if (encoder != null && encoder.needEncode(time)) {\n+                        floatValue = encoder.encodeFloat(floatValue, time);\n+                      }\n+                      ReadWriteIOUtils.write(floatValue, valueBAOS);\n+                      break;\n+                    case DOUBLE:\n+                      double doubleValue = batchData.getDouble();\n+                      if (encoder != null && encoder.needEncode(time)) {\n+                        doubleValue = encoder.encodeDouble(doubleValue, time);\n+                      }\n+                      ReadWriteIOUtils.write(doubleValue, valueBAOS);\n+                      break;\n+                    case BOOLEAN:\n+                      ReadWriteIOUtils.write(batchData.getBoolean(),\n+                              valueBAOS);\n+                      break;\n+                    case TEXT:\n+                      ReadWriteIOUtils\n+                              .write(batchData.getBinary(),\n+                                      valueBAOS);\n+                      break;\n+                    default:\n+                      throw new UnSupportedDataTypeException(\n+                              String.format(\"Data type %s is not supported.\", type));\n+                  }\n+                }\n+                batchData.next();\n+              }\n+              else {\n+                if (reader.hasNextBatch()) {\n+                  batchData = reader.nextBatch();\n+                  dataSet.cachedBatchData[index] = batchData;\n+                  continue;\n+                }\n+                else\n+                  break;\n+              }\n+              if (dataSet.offsetArray.get(index) == 0) {\n+                rowCount++;\n+                if (dataSet.limit > 0) {\n+                  dataSet.alreadyReturnedRowNumArray.incrementAndGet(index);\n+                }\n+              } else {\n+                dataSet.offsetArray.decrementAndGet(index);\n+              }\n+            }\n+            if (rowCount == 0) {\n+              blockingQueue.put(new Pair(null, null));\n+              // set the hasRemaining field in reader to false\n+              // tell the Consumer not to submit another task for this reader any more\n+              reader.setHasRemaining(false);\n+              // remove itself from the QueryTaskPoolManager\n+              reader.setManagedByQueryManager(false);\n+              return;\n+            }\n+\n+            ByteBuffer timeBuffer = ByteBuffer.allocate(timeBAOS.size());\n+            timeBuffer.put(timeBAOS.getBuf(), 0, timeBAOS.size());\n+            timeBuffer.flip();\n+            ByteBuffer valueBuffer = ByteBuffer.allocate(valueBAOS.size());\n+            valueBuffer.put(valueBAOS.getBuf(), 0, valueBAOS.size());\n+            valueBuffer.flip();\n+\n+            Pair<ByteBuffer, ByteBuffer> timeValueBAOSPair = new Pair(timeBuffer, valueBuffer);\n+\n+            blockingQueue.put(timeValueBAOSPair);\n+            // if the queue also has free space, just submit another itself\n+            if (blockingQueue.remainingCapacity() > 0) {\n+              pool.submit(this);\n+            }\n+            // the queue has no more space\n+            // remove itself from the QueryTaskPoolManager\n+            else {\n+              reader.setManagedByQueryManager(false);\n+            }\n+            return;\n+          }\n+          blockingQueue.put(new Pair(null, null));\n+          // set the hasRemaining field in reader to false\n+          // tell the Consumer not to submit another task for this reader any more\n+          reader.setHasRemaining(false);\n+          // remove itself from the QueryTaskPoolManager\n+          reader.setManagedByQueryManager(false);\n+        }\n+      } catch (InterruptedException e) {\n+        LOGGER.error(\"Interrupted while putting into the blocking queue: \", e);\n+      } catch (IOException e) {\n+        LOGGER.error(\"Something gets wrong while reading from the series reader: \", e);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Something gets wrong: \", e);\n+      }\n+\n+    }\n+\n+  }\n+\n+\n+  private List<ManagedSeriesReader> seriesReaderWithoutValueFilterList;\n+\n+  // Blocking queue list for each time value buffer pair\n+  private BlockingQueue<Pair<ByteBuffer, ByteBuffer>>[] blockingQueueArray;\n+\n+  private boolean initialized = false;\n+\n+  private AtomicIntegerArray offsetArray;\n+\n+  private int limit;\n+\n+  private AtomicIntegerArray alreadyReturnedRowNumArray;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI5NTI5MQ==", "bodyText": "It may be better to also end this query in case anyone forgets to close the resultset.", "url": "https://github.com/apache/iotdb/pull/738#discussion_r366295291", "createdAt": "2020-01-14T11:49:49Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "diffHunk": "@@ -802,23 +781,44 @@ public TSFetchResultsResp fetchResults(TSFetchResultsReq req) {\n \n       if (!queryId2DataSet.containsKey(req.queryId)) {\n         return getTSFetchResultsResp(\n-            getStatus(TSStatusCode.EXECUTE_STATEMENT_ERROR, \"Has not executed query\"));\n+                getStatus(TSStatusCode.EXECUTE_STATEMENT_ERROR, \"Has not executed query\"));\n       }\n \n       QueryDataSet queryDataSet = queryId2DataSet.get(req.queryId);\n-      TSQueryDataSet result = fillRpcReturnData(req.fetchSize, queryDataSet,\n-          sessionIdUsernameMap.get(req.sessionId));\n-\n-      boolean hasResultSet = result.bufferForTime().limit() != 0;\n-      if (!hasResultSet) {\n-        queryId2DataSet.remove(req.queryId);\n+      if (req.isAlign) {\n+        TSQueryDataSet result = fillRpcReturnData(req.fetchSize, queryDataSet,\n+                sessionIdUsernameMap.get(req.sessionId));\n+        boolean hasResultSet = result.bufferForTime().limit() != 0;\n+        if (!hasResultSet) {\n+          queryId2DataSet.remove(req.queryId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5"}, "originalPosition": 410}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI5Njk4Mw==", "bodyText": "And the field \"isAlign\".", "url": "https://github.com/apache/iotdb/pull/738#discussion_r366296983", "createdAt": "2020-01-14T11:53:59Z", "author": {"login": "jt2594838"}, "path": "service-rpc/rpc-changelist.md", "diffHunk": "@@ -107,9 +107,11 @@ Last Updated on November 12th, 2019 by Tian Jiang.\n | Latest Changes                                               | Related Committers                 |\n | ------------------------------------------------------------ | ---------------------------------- |\n | Add parameter sessionId in getTimeZone, getProperties, setStorageGroup, createTimeseries... | Tian Jiang|\n+| Add struct TSQueryNonAlignDataSet                            | Haonan Hou|\n \n ## 3. Update\n \n | Latest Changes                                               | Related Committers     |\n | ------------------------------------------------------------ | ---------------------- |\n-| Replace TS_SessionHandles with SessionIds, TSOperationHandle with queryIds  | Tian Jiang  |\n\\ No newline at end of file\n+| Replace TS_SessionHandles with SessionIds, TSOperationHandle with queryIds  | Tian Jiang  |\n+| Add optional TSQueryNonAlignDataSet in TSExecuteStatementResp, TSFetchResultsResp  | Haonan Hou |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee98df2f6659a55dd407a1e28d1ebadddf304b5"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNDc5MzQ4", "url": "https://github.com/apache/iotdb/pull/738#pullrequestreview-342479348", "createdAt": "2020-01-14T11:56:57Z", "commit": {"oid": "d969808f81b365e4530721b74c4c7b496a05cfe8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b4617fb2892a57b47a34df804e89dfab2c0829b", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/3b4617fb2892a57b47a34df804e89dfab2c0829b", "committedDate": "2020-01-14T13:18:24Z", "message": "for jiangtian"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29bc3179a27acb3843cd871c5d857da75120a71a", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/29bc3179a27acb3843cd871c5d857da75120a71a", "committedDate": "2020-01-15T01:44:01Z", "message": "Extract an abstract IoTDBResultSet"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d51d91c990c81c268eacc1f2f4ce0bab50965a6d", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/d51d91c990c81c268eacc1f2f4ce0bab50965a6d", "committedDate": "2020-01-15T02:12:41Z", "message": "resolve some code smell"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d992e099087fc916d3e0c99a373b8cfc8da0be0f", "author": {"user": {"login": "JackieTien97", "name": "Jackie Tien"}}, "url": "https://github.com/apache/iotdb/commit/d992e099087fc916d3e0c99a373b8cfc8da0be0f", "committedDate": "2020-01-15T02:57:01Z", "message": "fix some bug"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyOTk3ODYx", "url": "https://github.com/apache/iotdb/pull/738#pullrequestreview-342997861", "createdAt": "2020-01-15T05:41:54Z", "commit": {"oid": "d992e099087fc916d3e0c99a373b8cfc8da0be0f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3249, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}