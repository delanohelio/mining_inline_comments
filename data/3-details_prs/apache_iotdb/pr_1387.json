{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2MzMyMDEy", "number": 1387, "title": "[IOTDB-709] Create schema automatically", "bodyText": "This pull request implements schema automatic creation in distributed version.\nIf an InsertPlan is executed but an exception is encountered because the storage group is not set yet, or the timeseries is not created, the MetaGroupMember will first execute a SetStorageGroupPlan, or CreateTimeseriesPlan, and then execute the InsertPlan again.\nThese plans will be routed among the cluster, so that the corresponding nodes will be notified.", "createdAt": "2020-06-18T09:02:13Z", "url": "https://github.com/apache/iotdb/pull/1387", "merged": true, "mergeCommit": {"oid": "58e67c83b7babb3279b026ccb7081be8faeb26c7"}, "closed": true, "closedAt": "2020-06-28T13:35:35Z", "author": {"login": "Ring-k"}, "timelineItems": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcsZoYYgH2gAyNDM2MzMyMDEyOmU0ZjE5ZTUyYzU1YmEyMTcxZWQ5MzljZTJiNDBkYTEzYzVjMjk5ZmE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcvou1igFqTQzODc2MDY4Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e4f19e52c55ba2171ed939ce2b40da13c5c299fa", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/e4f19e52c55ba2171ed939ce2b40da13c5c299fa", "committedDate": "2020-06-18T07:50:29Z", "message": "auto schema creation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "267c814be2c8cd0457bbda9996a1b3c2b7515be8", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/267c814be2c8cd0457bbda9996a1b3c2b7515be8", "committedDate": "2020-06-18T09:12:42Z", "message": "add comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "committedDate": "2020-06-19T00:37:40Z", "message": "fix sonar"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzU4OTgx", "url": "https://github.com/apache/iotdb/pull/1387#pullrequestreview-433758981", "createdAt": "2020-06-19T02:12:20Z", "commit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjoxMjoyMFrOGmF0BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjo0ODoyM1rOGmGVWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NDMwOA==", "bodyText": "This should still be debug.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442594308", "createdAt": "2020-06-19T02:12:20Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1520,12 +1534,31 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && IoTDBDescriptor.getInstance().getConfig()\n+          .isAutoCreateSchemaEnabled()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = executeNonQuery(setStorageGroupPlan);\n+          if (setStorageGroupResult.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+            throw new MetadataException(\"Failed to set storage group \" + storageGroupName);\n+          }\n+          return executeNonQuery(plan);\n+        } catch (MetadataException e) {\n+          logger.info(\"Failed to set storage group of device id {}\", deviceId);\n+        }\n+      }\n+      logger.error(\"{}: Cannot found storage groups for {}\", name, plan);\n       return StatusUtils.NO_STORAGE_GROUP;\n     }\n-    logger.debug(\"{}: The data groups of {} are {}\", name, plan, planGroupMap);\n+    logger.error(\"{}: The data groups of {} are {}\", name, plan, planGroupMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NjE5Nw==", "bodyText": "I think we should add a specific status code like \"TSStatusCode.NO_TIMESERIES\", as this one is too abstract and we are not sure whether it is because of no metadata.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442596197", "createdAt": "2020-06-19T02:20:40Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1551,6 +1584,20 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n         subStatus = forwardPlan(entry.getKey(), entry.getValue());\n       }\n       if (subStatus.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        if (entry.getKey() instanceof InsertPlan\n+            && subStatus.getCode() == TSStatusCode.STORAGE_ENGINE_ERROR.getStatusCode()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5ODM1Mg==", "bodyText": "\"entry.getValue()\" is the data group you are going to send the plan to, and it may not be the group that should hold the metadata, so create timeseries plans should be forward to the group that should hold the metadata.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442598352", "createdAt": "2020-06-19T02:29:52Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1551,6 +1584,20 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n         subStatus = forwardPlan(entry.getKey(), entry.getValue());\n       }\n       if (subStatus.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        if (entry.getKey() instanceof InsertPlan\n+            && subStatus.getCode() == TSStatusCode.STORAGE_ENGINE_ERROR.getStatusCode()\n+            && IoTDBDescriptor.getInstance().getConfig().isAutoCreateSchemaEnabled()) {\n+          // try to create timeseries\n+          boolean hasCreate = autoCreateTimeseries((InsertPlan) entry.getKey(), entry.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5OTcxOA==", "bodyText": "getting -> get\nI would suggest print something like \"{} and other {} paths\", seriesList.get(0), seriesList.size() - 1 instead of \"{}\", serieseList, in case that the list is too long.\nAnd if you want to print a list in a log, you can just use the list as a parameter and there is no need to wrap it with \"Arrays.toString(seriesList.toArray(new String[0]))\".", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442599718", "createdAt": "2020-06-19T02:35:30Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1569,6 +1616,70 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   * @param insertPlan, some of the timeseries in it are not created yet\n+   * @param partitionGroup\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan, PartitionGroup partitionGroup) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+\n+\n+  /**\n+   * To check which timeseries in the input list is unregistered\n+   * @param seriesList\n+   * @param partitionGroup\n+   * @return\n+   */\n+  List<String> getUnregisteredSeriesList(List<String> seriesList, PartitionGroup partitionGroup) {\n+    Set<String> unregistered = new HashSet<>();\n+    for (Node node : partitionGroup) {\n+      try {\n+        DataClient client = getDataClient(node);\n+        Map<String, Boolean> result = SyncClientAdaptor\n+            .getUnregisteredMeasurements(client, partitionGroup.getHeader(), seriesList);\n+        for (Map.Entry<String, Boolean> entry : result.entrySet()) {\n+          if (!entry.getValue()) {\n+            unregistered.add(entry.getKey());\n+          }\n+        }\n+      } catch (TException | IOException e) {\n+        logger.error(\"{}: cannot getting unregistered series list {} from {}\", name,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMDU3Ng==", "bodyText": "Please add a TODO here: \"TODO-Cluster: add executeNonQueryBatch()\", so we can cut the number of communications later.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442600576", "createdAt": "2020-06-19T02:39:11Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1569,6 +1616,70 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   * @param insertPlan, some of the timeseries in it are not created yet\n+   * @param partitionGroup\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan, PartitionGroup partitionGroup) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMTIwMg==", "bodyText": "The schema may be auto-created concurrently, so I think the status code should be carefully checked, and if it says that the timeseries are already created, we should also return true.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442601202", "createdAt": "2020-06-19T02:41:43Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1569,6 +1616,70 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   * @param insertPlan, some of the timeseries in it are not created yet\n+   * @param partitionGroup\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan, PartitionGroup partitionGroup) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMjg0MQ==", "bodyText": "A suggestion about the interface design: I think the return type can be a list with the length of measurements because the sender clearly know what series it queries and the receiver need not send them back.\nAnother thing, I think \"measurement\" is not proper here, better just call them timeseries.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442602841", "createdAt": "2020-06-19T02:48:23Z", "author": {"login": "jt2594838"}, "path": "service-rpc/src/main/thrift/cluster.thrift", "diffHunk": "@@ -350,6 +350,8 @@ service TSDataService extends RaftService {\n \n   list<binary> getAggrResult(1:GetAggrResultRequest request)\n \n+  map<string, bool> isMeasurementsRegistered(1: Node header, 2: list<string> measurements)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzc2MjU0", "url": "https://github.com/apache/iotdb/pull/1387#pullrequestreview-433776254", "createdAt": "2020-06-19T03:15:35Z", "commit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMzoxNTozNVrOGmGtJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMzoxNTozNVrOGmGtJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwODkzMw==", "bodyText": "How about CreateTimeSeriesPlan? and other plans which can cause first check storage group exist or not ?", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442608933", "createdAt": "2020-06-19T03:15:35Z", "author": {"login": "neuyilan"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1520,12 +1534,31 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && IoTDBDescriptor.getInstance().getConfig()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40"}, "originalPosition": 65}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ea91ee1062bb191e6047f873b71b10e22120f42", "author": {"user": null}, "url": "https://github.com/apache/iotdb/commit/8ea91ee1062bb191e6047f873b71b10e22120f42", "committedDate": "2020-06-22T15:20:51Z", "message": "fix conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bca1a88bb8bd36b47bed84e76f992509660e3ce", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/0bca1a88bb8bd36b47bed84e76f992509660e3ce", "committedDate": "2020-06-22T15:26:01Z", "message": "error->debug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da7a76aa10b7d559fc1919fad2bc0d0ad2f46872", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/da7a76aa10b7d559fc1919fad2bc0d0ad2f46872", "committedDate": "2020-06-22T15:40:06Z", "message": "cluster properties"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "283cf21e45755ec8e47bff25c36e5851ee7f7de5", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/283cf21e45755ec8e47bff25c36e5851ee7f7de5", "committedDate": "2020-06-22T15:51:44Z", "message": "map -> list"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78c7c230a3af641ed6abaeb54cfc9e3a70e93757", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/78c7c230a3af641ed6abaeb54cfc9e3a70e93757", "committedDate": "2020-06-22T16:30:35Z", "message": "measurement -> timeseries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c7b5079ddafe3212684986dcecdd877946e6029", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/3c7b5079ddafe3212684986dcecdd877946e6029", "committedDate": "2020-06-23T01:14:10Z", "message": "change name"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1Mzg1NTg3", "url": "https://github.com/apache/iotdb/pull/1387#pullrequestreview-435385587", "createdAt": "2020-06-23T01:52:20Z", "commit": {"oid": "3c7b5079ddafe3212684986dcecdd877946e6029"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMTo1MjoyMFrOGnWhGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMTo1ODo1OFrOGnWoSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNjU3MA==", "bodyText": "Please resolve the conflicts.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443916570", "createdAt": "2020-06-23T01:52:20Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -1073,7 +1072,12 @@ public void pullTimeSeriesSchema(PullSchemaRequest request,\n \n   /**\n    * Create an IPointReader of \"path\" with \u201ctimeFilter\u201d and \"valueFilter\". A synchronization with\n+<<<<<<< HEAD\n+   * the leader will be performed first to preserve strong consistency. TODO-Cluster: also support\n+   * weak consistency\n+=======\n    * the leader will be performed according to consistency level\n+>>>>>>> origin/cluster_new", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c7b5079ddafe3212684986dcecdd877946e6029"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNjkwMg==", "bodyText": "I think there is a method syncLeaderWithConsistencyCheck now, and that one should be used.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443916902", "createdAt": "2020-06-23T01:53:39Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -1610,6 +1623,34 @@ public void getAggrResult(GetAggrResultRequest request,\n     resultHandler.onComplete(resultBuffers);\n   }\n \n+  /**\n+   * Check if the given measurements are registered or not\n+   * @param header\n+   * @param timeseriesList\n+   * @param resultHandler\n+   * @throws TException\n+   */\n+  @Override\n+  public void getUnregisteredTimeseries(Node header, List<String> timeseriesList,\n+      AsyncMethodCallback<List<String>> resultHandler) throws TException {\n+    if (!syncLeader()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c7b5079ddafe3212684986dcecdd877946e6029"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNzM5NQ==", "bodyText": "Better add the seriesPath which triggers the exception into the message.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443917395", "createdAt": "2020-06-23T01:55:25Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -1610,6 +1623,34 @@ public void getAggrResult(GetAggrResultRequest request,\n     resultHandler.onComplete(resultBuffers);\n   }\n \n+  /**\n+   * Check if the given measurements are registered or not\n+   * @param header\n+   * @param timeseriesList\n+   * @param resultHandler\n+   * @throws TException\n+   */\n+  @Override\n+  public void getUnregisteredTimeseries(Node header, List<String> timeseriesList,\n+      AsyncMethodCallback<List<String>> resultHandler) throws TException {\n+    if (!syncLeader()) {\n+      resultHandler.onError(new LeaderUnknownException(getAllNodes()));\n+      return;\n+    }\n+    List<String> result = new ArrayList<>();\n+    for (String seriesPath : timeseriesList) {\n+      try {\n+        List<String> path = MManager.getInstance().getAllTimeseriesName(seriesPath);\n+        if (path.size() != 1) {\n+          throw new MetadataException(\"Size of the path is not 1.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c7b5079ddafe3212684986dcecdd877946e6029"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxODQwOQ==", "bodyText": "Report the status code and its message in the exception.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443918409", "createdAt": "2020-06-23T01:58:58Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1530,9 +1544,29 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && ClusterDescriptor.getInstance().getConfig()\n+          .isEnableAutoCreateSchema()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = executeNonQuery(setStorageGroupPlan);\n+          if (setStorageGroupResult.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+            throw new MetadataException(\"Failed to set storage group \" + storageGroupName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c7b5079ddafe3212684986dcecdd877946e6029"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "523f1063953f57b5ac537213cf38ca2b4a717593", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/523f1063953f57b5ac537213cf38ca2b4a717593", "committedDate": "2020-06-23T02:36:31Z", "message": "route meta"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4687aaad5b3ce268d08401c7f94fcf3a345e7171", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/4687aaad5b3ce268d08401c7f94fcf3a345e7171", "committedDate": "2020-06-23T03:00:46Z", "message": "fix conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2493bcc51d702b6be99b84b0fae53f140469d61b", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/2493bcc51d702b6be99b84b0fae53f140469d61b", "committedDate": "2020-06-23T03:15:15Z", "message": "exception report"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1NTA4NTc5", "url": "https://github.com/apache/iotdb/pull/1387#pullrequestreview-435508579", "createdAt": "2020-06-23T07:23:58Z", "commit": {"oid": "2493bcc51d702b6be99b84b0fae53f140469d61b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwNzoyMzo1OVrOGnchNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwNzoyMzo1OVrOGnchNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAxNDkwMQ==", "bodyText": "It seems that this function forwardPlan will only be used in processNonPartitionedDataPlan, which will be called only when the type of plan is DeletePlan or DeleteTimeSeriesPlan, so maybe these new code in this function will never be called?", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444014901", "createdAt": "2020-06-23T07:23:59Z", "author": {"login": "LebronAl"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1667,6 +1710,18 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n         status = forwardPlan(plan, partitionGroup);\n       }\n       if (status.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        if (plan instanceof InsertPlan", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2493bcc51d702b6be99b84b0fae53f140469d61b"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1NTEzNTQy", "url": "https://github.com/apache/iotdb/pull/1387#pullrequestreview-435513542", "createdAt": "2020-06-23T07:31:07Z", "commit": {"oid": "2493bcc51d702b6be99b84b0fae53f140469d61b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwNzozMTowOFrOGncvyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwNzozMTowOFrOGncvyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAxODYzMg==", "bodyText": "maybe you can use processNonPartitionedMetaPlan directly to avoid unnecessary judgement", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444018632", "createdAt": "2020-06-23T07:31:08Z", "author": {"login": "LebronAl"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1530,9 +1544,38 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && ClusterDescriptor.getInstance().getConfig()\n+          .isEnableAutoCreateSchema()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = executeNonQuery(setStorageGroupPlan);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2493bcc51d702b6be99b84b0fae53f140469d61b"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1NTI1OTg4", "url": "https://github.com/apache/iotdb/pull/1387#pullrequestreview-435525988", "createdAt": "2020-06-23T07:48:22Z", "commit": {"oid": "2493bcc51d702b6be99b84b0fae53f140469d61b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwNzo0ODoyMlrOGndWnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwNzo0ODoyMlrOGndWnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAyODU3NQ==", "bodyText": "maybe you can use processPartitionedPlan directly to avoid unnecessary judgement", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444028575", "createdAt": "2020-06-23T07:48:22Z", "author": {"login": "LebronAl"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1684,6 +1739,77 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   *\n+   * @param insertPlan,    some of the timeseries in it are not created yet\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    String storageGroupName;\n+    try {\n+      storageGroupName = MetaUtils\n+          .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+              .getConfig().getDefaultStorageGroupLevel());\n+    } catch (MetadataException e) {\n+      logger.error(\"Failed to infer storage group from deviceId {}\", deviceId);\n+      return false;\n+    }\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    PartitionGroup partitionGroup = partitionTable.route(storageGroupName, 0);\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      // TODO-Cluster: add executeNonQueryBatch()\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2493bcc51d702b6be99b84b0fae53f140469d61b"}, "originalPosition": 155}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "362b4d00bd18798f3c83c566408735218429d34d", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/362b4d00bd18798f3c83c566408735218429d34d", "committedDate": "2020-06-24T04:34:03Z", "message": "insertPlan backup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d98656a9b1150d20ba4abf395a715298f6c28766", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/d98656a9b1150d20ba4abf395a715298f6c28766", "committedDate": "2020-06-24T04:54:42Z", "message": "clone"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfc17a5eefea399f14d423bad50cb8864927690a", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/dfc17a5eefea399f14d423bad50cb8864927690a", "committedDate": "2020-06-24T07:21:18Z", "message": "new error code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec1a35174123572c5a7ef45ecad4086539d2b141", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/ec1a35174123572c5a7ef45ecad4086539d2b141", "committedDate": "2020-06-24T07:41:18Z", "message": "executeNonQuery -> processNonPartitionedMetaPlan"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/c1a9f422e64004228e06f4b4adcdaeb46944fd87", "committedDate": "2020-06-24T08:07:20Z", "message": "check storage group already set"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NTExMTc0", "url": "https://github.com/apache/iotdb/pull/1387#pullrequestreview-436511174", "createdAt": "2020-06-24T10:13:35Z", "commit": {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDoxMzozNVrOGoL3-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDoyMzo1N1rOGoMNMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MDc3Ng==", "bodyText": "It would be better to use e (preserve stack traces).", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444790776", "createdAt": "2020-06-24T10:13:35Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1530,9 +1544,39 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && ClusterDescriptor.getInstance().getConfig()\n+          .isEnableAutoCreateSchema()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = processNonPartitionedMetaPlan(setStorageGroupPlan);\n+          if (setStorageGroupResult.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode() &&\n+          setStorageGroupResult.getCode() != TSStatusCode.PATH_ALREADY_EXIST_ERROR.getStatusCode()) {\n+            throw new MetadataException(\n+                String.format(\"Status Code: %d, failed to set storage group \",\n+                    setStorageGroupResult.getCode(), storageGroupName)\n+            );\n+          }\n+          // try to create timeseries\n+          boolean isAutoCreateTimeseriesSuccess = autoCreateTimeseries((InsertPlan)plan);\n+          if(!isAutoCreateTimeseriesSuccess){\n+            throw new MetadataException(\n+                String.format(\"Failed to create timeseries from InsertPlan automatically.\")\n+            );\n+          }\n+          return executeNonQuery(plan);\n+        } catch (MetadataException e) {\n+          logger.error(\"Failed to set storage group or create timeseries, because {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MjcyOA==", "bodyText": "Please refactor this message like the former one to avoid printing too many seriesPaths.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444792728", "createdAt": "2020-06-24T10:17:28Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1684,6 +1743,77 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   *\n+   * @param insertPlan,    some of the timeseries in it are not created yet\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    String storageGroupName;\n+    try {\n+      storageGroupName = MetaUtils\n+          .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+              .getConfig().getDefaultStorageGroupLevel());\n+    } catch (MetadataException e) {\n+      logger.error(\"Failed to infer storage group from deviceId {}\", deviceId);\n+      return false;\n+    }\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    PartitionGroup partitionGroup = partitionTable.route(storageGroupName, 0);\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      // TODO-Cluster: add executeNonQueryBatch()\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * To check which timeseries in the input list is unregistered\n+   *\n+   * @param seriesList\n+   * @param partitionGroup\n+   * @return\n+   */\n+  List<String> getUnregisteredSeriesList(List<String> seriesList, PartitionGroup partitionGroup) {\n+    Set<String> unregistered = new HashSet<>();\n+    for (Node node : partitionGroup) {\n+      try {\n+        DataClient client = getDataClient(node);\n+        List<String> result = SyncClientAdaptor\n+            .getUnregisteredMeasurements(client, partitionGroup.getHeader(), seriesList);\n+        unregistered.addAll(result);\n+      } catch (TException | IOException e) {\n+        logger.error(\"{}: cannot getting unregistered {} and other {} paths from {}\", name,\n+            seriesList.get(0), seriesList.get(seriesList.size() - 1), node, e);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        logger.error(\"{}: getting unregistered series list {} is interrupted from {}\", name,\n+            Arrays.toString(seriesList.toArray(new String[0])), node, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MzQ3NA==", "bodyText": "I think you should break once a non-null result is returned, and I do not think using a Set is necessary.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444793474", "createdAt": "2020-06-24T10:18:56Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1684,6 +1743,77 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   *\n+   * @param insertPlan,    some of the timeseries in it are not created yet\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    String storageGroupName;\n+    try {\n+      storageGroupName = MetaUtils\n+          .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+              .getConfig().getDefaultStorageGroupLevel());\n+    } catch (MetadataException e) {\n+      logger.error(\"Failed to infer storage group from deviceId {}\", deviceId);\n+      return false;\n+    }\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    PartitionGroup partitionGroup = partitionTable.route(storageGroupName, 0);\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      // TODO-Cluster: add executeNonQueryBatch()\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * To check which timeseries in the input list is unregistered\n+   *\n+   * @param seriesList\n+   * @param partitionGroup\n+   * @return\n+   */\n+  List<String> getUnregisteredSeriesList(List<String> seriesList, PartitionGroup partitionGroup) {\n+    Set<String> unregistered = new HashSet<>();\n+    for (Node node : partitionGroup) {\n+      try {\n+        DataClient client = getDataClient(node);\n+        List<String> result = SyncClientAdaptor\n+            .getUnregisteredMeasurements(client, partitionGroup.getHeader(), seriesList);\n+        unregistered.addAll(result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5NTQxNw==", "bodyText": "I suggest you just add a field of List in PathNotExistException, since concatenating a long string list is time-consuming.\nBesides, please perform a reformat.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444795417", "createdAt": "2020-06-24T10:22:29Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -914,8 +914,26 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       insertPlan.setSchemasAndTransferType(schemas);\n       StorageEngine.getInstance().insert(insertPlan);\n       if (insertPlan.getFailedMeasurements() != null) {\n-        throw new StorageEngineException(\n-            \"failed to insert points \" + insertPlan.getFailedMeasurements());\n+        // check if all path not exist exceptions\n+        List<String> failedPaths = new ArrayList<>(insertPlan.getFailedMeasurements().keySet());\n+        List<Exception> exceptions = new ArrayList<>(insertPlan.getFailedMeasurements().values());\n+        boolean isPathNotExistException = true;\n+        for(Exception e : exceptions){\n+          Exception curException = e;\n+          while(curException.getCause() != null){\n+            curException = (Exception) curException.getCause();\n+          }\n+          if(!(curException instanceof PathNotExistException)){\n+            isPathNotExistException = false;\n+            break;\n+          }\n+        }\n+        if(isPathNotExistException){\n+          throw new PathNotExistException(failedPaths.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5NjIwOQ==", "bodyText": "You may just define this as a Throwable so you may avoid the typecast.", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444796209", "createdAt": "2020-06-24T10:23:57Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -914,8 +914,26 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       insertPlan.setSchemasAndTransferType(schemas);\n       StorageEngine.getInstance().insert(insertPlan);\n       if (insertPlan.getFailedMeasurements() != null) {\n-        throw new StorageEngineException(\n-            \"failed to insert points \" + insertPlan.getFailedMeasurements());\n+        // check if all path not exist exceptions\n+        List<String> failedPaths = new ArrayList<>(insertPlan.getFailedMeasurements().keySet());\n+        List<Exception> exceptions = new ArrayList<>(insertPlan.getFailedMeasurements().values());\n+        boolean isPathNotExistException = true;\n+        for(Exception e : exceptions){\n+          Exception curException = e;\n+          while(curException.getCause() != null){\n+            curException = (Exception) curException.getCause();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acc18960ae7318bcafa49271f90398eaeca11ff3", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/acc18960ae7318bcafa49271f90398eaeca11ff3", "committedDate": "2020-06-24T14:34:53Z", "message": "exception message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10f19941e1e5986189b6fa35c767e69615b8bfa2", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/10f19941e1e5986189b6fa35c767e69615b8bfa2", "committedDate": "2020-06-24T14:37:31Z", "message": "fix conflict"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NzM3NDc0", "url": "https://github.com/apache/iotdb/pull/1387#pullrequestreview-438737474", "createdAt": "2020-06-28T02:23:36Z", "commit": {"oid": "10f19941e1e5986189b6fa35c767e69615b8bfa2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef2fd52fa5ef78aea2de64070746ae3b674c711a", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/ef2fd52fa5ef78aea2de64070746ae3b674c711a", "committedDate": "2020-06-28T07:13:15Z", "message": "test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9ba68f83d885a4adde57ec6c9eb705ec49dd8d9", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/b9ba68f83d885a4adde57ec6c9eb705ec49dd8d9", "committedDate": "2020-06-28T07:26:14Z", "message": "fix sonar"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NzYwNjg3", "url": "https://github.com/apache/iotdb/pull/1387#pullrequestreview-438760687", "createdAt": "2020-06-28T09:07:29Z", "commit": {"oid": "b9ba68f83d885a4adde57ec6c9eb705ec49dd8d9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwOTowNzozMFrOGp7wnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwOTowNzozMFrOGp7wnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyMzkwMw==", "bodyText": "Why change this?", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r446623903", "createdAt": "2020-06-28T09:07:30Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1586,7 +1586,7 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n           }\n           return executeNonQuery(plan);\n         } catch (MetadataException e) {\n-          logger.error(\"Failed to set storage group or create timeseries, because {}\", e);\n+          logger.error(String.format(\"Failed to set storage group or create timeseries, because %s\", e));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9ba68f83d885a4adde57ec6c9eb705ec49dd8d9"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3592, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}