{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyMjk5OTMw", "number": 2184, "reviewThreads": {"totalCount": 40, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQwMjoyMjowNFrOFP1C8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNDoxODozMVrOFQOcpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMTQyMDY3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQwMjoyMjowNFrOIVX_LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQwMjoyMjowNFrOIVX_LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI4NDAxMw==", "bodyText": "It seems upgradeFolder has been created in line402.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559284013", "createdAt": "2021-01-18T02:22:04Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -334,18 +342,117 @@ private void checkUnClosedTsFileV2InFolders(List<String> folders) {\n           if (!partitionDir.isDirectory()) {\n             continue;\n           }\n-          File[] tsfiles = FSFactoryProducer.getFSFactory()\n-            .listFilesBySuffix(partitionDir.toString(), TsFileConstant.TSFILE_SUFFIX);\n-          File[] resources = FSFactoryProducer.getFSFactory()\n-            .listFilesBySuffix(partitionDir.toString(), TsFileResource.RESOURCE_SUFFIX);\n+          File[] tsfiles = fsFactory\n+              .listFilesBySuffix(partitionDir.toString(), TsFileConstant.TSFILE_SUFFIX);\n+          File[] resources = fsFactory\n+              .listFilesBySuffix(partitionDir.toString(), TsFileResource.RESOURCE_SUFFIX);\n           if (tsfiles.length != resources.length) {\n-            logger.error(\"Unclosed Version-2 TsFile detected, please run 'flush' on v0.10 IoTDB\"\n-              + \" before upgrading to v0.11\");\n-            System.exit(-1);\n+            // If upgrading from v0.11.2 to v0.12, there may be some Unclosed merging files.\n+            // We have to delete these files before upgrading\n+            File[] unmergedTsfiles = fsFactory\n+                .listFilesBySuffix(partitionDir.toString(), \"0\" + TsFileConstant.TSFILE_SUFFIX);\n+            File[] unmergedResources = fsFactory\n+                .listFilesBySuffix(partitionDir.toString(), \"0\" + TsFileResource.RESOURCE_SUFFIX);\n+            if (unmergedTsfiles.length != unmergedResources.length) {\n+              logger.error(\"Unclosed Version-2 TsFile detected, please stop insertion, then run 'flush' \"\n+                  + \"on v0.11 IoTDB before upgrading to v0.12\");\n+              System.exit(-1);\n+            }\n+            deleteMergeingTsFiles(tsfiles, resources);\n           }\n         }\n       }\n     }\n   }\n+\n+  private void deleteMergeingTsFiles(File[] tsfiles, File[] resources) {\n+    Set<String> resourcesSet = new HashSet<>();\n+    for (File resource : resources) {\n+      resourcesSet.add(resource.getName());\n+    }\n+    for (File tsfile : tsfiles) {\n+      if (!resourcesSet.contains(tsfile.getName() + TsFileResource.RESOURCE_SUFFIX)) {\n+        if (!tsfile.delete()) {\n+          logger.error(\"Failed to delete merging tsfile {}\", tsfile);\n+          System.exit(-1);\n+        }\n+      }\n+    }\n+  }\n+\n+  private void moveTsFileV2() {\n+    moveFileToUpgradeFolder(DirectoryManager.getInstance().getAllSequenceFileFolders());\n+    moveFileToUpgradeFolder(DirectoryManager.getInstance().getAllUnSequenceFileFolders());\n+    logger.info(\"Move version-2 TsFile successfully\");\n+  }\n+\n+  @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n+  private void moveFileToUpgradeFolder(List<String> folders) {\n+    for (String baseDir : folders) {\n+      File fileFolder = fsFactory.getFile(baseDir);\n+      if (!fileFolder.isDirectory()) {\n+        continue;\n+      }\n+      for (File storageGroup : fileFolder.listFiles()) {\n+        if (!storageGroup.isDirectory()) {\n+          continue;\n+        }\n+        File upgradeFolder = fsFactory.getFile(storageGroup, IoTDBConstant.UPGRADE_FOLDER_NAME);\n+        // create upgrade directory if not exist\n+        if (upgradeFolder.mkdirs()) {\n+          logger.info(\"Upgrade Directory {} doesn't exist, create it\",\n+              upgradeFolder.getPath());\n+        } else if (!upgradeFolder.exists()) {\n+          logger.error(\"Create upgrade Directory {} failed\",\n+              upgradeFolder.getPath());\n+        }\n+        for (File partitionDir : storageGroup.listFiles()) {\n+          if (!partitionDir.isDirectory() || \n+              partitionDir.getName().equals(IoTDBConstant.UPGRADE_FOLDER_NAME)) {\n+            continue;\n+          }\n+          File[] oldTsfileArray = fsFactory\n+              .listFilesBySuffix(partitionDir.getAbsolutePath(), TsFileConstant.TSFILE_SUFFIX);\n+          File[] oldResourceFileArray = fsFactory\n+              .listFilesBySuffix(partitionDir.getAbsolutePath(), TsFileResource.RESOURCE_SUFFIX);\n+          File[] oldModificationFileArray = fsFactory\n+              .listFilesBySuffix(partitionDir.getAbsolutePath(), ModificationFile.FILE_SUFFIX);\n+          // move the old files to upgrade folder if exists\n+          if (oldTsfileArray.length != 0) {\n+            // create upgrade directory if not exist\n+            if (upgradeFolder.mkdirs()) {\n+              logger.info(\"Upgrade Directory {} doesn't exist, create it\",\n+                  upgradeFolder.getPath());\n+            } else if (!upgradeFolder.exists()) {\n+              logger.error(\"Create upgrade Directory {} failed\",\n+                  upgradeFolder.getPath());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b389da33961cce1852b8acc3a691dfea75630f54"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMTQyNzQ1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQwMjoyNzowN1rOIVYC4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNjoyNzozOFrOIWAA7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI4NDk2Mw==", "bodyText": "Remove this if it is truly unused.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559284963", "createdAt": "2021-01-18T02:27:07Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1748,10 +1717,39 @@ private void upgradeTsFileResourceCallBack(TsFileResource tsFileResource) {\n           }\n         }\n       }\n-      if (StorageEngine.getInstance().countUpgradeFiles() == 0) {\n-        UpgradeSevice.getINSTANCE().stop();\n+//      if (StorageEngine.getInstance().countUpgradeFiles() == 0) {\n+//        UpgradeSevice.getINSTANCE().stop();\n+//      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b389da33961cce1852b8acc3a691dfea75630f54"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkzOTgyMw==", "bodyText": "removed", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559939823", "createdAt": "2021-01-19T06:27:38Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1748,10 +1717,39 @@ private void upgradeTsFileResourceCallBack(TsFileResource tsFileResource) {\n           }\n         }\n       }\n-      if (StorageEngine.getInstance().countUpgradeFiles() == 0) {\n-        UpgradeSevice.getINSTANCE().stop();\n+//      if (StorageEngine.getInstance().countUpgradeFiles() == 0) {\n+//        UpgradeSevice.getINSTANCE().stop();\n+//      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI4NDk2Mw=="}, "originalCommit": {"oid": "b389da33961cce1852b8acc3a691dfea75630f54"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMTQzMTcwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQwMjoyOTozMlrOIVYFJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNjozMjoxNVrOIWAG8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI4NTU0Mw==", "bodyText": "Just to confirm, what if the storage group name contains a comma?", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559285543", "createdAt": "2021-01-18T02:29:32Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1748,10 +1717,39 @@ private void upgradeTsFileResourceCallBack(TsFileResource tsFileResource) {\n           }\n         }\n       }\n-      if (StorageEngine.getInstance().countUpgradeFiles() == 0) {\n-        UpgradeSevice.getINSTANCE().stop();\n+//      if (StorageEngine.getInstance().countUpgradeFiles() == 0) {\n+//        UpgradeSevice.getINSTANCE().stop();\n+//      }\n+    }\n+  }\n+\n+  private void loadUpgradedResources(List<TsFileResource> resources, boolean isseq) {\n+    if (resources.isEmpty()) {\n+      return;\n+    }\n+    for (TsFileResource resource : resources) {\n+      try {\n+        UpgradeUtils.moveUpgradedFiles(resource);\n+        tsFileManagement.addAll(resource.getUpgradedResources(), isseq); \n+        // delete old TsFile and resource\n+        resource.delete();\n+        UpgradeLog.writeUpgradeLogFile(\n+            resource.getTsFile().getAbsolutePath() + \",\" + UpgradeCheckStatus.UPGRADE_SUCCESS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b389da33961cce1852b8acc3a691dfea75630f54"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk0MTM2MQ==", "bodyText": "Name of storage group can only be characters, numbers and underscores.\nSee https://iotdb.apache.org/UserGuide/Master/Concept/Data%20Model%20and%20Terminology.html", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559941361", "createdAt": "2021-01-19T06:32:15Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1748,10 +1717,39 @@ private void upgradeTsFileResourceCallBack(TsFileResource tsFileResource) {\n           }\n         }\n       }\n-      if (StorageEngine.getInstance().countUpgradeFiles() == 0) {\n-        UpgradeSevice.getINSTANCE().stop();\n+//      if (StorageEngine.getInstance().countUpgradeFiles() == 0) {\n+//        UpgradeSevice.getINSTANCE().stop();\n+//      }\n+    }\n+  }\n+\n+  private void loadUpgradedResources(List<TsFileResource> resources, boolean isseq) {\n+    if (resources.isEmpty()) {\n+      return;\n+    }\n+    for (TsFileResource resource : resources) {\n+      try {\n+        UpgradeUtils.moveUpgradedFiles(resource);\n+        tsFileManagement.addAll(resource.getUpgradedResources(), isseq); \n+        // delete old TsFile and resource\n+        resource.delete();\n+        UpgradeLog.writeUpgradeLogFile(\n+            resource.getTsFile().getAbsolutePath() + \",\" + UpgradeCheckStatus.UPGRADE_SUCCESS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI4NTU0Mw=="}, "originalCommit": {"oid": "b389da33961cce1852b8acc3a691dfea75630f54"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMTQ4MDY0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/tools/upgrade/TsFileOnlineUpgradeTool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQwMzowMDoxOFrOIVYgGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNjo1MDoyNlrOIWAfng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI5MjQ0MQ==", "bodyText": "It would be better to add a comment and explain why such data types need decoding.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559292441", "createdAt": "2021-01-18T03:00:18Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/tools/upgrade/TsFileOnlineUpgradeTool.java", "diffHunk": "@@ -319,118 +104,133 @@ private ByteBuffer readData(long position, int size) throws IOException {\n    * @throws IOException, WriteProcessException\n    */\n   @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n-  public void upgradeFile(List<TsFileResource> upgradedResources)\n+  private void upgradeFile(List<TsFileResource> upgradedResources)\n       throws IOException, WriteProcessException {\n-    File oldTsFile = FSFactoryProducer.getFSFactory().getFile(this.file);\n \n-    // check if the old TsFile has correct header \n-    if (!fileCheck(oldTsFile)) {\n+    // check if the old TsFile has correct header\n+    if (!fileCheck()) {\n       return;\n     }\n \n+    int headerLength = TSFileConfig.MAGIC_STRING.getBytes().length +\n+        TSFileConfig.VERSION_NUMBER_V2.getBytes().length;\n+    reader.position(headerLength);\n     // start to scan chunks and chunkGroups\n     boolean newChunkGroup = true;\n-    int chunkGroupCount = 0;\n     List<List<PageHeader>> pageHeadersInChunkGroup = new ArrayList<>();\n     List<List<ByteBuffer>> pageDataInChunkGroup = new ArrayList<>();\n-    List<List<Boolean>> pagePartitionInfoInChunkGroup = new ArrayList<>();\n+    List<List<Boolean>> needToDecodeInfoInChunkGroup = new ArrayList<>();\n     byte marker;\n     List<MeasurementSchema> measurementSchemaList = new ArrayList<>();\n     try {\n-      while ((marker = this.readMarker()) != MetaMarker.SEPARATOR) {\n+      while ((marker = reader.readMarker()) != MetaMarker.SEPARATOR) {\n         switch (marker) {\n           case MetaMarker.CHUNK_HEADER:\n             // this is the first chunk of a new ChunkGroup.\n             if (newChunkGroup) {\n               newChunkGroup = false;\n             }\n-            ChunkHeader header = this.readChunkHeader();\n-            MeasurementSchema measurementSchema = new MeasurementSchema(header.getMeasurementID(),\n+            ChunkHeader header = reader.readChunkHeader();\n+            MeasurementSchema measurementSchema = new MeasurementSchema(\n+                header.getMeasurementID(),\n                 header.getDataType(),\n                 header.getEncodingType(),\n                 header.getCompressionType());\n             measurementSchemaList.add(measurementSchema);\n+            TSDataType dataType = header.getDataType();\n+            TSEncoding encoding = header.getEncodingType();\n             List<PageHeader> pageHeadersInChunk = new ArrayList<>();\n             List<ByteBuffer> dataInChunk = new ArrayList<>();\n-            List<Boolean> pagePartitionInfo = new ArrayList<>();\n+            List<Boolean> needToDecodeInfo = new ArrayList<>();\n             for (int j = 0; j < header.getNumOfPages(); j++) {\n-              PageHeader pageHeader = readPageHeader(header.getDataType());\n-              boolean pageInSamePartition = checkIfPageInSameTimePartition(pageHeader);\n-              pagePartitionInfo.add(pageInSamePartition);\n-              ByteBuffer pageData = pageInSamePartition ?\n-                  readCompressedPage(pageHeader)\n-                  : readPage(pageHeader, header.getCompressionType());\n+              // a new Page\n+              PageHeader pageHeader = reader.readPageHeader(dataType);\n+              boolean needToDecode = \n+                  checkIfNeedToDecode(dataType, encoding, pageHeader);\n+              needToDecodeInfo.add(needToDecode);\n+              ByteBuffer pageData = !needToDecode\n+                  ? reader.readCompressedPage(pageHeader) \n+                  : reader.readPage(pageHeader, header.getCompressionType());\n               pageHeadersInChunk.add(pageHeader);\n               dataInChunk.add(pageData);\n             }\n             pageHeadersInChunkGroup.add(pageHeadersInChunk);\n             pageDataInChunkGroup.add(dataInChunk);\n-            pagePartitionInfoInChunkGroup.add(pagePartitionInfo);\n+            needToDecodeInfoInChunkGroup.add(needToDecodeInfo);\n             break;\n-          case MetaMarker.CHUNK_GROUP_FOOTER:\n+          case MetaMarker.CHUNK_GROUP_HEADER:\n             // this is the footer of a ChunkGroup.\n-            ChunkGroupFooter chunkGroupFooter = this.readChunkGroupFooter();\n+            ChunkGroupHeader chunkGroupFooter = reader.readChunkGroupFooter();\n             String deviceID = chunkGroupFooter.getDeviceID();\n-            rewrite(oldTsFile, deviceID, measurementSchemaList, pageHeadersInChunkGroup,\n-                pageDataInChunkGroup, pagePartitionInfoInChunkGroup);\n-\n+            rewrite(deviceID, measurementSchemaList, pageHeadersInChunkGroup,\n+                pageDataInChunkGroup, needToDecodeInfoInChunkGroup);\n             pageHeadersInChunkGroup.clear();\n             pageDataInChunkGroup.clear();\n             measurementSchemaList.clear();\n-            pagePartitionInfoInChunkGroup.clear();\n+            needToDecodeInfoInChunkGroup.clear();\n             newChunkGroup = true;\n-            chunkGroupCount++;\n             break;\n-\n+          case MetaMarker.VERSION:\n+            reader.readVersion();\n+            // write plan indices\n+            for (TsFileIOWriter tsFileIOWriter : partitionWriterMap.values()) { \n+              tsFileIOWriter.writePlanIndices(); \n+            }\n+            break;\n           default:\n             // the disk file is corrupted, using this file may be dangerous\n-            logger.error(\"Unrecognized marker detected, this file may be corrupted\");\n-            return;\n+            throw new IOException(\"Unrecognized marker detected, \"\n+                + \"this file may be corrupted\");\n         }\n       }\n       // close upgraded tsFiles and generate resources for them\n       for (TsFileIOWriter tsFileIOWriter : partitionWriterMap.values()) {\n         upgradedResources.add(endFileAndGenerateResource(tsFileIOWriter));\n       }\n     } catch (IOException e2) {\n-      logger.info(\"TsFile upgrade process cannot proceed at position {} after {} chunk groups \"\n-          + \"recovered, because : {}\", this.position(), chunkGroupCount, e2.getMessage());\n+      throw new IOException(\"TsFile upgrade process cannot proceed at position \" +\n+          reader.position() + \"because: \" + e2.getMessage());\n     } finally {\n-      if (tsFileInput != null) {\n-        tsFileInput.close();\n+      if (reader != null) {\n+        reader.close();\n       }\n     }\n   }\n \n-  private boolean checkIfPageInSameTimePartition(PageHeader pageHeader) {\n-    return StorageEngine.getTimePartition(pageHeader.getStartTime())\n-        == StorageEngine.getTimePartition(pageHeader.getEndTime());\n+  private boolean checkIfNeedToDecode(TSDataType dataType, TSEncoding encoding,\n+      PageHeader pageHeader) {\n+    return dataType == TSDataType.BOOLEAN ||\n+        dataType == TSDataType.TEXT ||\n+        (dataType == TSDataType.INT32 && encoding == TSEncoding.PLAIN) ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b389da33961cce1852b8acc3a691dfea75630f54"}, "originalPosition": 416}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk0NzY3OA==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559947678", "createdAt": "2021-01-19T06:50:26Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/tools/upgrade/TsFileOnlineUpgradeTool.java", "diffHunk": "@@ -319,118 +104,133 @@ private ByteBuffer readData(long position, int size) throws IOException {\n    * @throws IOException, WriteProcessException\n    */\n   @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n-  public void upgradeFile(List<TsFileResource> upgradedResources)\n+  private void upgradeFile(List<TsFileResource> upgradedResources)\n       throws IOException, WriteProcessException {\n-    File oldTsFile = FSFactoryProducer.getFSFactory().getFile(this.file);\n \n-    // check if the old TsFile has correct header \n-    if (!fileCheck(oldTsFile)) {\n+    // check if the old TsFile has correct header\n+    if (!fileCheck()) {\n       return;\n     }\n \n+    int headerLength = TSFileConfig.MAGIC_STRING.getBytes().length +\n+        TSFileConfig.VERSION_NUMBER_V2.getBytes().length;\n+    reader.position(headerLength);\n     // start to scan chunks and chunkGroups\n     boolean newChunkGroup = true;\n-    int chunkGroupCount = 0;\n     List<List<PageHeader>> pageHeadersInChunkGroup = new ArrayList<>();\n     List<List<ByteBuffer>> pageDataInChunkGroup = new ArrayList<>();\n-    List<List<Boolean>> pagePartitionInfoInChunkGroup = new ArrayList<>();\n+    List<List<Boolean>> needToDecodeInfoInChunkGroup = new ArrayList<>();\n     byte marker;\n     List<MeasurementSchema> measurementSchemaList = new ArrayList<>();\n     try {\n-      while ((marker = this.readMarker()) != MetaMarker.SEPARATOR) {\n+      while ((marker = reader.readMarker()) != MetaMarker.SEPARATOR) {\n         switch (marker) {\n           case MetaMarker.CHUNK_HEADER:\n             // this is the first chunk of a new ChunkGroup.\n             if (newChunkGroup) {\n               newChunkGroup = false;\n             }\n-            ChunkHeader header = this.readChunkHeader();\n-            MeasurementSchema measurementSchema = new MeasurementSchema(header.getMeasurementID(),\n+            ChunkHeader header = reader.readChunkHeader();\n+            MeasurementSchema measurementSchema = new MeasurementSchema(\n+                header.getMeasurementID(),\n                 header.getDataType(),\n                 header.getEncodingType(),\n                 header.getCompressionType());\n             measurementSchemaList.add(measurementSchema);\n+            TSDataType dataType = header.getDataType();\n+            TSEncoding encoding = header.getEncodingType();\n             List<PageHeader> pageHeadersInChunk = new ArrayList<>();\n             List<ByteBuffer> dataInChunk = new ArrayList<>();\n-            List<Boolean> pagePartitionInfo = new ArrayList<>();\n+            List<Boolean> needToDecodeInfo = new ArrayList<>();\n             for (int j = 0; j < header.getNumOfPages(); j++) {\n-              PageHeader pageHeader = readPageHeader(header.getDataType());\n-              boolean pageInSamePartition = checkIfPageInSameTimePartition(pageHeader);\n-              pagePartitionInfo.add(pageInSamePartition);\n-              ByteBuffer pageData = pageInSamePartition ?\n-                  readCompressedPage(pageHeader)\n-                  : readPage(pageHeader, header.getCompressionType());\n+              // a new Page\n+              PageHeader pageHeader = reader.readPageHeader(dataType);\n+              boolean needToDecode = \n+                  checkIfNeedToDecode(dataType, encoding, pageHeader);\n+              needToDecodeInfo.add(needToDecode);\n+              ByteBuffer pageData = !needToDecode\n+                  ? reader.readCompressedPage(pageHeader) \n+                  : reader.readPage(pageHeader, header.getCompressionType());\n               pageHeadersInChunk.add(pageHeader);\n               dataInChunk.add(pageData);\n             }\n             pageHeadersInChunkGroup.add(pageHeadersInChunk);\n             pageDataInChunkGroup.add(dataInChunk);\n-            pagePartitionInfoInChunkGroup.add(pagePartitionInfo);\n+            needToDecodeInfoInChunkGroup.add(needToDecodeInfo);\n             break;\n-          case MetaMarker.CHUNK_GROUP_FOOTER:\n+          case MetaMarker.CHUNK_GROUP_HEADER:\n             // this is the footer of a ChunkGroup.\n-            ChunkGroupFooter chunkGroupFooter = this.readChunkGroupFooter();\n+            ChunkGroupHeader chunkGroupFooter = reader.readChunkGroupFooter();\n             String deviceID = chunkGroupFooter.getDeviceID();\n-            rewrite(oldTsFile, deviceID, measurementSchemaList, pageHeadersInChunkGroup,\n-                pageDataInChunkGroup, pagePartitionInfoInChunkGroup);\n-\n+            rewrite(deviceID, measurementSchemaList, pageHeadersInChunkGroup,\n+                pageDataInChunkGroup, needToDecodeInfoInChunkGroup);\n             pageHeadersInChunkGroup.clear();\n             pageDataInChunkGroup.clear();\n             measurementSchemaList.clear();\n-            pagePartitionInfoInChunkGroup.clear();\n+            needToDecodeInfoInChunkGroup.clear();\n             newChunkGroup = true;\n-            chunkGroupCount++;\n             break;\n-\n+          case MetaMarker.VERSION:\n+            reader.readVersion();\n+            // write plan indices\n+            for (TsFileIOWriter tsFileIOWriter : partitionWriterMap.values()) { \n+              tsFileIOWriter.writePlanIndices(); \n+            }\n+            break;\n           default:\n             // the disk file is corrupted, using this file may be dangerous\n-            logger.error(\"Unrecognized marker detected, this file may be corrupted\");\n-            return;\n+            throw new IOException(\"Unrecognized marker detected, \"\n+                + \"this file may be corrupted\");\n         }\n       }\n       // close upgraded tsFiles and generate resources for them\n       for (TsFileIOWriter tsFileIOWriter : partitionWriterMap.values()) {\n         upgradedResources.add(endFileAndGenerateResource(tsFileIOWriter));\n       }\n     } catch (IOException e2) {\n-      logger.info(\"TsFile upgrade process cannot proceed at position {} after {} chunk groups \"\n-          + \"recovered, because : {}\", this.position(), chunkGroupCount, e2.getMessage());\n+      throw new IOException(\"TsFile upgrade process cannot proceed at position \" +\n+          reader.position() + \"because: \" + e2.getMessage());\n     } finally {\n-      if (tsFileInput != null) {\n-        tsFileInput.close();\n+      if (reader != null) {\n+        reader.close();\n       }\n     }\n   }\n \n-  private boolean checkIfPageInSameTimePartition(PageHeader pageHeader) {\n-    return StorageEngine.getTimePartition(pageHeader.getStartTime())\n-        == StorageEngine.getTimePartition(pageHeader.getEndTime());\n+  private boolean checkIfNeedToDecode(TSDataType dataType, TSEncoding encoding,\n+      PageHeader pageHeader) {\n+    return dataType == TSDataType.BOOLEAN ||\n+        dataType == TSDataType.TEXT ||\n+        (dataType == TSDataType.INT32 && encoding == TSEncoding.PLAIN) ||", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI5MjQ0MQ=="}, "originalCommit": {"oid": "b389da33961cce1852b8acc3a691dfea75630f54"}, "originalPosition": 416}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMTUxMzA3OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/header/ChunkGroupHeader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQwMzoyMjowOFrOIVYyQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNzo0NDoyMlrOIWBzWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI5NzA4OA==", "bodyText": "String.getBytes is a bit wasteful here as the conversion result is discarded immediately, but I think maybe you can make this method non-static and cache the returned byte[] in this object, and use it when serializeTo is called.\nThe same technique may be applied to other structures where string length is calculated before actually serialized.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559297088", "createdAt": "2021-01-18T03:22:08Z", "author": {"login": "jt2594838"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/header/ChunkGroupHeader.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.tsfile.file.header;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import org.apache.iotdb.tsfile.common.conf.TSFileConfig;\n+import org.apache.iotdb.tsfile.file.MetaMarker;\n+import org.apache.iotdb.tsfile.read.reader.TsFileInput;\n+import org.apache.iotdb.tsfile.utils.ReadWriteForEncodingUtils;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+\n+public class ChunkGroupHeader {\n+\n+  private static final byte MARKER = MetaMarker.CHUNK_GROUP_HEADER;\n+\n+  private final String deviceID;\n+\n+  // this field does not need to be serialized.\n+  private int serializedSize;\n+\n+  /**\n+   * constructor of CHUNK_GROUP_FOOTER.\n+   *  @param deviceID       device ID\n+   *\n+   */\n+  public ChunkGroupHeader(String deviceID) {\n+    this.deviceID = deviceID;\n+    this.serializedSize = getSerializedSize(deviceID);\n+  }\n+\n+  public static int getSerializedSize(String deviceID) {\n+    int length = deviceID.getBytes(TSFileConfig.STRING_CHARSET).length;\n+    return Byte.BYTES + ReadWriteForEncodingUtils.varIntSize(length) + length;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b389da33961cce1852b8acc3a691dfea75630f54"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk2OTExMw==", "bodyText": "Actually, the method is called only once in the contructor method. But you are right, this method shouldn't be a statis method, it should be a private and non-static method", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559969113", "createdAt": "2021-01-19T07:44:22Z", "author": {"login": "JackieTien97"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/header/ChunkGroupHeader.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.tsfile.file.header;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import org.apache.iotdb.tsfile.common.conf.TSFileConfig;\n+import org.apache.iotdb.tsfile.file.MetaMarker;\n+import org.apache.iotdb.tsfile.read.reader.TsFileInput;\n+import org.apache.iotdb.tsfile.utils.ReadWriteForEncodingUtils;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+\n+public class ChunkGroupHeader {\n+\n+  private static final byte MARKER = MetaMarker.CHUNK_GROUP_HEADER;\n+\n+  private final String deviceID;\n+\n+  // this field does not need to be serialized.\n+  private int serializedSize;\n+\n+  /**\n+   * constructor of CHUNK_GROUP_FOOTER.\n+   *  @param deviceID       device ID\n+   *\n+   */\n+  public ChunkGroupHeader(String deviceID) {\n+    this.deviceID = deviceID;\n+    this.serializedSize = getSerializedSize(deviceID);\n+  }\n+\n+  public static int getSerializedSize(String deviceID) {\n+    int length = deviceID.getBytes(TSFileConfig.STRING_CHARSET).length;\n+    return Byte.BYTES + ReadWriteForEncodingUtils.varIntSize(length) + length;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI5NzA4OA=="}, "originalCommit": {"oid": "b389da33961cce1852b8acc3a691dfea75630f54"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMTUyMDExOnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/header/ChunkHeader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQwMzoyNzowMlrOIVY2OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQwMzoyNzowMlrOIVY2OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI5ODEwNA==", "bodyText": "Better to use some final static fields to explain this. And is it really necessary to use the numbers from Marker? It is confusing when you have 1 and 4, but there are no 2 and 3.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559298104", "createdAt": "2021-01-18T03:27:02Z", "author": {"login": "jt2594838"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/header/ChunkHeader.java", "diffHunk": "@@ -33,101 +34,119 @@\n \n public class ChunkHeader {\n \n+\n+  /**\n+   * 1 means this chunk has more than one page, so each page has its own page statistic 4 means this\n+   * chunk has only one page, and this page has no page statistic\n+   */\n+  private byte chunkType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b389da33961cce1852b8acc3a691dfea75630f54"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMTUzOTQ1OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/ChunkMetadata.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQwMzozODo1NFrOIVZAwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQwMzozODo1NFrOIVZAwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMwMDgwMg==", "bodyText": "Better to wrap this in a more semantic way.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559300802", "createdAt": "2021-01-18T03:38:54Z", "author": {"login": "jt2594838"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/ChunkMetadata.java", "diffHunk": "@@ -142,31 +142,32 @@ public TSDataType getDataType() {\n    * @return length\n    * @throws IOException IOException\n    */\n-  public int serializeTo(OutputStream outputStream) throws IOException {\n+  public int serializeTo(OutputStream outputStream, boolean serializeStatistic) throws IOException {\n     int byteLen = 0;\n-\n-    byteLen += ReadWriteIOUtils.write(measurementUid, outputStream);\n     byteLen += ReadWriteIOUtils.write(offsetOfChunkHeader, outputStream);\n-    byteLen += ReadWriteIOUtils.write(tsDataType, outputStream);\n-    byteLen += statistics.serialize(outputStream);\n+    if (serializeStatistic) {\n+      byteLen += statistics.serialize(outputStream);\n+    }\n     return byteLen;\n   }\n \n   /**\n    * deserialize from ByteBuffer.\n    *\n-   * @param buffer ByteBuffer\n+   * @param buffer          ByteBuffer\n    * @return ChunkMetaData object\n    */\n-  public static ChunkMetadata deserializeFrom(ByteBuffer buffer) {\n+  public static ChunkMetadata deserializeFrom(ByteBuffer buffer, TimeseriesMetadata timeseriesMetadata) {\n     ChunkMetadata chunkMetaData = new ChunkMetadata();\n \n-    chunkMetaData.measurementUid = ReadWriteIOUtils.readString(buffer);\n+    chunkMetaData.measurementUid = timeseriesMetadata.getMeasurementId();\n+    chunkMetaData.tsDataType = timeseriesMetadata.getTSDataType();\n     chunkMetaData.offsetOfChunkHeader = ReadWriteIOUtils.readLong(buffer);\n-    chunkMetaData.tsDataType = ReadWriteIOUtils.readDataType(buffer);\n-\n-    chunkMetaData.statistics = Statistics.deserialize(buffer, chunkMetaData.tsDataType);\n-\n+    if (timeseriesMetadata.getTimeSeriesMetadataType() != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b389da33961cce1852b8acc3a691dfea75630f54"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMTU0NDIxOnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/TimeseriesMetadata.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQwMzo0MjoxOFrOIVZDZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQwMzo0MjoxOFrOIVZDZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMwMTQ3OQ==", "bodyText": "How about changing it to a boolean and using a more accurate name?", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559301479", "createdAt": "2021-01-18T03:42:18Z", "author": {"login": "jt2594838"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/TimeseriesMetadata.java", "diffHunk": "@@ -27,10 +27,17 @@\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n import org.apache.iotdb.tsfile.read.controller.IChunkMetadataLoader;\n+import org.apache.iotdb.tsfile.utils.ReadWriteForEncodingUtils;\n import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n \n public class TimeseriesMetadata implements Accountable {\n \n+  /**\n+   * 0 means this time series has only one chunk, no need to save the statistic again in chunk metadata\n+   * 1 means this time series has more than one chunk, should save the statistic again in chunk metadata\n+   */\n+  private byte timeSeriesMetadataType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b389da33961cce1852b8acc3a691dfea75630f54"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMjkxMjMzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMTozOToyNVrOIVlhPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwMTo1NzowNlrOIV7pig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUwNTcyNw==", "bodyText": "The comments belong to line 369.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559505727", "createdAt": "2021-01-18T11:39:25Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -334,18 +342,117 @@ private void checkUnClosedTsFileV2InFolders(List<String> folders) {\n           if (!partitionDir.isDirectory()) {\n             continue;\n           }\n-          File[] tsfiles = FSFactoryProducer.getFSFactory()\n-            .listFilesBySuffix(partitionDir.toString(), TsFileConstant.TSFILE_SUFFIX);\n-          File[] resources = FSFactoryProducer.getFSFactory()\n-            .listFilesBySuffix(partitionDir.toString(), TsFileResource.RESOURCE_SUFFIX);\n+          File[] tsfiles = fsFactory\n+              .listFilesBySuffix(partitionDir.toString(), TsFileConstant.TSFILE_SUFFIX);\n+          File[] resources = fsFactory\n+              .listFilesBySuffix(partitionDir.toString(), TsFileResource.RESOURCE_SUFFIX);\n           if (tsfiles.length != resources.length) {\n-            logger.error(\"Unclosed Version-2 TsFile detected, please run 'flush' on v0.10 IoTDB\"\n-              + \" before upgrading to v0.11\");\n-            System.exit(-1);\n+            // If upgrading from v0.11.2 to v0.12, there may be some Unclosed merging files.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg2ODI5OA==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559868298", "createdAt": "2021-01-19T01:57:06Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -334,18 +342,117 @@ private void checkUnClosedTsFileV2InFolders(List<String> folders) {\n           if (!partitionDir.isDirectory()) {\n             continue;\n           }\n-          File[] tsfiles = FSFactoryProducer.getFSFactory()\n-            .listFilesBySuffix(partitionDir.toString(), TsFileConstant.TSFILE_SUFFIX);\n-          File[] resources = FSFactoryProducer.getFSFactory()\n-            .listFilesBySuffix(partitionDir.toString(), TsFileResource.RESOURCE_SUFFIX);\n+          File[] tsfiles = fsFactory\n+              .listFilesBySuffix(partitionDir.toString(), TsFileConstant.TSFILE_SUFFIX);\n+          File[] resources = fsFactory\n+              .listFilesBySuffix(partitionDir.toString(), TsFileResource.RESOURCE_SUFFIX);\n           if (tsfiles.length != resources.length) {\n-            logger.error(\"Unclosed Version-2 TsFile detected, please run 'flush' on v0.10 IoTDB\"\n-              + \" before upgrading to v0.11\");\n-            System.exit(-1);\n+            // If upgrading from v0.11.2 to v0.12, there may be some Unclosed merging files.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUwNTcyNw=="}, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMjkxNjk4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMTo0MDo0M1rOIVlj4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwMjowMTo0N1rOIV7udA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUwNjQwMA==", "bodyText": "Point out that the upgrade tool will remove all files that having no resources, no matter whether they are complete tsfiles or in-merging files.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559506400", "createdAt": "2021-01-18T11:40:43Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -334,18 +342,117 @@ private void checkUnClosedTsFileV2InFolders(List<String> folders) {\n           if (!partitionDir.isDirectory()) {\n             continue;\n           }\n-          File[] tsfiles = FSFactoryProducer.getFSFactory()\n-            .listFilesBySuffix(partitionDir.toString(), TsFileConstant.TSFILE_SUFFIX);\n-          File[] resources = FSFactoryProducer.getFSFactory()\n-            .listFilesBySuffix(partitionDir.toString(), TsFileResource.RESOURCE_SUFFIX);\n+          File[] tsfiles = fsFactory\n+              .listFilesBySuffix(partitionDir.toString(), TsFileConstant.TSFILE_SUFFIX);\n+          File[] resources = fsFactory\n+              .listFilesBySuffix(partitionDir.toString(), TsFileResource.RESOURCE_SUFFIX);\n           if (tsfiles.length != resources.length) {\n-            logger.error(\"Unclosed Version-2 TsFile detected, please run 'flush' on v0.10 IoTDB\"\n-              + \" before upgrading to v0.11\");\n-            System.exit(-1);\n+            // If upgrading from v0.11.2 to v0.12, there may be some Unclosed merging files.\n+            // We have to delete these files before upgrading\n+            File[] unmergedTsfiles = fsFactory\n+                .listFilesBySuffix(partitionDir.toString(), \"0\" + TsFileConstant.TSFILE_SUFFIX);\n+            File[] unmergedResources = fsFactory\n+                .listFilesBySuffix(partitionDir.toString(), \"0\" + TsFileResource.RESOURCE_SUFFIX);\n+            if (unmergedTsfiles.length != unmergedResources.length) {\n+              logger.error(\"Unclosed Version-2 TsFile detected, please stop insertion, then run 'flush' \"\n+                  + \"on v0.11 IoTDB before upgrading to v0.12\");\n+              System.exit(-1);\n+            }\n+            deleteMergeingTsFiles(tsfiles, resources);\n           }\n         }\n       }\n     }\n   }\n+\n+  private void deleteMergeingTsFiles(File[] tsfiles, File[] resources) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg2OTU1Ng==", "bodyText": "eh... actually we won't remove level-0 tsfiles, even they may not have resources.. In this case, the log will guide users to  re-start 0.11 and run flush manually to seal those level-0 files.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559869556", "createdAt": "2021-01-19T02:01:47Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfigCheck.java", "diffHunk": "@@ -334,18 +342,117 @@ private void checkUnClosedTsFileV2InFolders(List<String> folders) {\n           if (!partitionDir.isDirectory()) {\n             continue;\n           }\n-          File[] tsfiles = FSFactoryProducer.getFSFactory()\n-            .listFilesBySuffix(partitionDir.toString(), TsFileConstant.TSFILE_SUFFIX);\n-          File[] resources = FSFactoryProducer.getFSFactory()\n-            .listFilesBySuffix(partitionDir.toString(), TsFileResource.RESOURCE_SUFFIX);\n+          File[] tsfiles = fsFactory\n+              .listFilesBySuffix(partitionDir.toString(), TsFileConstant.TSFILE_SUFFIX);\n+          File[] resources = fsFactory\n+              .listFilesBySuffix(partitionDir.toString(), TsFileResource.RESOURCE_SUFFIX);\n           if (tsfiles.length != resources.length) {\n-            logger.error(\"Unclosed Version-2 TsFile detected, please run 'flush' on v0.10 IoTDB\"\n-              + \" before upgrading to v0.11\");\n-            System.exit(-1);\n+            // If upgrading from v0.11.2 to v0.12, there may be some Unclosed merging files.\n+            // We have to delete these files before upgrading\n+            File[] unmergedTsfiles = fsFactory\n+                .listFilesBySuffix(partitionDir.toString(), \"0\" + TsFileConstant.TSFILE_SUFFIX);\n+            File[] unmergedResources = fsFactory\n+                .listFilesBySuffix(partitionDir.toString(), \"0\" + TsFileResource.RESOURCE_SUFFIX);\n+            if (unmergedTsfiles.length != unmergedResources.length) {\n+              logger.error(\"Unclosed Version-2 TsFile detected, please stop insertion, then run 'flush' \"\n+                  + \"on v0.11 IoTDB before upgrading to v0.12\");\n+              System.exit(-1);\n+            }\n+            deleteMergeingTsFiles(tsfiles, resources);\n           }\n         }\n       }\n     }\n   }\n+\n+  private void deleteMergeingTsFiles(File[] tsfiles, File[] resources) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUwNjQwMA=="}, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMzA0NTA5OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/header/ChunkGroupHeader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMjoxNjo0MFrOIVmwog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMjoxNjo0MFrOIVmwog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUyNjA1MA==", "bodyText": "replace all \"FOOTER\"s in this file", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559526050", "createdAt": "2021-01-18T12:16:40Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/header/ChunkGroupHeader.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.tsfile.file.header;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import org.apache.iotdb.tsfile.common.conf.TSFileConfig;\n+import org.apache.iotdb.tsfile.file.MetaMarker;\n+import org.apache.iotdb.tsfile.read.reader.TsFileInput;\n+import org.apache.iotdb.tsfile.utils.ReadWriteForEncodingUtils;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+\n+public class ChunkGroupHeader {\n+\n+  private static final byte MARKER = MetaMarker.CHUNK_GROUP_HEADER;\n+\n+  private final String deviceID;\n+\n+  // this field does not need to be serialized.\n+  private int serializedSize;\n+\n+  /**\n+   * constructor of CHUNK_GROUP_FOOTER.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMzA3OTg4OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/MetaMarker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMjoyNjoxMFrOIVnFOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMjoyNjoxMFrOIVnFOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUzMTMyMA==", "bodyText": "Chunk header marker and this chunk has more than one page.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559531320", "createdAt": "2021-01-18T12:26:10Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/MetaMarker.java", "diffHunk": "@@ -26,15 +26,24 @@\n  */\n public class MetaMarker {\n \n-  public static final byte CHUNK_GROUP_FOOTER = 0;\n+  public static final byte CHUNK_GROUP_HEADER = 0;\n+  /**\n+   * means this chunk has more than one page", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMzA5MTI1OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/MetaMarker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMjoyOToxMFrOIVnLyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMjoyOToxMFrOIVnLyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUzMzAwMw==", "bodyText": "Chunk header marker and this chunk has only one page.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559533003", "createdAt": "2021-01-18T12:29:10Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/MetaMarker.java", "diffHunk": "@@ -26,15 +26,24 @@\n  */\n public class MetaMarker {\n \n-  public static final byte CHUNK_GROUP_FOOTER = 0;\n+  public static final byte CHUNK_GROUP_HEADER = 0;\n+  /**\n+   * means this chunk has more than one page\n+   */\n   public static final byte CHUNK_HEADER = 1;\n   public static final byte SEPARATOR = 2;\n   public static final byte VERSION = 3;\n+  \n   // following this marker are two longs marking the minimum and maximum indices of operations\n   // involved in the last flushed MemTable, which are generally used to support checkpoint,\n   // snapshot, or backup.\n   public static final byte OPERATION_INDEX_RANGE = 4;\n \n+  /**\n+   * means this chunk has only one page", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMzA5NTE3OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/header/ChunkHeader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMjozMDoyMVrOIVnOQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMjozMDoyMVrOIVnOQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUzMzYzNQ==", "bodyText": "1 and 5!", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559533635", "createdAt": "2021-01-18T12:30:21Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/header/ChunkHeader.java", "diffHunk": "@@ -33,101 +34,119 @@\n \n public class ChunkHeader {\n \n+\n+  /**\n+   * 1 means this chunk has more than one page, so each page has its own page statistic 4 means this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMzEyMDI4OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/header/ChunkHeader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMjozNzo0MFrOIVndeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNjowMTozM1rOIV_giA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUzNzUzMA==", "bodyText": "this method begins from the position behind the marker, while the deserializeFrom(ByteBufer) begins from the position of the marker.\nIt is inconsistent and hard to maintain codes.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559537530", "createdAt": "2021-01-18T12:37:40Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/header/ChunkHeader.java", "diffHunk": "@@ -33,101 +34,119 @@\n \n public class ChunkHeader {\n \n+\n+  /**\n+   * 1 means this chunk has more than one page, so each page has its own page statistic 4 means this\n+   * chunk has only one page, and this page has no page statistic\n+   */\n+  private byte chunkType;\n   private String measurementID;\n   private int dataSize;\n   private TSDataType dataType;\n   private CompressionType compressionType;\n   private TSEncoding encodingType;\n-  private int numOfPages;\n \n-  // this field does not need to be serialized.\n+  // the following fields do not need to be serialized.\n+  private int numOfPages;\n   private int serializedSize;\n \n   public ChunkHeader(String measurementID, int dataSize, TSDataType dataType,\n-      CompressionType compressionType,\n-      TSEncoding encoding, int numOfPages) {\n-    this(measurementID, dataSize, getSerializedSize(measurementID), dataType, compressionType,\n-        encoding, numOfPages);\n+      CompressionType compressionType, TSEncoding encoding, int numOfPages) {\n+    this(numOfPages <= 1 ? MetaMarker.ONLY_ONE_PAGE_CHUNK_HEADER : MetaMarker.CHUNK_HEADER,\n+        measurementID, dataSize, getSerializedSize(measurementID, dataSize), dataType,\n+        compressionType,\n+        encoding);\n+    this.numOfPages = numOfPages;\n   }\n \n-  private ChunkHeader(String measurementID, int dataSize, int headerSize, TSDataType dataType,\n-      CompressionType compressionType, TSEncoding encoding, int numOfPages) {\n+  public ChunkHeader(byte chunkType, String measurementID, int dataSize, TSDataType dataType,\n+      CompressionType compressionType, TSEncoding encoding) {\n+    this(chunkType, measurementID, dataSize, getSerializedSize(measurementID, dataSize), dataType,\n+        compressionType, encoding);\n+  }\n+\n+  public ChunkHeader(byte chunkType, String measurementID, int dataSize, int headerSize,\n+      TSDataType dataType, CompressionType compressionType, TSEncoding encoding) {\n+    this.chunkType = chunkType;\n     this.measurementID = measurementID;\n     this.dataSize = dataSize;\n     this.dataType = dataType;\n     this.compressionType = compressionType;\n-    this.numOfPages = numOfPages;\n     this.encodingType = encoding;\n     this.serializedSize = headerSize;\n   }\n \n+  /**\n+   * the exact serialized size of chunk header\n+   */\n+  public static int getSerializedSize(String measurementID, int dataSize) {\n+    int measurementIdLength = measurementID.getBytes(TSFileConfig.STRING_CHARSET).length;\n+    return Byte.BYTES // chunkType\n+        + ReadWriteForEncodingUtils.varIntSize(measurementIdLength) // measurementID length\n+        + measurementIdLength // measurementID\n+        + ReadWriteForEncodingUtils.uVarIntSize(dataSize) // dataSize\n+        + TSDataType.getSerializedSize() // dataType\n+        + CompressionType.getSerializedSize() // compressionType\n+        + TSEncoding.getSerializedSize(); // encodingType\n+  }\n+\n+  /**\n+   * The estimated serialized size of chunk header. Only used when we don't know the actual dataSize\n+   * attribute\n+   */\n   public static int getSerializedSize(String measurementID) {\n-    return Byte.BYTES // marker\n-        + Integer.BYTES // measurementID length\n-        + measurementID.getBytes(TSFileConfig.STRING_CHARSET).length // measurementID\n-        + Integer.BYTES // dataSize\n+\n+    int measurementIdLength = measurementID.getBytes(TSFileConfig.STRING_CHARSET).length;\n+    return  Byte.BYTES // chunkType\n+        + ReadWriteForEncodingUtils.varIntSize(measurementIdLength) // measurementID length\n+        + measurementIdLength // measurementID\n+        + Integer.BYTES + 1 // uVarInt dataSize\n         + TSDataType.getSerializedSize() // dataType\n         + CompressionType.getSerializedSize() // compressionType\n-        + TSEncoding.getSerializedSize() // encodingType\n-        + Integer.BYTES; // numOfPages\n+        + TSEncoding.getSerializedSize(); // encodingType\n   }\n \n   /**\n    * deserialize from inputStream.\n-   *\n-   * @param markerRead Whether the marker of the CHUNK_HEADER has been read\n    */\n-  public static ChunkHeader deserializeFrom(InputStream inputStream, boolean markerRead)\n+  public static ChunkHeader deserializeFrom(InputStream inputStream, byte chunkType)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkzMTUyOA==", "bodyText": "Yes, but we can get that from the method signature, because this method pass the marker as a parameter. And, i will add some comments for these two methods", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559931528", "createdAt": "2021-01-19T06:01:33Z", "author": {"login": "JackieTien97"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/header/ChunkHeader.java", "diffHunk": "@@ -33,101 +34,119 @@\n \n public class ChunkHeader {\n \n+\n+  /**\n+   * 1 means this chunk has more than one page, so each page has its own page statistic 4 means this\n+   * chunk has only one page, and this page has no page statistic\n+   */\n+  private byte chunkType;\n   private String measurementID;\n   private int dataSize;\n   private TSDataType dataType;\n   private CompressionType compressionType;\n   private TSEncoding encodingType;\n-  private int numOfPages;\n \n-  // this field does not need to be serialized.\n+  // the following fields do not need to be serialized.\n+  private int numOfPages;\n   private int serializedSize;\n \n   public ChunkHeader(String measurementID, int dataSize, TSDataType dataType,\n-      CompressionType compressionType,\n-      TSEncoding encoding, int numOfPages) {\n-    this(measurementID, dataSize, getSerializedSize(measurementID), dataType, compressionType,\n-        encoding, numOfPages);\n+      CompressionType compressionType, TSEncoding encoding, int numOfPages) {\n+    this(numOfPages <= 1 ? MetaMarker.ONLY_ONE_PAGE_CHUNK_HEADER : MetaMarker.CHUNK_HEADER,\n+        measurementID, dataSize, getSerializedSize(measurementID, dataSize), dataType,\n+        compressionType,\n+        encoding);\n+    this.numOfPages = numOfPages;\n   }\n \n-  private ChunkHeader(String measurementID, int dataSize, int headerSize, TSDataType dataType,\n-      CompressionType compressionType, TSEncoding encoding, int numOfPages) {\n+  public ChunkHeader(byte chunkType, String measurementID, int dataSize, TSDataType dataType,\n+      CompressionType compressionType, TSEncoding encoding) {\n+    this(chunkType, measurementID, dataSize, getSerializedSize(measurementID, dataSize), dataType,\n+        compressionType, encoding);\n+  }\n+\n+  public ChunkHeader(byte chunkType, String measurementID, int dataSize, int headerSize,\n+      TSDataType dataType, CompressionType compressionType, TSEncoding encoding) {\n+    this.chunkType = chunkType;\n     this.measurementID = measurementID;\n     this.dataSize = dataSize;\n     this.dataType = dataType;\n     this.compressionType = compressionType;\n-    this.numOfPages = numOfPages;\n     this.encodingType = encoding;\n     this.serializedSize = headerSize;\n   }\n \n+  /**\n+   * the exact serialized size of chunk header\n+   */\n+  public static int getSerializedSize(String measurementID, int dataSize) {\n+    int measurementIdLength = measurementID.getBytes(TSFileConfig.STRING_CHARSET).length;\n+    return Byte.BYTES // chunkType\n+        + ReadWriteForEncodingUtils.varIntSize(measurementIdLength) // measurementID length\n+        + measurementIdLength // measurementID\n+        + ReadWriteForEncodingUtils.uVarIntSize(dataSize) // dataSize\n+        + TSDataType.getSerializedSize() // dataType\n+        + CompressionType.getSerializedSize() // compressionType\n+        + TSEncoding.getSerializedSize(); // encodingType\n+  }\n+\n+  /**\n+   * The estimated serialized size of chunk header. Only used when we don't know the actual dataSize\n+   * attribute\n+   */\n   public static int getSerializedSize(String measurementID) {\n-    return Byte.BYTES // marker\n-        + Integer.BYTES // measurementID length\n-        + measurementID.getBytes(TSFileConfig.STRING_CHARSET).length // measurementID\n-        + Integer.BYTES // dataSize\n+\n+    int measurementIdLength = measurementID.getBytes(TSFileConfig.STRING_CHARSET).length;\n+    return  Byte.BYTES // chunkType\n+        + ReadWriteForEncodingUtils.varIntSize(measurementIdLength) // measurementID length\n+        + measurementIdLength // measurementID\n+        + Integer.BYTES + 1 // uVarInt dataSize\n         + TSDataType.getSerializedSize() // dataType\n         + CompressionType.getSerializedSize() // compressionType\n-        + TSEncoding.getSerializedSize() // encodingType\n-        + Integer.BYTES; // numOfPages\n+        + TSEncoding.getSerializedSize(); // encodingType\n   }\n \n   /**\n    * deserialize from inputStream.\n-   *\n-   * @param markerRead Whether the marker of the CHUNK_HEADER has been read\n    */\n-  public static ChunkHeader deserializeFrom(InputStream inputStream, boolean markerRead)\n+  public static ChunkHeader deserializeFrom(InputStream inputStream, byte chunkType)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUzNzUzMA=="}, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMzM4ODAwOnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/header/PageHeader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMzo0OTowNVrOIVp-mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMzo0OTowNVrOIVp-mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTU3ODc3OQ==", "bodyText": "comment why +1?", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559578779", "createdAt": "2021-01-18T13:49:05Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/header/PageHeader.java", "diffHunk": "@@ -41,25 +40,37 @@ public PageHeader(int uncompressedSize, int compressedSize, Statistics statistic\n     this.statistics = statistics;\n   }\n \n-  public static int calculatePageHeaderSizeWithoutStatistics() {\n-    return 2 * Integer.BYTES; // uncompressedSize, compressedSize\n+  /**\n+   * max page header size without statistics\n+   */\n+  public static int estimateMaxPageHeaderSizeWithoutStatistics() {\n+    return 2 * (Integer.BYTES + 1); // uncompressedSize, compressedSize", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMzcyMjE4OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/TimeseriesMetadata.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNTowODoxNVrOIVtIWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNTowODoxNVrOIVtIWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTYzMDQyNg==", "bodyText": "using two static Byte is better..", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559630426", "createdAt": "2021-01-18T15:08:15Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/TimeseriesMetadata.java", "diffHunk": "@@ -27,10 +27,17 @@\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n import org.apache.iotdb.tsfile.read.controller.IChunkMetadataLoader;\n+import org.apache.iotdb.tsfile.utils.ReadWriteForEncodingUtils;\n import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n \n public class TimeseriesMetadata implements Accountable {\n \n+  /**\n+   * 0 means this time series has only one chunk, no need to save the statistic again in chunk metadata", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMzc0NzU0OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/enums/MetadataIndexNodeType.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNToxNDoyOFrOIVtXzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNToxNDoyOFrOIVtXzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTYzNDM4MQ==", "bodyText": "not good using for-loop", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559634381", "createdAt": "2021-01-18T15:14:28Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/enums/MetadataIndexNodeType.java", "diffHunk": "@@ -42,19 +66,13 @@\n    * @return MetadataIndexNodeType\n    */\n   public static MetadataIndexNodeType deserialize(byte i) {\n-    if (i >= 4) {\n-      throw new IllegalArgumentException(\"Invalid input: \" + i);\n-    }\n-    switch (i) {\n-      case 0:\n-        return INTERNAL_DEVICE;\n-      case 1:\n-        return LEAF_DEVICE;\n-      case 2:\n-        return INTERNAL_MEASUREMENT;\n-      default:\n-        return LEAF_MEASUREMENT;\n+    for (MetadataIndexNodeType metadataIndexNodeType : MetadataIndexNodeType.values()) {\n+      if (i == metadataIndexNodeType.type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMzc1MjQ4OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/MetadataIndexConstructor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNToxNTo0MlrOIVta4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNjoxOToxNVrOIV_2JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTYzNTE2OQ==", "bodyText": "please double check whether the modification is correct.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559635169", "createdAt": "2021-01-18T15:15:42Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/MetadataIndexConstructor.java", "diffHunk": "@@ -81,7 +80,7 @@ public static MetadataIndexNode constructMetadataIndex(Map<String, List<Timeseri\n     // if not exceed the max child nodes num, ignore the device index and directly point to the measurement\n     if (deviceMetadataIndexMap.size() <= config.getMaxDegreeOfIndexNode()) {\n       MetadataIndexNode metadataIndexNode = new MetadataIndexNode(\n-          MetadataIndexNodeType.INTERNAL_MEASUREMENT);\n+          MetadataIndexNodeType.LEAF_DEVICE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkzNzA2MQ==", "bodyText": "Correct. This modification is mentioned in our design document : )", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559937061", "createdAt": "2021-01-19T06:19:15Z", "author": {"login": "samperson1997"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/MetadataIndexConstructor.java", "diffHunk": "@@ -81,7 +80,7 @@ public static MetadataIndexNode constructMetadataIndex(Map<String, List<Timeseri\n     // if not exceed the max child nodes num, ignore the device index and directly point to the measurement\n     if (deviceMetadataIndexMap.size() <= config.getMaxDegreeOfIndexNode()) {\n       MetadataIndexNode metadataIndexNode = new MetadataIndexNode(\n-          MetadataIndexNodeType.INTERNAL_MEASUREMENT);\n+          MetadataIndexNodeType.LEAF_DEVICE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTYzNTE2OQ=="}, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMzgyNTk1OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/enums/TSEncoding.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNTozMjoyM1rOIVuGsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNTozMjoyM1rOIVuGsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY0NjM4Ng==", "bodyText": "what's the difference of using swtch-case", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559646386", "createdAt": "2021-01-18T15:32:23Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/metadata/enums/TSEncoding.java", "diffHunk": "@@ -32,85 +46,27 @@ public static TSEncoding deserialize(short encoding) {\n     return getTsEncoding(encoding);\r\n   }\r\n \r\n-  public static byte deserializeToByte(short encoding) {\r\n-    if (encoding < 0 || 8 < encoding) {\r\n-      throw new IllegalArgumentException(\"Invalid input: \" + encoding);\r\n-    }\r\n-    return (byte) encoding;\r\n-  }\r\n \r\n   private static TSEncoding getTsEncoding(short encoding) {\r\n-    if (encoding < 0 || 8 < encoding) {\r\n-      throw new IllegalArgumentException(\"Invalid input: \" + encoding);\r\n-    }\r\n-    switch (encoding) {\r\n-      case 1:\r\n-        return PLAIN_DICTIONARY;\r\n-      case 2:\r\n-        return RLE;\r\n-      case 3:\r\n-        return DIFF;\r\n-      case 4:\r\n-        return TS_2DIFF;\r\n-      case 5:\r\n-        return BITMAP;\r\n-      case 6:\r\n-        return GORILLA_V1;\r\n-      case 7:\r\n-        return REGULAR;\r\n-      case 8:\r\n-        return GORILLA;\r\n-      default:\r\n-        return PLAIN;\r\n+    for (TSEncoding tsEncoding : TSEncoding.values()) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMzkxOTY2OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/encoding/encoder/PlainEncoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNTo1MzoyMlrOIVu97g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNjoyNzo0NlrOIWABMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY2MDUyNg==", "bodyText": "e...  it is not equal with previous version:\npublic void encode(short value, ByteArrayOutputStream out) uses varint while this function does not.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559660526", "createdAt": "2021-01-18T15:53:22Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/encoding/encoder/PlainEncoder.java", "diffHunk": "@@ -66,46 +54,29 @@ public void encode(boolean value, ByteArrayOutputStream out) {\n \n   @Override\n   public void encode(short value, ByteArrayOutputStream out) {\n-    if (this.endianType == EndianType.LITTLE_ENDIAN) {\n-      out.write(value & 0xFF);\n-      out.write((value >> 8) & 0xFF);\n-    } else if (this.endianType == EndianType.BIG_ENDIAN) {\n-      out.write((value >> 8) & 0xFF);\n-      out.write(value & 0xFF);\n-    }\n+    out.write((value >> 8) & 0xFF);\n+    out.write(value & 0xFF);\n   }\n \n   @Override\n   public void encode(int value, ByteArrayOutputStream out) {\n-    if (this.endianType == EndianType.LITTLE_ENDIAN) {\n-      out.write(value & 0xFF);\n-      out.write((value >> 8) & 0xFF);\n-      out.write((value >> 16) & 0xFF);\n-      out.write((value >> 24) & 0xFF);\n-    } else if (this.endianType == EndianType.BIG_ENDIAN) {\n-      out.write((value >> 24) & 0xFF);\n-      out.write((value >> 16) & 0xFF);\n-      out.write((value >> 8) & 0xFF);\n-      out.write(value & 0xFF);\n-    }\n+    ReadWriteForEncodingUtils.writeVarInt(value, out);\n   }\n \n   @Override\n   public void encode(long value, ByteArrayOutputStream out) {\n-    if (this.endianType == EndianType.LITTLE_ENDIAN) {\n-      for (int i = 0; i < 8; i++) {\n-        out.write((byte) (((value) >> (i * 8)) & 0xFF));\n-      }\n-    } else if (this.endianType == EndianType.BIG_ENDIAN) {\n-      for (int i = 7; i >= 0; i--) {\n-        out.write((byte) (((value) >> (i * 8)) & 0xFF));\n-      }\n+    for (int i = 7; i >= 0; i--) {\n+      out.write((byte) (((value) >> (i * 8)) & 0xFF));\n     }\n   }\n \n   @Override\n   public void encode(float value, ByteArrayOutputStream out) {\n-    encode(Float.floatToIntBits(value), out);\n+    int floatInt = Float.floatToIntBits(value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkzOTg5MQ==", "bodyText": "Previous version use encode(int value , ByteArrayOutputStream out) which in the previous version is not encode it as varInt. However, in the current version encode(int value , ByteArrayOutputStream out) encode the integer as a varInt, so the encode(float value, ByteArrayOutputStream out) can no longer call that method, because we don't want our float value become a varInt.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559939891", "createdAt": "2021-01-19T06:27:46Z", "author": {"login": "JackieTien97"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/encoding/encoder/PlainEncoder.java", "diffHunk": "@@ -66,46 +54,29 @@ public void encode(boolean value, ByteArrayOutputStream out) {\n \n   @Override\n   public void encode(short value, ByteArrayOutputStream out) {\n-    if (this.endianType == EndianType.LITTLE_ENDIAN) {\n-      out.write(value & 0xFF);\n-      out.write((value >> 8) & 0xFF);\n-    } else if (this.endianType == EndianType.BIG_ENDIAN) {\n-      out.write((value >> 8) & 0xFF);\n-      out.write(value & 0xFF);\n-    }\n+    out.write((value >> 8) & 0xFF);\n+    out.write(value & 0xFF);\n   }\n \n   @Override\n   public void encode(int value, ByteArrayOutputStream out) {\n-    if (this.endianType == EndianType.LITTLE_ENDIAN) {\n-      out.write(value & 0xFF);\n-      out.write((value >> 8) & 0xFF);\n-      out.write((value >> 16) & 0xFF);\n-      out.write((value >> 24) & 0xFF);\n-    } else if (this.endianType == EndianType.BIG_ENDIAN) {\n-      out.write((value >> 24) & 0xFF);\n-      out.write((value >> 16) & 0xFF);\n-      out.write((value >> 8) & 0xFF);\n-      out.write(value & 0xFF);\n-    }\n+    ReadWriteForEncodingUtils.writeVarInt(value, out);\n   }\n \n   @Override\n   public void encode(long value, ByteArrayOutputStream out) {\n-    if (this.endianType == EndianType.LITTLE_ENDIAN) {\n-      for (int i = 0; i < 8; i++) {\n-        out.write((byte) (((value) >> (i * 8)) & 0xFF));\n-      }\n-    } else if (this.endianType == EndianType.BIG_ENDIAN) {\n-      for (int i = 7; i >= 0; i--) {\n-        out.write((byte) (((value) >> (i * 8)) & 0xFF));\n-      }\n+    for (int i = 7; i >= 0; i--) {\n+      out.write((byte) (((value) >> (i * 8)) & 0xFF));\n     }\n   }\n \n   @Override\n   public void encode(float value, ByteArrayOutputStream out) {\n-    encode(Float.floatToIntBits(value), out);\n+    int floatInt = Float.floatToIntBits(value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY2MDUyNg=="}, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMzkyMjg2OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/encoding/encoder/PlainEncoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNTo1NDowNVrOIVu_sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwMjo1MDozNFrOIV8gIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY2MDk3Nw==", "bodyText": "contact @jt2594838  whether LITTLE_ENDIAN is not used anymore.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559660977", "createdAt": "2021-01-18T15:54:05Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/encoding/encoder/PlainEncoder.java", "diffHunk": "@@ -66,46 +54,29 @@ public void encode(boolean value, ByteArrayOutputStream out) {\n \n   @Override\n   public void encode(short value, ByteArrayOutputStream out) {\n-    if (this.endianType == EndianType.LITTLE_ENDIAN) {\n-      out.write(value & 0xFF);\n-      out.write((value >> 8) & 0xFF);\n-    } else if (this.endianType == EndianType.BIG_ENDIAN) {\n-      out.write((value >> 8) & 0xFF);\n-      out.write(value & 0xFF);\n-    }\n+    out.write((value >> 8) & 0xFF);\n+    out.write(value & 0xFF);\n   }\n \n   @Override\n   public void encode(int value, ByteArrayOutputStream out) {\n-    if (this.endianType == EndianType.LITTLE_ENDIAN) {\n-      out.write(value & 0xFF);\n-      out.write((value >> 8) & 0xFF);\n-      out.write((value >> 16) & 0xFF);\n-      out.write((value >> 24) & 0xFF);\n-    } else if (this.endianType == EndianType.BIG_ENDIAN) {\n-      out.write((value >> 24) & 0xFF);\n-      out.write((value >> 16) & 0xFF);\n-      out.write((value >> 8) & 0xFF);\n-      out.write(value & 0xFF);\n-    }\n+    ReadWriteForEncodingUtils.writeVarInt(value, out);\n   }\n \n   @Override\n   public void encode(long value, ByteArrayOutputStream out) {\n-    if (this.endianType == EndianType.LITTLE_ENDIAN) {\n-      for (int i = 0; i < 8; i++) {\n-        out.write((byte) (((value) >> (i * 8)) & 0xFF));\n-      }\n-    } else if (this.endianType == EndianType.BIG_ENDIAN) {\n-      for (int i = 7; i >= 0; i--) {\n-        out.write((byte) (((value) >> (i * 8)) & 0xFF));\n-      }\n+    for (int i = 7; i >= 0; i--) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4MjI3Mg==", "bodyText": "There has been only one endian for a long time.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559882272", "createdAt": "2021-01-19T02:50:34Z", "author": {"login": "jt2594838"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/encoding/encoder/PlainEncoder.java", "diffHunk": "@@ -66,46 +54,29 @@ public void encode(boolean value, ByteArrayOutputStream out) {\n \n   @Override\n   public void encode(short value, ByteArrayOutputStream out) {\n-    if (this.endianType == EndianType.LITTLE_ENDIAN) {\n-      out.write(value & 0xFF);\n-      out.write((value >> 8) & 0xFF);\n-    } else if (this.endianType == EndianType.BIG_ENDIAN) {\n-      out.write((value >> 8) & 0xFF);\n-      out.write(value & 0xFF);\n-    }\n+    out.write((value >> 8) & 0xFF);\n+    out.write(value & 0xFF);\n   }\n \n   @Override\n   public void encode(int value, ByteArrayOutputStream out) {\n-    if (this.endianType == EndianType.LITTLE_ENDIAN) {\n-      out.write(value & 0xFF);\n-      out.write((value >> 8) & 0xFF);\n-      out.write((value >> 16) & 0xFF);\n-      out.write((value >> 24) & 0xFF);\n-    } else if (this.endianType == EndianType.BIG_ENDIAN) {\n-      out.write((value >> 24) & 0xFF);\n-      out.write((value >> 16) & 0xFF);\n-      out.write((value >> 8) & 0xFF);\n-      out.write(value & 0xFF);\n-    }\n+    ReadWriteForEncodingUtils.writeVarInt(value, out);\n   }\n \n   @Override\n   public void encode(long value, ByteArrayOutputStream out) {\n-    if (this.endianType == EndianType.LITTLE_ENDIAN) {\n-      for (int i = 0; i < 8; i++) {\n-        out.write((byte) (((value) >> (i * 8)) & 0xFF));\n-      }\n-    } else if (this.endianType == EndianType.BIG_ENDIAN) {\n-      for (int i = 7; i >= 0; i--) {\n-        out.write((byte) (((value) >> (i * 8)) & 0xFF));\n-      }\n+    for (int i = 7; i >= 0; i--) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY2MDk3Nw=="}, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMzk1ODY5OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/utils/ReadWriteForEncodingUtils.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNjowMjozMVrOIVvVOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNjo0Njo0NVrOIWAahg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY2NjQ4OA==", "bodyText": "modify javadoc:\n@return -1 or int(>=0)", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559666488", "createdAt": "2021-01-18T16:02:31Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/utils/ReadWriteForEncodingUtils.java", "diffHunk": "@@ -98,14 +98,24 @@ public static int getLongMaxBitWidth(List<Long> list) {\n   public static int readUnsignedVarInt(InputStream in) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY2NzIzNA==", "bodyText": "by the way, how about  public static int readUnsignedVarInt(ByteBuffer buffer) (line 125)", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559667234", "createdAt": "2021-01-18T16:03:51Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/utils/ReadWriteForEncodingUtils.java", "diffHunk": "@@ -98,14 +98,24 @@ public static int getLongMaxBitWidth(List<Long> list) {\n   public static int readUnsignedVarInt(InputStream in) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY2NjQ4OA=="}, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk0NjM3NA==", "bodyText": "Even if the actual value is negative, readUnsignedVarInt() will not return -1, it will return a unknown positive num.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559946374", "createdAt": "2021-01-19T06:46:45Z", "author": {"login": "JackieTien97"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/utils/ReadWriteForEncodingUtils.java", "diffHunk": "@@ -98,14 +98,24 @@ public static int getLongMaxBitWidth(List<Long> list) {\n   public static int readUnsignedVarInt(InputStream in) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY2NjQ4OA=="}, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMzk2NDMyOnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/utils/ReadWriteForEncodingUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNjowNDowN1rOIVvYuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNjo0NzoxMVrOIWAbIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY2NzM4NQ==", "bodyText": "correct? how about -1?", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559667385", "createdAt": "2021-01-18T16:04:07Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/utils/ReadWriteForEncodingUtils.java", "diffHunk": "@@ -98,14 +98,24 @@ public static int getLongMaxBitWidth(List<Long> list) {\n   public static int readUnsignedVarInt(InputStream in) throws IOException {\n     int value = 0;\n     int i = 0;\n-    int b;\n-    while (((b = in.read()) & 0x80) != 0) {\n+    int b = in.read();\n+    while (b != -1 && (b & 0x80) != 0) {\n       value |= (b & 0x7F) << i;\n       i += 7;\n+      b = in.read();\n     }\n     return value | (b << i);\n   }\n \n+  public static int readVarInt(InputStream in) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk0NjUzMA==", "bodyText": "Yes, it is right, i will add some ut for this class", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559946530", "createdAt": "2021-01-19T06:47:11Z", "author": {"login": "JackieTien97"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/utils/ReadWriteForEncodingUtils.java", "diffHunk": "@@ -98,14 +98,24 @@ public static int getLongMaxBitWidth(List<Long> list) {\n   public static int readUnsignedVarInt(InputStream in) throws IOException {\n     int value = 0;\n     int i = 0;\n-    int b;\n-    while (((b = in.read()) & 0x80) != 0) {\n+    int b = in.read();\n+    while (b != -1 && (b & 0x80) != 0) {\n       value |= (b & 0x7F) << i;\n       i += 7;\n+      b = in.read();\n     }\n     return value | (b << i);\n   }\n \n+  public static int readVarInt(InputStream in) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY2NzM4NQ=="}, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMzk2ODM1OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/utils/ReadWriteForEncodingUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNjowNToxMFrOIVvbHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNjowNToxMFrOIVvbHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY2Nzk5Nw==", "bodyText": "add javadoc for @return", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559667997", "createdAt": "2021-01-18T16:05:10Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/utils/ReadWriteForEncodingUtils.java", "diffHunk": "@@ -134,12 +153,42 @@ public static int readUnsignedVarInt(ByteBuffer buffer) {\n    * @param value value to write into stream\n    * @param out   output stream\n    */\n-  public static void writeUnsignedVarInt(int value, ByteArrayOutputStream out) {\n+  public static int writeUnsignedVarInt(int value, ByteArrayOutputStream out) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNDAxNDI0OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/common/Chunk.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNjoxNjozOVrOIVv2Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNzoxMToxOFrOIWA8ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY3NDkzOQ==", "bodyText": "this method needs a lot of comments. Will review it after supplying comments.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559674939", "createdAt": "2021-01-18T16:16:39Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/common/Chunk.java", "diffHunk": "@@ -60,12 +67,51 @@ public void setDeleteIntervalList(List<TimeRange> list) {\n     this.deleteIntervalList = list;\n   }\n \n-  public void mergeChunk(Chunk chunk) {\n-    chunkHeader.mergeChunkHeader(chunk.chunkHeader);\n-    ByteBuffer newChunkData = ByteBuffer\n-        .allocate(chunkData.array().length + chunk.chunkData.array().length);\n-    newChunkData.put(chunkData.array());\n-    newChunkData.put(chunk.chunkData.array());\n+  public void mergeChunk(Chunk chunk) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk1NTEzOQ==", "bodyText": "already add, you can start reviewing", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559955139", "createdAt": "2021-01-19T07:11:18Z", "author": {"login": "JackieTien97"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/common/Chunk.java", "diffHunk": "@@ -60,12 +67,51 @@ public void setDeleteIntervalList(List<TimeRange> list) {\n     this.deleteIntervalList = list;\n   }\n \n-  public void mergeChunk(Chunk chunk) {\n-    chunkHeader.mergeChunkHeader(chunk.chunkHeader);\n-    ByteBuffer newChunkData = ByteBuffer\n-        .allocate(chunkData.array().length + chunk.chunkData.array().length);\n-    newChunkData.put(chunkData.array());\n-    newChunkData.put(chunk.chunkData.array());\n+  public void mergeChunk(Chunk chunk) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY3NDkzOQ=="}, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNDAyMzM1OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/common/Chunk.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNjoxODo1MlrOIVv7fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNjo1Njo0NFrOIWAnyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY3NjI4Nw==", "bodyText": "why add statistics here?", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559676287", "createdAt": "2021-01-18T16:18:52Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/common/Chunk.java", "diffHunk": "@@ -18,30 +18,37 @@\n  */\n package org.apache.iotdb.tsfile.read.common;\n \n+import java.io.IOException;\n import java.nio.ByteBuffer;\n-\n import java.util.List;\n import org.apache.iotdb.tsfile.common.cache.Accountable;\n+import org.apache.iotdb.tsfile.file.MetaMarker;\n import org.apache.iotdb.tsfile.file.header.ChunkHeader;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.utils.PublicBAOS;\n+import org.apache.iotdb.tsfile.utils.ReadWriteForEncodingUtils;\n \n /**\n  * used in query.\n  */\n public class Chunk implements Accountable {\n \n   private ChunkHeader chunkHeader;\n+  private Statistics chunkStatistic;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk0OTc2OQ==", "bodyText": "If the chunk has only one page, the page won't have page statistics, while constructing page of this chunk, we need to pass the chunk's statistics to the page as its page statistics.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559949769", "createdAt": "2021-01-19T06:56:44Z", "author": {"login": "JackieTien97"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/common/Chunk.java", "diffHunk": "@@ -18,30 +18,37 @@\n  */\n package org.apache.iotdb.tsfile.read.common;\n \n+import java.io.IOException;\n import java.nio.ByteBuffer;\n-\n import java.util.List;\n import org.apache.iotdb.tsfile.common.cache.Accountable;\n+import org.apache.iotdb.tsfile.file.MetaMarker;\n import org.apache.iotdb.tsfile.file.header.ChunkHeader;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.utils.PublicBAOS;\n+import org.apache.iotdb.tsfile.utils.ReadWriteForEncodingUtils;\n \n /**\n  * used in query.\n  */\n public class Chunk implements Accountable {\n \n   private ChunkHeader chunkHeader;\n+  private Statistics chunkStatistic;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY3NjI4Nw=="}, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNDA0NjE4OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/reader/LocalTsFileInput.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNjoyNDoyNlrOIVwJLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNzoyMjoxNFrOIWBN6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY3OTc4OA==", "bodyText": "this method... is not thread-safe... see how other functions use the channel.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559679788", "createdAt": "2021-01-18T16:24:26Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/reader/LocalTsFileInput.java", "diffHunk": "@@ -145,4 +146,13 @@ public void close() throws IOException {\n   public int readInt() {\n     throw new UnsupportedOperationException();\n   }\n+\n+  @Override\n+  public String readVarIntString(long offset) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk1OTUyOA==", "bodyText": "Ok, I've changed it to be thread-safe.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559959528", "createdAt": "2021-01-19T07:22:14Z", "author": {"login": "JackieTien97"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/reader/LocalTsFileInput.java", "diffHunk": "@@ -145,4 +146,13 @@ public void close() throws IOException {\n   public int readInt() {\n     throw new UnsupportedOperationException();\n   }\n+\n+  @Override\n+  public String readVarIntString(long offset) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY3OTc4OA=="}, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNDA2MDM4OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNjoyNzozNFrOIVwRTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNjoyNzozNFrOIVwRTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY4MTg2OA==", "bodyText": "comment for Byte.BYTES.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559681868", "createdAt": "2021-01-18T16:27:34Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java", "diffHunk": "@@ -208,10 +211,14 @@ public String readTailMagic() throws IOException {\n    * whether the file is a complete TsFile: only if the head magic and tail magic string exists.\n    */\n   public boolean isComplete() throws IOException {\n-    return tsFileInput.size() >= TSFileConfig.MAGIC_STRING.getBytes().length * 2\n-        + TSFileConfig.VERSION_NUMBER.getBytes().length\n-        && (readTailMagic().equals(readHeadMagic()) || readTailMagic()\n-        .equals(TSFileConfig.VERSION_NUMBER_V1));\n+    long size = tsFileInput.size();\n+    if (size >= TSFileConfig.MAGIC_STRING.getBytes().length * 2 + Byte.BYTES) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNDA4OTg4OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNjozNToxM1rOIVwjSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNzozNDo0NFrOIWBifA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY4NjQ3Mg==", "bodyText": "run index++ and curSize+= after seeriesMetadata.computeIfAbsent?", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559686472", "createdAt": "2021-01-18T16:35:13Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java", "diffHunk": "@@ -583,8 +593,15 @@ private int binarySearchInTimeseriesMetadataList(List<TimeseriesMetadata> timese\n     // read buffer of all ChunkMetadatas of this device\n     ByteBuffer buffer = readData(start, size);\n     Map<String, List<ChunkMetadata>> seriesMetadata = new HashMap<>();\n+    int index = 0;\n+    int curSize = timeseriesMetadataMap.get(index).getDataSizeOfChunkMetaDataList();\n     while (buffer.hasRemaining()) {\n-      ChunkMetadata chunkMetadata = ChunkMetadata.deserializeFrom(buffer);\n+      if (buffer.position() >= curSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk2NDc5Ng==", "bodyText": "Both ok, i think.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559964796", "createdAt": "2021-01-19T07:34:44Z", "author": {"login": "JackieTien97"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java", "diffHunk": "@@ -583,8 +593,15 @@ private int binarySearchInTimeseriesMetadataList(List<TimeseriesMetadata> timese\n     // read buffer of all ChunkMetadatas of this device\n     ByteBuffer buffer = readData(start, size);\n     Map<String, List<ChunkMetadata>> seriesMetadata = new HashMap<>();\n+    int index = 0;\n+    int curSize = timeseriesMetadataMap.get(index).getDataSizeOfChunkMetaDataList();\n     while (buffer.hasRemaining()) {\n-      ChunkMetadata chunkMetadata = ChunkMetadata.deserializeFrom(buffer);\n+      if (buffer.position() >= curSize) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY4NjQ3Mg=="}, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNDE0ODg3OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/MetaMarker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNjo1MTozNFrOIVxG2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNjo1MTozNFrOIVxG2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY5NTU3Nw==", "bodyText": "add @deprecated annotation here?", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559695577", "createdAt": "2021-01-18T16:51:34Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/file/MetaMarker.java", "diffHunk": "@@ -26,15 +26,24 @@\n  */\n public class MetaMarker {\n \n-  public static final byte CHUNK_GROUP_FOOTER = 0;\n+  public static final byte CHUNK_GROUP_HEADER = 0;\n+  /**\n+   * means this chunk has more than one page\n+   */\n   public static final byte CHUNK_HEADER = 1;\n   public static final byte SEPARATOR = 2;\n   public static final byte VERSION = 3;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35f7ea50b9576f32f111da53977a3653b077bdbf"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTMxNDk5OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwMTo0NzozM1rOIV7fLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwMTo0NzozM1rOIV7fLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg2NTY0NA==", "bodyText": "If the result is read-only, Collections.emptyMap should be enough.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559865644", "createdAt": "2021-01-19T01:47:33Z", "author": {"login": "jt2594838"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java", "diffHunk": "@@ -567,13 +576,14 @@ private int binarySearchInTimeseriesMetadataList(List<TimeseriesMetadata> timese\n    */\n   public Map<String, List<ChunkMetadata>> readChunkMetadataInDevice(String device)\n       throws IOException {\n-    if (tsFileMetaData == null) {\n-      readFileMetadata();\n-    }\n+    readFileMetadata();\n \n     long start = 0;\n     int size = 0;\n     List<TimeseriesMetadata> timeseriesMetadataMap = getDeviceTimeseriesMetadata(device);\n+    if (timeseriesMetadataMap.isEmpty()) {\n+      return new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc2ad1648cb109abe594841003e607066e113ca1"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTM5MTU1OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/utils/ReadWriteIOUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwMjoyODozNlrOIV8JeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwMjoyODozNlrOIV8JeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg3NjQ3Mw==", "bodyText": "Use TsFileConfig.STRING_CHARSET.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559876473", "createdAt": "2021-01-19T02:28:36Z", "author": {"login": "jt2594838"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/utils/ReadWriteIOUtils.java", "diffHunk": "@@ -352,6 +352,25 @@ public static int write(String s, OutputStream outputStream) throws IOException\n     return len;\n   }\n \n+  /**\n+   * write string to outputStream.\n+   *\n+   * @return the length of string represented by byte[].\n+   */\n+  public static int writeVar(String s, OutputStream outputStream) throws IOException {\n+    int len = 0;\n+    if (s == null) {\n+      len += ReadWriteForEncodingUtils.writeVarInt(-1, outputStream);\n+      return len;\n+    }\n+\n+    byte[] bytes = s.getBytes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc2ad1648cb109abe594841003e607066e113ca1"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTUyMDA1OnYy", "diffSide": "RIGHT", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/write/chunk/ChunkWriterImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwMzo0Mjo1OVrOIV9TSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwODowMDo0MVrOIWCSMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg5NTM3MA==", "bodyText": "if numberOfPages == 0, then write page0;\nelse if numberOfPages ==1, then rewrite page0 and write page1,\nelse write page_i.\nso we can reduce copy page1 data", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559895370", "createdAt": "2021-01-19T03:42:59Z", "author": {"login": "jixuan1989"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/write/chunk/ChunkWriterImpl.java", "diffHunk": "@@ -300,7 +308,19 @@ private void checkPageSizeAndMayOpenANewPage() {\n \n   private void writePageToPageBuffer() {\n     try {\n-      pageWriter.writePageHeaderAndDataIntoBuff(pageBuffer);\n+      int size = pageWriter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc2ad1648cb109abe594841003e607066e113ca1"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk3NzAxMQ==", "bodyText": "great idea!", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559977011", "createdAt": "2021-01-19T08:00:41Z", "author": {"login": "JackieTien97"}, "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/write/chunk/ChunkWriterImpl.java", "diffHunk": "@@ -300,7 +308,19 @@ private void checkPageSizeAndMayOpenANewPage() {\n \n   private void writePageToPageBuffer() {\n     try {\n-      pageWriter.writePageHeaderAndDataIntoBuff(pageBuffer);\n+      int size = pageWriter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg5NTM3MA=="}, "originalCommit": {"oid": "cc2ad1648cb109abe594841003e607066e113ca1"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTUyNjI4OnYy", "diffSide": "RIGHT", "path": "session/src/test/java/org/apache/iotdb/session/IoTDBSessionIteratorIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwMzo0NjozM1rOIV9Wqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwMzo0NjozM1rOIV9Wqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg5NjIzNA==", "bodyText": "check Python and Go....", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559896234", "createdAt": "2021-01-19T03:46:33Z", "author": {"login": "jixuan1989"}, "path": "session/src/test/java/org/apache/iotdb/session/IoTDBSessionIteratorIT.java", "diffHunk": "@@ -295,7 +295,7 @@ private void prepareData() throws IoTDBConnectionException, StatementExecutionEx\n     List<TSDataType> types = new ArrayList<>();\n     for (int i = 1; i <= 6; i++) {\n       measurements.add(\"s\" + i);\n-      types.add(TSDataType.deserialize((short) (i - 1)));\n+      types.add(TSDataType.deserialize((byte) (i - 1)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc2ad1648cb109abe594841003e607066e113ca1"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTUzMTc1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/utils/UpgradeUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwMzo0OTozNVrOIV9Z3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxNjowNTozNVrOIWVgNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg5NzA1NQ==", "bodyText": "where to check if the user uses Version 1 (i.e., version <0.10), then reject the upgrade.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559897055", "createdAt": "2021-01-19T03:49:35Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/UpgradeUtils.java", "diffHunk": "@@ -66,9 +73,9 @@ public static boolean isNeedUpgrade(TsFileResource tsFileResource) {\n     } finally {\n       tsFileResource.readUnlock();\n     }\n-    try (TsFileSequenceReader tsFileSequenceReader = new TsFileSequenceReader(\n+    try (TsFileSequenceReaderForV2 tsFileSequenceReader = new TsFileSequenceReaderForV2(\n         tsFileResource.getTsFile().getAbsolutePath())) {\n-      if (tsFileSequenceReader.readVersionNumber().equals(TSFileConfig.VERSION_NUMBER_V1)) {\n+      if (tsFileSequenceReader.readVersionNumberV2().equals(TSFileConfig.VERSION_NUMBER_V2)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc2ad1648cb109abe594841003e607066e113ca1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDI5MTg5NQ==", "bodyText": "This method is only called by load external TsFile module, which is no related with the upgrade.\nWhen user uses version 1, we will check System.properties file to know the version, show the error logs and close the IoTDB server.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r560291895", "createdAt": "2021-01-19T16:05:35Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/UpgradeUtils.java", "diffHunk": "@@ -66,9 +73,9 @@ public static boolean isNeedUpgrade(TsFileResource tsFileResource) {\n     } finally {\n       tsFileResource.readUnlock();\n     }\n-    try (TsFileSequenceReader tsFileSequenceReader = new TsFileSequenceReader(\n+    try (TsFileSequenceReaderForV2 tsFileSequenceReader = new TsFileSequenceReaderForV2(\n         tsFileResource.getTsFile().getAbsolutePath())) {\n-      if (tsFileSequenceReader.readVersionNumber().equals(TSFileConfig.VERSION_NUMBER_V1)) {\n+      if (tsFileSequenceReader.readVersionNumberV2().equals(TSFileConfig.VERSION_NUMBER_V2)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg5NzA1NQ=="}, "originalCommit": {"oid": "cc2ad1648cb109abe594841003e607066e113ca1"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTUzNDg0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/tools/TsFileSketchTool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwMzo1MToyMlrOIV9bhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNjoyMzo0NlrOIV_78w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg5NzQ3Nw==", "bodyText": "how about other TsFileTools", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559897477", "createdAt": "2021-01-19T03:51:22Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/tools/TsFileSketchTool.java", "diffHunk": "@@ -75,38 +75,33 @@ public static void main(String[] args) throws IOException {\n                 String.format(\"%20d\", TSFileConfig.MAGIC_STRING.getBytes().length)\n                         + \"|\\t[version number] \"\n                         + reader.readVersionNumber());\n+        long nextChunkGroupHeaderPos = (long) TSFileConfig.MAGIC_STRING.getBytes().length ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc2ad1648cb109abe594841003e607066e113ca1"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkzODU0Nw==", "bodyText": "I checked the TsFileSeqenceRead in TsFile example and it works well.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559938547", "createdAt": "2021-01-19T06:23:46Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/tools/TsFileSketchTool.java", "diffHunk": "@@ -75,38 +75,33 @@ public static void main(String[] args) throws IOException {\n                 String.format(\"%20d\", TSFileConfig.MAGIC_STRING.getBytes().length)\n                         + \"|\\t[version number] \"\n                         + reader.readVersionNumber());\n+        long nextChunkGroupHeaderPos = (long) TSFileConfig.MAGIC_STRING.getBytes().length ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg5NzQ3Nw=="}, "originalCommit": {"oid": "cc2ad1648cb109abe594841003e607066e113ca1"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTU3MjkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNDoxMjo0N1rOIV9w3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNjo0MzoyOVrOIWAWCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkwMjk0Mw==", "bodyText": "\"move\" ?", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559902943", "createdAt": "2021-01-19T04:12:47Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -515,6 +480,11 @@ else if (upgradeFolder.exists()) {\n             Collections.addAll(tsFiles,\n                 fsFactory.listFilesBySuffix(partitionFolder.getAbsolutePath(), TSFILE_SUFFIX));\n           }\n+          else {\n+            // move ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc2ad1648cb109abe594841003e607066e113ca1"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk0NTIyNA==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559945224", "createdAt": "2021-01-19T06:43:29Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -515,6 +480,11 @@ else if (upgradeFolder.exists()) {\n             Collections.addAll(tsFiles,\n                 fsFactory.listFilesBySuffix(partitionFolder.getAbsolutePath(), TSFILE_SUFFIX));\n           }\n+          else {\n+            // move ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkwMjk0Mw=="}, "originalCommit": {"oid": "cc2ad1648cb109abe594841003e607066e113ca1"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTU3OTc1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNDoxNzowMFrOIV90tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNDoxNzowMFrOIV90tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkwMzkyNQ==", "bodyText": "any side-effect that only moving finished files from upgrade list to the normal fileList  after all files are upgraded?", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559903925", "createdAt": "2021-01-19T04:17:00Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1717,23 +1692,19 @@ private void upgradeTsFileResourceCallBack(TsFileResource tsFileResource) {\n               resource.getEndTime(device))\n       );\n     }\n-    insertLock.writeLock().lock();\n-    tsFileManagement.writeLock();\n-    try {\n-      if (tsFileResource.isSeq()) {\n-        tsFileManagement.addAll(upgradedResources, true);\n-        upgradeSeqFileList.remove(tsFileResource);\n-      } else {\n-        tsFileManagement.addAll(upgradedResources, false);\n-        upgradeUnseqFileList.remove(tsFileResource);\n+    upgradeFileCount.getAndAdd(-1);\n+    // load all upgraded resources in this sg to tsFileManagement\n+    if (upgradeFileCount.get() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc2ad1648cb109abe594841003e607066e113ca1"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTU4MjQ0OnYy", "diffSide": "LEFT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNDoxODozMVrOIV92Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwNjoyMToxNlrOIV_45Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkwNDI5OA==", "bodyText": "So, when to stop the service?", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559904298", "createdAt": "2021-01-19T04:18:31Z", "author": {"login": "jixuan1989"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1748,10 +1719,38 @@ private void upgradeTsFileResourceCallBack(TsFileResource tsFileResource) {\n           }\n         }\n       }\n-      if (StorageEngine.getInstance().countUpgradeFiles() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc2ad1648cb109abe594841003e607066e113ca1"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkzNzc2NQ==", "bodyText": "At the end of the runMayThrow method of UpgradeTask.", "url": "https://github.com/apache/iotdb/pull/2184#discussion_r559937765", "createdAt": "2021-01-19T06:21:16Z", "author": {"login": "HTHou"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1748,10 +1719,38 @@ private void upgradeTsFileResourceCallBack(TsFileResource tsFileResource) {\n           }\n         }\n       }\n-      if (StorageEngine.getInstance().countUpgradeFiles() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkwNDI5OA=="}, "originalCommit": {"oid": "cc2ad1648cb109abe594841003e607066e113ca1"}, "originalPosition": 206}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 514, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}