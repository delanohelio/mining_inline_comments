{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3NTQ2ODMx", "number": 975, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMToxMzo0NlrODvg0kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjo1NDo0OVrODztk9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTQ3NDExOnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/UnCommittedEntryManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMToxMzo0NlrOGB-qeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDo1Mzo0OVrOGCHg2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcyODQ0MA==", "bodyText": "If the caller change the subList, our manager will be impacted. You can use a new arrayList to return or add some comment at the method", "url": "https://github.com/apache/iotdb/pull/975#discussion_r404728440", "createdAt": "2020-04-07T11:13:46Z", "author": {"login": "SilverNarcissus"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/UnCommittedEntryManager.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log;\n+\n+import org.apache.iotdb.cluster.exception.EntryUnavailableException;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class UnCommittedEntryManager {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnCommittedEntryManager.class);\n+    // all entries that have not been committed.\n+    private List<Log> entries;\n+    // the first uncommitted entry index.\n+    private long offset;\n+\n+    public UnCommittedEntryManager(long offset) {\n+        this.offset = offset;\n+        this.entries = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Return the first uncommitted index.\n+     *\n+     * @return offset\n+     */\n+    public long getFirstUnCommittedIndex() {\n+        return offset;\n+    }\n+\n+\n+    /**\n+     * Return last entry's index if this instance has at least one uncommitted entry.\n+     *\n+     * @return -1 if entries are empty, or last entry's index\n+     */\n+    public long maybeLastIndex() {\n+        int entryNum = entries.size();\n+        if (entryNum != 0) {\n+            return offset + entryNum - 1;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Return the entry's term for given index.\n+     * Note that the called should ensure index >= offset.\n+     *\n+     * @param index request entry index\n+     * @return -1 if index < offset, throw EntryUnavailableException if\n+     * index > last or entries is empty, or return the entry's term for given index\n+     * @throws EntryUnavailableException\n+     */\n+    public long maybeTerm(long index) throws EntryUnavailableException {\n+        if (index < offset) {\n+            logger.debug(\"invalid unCommittedEntryManager maybeTerm : parameter: index({}) < offset({})\", index, offset);\n+            return -1;\n+        }\n+        long last = maybeLastIndex();\n+        if (last == -1 || index > last) {\n+            long boundary = last == -1 ? offset - 1 : last;\n+            logger.info(\"unCommittedEntryManager maybeTerm out of bound : parameter: index({}) > lastIndex({})\", index, boundary);\n+            throw new EntryUnavailableException(index, boundary);\n+        }\n+        return entries.get((int) (index - offset)).getCurrLogTerm();\n+    }\n+\n+    /**\n+     * Remove useless prefix entries as long as these entries has been committed and persisted.\n+     * This method is only called after persisting newly committed entries.\n+     *\n+     * @param index request entry's index\n+     * @param term  request entry's term\n+     */\n+    public void stableTo(long index, long term) {\n+        try {\n+            long entryTerm = maybeTerm(index);\n+            // only update the uncommitted entries if term is matched with an uncommitted entry.\n+            if (entryTerm == term) {\n+                entries.subList(0, (int) (index + 1 - offset)).clear();\n+                offset = index + 1;\n+            }\n+        } catch (EntryUnavailableException e) {\n+            logger.info(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Update offset and clear entries because leader's snapshot is more up-to-date.\n+     * This method is only called for applying snapshot from leader.\n+     *\n+     * @param snapshot leader's snapshot\n+     */\n+    public void applyingSnapshot(Snapshot snapshot) {\n+        this.offset = snapshot.getLastLogIndex() + 1;\n+        this.entries.clear();\n+    }\n+\n+    /**\n+     * TruncateAndAppend uncommitted entries.\n+     * This method will truncate conflict entries if it finds inconsistencies.\n+     * Note that the caller should ensure appendingEntries[0].index <= entries[entries.size()-1].index + 1.\n+     * Note that the caller should ensure not to truncate entries which have been committed.\n+     *\n+     * @param appendingEntries request entries\n+     */\n+    public void truncateAndAppend(List<Log> appendingEntries) {\n+        long after = appendingEntries.get(0).getCurrLogIndex();\n+        long len = after - offset;\n+        if (len < 0) {\n+            // the logs are being truncated to before our current offset portion, which is committed entries\n+            // unconditional obedience to the leader's request. Maybe throw a exception here is better\n+            offset = after;\n+            entries = appendingEntries;\n+            logger.error(\"The logs which first index is {} are going to truncate committed logs\", after);\n+        } else if (len == entries.size()) {\n+            // after is the next index in the entries\n+            // directly append\n+            entries.addAll(appendingEntries);\n+        } else {\n+            // clear conflict entries\n+            // then append\n+            logger.info(\"truncate the entries after index {}\", after);\n+            int truncateIndex = (int) (after - offset);\n+            if (truncateIndex < entries.size()) {\n+                entries.subList(truncateIndex, entries.size()).clear();\n+            }\n+            entries.addAll(appendingEntries);\n+        }\n+    }\n+\n+    /**\n+     * Pack entries from low through high - 1, just like slice (entries[low:high]).\n+     * offset <= low <= high.\n+     * Note that caller must ensure low <= high.\n+     *\n+     * @param low  request index low bound\n+     * @param high request index upper bound\n+     */\n+    public List<Log> getEntries(long low, long high) {\n+        if (low > high) {\n+            logger.debug(\"invalid unCommittedEntryManager getEntries: parameter: low({}) > high({})\", low, high);\n+        }\n+        long upper = offset + entries.size();\n+        if (low > upper) {\n+            // don't throw a exception to support\n+            // getEntries(low, Integer.MAX_VALUE) if low is larger than lastIndex.\n+            logger.info(\"unCommittedEntryManager getEntries[{},{}) out of bound : [{},{}] , return empty ArrayList\", low, high, offset, upper);\n+            return new ArrayList<>();\n+        }\n+        if (low < offset) {\n+            logger.debug(\"unCommittedEntryManager getEntries[{},{}) out of bound : [{},{}]\", low, high, offset, upper);\n+            low = offset;\n+        }\n+        if (high > upper) {\n+            logger.info(\"unCommittedEntryManager getEntries[{},{}) out of bound : [{},{}] , adjust parameter 'high' to {}\", low, high, offset, upper, upper);\n+            // don't throw a exception to support getEntries(low, Integer.MAX_VALUE).\n+            high = upper;\n+        }\n+        return entries.subList((int) (low - offset), (int) (high - offset));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c21f8268b132fbfed7a826e9797585ed24def997"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg3MzQzMg==", "bodyText": "Actually,In RaftLogManager's getEntries implemetation,a new list is created to deeply copy these references.So it is safe to change the list outside RaftLogManager.\nThanks for reviewing!", "url": "https://github.com/apache/iotdb/pull/975#discussion_r404873432", "createdAt": "2020-04-07T14:53:49Z", "author": {"login": "LebronAl"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/UnCommittedEntryManager.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log;\n+\n+import org.apache.iotdb.cluster.exception.EntryUnavailableException;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class UnCommittedEntryManager {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnCommittedEntryManager.class);\n+    // all entries that have not been committed.\n+    private List<Log> entries;\n+    // the first uncommitted entry index.\n+    private long offset;\n+\n+    public UnCommittedEntryManager(long offset) {\n+        this.offset = offset;\n+        this.entries = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Return the first uncommitted index.\n+     *\n+     * @return offset\n+     */\n+    public long getFirstUnCommittedIndex() {\n+        return offset;\n+    }\n+\n+\n+    /**\n+     * Return last entry's index if this instance has at least one uncommitted entry.\n+     *\n+     * @return -1 if entries are empty, or last entry's index\n+     */\n+    public long maybeLastIndex() {\n+        int entryNum = entries.size();\n+        if (entryNum != 0) {\n+            return offset + entryNum - 1;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Return the entry's term for given index.\n+     * Note that the called should ensure index >= offset.\n+     *\n+     * @param index request entry index\n+     * @return -1 if index < offset, throw EntryUnavailableException if\n+     * index > last or entries is empty, or return the entry's term for given index\n+     * @throws EntryUnavailableException\n+     */\n+    public long maybeTerm(long index) throws EntryUnavailableException {\n+        if (index < offset) {\n+            logger.debug(\"invalid unCommittedEntryManager maybeTerm : parameter: index({}) < offset({})\", index, offset);\n+            return -1;\n+        }\n+        long last = maybeLastIndex();\n+        if (last == -1 || index > last) {\n+            long boundary = last == -1 ? offset - 1 : last;\n+            logger.info(\"unCommittedEntryManager maybeTerm out of bound : parameter: index({}) > lastIndex({})\", index, boundary);\n+            throw new EntryUnavailableException(index, boundary);\n+        }\n+        return entries.get((int) (index - offset)).getCurrLogTerm();\n+    }\n+\n+    /**\n+     * Remove useless prefix entries as long as these entries has been committed and persisted.\n+     * This method is only called after persisting newly committed entries.\n+     *\n+     * @param index request entry's index\n+     * @param term  request entry's term\n+     */\n+    public void stableTo(long index, long term) {\n+        try {\n+            long entryTerm = maybeTerm(index);\n+            // only update the uncommitted entries if term is matched with an uncommitted entry.\n+            if (entryTerm == term) {\n+                entries.subList(0, (int) (index + 1 - offset)).clear();\n+                offset = index + 1;\n+            }\n+        } catch (EntryUnavailableException e) {\n+            logger.info(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Update offset and clear entries because leader's snapshot is more up-to-date.\n+     * This method is only called for applying snapshot from leader.\n+     *\n+     * @param snapshot leader's snapshot\n+     */\n+    public void applyingSnapshot(Snapshot snapshot) {\n+        this.offset = snapshot.getLastLogIndex() + 1;\n+        this.entries.clear();\n+    }\n+\n+    /**\n+     * TruncateAndAppend uncommitted entries.\n+     * This method will truncate conflict entries if it finds inconsistencies.\n+     * Note that the caller should ensure appendingEntries[0].index <= entries[entries.size()-1].index + 1.\n+     * Note that the caller should ensure not to truncate entries which have been committed.\n+     *\n+     * @param appendingEntries request entries\n+     */\n+    public void truncateAndAppend(List<Log> appendingEntries) {\n+        long after = appendingEntries.get(0).getCurrLogIndex();\n+        long len = after - offset;\n+        if (len < 0) {\n+            // the logs are being truncated to before our current offset portion, which is committed entries\n+            // unconditional obedience to the leader's request. Maybe throw a exception here is better\n+            offset = after;\n+            entries = appendingEntries;\n+            logger.error(\"The logs which first index is {} are going to truncate committed logs\", after);\n+        } else if (len == entries.size()) {\n+            // after is the next index in the entries\n+            // directly append\n+            entries.addAll(appendingEntries);\n+        } else {\n+            // clear conflict entries\n+            // then append\n+            logger.info(\"truncate the entries after index {}\", after);\n+            int truncateIndex = (int) (after - offset);\n+            if (truncateIndex < entries.size()) {\n+                entries.subList(truncateIndex, entries.size()).clear();\n+            }\n+            entries.addAll(appendingEntries);\n+        }\n+    }\n+\n+    /**\n+     * Pack entries from low through high - 1, just like slice (entries[low:high]).\n+     * offset <= low <= high.\n+     * Note that caller must ensure low <= high.\n+     *\n+     * @param low  request index low bound\n+     * @param high request index upper bound\n+     */\n+    public List<Log> getEntries(long low, long high) {\n+        if (low > high) {\n+            logger.debug(\"invalid unCommittedEntryManager getEntries: parameter: low({}) > high({})\", low, high);\n+        }\n+        long upper = offset + entries.size();\n+        if (low > upper) {\n+            // don't throw a exception to support\n+            // getEntries(low, Integer.MAX_VALUE) if low is larger than lastIndex.\n+            logger.info(\"unCommittedEntryManager getEntries[{},{}) out of bound : [{},{}] , return empty ArrayList\", low, high, offset, upper);\n+            return new ArrayList<>();\n+        }\n+        if (low < offset) {\n+            logger.debug(\"unCommittedEntryManager getEntries[{},{}) out of bound : [{},{}]\", low, high, offset, upper);\n+            low = offset;\n+        }\n+        if (high > upper) {\n+            logger.info(\"unCommittedEntryManager getEntries[{},{}) out of bound : [{},{}] , adjust parameter 'high' to {}\", low, high, offset, upper, upper);\n+            // don't throw a exception to support getEntries(low, Integer.MAX_VALUE).\n+            high = upper;\n+        }\n+        return entries.subList((int) (low - offset), (int) (high - offset));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcyODQ0MA=="}, "originalCommit": {"oid": "c21f8268b132fbfed7a826e9797585ed24def997"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDM5OTEwOnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/UnCommittedEntryManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwODoyMzoyMFrOGII4EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToxOTo1M1rOGILKWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE4NzIxNg==", "bodyText": "I wonder if the checks are necessary, as you comment \"This method is only called after persisting newly committed entries\".", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411187216", "createdAt": "2020-04-20T08:23:20Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/UnCommittedEntryManager.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.manage;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.iotdb.cluster.exception.EntryUnavailableException;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class UnCommittedEntryManager {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnCommittedEntryManager.class);\n+    // all entries that have not been committed.\n+    private List<Log> entries;\n+    // the first uncommitted entry index.\n+    private long offset;\n+\n+    public UnCommittedEntryManager(long offset) {\n+        this.offset = offset;\n+        this.entries = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Return the first uncommitted index.\n+     *\n+     * @return offset\n+     */\n+    public long getFirstUnCommittedIndex() {\n+        return offset;\n+    }\n+\n+\n+    /**\n+     * Return last entry's index if this instance has at least one uncommitted entry.\n+     *\n+     * @return -1 if entries are empty, or last entry's index\n+     */\n+    public long maybeLastIndex() {\n+        int entryNum = entries.size();\n+        if (entryNum != 0) {\n+            return offset + entryNum - 1;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Return the entry's term for given index. Note that the called should ensure index >= offset.\n+     *\n+     * @param index request entry index\n+     * @return -1 if index < offset, throw EntryUnavailableException if index > last or entries is\n+     * empty, or return the entry's term for given index\n+     * @throws EntryUnavailableException\n+     */\n+    public long maybeTerm(long index) throws EntryUnavailableException {\n+        if (index < offset) {\n+            logger.debug(\n+                \"invalid unCommittedEntryManager maybeTerm : parameter: index({}) < offset({})\",\n+                index, offset);\n+            return -1;\n+        }\n+        long last = maybeLastIndex();\n+        if (last == -1 || index > last) {\n+            long boundary = last == -1 ? offset - 1 : last;\n+            logger.info(\n+                \"unCommittedEntryManager maybeTerm out of bound : parameter: index({}) > lastIndex({})\",\n+                index, boundary);\n+            throw new EntryUnavailableException(index, boundary);\n+        }\n+        return entries.get((int) (index - offset)).getCurrLogTerm();\n+    }\n+\n+    /**\n+     * Remove useless prefix entries as long as these entries has been committed and persisted. This\n+     * method is only called after persisting newly committed entries.\n+     *\n+     * @param index request entry's index\n+     * @param term  request entry's term\n+     */\n+    public void stableTo(long index, long term) {\n+        try {\n+            long entryTerm = maybeTerm(index);\n+            // only update the uncommitted entries if term is matched with an uncommitted entry.\n+            if (entryTerm == term) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e838ca4587541ccc284aac59f87ec2632774233c"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyNDY2NQ==", "bodyText": "This check is not required under the current design. I will delete it~", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411224665", "createdAt": "2020-04-20T09:19:53Z", "author": {"login": "LebronAl"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/UnCommittedEntryManager.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.manage;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.iotdb.cluster.exception.EntryUnavailableException;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class UnCommittedEntryManager {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnCommittedEntryManager.class);\n+    // all entries that have not been committed.\n+    private List<Log> entries;\n+    // the first uncommitted entry index.\n+    private long offset;\n+\n+    public UnCommittedEntryManager(long offset) {\n+        this.offset = offset;\n+        this.entries = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Return the first uncommitted index.\n+     *\n+     * @return offset\n+     */\n+    public long getFirstUnCommittedIndex() {\n+        return offset;\n+    }\n+\n+\n+    /**\n+     * Return last entry's index if this instance has at least one uncommitted entry.\n+     *\n+     * @return -1 if entries are empty, or last entry's index\n+     */\n+    public long maybeLastIndex() {\n+        int entryNum = entries.size();\n+        if (entryNum != 0) {\n+            return offset + entryNum - 1;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Return the entry's term for given index. Note that the called should ensure index >= offset.\n+     *\n+     * @param index request entry index\n+     * @return -1 if index < offset, throw EntryUnavailableException if index > last or entries is\n+     * empty, or return the entry's term for given index\n+     * @throws EntryUnavailableException\n+     */\n+    public long maybeTerm(long index) throws EntryUnavailableException {\n+        if (index < offset) {\n+            logger.debug(\n+                \"invalid unCommittedEntryManager maybeTerm : parameter: index({}) < offset({})\",\n+                index, offset);\n+            return -1;\n+        }\n+        long last = maybeLastIndex();\n+        if (last == -1 || index > last) {\n+            long boundary = last == -1 ? offset - 1 : last;\n+            logger.info(\n+                \"unCommittedEntryManager maybeTerm out of bound : parameter: index({}) > lastIndex({})\",\n+                index, boundary);\n+            throw new EntryUnavailableException(index, boundary);\n+        }\n+        return entries.get((int) (index - offset)).getCurrLogTerm();\n+    }\n+\n+    /**\n+     * Remove useless prefix entries as long as these entries has been committed and persisted. This\n+     * method is only called after persisting newly committed entries.\n+     *\n+     * @param index request entry's index\n+     * @param term  request entry's term\n+     */\n+    public void stableTo(long index, long term) {\n+        try {\n+            long entryTerm = maybeTerm(index);\n+            // only update the uncommitted entries if term is matched with an uncommitted entry.\n+            if (entryTerm == term) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE4NzIxNg=="}, "originalCommit": {"oid": "e838ca4587541ccc284aac59f87ec2632774233c"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDQxNjk4OnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/RaftLogManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwODoyNzoxNlrOGIJCaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMDo0MDoyNlrOGIOPSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE4OTg2NQ==", "bodyText": "It would be better to give also a single-log-append interface, as in the normal procedure, logs mainly go to followers one-by-one and it is costly to wrap them as singleton lists.", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411189865", "createdAt": "2020-04-20T08:27:16Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/RaftLogManager.java", "diffHunk": "@@ -0,0 +1,420 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.manage;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.cluster.exception.EntryCompactedException;\n+import org.apache.iotdb.cluster.exception.EntryUnavailableException;\n+import org.apache.iotdb.cluster.exception.GetEntriesWrongParametersException;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.LogApplier;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.db.exception.metadata.PathAlreadyExistException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class RaftLogManager {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RaftLogManager.class);\n+\n+    // manage uncommitted entries\n+    public UnCommittedEntryManager unCommittedEntryManager;\n+    // manage committed entries in memory as a cache\n+    public CommittedEntryManager committedEntryManager;\n+    // manage committed entries in disk for safety\n+    public StableEntryManager stableEntryManager;\n+\n+    private long commitIndex;\n+    private LogApplier logApplier;\n+\n+    public RaftLogManager(CommittedEntryManager committedEntryManager,\n+        StableEntryManager stableEntryManager, LogApplier applier) {\n+        this.logApplier = applier;\n+        this.committedEntryManager = committedEntryManager;\n+        this.stableEntryManager = stableEntryManager;\n+        this.committedEntryManager.append(stableEntryManager.getAllEntries());\n+        long last = committedEntryManager.getLastIndex();\n+        this.unCommittedEntryManager = new UnCommittedEntryManager(last + 1);\n+        // must have applied entry [compactIndex,last] to state machine\n+        this.commitIndex = last;\n+    }\n+\n+    // placeholder method\n+    public Snapshot getSnapshot() {\n+        return null;\n+    }\n+\n+    // placeholder method\n+    public void takeSnapshot() throws IOException {\n+\n+    }\n+\n+    public LogApplier getApplier() {\n+        return logApplier;\n+    }\n+\n+    /**\n+     * Return the raftNode's commitIndex.\n+     *\n+     * @return commitIndex\n+     */\n+    public long getCommitLogIndex() {\n+        return commitIndex;\n+    }\n+\n+    /**\n+     * Set the raftNode's commitIndex.\n+     *\n+     * @param commitIndex request commitIndex\n+     */\n+    public void setCommitLogIndex(long commitIndex) {\n+        this.commitIndex = commitIndex;\n+    }\n+\n+    /**\n+     * Return the first entry's index which have not been compacted.\n+     *\n+     * @return firstIndex\n+     */\n+    public long getFirstIndex() {\n+        return committedEntryManager.getFirstIndex();\n+    }\n+\n+    /**\n+     * Return the last entry's index which have been added into log module.\n+     *\n+     * @return lastIndex\n+     */\n+    public long getLastLogIndex() {\n+        long last = unCommittedEntryManager.maybeLastIndex();\n+        if (last != -1) {\n+            return last;\n+        }\n+        return committedEntryManager.getLastIndex();\n+    }\n+\n+    /**\n+     * Returns the term for given index.\n+     *\n+     * @param index request entry index\n+     * @return throw EntryCompactedException if index < dummyIndex, throw EntryUnavailableException if\n+     * index > lastIndex, otherwise return the entry's term for given index\n+     * @throws EntryUnavailableException\n+     * @throws EntryCompactedException\n+     */\n+    public long getTerm(long index) throws EntryUnavailableException, EntryCompactedException {\n+        long dummyIndex = getFirstIndex() - 1;\n+        if (index < dummyIndex) {\n+            logger.info(\"invalid getTerm: parameter: index({}) < compactIndex({})\", index,\n+                dummyIndex);\n+            throw new EntryCompactedException(index, dummyIndex);\n+        }\n+        long lastIndex = getLastLogIndex();\n+        if (index > lastIndex) {\n+            logger.info(\"invalid getTerm: parameter: index({}) > lastIndex({})\", index, lastIndex);\n+            throw new EntryUnavailableException(index, lastIndex);\n+        }\n+        if (index >= unCommittedEntryManager.getFirstUnCommittedIndex()) {\n+            return unCommittedEntryManager.maybeTerm(index);\n+        }\n+        return committedEntryManager.maybeTerm(index);\n+    }\n+\n+    /**\n+     * Return the last entry's term. If it goes wrong, there must be an unexpected exception.\n+     *\n+     * @return last entry's term\n+     */\n+    public long getLastLogTerm() {\n+        long term = -1;\n+        try {\n+            term = getTerm(getLastLogIndex());\n+        } catch (Exception e) {\n+            logger.error(\"unexpected error when getting the last term : {}\", e.getMessage());\n+        }\n+        return term;\n+    }\n+\n+    /**\n+     * Return the commitIndex's term. If it goes wrong, there must be an unexpected exception.\n+     *\n+     * @return commitIndex's term\n+     */\n+    public long getCommitLogTerm() {\n+        long term = -1;\n+        try {\n+            term = getTerm(getCommitLogIndex());\n+        } catch (Exception e) {\n+            logger.error(\"unexpected error when getting the last term : {}\", e.getMessage());\n+        }\n+        return term;\n+    }\n+\n+    /**\n+     * Used by follower node to support leader's complicated log replication rpc parameters and try to\n+     * commit entries.\n+     *\n+     * @param lastIndex    leader's matchIndex for this follower node\n+     * @param lastTerm     the entry's term which index is leader's matchIndex for this follower node\n+     * @param leaderCommit leader's commitIndex\n+     * @param entries      entries sent from the leader node Note that the leader must ensure\n+     *                     entries[0].index = lastIndex + 1\n+     * @return -1 if the entries cannot be appended, otherwise the last index of new entries\n+     */\n+    public long maybeAppend(long lastIndex, long lastTerm, long leaderCommit, List<Log> entries) {\n+        if (matchTerm(lastTerm, lastIndex)) {\n+            long newLastIndex = lastIndex + entries.size();\n+            long ci = findConflict(entries);\n+            if (ci == 0 || ci <= commitIndex) {\n+                logger\n+                    .error(\"entry {} conflict with committed entry [commitIndex({})]\", ci,\n+                        commitIndex);\n+            } else {\n+                long offset = lastIndex + 1;\n+                append(entries.subList((int) (ci - offset), entries.size()));\n+            }\n+            commitTo(Math.min(leaderCommit, newLastIndex));\n+            return newLastIndex;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Used by leader node or MaybeAppend to directly append to unCommittedEntryManager. Note that the\n+     * caller should ensure entries[0].index > committed.\n+     *\n+     * @param entries appendingEntries\n+     * @return the newly generated lastIndex\n+     */\n+    public long append(List<Log> entries) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e838ca4587541ccc284aac59f87ec2632774233c"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI3NTA4Mg==", "bodyText": "I think that as long as batch replication is supported, any log will be sent in batches to follower, and the single-log-append interface will only be used for leader to append member changes logs as long as the client can also send a batch of logs~ But for scalability and efficiency,  I have added a single-log-append  interface~", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411275082", "createdAt": "2020-04-20T10:40:26Z", "author": {"login": "LebronAl"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/RaftLogManager.java", "diffHunk": "@@ -0,0 +1,420 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.manage;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.cluster.exception.EntryCompactedException;\n+import org.apache.iotdb.cluster.exception.EntryUnavailableException;\n+import org.apache.iotdb.cluster.exception.GetEntriesWrongParametersException;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.LogApplier;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.db.exception.metadata.PathAlreadyExistException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class RaftLogManager {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RaftLogManager.class);\n+\n+    // manage uncommitted entries\n+    public UnCommittedEntryManager unCommittedEntryManager;\n+    // manage committed entries in memory as a cache\n+    public CommittedEntryManager committedEntryManager;\n+    // manage committed entries in disk for safety\n+    public StableEntryManager stableEntryManager;\n+\n+    private long commitIndex;\n+    private LogApplier logApplier;\n+\n+    public RaftLogManager(CommittedEntryManager committedEntryManager,\n+        StableEntryManager stableEntryManager, LogApplier applier) {\n+        this.logApplier = applier;\n+        this.committedEntryManager = committedEntryManager;\n+        this.stableEntryManager = stableEntryManager;\n+        this.committedEntryManager.append(stableEntryManager.getAllEntries());\n+        long last = committedEntryManager.getLastIndex();\n+        this.unCommittedEntryManager = new UnCommittedEntryManager(last + 1);\n+        // must have applied entry [compactIndex,last] to state machine\n+        this.commitIndex = last;\n+    }\n+\n+    // placeholder method\n+    public Snapshot getSnapshot() {\n+        return null;\n+    }\n+\n+    // placeholder method\n+    public void takeSnapshot() throws IOException {\n+\n+    }\n+\n+    public LogApplier getApplier() {\n+        return logApplier;\n+    }\n+\n+    /**\n+     * Return the raftNode's commitIndex.\n+     *\n+     * @return commitIndex\n+     */\n+    public long getCommitLogIndex() {\n+        return commitIndex;\n+    }\n+\n+    /**\n+     * Set the raftNode's commitIndex.\n+     *\n+     * @param commitIndex request commitIndex\n+     */\n+    public void setCommitLogIndex(long commitIndex) {\n+        this.commitIndex = commitIndex;\n+    }\n+\n+    /**\n+     * Return the first entry's index which have not been compacted.\n+     *\n+     * @return firstIndex\n+     */\n+    public long getFirstIndex() {\n+        return committedEntryManager.getFirstIndex();\n+    }\n+\n+    /**\n+     * Return the last entry's index which have been added into log module.\n+     *\n+     * @return lastIndex\n+     */\n+    public long getLastLogIndex() {\n+        long last = unCommittedEntryManager.maybeLastIndex();\n+        if (last != -1) {\n+            return last;\n+        }\n+        return committedEntryManager.getLastIndex();\n+    }\n+\n+    /**\n+     * Returns the term for given index.\n+     *\n+     * @param index request entry index\n+     * @return throw EntryCompactedException if index < dummyIndex, throw EntryUnavailableException if\n+     * index > lastIndex, otherwise return the entry's term for given index\n+     * @throws EntryUnavailableException\n+     * @throws EntryCompactedException\n+     */\n+    public long getTerm(long index) throws EntryUnavailableException, EntryCompactedException {\n+        long dummyIndex = getFirstIndex() - 1;\n+        if (index < dummyIndex) {\n+            logger.info(\"invalid getTerm: parameter: index({}) < compactIndex({})\", index,\n+                dummyIndex);\n+            throw new EntryCompactedException(index, dummyIndex);\n+        }\n+        long lastIndex = getLastLogIndex();\n+        if (index > lastIndex) {\n+            logger.info(\"invalid getTerm: parameter: index({}) > lastIndex({})\", index, lastIndex);\n+            throw new EntryUnavailableException(index, lastIndex);\n+        }\n+        if (index >= unCommittedEntryManager.getFirstUnCommittedIndex()) {\n+            return unCommittedEntryManager.maybeTerm(index);\n+        }\n+        return committedEntryManager.maybeTerm(index);\n+    }\n+\n+    /**\n+     * Return the last entry's term. If it goes wrong, there must be an unexpected exception.\n+     *\n+     * @return last entry's term\n+     */\n+    public long getLastLogTerm() {\n+        long term = -1;\n+        try {\n+            term = getTerm(getLastLogIndex());\n+        } catch (Exception e) {\n+            logger.error(\"unexpected error when getting the last term : {}\", e.getMessage());\n+        }\n+        return term;\n+    }\n+\n+    /**\n+     * Return the commitIndex's term. If it goes wrong, there must be an unexpected exception.\n+     *\n+     * @return commitIndex's term\n+     */\n+    public long getCommitLogTerm() {\n+        long term = -1;\n+        try {\n+            term = getTerm(getCommitLogIndex());\n+        } catch (Exception e) {\n+            logger.error(\"unexpected error when getting the last term : {}\", e.getMessage());\n+        }\n+        return term;\n+    }\n+\n+    /**\n+     * Used by follower node to support leader's complicated log replication rpc parameters and try to\n+     * commit entries.\n+     *\n+     * @param lastIndex    leader's matchIndex for this follower node\n+     * @param lastTerm     the entry's term which index is leader's matchIndex for this follower node\n+     * @param leaderCommit leader's commitIndex\n+     * @param entries      entries sent from the leader node Note that the leader must ensure\n+     *                     entries[0].index = lastIndex + 1\n+     * @return -1 if the entries cannot be appended, otherwise the last index of new entries\n+     */\n+    public long maybeAppend(long lastIndex, long lastTerm, long leaderCommit, List<Log> entries) {\n+        if (matchTerm(lastTerm, lastIndex)) {\n+            long newLastIndex = lastIndex + entries.size();\n+            long ci = findConflict(entries);\n+            if (ci == 0 || ci <= commitIndex) {\n+                logger\n+                    .error(\"entry {} conflict with committed entry [commitIndex({})]\", ci,\n+                        commitIndex);\n+            } else {\n+                long offset = lastIndex + 1;\n+                append(entries.subList((int) (ci - offset), entries.size()));\n+            }\n+            commitTo(Math.min(leaderCommit, newLastIndex));\n+            return newLastIndex;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Used by leader node or MaybeAppend to directly append to unCommittedEntryManager. Note that the\n+     * caller should ensure entries[0].index > committed.\n+     *\n+     * @param entries appendingEntries\n+     * @return the newly generated lastIndex\n+     */\n+    public long append(List<Log> entries) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE4OTg2NQ=="}, "originalCommit": {"oid": "e838ca4587541ccc284aac59f87ec2632774233c"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDQ2OTc5OnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwODozODo0M1rOGIJgfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMDo0MjoxN1rOGIOS1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE5NzU2NQ==", "bodyText": "It would be better to eliminate this overhead with a new interface.", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411197565", "createdAt": "2020-04-20T08:38:43Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -918,7 +916,9 @@ public boolean closePartition(String storageGroupName, long partitionId, boolean\n       log.setPreviousLogTerm(logManager.getLastLogTerm());\n       log.setCurrLogIndex(logManager.getLastLogIndex() + 1);\n \n-      logManager.appendLog(log);\n+      logManager.append(new ArrayList<Log>() {{\n+        add(log);\n+      }});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e838ca4587541ccc284aac59f87ec2632774233c"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI3NTk5MQ==", "bodyText": "OK~I will fix it.", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411275991", "createdAt": "2020-04-20T10:42:17Z", "author": {"login": "LebronAl"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -918,7 +916,9 @@ public boolean closePartition(String storageGroupName, long partitionId, boolean\n       log.setPreviousLogTerm(logManager.getLastLogTerm());\n       log.setCurrLogIndex(logManager.getLastLogIndex() + 1);\n \n-      logManager.appendLog(log);\n+      logManager.append(new ArrayList<Log>() {{\n+        add(log);\n+      }});", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE5NzU2NQ=="}, "originalCommit": {"oid": "e838ca4587541ccc284aac59f87ec2632774233c"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDQ4NjkwOnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwODo0Mjo0MFrOGIJqVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMzo1MDoyMVrOGIVctw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwMDA4Nw==", "bodyText": "The new ArrayList() seems unused.\nEven if !allLogsValid holds, the logs after the snapshot point should still be attained.\nPlease log e instead of e.getMessage() for the sake of debugging.", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411200087", "createdAt": "2020-04-20T08:42:40Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java", "diffHunk": "@@ -671,17 +672,22 @@ public void catchUp(Node follower, long followerLastLogIndex) {\n \n     AsyncClient client = connectNode(follower);\n     if (client != null) {\n-      List<Log> logs;\n+      List<Log> logs = new ArrayList<>();\n       boolean allLogsValid;\n       Snapshot snapshot = null;\n       synchronized (logManager) {\n         // check if the very first log has been snapshot\n         allLogsValid = logManager.logValid(followerLastLogIndex);\n-        logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n         if (!allLogsValid) {\n           // if the first log has been snapshot, the snapshot should also be sent to the\n           // follower, otherwise some data will be missing\n           snapshot = logManager.getSnapshot();\n+        }else{\n+          try {\n+            logs = logManager.getEntries(followerLastLogIndex, Long.MAX_VALUE);\n+          }catch (Exception e){\n+              logger.error(\"Unexpected error: {}\" ,e.getMessage());\n+          }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e838ca4587541ccc284aac59f87ec2632774233c"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM5MzIwNw==", "bodyText": "Sorry,I misunderstood the code here. I thought the logs weren't needed when the snapshot was sent.I will fix this~", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411393207", "createdAt": "2020-04-20T13:50:21Z", "author": {"login": "LebronAl"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java", "diffHunk": "@@ -671,17 +672,22 @@ public void catchUp(Node follower, long followerLastLogIndex) {\n \n     AsyncClient client = connectNode(follower);\n     if (client != null) {\n-      List<Log> logs;\n+      List<Log> logs = new ArrayList<>();\n       boolean allLogsValid;\n       Snapshot snapshot = null;\n       synchronized (logManager) {\n         // check if the very first log has been snapshot\n         allLogsValid = logManager.logValid(followerLastLogIndex);\n-        logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n         if (!allLogsValid) {\n           // if the first log has been snapshot, the snapshot should also be sent to the\n           // follower, otherwise some data will be missing\n           snapshot = logManager.getSnapshot();\n+        }else{\n+          try {\n+            logs = logManager.getEntries(followerLastLogIndex, Long.MAX_VALUE);\n+          }catch (Exception e){\n+              logger.error(\"Unexpected error: {}\" ,e.getMessage());\n+          }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwMDA4Nw=="}, "originalCommit": {"oid": "e838ca4587541ccc284aac59f87ec2632774233c"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDUwNjU0OnYy", "diffSide": "RIGHT", "path": "cluster/src/test/java/org/apache/iotdb/cluster/log/manage/RaftLogManagerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwODo0NzowN1rOGIJ1xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTozMzo0OVrOGILvLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwMzAxNQ==", "bodyText": "The indents seem too long in the tests, please check the code style.", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411203015", "createdAt": "2020-04-20T08:47:07Z", "author": {"login": "jt2594838"}, "path": "cluster/src/test/java/org/apache/iotdb/cluster/log/manage/RaftLogManagerTest.java", "diffHunk": "@@ -0,0 +1,787 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.manage;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.iotdb.cluster.common.TestLogApplier;\n+import org.apache.iotdb.cluster.common.TestUtils;\n+import org.apache.iotdb.cluster.exception.EntryCompactedException;\n+import org.apache.iotdb.cluster.exception.EntryUnavailableException;\n+import org.apache.iotdb.cluster.exception.GetEntriesWrongParametersException;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.LogApplier;\n+import org.apache.iotdb.cluster.log.logtypes.EmptyContentLog;\n+import org.apache.iotdb.cluster.log.snapshot.SimpleSnapshot;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class RaftLogManagerTest {\n+\n+\tprivate Set<Log> appliedLogs;\n+\tprivate LogApplier logApplier = new TestLogApplier() {\n+\t\t@Override\n+\t\tpublic void apply(Log log) {\n+\t\t\tappliedLogs.add(log);\n+\t\t}\n+\t};\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e838ca4587541ccc284aac59f87ec2632774233c"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIzNDA5NQ==", "bodyText": "OK~", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411234095", "createdAt": "2020-04-20T09:33:49Z", "author": {"login": "LebronAl"}, "path": "cluster/src/test/java/org/apache/iotdb/cluster/log/manage/RaftLogManagerTest.java", "diffHunk": "@@ -0,0 +1,787 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.manage;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.iotdb.cluster.common.TestLogApplier;\n+import org.apache.iotdb.cluster.common.TestUtils;\n+import org.apache.iotdb.cluster.exception.EntryCompactedException;\n+import org.apache.iotdb.cluster.exception.EntryUnavailableException;\n+import org.apache.iotdb.cluster.exception.GetEntriesWrongParametersException;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.LogApplier;\n+import org.apache.iotdb.cluster.log.logtypes.EmptyContentLog;\n+import org.apache.iotdb.cluster.log.snapshot.SimpleSnapshot;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class RaftLogManagerTest {\n+\n+\tprivate Set<Log> appliedLogs;\n+\tprivate LogApplier logApplier = new TestLogApplier() {\n+\t\t@Override\n+\t\tpublic void apply(Log log) {\n+\t\t\tappliedLogs.add(log);\n+\t\t}\n+\t};\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwMzAxNQ=="}, "originalCommit": {"oid": "e838ca4587541ccc284aac59f87ec2632774233c"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTQ4NTIzOnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/CommittedEntryManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjo0OTo1MlrOGIS0QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMzo1MzozOVrOGIVn4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM1MDA4MQ==", "bodyText": "May be you should just return here or throw an IllegalArugumentException", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411350081", "createdAt": "2020-04-20T12:49:52Z", "author": {"login": "SilverNarcissus"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/CommittedEntryManager.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.manage;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.cluster.exception.EntryCompactedException;\n+import org.apache.iotdb.cluster.exception.EntryUnavailableException;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.cluster.log.logtypes.EmptyContentLog;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CommittedEntryManager {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(CommittedEntryManager.class);\n+\n+    // memory cache for logs which have been persisted in disk.\n+    private List<Log> entries;\n+\n+    /**\n+     * Note that it is better to use applyingSnapshot to update dummy entry immediately after this\n+     * instance is created.\n+     */\n+    public CommittedEntryManager() {\n+        entries = new ArrayList<Log>() {{\n+            add(new EmptyContentLog(-1, -1));\n+        }};\n+    }\n+\n+    /**\n+     * Overwrite the contents of this object with those of the given snapshot. Note that this function\n+     * is only used if you want to override all the contents, otherwise please use\n+     * compactEntries(snapshot.lastIndex()).\n+     *\n+     * @param snapshot snapshot\n+     */\n+    public void applyingSnapshot(Snapshot snapshot) {\n+        long localIndex = getDummyIndex();\n+        long snapIndex = snapshot.getLastLogIndex();\n+        if (localIndex >= snapIndex) {\n+            logger.info(\"requested snapshot is older than the existing snapshot\");\n+            return;\n+        }\n+        entries.clear();\n+        entries.add(new EmptyContentLog(snapshot.getLastLogIndex(), snapshot.getLastLogTerm()));\n+    }\n+\n+    /**\n+     * Return the last entry's index which have been compacted.\n+     *\n+     * @return dummyIndex\n+     */\n+    public Long getDummyIndex() {\n+        return entries.get(0).getCurrLogIndex();\n+    }\n+\n+    /**\n+     * Return the first entry's index which have not been compacted.\n+     *\n+     * @return firstIndex\n+     */\n+    public Long getFirstIndex() {\n+        return getDummyIndex() + 1;\n+    }\n+\n+    /**\n+     * Return the last entry's index which have been committed and persisted.\n+     *\n+     * @return getLastIndex\n+     */\n+    public Long getLastIndex() {\n+        return getDummyIndex() + entries.size() - 1;\n+    }\n+\n+    /**\n+     * Return the entry's term for given index. Note that the called should ensure index <=\n+     * entries[entries.size()-1].index.\n+     *\n+     * @param index request entry index\n+     * @return -1 if index > entries[entries.size()-1].index, throw EntryCompactedException if index <\n+     * dummyIndex, or return the entry's term for given index\n+     * @throws EntryCompactedException\n+     */\n+    public long maybeTerm(long index) throws EntryCompactedException {\n+        long dummyIndex = getDummyIndex();\n+        if (index < dummyIndex) {\n+            logger.info(\n+                \"invalid committedEntryManager maybeTerm: parameter: index({}) < compactIndex({})\",\n+                index, dummyIndex);\n+            throw new EntryCompactedException(index, dummyIndex);\n+        }\n+        if ((int) (index - dummyIndex) >= entries.size()) {\n+            logger.debug(\n+                \"invalid committedEntryManager maybeTerm : parameter: index({}) > lastIndex({})\",\n+                index, getLastIndex());\n+            return -1;\n+        }\n+        return entries.get((int) (index - dummyIndex)).getCurrLogTerm();\n+    }\n+\n+    /**\n+     * Pack entries from low through high - 1, just like slice (entries[low:high]). dummyIndex < low\n+     * <= high. Note that caller must ensure low <= high.\n+     *\n+     * @param low  request index low bound\n+     * @param high request index upper bound\n+     * @throws EntryCompactedException\n+     */\n+    public List<Log> getEntries(long low, long high) throws EntryCompactedException {\n+        if (low > high) {\n+            logger.debug(\"invalid getEntries: parameter: {} > {}\", low, high);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e838ca4587541ccc284aac59f87ec2632774233c"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM5NjA2Ng==", "bodyText": "OK~ I will return a empty list here~", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411396066", "createdAt": "2020-04-20T13:53:39Z", "author": {"login": "LebronAl"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/CommittedEntryManager.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.manage;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.cluster.exception.EntryCompactedException;\n+import org.apache.iotdb.cluster.exception.EntryUnavailableException;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.cluster.log.logtypes.EmptyContentLog;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CommittedEntryManager {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(CommittedEntryManager.class);\n+\n+    // memory cache for logs which have been persisted in disk.\n+    private List<Log> entries;\n+\n+    /**\n+     * Note that it is better to use applyingSnapshot to update dummy entry immediately after this\n+     * instance is created.\n+     */\n+    public CommittedEntryManager() {\n+        entries = new ArrayList<Log>() {{\n+            add(new EmptyContentLog(-1, -1));\n+        }};\n+    }\n+\n+    /**\n+     * Overwrite the contents of this object with those of the given snapshot. Note that this function\n+     * is only used if you want to override all the contents, otherwise please use\n+     * compactEntries(snapshot.lastIndex()).\n+     *\n+     * @param snapshot snapshot\n+     */\n+    public void applyingSnapshot(Snapshot snapshot) {\n+        long localIndex = getDummyIndex();\n+        long snapIndex = snapshot.getLastLogIndex();\n+        if (localIndex >= snapIndex) {\n+            logger.info(\"requested snapshot is older than the existing snapshot\");\n+            return;\n+        }\n+        entries.clear();\n+        entries.add(new EmptyContentLog(snapshot.getLastLogIndex(), snapshot.getLastLogTerm()));\n+    }\n+\n+    /**\n+     * Return the last entry's index which have been compacted.\n+     *\n+     * @return dummyIndex\n+     */\n+    public Long getDummyIndex() {\n+        return entries.get(0).getCurrLogIndex();\n+    }\n+\n+    /**\n+     * Return the first entry's index which have not been compacted.\n+     *\n+     * @return firstIndex\n+     */\n+    public Long getFirstIndex() {\n+        return getDummyIndex() + 1;\n+    }\n+\n+    /**\n+     * Return the last entry's index which have been committed and persisted.\n+     *\n+     * @return getLastIndex\n+     */\n+    public Long getLastIndex() {\n+        return getDummyIndex() + entries.size() - 1;\n+    }\n+\n+    /**\n+     * Return the entry's term for given index. Note that the called should ensure index <=\n+     * entries[entries.size()-1].index.\n+     *\n+     * @param index request entry index\n+     * @return -1 if index > entries[entries.size()-1].index, throw EntryCompactedException if index <\n+     * dummyIndex, or return the entry's term for given index\n+     * @throws EntryCompactedException\n+     */\n+    public long maybeTerm(long index) throws EntryCompactedException {\n+        long dummyIndex = getDummyIndex();\n+        if (index < dummyIndex) {\n+            logger.info(\n+                \"invalid committedEntryManager maybeTerm: parameter: index({}) < compactIndex({})\",\n+                index, dummyIndex);\n+            throw new EntryCompactedException(index, dummyIndex);\n+        }\n+        if ((int) (index - dummyIndex) >= entries.size()) {\n+            logger.debug(\n+                \"invalid committedEntryManager maybeTerm : parameter: index({}) > lastIndex({})\",\n+                index, getLastIndex());\n+            return -1;\n+        }\n+        return entries.get((int) (index - dummyIndex)).getCurrLogTerm();\n+    }\n+\n+    /**\n+     * Pack entries from low through high - 1, just like slice (entries[low:high]). dummyIndex < low\n+     * <= high. Note that caller must ensure low <= high.\n+     *\n+     * @param low  request index low bound\n+     * @param high request index upper bound\n+     * @throws EntryCompactedException\n+     */\n+    public List<Log> getEntries(long low, long high) throws EntryCompactedException {\n+        if (low > high) {\n+            logger.debug(\"invalid getEntries: parameter: {} > {}\", low, high);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM1MDA4MQ=="}, "originalCommit": {"oid": "e838ca4587541ccc284aac59f87ec2632774233c"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTUwNzEwOnYy", "diffSide": "RIGHT", "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/UnCommittedEntryManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjo1NDo0OVrOGITBEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMzo1Mzo1N1rOGIVpKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM1MzM2MQ==", "bodyText": "May be you should just return here or throw an IllegalArugumentException", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411353361", "createdAt": "2020-04-20T12:54:49Z", "author": {"login": "SilverNarcissus"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/UnCommittedEntryManager.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.manage;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.iotdb.cluster.exception.EntryUnavailableException;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class UnCommittedEntryManager {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnCommittedEntryManager.class);\n+    // all entries that have not been committed.\n+    private List<Log> entries;\n+    // the first uncommitted entry index.\n+    private long offset;\n+\n+    public UnCommittedEntryManager(long offset) {\n+        this.offset = offset;\n+        this.entries = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Return the first uncommitted index.\n+     *\n+     * @return offset\n+     */\n+    public long getFirstUnCommittedIndex() {\n+        return offset;\n+    }\n+\n+\n+    /**\n+     * Return last entry's index if this instance has at least one uncommitted entry.\n+     *\n+     * @return -1 if entries are empty, or last entry's index\n+     */\n+    public long maybeLastIndex() {\n+        int entryNum = entries.size();\n+        if (entryNum != 0) {\n+            return offset + entryNum - 1;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Return the entry's term for given index. Note that the called should ensure index >= offset.\n+     *\n+     * @param index request entry index\n+     * @return -1 if index < offset, throw EntryUnavailableException if index > last or entries is\n+     * empty, or return the entry's term for given index\n+     * @throws EntryUnavailableException\n+     */\n+    public long maybeTerm(long index) throws EntryUnavailableException {\n+        if (index < offset) {\n+            logger.debug(\n+                \"invalid unCommittedEntryManager maybeTerm : parameter: index({}) < offset({})\",\n+                index, offset);\n+            return -1;\n+        }\n+        long last = maybeLastIndex();\n+        if (last == -1 || index > last) {\n+            long boundary = last == -1 ? offset - 1 : last;\n+            logger.info(\n+                \"unCommittedEntryManager maybeTerm out of bound : parameter: index({}) > lastIndex({})\",\n+                index, boundary);\n+            throw new EntryUnavailableException(index, boundary);\n+        }\n+        return entries.get((int) (index - offset)).getCurrLogTerm();\n+    }\n+\n+    /**\n+     * Remove useless prefix entries as long as these entries has been committed and persisted. This\n+     * method is only called after persisting newly committed entries.\n+     *\n+     * @param index request entry's index\n+     * @param term  request entry's term\n+     */\n+    public void stableTo(long index, long term) {\n+        try {\n+            long entryTerm = maybeTerm(index);\n+            // only update the uncommitted entries if term is matched with an uncommitted entry.\n+            if (entryTerm == term) {\n+                entries.subList(0, (int) (index + 1 - offset)).clear();\n+                offset = index + 1;\n+            }\n+        } catch (EntryUnavailableException e) {\n+            logger.info(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Update offset and clear entries because leader's snapshot is more up-to-date. This method is\n+     * only called for applying snapshot from leader.\n+     *\n+     * @param snapshot leader's snapshot\n+     */\n+    public void applyingSnapshot(Snapshot snapshot) {\n+        this.offset = snapshot.getLastLogIndex() + 1;\n+        this.entries.clear();\n+    }\n+\n+    /**\n+     * TruncateAndAppend uncommitted entries. This method will truncate conflict entries if it finds\n+     * inconsistencies. Note that the caller should ensure appendingEntries[0].index <=\n+     * entries[entries.size()-1].index + 1. Note that the caller should ensure not to truncate entries\n+     * which have been committed.\n+     *\n+     * @param appendingEntries request entries\n+     */\n+    public void truncateAndAppend(List<Log> appendingEntries) {\n+        long after = appendingEntries.get(0).getCurrLogIndex();\n+        long len = after - offset;\n+        if (len < 0) {\n+            // the logs are being truncated to before our current offset portion, which is committed entries\n+            // unconditional obedience to the leader's request. Maybe throw a exception here is better\n+            offset = after;\n+            entries = appendingEntries;\n+            logger.error(\"The logs which first index is {} are going to truncate committed logs\",\n+                after);\n+        } else if (len == entries.size()) {\n+            // after is the next index in the entries\n+            // directly append\n+            entries.addAll(appendingEntries);\n+        } else {\n+            // clear conflict entries\n+            // then append\n+            logger.info(\"truncate the entries after index {}\", after);\n+            int truncateIndex = (int) (after - offset);\n+            if (truncateIndex < entries.size()) {\n+                entries.subList(truncateIndex, entries.size()).clear();\n+            }\n+            entries.addAll(appendingEntries);\n+        }\n+    }\n+\n+    /**\n+     * Pack entries from low through high - 1, just like slice (entries[low:high]). offset <= low <=\n+     * high. Note that caller must ensure low <= high.\n+     *\n+     * @param low  request index low bound\n+     * @param high request index upper bound\n+     */\n+    public List<Log> getEntries(long low, long high) {\n+        if (low > high) {\n+            logger\n+                .debug(\"invalid unCommittedEntryManager getEntries: parameter: low({}) > high({})\",\n+                    low, high);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e838ca4587541ccc284aac59f87ec2632774233c"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM5NjM5NQ==", "bodyText": "Fine~", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411396395", "createdAt": "2020-04-20T13:53:57Z", "author": {"login": "LebronAl"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/UnCommittedEntryManager.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.manage;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.iotdb.cluster.exception.EntryUnavailableException;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class UnCommittedEntryManager {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnCommittedEntryManager.class);\n+    // all entries that have not been committed.\n+    private List<Log> entries;\n+    // the first uncommitted entry index.\n+    private long offset;\n+\n+    public UnCommittedEntryManager(long offset) {\n+        this.offset = offset;\n+        this.entries = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Return the first uncommitted index.\n+     *\n+     * @return offset\n+     */\n+    public long getFirstUnCommittedIndex() {\n+        return offset;\n+    }\n+\n+\n+    /**\n+     * Return last entry's index if this instance has at least one uncommitted entry.\n+     *\n+     * @return -1 if entries are empty, or last entry's index\n+     */\n+    public long maybeLastIndex() {\n+        int entryNum = entries.size();\n+        if (entryNum != 0) {\n+            return offset + entryNum - 1;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Return the entry's term for given index. Note that the called should ensure index >= offset.\n+     *\n+     * @param index request entry index\n+     * @return -1 if index < offset, throw EntryUnavailableException if index > last or entries is\n+     * empty, or return the entry's term for given index\n+     * @throws EntryUnavailableException\n+     */\n+    public long maybeTerm(long index) throws EntryUnavailableException {\n+        if (index < offset) {\n+            logger.debug(\n+                \"invalid unCommittedEntryManager maybeTerm : parameter: index({}) < offset({})\",\n+                index, offset);\n+            return -1;\n+        }\n+        long last = maybeLastIndex();\n+        if (last == -1 || index > last) {\n+            long boundary = last == -1 ? offset - 1 : last;\n+            logger.info(\n+                \"unCommittedEntryManager maybeTerm out of bound : parameter: index({}) > lastIndex({})\",\n+                index, boundary);\n+            throw new EntryUnavailableException(index, boundary);\n+        }\n+        return entries.get((int) (index - offset)).getCurrLogTerm();\n+    }\n+\n+    /**\n+     * Remove useless prefix entries as long as these entries has been committed and persisted. This\n+     * method is only called after persisting newly committed entries.\n+     *\n+     * @param index request entry's index\n+     * @param term  request entry's term\n+     */\n+    public void stableTo(long index, long term) {\n+        try {\n+            long entryTerm = maybeTerm(index);\n+            // only update the uncommitted entries if term is matched with an uncommitted entry.\n+            if (entryTerm == term) {\n+                entries.subList(0, (int) (index + 1 - offset)).clear();\n+                offset = index + 1;\n+            }\n+        } catch (EntryUnavailableException e) {\n+            logger.info(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Update offset and clear entries because leader's snapshot is more up-to-date. This method is\n+     * only called for applying snapshot from leader.\n+     *\n+     * @param snapshot leader's snapshot\n+     */\n+    public void applyingSnapshot(Snapshot snapshot) {\n+        this.offset = snapshot.getLastLogIndex() + 1;\n+        this.entries.clear();\n+    }\n+\n+    /**\n+     * TruncateAndAppend uncommitted entries. This method will truncate conflict entries if it finds\n+     * inconsistencies. Note that the caller should ensure appendingEntries[0].index <=\n+     * entries[entries.size()-1].index + 1. Note that the caller should ensure not to truncate entries\n+     * which have been committed.\n+     *\n+     * @param appendingEntries request entries\n+     */\n+    public void truncateAndAppend(List<Log> appendingEntries) {\n+        long after = appendingEntries.get(0).getCurrLogIndex();\n+        long len = after - offset;\n+        if (len < 0) {\n+            // the logs are being truncated to before our current offset portion, which is committed entries\n+            // unconditional obedience to the leader's request. Maybe throw a exception here is better\n+            offset = after;\n+            entries = appendingEntries;\n+            logger.error(\"The logs which first index is {} are going to truncate committed logs\",\n+                after);\n+        } else if (len == entries.size()) {\n+            // after is the next index in the entries\n+            // directly append\n+            entries.addAll(appendingEntries);\n+        } else {\n+            // clear conflict entries\n+            // then append\n+            logger.info(\"truncate the entries after index {}\", after);\n+            int truncateIndex = (int) (after - offset);\n+            if (truncateIndex < entries.size()) {\n+                entries.subList(truncateIndex, entries.size()).clear();\n+            }\n+            entries.addAll(appendingEntries);\n+        }\n+    }\n+\n+    /**\n+     * Pack entries from low through high - 1, just like slice (entries[low:high]). offset <= low <=\n+     * high. Note that caller must ensure low <= high.\n+     *\n+     * @param low  request index low bound\n+     * @param high request index upper bound\n+     */\n+    public List<Log> getEntries(long low, long high) {\n+        if (low > high) {\n+            logger\n+                .debug(\"invalid unCommittedEntryManager getEntries: parameter: low({}) > high({})\",\n+                    low, high);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM1MzM2MQ=="}, "originalCommit": {"oid": "e838ca4587541ccc284aac59f87ec2632774233c"}, "originalPosition": 171}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 175, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}