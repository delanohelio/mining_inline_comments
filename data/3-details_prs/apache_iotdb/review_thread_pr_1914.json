{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzODczNzk1", "number": 1914, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNDozMTo1OVrOE2gtJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMzowOTowM1rOE7CwQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NTk0NDA3OnYy", "diffSide": "RIGHT", "path": "README_ZH.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNDozMTo1OVrOHvWqPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNDozMTo1OVrOHvWqPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQxNjM4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            > \u5982\u679c\u60a8\u6ca1\u6709\u5728\u53e6\u4e00\u53f0\u8ba1\u7b97\u673a\u7684IoTDB\u4e2d\u521b\u5efa\u5143\u6570\u636e\uff0cIoTDB\u5c06\u81ea\u5df1\u63a8\u65ad\u6570\u636e\u7c7b\u578b\uff0c\u8fd9\u53ef\u80fd\u4f1a\u5bfc\u81f4\u65f6\u95f4\u5e8f\u5217\u5177\u6709\u4e0d\u540c\u7684\u6570\u636e\u7c7b\u578b\u548c\u8bb8\u591a\u5176\u4ed6\u610f\u60f3\u4e0d\u5230\u7684\u4e1c\u897f\u3002\n          \n          \n            \n            IoTDB\u5177\u6709\u7c7b\u578b\u63a8\u65ad\u7684\u80fd\u529b\uff0c\u56e0\u6b64\u5728\u6570\u636e\u5bfc\u5165\u524d\u521b\u5efa\u5143\u6570\u636e\u4e0d\u662f\u5fc5\u987b\u7684\u3002\u4f46\u6211\u4eec\u4ecd\u7136\u63a8\u8350\u5728\u4f7f\u7528CSV\u5bfc\u5165\u5de5\u5177\u5bfc\u5165\u6570\u636e\u524d\u521b\u5efa\u5143\u6570\u636e\uff0c\u56e0\u4e3a\u8fd9\u53ef\u4ee5\u907f\u514d\u4e0d\u5fc5\u8981\u7684\u7c7b\u578b\u8f6c\u6362\u9519\u8bef\u3002", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r519416380", "createdAt": "2020-11-08T14:31:59Z", "author": {"login": "SteveYurongSu"}, "path": "README_ZH.md", "diffHunk": "@@ -347,16 +347,19 @@ CREATE TIMESERIES root.fit.d2.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n CREATE TIMESERIES root.fit.d2.s3 WITH DATATYPE=INT32,ENCODING=RLE;\n CREATE TIMESERIES root.fit.p.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n ```\n+> \u5982\u679c\u60a8\u6ca1\u6709\u5728\u53e6\u4e00\u53f0\u8ba1\u7b97\u673a\u7684IoTDB\u4e2d\u521b\u5efa\u5143\u6570\u636e\uff0cIoTDB\u5c06\u81ea\u5df1\u63a8\u65ad\u6570\u636e\u7c7b\u578b\uff0c\u8fd9\u53ef\u80fd\u4f1a\u5bfc\u81f4\u65f6\u95f4\u5e8f\u5217\u5177\u6709\u4e0d\u540c\u7684\u6570\u636e\u7c7b\u578b\u548c\u8bb8\u591a\u5176\u4ed6\u610f\u60f3\u4e0d\u5230\u7684\u4e1c\u897f\u3002", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052e64c974dd338358b037d87788900aca42457"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NTk0NjQwOnYy", "diffSide": "RIGHT", "path": "README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNDozMzoxOFrOHvWrzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNDozMzoxOFrOHvWrzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQxNjc4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            > if you didn't create metadata in the IoTDB in another computer, IoTDB will infer datatype by itself and this probably caused time series has different datatype and many other unexpected things.\n          \n          \n            \n            IoTDB has the ability of type inference, so it is not necessary to create metadata before data import. However, we still recommend creating metadata before importing data using the CSV import tool, as this can avoid unnecessary type conversion errors.", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r519416781", "createdAt": "2020-11-08T14:33:18Z", "author": {"login": "SteveYurongSu"}, "path": "README.md", "diffHunk": "@@ -347,14 +348,17 @@ CREATE TIMESERIES root.fit.d2.s3 WITH DATATYPE=INT32,ENCODING=RLE;\n CREATE TIMESERIES root.fit.p.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n ```\n \n+> if you didn't create metadata in the IoTDB in another computer, IoTDB will infer datatype by itself and this probably caused time series has different datatype and many other unexpected things.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052e64c974dd338358b037d87788900aca42457"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NTk0ODM4OnYy", "diffSide": "RIGHT", "path": "README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNDozNDoxNlrOHvWs_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNDozNDoxNlrOHvWs_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQxNzA4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            3,900,IoTDB,1000,1100,1200\n          \n          \n            \n            3,900,\"hello, world\",1000,1100,1200", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r519417087", "createdAt": "2020-11-08T14:34:16Z", "author": {"login": "SteveYurongSu"}, "path": "README.md", "diffHunk": "@@ -347,14 +348,17 @@ CREATE TIMESERIES root.fit.d2.s3 WITH DATATYPE=INT32,ENCODING=RLE;\n CREATE TIMESERIES root.fit.p.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n ```\n \n+> if you didn't create metadata in the IoTDB in another computer, IoTDB will infer datatype by itself and this probably caused time series has different datatype and many other unexpected things.\n+\n ### An example of import csv file\n \n ```\n Time,root.fit.d1.s1,root.fit.d1.s2,root.fit.d2.s1,root.fit.d2.s3,root.fit.p.s1\n-1,100,'hello',200,300,400\n-2,500,'world',600,700,800\n-3,900,'IoTDB',1000,1100,1200\n+1,100,hello,200,300,400\n+2,500,world,600,700,800\n+3,900,IoTDB,1000,1100,1200", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052e64c974dd338358b037d87788900aca42457"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjAxNzczOnYy", "diffSide": "RIGHT", "path": "README.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNTowNzozMFrOHvXY3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMjo1ODoxNFrOHvdeJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQyODMxNg==", "bodyText": "As a user, I may have the following concerns:\n\nWhat delimiters are allowed?\nWhat are the special characters (e.g., \" and ,) that will affect data import? How should these special characters be handled?\n\nI think the documentation is not clear enough.", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r519428316", "createdAt": "2020-11-08T15:07:30Z", "author": {"login": "SteveYurongSu"}, "path": "README.md", "diffHunk": "@@ -347,14 +348,17 @@ CREATE TIMESERIES root.fit.d2.s3 WITH DATATYPE=INT32,ENCODING=RLE;\n CREATE TIMESERIES root.fit.p.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n ```\n \n+> if you didn't create metadata in the IoTDB in another computer, IoTDB will infer datatype by itself and this probably caused time series has different datatype and many other unexpected things.\n+\n ### An example of import csv file\n \n ```\n Time,root.fit.d1.s1,root.fit.d1.s2,root.fit.d2.s1,root.fit.d2.s3,root.fit.p.s1\n-1,100,'hello',200,300,400\n-2,500,'world',600,700,800\n-3,900,'IoTDB',1000,1100,1200\n+1,100,hello,200,300,400\n+2,500,world,600,700,800\n+3,900,IoTDB,1000,1100,1200\n ```\n+> if you have a comma in your field, the field should be enclosed by a double quote or single quote.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052e64c974dd338358b037d87788900aca42457"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyNzk3NQ==", "bodyText": "updated", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r519527975", "createdAt": "2020-11-09T02:58:14Z", "author": {"login": "Genius-pig"}, "path": "README.md", "diffHunk": "@@ -347,14 +348,17 @@ CREATE TIMESERIES root.fit.d2.s3 WITH DATATYPE=INT32,ENCODING=RLE;\n CREATE TIMESERIES root.fit.p.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n ```\n \n+> if you didn't create metadata in the IoTDB in another computer, IoTDB will infer datatype by itself and this probably caused time series has different datatype and many other unexpected things.\n+\n ### An example of import csv file\n \n ```\n Time,root.fit.d1.s1,root.fit.d1.s2,root.fit.d2.s1,root.fit.d2.s3,root.fit.p.s1\n-1,100,'hello',200,300,400\n-2,500,'world',600,700,800\n-3,900,'IoTDB',1000,1100,1200\n+1,100,hello,200,300,400\n+2,500,world,600,700,800\n+3,900,IoTDB,1000,1100,1200\n ```\n+> if you have a comma in your field, the field should be enclosed by a double quote or single quote.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQyODMxNg=="}, "originalCommit": {"oid": "6052e64c974dd338358b037d87788900aca42457"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjU4Njg1OnYy", "diffSide": "RIGHT", "path": "README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMzowMjowMVrOH0zvcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMzowMjowMVrOH0zvcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzNTczMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            3,900,\"hello, world\",1000,1100,1200\n          \n          \n            \n            3,900,\"hello, \\\"world\\\"\",1000,1100,1200", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r525135730", "createdAt": "2020-11-17T13:02:01Z", "author": {"login": "SteveYurongSu"}, "path": "README.md", "diffHunk": "@@ -347,14 +348,17 @@ CREATE TIMESERIES root.fit.d2.s3 WITH DATATYPE=INT32,ENCODING=RLE;\n CREATE TIMESERIES root.fit.p.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n ```\n \n+IoTDB has the ability of type inference, so it is not necessary to create metadata before data import. However, we still recommend creating metadata before importing data using the CSV import tool, as this can avoid unnecessary type conversion errors.\n+\n ### An example of import csv file\n \n ```\n Time,root.fit.d1.s1,root.fit.d1.s2,root.fit.d2.s1,root.fit.d2.s3,root.fit.p.s1\n-1,100,'hello',200,300,400\n-2,500,'world',600,700,800\n-3,900,'IoTDB',1000,1100,1200\n+1,100,hello,200,300,400\n+2,500,world,600,700,800\n+3,900,\"hello, world\",1000,1100,1200", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40b45a0fa86717ee53aac4e72e01996c34825fc5"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5Mjc2ODQzOnYy", "diffSide": "RIGHT", "path": "README.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMzo0NDo1M1rOH01gug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwMjowOTowM1rOH1TBsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE2NDczMA==", "bodyText": "Note that the following special characters in fields need to be checked before importing:\n\n, : fields containing , should be quoted by a pair of \" or a pair of '.\n\" : \" in fields should be replaced by \\\" .\n' : ' in fields should be replaced by \\' .", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r525164730", "createdAt": "2020-11-17T13:44:53Z", "author": {"login": "SteveYurongSu"}, "path": "README.md", "diffHunk": "@@ -347,14 +348,17 @@ CREATE TIMESERIES root.fit.d2.s3 WITH DATATYPE=INT32,ENCODING=RLE;\n CREATE TIMESERIES root.fit.p.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n ```\n \n+IoTDB has the ability of type inference, so it is not necessary to create metadata before data import. However, we still recommend creating metadata before importing data using the CSV import tool, as this can avoid unnecessary type conversion errors.\n+\n ### An example of import csv file\n \n ```\n Time,root.fit.d1.s1,root.fit.d1.s2,root.fit.d2.s1,root.fit.d2.s3,root.fit.p.s1\n-1,100,'hello',200,300,400\n-2,500,'world',600,700,800\n-3,900,'IoTDB',1000,1100,1200\n+1,100,hello,200,300,400\n+2,500,world,600,700,800\n+3,900,\"hello, world\",1000,1100,1200\n ```\n+> if you have some special characters like comma in your field, the field should be enclosed by a double quote or single quote. for example, \"hello,\\\"great\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40b45a0fa86717ee53aac4e72e01996c34825fc5"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0ODMwNg==", "bodyText": "update", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r525648306", "createdAt": "2020-11-18T02:09:03Z", "author": {"login": "Genius-pig"}, "path": "README.md", "diffHunk": "@@ -347,14 +348,17 @@ CREATE TIMESERIES root.fit.d2.s3 WITH DATATYPE=INT32,ENCODING=RLE;\n CREATE TIMESERIES root.fit.p.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n ```\n \n+IoTDB has the ability of type inference, so it is not necessary to create metadata before data import. However, we still recommend creating metadata before importing data using the CSV import tool, as this can avoid unnecessary type conversion errors.\n+\n ### An example of import csv file\n \n ```\n Time,root.fit.d1.s1,root.fit.d1.s2,root.fit.d2.s1,root.fit.d2.s3,root.fit.p.s1\n-1,100,'hello',200,300,400\n-2,500,'world',600,700,800\n-3,900,'IoTDB',1000,1100,1200\n+1,100,hello,200,300,400\n+2,500,world,600,700,800\n+3,900,\"hello, world\",1000,1100,1200\n ```\n+> if you have some special characters like comma in your field, the field should be enclosed by a double quote or single quote. for example, \"hello,\\\"great\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE2NDczMA=="}, "originalCommit": {"oid": "40b45a0fa86717ee53aac4e72e01996c34825fc5"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5Mjc3MDkwOnYy", "diffSide": "RIGHT", "path": "README_ZH.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMzo0NToyN1rOH01iTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMzo0NToyN1rOH01iTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE2NTEzNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            3,900,IoTDB,1000,1100,1200\n          \n          \n            \n            3,900,\"hello, \\\"world\\\"\",1000,1100,1200", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r525165134", "createdAt": "2020-11-17T13:45:27Z", "author": {"login": "SteveYurongSu"}, "path": "README_ZH.md", "diffHunk": "@@ -347,16 +347,19 @@ CREATE TIMESERIES root.fit.d2.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n CREATE TIMESERIES root.fit.d2.s3 WITH DATATYPE=INT32,ENCODING=RLE;\n CREATE TIMESERIES root.fit.p.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n ```\n+IoTDB\u5177\u6709\u7c7b\u578b\u63a8\u65ad\u7684\u80fd\u529b\uff0c\u56e0\u6b64\u5728\u6570\u636e\u5bfc\u5165\u524d\u521b\u5efa\u5143\u6570\u636e\u4e0d\u662f\u5fc5\u987b\u7684\u3002\u4f46\u6211\u4eec\u4ecd\u7136\u63a8\u8350\u5728\u4f7f\u7528CSV\u5bfc\u5165\u5de5\u5177\u5bfc\u5165\u6570\u636e\u524d\u521b\u5efa\u5143\u6570\u636e\uff0c\u56e0\u4e3a\u8fd9\u53ef\u4ee5\u907f\u514d\u4e0d\u5fc5\u8981\u7684\u7c7b\u578b\u8f6c\u6362\u9519\u8bef\u3002\n \n ### \u4ece csv \u6587\u4ef6\u5bfc\u5165\u6570\u636e\u7684\u793a\u4f8b\n \n ```\n Time,root.fit.d1.s1,root.fit.d1.s2,root.fit.d2.s1,root.fit.d2.s3,root.fit.p.s1\n-1,100,'hello',200,300,400\n-2,500,'world',600,700,800\n-3,900,'IoTDB',1000,1100,1200\n+1,100,hello,200,300,400\n+2,500,world,600,700,800\n+3,900,IoTDB,1000,1100,1200", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40b45a0fa86717ee53aac4e72e01996c34825fc5"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjgwNjY5OnYy", "diffSide": "RIGHT", "path": "README_ZH.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMzo1Mzo0NVrOH015Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwMjowOToxNlrOH1TB-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE3MDk5OQ==", "bodyText": "\u6ce8\u610f\uff0c\u5728\u5bfc\u5165\u6570\u636e\u524d\uff0c\u9700\u8981\u7279\u6b8a\u5904\u7406\u4e0b\u5217\u7684\u5b57\u7b26\uff1a\n\n, : \u5305\u542b,\u7684\u5b57\u6bb5\u9700\u8981\u4f7f\u7528\u5355\u5f15\u53f7\u6216\u8005\u53cc\u5f15\u53f7\u62ec\u8d77\u6765\n\" : \"\u5b57\u6bb5\u4e2d\u7684\"\u9700\u8981\u88ab\u66ff\u6362\u6210\u8f6c\u4e49\u5b57\u7b26\\\"\n' : \"\u5b57\u6bb5\u4e2d\u7684'\u9700\u8981\u88ab\u66ff\u6362\u6210\u8f6c\u4e49\u5b57\u7b26\\'", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r525170999", "createdAt": "2020-11-17T13:53:45Z", "author": {"login": "SteveYurongSu"}, "path": "README_ZH.md", "diffHunk": "@@ -347,16 +347,19 @@ CREATE TIMESERIES root.fit.d2.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n CREATE TIMESERIES root.fit.d2.s3 WITH DATATYPE=INT32,ENCODING=RLE;\n CREATE TIMESERIES root.fit.p.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n ```\n+IoTDB\u5177\u6709\u7c7b\u578b\u63a8\u65ad\u7684\u80fd\u529b\uff0c\u56e0\u6b64\u5728\u6570\u636e\u5bfc\u5165\u524d\u521b\u5efa\u5143\u6570\u636e\u4e0d\u662f\u5fc5\u987b\u7684\u3002\u4f46\u6211\u4eec\u4ecd\u7136\u63a8\u8350\u5728\u4f7f\u7528CSV\u5bfc\u5165\u5de5\u5177\u5bfc\u5165\u6570\u636e\u524d\u521b\u5efa\u5143\u6570\u636e\uff0c\u56e0\u4e3a\u8fd9\u53ef\u4ee5\u907f\u514d\u4e0d\u5fc5\u8981\u7684\u7c7b\u578b\u8f6c\u6362\u9519\u8bef\u3002\n \n ### \u4ece csv \u6587\u4ef6\u5bfc\u5165\u6570\u636e\u7684\u793a\u4f8b\n \n ```\n Time,root.fit.d1.s1,root.fit.d1.s2,root.fit.d2.s1,root.fit.d2.s3,root.fit.p.s1\n-1,100,'hello',200,300,400\n-2,500,'world',600,700,800\n-3,900,'IoTDB',1000,1100,1200\n+1,100,hello,200,300,400\n+2,500,world,600,700,800\n+3,900,IoTDB,1000,1100,1200\n ```\n \n+> \u5982\u679c\u5b57\u6bb5\u4e2d\u6709\u4e00\u4e9b\u7279\u6b8a\u5b57\u7b26\uff0c\u5982\u9017\u53f7\uff0c\u5b57\u6bb5\u5e94\u8be5\u7528\u53cc\u5f15\u53f7\u6216\u5355\u5f15\u53f7\u62ec\u8d77\u6765\u3002\u4f8b\u5982, \"hello,\\\"great\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40b45a0fa86717ee53aac4e72e01996c34825fc5"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0ODM3OA==", "bodyText": "update", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r525648378", "createdAt": "2020-11-18T02:09:16Z", "author": {"login": "Genius-pig"}, "path": "README_ZH.md", "diffHunk": "@@ -347,16 +347,19 @@ CREATE TIMESERIES root.fit.d2.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n CREATE TIMESERIES root.fit.d2.s3 WITH DATATYPE=INT32,ENCODING=RLE;\n CREATE TIMESERIES root.fit.p.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n ```\n+IoTDB\u5177\u6709\u7c7b\u578b\u63a8\u65ad\u7684\u80fd\u529b\uff0c\u56e0\u6b64\u5728\u6570\u636e\u5bfc\u5165\u524d\u521b\u5efa\u5143\u6570\u636e\u4e0d\u662f\u5fc5\u987b\u7684\u3002\u4f46\u6211\u4eec\u4ecd\u7136\u63a8\u8350\u5728\u4f7f\u7528CSV\u5bfc\u5165\u5de5\u5177\u5bfc\u5165\u6570\u636e\u524d\u521b\u5efa\u5143\u6570\u636e\uff0c\u56e0\u4e3a\u8fd9\u53ef\u4ee5\u907f\u514d\u4e0d\u5fc5\u8981\u7684\u7c7b\u578b\u8f6c\u6362\u9519\u8bef\u3002\n \n ### \u4ece csv \u6587\u4ef6\u5bfc\u5165\u6570\u636e\u7684\u793a\u4f8b\n \n ```\n Time,root.fit.d1.s1,root.fit.d1.s2,root.fit.d2.s1,root.fit.d2.s3,root.fit.p.s1\n-1,100,'hello',200,300,400\n-2,500,'world',600,700,800\n-3,900,'IoTDB',1000,1100,1200\n+1,100,hello,200,300,400\n+2,500,world,600,700,800\n+3,900,IoTDB,1000,1100,1200\n ```\n \n+> \u5982\u679c\u5b57\u6bb5\u4e2d\u6709\u4e00\u4e9b\u7279\u6b8a\u5b57\u7b26\uff0c\u5982\u9017\u53f7\uff0c\u5b57\u6bb5\u5e94\u8be5\u7528\u53cc\u5f15\u53f7\u6216\u5355\u5f15\u53f7\u62ec\u8d77\u6765\u3002\u4f8b\u5982, \"hello,\\\"great\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE3MDk5OQ=="}, "originalCommit": {"oid": "40b45a0fa86717ee53aac4e72e01996c34825fc5"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MzEwMTA2OnYy", "diffSide": "RIGHT", "path": "cli/src/test/java/org/apache/iotdb/tool/CsvLineSplitTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNDo1NDo0NlrOH04tvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwMjowOToyM1rOH1TCHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTIxNzIxMg==", "bodyText": "Please indicate in the document that \"\" is also a special character...", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r525217212", "createdAt": "2020-11-17T14:54:46Z", "author": {"login": "SteveYurongSu"}, "path": "cli/src/test/java/org/apache/iotdb/tool/CsvLineSplitTest.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.tool;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class CsvLineSplitTest {\n+\n+  @Test\n+  public void testSplit() {\n+    Assert.assertArrayEquals(new String[]{\"\", \"a\", \"b\", \"c\", \"\\\\\\\"\"}, ImportCsv.splitCsvLine(\",a,b,c,\\\"\\\\\\\"\\\"\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40b45a0fa86717ee53aac4e72e01996c34825fc5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0ODQxNA==", "bodyText": "update", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r525648414", "createdAt": "2020-11-18T02:09:23Z", "author": {"login": "Genius-pig"}, "path": "cli/src/test/java/org/apache/iotdb/tool/CsvLineSplitTest.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.tool;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class CsvLineSplitTest {\n+\n+  @Test\n+  public void testSplit() {\n+    Assert.assertArrayEquals(new String[]{\"\", \"a\", \"b\", \"c\", \"\\\\\\\"\"}, ImportCsv.splitCsvLine(\",a,b,c,\\\"\\\\\\\"\\\"\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTIxNzIxMg=="}, "originalCommit": {"oid": "40b45a0fa86717ee53aac4e72e01996c34825fc5"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MzIyNzkxOnYy", "diffSide": "RIGHT", "path": "cli/src/main/java/org/apache/iotdb/tool/ImportCsv.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNToxODoxN1rOH0560w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNToxODoxN1rOH0560w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTIzNjk0Nw==", "bodyText": "I think there may be a problem when importing millions of records at a time...", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r525236947", "createdAt": "2020-11-17T15:18:17Z", "author": {"login": "SteveYurongSu"}, "path": "cli/src/main/java/org/apache/iotdb/tool/ImportCsv.java", "diffHunk": "@@ -119,296 +88,78 @@ private static Options createOptions() {\n   /**\n    * Data from csv To tsfile.\n    */\n-  private static void loadDataFromCSV(File file, int index) {\n-    statement = null;\n+  private static void loadDataFromCSV(File file) {\n     int fileLine;\n     try {\n       fileLine = getFileLineCount(file);\n     } catch (IOException e) {\n       System.out.println(\"Failed to import file: \" + file.getName());\n       return;\n     }\n-    File errorFile = new File(errorInsertInfo + index);\n-    if (!errorFile.exists()) {\n-      try {\n-        errorFile.createNewFile();\n-      } catch (IOException e) {\n-        System.out.println(\"Cannot create a errorFile because: \" + e.getMessage());\n-        return;\n-      }\n-    }\n     System.out.println(\"Start to import data from: \" + file.getName());\n-    errorFlag = true;\n     try(BufferedReader br = new BufferedReader(new FileReader(file));\n-        BufferedWriter bw = new BufferedWriter(new FileWriter(errorFile));\n         ProgressBar pb = new ProgressBar(\"Import from: \" + file.getName(), fileLine)) {\n       pb.setExtraMessage(\"Importing...\");\n       String header = br.readLine();\n-\n-      bw.write(\"From \" + file.getAbsolutePath());\n-      bw.newLine();\n-      bw.newLine();\n-      bw.write(header);\n-      bw.newLine();\n-      bw.newLine();\n-\n-      // storage csv table head info\n-      Map<String, ArrayList<Integer>> deviceToColumn = new HashMap<>();\n-      // storage csv table head info\n-      List<String> colInfo = new ArrayList<>();\n-      // storage csv device sensor info, corresponding csv table head\n-      List<String> headInfo = new ArrayList<>();\n-\n-      String[] strHeadInfo = header.split(\",\");\n-      if (strHeadInfo.length <= 1) {\n+      String[] cols = splitCsvLine(header);\n+      if (cols.length <= 1) {\n         System.out.println(\"The CSV file \"+ file.getName() +\" illegal, please check first line\");\n         return;\n       }\n \n-      long startTime = System.currentTimeMillis();\n-      Map<String, String> timeseriesDataType = new HashMap<>();\n+      List<String> devices = new ArrayList<>();\n+      List<Long> times = new ArrayList<>();\n+      List<List<String>> measurementsList = new ArrayList<>();\n+      List<List<String>> valuesList = new ArrayList<>();\n+      Map<String, Map<String, Integer>> devicesToMeasurementsAndPositions = new HashMap<>();\n \n-      boolean success = queryDatabaseMeta(strHeadInfo, file, bw, timeseriesDataType, headInfo,\n-          deviceToColumn, colInfo);\n-      if (!success) {\n-        errorFlag = false;\n-        return;\n+      for(int i = 1; i < cols.length; i++) {\n+        splitColToDeviceAndMeasurement(cols[i], devicesToMeasurementsAndPositions, i);\n       }\n \n-      statement = connection.createStatement();\n-\n-\n-      List<String> tmp = new ArrayList<>();\n-      success = readAndGenSqls(br, timeseriesDataType, deviceToColumn, colInfo, headInfo,\n-          bw, tmp, pb);\n-      if (!success) {\n-        return;\n+      String line;\n+      while((line = br.readLine()) != null) {\n+        cols = splitCsvLine(line);\n+        for(Entry<String, Map<String, Integer>> deviceToMeasurementsAndPositions: devicesToMeasurementsAndPositions.entrySet()) {\n+          devices.add(deviceToMeasurementsAndPositions.getKey());\n+          times.add(Long.parseLong(cols[0]));\n+          Map<String, Integer> measurementsAndPositions = deviceToMeasurementsAndPositions.getValue();\n+          List<String> measurements = new ArrayList<>();\n+          List<String> values = new ArrayList<>();\n+          for(Entry<String, Integer> measurementAndPosition : measurementsAndPositions.entrySet()) {\n+            measurements.add(measurementAndPosition.getKey());\n+            if(cols[measurementAndPosition.getValue()].equals(\"\") && cols[measurementAndPosition.getValue()].equals(\"null\")) {\n+              values.add(null);\n+            } else {\n+              values.add(cols[measurementAndPosition.getValue()]);\n+            }\n+          }\n+          measurementsList.add(measurements);\n+          valuesList.add(values);\n+        }\n       }\n-\n-      executeSqls(bw, tmp, startTime, file);\n+      session.insertRecords(devices, times, measurementsList, valuesList);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40b45a0fa86717ee53aac4e72e01996c34825fc5"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMjc3ODQ1OnYy", "diffSide": "RIGHT", "path": "cross-tests/src/test/java/org/apache/iotdb/cross/tests/tools/importCsv/ExportCsvTestIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMDozNTo1MFrOH2WtEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNDozNzo0OVrOH2hoPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1NzEzNg==", "bodyText": "Tests about '?", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r526757136", "createdAt": "2020-11-19T10:35:50Z", "author": {"login": "SteveYurongSu"}, "path": "cross-tests/src/test/java/org/apache/iotdb/cross/tests/tools/importCsv/ExportCsvTestIT.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cross.tests.tools.importCsv;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.db.utils.EnvironmentUtils;\n+import org.apache.iotdb.rpc.IoTDBConnectionException;\n+import org.apache.iotdb.rpc.StatementExecutionException;\n+import org.apache.iotdb.session.Session;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ExportCsvTestIT extends AbstractScript{\n+\n+  private final String SQL_FILE = \"target\" + File.separator + \"sql.txt\";\n+\n+  private final String EXPORT_FILE = \"target\" + File.separator + \"dump0.csv\";\n+\n+  @Before\n+  public void setUp() {\n+    EnvironmentUtils.closeStatMonitor();\n+    EnvironmentUtils.envSetUp();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    EnvironmentUtils.cleanEnv();\n+  }\n+\n+  @Override\n+  protected void testOnWindows() throws IOException {\n+    final String[] output = {\n+            \"------------------------------------------\",\n+            \"Starting IoTDB Client Export Script\",\n+            \"------------------------------------------\",\n+            \"Start to export data from sql statement\",\n+            \"successfully\",\n+    };\n+    String dir = getCliPath();\n+    ProcessBuilder builder = new ProcessBuilder(\"cmd.exe\", \"/c\",\n+        dir + File.separator + \"tools\" + File.separator + \"export-csv.bat\",\n+        \"-h\", \"127.0.0.1\", \"-p\", \"6667\", \"-u\", \"root\", \"-pw\", \"root\", \"-td\", \"./target\",\n+        \"-s\", SQL_FILE);\n+    testOutput(builder, output);\n+  }\n+\n+  @Override\n+  protected void testOnUnix() throws IOException {\n+    final String[] output = {\n+        \"------------------------------------------\",\n+        \"Starting IoTDB Client Export Script\",\n+        \"------------------------------------------\",\n+        \"Start to export data from sql statement\",\n+        \"successfully\",\n+    };\n+    String dir = getCliPath();\n+    ProcessBuilder builder = new ProcessBuilder(\"sh\",\n+        dir + File.separator + \"tools\" + File.separator + \"export-csv.sh\",\n+        \"-h\", \"127.0.0.1\", \"-p\", \"6667\", \"-u\", \"root\", \"-pw\", \"root\", \"-td\", \"./target\",\n+        \"-s\", SQL_FILE);\n+    testOutput(builder, output);\n+  }\n+\n+  private boolean generateSQLFile(String[] sql) {\n+    BufferedWriter writer;\n+    try {\n+      writer = new BufferedWriter(new FileWriter(SQL_FILE));\n+      writer.write(\"\");\n+      for (String s : sql) {\n+        writer.write(s);\n+        writer.newLine();\n+      }\n+      writer.flush();\n+      writer.close();\n+      return true;\n+    } catch (IOException e) {\n+      System.out.println(\"failed to create test csv\");\n+    }\n+    return false;\n+  }\n+\n+  @Test\n+  public void testRawDataQuery() throws IOException, StatementExecutionException, IoTDBConnectionException {\n+    final String[] expectCsv = new String[]{\"Time,root.sg1.d1.s1,root.sg1.d1.s2\",\n+        \"1.0,'abc\\\",aa'\"};\n+    prepareData();\n+    String os = System.getProperty(\"os.name\").toLowerCase();\n+    String[] sql = {\"select * from root\"};\n+    assertTrue(generateSQLFile(sql));\n+    if (os.startsWith(\"windows\")) {\n+      testOnWindows();\n+    } else {\n+      testOnUnix();\n+    }\n+    FileReader fileReader = new FileReader(EXPORT_FILE);\n+    BufferedReader br = new BufferedReader(fileReader);\n+    String line = br.readLine();\n+    int i = 0;\n+    while(line != null) {\n+      if(i == 0) {\n+        assertEquals(expectCsv[i], line);\n+      } else {\n+        String lineWithoutTime = line.substring(line.indexOf(',') + 1);\n+        assertEquals(expectCsv[i], lineWithoutTime);\n+      }\n+      i++;\n+      line = br.readLine();\n+    }\n+    File file = new File(EXPORT_FILE);\n+    if (file.exists()) {\n+      file.delete();\n+    }\n+  }\n+\n+  @Test\n+  public void testAggregationQuery() throws StatementExecutionException, IoTDBConnectionException, IOException {\n+    final String[] expectCsv = new String[]{\"Time,count(root.sg1.d1.s1),count(root.sg1.d1.s2)\",\n+            \"1,1\"};\n+    prepareData();\n+    String os = System.getProperty(\"os.name\").toLowerCase();\n+    String[] sql = {\"select count(*) from root\"};\n+    generateSQLFile(sql);\n+    if (os.startsWith(\"windows\")) {\n+      testOnWindows();\n+    } else {\n+      testOnUnix();\n+    }\n+    FileReader fileReader = new FileReader(EXPORT_FILE);\n+    BufferedReader br = new BufferedReader(fileReader);\n+    String line = br.readLine();\n+    int i = 0;\n+    while(line != null) {\n+      if(i == 0) {\n+        assertEquals(expectCsv[i], line);\n+      } else {\n+        String lineWithoutTime = line.substring(line.indexOf(',') + 1);\n+        assertEquals(expectCsv[i], lineWithoutTime);\n+      }\n+      i++;\n+      line = br.readLine();\n+    }\n+    File file = new File(EXPORT_FILE);\n+    if (file.exists()) {\n+      file.delete();\n+    }\n+  }\n+\n+  private void prepareData() throws IoTDBConnectionException, StatementExecutionException {\n+    Session session = new Session(\"127.0.0.1\", 6667, \"root\", \"root\");\n+    session.open();\n+\n+    String deviceId = \"root.sg1.d1\";\n+    List<String> measurements = new ArrayList<>();\n+    measurements.add(\"s1\");\n+    measurements.add(\"s2\");\n+\n+    List<String> values = new ArrayList<>();\n+    values.add(\"1.0\");\n+    values.add(\"abc\\\",aa\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "756ee0d3c9cac348680c167f4da64c9fe417a2f3"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjkzNjEyNw==", "bodyText": "add", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r526936127", "createdAt": "2020-11-19T14:37:49Z", "author": {"login": "Genius-pig"}, "path": "cross-tests/src/test/java/org/apache/iotdb/cross/tests/tools/importCsv/ExportCsvTestIT.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cross.tests.tools.importCsv;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.db.utils.EnvironmentUtils;\n+import org.apache.iotdb.rpc.IoTDBConnectionException;\n+import org.apache.iotdb.rpc.StatementExecutionException;\n+import org.apache.iotdb.session.Session;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ExportCsvTestIT extends AbstractScript{\n+\n+  private final String SQL_FILE = \"target\" + File.separator + \"sql.txt\";\n+\n+  private final String EXPORT_FILE = \"target\" + File.separator + \"dump0.csv\";\n+\n+  @Before\n+  public void setUp() {\n+    EnvironmentUtils.closeStatMonitor();\n+    EnvironmentUtils.envSetUp();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    EnvironmentUtils.cleanEnv();\n+  }\n+\n+  @Override\n+  protected void testOnWindows() throws IOException {\n+    final String[] output = {\n+            \"------------------------------------------\",\n+            \"Starting IoTDB Client Export Script\",\n+            \"------------------------------------------\",\n+            \"Start to export data from sql statement\",\n+            \"successfully\",\n+    };\n+    String dir = getCliPath();\n+    ProcessBuilder builder = new ProcessBuilder(\"cmd.exe\", \"/c\",\n+        dir + File.separator + \"tools\" + File.separator + \"export-csv.bat\",\n+        \"-h\", \"127.0.0.1\", \"-p\", \"6667\", \"-u\", \"root\", \"-pw\", \"root\", \"-td\", \"./target\",\n+        \"-s\", SQL_FILE);\n+    testOutput(builder, output);\n+  }\n+\n+  @Override\n+  protected void testOnUnix() throws IOException {\n+    final String[] output = {\n+        \"------------------------------------------\",\n+        \"Starting IoTDB Client Export Script\",\n+        \"------------------------------------------\",\n+        \"Start to export data from sql statement\",\n+        \"successfully\",\n+    };\n+    String dir = getCliPath();\n+    ProcessBuilder builder = new ProcessBuilder(\"sh\",\n+        dir + File.separator + \"tools\" + File.separator + \"export-csv.sh\",\n+        \"-h\", \"127.0.0.1\", \"-p\", \"6667\", \"-u\", \"root\", \"-pw\", \"root\", \"-td\", \"./target\",\n+        \"-s\", SQL_FILE);\n+    testOutput(builder, output);\n+  }\n+\n+  private boolean generateSQLFile(String[] sql) {\n+    BufferedWriter writer;\n+    try {\n+      writer = new BufferedWriter(new FileWriter(SQL_FILE));\n+      writer.write(\"\");\n+      for (String s : sql) {\n+        writer.write(s);\n+        writer.newLine();\n+      }\n+      writer.flush();\n+      writer.close();\n+      return true;\n+    } catch (IOException e) {\n+      System.out.println(\"failed to create test csv\");\n+    }\n+    return false;\n+  }\n+\n+  @Test\n+  public void testRawDataQuery() throws IOException, StatementExecutionException, IoTDBConnectionException {\n+    final String[] expectCsv = new String[]{\"Time,root.sg1.d1.s1,root.sg1.d1.s2\",\n+        \"1.0,'abc\\\",aa'\"};\n+    prepareData();\n+    String os = System.getProperty(\"os.name\").toLowerCase();\n+    String[] sql = {\"select * from root\"};\n+    assertTrue(generateSQLFile(sql));\n+    if (os.startsWith(\"windows\")) {\n+      testOnWindows();\n+    } else {\n+      testOnUnix();\n+    }\n+    FileReader fileReader = new FileReader(EXPORT_FILE);\n+    BufferedReader br = new BufferedReader(fileReader);\n+    String line = br.readLine();\n+    int i = 0;\n+    while(line != null) {\n+      if(i == 0) {\n+        assertEquals(expectCsv[i], line);\n+      } else {\n+        String lineWithoutTime = line.substring(line.indexOf(',') + 1);\n+        assertEquals(expectCsv[i], lineWithoutTime);\n+      }\n+      i++;\n+      line = br.readLine();\n+    }\n+    File file = new File(EXPORT_FILE);\n+    if (file.exists()) {\n+      file.delete();\n+    }\n+  }\n+\n+  @Test\n+  public void testAggregationQuery() throws StatementExecutionException, IoTDBConnectionException, IOException {\n+    final String[] expectCsv = new String[]{\"Time,count(root.sg1.d1.s1),count(root.sg1.d1.s2)\",\n+            \"1,1\"};\n+    prepareData();\n+    String os = System.getProperty(\"os.name\").toLowerCase();\n+    String[] sql = {\"select count(*) from root\"};\n+    generateSQLFile(sql);\n+    if (os.startsWith(\"windows\")) {\n+      testOnWindows();\n+    } else {\n+      testOnUnix();\n+    }\n+    FileReader fileReader = new FileReader(EXPORT_FILE);\n+    BufferedReader br = new BufferedReader(fileReader);\n+    String line = br.readLine();\n+    int i = 0;\n+    while(line != null) {\n+      if(i == 0) {\n+        assertEquals(expectCsv[i], line);\n+      } else {\n+        String lineWithoutTime = line.substring(line.indexOf(',') + 1);\n+        assertEquals(expectCsv[i], lineWithoutTime);\n+      }\n+      i++;\n+      line = br.readLine();\n+    }\n+    File file = new File(EXPORT_FILE);\n+    if (file.exists()) {\n+      file.delete();\n+    }\n+  }\n+\n+  private void prepareData() throws IoTDBConnectionException, StatementExecutionException {\n+    Session session = new Session(\"127.0.0.1\", 6667, \"root\", \"root\");\n+    session.open();\n+\n+    String deviceId = \"root.sg1.d1\";\n+    List<String> measurements = new ArrayList<>();\n+    measurements.add(\"s1\");\n+    measurements.add(\"s2\");\n+\n+    List<String> values = new ArrayList<>();\n+    values.add(\"1.0\");\n+    values.add(\"abc\\\",aa\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1NzEzNg=="}, "originalCommit": {"oid": "756ee0d3c9cac348680c167f4da64c9fe417a2f3"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMzI2MDk1OnYy", "diffSide": "RIGHT", "path": "README_ZH.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjoyNToxMFrOH2bZqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjoyNToxMFrOH2bZqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzNDA5MQ==", "bodyText": "This is a broken link...", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r526834091", "createdAt": "2020-11-19T12:25:10Z", "author": {"login": "SteveYurongSu"}, "path": "README_ZH.md", "diffHunk": "@@ -333,61 +331,9 @@ server \u53ef\u4ee5\u4f7f\u7528 \"ctrl-C\" \u6216\u8005\u6267\u884c\u4e0b\u9762\u7684\u811a\u672c:\n \n \u7f16\u8bd1\u5b8c\u6210\u540e, IoTDB cli \u5c06\u751f\u6210\u5728 \"cli/target/iotdb-cli-{project.version}\".\n \n-## \u4f7f\u7528 import-csv.sh\n-\n-### \u521b\u5efa\u5143\u6570\u636e\n-\n-```\n-SET STORAGE GROUP TO root.fit.d1;\n-SET STORAGE GROUP TO root.fit.d2;\n-SET STORAGE GROUP TO root.fit.p;\n-CREATE TIMESERIES root.fit.d1.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n-CREATE TIMESERIES root.fit.d1.s2 WITH DATATYPE=TEXT,ENCODING=PLAIN;\n-CREATE TIMESERIES root.fit.d2.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n-CREATE TIMESERIES root.fit.d2.s3 WITH DATATYPE=INT32,ENCODING=RLE;\n-CREATE TIMESERIES root.fit.p.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n-```\n-\n-### \u4ece csv \u6587\u4ef6\u5bfc\u5165\u6570\u636e\u7684\u793a\u4f8b\n-\n-```\n-Time,root.fit.d1.s1,root.fit.d1.s2,root.fit.d2.s1,root.fit.d2.s3,root.fit.p.s1\n-1,100,'hello',200,300,400\n-2,500,'world',600,700,800\n-3,900,'IoTDB',1000,1100,1200\n-```\n-\n-### \u8fd0\u884c import shell\n-```\n-# Unix/OS X\n-> tools/import-csv.sh -h <ip> -p <port> -u <username> -pw <password> -f <xxx.csv>\n-\n-# Windows\n-> tools\\import-csv.bat -h <ip> -p <port> -u <username> -pw <password> -f <xxx.csv>\n-```\n-\n-### \u9519\u8bef\u7684\u6570\u636e\u6587\u4ef6\n-\n-`csvInsertError.error`\n-\n-## \u4f7f\u7528 export-csv.sh\n-\n-### \u8fd0\u884c export shell\n-\n-```\n-# Unix/OS X\n-> tools/export-csv.sh -h <ip> -p <port> -u <username> -pw <password> -td <directory> [-tf <time-format>]\n-\n-# Windows\n-> tools\\export-csv.bat -h <ip> -p <port> -u <username> -pw <password> -td <directory> [-tf <time-format>]\n-```\n-\n-### \u6267\u884c\u67e5\u8be2\n-\n-```\n-select * from root.fit.d1\n-```\n+# \u5bfc\u5165\u5bfc\u51faCSV\u5de5\u5177\n \n+\u67e5\u770b [\u5bfc\u5165\u5bfc\u51faCSV\u5de5\u5177](docs/zh/UserGuide/System Tools/CSV Tool.md)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fac00b7abb398a1f9b4de8dd91876cbbbbda4b1b"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMzI2MzQ1OnYy", "diffSide": "RIGHT", "path": "README.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjoyNTo0NlrOH2bbHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjoyNTo0NlrOH2bbHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzNDQ2MA==", "bodyText": "This is a broken link...", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r526834460", "createdAt": "2020-11-19T12:25:46Z", "author": {"login": "SteveYurongSu"}, "path": "README.md", "diffHunk": "@@ -333,59 +326,9 @@ Under the root path of iotdb:\n \n After being built, the IoTDB cli is located at the folder \"cli/target/iotdb-cli-{project.version}\".\n \n-## Usage of import-csv.sh\n-\n-### Create metadata\n-```\n-SET STORAGE GROUP TO root.fit.d1;\n-SET STORAGE GROUP TO root.fit.d2;\n-SET STORAGE GROUP TO root.fit.p;\n-CREATE TIMESERIES root.fit.d1.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n-CREATE TIMESERIES root.fit.d1.s2 WITH DATATYPE=TEXT,ENCODING=PLAIN;\n-CREATE TIMESERIES root.fit.d2.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n-CREATE TIMESERIES root.fit.d2.s3 WITH DATATYPE=INT32,ENCODING=RLE;\n-CREATE TIMESERIES root.fit.p.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n-```\n-\n-### An example of import csv file\n-\n-```\n-Time,root.fit.d1.s1,root.fit.d1.s2,root.fit.d2.s1,root.fit.d2.s3,root.fit.p.s1\n-1,100,'hello',200,300,400\n-2,500,'world',600,700,800\n-3,900,'IoTDB',1000,1100,1200\n-```\n-\n-### Run import shell\n-```\n-# Unix/OS X\n-> tools/import-csv.sh -h <ip> -p <port> -u <username> -pw <password> -f <xxx.csv>\n-\n-# Windows\n-> tools\\import-csv.bat -h <ip> -p <port> -u <username> -pw <password> -f <xxx.csv>\n-```\n-\n-### Error data file\n-\n-`csvInsertError.error`\n-\n-## Usage of export-csv.sh\n-\n-### Run export shell\n-```\n-# Unix/OS X\n-> tools/export-csv.sh -h <ip> -p <port> -u <username> -pw <password> -td <directory> [-tf <time-format>]\n-\n-# Windows\n-> tools\\export-csv.bat -h <ip> -p <port> -u <username> -pw <password> -td <directory> [-tf <time-format>]\n-```\n-\n-### Input query\n-\n-```\n-select * from root.fit.d1\n-```\n+# Usage of CSV Import and Export Tool\n \n+see [Usage of CSV Import and Export Tool](docs/UserGuide/System Tools/CSV Tool.md)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fac00b7abb398a1f9b4de8dd91876cbbbbda4b1b"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMzI2OTQ5OnYy", "diffSide": "RIGHT", "path": "README_ZH.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjoyNzoxMVrOH2befA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjoyNzoxMVrOH2befA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzNTMyNA==", "bodyText": "Remove \"\u4f7f\u7528 import-csv.sh\" please.", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r526835324", "createdAt": "2020-11-19T12:27:11Z", "author": {"login": "SteveYurongSu"}, "path": "README_ZH.md", "diffHunk": "@@ -75,9 +75,7 @@ IoTDB\u7684\u4e3b\u8981\u7279\u70b9\u5982\u4e0b:\n     - [\u4ece csv \u6587\u4ef6\u5bfc\u5165\u6570\u636e\u7684\u793a\u4f8b](#\u4ece-csv-\u6587\u4ef6\u5bfc\u5165\u6570\u636e\u7684\u793a\u4f8b)\n     - [\u8fd0\u884c import shell](#\u8fd0\u884c-import-shell)\n     - [\u9519\u8bef\u7684\u6570\u636e\u6587\u4ef6](#\u9519\u8bef\u7684\u6570\u636e\u6587\u4ef6)\n-  - [\u4f7f\u7528 export-csv.sh](#\u4f7f\u7528-export-csvsh)\n-    - [\u8fd0\u884c export shell](#\u8fd0\u884c-export-shell)\n-    - [\u6267\u884c\u67e5\u8be2](#\u6267\u884c\u67e5\u8be2)\n+  - [\u5bfc\u5165\u5bfc\u51faCSV\u5de5\u5177](#\u5bfc\u5165\u5bfc\u51faCSV\u5de5\u5177)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fac00b7abb398a1f9b4de8dd91876cbbbbda4b1b"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMzI3MDc0OnYy", "diffSide": "RIGHT", "path": "README.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjoyNzozNVrOH2bfTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjoyNzozNVrOH2bfTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzNTUzMg==", "bodyText": "This is a broken link.", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r526835532", "createdAt": "2020-11-19T12:27:35Z", "author": {"login": "SteveYurongSu"}, "path": "README.md", "diffHunk": "@@ -333,59 +326,9 @@ Under the root path of iotdb:\n \n After being built, the IoTDB cli is located at the folder \"cli/target/iotdb-cli-{project.version}\".\n \n-## Usage of import-csv.sh\n-\n-### Create metadata\n-```\n-SET STORAGE GROUP TO root.fit.d1;\n-SET STORAGE GROUP TO root.fit.d2;\n-SET STORAGE GROUP TO root.fit.p;\n-CREATE TIMESERIES root.fit.d1.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n-CREATE TIMESERIES root.fit.d1.s2 WITH DATATYPE=TEXT,ENCODING=PLAIN;\n-CREATE TIMESERIES root.fit.d2.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n-CREATE TIMESERIES root.fit.d2.s3 WITH DATATYPE=INT32,ENCODING=RLE;\n-CREATE TIMESERIES root.fit.p.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n-```\n-\n-### An example of import csv file\n-\n-```\n-Time,root.fit.d1.s1,root.fit.d1.s2,root.fit.d2.s1,root.fit.d2.s3,root.fit.p.s1\n-1,100,'hello',200,300,400\n-2,500,'world',600,700,800\n-3,900,'IoTDB',1000,1100,1200\n-```\n-\n-### Run import shell\n-```\n-# Unix/OS X\n-> tools/import-csv.sh -h <ip> -p <port> -u <username> -pw <password> -f <xxx.csv>\n-\n-# Windows\n-> tools\\import-csv.bat -h <ip> -p <port> -u <username> -pw <password> -f <xxx.csv>\n-```\n-\n-### Error data file\n-\n-`csvInsertError.error`\n-\n-## Usage of export-csv.sh\n-\n-### Run export shell\n-```\n-# Unix/OS X\n-> tools/export-csv.sh -h <ip> -p <port> -u <username> -pw <password> -td <directory> [-tf <time-format>]\n-\n-# Windows\n-> tools\\export-csv.bat -h <ip> -p <port> -u <username> -pw <password> -td <directory> [-tf <time-format>]\n-```\n-\n-### Input query\n-\n-```\n-select * from root.fit.d1\n-```\n+# Usage of CSV Import and Export Tool\n \n+see [Usage of CSV Import and Export Tool](docs/UserGuide/System Tools/CSV Tool.md)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fac00b7abb398a1f9b4de8dd91876cbbbbda4b1b"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMzI3MTcyOnYy", "diffSide": "RIGHT", "path": "README_ZH.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjoyNzo1NFrOH2bf6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjoyNzo1NFrOH2bf6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzNTY4OA==", "bodyText": "This is a broken link.", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r526835688", "createdAt": "2020-11-19T12:27:54Z", "author": {"login": "SteveYurongSu"}, "path": "README_ZH.md", "diffHunk": "@@ -333,61 +331,9 @@ server \u53ef\u4ee5\u4f7f\u7528 \"ctrl-C\" \u6216\u8005\u6267\u884c\u4e0b\u9762\u7684\u811a\u672c:\n \n \u7f16\u8bd1\u5b8c\u6210\u540e, IoTDB cli \u5c06\u751f\u6210\u5728 \"cli/target/iotdb-cli-{project.version}\".\n \n-## \u4f7f\u7528 import-csv.sh\n-\n-### \u521b\u5efa\u5143\u6570\u636e\n-\n-```\n-SET STORAGE GROUP TO root.fit.d1;\n-SET STORAGE GROUP TO root.fit.d2;\n-SET STORAGE GROUP TO root.fit.p;\n-CREATE TIMESERIES root.fit.d1.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n-CREATE TIMESERIES root.fit.d1.s2 WITH DATATYPE=TEXT,ENCODING=PLAIN;\n-CREATE TIMESERIES root.fit.d2.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n-CREATE TIMESERIES root.fit.d2.s3 WITH DATATYPE=INT32,ENCODING=RLE;\n-CREATE TIMESERIES root.fit.p.s1 WITH DATATYPE=INT32,ENCODING=RLE;\n-```\n-\n-### \u4ece csv \u6587\u4ef6\u5bfc\u5165\u6570\u636e\u7684\u793a\u4f8b\n-\n-```\n-Time,root.fit.d1.s1,root.fit.d1.s2,root.fit.d2.s1,root.fit.d2.s3,root.fit.p.s1\n-1,100,'hello',200,300,400\n-2,500,'world',600,700,800\n-3,900,'IoTDB',1000,1100,1200\n-```\n-\n-### \u8fd0\u884c import shell\n-```\n-# Unix/OS X\n-> tools/import-csv.sh -h <ip> -p <port> -u <username> -pw <password> -f <xxx.csv>\n-\n-# Windows\n-> tools\\import-csv.bat -h <ip> -p <port> -u <username> -pw <password> -f <xxx.csv>\n-```\n-\n-### \u9519\u8bef\u7684\u6570\u636e\u6587\u4ef6\n-\n-`csvInsertError.error`\n-\n-## \u4f7f\u7528 export-csv.sh\n-\n-### \u8fd0\u884c export shell\n-\n-```\n-# Unix/OS X\n-> tools/export-csv.sh -h <ip> -p <port> -u <username> -pw <password> -td <directory> [-tf <time-format>]\n-\n-# Windows\n-> tools\\export-csv.bat -h <ip> -p <port> -u <username> -pw <password> -td <directory> [-tf <time-format>]\n-```\n-\n-### \u6267\u884c\u67e5\u8be2\n-\n-```\n-select * from root.fit.d1\n-```\n+# \u5bfc\u5165\u5bfc\u51faCSV\u5de5\u5177\n \n+\u67e5\u770b [\u5bfc\u5165\u5bfc\u51faCSV\u5de5\u5177](docs/zh/UserGuide/System Tools/CSV Tool.md)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fac00b7abb398a1f9b4de8dd91876cbbbbda4b1b"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMzM1NDg5OnYy", "diffSide": "RIGHT", "path": "cli/src/main/java/org/apache/iotdb/tool/ExportCsv.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjo0MDoxNVrOH2cVjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMzo1Njo1NFrOH2fyAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg0OTQyMQ==", "bodyText": "Note that location may equals to 0, which will cause Exception...", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r526849421", "createdAt": "2020-11-19T12:40:15Z", "author": {"login": "SteveYurongSu"}, "path": "cli/src/main/java/org/apache/iotdb/tool/ExportCsv.java", "diffHunk": "@@ -263,112 +228,123 @@ private static void dumpResult(String sql, int index)\n         return;\n       }\n     } catch (IOException e) {\n-      System.out.println(\"Cannot create dump file \" + path + \"because: \" + e.getMessage());\n+      System.out.println(\"Cannot create dump file \" + path + \" \" + \"because: \" + e.getMessage());\n       return;\n     }\n     System.out.println(\"Start to export data from sql statement: \" + sql);\n-    try (Statement statement = connection.createStatement();\n-        ResultSet rs = statement.executeQuery(sql);\n-        BufferedWriter bw = new BufferedWriter(new FileWriter(tf))) {\n-      ResultSetMetaData metadata = rs.getMetaData();\n+    try (BufferedWriter bw = new BufferedWriter(new FileWriter(tf))) {\n+      SessionDataSet sessionDataSet = session.executeQueryStatement(sql);\n       long startTime = System.currentTimeMillis();\n-\n-      int count = metadata.getColumnCount();\n       // write data in csv file\n-      writeMetadata(bw, count, metadata);\n+      writeMetadata(bw, sessionDataSet.getColumnNames());\n \n-      int line = writeResultSet(rs, bw, count);\n+      int line = writeResultSet(sessionDataSet, bw);\n       System.out\n-          .println(String.format(\"Statement [%s] has dumped to file %s successfully! It costs \"\n-                  + \"%dms to export %d lines.\", sql, path, System.currentTimeMillis() - startTime,\n-              line));\n-    } catch (IOException e) {\n+          .printf(\"Statement [%s] has dumped to file %s successfully! It costs \"\n+                  + \"%dms to export %d lines.%n\", sql, path, System.currentTimeMillis() - startTime,\n+              line);\n+    } catch (IOException | StatementExecutionException | IoTDBConnectionException e) {\n       System.out.println(\"Cannot dump result because: \" + e.getMessage());\n     }\n   }\n \n-  private static void writeMetadata(BufferedWriter bw, int count, ResultSetMetaData metadata)\n-      throws SQLException, IOException {\n-    for (int i = 1; i <= count; i++) {\n-      if (i < count) {\n-        bw.write(metadata.getColumnLabel(i) + \",\");\n-      } else {\n-        bw.write(metadata.getColumnLabel(i) + \"\\n\");\n-      }\n-      typeList.add(metadata.getColumnType(i));\n+  private static void writeMetadata(BufferedWriter bw, List<String> columnNames)\n+      throws IOException {\n+    if (!columnNames.get(0).equals(\"Time\")) {\n+      bw.write(\"Time\" + \",\");\n+    }\n+    for (int i = 0; i < columnNames.size() - 1; i++) {\n+      bw.write(columnNames.get(i) + \",\");\n     }\n+    bw.write(columnNames.get(columnNames.size() - 1) + \"\\n\");\n   }\n \n-  private static int writeResultSet(ResultSet rs, BufferedWriter bw, int count)\n-      throws SQLException, IOException {\n+  private static int writeResultSet(SessionDataSet rs, BufferedWriter bw)\n+      throws IOException, StatementExecutionException, IoTDBConnectionException {\n     int line = 0;\n     long timestamp = System.currentTimeMillis();\n-    while (rs.next()) {\n-      if (rs.getString(1) == null ||\n-          \"null\".equalsIgnoreCase(rs.getString(1))) {\n-        bw.write(\",\");\n-      } else {\n-        writeTime(rs, bw);\n-        writeValue(rs, count, bw);\n-      }\n+    while (rs.hasNext()) {\n+      RowRecord rowRecord = rs.next();\n+      List<Field> fields = rowRecord.getFields();\n+      writeTime(rowRecord.getTimestamp(), bw);\n+      writeValue(fields, bw);\n       line++;\n       if (line % EXPORT_PER_LINE_COUNT == 0) {\n         long tmp = System.currentTimeMillis();\n-        System.out.println(\n-            String.format(\"%d lines have been exported, it takes %dms\", line, (tmp - timestamp)));\n+        System.out.printf(\"%d lines have been exported, it takes %dms%n\", line, (tmp - timestamp));\n         timestamp = tmp;\n       }\n     }\n     return line;\n   }\n \n-  private static void writeTime(ResultSet rs, BufferedWriter bw) throws SQLException, IOException {\n+  private static void writeTime(Long time, BufferedWriter bw) throws IOException {\n     ZonedDateTime dateTime;\n+    String timestampPrecision = \"ms\";\n     switch (timeFormat) {\n       case \"default\":\n-        long timestamp = rs.getLong(1);\n         String str = AbstractCli\n-            .parseLongToDateWithPrecision(DateTimeFormatter.ISO_OFFSET_DATE_TIME, timestamp, zoneId,\n-                TIMESTAMP_PRECISION);\n+            .parseLongToDateWithPrecision(DateTimeFormatter.ISO_OFFSET_DATE_TIME, time, zoneId,\n+                timestampPrecision);\n         bw.write(str + \",\");\n         break;\n       case \"timestamp\":\n       case \"long\":\n       case \"nubmer\":\n-        bw.write(rs.getLong(1) + \",\");\n+        bw.write(time + \",\");\n         break;\n       default:\n-        dateTime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(rs.getLong(1)),\n+        dateTime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(time),\n             zoneId);\n         bw.write(dateTime.format(DateTimeFormatter.ofPattern(timeFormat)) + \",\");\n         break;\n     }\n   }\n \n   @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n-  private static void writeValue(ResultSet rs, int count, BufferedWriter bw)\n-      throws SQLException, IOException {\n-    for (int j = 2; j <= count; j++) {\n-      if (j < count) {\n-        if (\"null\".equals(rs.getString(j))) {\n-          bw.write(\",\");\n-        } else {\n-          if(typeList.get(j-1) == Types.VARCHAR) {\n-            bw.write(\"\\'\" + rs.getString(j) + \"\\'\"+ \",\");\n+  private static void writeValue(List<Field> fields, BufferedWriter bw) throws IOException {\n+    for (int j = 0; j < fields.size() - 1; j++) {\n+      String value = fields.get(j).getStringValue();\n+      if (\"null\".equalsIgnoreCase(value)) {\n+        bw.write(\",\");\n+      } else {\n+        if (fields.get(j).getDataType() == TSDataType.TEXT) {\n+          int location = value.indexOf(\"\\\"\");\n+          if (location > -1) {\n+            if (value.charAt(location - 1) != '\\\\') {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fac00b7abb398a1f9b4de8dd91876cbbbbda4b1b"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1ODExNg==", "bodyText": "And why we need this judgement?", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r526858116", "createdAt": "2020-11-19T12:54:43Z", "author": {"login": "SteveYurongSu"}, "path": "cli/src/main/java/org/apache/iotdb/tool/ExportCsv.java", "diffHunk": "@@ -263,112 +228,123 @@ private static void dumpResult(String sql, int index)\n         return;\n       }\n     } catch (IOException e) {\n-      System.out.println(\"Cannot create dump file \" + path + \"because: \" + e.getMessage());\n+      System.out.println(\"Cannot create dump file \" + path + \" \" + \"because: \" + e.getMessage());\n       return;\n     }\n     System.out.println(\"Start to export data from sql statement: \" + sql);\n-    try (Statement statement = connection.createStatement();\n-        ResultSet rs = statement.executeQuery(sql);\n-        BufferedWriter bw = new BufferedWriter(new FileWriter(tf))) {\n-      ResultSetMetaData metadata = rs.getMetaData();\n+    try (BufferedWriter bw = new BufferedWriter(new FileWriter(tf))) {\n+      SessionDataSet sessionDataSet = session.executeQueryStatement(sql);\n       long startTime = System.currentTimeMillis();\n-\n-      int count = metadata.getColumnCount();\n       // write data in csv file\n-      writeMetadata(bw, count, metadata);\n+      writeMetadata(bw, sessionDataSet.getColumnNames());\n \n-      int line = writeResultSet(rs, bw, count);\n+      int line = writeResultSet(sessionDataSet, bw);\n       System.out\n-          .println(String.format(\"Statement [%s] has dumped to file %s successfully! It costs \"\n-                  + \"%dms to export %d lines.\", sql, path, System.currentTimeMillis() - startTime,\n-              line));\n-    } catch (IOException e) {\n+          .printf(\"Statement [%s] has dumped to file %s successfully! It costs \"\n+                  + \"%dms to export %d lines.%n\", sql, path, System.currentTimeMillis() - startTime,\n+              line);\n+    } catch (IOException | StatementExecutionException | IoTDBConnectionException e) {\n       System.out.println(\"Cannot dump result because: \" + e.getMessage());\n     }\n   }\n \n-  private static void writeMetadata(BufferedWriter bw, int count, ResultSetMetaData metadata)\n-      throws SQLException, IOException {\n-    for (int i = 1; i <= count; i++) {\n-      if (i < count) {\n-        bw.write(metadata.getColumnLabel(i) + \",\");\n-      } else {\n-        bw.write(metadata.getColumnLabel(i) + \"\\n\");\n-      }\n-      typeList.add(metadata.getColumnType(i));\n+  private static void writeMetadata(BufferedWriter bw, List<String> columnNames)\n+      throws IOException {\n+    if (!columnNames.get(0).equals(\"Time\")) {\n+      bw.write(\"Time\" + \",\");\n+    }\n+    for (int i = 0; i < columnNames.size() - 1; i++) {\n+      bw.write(columnNames.get(i) + \",\");\n     }\n+    bw.write(columnNames.get(columnNames.size() - 1) + \"\\n\");\n   }\n \n-  private static int writeResultSet(ResultSet rs, BufferedWriter bw, int count)\n-      throws SQLException, IOException {\n+  private static int writeResultSet(SessionDataSet rs, BufferedWriter bw)\n+      throws IOException, StatementExecutionException, IoTDBConnectionException {\n     int line = 0;\n     long timestamp = System.currentTimeMillis();\n-    while (rs.next()) {\n-      if (rs.getString(1) == null ||\n-          \"null\".equalsIgnoreCase(rs.getString(1))) {\n-        bw.write(\",\");\n-      } else {\n-        writeTime(rs, bw);\n-        writeValue(rs, count, bw);\n-      }\n+    while (rs.hasNext()) {\n+      RowRecord rowRecord = rs.next();\n+      List<Field> fields = rowRecord.getFields();\n+      writeTime(rowRecord.getTimestamp(), bw);\n+      writeValue(fields, bw);\n       line++;\n       if (line % EXPORT_PER_LINE_COUNT == 0) {\n         long tmp = System.currentTimeMillis();\n-        System.out.println(\n-            String.format(\"%d lines have been exported, it takes %dms\", line, (tmp - timestamp)));\n+        System.out.printf(\"%d lines have been exported, it takes %dms%n\", line, (tmp - timestamp));\n         timestamp = tmp;\n       }\n     }\n     return line;\n   }\n \n-  private static void writeTime(ResultSet rs, BufferedWriter bw) throws SQLException, IOException {\n+  private static void writeTime(Long time, BufferedWriter bw) throws IOException {\n     ZonedDateTime dateTime;\n+    String timestampPrecision = \"ms\";\n     switch (timeFormat) {\n       case \"default\":\n-        long timestamp = rs.getLong(1);\n         String str = AbstractCli\n-            .parseLongToDateWithPrecision(DateTimeFormatter.ISO_OFFSET_DATE_TIME, timestamp, zoneId,\n-                TIMESTAMP_PRECISION);\n+            .parseLongToDateWithPrecision(DateTimeFormatter.ISO_OFFSET_DATE_TIME, time, zoneId,\n+                timestampPrecision);\n         bw.write(str + \",\");\n         break;\n       case \"timestamp\":\n       case \"long\":\n       case \"nubmer\":\n-        bw.write(rs.getLong(1) + \",\");\n+        bw.write(time + \",\");\n         break;\n       default:\n-        dateTime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(rs.getLong(1)),\n+        dateTime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(time),\n             zoneId);\n         bw.write(dateTime.format(DateTimeFormatter.ofPattern(timeFormat)) + \",\");\n         break;\n     }\n   }\n \n   @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n-  private static void writeValue(ResultSet rs, int count, BufferedWriter bw)\n-      throws SQLException, IOException {\n-    for (int j = 2; j <= count; j++) {\n-      if (j < count) {\n-        if (\"null\".equals(rs.getString(j))) {\n-          bw.write(\",\");\n-        } else {\n-          if(typeList.get(j-1) == Types.VARCHAR) {\n-            bw.write(\"\\'\" + rs.getString(j) + \"\\'\"+ \",\");\n+  private static void writeValue(List<Field> fields, BufferedWriter bw) throws IOException {\n+    for (int j = 0; j < fields.size() - 1; j++) {\n+      String value = fields.get(j).getStringValue();\n+      if (\"null\".equalsIgnoreCase(value)) {\n+        bw.write(\",\");\n+      } else {\n+        if (fields.get(j).getDataType() == TSDataType.TEXT) {\n+          int location = value.indexOf(\"\\\"\");\n+          if (location > -1) {\n+            if (value.charAt(location - 1) != '\\\\') {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg0OTQyMQ=="}, "originalCommit": {"oid": "fac00b7abb398a1f9b4de8dd91876cbbbbda4b1b"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjkwNTg1OA==", "bodyText": "because we need to know before  \", whether has a \"\".", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r526905858", "createdAt": "2020-11-19T13:56:54Z", "author": {"login": "Genius-pig"}, "path": "cli/src/main/java/org/apache/iotdb/tool/ExportCsv.java", "diffHunk": "@@ -263,112 +228,123 @@ private static void dumpResult(String sql, int index)\n         return;\n       }\n     } catch (IOException e) {\n-      System.out.println(\"Cannot create dump file \" + path + \"because: \" + e.getMessage());\n+      System.out.println(\"Cannot create dump file \" + path + \" \" + \"because: \" + e.getMessage());\n       return;\n     }\n     System.out.println(\"Start to export data from sql statement: \" + sql);\n-    try (Statement statement = connection.createStatement();\n-        ResultSet rs = statement.executeQuery(sql);\n-        BufferedWriter bw = new BufferedWriter(new FileWriter(tf))) {\n-      ResultSetMetaData metadata = rs.getMetaData();\n+    try (BufferedWriter bw = new BufferedWriter(new FileWriter(tf))) {\n+      SessionDataSet sessionDataSet = session.executeQueryStatement(sql);\n       long startTime = System.currentTimeMillis();\n-\n-      int count = metadata.getColumnCount();\n       // write data in csv file\n-      writeMetadata(bw, count, metadata);\n+      writeMetadata(bw, sessionDataSet.getColumnNames());\n \n-      int line = writeResultSet(rs, bw, count);\n+      int line = writeResultSet(sessionDataSet, bw);\n       System.out\n-          .println(String.format(\"Statement [%s] has dumped to file %s successfully! It costs \"\n-                  + \"%dms to export %d lines.\", sql, path, System.currentTimeMillis() - startTime,\n-              line));\n-    } catch (IOException e) {\n+          .printf(\"Statement [%s] has dumped to file %s successfully! It costs \"\n+                  + \"%dms to export %d lines.%n\", sql, path, System.currentTimeMillis() - startTime,\n+              line);\n+    } catch (IOException | StatementExecutionException | IoTDBConnectionException e) {\n       System.out.println(\"Cannot dump result because: \" + e.getMessage());\n     }\n   }\n \n-  private static void writeMetadata(BufferedWriter bw, int count, ResultSetMetaData metadata)\n-      throws SQLException, IOException {\n-    for (int i = 1; i <= count; i++) {\n-      if (i < count) {\n-        bw.write(metadata.getColumnLabel(i) + \",\");\n-      } else {\n-        bw.write(metadata.getColumnLabel(i) + \"\\n\");\n-      }\n-      typeList.add(metadata.getColumnType(i));\n+  private static void writeMetadata(BufferedWriter bw, List<String> columnNames)\n+      throws IOException {\n+    if (!columnNames.get(0).equals(\"Time\")) {\n+      bw.write(\"Time\" + \",\");\n+    }\n+    for (int i = 0; i < columnNames.size() - 1; i++) {\n+      bw.write(columnNames.get(i) + \",\");\n     }\n+    bw.write(columnNames.get(columnNames.size() - 1) + \"\\n\");\n   }\n \n-  private static int writeResultSet(ResultSet rs, BufferedWriter bw, int count)\n-      throws SQLException, IOException {\n+  private static int writeResultSet(SessionDataSet rs, BufferedWriter bw)\n+      throws IOException, StatementExecutionException, IoTDBConnectionException {\n     int line = 0;\n     long timestamp = System.currentTimeMillis();\n-    while (rs.next()) {\n-      if (rs.getString(1) == null ||\n-          \"null\".equalsIgnoreCase(rs.getString(1))) {\n-        bw.write(\",\");\n-      } else {\n-        writeTime(rs, bw);\n-        writeValue(rs, count, bw);\n-      }\n+    while (rs.hasNext()) {\n+      RowRecord rowRecord = rs.next();\n+      List<Field> fields = rowRecord.getFields();\n+      writeTime(rowRecord.getTimestamp(), bw);\n+      writeValue(fields, bw);\n       line++;\n       if (line % EXPORT_PER_LINE_COUNT == 0) {\n         long tmp = System.currentTimeMillis();\n-        System.out.println(\n-            String.format(\"%d lines have been exported, it takes %dms\", line, (tmp - timestamp)));\n+        System.out.printf(\"%d lines have been exported, it takes %dms%n\", line, (tmp - timestamp));\n         timestamp = tmp;\n       }\n     }\n     return line;\n   }\n \n-  private static void writeTime(ResultSet rs, BufferedWriter bw) throws SQLException, IOException {\n+  private static void writeTime(Long time, BufferedWriter bw) throws IOException {\n     ZonedDateTime dateTime;\n+    String timestampPrecision = \"ms\";\n     switch (timeFormat) {\n       case \"default\":\n-        long timestamp = rs.getLong(1);\n         String str = AbstractCli\n-            .parseLongToDateWithPrecision(DateTimeFormatter.ISO_OFFSET_DATE_TIME, timestamp, zoneId,\n-                TIMESTAMP_PRECISION);\n+            .parseLongToDateWithPrecision(DateTimeFormatter.ISO_OFFSET_DATE_TIME, time, zoneId,\n+                timestampPrecision);\n         bw.write(str + \",\");\n         break;\n       case \"timestamp\":\n       case \"long\":\n       case \"nubmer\":\n-        bw.write(rs.getLong(1) + \",\");\n+        bw.write(time + \",\");\n         break;\n       default:\n-        dateTime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(rs.getLong(1)),\n+        dateTime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(time),\n             zoneId);\n         bw.write(dateTime.format(DateTimeFormatter.ofPattern(timeFormat)) + \",\");\n         break;\n     }\n   }\n \n   @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n-  private static void writeValue(ResultSet rs, int count, BufferedWriter bw)\n-      throws SQLException, IOException {\n-    for (int j = 2; j <= count; j++) {\n-      if (j < count) {\n-        if (\"null\".equals(rs.getString(j))) {\n-          bw.write(\",\");\n-        } else {\n-          if(typeList.get(j-1) == Types.VARCHAR) {\n-            bw.write(\"\\'\" + rs.getString(j) + \"\\'\"+ \",\");\n+  private static void writeValue(List<Field> fields, BufferedWriter bw) throws IOException {\n+    for (int j = 0; j < fields.size() - 1; j++) {\n+      String value = fields.get(j).getStringValue();\n+      if (\"null\".equalsIgnoreCase(value)) {\n+        bw.write(\",\");\n+      } else {\n+        if (fields.get(j).getDataType() == TSDataType.TEXT) {\n+          int location = value.indexOf(\"\\\"\");\n+          if (location > -1) {\n+            if (value.charAt(location - 1) != '\\\\') {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg0OTQyMQ=="}, "originalCommit": {"oid": "fac00b7abb398a1f9b4de8dd91876cbbbbda4b1b"}, "originalPosition": 298}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMzM2MDA4OnYy", "diffSide": "RIGHT", "path": "cli/src/main/java/org/apache/iotdb/tool/ExportCsv.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjo0MTo0MVrOH2cYxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjo1NDoxNVrOH2c2WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1MDI0Nw==", "bodyText": "Note that location may equals to 0, which will cause Exception...", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r526850247", "createdAt": "2020-11-19T12:41:41Z", "author": {"login": "SteveYurongSu"}, "path": "cli/src/main/java/org/apache/iotdb/tool/ExportCsv.java", "diffHunk": "@@ -263,112 +228,123 @@ private static void dumpResult(String sql, int index)\n         return;\n       }\n     } catch (IOException e) {\n-      System.out.println(\"Cannot create dump file \" + path + \"because: \" + e.getMessage());\n+      System.out.println(\"Cannot create dump file \" + path + \" \" + \"because: \" + e.getMessage());\n       return;\n     }\n     System.out.println(\"Start to export data from sql statement: \" + sql);\n-    try (Statement statement = connection.createStatement();\n-        ResultSet rs = statement.executeQuery(sql);\n-        BufferedWriter bw = new BufferedWriter(new FileWriter(tf))) {\n-      ResultSetMetaData metadata = rs.getMetaData();\n+    try (BufferedWriter bw = new BufferedWriter(new FileWriter(tf))) {\n+      SessionDataSet sessionDataSet = session.executeQueryStatement(sql);\n       long startTime = System.currentTimeMillis();\n-\n-      int count = metadata.getColumnCount();\n       // write data in csv file\n-      writeMetadata(bw, count, metadata);\n+      writeMetadata(bw, sessionDataSet.getColumnNames());\n \n-      int line = writeResultSet(rs, bw, count);\n+      int line = writeResultSet(sessionDataSet, bw);\n       System.out\n-          .println(String.format(\"Statement [%s] has dumped to file %s successfully! It costs \"\n-                  + \"%dms to export %d lines.\", sql, path, System.currentTimeMillis() - startTime,\n-              line));\n-    } catch (IOException e) {\n+          .printf(\"Statement [%s] has dumped to file %s successfully! It costs \"\n+                  + \"%dms to export %d lines.%n\", sql, path, System.currentTimeMillis() - startTime,\n+              line);\n+    } catch (IOException | StatementExecutionException | IoTDBConnectionException e) {\n       System.out.println(\"Cannot dump result because: \" + e.getMessage());\n     }\n   }\n \n-  private static void writeMetadata(BufferedWriter bw, int count, ResultSetMetaData metadata)\n-      throws SQLException, IOException {\n-    for (int i = 1; i <= count; i++) {\n-      if (i < count) {\n-        bw.write(metadata.getColumnLabel(i) + \",\");\n-      } else {\n-        bw.write(metadata.getColumnLabel(i) + \"\\n\");\n-      }\n-      typeList.add(metadata.getColumnType(i));\n+  private static void writeMetadata(BufferedWriter bw, List<String> columnNames)\n+      throws IOException {\n+    if (!columnNames.get(0).equals(\"Time\")) {\n+      bw.write(\"Time\" + \",\");\n+    }\n+    for (int i = 0; i < columnNames.size() - 1; i++) {\n+      bw.write(columnNames.get(i) + \",\");\n     }\n+    bw.write(columnNames.get(columnNames.size() - 1) + \"\\n\");\n   }\n \n-  private static int writeResultSet(ResultSet rs, BufferedWriter bw, int count)\n-      throws SQLException, IOException {\n+  private static int writeResultSet(SessionDataSet rs, BufferedWriter bw)\n+      throws IOException, StatementExecutionException, IoTDBConnectionException {\n     int line = 0;\n     long timestamp = System.currentTimeMillis();\n-    while (rs.next()) {\n-      if (rs.getString(1) == null ||\n-          \"null\".equalsIgnoreCase(rs.getString(1))) {\n-        bw.write(\",\");\n-      } else {\n-        writeTime(rs, bw);\n-        writeValue(rs, count, bw);\n-      }\n+    while (rs.hasNext()) {\n+      RowRecord rowRecord = rs.next();\n+      List<Field> fields = rowRecord.getFields();\n+      writeTime(rowRecord.getTimestamp(), bw);\n+      writeValue(fields, bw);\n       line++;\n       if (line % EXPORT_PER_LINE_COUNT == 0) {\n         long tmp = System.currentTimeMillis();\n-        System.out.println(\n-            String.format(\"%d lines have been exported, it takes %dms\", line, (tmp - timestamp)));\n+        System.out.printf(\"%d lines have been exported, it takes %dms%n\", line, (tmp - timestamp));\n         timestamp = tmp;\n       }\n     }\n     return line;\n   }\n \n-  private static void writeTime(ResultSet rs, BufferedWriter bw) throws SQLException, IOException {\n+  private static void writeTime(Long time, BufferedWriter bw) throws IOException {\n     ZonedDateTime dateTime;\n+    String timestampPrecision = \"ms\";\n     switch (timeFormat) {\n       case \"default\":\n-        long timestamp = rs.getLong(1);\n         String str = AbstractCli\n-            .parseLongToDateWithPrecision(DateTimeFormatter.ISO_OFFSET_DATE_TIME, timestamp, zoneId,\n-                TIMESTAMP_PRECISION);\n+            .parseLongToDateWithPrecision(DateTimeFormatter.ISO_OFFSET_DATE_TIME, time, zoneId,\n+                timestampPrecision);\n         bw.write(str + \",\");\n         break;\n       case \"timestamp\":\n       case \"long\":\n       case \"nubmer\":\n-        bw.write(rs.getLong(1) + \",\");\n+        bw.write(time + \",\");\n         break;\n       default:\n-        dateTime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(rs.getLong(1)),\n+        dateTime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(time),\n             zoneId);\n         bw.write(dateTime.format(DateTimeFormatter.ofPattern(timeFormat)) + \",\");\n         break;\n     }\n   }\n \n   @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n-  private static void writeValue(ResultSet rs, int count, BufferedWriter bw)\n-      throws SQLException, IOException {\n-    for (int j = 2; j <= count; j++) {\n-      if (j < count) {\n-        if (\"null\".equals(rs.getString(j))) {\n-          bw.write(\",\");\n-        } else {\n-          if(typeList.get(j-1) == Types.VARCHAR) {\n-            bw.write(\"\\'\" + rs.getString(j) + \"\\'\"+ \",\");\n+  private static void writeValue(List<Field> fields, BufferedWriter bw) throws IOException {\n+    for (int j = 0; j < fields.size() - 1; j++) {\n+      String value = fields.get(j).getStringValue();\n+      if (\"null\".equalsIgnoreCase(value)) {\n+        bw.write(\",\");\n+      } else {\n+        if (fields.get(j).getDataType() == TSDataType.TEXT) {\n+          int location = value.indexOf(\"\\\"\");\n+          if (location > -1) {\n+            if (value.charAt(location - 1) != '\\\\') {\n+              bw.write(\"\\\"\" + value.replace(\"\\\"\", \"\\\\\\\"\") + \"\\\",\");\n+            } else {\n+              bw.write(\"\\\"\" + value + \"\\\",\");\n+            }\n+          } else if (value.contains(\",\")) {\n+            bw.write(\"\\\"\" + value + \"\\\",\");\n           } else {\n-            bw.write(rs.getString(j) + \",\");\n+            bw.write(value + \",\");\n           }\n-        }\n-      } else {\n-        if (\"null\".equals(rs.getString(j))) {\n-          bw.write(\"\\n\");\n         } else {\n-          if(typeList.get(j-1) == Types.VARCHAR) {\n-            bw.write(\"\\'\" + rs.getString(j) + \"\\'\"+ \"\\n\");\n+          bw.write(value + \",\");\n+        }\n+      }\n+    }\n+    String lastValue = fields.get(fields.size() - 1).getStringValue();\n+    if (\"null\".equalsIgnoreCase(lastValue)) {\n+      bw.write(\"\\n\");\n+    } else {\n+      if (fields.get(fields.size() - 1).getDataType() == TSDataType.TEXT) {\n+        int location = lastValue.indexOf(\"\\\"\");\n+        if (location > -1) {\n+          if (lastValue.charAt(location - 1) != '\\\\') {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fac00b7abb398a1f9b4de8dd91876cbbbbda4b1b"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1NzgxNw==", "bodyText": "And why we need this judgement?", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r526857817", "createdAt": "2020-11-19T12:54:15Z", "author": {"login": "SteveYurongSu"}, "path": "cli/src/main/java/org/apache/iotdb/tool/ExportCsv.java", "diffHunk": "@@ -263,112 +228,123 @@ private static void dumpResult(String sql, int index)\n         return;\n       }\n     } catch (IOException e) {\n-      System.out.println(\"Cannot create dump file \" + path + \"because: \" + e.getMessage());\n+      System.out.println(\"Cannot create dump file \" + path + \" \" + \"because: \" + e.getMessage());\n       return;\n     }\n     System.out.println(\"Start to export data from sql statement: \" + sql);\n-    try (Statement statement = connection.createStatement();\n-        ResultSet rs = statement.executeQuery(sql);\n-        BufferedWriter bw = new BufferedWriter(new FileWriter(tf))) {\n-      ResultSetMetaData metadata = rs.getMetaData();\n+    try (BufferedWriter bw = new BufferedWriter(new FileWriter(tf))) {\n+      SessionDataSet sessionDataSet = session.executeQueryStatement(sql);\n       long startTime = System.currentTimeMillis();\n-\n-      int count = metadata.getColumnCount();\n       // write data in csv file\n-      writeMetadata(bw, count, metadata);\n+      writeMetadata(bw, sessionDataSet.getColumnNames());\n \n-      int line = writeResultSet(rs, bw, count);\n+      int line = writeResultSet(sessionDataSet, bw);\n       System.out\n-          .println(String.format(\"Statement [%s] has dumped to file %s successfully! It costs \"\n-                  + \"%dms to export %d lines.\", sql, path, System.currentTimeMillis() - startTime,\n-              line));\n-    } catch (IOException e) {\n+          .printf(\"Statement [%s] has dumped to file %s successfully! It costs \"\n+                  + \"%dms to export %d lines.%n\", sql, path, System.currentTimeMillis() - startTime,\n+              line);\n+    } catch (IOException | StatementExecutionException | IoTDBConnectionException e) {\n       System.out.println(\"Cannot dump result because: \" + e.getMessage());\n     }\n   }\n \n-  private static void writeMetadata(BufferedWriter bw, int count, ResultSetMetaData metadata)\n-      throws SQLException, IOException {\n-    for (int i = 1; i <= count; i++) {\n-      if (i < count) {\n-        bw.write(metadata.getColumnLabel(i) + \",\");\n-      } else {\n-        bw.write(metadata.getColumnLabel(i) + \"\\n\");\n-      }\n-      typeList.add(metadata.getColumnType(i));\n+  private static void writeMetadata(BufferedWriter bw, List<String> columnNames)\n+      throws IOException {\n+    if (!columnNames.get(0).equals(\"Time\")) {\n+      bw.write(\"Time\" + \",\");\n+    }\n+    for (int i = 0; i < columnNames.size() - 1; i++) {\n+      bw.write(columnNames.get(i) + \",\");\n     }\n+    bw.write(columnNames.get(columnNames.size() - 1) + \"\\n\");\n   }\n \n-  private static int writeResultSet(ResultSet rs, BufferedWriter bw, int count)\n-      throws SQLException, IOException {\n+  private static int writeResultSet(SessionDataSet rs, BufferedWriter bw)\n+      throws IOException, StatementExecutionException, IoTDBConnectionException {\n     int line = 0;\n     long timestamp = System.currentTimeMillis();\n-    while (rs.next()) {\n-      if (rs.getString(1) == null ||\n-          \"null\".equalsIgnoreCase(rs.getString(1))) {\n-        bw.write(\",\");\n-      } else {\n-        writeTime(rs, bw);\n-        writeValue(rs, count, bw);\n-      }\n+    while (rs.hasNext()) {\n+      RowRecord rowRecord = rs.next();\n+      List<Field> fields = rowRecord.getFields();\n+      writeTime(rowRecord.getTimestamp(), bw);\n+      writeValue(fields, bw);\n       line++;\n       if (line % EXPORT_PER_LINE_COUNT == 0) {\n         long tmp = System.currentTimeMillis();\n-        System.out.println(\n-            String.format(\"%d lines have been exported, it takes %dms\", line, (tmp - timestamp)));\n+        System.out.printf(\"%d lines have been exported, it takes %dms%n\", line, (tmp - timestamp));\n         timestamp = tmp;\n       }\n     }\n     return line;\n   }\n \n-  private static void writeTime(ResultSet rs, BufferedWriter bw) throws SQLException, IOException {\n+  private static void writeTime(Long time, BufferedWriter bw) throws IOException {\n     ZonedDateTime dateTime;\n+    String timestampPrecision = \"ms\";\n     switch (timeFormat) {\n       case \"default\":\n-        long timestamp = rs.getLong(1);\n         String str = AbstractCli\n-            .parseLongToDateWithPrecision(DateTimeFormatter.ISO_OFFSET_DATE_TIME, timestamp, zoneId,\n-                TIMESTAMP_PRECISION);\n+            .parseLongToDateWithPrecision(DateTimeFormatter.ISO_OFFSET_DATE_TIME, time, zoneId,\n+                timestampPrecision);\n         bw.write(str + \",\");\n         break;\n       case \"timestamp\":\n       case \"long\":\n       case \"nubmer\":\n-        bw.write(rs.getLong(1) + \",\");\n+        bw.write(time + \",\");\n         break;\n       default:\n-        dateTime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(rs.getLong(1)),\n+        dateTime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(time),\n             zoneId);\n         bw.write(dateTime.format(DateTimeFormatter.ofPattern(timeFormat)) + \",\");\n         break;\n     }\n   }\n \n   @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n-  private static void writeValue(ResultSet rs, int count, BufferedWriter bw)\n-      throws SQLException, IOException {\n-    for (int j = 2; j <= count; j++) {\n-      if (j < count) {\n-        if (\"null\".equals(rs.getString(j))) {\n-          bw.write(\",\");\n-        } else {\n-          if(typeList.get(j-1) == Types.VARCHAR) {\n-            bw.write(\"\\'\" + rs.getString(j) + \"\\'\"+ \",\");\n+  private static void writeValue(List<Field> fields, BufferedWriter bw) throws IOException {\n+    for (int j = 0; j < fields.size() - 1; j++) {\n+      String value = fields.get(j).getStringValue();\n+      if (\"null\".equalsIgnoreCase(value)) {\n+        bw.write(\",\");\n+      } else {\n+        if (fields.get(j).getDataType() == TSDataType.TEXT) {\n+          int location = value.indexOf(\"\\\"\");\n+          if (location > -1) {\n+            if (value.charAt(location - 1) != '\\\\') {\n+              bw.write(\"\\\"\" + value.replace(\"\\\"\", \"\\\\\\\"\") + \"\\\",\");\n+            } else {\n+              bw.write(\"\\\"\" + value + \"\\\",\");\n+            }\n+          } else if (value.contains(\",\")) {\n+            bw.write(\"\\\"\" + value + \"\\\",\");\n           } else {\n-            bw.write(rs.getString(j) + \",\");\n+            bw.write(value + \",\");\n           }\n-        }\n-      } else {\n-        if (\"null\".equals(rs.getString(j))) {\n-          bw.write(\"\\n\");\n         } else {\n-          if(typeList.get(j-1) == Types.VARCHAR) {\n-            bw.write(\"\\'\" + rs.getString(j) + \"\\'\"+ \"\\n\");\n+          bw.write(value + \",\");\n+        }\n+      }\n+    }\n+    String lastValue = fields.get(fields.size() - 1).getStringValue();\n+    if (\"null\".equalsIgnoreCase(lastValue)) {\n+      bw.write(\"\\n\");\n+    } else {\n+      if (fields.get(fields.size() - 1).getDataType() == TSDataType.TEXT) {\n+        int location = lastValue.indexOf(\"\\\"\");\n+        if (location > -1) {\n+          if (lastValue.charAt(location - 1) != '\\\\') {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1MDI0Nw=="}, "originalCommit": {"oid": "fac00b7abb398a1f9b4de8dd91876cbbbbda4b1b"}, "originalPosition": 327}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMzQ2NTYwOnYy", "diffSide": "RIGHT", "path": "cli/src/main/java/org/apache/iotdb/tool/ImportCsv.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMzowOTowM1rOH2dZiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNDozODoxNFrOH2hpfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg2NjgyNw==", "bodyText": "This equation is always false and ...\nDoes \"\" represent null?", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r526866827", "createdAt": "2020-11-19T13:09:03Z", "author": {"login": "SteveYurongSu"}, "path": "cli/src/main/java/org/apache/iotdb/tool/ImportCsv.java", "diffHunk": "@@ -119,296 +89,90 @@ private static Options createOptions() {\n   /**\n    * Data from csv To tsfile.\n    */\n-  private static void loadDataFromCSV(File file, int index) {\n-    statement = null;\n+  private static void loadDataFromCSV(File file) {\n     int fileLine;\n     try {\n       fileLine = getFileLineCount(file);\n     } catch (IOException e) {\n       System.out.println(\"Failed to import file: \" + file.getName());\n       return;\n     }\n-    File errorFile = new File(errorInsertInfo + index);\n-    if (!errorFile.exists()) {\n-      try {\n-        errorFile.createNewFile();\n-      } catch (IOException e) {\n-        System.out.println(\"Cannot create a errorFile because: \" + e.getMessage());\n-        return;\n-      }\n-    }\n     System.out.println(\"Start to import data from: \" + file.getName());\n-    errorFlag = true;\n-    try(BufferedReader br = new BufferedReader(new FileReader(file));\n-        BufferedWriter bw = new BufferedWriter(new FileWriter(errorFile));\n+    try (BufferedReader br = new BufferedReader(new FileReader(file));\n         ProgressBar pb = new ProgressBar(\"Import from: \" + file.getName(), fileLine)) {\n       pb.setExtraMessage(\"Importing...\");\n       String header = br.readLine();\n-\n-      bw.write(\"From \" + file.getAbsolutePath());\n-      bw.newLine();\n-      bw.newLine();\n-      bw.write(header);\n-      bw.newLine();\n-      bw.newLine();\n-\n-      // storage csv table head info\n-      Map<String, ArrayList<Integer>> deviceToColumn = new HashMap<>();\n-      // storage csv table head info\n-      List<String> colInfo = new ArrayList<>();\n-      // storage csv device sensor info, corresponding csv table head\n-      List<String> headInfo = new ArrayList<>();\n-\n-      String[] strHeadInfo = header.split(\",\");\n-      if (strHeadInfo.length <= 1) {\n-        System.out.println(\"The CSV file \"+ file.getName() +\" illegal, please check first line\");\n+      String[] cols = splitCsvLine(header);\n+      if (cols.length <= 1) {\n+        System.out.println(\"The CSV file \" + file.getName() + \" illegal, please check first line\");\n         return;\n       }\n \n-      long startTime = System.currentTimeMillis();\n-      Map<String, String> timeseriesDataType = new HashMap<>();\n+      List<String> devices = new ArrayList<>();\n+      List<Long> times = new ArrayList<>();\n+      List<List<String>> measurementsList = new ArrayList<>();\n+      List<List<String>> valuesList = new ArrayList<>();\n+      Map<String, List<Integer>> devicesToPositions = new HashMap<>();\n+      Map<String, List<String>> devicesToMeasurements = new HashMap<>();\n \n-      boolean success = queryDatabaseMeta(strHeadInfo, file, bw, timeseriesDataType, headInfo,\n-          deviceToColumn, colInfo);\n-      if (!success) {\n-        errorFlag = false;\n-        return;\n+      for (int i = 1; i < cols.length; i++) {\n+        splitColToDeviceAndMeasurement(cols[i], devicesToPositions, devicesToMeasurements, i);\n       }\n \n-      statement = connection.createStatement();\n-\n+      int lineNumber = 0;\n+      String line;\n+      while ((line = br.readLine()) != null) {\n+        cols = splitCsvLine(line);\n+        lineNumber++;\n+        for (Entry<String, List<Integer>> deviceToPositions : devicesToPositions\n+            .entrySet()) {\n+          String device = deviceToPositions.getKey();\n+          devices.add(device);\n+\n+          times.add(Long.parseLong(cols[0]));\n+\n+          List<String> values = new ArrayList<>();\n+          for (int position : deviceToPositions.getValue()) {\n+            if (cols[position].equals(\"\") && cols[position].equals(\"null\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fac00b7abb398a1f9b4de8dd91876cbbbbda4b1b"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjkzNjQ0NA==", "bodyText": "remove, \"\" represent \"\";", "url": "https://github.com/apache/iotdb/pull/1914#discussion_r526936444", "createdAt": "2020-11-19T14:38:14Z", "author": {"login": "Genius-pig"}, "path": "cli/src/main/java/org/apache/iotdb/tool/ImportCsv.java", "diffHunk": "@@ -119,296 +89,90 @@ private static Options createOptions() {\n   /**\n    * Data from csv To tsfile.\n    */\n-  private static void loadDataFromCSV(File file, int index) {\n-    statement = null;\n+  private static void loadDataFromCSV(File file) {\n     int fileLine;\n     try {\n       fileLine = getFileLineCount(file);\n     } catch (IOException e) {\n       System.out.println(\"Failed to import file: \" + file.getName());\n       return;\n     }\n-    File errorFile = new File(errorInsertInfo + index);\n-    if (!errorFile.exists()) {\n-      try {\n-        errorFile.createNewFile();\n-      } catch (IOException e) {\n-        System.out.println(\"Cannot create a errorFile because: \" + e.getMessage());\n-        return;\n-      }\n-    }\n     System.out.println(\"Start to import data from: \" + file.getName());\n-    errorFlag = true;\n-    try(BufferedReader br = new BufferedReader(new FileReader(file));\n-        BufferedWriter bw = new BufferedWriter(new FileWriter(errorFile));\n+    try (BufferedReader br = new BufferedReader(new FileReader(file));\n         ProgressBar pb = new ProgressBar(\"Import from: \" + file.getName(), fileLine)) {\n       pb.setExtraMessage(\"Importing...\");\n       String header = br.readLine();\n-\n-      bw.write(\"From \" + file.getAbsolutePath());\n-      bw.newLine();\n-      bw.newLine();\n-      bw.write(header);\n-      bw.newLine();\n-      bw.newLine();\n-\n-      // storage csv table head info\n-      Map<String, ArrayList<Integer>> deviceToColumn = new HashMap<>();\n-      // storage csv table head info\n-      List<String> colInfo = new ArrayList<>();\n-      // storage csv device sensor info, corresponding csv table head\n-      List<String> headInfo = new ArrayList<>();\n-\n-      String[] strHeadInfo = header.split(\",\");\n-      if (strHeadInfo.length <= 1) {\n-        System.out.println(\"The CSV file \"+ file.getName() +\" illegal, please check first line\");\n+      String[] cols = splitCsvLine(header);\n+      if (cols.length <= 1) {\n+        System.out.println(\"The CSV file \" + file.getName() + \" illegal, please check first line\");\n         return;\n       }\n \n-      long startTime = System.currentTimeMillis();\n-      Map<String, String> timeseriesDataType = new HashMap<>();\n+      List<String> devices = new ArrayList<>();\n+      List<Long> times = new ArrayList<>();\n+      List<List<String>> measurementsList = new ArrayList<>();\n+      List<List<String>> valuesList = new ArrayList<>();\n+      Map<String, List<Integer>> devicesToPositions = new HashMap<>();\n+      Map<String, List<String>> devicesToMeasurements = new HashMap<>();\n \n-      boolean success = queryDatabaseMeta(strHeadInfo, file, bw, timeseriesDataType, headInfo,\n-          deviceToColumn, colInfo);\n-      if (!success) {\n-        errorFlag = false;\n-        return;\n+      for (int i = 1; i < cols.length; i++) {\n+        splitColToDeviceAndMeasurement(cols[i], devicesToPositions, devicesToMeasurements, i);\n       }\n \n-      statement = connection.createStatement();\n-\n+      int lineNumber = 0;\n+      String line;\n+      while ((line = br.readLine()) != null) {\n+        cols = splitCsvLine(line);\n+        lineNumber++;\n+        for (Entry<String, List<Integer>> deviceToPositions : devicesToPositions\n+            .entrySet()) {\n+          String device = deviceToPositions.getKey();\n+          devices.add(device);\n+\n+          times.add(Long.parseLong(cols[0]));\n+\n+          List<String> values = new ArrayList<>();\n+          for (int position : deviceToPositions.getValue()) {\n+            if (cols[position].equals(\"\") && cols[position].equals(\"null\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg2NjgyNw=="}, "originalCommit": {"oid": "fac00b7abb398a1f9b4de8dd91876cbbbbda4b1b"}, "originalPosition": 183}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 692, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}