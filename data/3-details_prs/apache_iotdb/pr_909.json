{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg4MTcwMjUz", "number": 909, "title": "[IOTDB-355] Start-up checks", "bodyText": "This pr implement start up checks according to the issue IOTDB-355.", "createdAt": "2020-03-14T05:41:39Z", "url": "https://github.com/apache/iotdb/pull/909", "merged": true, "mergeCommit": {"oid": "c8683e7c2a35e0cb6a76a9c5baeb4aef2535b018"}, "closed": true, "closedAt": "2020-03-20T03:39:03Z", "author": {"login": "Ring-k"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcNeNZcgH2gAyMzg4MTcwMjUzOjQxZGI5ZDVhMWI4NjM0NGE5YWU4ZWY4ZmM0MmI2MjYyMThjMjQ0NzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcPYDFNAH2gAyMzg4MTcwMjUzOjVmY2I5ZjA3ODZhZWUyZjM2ZTFiMjI0OTMxMDU5MzcxY2ZjOWI0NjU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "41db9d5a1b86344a9ae8ef8fc42b626218c24473", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/41db9d5a1b86344a9ae8ef8fc42b626218c24473", "committedDate": "2020-03-14T05:38:53Z", "message": "fix some typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6abea8410570fb569a8749cfe4b88b2e2b56690f", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/6abea8410570fb569a8749cfe4b88b2e2b56690f", "committedDate": "2020-03-14T14:30:10Z", "message": "start up check"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1MDA1OTY2", "url": "https://github.com/apache/iotdb/pull/909#pullrequestreview-375005966", "createdAt": "2020-03-16T08:42:52Z", "commit": {"oid": "6abea8410570fb569a8749cfe4b88b2e2b56690f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwODo0Mjo1MlrOF2qLVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwODo1NDoyMlrOF2qiTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1ODQ1Mw==", "bodyText": "This check should only be used when a node tries to form the initial cluster (startCluster()). If a node wants to join a cluster, the size of its seeds does not really matter.", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392858453", "createdAt": "2020-03-16T08:42:52Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/MetaClusterServer.java", "diffHunk": "@@ -56,16 +59,22 @@\n   // to register the ClusterMonitor that helps monitoring the cluster\n   private RegisterManager registerManager = new RegisterManager();\n \n-  public MetaClusterServer() throws QueryProcessException {\n+  public MetaClusterServer() throws QueryProcessException, StartupException {\n     super();\n     member = new MetaGroupMember(protocolFactory, thisNode);\n-    // TODO-Cluster#355: check the initial cluster size and refuse to start when the size <\n-    //  #replication\n+    // check the initial cluster size and refuse to start when the size < quorum\n+    int quorum = config.getReplicationNum() / 2 + 1;\n+    if (config.getSeedNodeUrls().size() < quorum) {\n+      String message = String.format(\"Seed number less than quorum, seed number: {}, quorum: {}.\",\n+          config.getSeedNodeUrls().size(), quorum);\n+      throw new StartupException(member.getName(), message);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6abea8410570fb569a8749cfe4b88b2e2b56690f"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1ODY4Nw==", "bodyText": "remove this or use a log", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392858687", "createdAt": "2020-03-16T08:43:18Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/MetaClusterServer.java", "diffHunk": "@@ -74,6 +83,7 @@ public void start() throws TTransportException, StartupException {\n     super.start();\n     ioTDB = new IoTDB();\n     ioTDB.active();\n+    System.out.println(\"--------------------start connecting\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6abea8410570fb569a8749cfe4b88b2e2b56690f"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1OTgxMg==", "bodyText": "Is it necessary to new here? I think the handler should always have the result set by onComplete.", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392859812", "createdAt": "2020-03-16T08:45:31Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/handlers/caller/CheckStatusHandler.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package org.apache.iotdb.cluster.server.handlers.caller;\n+\n+import org.apache.iotdb.cluster.rpc.thrift.CheckStatusResponse;\n+import org.apache.thrift.async.AsyncMethodCallback;\n+\n+public class CheckStatusHandler implements AsyncMethodCallback<CheckStatusResponse> {\n+\n+  CheckStatusResponse checkStatusResponse;\n+\n+  public CheckStatusHandler() {\n+    this.checkStatusResponse = new CheckStatusResponse();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6abea8410570fb569a8749cfe4b88b2e2b56690f"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MTg0NQ==", "bodyText": "I think it is simpler to just add these configurations that should be checked into the AddNodeRequest so that you can cut one communication down.\nBesides, please remove the commented code.", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392861845", "createdAt": "2020-03-16T08:49:29Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -623,6 +627,50 @@ private boolean processAddNodeLocally(Node node, AddNodeResponse response,\n         return true;\n       }\n \n+      // check status of the new node\n+//      AsyncClient client = (AsyncClient) connectNode(node);\n+//      try {\n+//        AsyncMethodCallback<String> result = new AsyncMethodCallback<String>() {\n+//          String words;\n+//          @Override\n+//          public void onComplete(String s) {\n+//            this.words = s;\n+//          }\n+//          @Override\n+//          public void onError(Exception e) {\n+//            System.out.println(\"some error happens\");\n+//          }\n+//          public String getWords() {\n+//            return words;\n+//          }\n+//        };\n+//        System.out.println(result);\n+//        client.echo(\"hello world\", result);\n+//      } catch (TException e) {\n+//        e.printStackTrace();\n+//      }\n+      CheckStatusRequest checkStatusRequest = new CheckStatusRequest();\n+      checkStatusRequest.setHashSalt(ClusterConstant.HASH_SALT);\n+      checkStatusRequest\n+          .setPartitionInterval(IoTDBDescriptor.getInstance().getConfig().getPartitionInterval());\n+      checkStatusRequest.setReplicationNumber(config.getReplicationNum());\n+      CheckStatusHandler checkStatusHandler = new CheckStatusHandler();\n+      try {\n+        sendStatusToNewNode(node, checkStatusRequest, checkStatusHandler);\n+      } catch (TException exception) {\n+        logger.error(\"Failed to send current state to the new node {}\", node, exception);\n+      }\n+      if (!checkStatusHandler.getCheckStatusResponse().isPartitionalIntervalEquals()) {\n+        logger.info(\"The partition interval of the new node {} conflicts.\", node);\n+        return true;\n+      } else if (!checkStatusHandler.getCheckStatusResponse().isHashSaltIntervalEquals()) {\n+        logger.info(\"The hash salt of the new node {} conflicts.\", node);\n+        return true;\n+      } else if (!checkStatusHandler.getCheckStatusResponse().isReplicationNumEquals()) {\n+        logger.info(\"The replication number of the new node {} conflicts.\", node);\n+        return true;\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6abea8410570fb569a8749cfe4b88b2e2b56690f"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MzMwMQ==", "bodyText": "client.checkStatus is an asynchronous method, so if you use it like this, you will probably get nothing in the response. Please refer to other usages where a lock (synchronized) is used to assure that the result is returned before we move on.", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392863301", "createdAt": "2020-03-16T08:52:20Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -663,6 +711,14 @@ private boolean processAddNodeLocally(Node node, AddNodeResponse response,\n     return false;\n   }\n \n+\n+  private void sendStatusToNewNode(Node node, CheckStatusRequest checkStatusRequest,\n+      AsyncMethodCallback<CheckStatusResponse> response)\n+      throws TException {\n+    AsyncClient client = (AsyncClient) connectNode(node);\n+    client.checkStatus(checkStatusRequest, response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6abea8410570fb569a8749cfe4b88b2e2b56690f"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NDMzMg==", "bodyText": "Please also fulfill the tests.", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392864332", "createdAt": "2020-03-16T08:54:22Z", "author": {"login": "jt2594838"}, "path": "cluster/src/test/java/org/apache/iotdb/cluster/server/handlers/caller/CheckStatusHandlerTest.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.apache.iotdb.cluster.server.handlers.caller;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertFalse;\n+import static junit.framework.TestCase.assertTrue;\n+\n+import org.apache.iotdb.cluster.common.TestException;\n+import org.apache.iotdb.cluster.common.TestLogManager;\n+import org.apache.iotdb.cluster.common.TestMetaGroupMember;\n+import org.apache.iotdb.cluster.common.TestUtils;\n+import org.apache.iotdb.cluster.log.LogManager;\n+import org.apache.iotdb.cluster.rpc.thrift.HeartbeatResponse;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.cluster.server.Response;\n+import org.apache.iotdb.cluster.server.member.MetaGroupMember;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class CheckStatusHandlerTest {\n+  private MetaGroupMember metaGroupMember;\n+  private boolean catchUpFlag;\n+\n+  @Before\n+  public void setUp() {\n+    metaGroupMember = new TestMetaGroupMember() {\n+      @Override\n+      public void catchUp(Node follower, long followerLastLogIndex) {\n+        synchronized (metaGroupMember) {\n+          catchUpFlag = true;\n+          metaGroupMember.notifyAll();\n+        }\n+      }\n+\n+      @Override\n+      public LogManager getLogManager() {\n+        return new TestLogManager();\n+      }\n+    };\n+  }\n+\n+  @Test\n+  public void testComplete() throws InterruptedException {\n+    CheckStatusHandler checkStatusHandler = new CheckStatusHandler();\n+    // TODO\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6abea8410570fb569a8749cfe4b88b2e2b56690f"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "850a3af48f766b84404dd1d653e50e831d7c20b4", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/850a3af48f766b84404dd1d653e50e831d7c20b4", "committedDate": "2020-03-16T09:05:52Z", "message": "implement startup check"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1MDMyOTE2", "url": "https://github.com/apache/iotdb/pull/909#pullrequestreview-375032916", "createdAt": "2020-03-16T09:24:14Z", "commit": {"oid": "850a3af48f766b84404dd1d653e50e831d7c20b4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwOToyNDoxNFrOF2rfVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwOToyNzoyMVrOF2rmAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3OTk1OQ==", "bodyText": "Please reverse this.", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392879959", "createdAt": "2020-03-16T09:24:14Z", "author": {"login": "jt2594838"}, "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -60,7 +60,7 @@\n   /**\n    * Port which the JDBC server listens to.\n    */\n-  private int rpcPort = 6667;\n+  private int rpcPort = 6670;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "850a3af48f766b84404dd1d653e50e831d7c20b4"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4MTY2Nw==", "bodyText": "If you decide to return true, then you must call either resultHandler.onComplete() or resultHandler.onError(), otherwise the requestor will wait forever.\nAnd be sure to let the requestor know why there is a failure.", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392881667", "createdAt": "2020-03-16T09:27:21Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -628,45 +627,32 @@ private boolean processAddNodeLocally(Node node, AddNodeResponse response,\n       }\n \n       // check status of the new node\n-//      AsyncClient client = (AsyncClient) connectNode(node);\n-//      try {\n-//        AsyncMethodCallback<String> result = new AsyncMethodCallback<String>() {\n-//          String words;\n-//          @Override\n-//          public void onComplete(String s) {\n-//            this.words = s;\n-//          }\n-//          @Override\n-//          public void onError(Exception e) {\n-//            System.out.println(\"some error happens\");\n-//          }\n-//          public String getWords() {\n-//            return words;\n-//          }\n-//        };\n-//        System.out.println(result);\n-//        client.echo(\"hello world\", result);\n-//      } catch (TException e) {\n-//        e.printStackTrace();\n-//      }\n       CheckStatusRequest checkStatusRequest = new CheckStatusRequest();\n       checkStatusRequest.setHashSalt(ClusterConstant.HASH_SALT);\n       checkStatusRequest\n           .setPartitionInterval(IoTDBDescriptor.getInstance().getConfig().getPartitionInterval());\n       checkStatusRequest.setReplicationNumber(config.getReplicationNum());\n-      CheckStatusHandler checkStatusHandler = new CheckStatusHandler();\n+\n+      AtomicReference<CheckStatusResponse> checkStatusResponseReference = new AtomicReference<>();\n+      GenericHandler<CheckStatusResponse> checkStatusHandler = new GenericHandler<>(node,\n+          checkStatusResponseReference);\n       try {\n-        sendStatusToNewNode(node, checkStatusRequest, checkStatusHandler);\n-      } catch (TException exception) {\n+        synchronized (checkStatusResponseReference) {\n+          AsyncClient client = (AsyncClient) connectNode(node);\n+          client.checkStatus(checkStatusRequest, checkStatusHandler);\n+          checkStatusResponseReference.wait(connectionTimeoutInMS);\n+        }\n+      } catch (TException | InterruptedException exception) {\n         logger.error(\"Failed to send current state to the new node {}\", node, exception);\n       }\n-      if (!checkStatusHandler.getCheckStatusResponse().isPartitionalIntervalEquals()) {\n+      CheckStatusResponse checkStatusResult = checkStatusResponseReference.get();\n+      if (!checkStatusResult.isPartitionalIntervalEquals()) {\n         logger.info(\"The partition interval of the new node {} conflicts.\", node);\n         return true;\n-      } else if (!checkStatusHandler.getCheckStatusResponse().isHashSaltIntervalEquals()) {\n+      } else if (!checkStatusResult.isHashSaltIntervalEquals()) {\n         logger.info(\"The hash salt of the new node {} conflicts.\", node);\n         return true;\n-      } else if (!checkStatusHandler.getCheckStatusResponse().isReplicationNumEquals()) {\n+      } else if (!checkStatusResult.isReplicationNumEquals()) {\n         logger.info(\"The replication number of the new node {} conflicts.\", node);\n         return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "850a3af48f766b84404dd1d653e50e831d7c20b4"}, "originalPosition": 66}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32681c926673032db696bf0aeef8b274a12127a2", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/32681c926673032db696bf0aeef8b274a12127a2", "committedDate": "2020-03-16T10:50:54Z", "message": "reset iotdb config"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NzAxMTI2", "url": "https://github.com/apache/iotdb/pull/909#pullrequestreview-375701126", "createdAt": "2020-03-17T02:35:47Z", "commit": {"oid": "32681c926673032db696bf0aeef8b274a12127a2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "186335a727b2419bbdff65d58980f3180c6f27dd", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/186335a727b2419bbdff65d58980f3180c6f27dd", "committedDate": "2020-03-17T12:12:51Z", "message": "start up check on -s mode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6cec35de3cc498311785f1b5c1d254c2382bb433", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/6cec35de3cc498311785f1b5c1d254c2382bb433", "committedDate": "2020-03-17T12:26:22Z", "message": "call onComplete() before returning"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a269b96788a3994dd4655708d427f0e3a2979296", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/a269b96788a3994dd4655708d427f0e3a2979296", "committedDate": "2020-03-18T13:51:17Z", "message": "merge check status in add node"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9d0c10634efbd5fdd7fd9e3c76ccbaf34797b51", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/c9d0c10634efbd5fdd7fd9e3c76ccbaf34797b51", "committedDate": "2020-03-18T13:52:12Z", "message": "remove useless comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db5019c0483230de9650702bc431c557898911e7", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/db5019c0483230de9650702bc431c557898911e7", "committedDate": "2020-03-18T14:14:36Z", "message": "add unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8642a2cb02a0488fea39cdab1b0bdaab8bc5e68", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/c8642a2cb02a0488fea39cdab1b0bdaab8bc5e68", "committedDate": "2020-03-18T14:41:18Z", "message": "fix conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79b40fbb1b17649d63ac64fdbc0c0fd5202d78dc", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/79b40fbb1b17649d63ac64fdbc0c0fd5202d78dc", "committedDate": "2020-03-19T14:08:34Z", "message": "fix conflict"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MjE1ODg1", "url": "https://github.com/apache/iotdb/pull/909#pullrequestreview-378215885", "createdAt": "2020-03-20T03:22:46Z", "commit": {"oid": "79b40fbb1b17649d63ac64fdbc0c0fd5202d78dc"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwMzoyMjo0N1rOF5GwNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwMzoyNDoxM1rOF5GxVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyMzc5Ng==", "bodyText": "Please notice the conflict marks and resolve them. I will mark all I see in case you miss any.", "url": "https://github.com/apache/iotdb/pull/909#discussion_r395423796", "createdAt": "2020-03-20T03:22:47Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java", "diffHunk": "@@ -545,424 +550,487 @@ public Node getThisNode() {\n   }\n \n \n-  public void processValidHeartbeatResp(HeartbeatResponse response, Node receiver) {\n+    /**\n+     * Sub-classes will add their own process of HeartBeatResponse in this method.\n+     * @param response\n+     * @param receiver\n+     */\n+    public void processValidHeartbeatResp (HeartbeatResponse response, Node receiver){\n \n-  }\n-\n-  /**\n-   * The actions performed when the node wins in an election (becoming a leader).\n-   */\n-  public void onElectionWins() {\n-\n-  }\n-\n-  void processValidHeartbeatReq(HeartbeatRequest request, HeartbeatResponse response) {\n+    }\n \n-  }\n+    /**\n+     * The actions performed when the node wins in an election (becoming a leader).\n+     */\n+    public void onElectionWins () {\n \n-  /**\n-   * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n-   * reset heartbeat timer.\n-   * @param newTerm\n-   */\n-  public void retireFromLeader(long newTerm) {\n-    synchronized (term) {\n-      long currTerm = term.get();\n-      // confirm that the heartbeat of the new leader hasn't come\n-      if (currTerm < newTerm) {\n-        term.set(newTerm);\n-        setCharacter(NodeCharacter.FOLLOWER);\n-        setLeader(null);\n-        setLastHeartbeatReceivedTime(System.currentTimeMillis());\n-      }\n     }\n-  }\n-\n-  /**\n-   * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n-   * request is valid.\n-   * @param electionRequest\n-   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-   *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-   */\n-  long processElectionRequest(ElectionRequest electionRequest) {\n \n-    long thatTerm = electionRequest.getTerm();\n-    long thatLastLogId = electionRequest.getLastLogIndex();\n-    long thatLastLogTerm = electionRequest.getLastLogTerm();\n-    logger.info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n-        name, thatTerm,\n-        thatLastLogId, thatLastLogTerm);\n \n-    long lastLogIndex = logManager.getLastLogIndex();\n-    long lastLogTerm = logManager.getLastLogTerm();\n+      /**\n+       * Sub-classes will add their own process of HeartBeatRequest in this method.\n+       * @param request\n+       * @param response\n+       */\n+      void processValidHeartbeatReq (HeartbeatRequest request, HeartbeatResponse response){\n \n-    synchronized (term) {\n-      long thisTerm = term.get();\n-      long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n-          thatLastLogTerm);\n-      if (resp == Response.RESPONSE_AGREE) {\n-        term.set(thatTerm);\n-        setCharacter(NodeCharacter.FOLLOWER);\n-        lastHeartbeatReceivedTime = System.currentTimeMillis();\n-        leader = electionRequest.getElector();\n-        // interrupt election\n-        term.notifyAll();\n       }\n-      return resp;\n-    }\n-  }\n \n-  /**\n-   *  Reject the election if one of the four holds:\n-   *   1. the term of the candidate is no bigger than the voter's\n-   *   2. the lastLogTerm of the candidate is smaller than the voter's\n-   *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n-   *      smaller than the voter's\n-   *   Otherwise accept the election.\n-   * @param thisTerm\n-   * @param thisLastLogIndex\n-   * @param thisLastLogTerm\n-   * @param thatTerm\n-   * @param thatLastLogId\n-   * @param thatLastLogTerm\n-   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-   * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-   */\n-  long verifyElector(long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n-      long thatTerm, long thatLastLogId, long thatLastLogTerm) {\n-    long response;\n-    if (thatTerm <= thisTerm) {\n-      response = thisTerm;\n-      logger.debug(\"{} rejected an election request, term:{}/{}\",\n-          name, thatTerm, thisTerm);\n-    } else if (thatLastLogTerm < thisLastLogTerm\n-        || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n-      logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n-          name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n-      response = Response.RESPONSE_LOG_MISMATCH;\n-    } else {\n-      logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n-          name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n-          thisLastLogTerm);\n-      response = Response.RESPONSE_AGREE;\n-    }\n-    return response;\n-  }\n-\n-  /**\n-   * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n-   * follower. If some of the logs are not in memory, also send the snapshot.\n-   * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n-   *\n-   * @param follower\n-   * @param followerLastLogIndex\n-   */\n-  public void catchUp(Node follower, long followerLastLogIndex) {\n-    // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n-    // for one follower, there is at most one ongoing catch-up\n-    synchronized (follower) {\n-      // check if the last catch-up is still ongoing\n-      Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n-      if (lastCatchupResp != null\n-          && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n-        logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n-        return;\n-      } else {\n-        // record the start of the catch-up\n-        lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+      /**\n+       * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n+       * reset heartbeat timer.\n+       * @param newTerm\n+       */\n+      public void retireFromLeader ( long newTerm){\n+        synchronized (term) {\n+          long currTerm = term.get();\n+          // confirm that the heartbeat of the new leader hasn't come\n+          if (currTerm < newTerm) {\n+            term.set(newTerm);\n+            setCharacter(NodeCharacter.FOLLOWER);\n+            setLeader(null);\n+            setLastHeartbeatReceivedTime(System.currentTimeMillis());\n+          }\n+        }\n       }\n-    }\n-    if (followerLastLogIndex == -1) {\n-      // if the follower does not have any logs, send from the first one\n-      followerLastLogIndex = 0;\n-    }\n \n-    AsyncClient client = connectNode(follower);\n-    if (client != null) {\n-      List<Log> logs;\n-      boolean allLogsValid;\n-      Snapshot snapshot = null;\n-      synchronized (logManager) {\n-        // check if the very first log has been snapshot\n-        allLogsValid = logManager.logValid(followerLastLogIndex);\n-        logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n-        if (!allLogsValid) {\n-          // if the first log has been snapshot, the snapshot should also be sent to the\n-          // follower, otherwise some data will be missing\n-          snapshot = logManager.getSnapshot();\n+      /**\n+       * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n+       * request is valid.\n+       * @param electionRequest\n+       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n+       *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+       */\n+      long processElectionRequest (ElectionRequest electionRequest){\n+\n+        long thatTerm = electionRequest.getTerm();\n+        long thatLastLogId = electionRequest.getLastLogIndex();\n+        long thatLastLogTerm = electionRequest.getLastLogTerm();\n+        logger\n+            .info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n+                name, thatTerm,\n+                thatLastLogId, thatLastLogTerm);\n+\n+        long lastLogIndex = logManager.getLastLogIndex();\n+        long lastLogTerm = logManager.getLastLogTerm();\n+\n+        synchronized (term) {\n+          long thisTerm = term.get();\n+          long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n+              thatLastLogTerm);\n+          if (resp == Response.RESPONSE_AGREE) {\n+            term.set(thatTerm);\n+            setCharacter(NodeCharacter.FOLLOWER);\n+            lastHeartbeatReceivedTime = System.currentTimeMillis();\n+            leader = electionRequest.getElector();\n+            // interrupt election\n+            term.notifyAll();\n+          }\n+          return resp;\n         }\n       }\n \n-      if (allLogsValid) {\n-        if (logger.isDebugEnabled()) {\n-          logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+      /**\n+       *  Reject the election if one of the four holds:\n+       *   1. the term of the candidate is no bigger than the voter's\n+       *   2. the lastLogTerm of the candidate is smaller than the voter's\n+       *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n+       *      smaller than the voter's\n+       *   Otherwise accept the election.\n+       * @param thisTerm\n+       * @param thisLastLogIndex\n+       * @param thisLastLogTerm\n+       * @param thatTerm\n+       * @param thatLastLogId\n+       * @param thatLastLogTerm\n+       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n+       * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+       */\n+      long verifyElector ( long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n+      long thatTerm, long thatLastLogId, long thatLastLogTerm){\n+        long response;\n+        if (thatTerm <= thisTerm) {\n+          response = thisTerm;\n+          logger.debug(\"{} rejected an election request, term:{}/{}\",\n+              name, thatTerm, thisTerm);\n+        } else if (thatLastLogTerm < thisLastLogTerm\n+            || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n+          logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n+              name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n+          response = Response.RESPONSE_LOG_MISMATCH;\n+        } else {\n+          logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n+              name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n+              thisLastLogTerm);\n+          response = Response.RESPONSE_AGREE;\n         }\n-        catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n-      } else {\n-        logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n-        catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n+        return response;\n       }\n-    } else {\n-      lastCatchUpResponseTime.remove(follower);\n-      logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n-    }\n-  }\n \n-  public String getName() {\n-    return name;\n-  }\n+      /**\n+       * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n+       * follower. If some of the logs are not in memory, also send the snapshot.\n+       * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n+       *\n+       * @param follower\n+       * @param followerLastLogIndex\n+       */\n+      public void catchUp (Node follower,long followerLastLogIndex){\n+        // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n+        // for one follower, there is at most one ongoing catch-up\n+        synchronized (follower) {\n+          // check if the last catch-up is still ongoing\n+          Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n+          if (lastCatchupResp != null\n+              && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n+            logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n+            return;\n+          } else {\n+            // record the start of the catch-up\n+            lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+          }\n+        }\n+        if (followerLastLogIndex == -1) {\n+          // if the follower does not have any logs, send from the first one\n+          followerLastLogIndex = 0;\n+        }\n \n-  /**\n-   * @return the header of the data raft group or null if this is in a meta group.\n-   */\n-  public Node getHeader() {\n-    return null;\n-  }\n+        AsyncClient client = connectNode(follower);\n+        if (client != null) {\n+          List<Log> logs;\n+          boolean allLogsValid;\n+          Snapshot snapshot = null;\n+          synchronized (logManager) {\n+            // check if the very first log has been snapshot\n+            allLogsValid = logManager.logValid(followerLastLogIndex);\n+            logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n+            if (!allLogsValid) {\n+              // if the first log has been snapshot, the snapshot should also be sent to the\n+              // follower, otherwise some data will be missing\n+              snapshot = logManager.getSnapshot();\n+            }\n+          }\n \n-  /**\n-   * Forward a plan to a node using the default client.\n-   *\n-   * @param plan\n-   * @param node\n-   * @param header must be set for data group communication, set to null for meta group\n-   *               communication\n-   * @return a TSStatus indicating if the forwarding is successful.\n-   */\n-  TSStatus forwardPlan(PhysicalPlan plan, Node node, Node header) {\n-    if (node == thisNode || node == null) {\n-      logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n-      return StatusUtils.NO_LEADER;\n-    }\n+          if (allLogsValid) {\n+            if (logger.isDebugEnabled()) {\n+              logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+            }\n+            catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n+          } else {\n+            logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n+            catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n+          }\n+        } else {\n+          lastCatchUpResponseTime.remove(follower);\n+          logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n+        }\n+      }\n \n-    logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n+      public String getName () {\n+        return name;\n+      }\n \n-    AsyncClient client = connectNode(node);\n-    if (client != null) {\n-      return forwardPlan(plan, client, node, header);\n-    }\n-    return StatusUtils.TIME_OUT;\n-  }\n+      /**\n+       * @return the header of the data raft group or null if this is in a meta group.\n+       */\n+      public Node getHeader () {\n+        return null;\n+      }\n \n-  /**\n-   * Forward a non-query plan to \"receiver\" using \"client\".\n-   * @param plan a non-query plan\n-   * @param client\n-   * @param receiver\n-   * @param header to determine which DataGroupMember of \"receiver\" will process the request.\n-   * @return a TSStatus indicating if the forwarding is successful.\n-   */\n-  TSStatus forwardPlan(PhysicalPlan plan, AsyncClient client, Node receiver, Node header) {\n-    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n-    DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n-    try {\n-      plan.serializeTo(dataOutputStream);\n-      AtomicReference<TSStatus> status = new AtomicReference<>();\n-      ExecutNonQueryReq req = new ExecutNonQueryReq();\n-      req.setPlanBytes(byteArrayOutputStream.toByteArray());\n-      if (header != null) {\n-        req.setHeader(header);\n+      /**\n+       <<<<<<< HEAD\n+       * Forward a plan to a node using the default client.\n+       *\n+       * @param plan\n+       * @param node\n+      =======\n+       * Forward a non-query plan to a node using the default client.\n+       * @param plan a non-query plan\n+       * @param node cannot be the local node\n+      >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79b40fbb1b17649d63ac64fdbc0c0fd5202d78dc"}, "originalPosition": 531}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyNDA1OA==", "bodyText": "Conflict marks.", "url": "https://github.com/apache/iotdb/pull/909#discussion_r395424058", "createdAt": "2020-03-20T03:24:02Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java", "diffHunk": "@@ -545,424 +550,487 @@ public Node getThisNode() {\n   }\n \n \n-  public void processValidHeartbeatResp(HeartbeatResponse response, Node receiver) {\n+    /**\n+     * Sub-classes will add their own process of HeartBeatResponse in this method.\n+     * @param response\n+     * @param receiver\n+     */\n+    public void processValidHeartbeatResp (HeartbeatResponse response, Node receiver){\n \n-  }\n-\n-  /**\n-   * The actions performed when the node wins in an election (becoming a leader).\n-   */\n-  public void onElectionWins() {\n-\n-  }\n-\n-  void processValidHeartbeatReq(HeartbeatRequest request, HeartbeatResponse response) {\n+    }\n \n-  }\n+    /**\n+     * The actions performed when the node wins in an election (becoming a leader).\n+     */\n+    public void onElectionWins () {\n \n-  /**\n-   * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n-   * reset heartbeat timer.\n-   * @param newTerm\n-   */\n-  public void retireFromLeader(long newTerm) {\n-    synchronized (term) {\n-      long currTerm = term.get();\n-      // confirm that the heartbeat of the new leader hasn't come\n-      if (currTerm < newTerm) {\n-        term.set(newTerm);\n-        setCharacter(NodeCharacter.FOLLOWER);\n-        setLeader(null);\n-        setLastHeartbeatReceivedTime(System.currentTimeMillis());\n-      }\n     }\n-  }\n-\n-  /**\n-   * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n-   * request is valid.\n-   * @param electionRequest\n-   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-   *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-   */\n-  long processElectionRequest(ElectionRequest electionRequest) {\n \n-    long thatTerm = electionRequest.getTerm();\n-    long thatLastLogId = electionRequest.getLastLogIndex();\n-    long thatLastLogTerm = electionRequest.getLastLogTerm();\n-    logger.info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n-        name, thatTerm,\n-        thatLastLogId, thatLastLogTerm);\n \n-    long lastLogIndex = logManager.getLastLogIndex();\n-    long lastLogTerm = logManager.getLastLogTerm();\n+      /**\n+       * Sub-classes will add their own process of HeartBeatRequest in this method.\n+       * @param request\n+       * @param response\n+       */\n+      void processValidHeartbeatReq (HeartbeatRequest request, HeartbeatResponse response){\n \n-    synchronized (term) {\n-      long thisTerm = term.get();\n-      long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n-          thatLastLogTerm);\n-      if (resp == Response.RESPONSE_AGREE) {\n-        term.set(thatTerm);\n-        setCharacter(NodeCharacter.FOLLOWER);\n-        lastHeartbeatReceivedTime = System.currentTimeMillis();\n-        leader = electionRequest.getElector();\n-        // interrupt election\n-        term.notifyAll();\n       }\n-      return resp;\n-    }\n-  }\n \n-  /**\n-   *  Reject the election if one of the four holds:\n-   *   1. the term of the candidate is no bigger than the voter's\n-   *   2. the lastLogTerm of the candidate is smaller than the voter's\n-   *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n-   *      smaller than the voter's\n-   *   Otherwise accept the election.\n-   * @param thisTerm\n-   * @param thisLastLogIndex\n-   * @param thisLastLogTerm\n-   * @param thatTerm\n-   * @param thatLastLogId\n-   * @param thatLastLogTerm\n-   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-   * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-   */\n-  long verifyElector(long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n-      long thatTerm, long thatLastLogId, long thatLastLogTerm) {\n-    long response;\n-    if (thatTerm <= thisTerm) {\n-      response = thisTerm;\n-      logger.debug(\"{} rejected an election request, term:{}/{}\",\n-          name, thatTerm, thisTerm);\n-    } else if (thatLastLogTerm < thisLastLogTerm\n-        || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n-      logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n-          name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n-      response = Response.RESPONSE_LOG_MISMATCH;\n-    } else {\n-      logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n-          name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n-          thisLastLogTerm);\n-      response = Response.RESPONSE_AGREE;\n-    }\n-    return response;\n-  }\n-\n-  /**\n-   * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n-   * follower. If some of the logs are not in memory, also send the snapshot.\n-   * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n-   *\n-   * @param follower\n-   * @param followerLastLogIndex\n-   */\n-  public void catchUp(Node follower, long followerLastLogIndex) {\n-    // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n-    // for one follower, there is at most one ongoing catch-up\n-    synchronized (follower) {\n-      // check if the last catch-up is still ongoing\n-      Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n-      if (lastCatchupResp != null\n-          && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n-        logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n-        return;\n-      } else {\n-        // record the start of the catch-up\n-        lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+      /**\n+       * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n+       * reset heartbeat timer.\n+       * @param newTerm\n+       */\n+      public void retireFromLeader ( long newTerm){\n+        synchronized (term) {\n+          long currTerm = term.get();\n+          // confirm that the heartbeat of the new leader hasn't come\n+          if (currTerm < newTerm) {\n+            term.set(newTerm);\n+            setCharacter(NodeCharacter.FOLLOWER);\n+            setLeader(null);\n+            setLastHeartbeatReceivedTime(System.currentTimeMillis());\n+          }\n+        }\n       }\n-    }\n-    if (followerLastLogIndex == -1) {\n-      // if the follower does not have any logs, send from the first one\n-      followerLastLogIndex = 0;\n-    }\n \n-    AsyncClient client = connectNode(follower);\n-    if (client != null) {\n-      List<Log> logs;\n-      boolean allLogsValid;\n-      Snapshot snapshot = null;\n-      synchronized (logManager) {\n-        // check if the very first log has been snapshot\n-        allLogsValid = logManager.logValid(followerLastLogIndex);\n-        logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n-        if (!allLogsValid) {\n-          // if the first log has been snapshot, the snapshot should also be sent to the\n-          // follower, otherwise some data will be missing\n-          snapshot = logManager.getSnapshot();\n+      /**\n+       * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n+       * request is valid.\n+       * @param electionRequest\n+       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n+       *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+       */\n+      long processElectionRequest (ElectionRequest electionRequest){\n+\n+        long thatTerm = electionRequest.getTerm();\n+        long thatLastLogId = electionRequest.getLastLogIndex();\n+        long thatLastLogTerm = electionRequest.getLastLogTerm();\n+        logger\n+            .info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n+                name, thatTerm,\n+                thatLastLogId, thatLastLogTerm);\n+\n+        long lastLogIndex = logManager.getLastLogIndex();\n+        long lastLogTerm = logManager.getLastLogTerm();\n+\n+        synchronized (term) {\n+          long thisTerm = term.get();\n+          long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n+              thatLastLogTerm);\n+          if (resp == Response.RESPONSE_AGREE) {\n+            term.set(thatTerm);\n+            setCharacter(NodeCharacter.FOLLOWER);\n+            lastHeartbeatReceivedTime = System.currentTimeMillis();\n+            leader = electionRequest.getElector();\n+            // interrupt election\n+            term.notifyAll();\n+          }\n+          return resp;\n         }\n       }\n \n-      if (allLogsValid) {\n-        if (logger.isDebugEnabled()) {\n-          logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+      /**\n+       *  Reject the election if one of the four holds:\n+       *   1. the term of the candidate is no bigger than the voter's\n+       *   2. the lastLogTerm of the candidate is smaller than the voter's\n+       *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n+       *      smaller than the voter's\n+       *   Otherwise accept the election.\n+       * @param thisTerm\n+       * @param thisLastLogIndex\n+       * @param thisLastLogTerm\n+       * @param thatTerm\n+       * @param thatLastLogId\n+       * @param thatLastLogTerm\n+       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n+       * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+       */\n+      long verifyElector ( long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n+      long thatTerm, long thatLastLogId, long thatLastLogTerm){\n+        long response;\n+        if (thatTerm <= thisTerm) {\n+          response = thisTerm;\n+          logger.debug(\"{} rejected an election request, term:{}/{}\",\n+              name, thatTerm, thisTerm);\n+        } else if (thatLastLogTerm < thisLastLogTerm\n+            || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n+          logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n+              name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n+          response = Response.RESPONSE_LOG_MISMATCH;\n+        } else {\n+          logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n+              name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n+              thisLastLogTerm);\n+          response = Response.RESPONSE_AGREE;\n         }\n-        catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n-      } else {\n-        logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n-        catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n+        return response;\n       }\n-    } else {\n-      lastCatchUpResponseTime.remove(follower);\n-      logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n-    }\n-  }\n \n-  public String getName() {\n-    return name;\n-  }\n+      /**\n+       * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n+       * follower. If some of the logs are not in memory, also send the snapshot.\n+       * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n+       *\n+       * @param follower\n+       * @param followerLastLogIndex\n+       */\n+      public void catchUp (Node follower,long followerLastLogIndex){\n+        // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n+        // for one follower, there is at most one ongoing catch-up\n+        synchronized (follower) {\n+          // check if the last catch-up is still ongoing\n+          Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n+          if (lastCatchupResp != null\n+              && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n+            logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n+            return;\n+          } else {\n+            // record the start of the catch-up\n+            lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+          }\n+        }\n+        if (followerLastLogIndex == -1) {\n+          // if the follower does not have any logs, send from the first one\n+          followerLastLogIndex = 0;\n+        }\n \n-  /**\n-   * @return the header of the data raft group or null if this is in a meta group.\n-   */\n-  public Node getHeader() {\n-    return null;\n-  }\n+        AsyncClient client = connectNode(follower);\n+        if (client != null) {\n+          List<Log> logs;\n+          boolean allLogsValid;\n+          Snapshot snapshot = null;\n+          synchronized (logManager) {\n+            // check if the very first log has been snapshot\n+            allLogsValid = logManager.logValid(followerLastLogIndex);\n+            logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n+            if (!allLogsValid) {\n+              // if the first log has been snapshot, the snapshot should also be sent to the\n+              // follower, otherwise some data will be missing\n+              snapshot = logManager.getSnapshot();\n+            }\n+          }\n \n-  /**\n-   * Forward a plan to a node using the default client.\n-   *\n-   * @param plan\n-   * @param node\n-   * @param header must be set for data group communication, set to null for meta group\n-   *               communication\n-   * @return a TSStatus indicating if the forwarding is successful.\n-   */\n-  TSStatus forwardPlan(PhysicalPlan plan, Node node, Node header) {\n-    if (node == thisNode || node == null) {\n-      logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n-      return StatusUtils.NO_LEADER;\n-    }\n+          if (allLogsValid) {\n+            if (logger.isDebugEnabled()) {\n+              logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+            }\n+            catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n+          } else {\n+            logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n+            catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n+          }\n+        } else {\n+          lastCatchUpResponseTime.remove(follower);\n+          logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n+        }\n+      }\n \n-    logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n+      public String getName () {\n+        return name;\n+      }\n \n-    AsyncClient client = connectNode(node);\n-    if (client != null) {\n-      return forwardPlan(plan, client, node, header);\n-    }\n-    return StatusUtils.TIME_OUT;\n-  }\n+      /**\n+       * @return the header of the data raft group or null if this is in a meta group.\n+       */\n+      public Node getHeader () {\n+        return null;\n+      }\n \n-  /**\n-   * Forward a non-query plan to \"receiver\" using \"client\".\n-   * @param plan a non-query plan\n-   * @param client\n-   * @param receiver\n-   * @param header to determine which DataGroupMember of \"receiver\" will process the request.\n-   * @return a TSStatus indicating if the forwarding is successful.\n-   */\n-  TSStatus forwardPlan(PhysicalPlan plan, AsyncClient client, Node receiver, Node header) {\n-    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n-    DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n-    try {\n-      plan.serializeTo(dataOutputStream);\n-      AtomicReference<TSStatus> status = new AtomicReference<>();\n-      ExecutNonQueryReq req = new ExecutNonQueryReq();\n-      req.setPlanBytes(byteArrayOutputStream.toByteArray());\n-      if (header != null) {\n-        req.setHeader(header);\n+      /**\n+       <<<<<<< HEAD\n+       * Forward a plan to a node using the default client.\n+       *\n+       * @param plan\n+       * @param node\n+      =======\n+       * Forward a non-query plan to a node using the default client.\n+       * @param plan a non-query plan\n+       * @param node cannot be the local node\n+      >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c\n+       * @param header must be set for data group communication, set to null for meta group\n+       *               communication\n+       * @return a TSStatus indicating if the forwarding is successful.\n+       */\n+      TSStatus forwardPlan (PhysicalPlan plan, Node node, Node header){\n+        if (node == thisNode || node == null) {\n+          logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n+          return StatusUtils.NO_LEADER;\n+        }\n+\n+        logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n+\n+        AsyncClient client = connectNode(node);\n+        if (client != null) {\n+          return forwardPlan(plan, client, node, header);\n+        }\n+        return StatusUtils.TIME_OUT;\n       }\n-      synchronized (status) {\n-        client.executeNonQueryPlan(req, new ForwardPlanHandler(status, plan, receiver));\n-        status.wait(RaftServer.connectionTimeoutInMS);\n+\n+      /**\n+       * Forward a non-query plan to \"receiver\" using \"client\".\n+       * @param plan a non-query plan\n+       * @param client\n+       * @param receiver\n+       * @param header to determine which DataGroupMember of \"receiver\" will process the request.\n+       * @return a TSStatus indicating if the forwarding is successful.\n+       */\n+      TSStatus forwardPlan (PhysicalPlan plan, AsyncClient client, Node receiver, Node header){\n+        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n+        try {\n+          plan.serializeTo(dataOutputStream);\n+          AtomicReference<TSStatus> status = new AtomicReference<>();\n+          ExecutNonQueryReq req = new ExecutNonQueryReq();\n+          req.setPlanBytes(byteArrayOutputStream.toByteArray());\n+          if (header != null) {\n+            req.setHeader(header);\n+          }\n+          synchronized (status) {\n+            client.executeNonQueryPlan(req, new ForwardPlanHandler(status, plan, receiver));\n+            status.wait(RaftServer.connectionTimeoutInMS);\n+          }\n+          return status.get() == null ? StatusUtils.TIME_OUT : status.get();\n+        } catch (IOException | TException e) {\n+          TSStatus status = StatusUtils.INTERNAL_ERROR.deepCopy();\n+          status.setMessage(e.getMessage());\n+          logger\n+              .error(\"{}: encountered an error when forwarding {} to {}\", name, plan, receiver, e);\n+          return status;\n+        } catch (InterruptedException e) {\n+          return StatusUtils.TIME_OUT;\n+        }\n       }\n-      return status.get() == null ? StatusUtils.TIME_OUT : status.get();\n-    } catch (IOException | TException e) {\n-      TSStatus status = StatusUtils.INTERNAL_ERROR.deepCopy();\n-      status.setMessage(e.getMessage());\n-      logger.error(\"{}: encountered an error when forwarding {} to {}\", name, plan, receiver, e);\n-      return status;\n-    } catch (InterruptedException e) {\n-      return StatusUtils.TIME_OUT;\n-    }\n-  }\n \n-  /**\n-   * Only the group leader can call this method. Will commit the log locally and send it to\n-   * followers\n-   *\n-   * @param plan\n-   * @return OK if over half of the followers accept the log or null if the leadership is lost\n-   * during the appending\n-   */\n-  TSStatus processPlanLocally(PhysicalPlan plan) {\n-    logger.debug(\"{}: Processing plan {}\", name, plan);\n-    if (readOnly) {\n-      return StatusUtils.NODE_READ_ONLY;\n-    }\n+      /**\n+       <<<<<<< HEAD\n+       * Only the group leader can call this method. Will commit the log locally and send it to\n+       * followers\n+       *\n+       =======\n+       * Create a log for \"plan\" and append it locally and to all followers.\n+       * Only the group leader can call this method.\n+       * Will commit the log locally and send it to followers\n+       >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79b40fbb1b17649d63ac64fdbc0c0fd5202d78dc"}, "originalPosition": 621}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyNDA4Ng==", "bodyText": "Conflict marks.", "url": "https://github.com/apache/iotdb/pull/909#discussion_r395424086", "createdAt": "2020-03-20T03:24:13Z", "author": {"login": "jt2594838"}, "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java", "diffHunk": "@@ -545,424 +550,487 @@ public Node getThisNode() {\n   }\n \n \n-  public void processValidHeartbeatResp(HeartbeatResponse response, Node receiver) {\n+    /**\n+     * Sub-classes will add their own process of HeartBeatResponse in this method.\n+     * @param response\n+     * @param receiver\n+     */\n+    public void processValidHeartbeatResp (HeartbeatResponse response, Node receiver){\n \n-  }\n-\n-  /**\n-   * The actions performed when the node wins in an election (becoming a leader).\n-   */\n-  public void onElectionWins() {\n-\n-  }\n-\n-  void processValidHeartbeatReq(HeartbeatRequest request, HeartbeatResponse response) {\n+    }\n \n-  }\n+    /**\n+     * The actions performed when the node wins in an election (becoming a leader).\n+     */\n+    public void onElectionWins () {\n \n-  /**\n-   * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n-   * reset heartbeat timer.\n-   * @param newTerm\n-   */\n-  public void retireFromLeader(long newTerm) {\n-    synchronized (term) {\n-      long currTerm = term.get();\n-      // confirm that the heartbeat of the new leader hasn't come\n-      if (currTerm < newTerm) {\n-        term.set(newTerm);\n-        setCharacter(NodeCharacter.FOLLOWER);\n-        setLeader(null);\n-        setLastHeartbeatReceivedTime(System.currentTimeMillis());\n-      }\n     }\n-  }\n-\n-  /**\n-   * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n-   * request is valid.\n-   * @param electionRequest\n-   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-   *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-   */\n-  long processElectionRequest(ElectionRequest electionRequest) {\n \n-    long thatTerm = electionRequest.getTerm();\n-    long thatLastLogId = electionRequest.getLastLogIndex();\n-    long thatLastLogTerm = electionRequest.getLastLogTerm();\n-    logger.info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n-        name, thatTerm,\n-        thatLastLogId, thatLastLogTerm);\n \n-    long lastLogIndex = logManager.getLastLogIndex();\n-    long lastLogTerm = logManager.getLastLogTerm();\n+      /**\n+       * Sub-classes will add their own process of HeartBeatRequest in this method.\n+       * @param request\n+       * @param response\n+       */\n+      void processValidHeartbeatReq (HeartbeatRequest request, HeartbeatResponse response){\n \n-    synchronized (term) {\n-      long thisTerm = term.get();\n-      long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n-          thatLastLogTerm);\n-      if (resp == Response.RESPONSE_AGREE) {\n-        term.set(thatTerm);\n-        setCharacter(NodeCharacter.FOLLOWER);\n-        lastHeartbeatReceivedTime = System.currentTimeMillis();\n-        leader = electionRequest.getElector();\n-        // interrupt election\n-        term.notifyAll();\n       }\n-      return resp;\n-    }\n-  }\n \n-  /**\n-   *  Reject the election if one of the four holds:\n-   *   1. the term of the candidate is no bigger than the voter's\n-   *   2. the lastLogTerm of the candidate is smaller than the voter's\n-   *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n-   *      smaller than the voter's\n-   *   Otherwise accept the election.\n-   * @param thisTerm\n-   * @param thisLastLogIndex\n-   * @param thisLastLogTerm\n-   * @param thatTerm\n-   * @param thatLastLogId\n-   * @param thatLastLogTerm\n-   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-   * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-   */\n-  long verifyElector(long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n-      long thatTerm, long thatLastLogId, long thatLastLogTerm) {\n-    long response;\n-    if (thatTerm <= thisTerm) {\n-      response = thisTerm;\n-      logger.debug(\"{} rejected an election request, term:{}/{}\",\n-          name, thatTerm, thisTerm);\n-    } else if (thatLastLogTerm < thisLastLogTerm\n-        || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n-      logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n-          name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n-      response = Response.RESPONSE_LOG_MISMATCH;\n-    } else {\n-      logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n-          name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n-          thisLastLogTerm);\n-      response = Response.RESPONSE_AGREE;\n-    }\n-    return response;\n-  }\n-\n-  /**\n-   * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n-   * follower. If some of the logs are not in memory, also send the snapshot.\n-   * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n-   *\n-   * @param follower\n-   * @param followerLastLogIndex\n-   */\n-  public void catchUp(Node follower, long followerLastLogIndex) {\n-    // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n-    // for one follower, there is at most one ongoing catch-up\n-    synchronized (follower) {\n-      // check if the last catch-up is still ongoing\n-      Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n-      if (lastCatchupResp != null\n-          && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n-        logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n-        return;\n-      } else {\n-        // record the start of the catch-up\n-        lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+      /**\n+       * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n+       * reset heartbeat timer.\n+       * @param newTerm\n+       */\n+      public void retireFromLeader ( long newTerm){\n+        synchronized (term) {\n+          long currTerm = term.get();\n+          // confirm that the heartbeat of the new leader hasn't come\n+          if (currTerm < newTerm) {\n+            term.set(newTerm);\n+            setCharacter(NodeCharacter.FOLLOWER);\n+            setLeader(null);\n+            setLastHeartbeatReceivedTime(System.currentTimeMillis());\n+          }\n+        }\n       }\n-    }\n-    if (followerLastLogIndex == -1) {\n-      // if the follower does not have any logs, send from the first one\n-      followerLastLogIndex = 0;\n-    }\n \n-    AsyncClient client = connectNode(follower);\n-    if (client != null) {\n-      List<Log> logs;\n-      boolean allLogsValid;\n-      Snapshot snapshot = null;\n-      synchronized (logManager) {\n-        // check if the very first log has been snapshot\n-        allLogsValid = logManager.logValid(followerLastLogIndex);\n-        logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n-        if (!allLogsValid) {\n-          // if the first log has been snapshot, the snapshot should also be sent to the\n-          // follower, otherwise some data will be missing\n-          snapshot = logManager.getSnapshot();\n+      /**\n+       * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n+       * request is valid.\n+       * @param electionRequest\n+       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n+       *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+       */\n+      long processElectionRequest (ElectionRequest electionRequest){\n+\n+        long thatTerm = electionRequest.getTerm();\n+        long thatLastLogId = electionRequest.getLastLogIndex();\n+        long thatLastLogTerm = electionRequest.getLastLogTerm();\n+        logger\n+            .info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n+                name, thatTerm,\n+                thatLastLogId, thatLastLogTerm);\n+\n+        long lastLogIndex = logManager.getLastLogIndex();\n+        long lastLogTerm = logManager.getLastLogTerm();\n+\n+        synchronized (term) {\n+          long thisTerm = term.get();\n+          long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n+              thatLastLogTerm);\n+          if (resp == Response.RESPONSE_AGREE) {\n+            term.set(thatTerm);\n+            setCharacter(NodeCharacter.FOLLOWER);\n+            lastHeartbeatReceivedTime = System.currentTimeMillis();\n+            leader = electionRequest.getElector();\n+            // interrupt election\n+            term.notifyAll();\n+          }\n+          return resp;\n         }\n       }\n \n-      if (allLogsValid) {\n-        if (logger.isDebugEnabled()) {\n-          logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+      /**\n+       *  Reject the election if one of the four holds:\n+       *   1. the term of the candidate is no bigger than the voter's\n+       *   2. the lastLogTerm of the candidate is smaller than the voter's\n+       *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n+       *      smaller than the voter's\n+       *   Otherwise accept the election.\n+       * @param thisTerm\n+       * @param thisLastLogIndex\n+       * @param thisLastLogTerm\n+       * @param thatTerm\n+       * @param thatLastLogId\n+       * @param thatLastLogTerm\n+       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n+       * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+       */\n+      long verifyElector ( long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n+      long thatTerm, long thatLastLogId, long thatLastLogTerm){\n+        long response;\n+        if (thatTerm <= thisTerm) {\n+          response = thisTerm;\n+          logger.debug(\"{} rejected an election request, term:{}/{}\",\n+              name, thatTerm, thisTerm);\n+        } else if (thatLastLogTerm < thisLastLogTerm\n+            || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n+          logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n+              name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n+          response = Response.RESPONSE_LOG_MISMATCH;\n+        } else {\n+          logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n+              name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n+              thisLastLogTerm);\n+          response = Response.RESPONSE_AGREE;\n         }\n-        catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n-      } else {\n-        logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n-        catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n+        return response;\n       }\n-    } else {\n-      lastCatchUpResponseTime.remove(follower);\n-      logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n-    }\n-  }\n \n-  public String getName() {\n-    return name;\n-  }\n+      /**\n+       * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n+       * follower. If some of the logs are not in memory, also send the snapshot.\n+       * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n+       *\n+       * @param follower\n+       * @param followerLastLogIndex\n+       */\n+      public void catchUp (Node follower,long followerLastLogIndex){\n+        // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n+        // for one follower, there is at most one ongoing catch-up\n+        synchronized (follower) {\n+          // check if the last catch-up is still ongoing\n+          Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n+          if (lastCatchupResp != null\n+              && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n+            logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n+            return;\n+          } else {\n+            // record the start of the catch-up\n+            lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+          }\n+        }\n+        if (followerLastLogIndex == -1) {\n+          // if the follower does not have any logs, send from the first one\n+          followerLastLogIndex = 0;\n+        }\n \n-  /**\n-   * @return the header of the data raft group or null if this is in a meta group.\n-   */\n-  public Node getHeader() {\n-    return null;\n-  }\n+        AsyncClient client = connectNode(follower);\n+        if (client != null) {\n+          List<Log> logs;\n+          boolean allLogsValid;\n+          Snapshot snapshot = null;\n+          synchronized (logManager) {\n+            // check if the very first log has been snapshot\n+            allLogsValid = logManager.logValid(followerLastLogIndex);\n+            logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n+            if (!allLogsValid) {\n+              // if the first log has been snapshot, the snapshot should also be sent to the\n+              // follower, otherwise some data will be missing\n+              snapshot = logManager.getSnapshot();\n+            }\n+          }\n \n-  /**\n-   * Forward a plan to a node using the default client.\n-   *\n-   * @param plan\n-   * @param node\n-   * @param header must be set for data group communication, set to null for meta group\n-   *               communication\n-   * @return a TSStatus indicating if the forwarding is successful.\n-   */\n-  TSStatus forwardPlan(PhysicalPlan plan, Node node, Node header) {\n-    if (node == thisNode || node == null) {\n-      logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n-      return StatusUtils.NO_LEADER;\n-    }\n+          if (allLogsValid) {\n+            if (logger.isDebugEnabled()) {\n+              logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+            }\n+            catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n+          } else {\n+            logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n+            catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n+          }\n+        } else {\n+          lastCatchUpResponseTime.remove(follower);\n+          logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n+        }\n+      }\n \n-    logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n+      public String getName () {\n+        return name;\n+      }\n \n-    AsyncClient client = connectNode(node);\n-    if (client != null) {\n-      return forwardPlan(plan, client, node, header);\n-    }\n-    return StatusUtils.TIME_OUT;\n-  }\n+      /**\n+       * @return the header of the data raft group or null if this is in a meta group.\n+       */\n+      public Node getHeader () {\n+        return null;\n+      }\n \n-  /**\n-   * Forward a non-query plan to \"receiver\" using \"client\".\n-   * @param plan a non-query plan\n-   * @param client\n-   * @param receiver\n-   * @param header to determine which DataGroupMember of \"receiver\" will process the request.\n-   * @return a TSStatus indicating if the forwarding is successful.\n-   */\n-  TSStatus forwardPlan(PhysicalPlan plan, AsyncClient client, Node receiver, Node header) {\n-    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n-    DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n-    try {\n-      plan.serializeTo(dataOutputStream);\n-      AtomicReference<TSStatus> status = new AtomicReference<>();\n-      ExecutNonQueryReq req = new ExecutNonQueryReq();\n-      req.setPlanBytes(byteArrayOutputStream.toByteArray());\n-      if (header != null) {\n-        req.setHeader(header);\n+      /**\n+       <<<<<<< HEAD\n+       * Forward a plan to a node using the default client.\n+       *\n+       * @param plan\n+       * @param node\n+      =======\n+       * Forward a non-query plan to a node using the default client.\n+       * @param plan a non-query plan\n+       * @param node cannot be the local node\n+      >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c\n+       * @param header must be set for data group communication, set to null for meta group\n+       *               communication\n+       * @return a TSStatus indicating if the forwarding is successful.\n+       */\n+      TSStatus forwardPlan (PhysicalPlan plan, Node node, Node header){\n+        if (node == thisNode || node == null) {\n+          logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n+          return StatusUtils.NO_LEADER;\n+        }\n+\n+        logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n+\n+        AsyncClient client = connectNode(node);\n+        if (client != null) {\n+          return forwardPlan(plan, client, node, header);\n+        }\n+        return StatusUtils.TIME_OUT;\n       }\n-      synchronized (status) {\n-        client.executeNonQueryPlan(req, new ForwardPlanHandler(status, plan, receiver));\n-        status.wait(RaftServer.connectionTimeoutInMS);\n+\n+      /**\n+       * Forward a non-query plan to \"receiver\" using \"client\".\n+       * @param plan a non-query plan\n+       * @param client\n+       * @param receiver\n+       * @param header to determine which DataGroupMember of \"receiver\" will process the request.\n+       * @return a TSStatus indicating if the forwarding is successful.\n+       */\n+      TSStatus forwardPlan (PhysicalPlan plan, AsyncClient client, Node receiver, Node header){\n+        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n+        try {\n+          plan.serializeTo(dataOutputStream);\n+          AtomicReference<TSStatus> status = new AtomicReference<>();\n+          ExecutNonQueryReq req = new ExecutNonQueryReq();\n+          req.setPlanBytes(byteArrayOutputStream.toByteArray());\n+          if (header != null) {\n+            req.setHeader(header);\n+          }\n+          synchronized (status) {\n+            client.executeNonQueryPlan(req, new ForwardPlanHandler(status, plan, receiver));\n+            status.wait(RaftServer.connectionTimeoutInMS);\n+          }\n+          return status.get() == null ? StatusUtils.TIME_OUT : status.get();\n+        } catch (IOException | TException e) {\n+          TSStatus status = StatusUtils.INTERNAL_ERROR.deepCopy();\n+          status.setMessage(e.getMessage());\n+          logger\n+              .error(\"{}: encountered an error when forwarding {} to {}\", name, plan, receiver, e);\n+          return status;\n+        } catch (InterruptedException e) {\n+          return StatusUtils.TIME_OUT;\n+        }\n       }\n-      return status.get() == null ? StatusUtils.TIME_OUT : status.get();\n-    } catch (IOException | TException e) {\n-      TSStatus status = StatusUtils.INTERNAL_ERROR.deepCopy();\n-      status.setMessage(e.getMessage());\n-      logger.error(\"{}: encountered an error when forwarding {} to {}\", name, plan, receiver, e);\n-      return status;\n-    } catch (InterruptedException e) {\n-      return StatusUtils.TIME_OUT;\n-    }\n-  }\n \n-  /**\n-   * Only the group leader can call this method. Will commit the log locally and send it to\n-   * followers\n-   *\n-   * @param plan\n-   * @return OK if over half of the followers accept the log or null if the leadership is lost\n-   * during the appending\n-   */\n-  TSStatus processPlanLocally(PhysicalPlan plan) {\n-    logger.debug(\"{}: Processing plan {}\", name, plan);\n-    if (readOnly) {\n-      return StatusUtils.NODE_READ_ONLY;\n-    }\n+      /**\n+       <<<<<<< HEAD\n+       * Only the group leader can call this method. Will commit the log locally and send it to\n+       * followers\n+       *\n+       =======\n+       * Create a log for \"plan\" and append it locally and to all followers.\n+       * Only the group leader can call this method.\n+       * Will commit the log locally and send it to followers\n+       >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c\n+       * @param plan\n+       * @return OK if over half of the followers accept the log or null if the leadership is lost\n+       * during the appending\n+       */\n+      TSStatus processPlanLocally (PhysicalPlan plan){\n+        logger.debug(\"{}: Processing plan {}\", name, plan);\n+        if (readOnly) {\n+          return StatusUtils.NODE_READ_ONLY;\n+        }\n \n-    PhysicalPlanLog log = new PhysicalPlanLog();\n-    // assign term and index to the new log and append it\n-    synchronized (logManager) {\n-      log.setCurrLogTerm(getTerm().get());\n-      log.setPreviousLogIndex(logManager.getLastLogIndex());\n-      log.setPreviousLogTerm(logManager.getLastLogTerm());\n-      log.setCurrLogIndex(logManager.getLastLogIndex() + 1);\n+        PhysicalPlanLog log = new PhysicalPlanLog();\n+        // assign term and index to the new log and append it\n+        synchronized (logManager) {\n+          log.setCurrLogTerm(getTerm().get());\n+          log.setPreviousLogIndex(logManager.getLastLogIndex());\n+          log.setPreviousLogTerm(logManager.getLastLogTerm());\n+          log.setCurrLogIndex(logManager.getLastLogIndex() + 1);\n \n-      log.setPlan(plan);\n-      logManager.appendLog(log);\n-    }\n+          log.setPlan(plan);\n+          logManager.appendLog(log);\n+        }\n \n-    if (appendLogInGroup(log)) {\n-      return StatusUtils.OK;\n-    }\n-    return null;\n-  }\n+        if (appendLogInGroup(log)) {\n+          return StatusUtils.OK;\n+        }\n+        return null;\n+      }\n \n-  /**\n-   * if the node is not a leader, will send it to the leader. Otherwise do it locally (whether to\n-   * send it to followers depends on the implementation of executeNonQuery()).\n-   *\n-   * @param request\n-   * @param resultHandler\n-   */\n-  public void executeNonQueryPlan(ExecutNonQueryReq request,\n-      AsyncMethodCallback<TSStatus> resultHandler) {\n-    if (character != NodeCharacter.LEADER) {\n-      // forward the plan to the leader\n-      AsyncClient client = connectNode(leader);\n-      if (client != null) {\n+      /**\n+       <<<<<<< HEAD\n+       * if the node is not a leader, will send it to the leader. Otherwise do it locally (whether to\n+       * send it to followers depends on the implementation of executeNonQuery()).\n+       *\n+       =======\n+       * Append a log to all followers in the group until half of them accept the log or the\n+       * leadership is lost.\n+       * @param log\n+       * @return true if the log is accepted by the quorum of the group, false otherwise", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79b40fbb1b17649d63ac64fdbc0c0fd5202d78dc"}, "originalPosition": 687}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fcb9f0786aee2f36e1b224931059371cfc9b465", "author": {"user": {"login": "Ring-k", "name": null}}, "url": "https://github.com/apache/iotdb/commit/5fcb9f0786aee2f36e1b224931059371cfc9b465", "committedDate": "2020-03-20T03:36:02Z", "message": "fix conflict in RaftMember"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3187, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}