{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2MjcwNzEz", "number": 821, "reviewThreads": {"totalCount": 51, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwODoyNjozM1rODgmeFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjoyMToxNFrODkPytQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTExMzE2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwODoyNjozM1rOFq5A4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOTo0Njo0NFrOFq7m0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxODYyNQ==", "bodyText": "what's this for?", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380518625", "createdAt": "2020-02-18T08:26:33Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "diffHunk": "@@ -22,10 +22,15 @@\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.Map;\n+\n+import com.sun.rowset.internal.Row;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU2MTEwNg==", "bodyText": "Removed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380561106", "createdAt": "2020-02-18T09:46:44Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "diffHunk": "@@ -22,10 +22,15 @@\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.Map;\n+\n+import com.sun.rowset.internal.Row;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxODYyNQ=="}, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTExNDk3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwODoyNzoxMlrOFq5B9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOTo0Njo1M1rOFq7nIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxODkwMQ==", "bodyText": "this import is not used, please remove it.", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380518901", "createdAt": "2020-02-18T08:27:12Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "diffHunk": "@@ -22,10 +22,15 @@\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.Map;\n+\n+import com.sun.rowset.internal.Row;\n import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU2MTE4NQ==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380561185", "createdAt": "2020-02-18T09:46:53Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "diffHunk": "@@ -22,10 +22,15 @@\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.Map;\n+\n+import com.sun.rowset.internal.Row;\n import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxODkwMQ=="}, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTE5Nzk0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwODo1NDo1M1rOFq50eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzoxNDo1NlrOFrLJRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzMTgzMw==", "bodyText": "You can use the chunk and page statistics if possible. The code will be like as:\n        while (seriesReader.hasNextChunk()) {\n            if (seriesReader.canUseCurrentChunkStatistics()) {\n                if (seriesReader.currentChunkStatistics().getEndTime() > maxTime) {\n                    maxTime = seriesReader.currentChunkStatistics().getEndTime();\n                    queryResult.setPairResult(maxTime, seriesReader.currentChunkStatistics().getLastValue(), tsDataType);\n                }\n                seriesReader.skipCurrentChunk();\n                continue;\n            }\n            while (seriesReader.hasNextPage()) {\n                if (seriesReader.canUseCurrentPageStatistics()) {\n                    if (seriesReader.currentPageStatistics().getEndTime() > maxTime) {\n                        maxTime = seriesReader.currentPageStatistics().getEndTime();\n                        queryResult.setPairResult(maxTime, seriesReader.currentPageStatistics().getLastValue(), tsDataType);\n                    }\n                    seriesReader.skipCurrentPage();\n                    continue;\n                }\n                // cal by page data\n                while (seriesReader.hasNextOverlappedPage()) {\n                    BatchData nextOverlappedPageData = seriesReader.nextOverlappedPage();\n                    int maxIndex = nextOverlappedPageData.length() - 1;\n                    if (maxIndex < 0) {\n                        continue;\n                    }\n                    long time = nextOverlappedPageData.getTimeByIndex(maxIndex);\n                    if (time > maxTime) {\n                        maxTime = time;\n                        queryResult.setPairResult(maxTime, nextOverlappedPageData.getValueInTimestamp(time), tsDataType);\n                    }\n                    nextOverlappedPageData.resetBatchData();\n                }\n            }\n        }", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380531833", "createdAt": "2020-02-18T08:54:53Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.constant.SQLConstant;\n+import org.apache.iotdb.db.qp.physical.crud.AggregationPlan;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.factory.AggreResultFactory;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.omg.CORBA.TIMEOUT;\n+\n+import java.io.IOException;\n+import java.sql.Time;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+    private List<Path> selectedSeries;\n+    private List<TSDataType> dataTypes;\n+\n+    public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+        this.selectedSeries = lastQueryPlan.getPaths();\n+        this.dataTypes = lastQueryPlan.getDataTypes();\n+    }\n+\n+    /**\n+     * execute last function\n+     *\n+     * @param context query context\n+     */\n+    public QueryDataSet execute(QueryContext context)\n+            throws StorageEngineException, IOException, QueryProcessException {\n+\n+        List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+        for (int i = 0; i < selectedSeries.size(); i++) {\n+            LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+            lastQueryResultList.add(lastQueryResult);\n+        }\n+\n+        RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);\n+        SingleDataSet dataSet = new SingleDataSet(selectedSeries, dataTypes);\n+        dataSet.setRecord(resultRecord);\n+        return dataSet;\n+    }\n+\n+    /**\n+     * get aggregation result for one series\n+     *\n+     * @param context query context\n+     * @return AggregateResult list\n+     */\n+    private LastQueryResult calculateLastPairForOneSeries(\n+            Path seriesPath, TSDataType tsDataType,\n+            QueryContext context)\n+            throws IOException, QueryProcessException, StorageEngineException {\n+        LastQueryResult queryResult = new LastQueryResult();\n+        MNode node = null;\n+        try {\n+            node = MManager.getInstance().getNodeByPathFromCache(seriesPath.toString());\n+        } catch (PathException e) {\n+            throw new QueryProcessException(e);\n+        } catch (CacheException e) {\n+            throw new QueryProcessException(e.getMessage());\n+        }\n+        if (node.getCachedLast() != null) {\n+            queryResult.setPairResult(node.getCachedLast());\n+            return queryResult;\n+        }\n+\n+        // construct series reader without value filter\n+        Filter timeFilter = null;\n+        IAggregateReader seriesReader = new SeriesAggregateReader(\n+                seriesPath, tsDataType, context, QueryResourceManager.getInstance()\n+                .getQueryDataSource(seriesPath, context, timeFilter), timeFilter, null);\n+\n+        long maxTime = Long.MIN_VALUE;\n+        while (seriesReader.hasNextChunk()) {\n+            while (seriesReader.hasNextPage()) {\n+                // cal by page data\n+                while (seriesReader.hasNextOverlappedPage()) {\n+                    BatchData nextOverlappedPageData = seriesReader.nextOverlappedPage();\n+                    int maxIndex = nextOverlappedPageData.length() - 1;\n+                    if (maxIndex < 0) {\n+                        continue;\n+                    }\n+                    long time = nextOverlappedPageData.getTimeByIndex(maxIndex);\n+                    if (time > maxTime) {\n+                        maxTime = time;\n+                        queryResult.setPairResult(maxTime, nextOverlappedPageData.getValueInTimestamp(time), tsDataType);\n+                    }\n+                    nextOverlappedPageData.resetBatchData();\n+                }\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxNTY4NA==", "bodyText": "Yes, adopted", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380815684", "createdAt": "2020-02-18T17:14:56Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.constant.SQLConstant;\n+import org.apache.iotdb.db.qp.physical.crud.AggregationPlan;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.factory.AggreResultFactory;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.omg.CORBA.TIMEOUT;\n+\n+import java.io.IOException;\n+import java.sql.Time;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+    private List<Path> selectedSeries;\n+    private List<TSDataType> dataTypes;\n+\n+    public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+        this.selectedSeries = lastQueryPlan.getPaths();\n+        this.dataTypes = lastQueryPlan.getDataTypes();\n+    }\n+\n+    /**\n+     * execute last function\n+     *\n+     * @param context query context\n+     */\n+    public QueryDataSet execute(QueryContext context)\n+            throws StorageEngineException, IOException, QueryProcessException {\n+\n+        List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+        for (int i = 0; i < selectedSeries.size(); i++) {\n+            LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+            lastQueryResultList.add(lastQueryResult);\n+        }\n+\n+        RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);\n+        SingleDataSet dataSet = new SingleDataSet(selectedSeries, dataTypes);\n+        dataSet.setRecord(resultRecord);\n+        return dataSet;\n+    }\n+\n+    /**\n+     * get aggregation result for one series\n+     *\n+     * @param context query context\n+     * @return AggregateResult list\n+     */\n+    private LastQueryResult calculateLastPairForOneSeries(\n+            Path seriesPath, TSDataType tsDataType,\n+            QueryContext context)\n+            throws IOException, QueryProcessException, StorageEngineException {\n+        LastQueryResult queryResult = new LastQueryResult();\n+        MNode node = null;\n+        try {\n+            node = MManager.getInstance().getNodeByPathFromCache(seriesPath.toString());\n+        } catch (PathException e) {\n+            throw new QueryProcessException(e);\n+        } catch (CacheException e) {\n+            throw new QueryProcessException(e.getMessage());\n+        }\n+        if (node.getCachedLast() != null) {\n+            queryResult.setPairResult(node.getCachedLast());\n+            return queryResult;\n+        }\n+\n+        // construct series reader without value filter\n+        Filter timeFilter = null;\n+        IAggregateReader seriesReader = new SeriesAggregateReader(\n+                seriesPath, tsDataType, context, QueryResourceManager.getInstance()\n+                .getQueryDataSource(seriesPath, context, timeFilter), timeFilter, null);\n+\n+        long maxTime = Long.MIN_VALUE;\n+        while (seriesReader.hasNextChunk()) {\n+            while (seriesReader.hasNextPage()) {\n+                // cal by page data\n+                while (seriesReader.hasNextOverlappedPage()) {\n+                    BatchData nextOverlappedPageData = seriesReader.nextOverlappedPage();\n+                    int maxIndex = nextOverlappedPageData.length() - 1;\n+                    if (maxIndex < 0) {\n+                        continue;\n+                    }\n+                    long time = nextOverlappedPageData.getTimeByIndex(maxIndex);\n+                    if (time > maxTime) {\n+                        maxTime = time;\n+                        queryResult.setPairResult(maxTime, nextOverlappedPageData.getValueInTimestamp(time), tsDataType);\n+                    }\n+                    nextOverlappedPageData.resetBatchData();\n+                }\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzMTgzMw=="}, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTIwMzI4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwODo1NjoyNlrOFq53ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOTo0NzoxMlrOFq7nzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzMjYzOA==", "bodyText": "A lot of imports are not used. You should check that and delete them", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380532638", "createdAt": "2020-02-18T08:56:26Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.constant.SQLConstant;\n+import org.apache.iotdb.db.qp.physical.crud.AggregationPlan;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.factory.AggreResultFactory;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.omg.CORBA.TIMEOUT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU2MTM1Nw==", "bodyText": "Fixed, thanks", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380561357", "createdAt": "2020-02-18T09:47:12Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.constant.SQLConstant;\n+import org.apache.iotdb.db.qp.physical.crud.AggregationPlan;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.factory.AggreResultFactory;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.omg.CORBA.TIMEOUT;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzMjYzOA=="}, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTIzNTc5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOTowNjowM1rOFq6MAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzoyNTo0OFrOFrLhLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNzg1OA==", "bodyText": "It is not suitable to put the updateMNodeLastValues method in the InsertPlan.\nYou can update the last value in the before loop, there you already got the measurementNode.", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380537858", "createdAt": "2020-02-18T09:06:03Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -680,6 +674,7 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       }\n       insertPlan.setDataTypes(dataTypes);\n       storageEngine.insert(insertPlan);\n+      insertPlan.updateMNodeLastValues(node);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgyMTgwNQ==", "bodyText": "The update function is moved into MNode structure.\nI added a loop to update the last value after storageEngine.insert(). It is possible that insert() could fail and throw exceptions. In such case the last value cache will not be updated.", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380821805", "createdAt": "2020-02-18T17:25:48Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -680,6 +674,7 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       }\n       insertPlan.setDataTypes(dataTypes);\n       storageEngine.insert(insertPlan);\n+      insertPlan.updateMNodeLastValues(node);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNzg1OA=="}, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTIzODE1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOTowNjo0N1rOFq6NdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOTowNjo0N1rOFq6NdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzODIyOQ==", "bodyText": "The same as before", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380538229", "createdAt": "2020-02-18T09:06:47Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -772,8 +767,9 @@ private void checkPathExists(MNode node, String fullPath, MeasurementSchema sche\n                   measurementNode.getSchema().getType()));\n         }\n       }\n-      return storageEngine.insertBatch(batchInsertPlan);\n-\n+      Integer[] results = storageEngine.insertBatch(batchInsertPlan);\n+      batchInsertPlan.updateMNodeLastValues(node);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTI0NDc3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOTowODo1M1rOFq6RnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMDo1MTo0OFrOFq91IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzOTI5Mw==", "bodyText": "It's better to add it to the last, because you don't know whether the programmers are using the enum's ordinal() function", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380539293", "createdAt": "2020-02-18T09:08:53Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java", "diffHunk": "@@ -68,7 +68,7 @@ public String toString() {\n   public enum OperatorType {\n     SFW, JOIN, UNION, FILTER, GROUPBY, ORDERBY, LIMIT, SELECT, SEQTABLESCAN, HASHTABLESCAN,\n     MERGEJOIN, FILEREAD, NULL, TABLESCAN, UPDATE, INSERT, BATCHINSERT, DELETE, BASIC_FUNC, IN, QUERY, MERGEQUERY,\n-    AGGREGATION, AUTHOR, FROM, FUNC, LOADDATA, METADATA, PROPERTY, INDEX, INDEXQUERY, FILL,\n+    AGGREGATION, AUTHOR, FROM, FUNC, LOADDATA, METADATA, PROPERTY, INDEX, INDEXQUERY, FILL, LAST,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU5NzUzNg==", "bodyText": "Modified", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380597536", "createdAt": "2020-02-18T10:51:48Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java", "diffHunk": "@@ -68,7 +68,7 @@ public String toString() {\n   public enum OperatorType {\n     SFW, JOIN, UNION, FILTER, GROUPBY, ORDERBY, LIMIT, SELECT, SEQTABLESCAN, HASHTABLESCAN,\n     MERGEJOIN, FILEREAD, NULL, TABLESCAN, UPDATE, INSERT, BATCHINSERT, DELETE, BASIC_FUNC, IN, QUERY, MERGEQUERY,\n-    AGGREGATION, AUTHOR, FROM, FUNC, LOADDATA, METADATA, PROPERTY, INDEX, INDEXQUERY, FILL,\n+    AGGREGATION, AUTHOR, FROM, FUNC, LOADDATA, METADATA, PROPERTY, INDEX, INDEXQUERY, FILL, LAST,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzOTI5Mw=="}, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTI1MDQyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOToxMDozN1rOFq6VIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNjo0Mzo0OFrOFrJ-RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDE5NQ==", "bodyText": "This function is not the InsertPlan's responsibility", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380540195", "createdAt": "2020-02-18T09:10:37Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java", "diffHunk": "@@ -288,6 +292,23 @@ public long getMaxTime() {\n     return maxTime;\n   }\n \n+  public void updateMNodeLastValues(MNode node) {\n+    long maxTime = Long.MIN_VALUE;\n+    int maxIndex = 0;\n+    for (int i = 0; i < times.length; i++) {\n+      if (times[i] > maxTime) {\n+        maxTime = times[i];\n+        maxIndex = i;\n+      }\n+    }\n+    for (int i = 0; i < measurements.length; i++) {\n+      if (node.hasChild(measurements[i])) {\n+        Object[] column = (Object[]) columns[i];\n+        node.getChild(measurements[i]).updateCachedLast(maxTime, column[maxIndex], dataTypes[i]);\n+      }\n+    }\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NjQ4NQ==", "bodyText": "Agree. Moved it out of InsertPlan", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380796485", "createdAt": "2020-02-18T16:43:48Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java", "diffHunk": "@@ -288,6 +292,23 @@ public long getMaxTime() {\n     return maxTime;\n   }\n \n+  public void updateMNodeLastValues(MNode node) {\n+    long maxTime = Long.MIN_VALUE;\n+    int maxIndex = 0;\n+    for (int i = 0; i < times.length; i++) {\n+      if (times[i] > maxTime) {\n+        maxTime = times[i];\n+        maxIndex = i;\n+      }\n+    }\n+    for (int i = 0; i < measurements.length; i++) {\n+      if (node.hasChild(measurements[i])) {\n+        Object[] column = (Object[]) columns[i];\n+        node.getChild(measurements[i]).updateCachedLast(maxTime, column[maxIndex], dataTypes[i]);\n+      }\n+    }\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDE5NQ=="}, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTI1MTI5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/InsertPlan.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOToxMDo1MVrOFq6Vqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNjo0NDowMlrOFrJ-6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDMzMA==", "bodyText": "Same as before", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380540330", "createdAt": "2020-02-18T09:10:51Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/InsertPlan.java", "diffHunk": "@@ -185,4 +190,13 @@ public void deserializeFrom(ByteBuffer buffer) {\n   public String toString() {\n     return \"deviceId: \" + deviceId + \", time: \" + time;\n   }\n+\n+  public void updateMNodeLastValues(MNode node) throws QueryProcessException {\n+    for (int i = 0; i < measurements.length; i++) {\n+      if (node.hasChild(measurements[i])) {\n+        Object value = CommonUtils.parseValue(dataTypes[i], values[i]);\n+        node.getChild(measurements[i]).updateCachedLast(time, value, dataTypes[i]);\n+      }\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NjY1MA==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380796650", "createdAt": "2020-02-18T16:44:02Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/InsertPlan.java", "diffHunk": "@@ -185,4 +190,13 @@ public void deserializeFrom(ByteBuffer buffer) {\n   public String toString() {\n     return \"deviceId: \" + deviceId + \", time: \" + time;\n   }\n+\n+  public void updateMNodeLastValues(MNode node) throws QueryProcessException {\n+    for (int i = 0; i < measurements.length; i++) {\n+      if (node.hasChild(measurements[i])) {\n+        Object value = CommonUtils.parseValue(dataTypes[i], values[i]);\n+        node.getChild(measurements[i]).updateCachedLast(time, value, dataTypes[i]);\n+      }\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDMzMA=="}, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTI1Njc1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOToxMjoyMVrOFq6ZAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMDo0OTo1NVrOFq9xCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MTE4NQ==", "bodyText": "delete it", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380541185", "createdAt": "2020-02-18T09:12:21Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "diffHunk": "@@ -196,6 +196,7 @@ public static TSDataType getSeriesType(String path) throws QueryProcessException\n         case SQLConstant.FIRST_VALUE:\n         case SQLConstant.MIN_VALUE:\n         case SQLConstant.MAX_VALUE:\n+        //case SQLConstant.LAST:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU5NjQ5MA==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380596490", "createdAt": "2020-02-18T10:49:55Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "diffHunk": "@@ -196,6 +196,7 @@ public static TSDataType getSeriesType(String path) throws QueryProcessException\n         case SQLConstant.FIRST_VALUE:\n         case SQLConstant.MIN_VALUE:\n         case SQLConstant.MAX_VALUE:\n+        //case SQLConstant.LAST:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MTE4NQ=="}, "originalCommit": {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODMyMzI5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMTowNDowNFrOFrX3-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMTowNDowNFrOFrX3-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAyNDI0OQ==", "bodyText": "Why not combine this loop with the before one.", "url": "https://github.com/apache/iotdb/pull/821#discussion_r381024249", "createdAt": "2020-02-19T01:04:04Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -680,6 +683,10 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       }\n       insertPlan.setDataTypes(dataTypes);\n       storageEngine.insert(insertPlan);\n+      for (int i = 0; i < measurementList.length; i++) {\n+        MNode measurementNode = node.getChild(measurementList[i]);\n+        measurementNode.updateCachedLast(insertPlan.composeTimeValuePair(i));\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f02f7c313c7e3dbfae12e0e5ca0cbdfdc61246f"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODM3MzM1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMTozMzoyOVrOFrYW2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMTozMzoyOVrOFrYW2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzMjE1Mw==", "bodyText": "same as before.", "url": "https://github.com/apache/iotdb/pull/821#discussion_r381032153", "createdAt": "2020-02-19T01:33:29Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -772,8 +779,12 @@ private void checkPathExists(MNode node, String fullPath, MeasurementSchema sche\n                   measurementNode.getSchema().getType()));\n         }\n       }\n-      return storageEngine.insertBatch(batchInsertPlan);\n-\n+      Integer[] results = storageEngine.insertBatch(batchInsertPlan);\n+      for (int i = 0; i < measurementList.length; i++) {\n+        MNode measurementNode = node.getChild(measurementList[i]);\n+        measurementNode.updateCachedLast(batchInsertPlan.composeLastTimeValuePair(i));\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f02f7c313c7e3dbfae12e0e5ca0cbdfdc61246f"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODM4ODk2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMTo0MjoxM1rOFrYgKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNToyMDoyNlrOFvFi9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzNDUzOQ==", "bodyText": "No matter what measurementIndex is, this calculation process is the same. It only needs to be called once.\nYou can extract that method outside the the calling loop.", "url": "https://github.com/apache/iotdb/pull/821#discussion_r381034539", "createdAt": "2020-02-19T01:42:13Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java", "diffHunk": "@@ -288,6 +291,19 @@ public long getMaxTime() {\n     return maxTime;\n   }\n \n+  public TimeValuePair composeLastTimeValuePair(int measurementIndex) {\n+    long maxTime = Long.MIN_VALUE;\n+    int maxIndex = 0;\n+    for (int i = 0; i < times.length; i++) {\n+      if (times[i] > maxTime) {\n+        maxTime = times[i];\n+        maxIndex = i;\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f02f7c313c7e3dbfae12e0e5ca0cbdfdc61246f"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxODI2MA==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384918260", "createdAt": "2020-02-27T05:20:26Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java", "diffHunk": "@@ -288,6 +291,19 @@ public long getMaxTime() {\n     return maxTime;\n   }\n \n+  public TimeValuePair composeLastTimeValuePair(int measurementIndex) {\n+    long maxTime = Long.MIN_VALUE;\n+    int maxIndex = 0;\n+    for (int i = 0; i < times.length; i++) {\n+      if (times[i] > maxTime) {\n+        maxTime = times[i];\n+        maxIndex = i;\n+      }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzNDUzOQ=="}, "originalCommit": {"oid": "3f02f7c313c7e3dbfae12e0e5ca0cbdfdc61246f"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzIxMTc5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMzozMjozNlrOFsqslg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoyNDo0M1rOFu060w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM4MTIwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } else if (timeValuePair.getTimestamp() > cachedLastValuePair.getTimestamp()) {\n          \n          \n            \n                } else if (timeValuePair.getTimestamp() >= cachedLastValuePair.getTimestamp()) {\n          \n      \n    \n    \n  \n\ninsert time-value 1-1\ninsert time-value 1-2\nthe vlaue of 1 should be updated to 2", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382381206", "createdAt": "2020-02-21T03:32:36Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "diffHunk": "@@ -238,4 +241,23 @@ public String getFullPath() {\n     }\n     return fullPath = builder.toString();\n   }\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public void setCachedLast(TimeValuePair timeValuePair) {\n+    cachedLastValuePair = timeValuePair;\n+  }\n+\n+  public void updateCachedLast(TimeValuePair timeValuePair) {\n+    if (timeValuePair == null)\n+      return;\n+    if (cachedLastValuePair == null) {\n+      cachedLastValuePair = new TimeValuePair(timeValuePair.getTimestamp(), timeValuePair.getValue());\n+    } else if (timeValuePair.getTimestamp() > cachedLastValuePair.getTimestamp()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43426a7987c156d3d373fbf1cfa1d9858a2815d"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NTg0Mw==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384645843", "createdAt": "2020-02-26T17:24:43Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "diffHunk": "@@ -238,4 +241,23 @@ public String getFullPath() {\n     }\n     return fullPath = builder.toString();\n   }\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public void setCachedLast(TimeValuePair timeValuePair) {\n+    cachedLastValuePair = timeValuePair;\n+  }\n+\n+  public void updateCachedLast(TimeValuePair timeValuePair) {\n+    if (timeValuePair == null)\n+      return;\n+    if (cachedLastValuePair == null) {\n+      cachedLastValuePair = new TimeValuePair(timeValuePair.getTimestamp(), timeValuePair.getValue());\n+    } else if (timeValuePair.getTimestamp() > cachedLastValuePair.getTimestamp()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM4MTIwNg=="}, "originalCommit": {"oid": "f43426a7987c156d3d373fbf1cfa1d9858a2815d"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2Nzc1MTI1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwODo1NzowOVrOFsvu9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoyNTowMFrOFu07dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2MzczMg==", "bodyText": "the time in BatchInsertPlan is always in ascending order, you could directly get the last", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382463732", "createdAt": "2020-02-21T08:57:09Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java", "diffHunk": "@@ -288,6 +291,19 @@ public long getMaxTime() {\n     return maxTime;\n   }\n \n+  public TimeValuePair composeLastTimeValuePair(int measurementIndex) {\n+    long maxTime = Long.MIN_VALUE;\n+    int maxIndex = 0;\n+    for (int i = 0; i < times.length; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43426a7987c156d3d373fbf1cfa1d9858a2815d"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NjAwNA==", "bodyText": "Done", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384646004", "createdAt": "2020-02-26T17:25:00Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java", "diffHunk": "@@ -288,6 +291,19 @@ public long getMaxTime() {\n     return maxTime;\n   }\n \n+  public TimeValuePair composeLastTimeValuePair(int measurementIndex) {\n+    long maxTime = Long.MIN_VALUE;\n+    int maxIndex = 0;\n+    for (int i = 0; i < times.length; i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2MzczMg=="}, "originalCommit": {"oid": "f43426a7987c156d3d373fbf1cfa1d9858a2815d"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2Nzc1NjU4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwODo1ODo1MlrOFsvyPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoyNjoyN1rOFu0-tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NDU3NA==", "bodyText": "the sql needs update", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382464574", "createdAt": "2020-02-21T08:58:52Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java", "diffHunk": "@@ -1047,6 +1048,16 @@ public void enterSelectElement(SelectElementContext ctx) {\n     queryOp.setSelectOperator(selectOp);\n   }\n \n+  @Override\n+  public void enterLastElement(SqlBaseParser.LastElementContext ctx) {\n+    super.enterLastElement(ctx);\n+    selectOp = new SelectOperator(SQLConstant.TOK_SELECT);\n+    LastFunctionCallContext functionCallContext = ctx.lastFunctionCall();\n+    Path path = parseSuffixPath(functionCallContext.suffixPath());\n+    selectOp.addLastPath(path, functionCallContext.LAST().getText());\n+    queryOp.setSelectOperator(selectOp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43426a7987c156d3d373fbf1cfa1d9858a2815d"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NjgzOA==", "bodyText": "Sql syntax updated", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384646838", "createdAt": "2020-02-26T17:26:27Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java", "diffHunk": "@@ -1047,6 +1048,16 @@ public void enterSelectElement(SelectElementContext ctx) {\n     queryOp.setSelectOperator(selectOp);\n   }\n \n+  @Override\n+  public void enterLastElement(SqlBaseParser.LastElementContext ctx) {\n+    super.enterLastElement(ctx);\n+    selectOp = new SelectOperator(SQLConstant.TOK_SELECT);\n+    LastFunctionCallContext functionCallContext = ctx.lastFunctionCall();\n+    Path path = parseSuffixPath(functionCallContext.suffixPath());\n+    selectOp.addLastPath(path, functionCallContext.LAST().getText());\n+    queryOp.setSelectOperator(selectOp);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NDU3NA=="}, "originalCommit": {"oid": "f43426a7987c156d3d373fbf1cfa1d9858a2815d"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2Nzc2MzQ0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwOTowMTowOVrOFsv2Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoyNjo0NFrOFu0_bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NTYzOQ==", "bodyText": "The result format should be updated to path, time, value", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382465639", "createdAt": "2020-02-21T09:01:09Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+          throws StorageEngineException, IOException, QueryProcessException {\n+\n+    List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      lastQueryResultList.add(lastQueryResult);\n+    }\n+\n+    RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43426a7987c156d3d373fbf1cfa1d9858a2815d"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NzAyMA==", "bodyText": "Result set updated", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384647020", "createdAt": "2020-02-26T17:26:44Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+          throws StorageEngineException, IOException, QueryProcessException {\n+\n+    List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      lastQueryResultList.add(lastQueryResult);\n+    }\n+\n+    RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NTYzOQ=="}, "originalCommit": {"oid": "f43426a7987c156d3d373fbf1cfa1d9858a2815d"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2Nzc3MjYyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwOTowNDoxNFrOFsv8Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoyNToxN1rOFu08IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NzA5MQ==", "bodyText": "I think this class is not needed, you could use TimeValuePair directly unless you store the path of a series in this class.", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382467091", "createdAt": "2020-02-21T09:04:14Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+          throws StorageEngineException, IOException, QueryProcessException {\n+\n+    List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      lastQueryResultList.add(lastQueryResult);\n+    }\n+\n+    RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);\n+    SingleDataSet dataSet = new SingleDataSet(selectedSeries, dataTypes);\n+    dataSet.setRecord(resultRecord);\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get aggregation result for one series\n+   *\n+   * @param context query context\n+   * @return AggregateResult list\n+   */\n+  private LastQueryResult calculateLastPairForOneSeries(\n+          Path seriesPath, TSDataType tsDataType,\n+          QueryContext context)\n+          throws IOException, QueryProcessException, StorageEngineException {\n+    LastQueryResult queryResult = new LastQueryResult();\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getNodeByPathFromCache(seriesPath.toString());\n+    } catch (PathException e) {\n+      throw new QueryProcessException(e);\n+    } catch (CacheException e) {\n+      throw new QueryProcessException(e.getMessage());\n+    }\n+    if (node.getCachedLast() != null) {\n+      queryResult.setPairResult(node.getCachedLast());\n+      return queryResult;\n+    }\n+\n+    // construct series reader without value filter\n+    Filter timeFilter = null;\n+    IAggregateReader seriesReader = new SeriesAggregateReader(\n+            seriesPath, tsDataType, context, QueryResourceManager.getInstance()\n+            .getQueryDataSource(seriesPath, context, timeFilter), timeFilter, null);\n+\n+    long maxTime = Long.MIN_VALUE;\n+    while (seriesReader.hasNextChunk()) {\n+      // cal by chunk statistics\n+      if (seriesReader.canUseCurrentChunkStatistics()) {\n+        Statistics chunkStatistics = seriesReader.currentChunkStatistics();\n+        if (chunkStatistics.getEndTime() > maxTime) {\n+          maxTime = chunkStatistics.getEndTime();\n+          queryResult.setPairResult(maxTime, chunkStatistics.getLastValue(), tsDataType);\n+        }\n+        seriesReader.skipCurrentChunk();\n+        continue;\n+      }\n+      while (seriesReader.hasNextPage()) {\n+        //cal by page statistics\n+        if (seriesReader.canUseCurrentPageStatistics()) {\n+          Statistics pageStatistic = seriesReader.currentPageStatistics();\n+          if (pageStatistic.getEndTime() > maxTime) {\n+            maxTime = pageStatistic.getEndTime();\n+            queryResult.setPairResult(maxTime, pageStatistic.getLastValue(), tsDataType);\n+          }\n+          seriesReader.skipCurrentPage();\n+          continue;\n+        }\n+        // cal by page data\n+        while (seriesReader.hasNextOverlappedPage()) {\n+          BatchData nextOverlappedPageData = seriesReader.nextOverlappedPage();\n+          int maxIndex = nextOverlappedPageData.length() - 1;\n+          if (maxIndex < 0) {\n+            continue;\n+          }\n+          long time = nextOverlappedPageData.getTimeByIndex(maxIndex);\n+          if (time > maxTime) {\n+            maxTime = time;\n+            queryResult.setPairResult(maxTime, nextOverlappedPageData.getValueInTimestamp(time), tsDataType);\n+          }\n+          nextOverlappedPageData.resetBatchData();\n+        }\n+      }\n+    }\n+    if (queryResult.hasResult())\n+      node.setCachedLast(queryResult.getPairResult());\n+    return queryResult;\n+  }\n+\n+  /**\n+   * using last result data list construct QueryDataSet.\n+   *\n+   * @param lastQueryResultList last result list\n+   */\n+  private RowRecord constructLastRowRecord(List<LastQueryResult> lastQueryResultList) {\n+    long maxTime = Long.MIN_VALUE;\n+    for (LastQueryResult lastPair : lastQueryResultList) {\n+      if (lastPair.hasResult() && lastPair.getTimestamp() > maxTime)\n+        maxTime = lastPair.getTimestamp();\n+    }\n+\n+    RowRecord resultRecord = new RowRecord(maxTime);\n+    for (int i = 0; i < lastQueryResultList.size(); i++) {\n+      TSDataType dataType = dataTypes.get(i);\n+      LastQueryResult lastPair = lastQueryResultList.get(i);\n+      if (lastPair.hasResult() && lastPair.getTimestamp() == maxTime)\n+        resultRecord.addField(lastPair.getValue(), dataType);\n+      else\n+        resultRecord.addField(null, dataType);\n+    }\n+\n+    return resultRecord;\n+  }\n+\n+  class LastQueryResult {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43426a7987c156d3d373fbf1cfa1d9858a2815d"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NjE3Ng==", "bodyText": "Removed in the new version", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384646176", "createdAt": "2020-02-26T17:25:17Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+          throws StorageEngineException, IOException, QueryProcessException {\n+\n+    List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      lastQueryResultList.add(lastQueryResult);\n+    }\n+\n+    RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);\n+    SingleDataSet dataSet = new SingleDataSet(selectedSeries, dataTypes);\n+    dataSet.setRecord(resultRecord);\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get aggregation result for one series\n+   *\n+   * @param context query context\n+   * @return AggregateResult list\n+   */\n+  private LastQueryResult calculateLastPairForOneSeries(\n+          Path seriesPath, TSDataType tsDataType,\n+          QueryContext context)\n+          throws IOException, QueryProcessException, StorageEngineException {\n+    LastQueryResult queryResult = new LastQueryResult();\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getNodeByPathFromCache(seriesPath.toString());\n+    } catch (PathException e) {\n+      throw new QueryProcessException(e);\n+    } catch (CacheException e) {\n+      throw new QueryProcessException(e.getMessage());\n+    }\n+    if (node.getCachedLast() != null) {\n+      queryResult.setPairResult(node.getCachedLast());\n+      return queryResult;\n+    }\n+\n+    // construct series reader without value filter\n+    Filter timeFilter = null;\n+    IAggregateReader seriesReader = new SeriesAggregateReader(\n+            seriesPath, tsDataType, context, QueryResourceManager.getInstance()\n+            .getQueryDataSource(seriesPath, context, timeFilter), timeFilter, null);\n+\n+    long maxTime = Long.MIN_VALUE;\n+    while (seriesReader.hasNextChunk()) {\n+      // cal by chunk statistics\n+      if (seriesReader.canUseCurrentChunkStatistics()) {\n+        Statistics chunkStatistics = seriesReader.currentChunkStatistics();\n+        if (chunkStatistics.getEndTime() > maxTime) {\n+          maxTime = chunkStatistics.getEndTime();\n+          queryResult.setPairResult(maxTime, chunkStatistics.getLastValue(), tsDataType);\n+        }\n+        seriesReader.skipCurrentChunk();\n+        continue;\n+      }\n+      while (seriesReader.hasNextPage()) {\n+        //cal by page statistics\n+        if (seriesReader.canUseCurrentPageStatistics()) {\n+          Statistics pageStatistic = seriesReader.currentPageStatistics();\n+          if (pageStatistic.getEndTime() > maxTime) {\n+            maxTime = pageStatistic.getEndTime();\n+            queryResult.setPairResult(maxTime, pageStatistic.getLastValue(), tsDataType);\n+          }\n+          seriesReader.skipCurrentPage();\n+          continue;\n+        }\n+        // cal by page data\n+        while (seriesReader.hasNextOverlappedPage()) {\n+          BatchData nextOverlappedPageData = seriesReader.nextOverlappedPage();\n+          int maxIndex = nextOverlappedPageData.length() - 1;\n+          if (maxIndex < 0) {\n+            continue;\n+          }\n+          long time = nextOverlappedPageData.getTimeByIndex(maxIndex);\n+          if (time > maxTime) {\n+            maxTime = time;\n+            queryResult.setPairResult(maxTime, nextOverlappedPageData.getValueInTimestamp(time), tsDataType);\n+          }\n+          nextOverlappedPageData.resetBatchData();\n+        }\n+      }\n+    }\n+    if (queryResult.hasResult())\n+      node.setCachedLast(queryResult.getPairResult());\n+    return queryResult;\n+  }\n+\n+  /**\n+   * using last result data list construct QueryDataSet.\n+   *\n+   * @param lastQueryResultList last result list\n+   */\n+  private RowRecord constructLastRowRecord(List<LastQueryResult> lastQueryResultList) {\n+    long maxTime = Long.MIN_VALUE;\n+    for (LastQueryResult lastPair : lastQueryResultList) {\n+      if (lastPair.hasResult() && lastPair.getTimestamp() > maxTime)\n+        maxTime = lastPair.getTimestamp();\n+    }\n+\n+    RowRecord resultRecord = new RowRecord(maxTime);\n+    for (int i = 0; i < lastQueryResultList.size(); i++) {\n+      TSDataType dataType = dataTypes.get(i);\n+      LastQueryResult lastPair = lastQueryResultList.get(i);\n+      if (lastPair.hasResult() && lastPair.getTimestamp() == maxTime)\n+        resultRecord.addField(lastPair.getValue(), dataType);\n+      else\n+        resultRecord.addField(null, dataType);\n+    }\n+\n+    return resultRecord;\n+  }\n+\n+  class LastQueryResult {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NzA5MQ=="}, "originalCommit": {"oid": "f43426a7987c156d3d373fbf1cfa1d9858a2815d"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzgzMTExOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwOToyNDoyOFrOFswgdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoyNToyNVrOFu08Yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3NjQwNA==", "bodyText": "remove this field and use null directly", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382476404", "createdAt": "2020-02-21T09:24:28Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+          throws StorageEngineException, IOException, QueryProcessException {\n+\n+    List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      lastQueryResultList.add(lastQueryResult);\n+    }\n+\n+    RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);\n+    SingleDataSet dataSet = new SingleDataSet(selectedSeries, dataTypes);\n+    dataSet.setRecord(resultRecord);\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get aggregation result for one series\n+   *\n+   * @param context query context\n+   * @return AggregateResult list\n+   */\n+  private LastQueryResult calculateLastPairForOneSeries(\n+          Path seriesPath, TSDataType tsDataType,\n+          QueryContext context)\n+          throws IOException, QueryProcessException, StorageEngineException {\n+    LastQueryResult queryResult = new LastQueryResult();\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getNodeByPathFromCache(seriesPath.toString());\n+    } catch (PathException e) {\n+      throw new QueryProcessException(e);\n+    } catch (CacheException e) {\n+      throw new QueryProcessException(e.getMessage());\n+    }\n+    if (node.getCachedLast() != null) {\n+      queryResult.setPairResult(node.getCachedLast());\n+      return queryResult;\n+    }\n+\n+    // construct series reader without value filter\n+    Filter timeFilter = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43426a7987c156d3d373fbf1cfa1d9858a2815d"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NjI0Mg==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384646242", "createdAt": "2020-02-26T17:25:25Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+          throws StorageEngineException, IOException, QueryProcessException {\n+\n+    List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      lastQueryResultList.add(lastQueryResult);\n+    }\n+\n+    RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);\n+    SingleDataSet dataSet = new SingleDataSet(selectedSeries, dataTypes);\n+    dataSet.setRecord(resultRecord);\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get aggregation result for one series\n+   *\n+   * @param context query context\n+   * @return AggregateResult list\n+   */\n+  private LastQueryResult calculateLastPairForOneSeries(\n+          Path seriesPath, TSDataType tsDataType,\n+          QueryContext context)\n+          throws IOException, QueryProcessException, StorageEngineException {\n+    LastQueryResult queryResult = new LastQueryResult();\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getNodeByPathFromCache(seriesPath.toString());\n+    } catch (PathException e) {\n+      throw new QueryProcessException(e);\n+    } catch (CacheException e) {\n+      throw new QueryProcessException(e.getMessage());\n+    }\n+    if (node.getCachedLast() != null) {\n+      queryResult.setPairResult(node.getCachedLast());\n+      return queryResult;\n+    }\n+\n+    // construct series reader without value filter\n+    Filter timeFilter = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3NjQwNA=="}, "originalCommit": {"oid": "f43426a7987c156d3d373fbf1cfa1d9858a2815d"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2Nzg2NzQxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwOTozNjoxMFrOFsw2eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoyNTo0OVrOFu09OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4MjA0MQ==", "bodyText": "Notice:  considering inserting a point while querying.\nIt's better to remove the setCachedLast and change updateCachedLast method to a synchronized one. Then, extend updateCachedLast with a parameter: boolean highPriority, which is to determine whether update the value if the time is equal to the previous cached one.\nThen, in the normal inserting process, update the cache with high priority. Here, update the cache with low priority.\nThis could resolve the condition: there is an insert (10,11) when you get the last point (10,10) from disk.", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382482041", "createdAt": "2020-02-21T09:36:10Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+          throws StorageEngineException, IOException, QueryProcessException {\n+\n+    List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      lastQueryResultList.add(lastQueryResult);\n+    }\n+\n+    RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);\n+    SingleDataSet dataSet = new SingleDataSet(selectedSeries, dataTypes);\n+    dataSet.setRecord(resultRecord);\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get aggregation result for one series\n+   *\n+   * @param context query context\n+   * @return AggregateResult list\n+   */\n+  private LastQueryResult calculateLastPairForOneSeries(\n+          Path seriesPath, TSDataType tsDataType,\n+          QueryContext context)\n+          throws IOException, QueryProcessException, StorageEngineException {\n+    LastQueryResult queryResult = new LastQueryResult();\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getNodeByPathFromCache(seriesPath.toString());\n+    } catch (PathException e) {\n+      throw new QueryProcessException(e);\n+    } catch (CacheException e) {\n+      throw new QueryProcessException(e.getMessage());\n+    }\n+    if (node.getCachedLast() != null) {\n+      queryResult.setPairResult(node.getCachedLast());\n+      return queryResult;\n+    }\n+\n+    // construct series reader without value filter\n+    Filter timeFilter = null;\n+    IAggregateReader seriesReader = new SeriesAggregateReader(\n+            seriesPath, tsDataType, context, QueryResourceManager.getInstance()\n+            .getQueryDataSource(seriesPath, context, timeFilter), timeFilter, null);\n+\n+    long maxTime = Long.MIN_VALUE;\n+    while (seriesReader.hasNextChunk()) {\n+      // cal by chunk statistics\n+      if (seriesReader.canUseCurrentChunkStatistics()) {\n+        Statistics chunkStatistics = seriesReader.currentChunkStatistics();\n+        if (chunkStatistics.getEndTime() > maxTime) {\n+          maxTime = chunkStatistics.getEndTime();\n+          queryResult.setPairResult(maxTime, chunkStatistics.getLastValue(), tsDataType);\n+        }\n+        seriesReader.skipCurrentChunk();\n+        continue;\n+      }\n+      while (seriesReader.hasNextPage()) {\n+        //cal by page statistics\n+        if (seriesReader.canUseCurrentPageStatistics()) {\n+          Statistics pageStatistic = seriesReader.currentPageStatistics();\n+          if (pageStatistic.getEndTime() > maxTime) {\n+            maxTime = pageStatistic.getEndTime();\n+            queryResult.setPairResult(maxTime, pageStatistic.getLastValue(), tsDataType);\n+          }\n+          seriesReader.skipCurrentPage();\n+          continue;\n+        }\n+        // cal by page data\n+        while (seriesReader.hasNextOverlappedPage()) {\n+          BatchData nextOverlappedPageData = seriesReader.nextOverlappedPage();\n+          int maxIndex = nextOverlappedPageData.length() - 1;\n+          if (maxIndex < 0) {\n+            continue;\n+          }\n+          long time = nextOverlappedPageData.getTimeByIndex(maxIndex);\n+          if (time > maxTime) {\n+            maxTime = time;\n+            queryResult.setPairResult(maxTime, nextOverlappedPageData.getValueInTimestamp(time), tsDataType);\n+          }\n+          nextOverlappedPageData.resetBatchData();\n+        }\n+      }\n+    }\n+    if (queryResult.hasResult())\n+      node.setCachedLast(queryResult.getPairResult());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43426a7987c156d3d373fbf1cfa1d9858a2815d"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NjQ1Nw==", "bodyText": "Updated, thanks", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384646457", "createdAt": "2020-02-26T17:25:49Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+          throws StorageEngineException, IOException, QueryProcessException {\n+\n+    List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      lastQueryResultList.add(lastQueryResult);\n+    }\n+\n+    RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);\n+    SingleDataSet dataSet = new SingleDataSet(selectedSeries, dataTypes);\n+    dataSet.setRecord(resultRecord);\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get aggregation result for one series\n+   *\n+   * @param context query context\n+   * @return AggregateResult list\n+   */\n+  private LastQueryResult calculateLastPairForOneSeries(\n+          Path seriesPath, TSDataType tsDataType,\n+          QueryContext context)\n+          throws IOException, QueryProcessException, StorageEngineException {\n+    LastQueryResult queryResult = new LastQueryResult();\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getNodeByPathFromCache(seriesPath.toString());\n+    } catch (PathException e) {\n+      throw new QueryProcessException(e);\n+    } catch (CacheException e) {\n+      throw new QueryProcessException(e.getMessage());\n+    }\n+    if (node.getCachedLast() != null) {\n+      queryResult.setPairResult(node.getCachedLast());\n+      return queryResult;\n+    }\n+\n+    // construct series reader without value filter\n+    Filter timeFilter = null;\n+    IAggregateReader seriesReader = new SeriesAggregateReader(\n+            seriesPath, tsDataType, context, QueryResourceManager.getInstance()\n+            .getQueryDataSource(seriesPath, context, timeFilter), timeFilter, null);\n+\n+    long maxTime = Long.MIN_VALUE;\n+    while (seriesReader.hasNextChunk()) {\n+      // cal by chunk statistics\n+      if (seriesReader.canUseCurrentChunkStatistics()) {\n+        Statistics chunkStatistics = seriesReader.currentChunkStatistics();\n+        if (chunkStatistics.getEndTime() > maxTime) {\n+          maxTime = chunkStatistics.getEndTime();\n+          queryResult.setPairResult(maxTime, chunkStatistics.getLastValue(), tsDataType);\n+        }\n+        seriesReader.skipCurrentChunk();\n+        continue;\n+      }\n+      while (seriesReader.hasNextPage()) {\n+        //cal by page statistics\n+        if (seriesReader.canUseCurrentPageStatistics()) {\n+          Statistics pageStatistic = seriesReader.currentPageStatistics();\n+          if (pageStatistic.getEndTime() > maxTime) {\n+            maxTime = pageStatistic.getEndTime();\n+            queryResult.setPairResult(maxTime, pageStatistic.getLastValue(), tsDataType);\n+          }\n+          seriesReader.skipCurrentPage();\n+          continue;\n+        }\n+        // cal by page data\n+        while (seriesReader.hasNextOverlappedPage()) {\n+          BatchData nextOverlappedPageData = seriesReader.nextOverlappedPage();\n+          int maxIndex = nextOverlappedPageData.length() - 1;\n+          if (maxIndex < 0) {\n+            continue;\n+          }\n+          long time = nextOverlappedPageData.getTimeByIndex(maxIndex);\n+          if (time > maxTime) {\n+            maxTime = time;\n+            queryResult.setPairResult(maxTime, nextOverlappedPageData.getValueInTimestamp(time), tsDataType);\n+          }\n+          nextOverlappedPageData.resetBatchData();\n+        }\n+      }\n+    }\n+    if (queryResult.hasResult())\n+      node.setCachedLast(queryResult.getPairResult());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4MjA0MQ=="}, "originalCommit": {"oid": "f43426a7987c156d3d373fbf1cfa1d9858a2815d"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mzg2MDYyOnYy", "diffSide": "RIGHT", "path": "docs/Documentation-CHN/UserGuide/5-Operation Manual/2-DML (Data Manipulation Language).md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNjoxMDo0MlrOFvGQfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOTozNTo1M1rOFvuwFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkyOTkxOQ==", "bodyText": "check this", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384929919", "createdAt": "2020-02-27T06:10:42Z", "author": {"login": "qiaojialin"}, "path": "docs/Documentation-CHN/UserGuide/5-Operation Manual/2-DML (Data Manipulation Language).md", "diffHunk": "@@ -257,6 +257,39 @@ GROUP BY\u7684SELECT\u5b50\u53e5\u91cc\u7684\u67e5\u8be2\u8def\u5f84\u5fc5\u987b\u662f\u805a\u5408\u51fd\u6570\uff0c\u5426\u5219\u7cfb\u7edf\u5c06\n \n <center><img style=\"width:100%; max-width:800px; max-height:600px; margin-left:auto; margin-right:auto; display:block;\" src=\"https://user-images.githubusercontent.com/16079446/69116099-0b715300-0ac6-11ea-8074-84e04797b8c7.png\"></center>\n \n+### \u6700\u8fd1\u65f6\u95f4\u6233\u6570\u636e\u67e5\u8be2\n+\n+\u5bf9\u5e94\u7684SQL\u8bed\u53e5\u662f\uff1a\n+\n+```\n+select last <Path> [COMMA <Path>]* from < PrefixPath > [COMMA < PrefixPath >]* <DISABLE ALIGN>\n+```\n+\u5176\u542b\u4e49\u662f\uff1a\n+\n+\u67e5\u8be2\u65f6\u95f4\u5e8f\u5217prefixPath.path\u4e2d\u6700\u8fd1\u65f6\u95f4\u6233\u7684\u6570\u636e\n+\n+\u4e0b\u9762\u7684\u4f8b\u5b50\u4e2d\u67e5\u8be2\u65f6\u95f4\u5e8f\u5217root.ln.wf01.wt01.status\u6700\u8fd1\u65f6\u95f4\u6233\u7684\u6570\u636e:\n+```\n+select last(status) from root.ln.wf01.wt01 disable align", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6fb25b2b7d96e1459911b09844e2418defb7362"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU5MzM2Ng==", "bodyText": "fixed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385593366", "createdAt": "2020-02-28T09:35:53Z", "author": {"login": "wshao08"}, "path": "docs/Documentation-CHN/UserGuide/5-Operation Manual/2-DML (Data Manipulation Language).md", "diffHunk": "@@ -257,6 +257,39 @@ GROUP BY\u7684SELECT\u5b50\u53e5\u91cc\u7684\u67e5\u8be2\u8def\u5f84\u5fc5\u987b\u662f\u805a\u5408\u51fd\u6570\uff0c\u5426\u5219\u7cfb\u7edf\u5c06\n \n <center><img style=\"width:100%; max-width:800px; max-height:600px; margin-left:auto; margin-right:auto; display:block;\" src=\"https://user-images.githubusercontent.com/16079446/69116099-0b715300-0ac6-11ea-8074-84e04797b8c7.png\"></center>\n \n+### \u6700\u8fd1\u65f6\u95f4\u6233\u6570\u636e\u67e5\u8be2\n+\n+\u5bf9\u5e94\u7684SQL\u8bed\u53e5\u662f\uff1a\n+\n+```\n+select last <Path> [COMMA <Path>]* from < PrefixPath > [COMMA < PrefixPath >]* <DISABLE ALIGN>\n+```\n+\u5176\u542b\u4e49\u662f\uff1a\n+\n+\u67e5\u8be2\u65f6\u95f4\u5e8f\u5217prefixPath.path\u4e2d\u6700\u8fd1\u65f6\u95f4\u6233\u7684\u6570\u636e\n+\n+\u4e0b\u9762\u7684\u4f8b\u5b50\u4e2d\u67e5\u8be2\u65f6\u95f4\u5e8f\u5217root.ln.wf01.wt01.status\u6700\u8fd1\u65f6\u95f4\u6233\u7684\u6570\u636e:\n+```\n+select last(status) from root.ln.wf01.wt01 disable align", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkyOTkxOQ=="}, "originalCommit": {"oid": "f6fb25b2b7d96e1459911b09844e2418defb7362"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mzg2NDk5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNjoxMzozMVrOFvGTEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOTozNjowM1rOFvuwUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMDU3OA==", "bodyText": "move this to LeafMNode", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384930578", "createdAt": "2020-02-27T06:13:31Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -43,6 +44,8 @@\n    */\n   protected String fullPath;\n \n+  private TimeValuePair cachedLastValuePair = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6fb25b2b7d96e1459911b09844e2418defb7362"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU5MzQyNg==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385593426", "createdAt": "2020-02-28T09:36:03Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -43,6 +44,8 @@\n    */\n   protected String fullPath;\n \n+  private TimeValuePair cachedLastValuePair = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMDU3OA=="}, "originalCommit": {"oid": "f6fb25b2b7d96e1459911b09844e2418defb7362"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mzg2NjE4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNjoxNDoxMVrOFvGTyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNjoxNDoxMVrOFvGTyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMDc2MQ==", "bodyText": "add javadoc for highPriorityUpdate", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384930761", "createdAt": "2020-02-27T06:14:11Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -113,4 +116,22 @@ public String getName() {\n   public void setName(String name) {\n     this.name = name;\n   }\n-}\n\\ No newline at end of file\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public synchronized void updateCachedLast(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6fb25b2b7d96e1459911b09844e2418defb7362"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mzg2OTQxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/crud/SelectOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNjoxNjowNFrOFvGVvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNjoxNjowNFrOFvGVvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMTI2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private boolean hasLast;\n          \n          \n            \n              private boolean lastQuery;", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384931262", "createdAt": "2020-02-27T06:16:04Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/crud/SelectOperator.java", "diffHunk": "@@ -30,6 +30,7 @@\n \n   private List<Path> suffixList;\n   private List<String> aggregations;\n+  private boolean hasLast;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6fb25b2b7d96e1459911b09844e2418defb7362"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mzg3MTA3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/PhysicalGenerator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNjoxNzowNFrOFvGWug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNjoxNzowNFrOFvGWug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMTUxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } else if (queryOperator.hasLast()) {\n          \n          \n            \n                } else if (queryOperator.isLastQuery()) {", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384931514", "createdAt": "2020-02-27T06:17:04Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/PhysicalGenerator.java", "diffHunk": "@@ -236,6 +237,8 @@ private PhysicalPlan transformQuery(QueryOperator queryOperator)\n       queryPlan = new AggregationPlan();\n       ((AggregationPlan) queryPlan)\n           .setAggregations(queryOperator.getSelectOperator().getAggregations());\n+    } else if (queryOperator.hasLast()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6fb25b2b7d96e1459911b09844e2418defb7362"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mzg3MjI4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNjoxNzo1NVrOFvGXfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOTozNjoyMVrOFvuw2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMTcxMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ListDataSet dataSet =\n          \n          \n            \n                        new ListDataSet(\n          \n          \n            \n                ListDataSet dataSet = new ListDataSet(", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384931711", "createdAt": "2020-02-27T06:17:55Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet =\n+            new ListDataSet(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6fb25b2b7d96e1459911b09844e2418defb7362"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU5MzU2MA==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385593560", "createdAt": "2020-02-28T09:36:21Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet =\n+            new ListDataSet(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMTcxMQ=="}, "originalCommit": {"oid": "f6fb25b2b7d96e1459911b09844e2418defb7362"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mzg4OTE4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNjoyODowN1rOFvGhnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOTozNjoyN1rOFvuxBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzNDMwMA==", "bodyText": "\uff1f", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384934300", "createdAt": "2020-02-27T06:28:07Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "diffHunk": "@@ -646,7 +644,7 @@ private TSExecuteStatementResp executeQueryStatement(\n       resp.setOperationType(plan.getOperatorType().toString());\n       // generate the queryId for the operation\n       long queryId = generateQueryId(true);\n-      // put it into the corresponding Set\n+      // put it into the corresponding SetO", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6fb25b2b7d96e1459911b09844e2418defb7362"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU5MzYwNQ==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385593605", "createdAt": "2020-02-28T09:36:27Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "diffHunk": "@@ -646,7 +644,7 @@ private TSExecuteStatementResp executeQueryStatement(\n       resp.setOperationType(plan.getOperatorType().toString());\n       // generate the queryId for the operation\n       long queryId = generateQueryId(true);\n-      // put it into the corresponding Set\n+      // put it into the corresponding SetO", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzNDMwMA=="}, "originalCommit": {"oid": "f6fb25b2b7d96e1459911b09844e2418defb7362"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mzg5MTY2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNjoyOTozOFrOFvGjGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNjoyOTozOFrOFvGjGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzNDY4MA==", "bodyText": "I don't remember, doesn't the respColumns contain time column?", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384934680", "createdAt": "2020-02-27T06:29:38Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "diffHunk": "@@ -916,6 +913,15 @@ else if (constMeasurementsLoc < plan.getConstMeasurements().size()\n     plan.setDataTypeConsistencyChecker(null);\n   }\n \n+  private void getLastQueryHeaders(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6fb25b2b7d96e1459911b09844e2418defb7362"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODU3MTM4OnYy", "diffSide": "LEFT", "path": "server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjowODo0MFrOFvy5Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQxNDo0NzoxN1rOFwJkgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MTI1MA==", "bodyText": "add a blank line...", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385661250", "createdAt": "2020-02-28T12:08:40Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java", "diffHunk": "@@ -235,7 +235,6 @@ public void insert(InsertPlan insertPlan)\n       throw new QueryProcessException(e);\n     }\n   }\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjc2OQ==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032769", "createdAt": "2020-02-29T14:47:17Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java", "diffHunk": "@@ -235,7 +235,6 @@ public void insert(InsertPlan insertPlan)\n       throw new QueryProcessException(e);\n     }\n   }\n-", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MTI1MA=="}, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODU3NTA2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjoxMDoxMVrOFvy7fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjoxMDoxMVrOFvy7fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MTgyMg==", "bodyText": "rename this to latestDeviceFlushedTimeInEachPartition distinguish with globalLatestFlushedTimeForEachDevice", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385661822", "createdAt": "2020-02-28T12:10:11Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -178,6 +180,12 @@\n    * file.\n    */\n   private Map<Long, Map<String, Long>> latestFlushedTimeForEachDevice = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODYwNjUzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjoyMzoxOFrOFvzO0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjoyMzoxOFrOFvzO0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2Njc3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n          \n          \n            \n                  long globalLatestFlushTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385666771", "createdAt": "2020-02-28T12:23:18Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -496,15 +511,38 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       latestFlushedTimeForEachDevice.computeIfAbsent(timePartitionId, id -> new HashMap<>())\n           .putIfAbsent(insertPlan.getDeviceId(), Long.MIN_VALUE);\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODYxMDIzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjoyNDo0M1rOFvzRGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQxNDo0ODowOFrOFwJksw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2NzM1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (latestFlushedTime < insertPlan.getTime())\n          \n          \n            \n                    globalLatestFlushedTimeForEachDevice.put(insertPlan.getDeviceId(), insertPlan.getTime());\n          \n          \n            \n                  if (latestFlushedTime < insertPlan.getTime()) {\n          \n          \n            \n                    globalLatestFlushedTimeForEachDevice.put(insertPlan.getDeviceId(), insertPlan.getTime());\n          \n          \n            \n                  }", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385667354", "createdAt": "2020-02-28T12:24:43Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -496,15 +511,38 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       latestFlushedTimeForEachDevice.computeIfAbsent(timePartitionId, id -> new HashMap<>())\n           .putIfAbsent(insertPlan.getDeviceId(), Long.MIN_VALUE);\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n+              insertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // insert to sequence or unSequence file\n       insertToTsFileProcessor(insertPlan,\n           insertPlan.getTime() > latestFlushedTimeForEachDevice.get(timePartitionId)\n               .get(insertPlan.getDeviceId()));\n+\n+      updateInsertPlanLast(insertPlan, latestFlushedTime);\n+      if (latestFlushedTime < insertPlan.getTime())\n+        globalLatestFlushedTimeForEachDevice.put(insertPlan.getDeviceId(), insertPlan.getTime());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3MjUxMQ==", "bodyText": "Then, move these three lines to insertToTsFileProcessor(), make it updated at the same time as the lastFlushTimeForEachDevice", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385672511", "createdAt": "2020-02-28T12:37:23Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -496,15 +511,38 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       latestFlushedTimeForEachDevice.computeIfAbsent(timePartitionId, id -> new HashMap<>())\n           .putIfAbsent(insertPlan.getDeviceId(), Long.MIN_VALUE);\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n+              insertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // insert to sequence or unSequence file\n       insertToTsFileProcessor(insertPlan,\n           insertPlan.getTime() > latestFlushedTimeForEachDevice.get(timePartitionId)\n               .get(insertPlan.getDeviceId()));\n+\n+      updateInsertPlanLast(insertPlan, latestFlushedTime);\n+      if (latestFlushedTime < insertPlan.getTime())\n+        globalLatestFlushedTimeForEachDevice.put(insertPlan.getDeviceId(), insertPlan.getTime());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2NzM1NA=="}, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjgxOQ==", "bodyText": "Yes moved, looks better now.", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032819", "createdAt": "2020-02-29T14:48:08Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -496,15 +511,38 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       latestFlushedTimeForEachDevice.computeIfAbsent(timePartitionId, id -> new HashMap<>())\n           .putIfAbsent(insertPlan.getDeviceId(), Long.MIN_VALUE);\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n+              insertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // insert to sequence or unSequence file\n       insertToTsFileProcessor(insertPlan,\n           insertPlan.getTime() > latestFlushedTimeForEachDevice.get(timePartitionId)\n               .get(insertPlan.getDeviceId()));\n+\n+      updateInsertPlanLast(insertPlan, latestFlushedTime);\n+      if (latestFlushedTime < insertPlan.getTime())\n+        globalLatestFlushedTimeForEachDevice.put(insertPlan.getDeviceId(), insertPlan.getTime());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2NzM1NA=="}, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODY0NTQ5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjozODowMFrOFvzmUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjozODowMFrOFvzmUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3Mjc4NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void updateInsertPlanLast(InsertPlan plan, Long latestFlushedTime)\n          \n          \n            \n              public void tryToUpdateCache(InsertPlan plan, Long latestFlushedTime)", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385672785", "createdAt": "2020-02-28T12:38:00Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -496,15 +511,38 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       latestFlushedTimeForEachDevice.computeIfAbsent(timePartitionId, id -> new HashMap<>())\n           .putIfAbsent(insertPlan.getDeviceId(), Long.MIN_VALUE);\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n+              insertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // insert to sequence or unSequence file\n       insertToTsFileProcessor(insertPlan,\n           insertPlan.getTime() > latestFlushedTimeForEachDevice.get(timePartitionId)\n               .get(insertPlan.getDeviceId()));\n+\n+      updateInsertPlanLast(insertPlan, latestFlushedTime);\n+      if (latestFlushedTime < insertPlan.getTime())\n+        globalLatestFlushedTimeForEachDevice.put(insertPlan.getDeviceId(), insertPlan.getTime());\n     } finally {\n       writeUnlock();\n     }\n   }\n \n+  public void updateInsertPlanLast(InsertPlan plan, Long latestFlushedTime)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODY0OTMzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjozOToyMFrOFvzokQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjozOToyMFrOFvzokQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3MzM2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n          \n          \n            \n                  long globalLatestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385673361", "createdAt": "2020-02-28T12:39:20Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -569,18 +607,40 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n         }\n       }\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODY1MDM1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjozOTo0NVrOFvzpOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQxNDo0NTozMFrOFwJkEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3MzUyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (latestFlushedTime < batchInsertPlan.getMaxTime())\n          \n          \n            \n                    globalLatestFlushedTimeForEachDevice.put(batchInsertPlan.getDeviceId(), batchInsertPlan.getMaxTime());\n          \n          \n            \n                  if (latestFlushedTime < batchInsertPlan.getMaxTime()) {\n          \n          \n            \n                    globalLatestFlushedTimeForEachDevice.put(batchInsertPlan.getDeviceId(), batchInsertPlan.getMaxTime());\n          \n          \n            \n                  }", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385673528", "createdAt": "2020-02-28T12:39:45Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -569,18 +607,40 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n         }\n       }\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n+              batchInsertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // do not forget last part\n       if (before < loc) {\n         insertBatchToTsFileProcessor(batchInsertPlan, before, loc, isSequence, results,\n             beforeTimePartition);\n       }\n+      updateBatchInsertPlanLast(batchInsertPlan, latestFlushedTime);\n+      if (latestFlushedTime < batchInsertPlan.getMaxTime())\n+        globalLatestFlushedTimeForEachDevice.put(batchInsertPlan.getDeviceId(), batchInsertPlan.getMaxTime());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3MzcyNg==", "bodyText": "move this into insertBatchToTsFileProcessor()", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385673726", "createdAt": "2020-02-28T12:40:11Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -569,18 +607,40 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n         }\n       }\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n+              batchInsertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // do not forget last part\n       if (before < loc) {\n         insertBatchToTsFileProcessor(batchInsertPlan, before, loc, isSequence, results,\n             beforeTimePartition);\n       }\n+      updateBatchInsertPlanLast(batchInsertPlan, latestFlushedTime);\n+      if (latestFlushedTime < batchInsertPlan.getMaxTime())\n+        globalLatestFlushedTimeForEachDevice.put(batchInsertPlan.getDeviceId(), batchInsertPlan.getMaxTime());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3MzUyOA=="}, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjY1OA==", "bodyText": "Moved", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032658", "createdAt": "2020-02-29T14:45:30Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -569,18 +607,40 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n         }\n       }\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n+              batchInsertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // do not forget last part\n       if (before < loc) {\n         insertBatchToTsFileProcessor(batchInsertPlan, before, loc, isSequence, results,\n             beforeTimePartition);\n       }\n+      updateBatchInsertPlanLast(batchInsertPlan, latestFlushedTime);\n+      if (latestFlushedTime < batchInsertPlan.getMaxTime())\n+        globalLatestFlushedTimeForEachDevice.put(batchInsertPlan.getDeviceId(), batchInsertPlan.getMaxTime());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3MzUyOA=="}, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODY1NTg4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo0MTozM1rOFvzsdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQxNDo0NToxN1rOFwJkBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NDM1Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ((LeafMNode)measurementNode).updateCachedLast(\n          \n          \n            \n                    ((LeafMNode) measurementNode).updateCachedLast(\n          \n      \n    \n    \n  \n\nimport java-google-code.xml  code style and format the code", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385674357", "createdAt": "2020-02-28T12:41:33Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -569,18 +607,40 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n         }\n       }\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n+              batchInsertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // do not forget last part\n       if (before < loc) {\n         insertBatchToTsFileProcessor(batchInsertPlan, before, loc, isSequence, results,\n             beforeTimePartition);\n       }\n+      updateBatchInsertPlanLast(batchInsertPlan, latestFlushedTime);\n+      if (latestFlushedTime < batchInsertPlan.getMaxTime())\n+        globalLatestFlushedTimeForEachDevice.put(batchInsertPlan.getDeviceId(), batchInsertPlan.getMaxTime());\n \n       return results;\n     } finally {\n       writeUnlock();\n     }\n   }\n \n+  public void updateBatchInsertPlanLast(BatchInsertPlan plan, Long latestFlushedTime)\n+          throws QueryProcessException {\n+    try {\n+      MNode node =\n+              MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(plan.getDeviceId());\n+      String[] measurementList = plan.getMeasurements();\n+      for (int i = 0; i < measurementList.length; i++) {\n+        // Update cached last value with high priority\n+        MNode measurementNode = node.getChild(measurementList[i]);\n+        ((LeafMNode)measurementNode).updateCachedLast(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjY0NQ==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032645", "createdAt": "2020-02-29T14:45:17Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -569,18 +607,40 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n         }\n       }\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n+              batchInsertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // do not forget last part\n       if (before < loc) {\n         insertBatchToTsFileProcessor(batchInsertPlan, before, loc, isSequence, results,\n             beforeTimePartition);\n       }\n+      updateBatchInsertPlanLast(batchInsertPlan, latestFlushedTime);\n+      if (latestFlushedTime < batchInsertPlan.getMaxTime())\n+        globalLatestFlushedTimeForEachDevice.put(batchInsertPlan.getDeviceId(), batchInsertPlan.getMaxTime());\n \n       return results;\n     } finally {\n       writeUnlock();\n     }\n   }\n \n+  public void updateBatchInsertPlanLast(BatchInsertPlan plan, Long latestFlushedTime)\n+          throws QueryProcessException {\n+    try {\n+      MNode node =\n+              MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(plan.getDeviceId());\n+      String[] measurementList = plan.getMeasurements();\n+      for (int i = 0; i < measurementList.length; i++) {\n+        // Update cached last value with high priority\n+        MNode measurementNode = node.getChild(measurementList[i]);\n+        ((LeafMNode)measurementNode).updateCachedLast(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NDM1Nw=="}, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODY2MjU0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo0Mzo1MVrOFvzwSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo0Mzo1MVrOFvzwSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NTMzNw==", "bodyText": "update javadoc", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385675337", "createdAt": "2020-02-28T12:43:51Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1695,6 +1759,10 @@ private void updateLatestTimeMap(TsFileResource newTsFileResource) {\n             .computeIfAbsent(timePartitionId, id -> new HashMap<String, Long>())\n             .put(device, endTime);\n       }\n+      if (!globalLatestFlushedTimeForEachDevice.containsKey(device)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODY2Mzk4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo0NDoyNlrOFvzxJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQxNDo0NToxMFrOFwJkAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NTU1Ng==", "bodyText": "remove", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385675556", "createdAt": "2020-02-28T12:44:26Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java", "diffHunk": "@@ -20,6 +20,8 @@\n \n import java.util.LinkedHashMap;\n import java.util.Map;\n+\n+import org.apache.iotdb.tsfile.read.TimeValuePair;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjY0MA==", "bodyText": "Done", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032640", "createdAt": "2020-02-29T14:45:10Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java", "diffHunk": "@@ -20,6 +20,8 @@\n \n import java.util.LinkedHashMap;\n import java.util.Map;\n+\n+import org.apache.iotdb.tsfile.read.TimeValuePair;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NTU1Ng=="}, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODY2NTg2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo0NDo1OFrOFvzyJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQxNDo0NTowNFrOFwJj_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NTgxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!insertionUpdate || latestFlushedTime < timeValuePair.getTimestamp()) {\n          \n          \n            \n                  if (!insertionUpdate || latestFlushedTime <= timeValuePair.getTimestamp()) {", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385675814", "createdAt": "2020-02-28T12:44:58Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "diffHunk": "@@ -74,4 +77,25 @@ public int getLeafCount() {\n   public MeasurementSchema getSchema() {\n     return schema;\n   }\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,\n+                                            Long latestFlushedTime) {\n+    if (timeValuePair == null || timeValuePair.getValue() == null) return;\n+\n+    if (cachedLastValuePair == null){\n+      // If no cached last, a last read or an insertion to a sequenceTsFile will update cache.\n+      if (!insertionUpdate || latestFlushedTime < timeValuePair.getTimestamp()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjYzOQ==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032639", "createdAt": "2020-02-29T14:45:04Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "diffHunk": "@@ -74,4 +77,25 @@ public int getLeafCount() {\n   public MeasurementSchema getSchema() {\n     return schema;\n   }\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,\n+                                            Long latestFlushedTime) {\n+    if (timeValuePair == null || timeValuePair.getValue() == null) return;\n+\n+    if (cachedLastValuePair == null){\n+      // If no cached last, a last read or an insertion to a sequenceTsFile will update cache.\n+      if (!insertionUpdate || latestFlushedTime < timeValuePair.getTimestamp()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NTgxNA=="}, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODY2NzQ4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo0NTozM1rOFvzzFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo0NTozM1rOFvzzFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NjA1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,\n          \n          \n            \n              public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean updateAtSameTime,\n          \n      \n    \n    \n  \n\nadd java doc", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385676055", "createdAt": "2020-02-28T12:45:33Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "diffHunk": "@@ -74,4 +77,25 @@ public int getLeafCount() {\n   public MeasurementSchema getSchema() {\n     return schema;\n   }\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODY4NjEyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo1MjozMlrOFvz-PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo1MjozMlrOFvz-PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3ODkwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  // If no cached last, a last read or an insertion to a sequenceTsFile will update cache.\n          \n          \n            \n                  // If no cached last, (1) a last query or (2) an unseq insertion at globalLastFlushTime or (3) a seq insertion will update cache.", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385678908", "createdAt": "2020-02-28T12:52:32Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "diffHunk": "@@ -74,4 +77,25 @@ public int getLeafCount() {\n   public MeasurementSchema getSchema() {\n     return schema;\n   }\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,\n+                                            Long latestFlushedTime) {\n+    if (timeValuePair == null || timeValuePair.getValue() == null) return;\n+\n+    if (cachedLastValuePair == null){\n+      // If no cached last, a last read or an insertion to a sequenceTsFile will update cache.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODY4NjM4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo1MjozOFrOFvz-aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQxNDo0NDo0NlrOFwJj7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3ODk1NQ==", "bodyText": "format", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385678955", "createdAt": "2020-02-28T12:52:38Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "diffHunk": "@@ -74,4 +77,25 @@ public int getLeafCount() {\n   public MeasurementSchema getSchema() {\n     return schema;\n   }\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,\n+                                            Long latestFlushedTime) {\n+    if (timeValuePair == null || timeValuePair.getValue() == null) return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjYyMw==", "bodyText": "Done", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032623", "createdAt": "2020-02-29T14:44:46Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "diffHunk": "@@ -74,4 +77,25 @@ public int getLeafCount() {\n   public MeasurementSchema getSchema() {\n     return schema;\n   }\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,\n+                                            Long latestFlushedTime) {\n+    if (timeValuePair == null || timeValuePair.getValue() == null) return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3ODk1NQ=="}, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODY4NzM1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo1Mjo1OFrOFvz_BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQxNDo0NDo0MFrOFwJj7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3OTEwOA==", "bodyText": "remove this and its import", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385679108", "createdAt": "2020-02-28T12:52:58Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -43,6 +44,8 @@\n    */\n   protected String fullPath;\n \n+  private TimeValuePair cachedLastValuePair = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjYyMA==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032620", "createdAt": "2020-02-29T14:44:40Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -43,6 +44,8 @@\n    */\n   protected String fullPath;\n \n+  private TimeValuePair cachedLastValuePair = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3OTEwOA=="}, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODY5MjM1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/crud/SelectOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo1NDo1MlrOFv0B3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo1NDo1MlrOFv0B3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3OTgzNg==", "bodyText": "I suggest use addSelectPath to replace this method and add a setLastQuery()", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385679836", "createdAt": "2020-02-28T12:54:52Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/crud/SelectOperator.java", "diffHunk": "@@ -50,6 +52,11 @@ public void addClusterPath(Path suffixPath, String aggregation) {\n     aggregations.add(aggregation);\n   }\n \n+  public void addLastPath(Path suffixPath) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODY5ODUyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo1NzowMlrOFv0FhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQxNDo0Mzo1N1rOFwJj0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MDc3Mw==", "bodyText": "extract this to a Tools static method", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385680773", "createdAt": "2020-02-28T12:57:02Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.LeafMNode;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.QueryUtils;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet = new ListDataSet(\n+            Arrays.asList(new Path(COLUMN_TIMESERIES), new Path(COLUMN_VALUE)),\n+            Arrays.asList(TSDataType.TEXT, TSDataType.TEXT));\n+\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      TimeValuePair lastTimeValuePair =\n+          calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      if (lastTimeValuePair.getValue() != null) {\n+        RowRecord resultRecord = new RowRecord(lastTimeValuePair.getTimestamp());\n+        Field pathField = new Field(TSDataType.TEXT);\n+        pathField.setBinaryV(new Binary(selectedSeries.get(i).getFullPath()));\n+        resultRecord.addField(pathField);\n+\n+        Field valueField = new Field(TSDataType.TEXT);\n+        valueField.setBinaryV(new Binary(lastTimeValuePair.getValue().getStringValue()));\n+        resultRecord.addField(valueField);\n+\n+        dataSet.putRecord(resultRecord);\n+      }\n+    }\n+\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get last result for one series\n+   *\n+   * @param context query context\n+   * @return TimeValuePair\n+   */\n+  private TimeValuePair calculateLastPairForOneSeries(\n+      Path seriesPath, TSDataType tsDataType, QueryContext context)\n+      throws IOException, QueryProcessException, StorageEngineException {\n+\n+    // Retrieve last value from MNode\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+    } catch (MetadataException e) {\n+      throw new QueryProcessException(e);\n+    }\n+    if (((LeafMNode)node).getCachedLast() != null) {\n+      return ((LeafMNode)node).getCachedLast();\n+    }\n+\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, null);\n+\n+    List<TsFileResource> seqFileResources = dataSource.getSeqResources();\n+    List<TsFileResource> unseqFileResources = dataSource.getUnseqResources();\n+\n+    TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);\n+\n+    for (int i = seqFileResources.size() - 1; i >= 0; i--) {\n+      List<ChunkMetaData> chunkMetadata =\n+          loadSatisfiedChunkMetadata(seqFileResources.get(i), seriesPath, context);\n+      if (!chunkMetadata.isEmpty()) {\n+        ChunkMetaData lastChunkMetaData = chunkMetadata.get(chunkMetadata.size() - 1);\n+        Statistics chunkStatistics = lastChunkMetaData.getStatistics();\n+        resultPair = constructLastPair(\n+                chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+        break;\n+      }\n+    }\n+\n+    long version = 0;\n+    for (TsFileResource resource : unseqFileResources) {\n+      if (resource.getEndTimeMap().get(seriesPath.getDevice()) < resultPair.getTimestamp()) {\n+        break;\n+      }\n+      List<ChunkMetaData> chunkMetadata = loadSatisfiedChunkMetadata(resource, seriesPath, context);\n+      for (ChunkMetaData chunkMetaData : chunkMetadata) {\n+        if (chunkMetaData.getEndTime() == resultPair.getTimestamp()\n+            && chunkMetaData.getVersion() > version) {\n+          Statistics chunkStatistics = chunkMetaData.getStatistics();\n+          resultPair = constructLastPair(\n+                  chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+          version = chunkMetaData.getVersion();\n+        }\n+      }\n+    }\n+\n+    // Update cached last value with low priority\n+    ((LeafMNode)node).updateCachedLast(resultPair, false, Long.MIN_VALUE);\n+    return resultPair;\n+  }\n+\n+  private List<ChunkMetaData> loadSatisfiedChunkMetadata(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjU5Mg==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032592", "createdAt": "2020-02-29T14:43:57Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.LeafMNode;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.QueryUtils;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet = new ListDataSet(\n+            Arrays.asList(new Path(COLUMN_TIMESERIES), new Path(COLUMN_VALUE)),\n+            Arrays.asList(TSDataType.TEXT, TSDataType.TEXT));\n+\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      TimeValuePair lastTimeValuePair =\n+          calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      if (lastTimeValuePair.getValue() != null) {\n+        RowRecord resultRecord = new RowRecord(lastTimeValuePair.getTimestamp());\n+        Field pathField = new Field(TSDataType.TEXT);\n+        pathField.setBinaryV(new Binary(selectedSeries.get(i).getFullPath()));\n+        resultRecord.addField(pathField);\n+\n+        Field valueField = new Field(TSDataType.TEXT);\n+        valueField.setBinaryV(new Binary(lastTimeValuePair.getValue().getStringValue()));\n+        resultRecord.addField(valueField);\n+\n+        dataSet.putRecord(resultRecord);\n+      }\n+    }\n+\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get last result for one series\n+   *\n+   * @param context query context\n+   * @return TimeValuePair\n+   */\n+  private TimeValuePair calculateLastPairForOneSeries(\n+      Path seriesPath, TSDataType tsDataType, QueryContext context)\n+      throws IOException, QueryProcessException, StorageEngineException {\n+\n+    // Retrieve last value from MNode\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+    } catch (MetadataException e) {\n+      throw new QueryProcessException(e);\n+    }\n+    if (((LeafMNode)node).getCachedLast() != null) {\n+      return ((LeafMNode)node).getCachedLast();\n+    }\n+\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, null);\n+\n+    List<TsFileResource> seqFileResources = dataSource.getSeqResources();\n+    List<TsFileResource> unseqFileResources = dataSource.getUnseqResources();\n+\n+    TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);\n+\n+    for (int i = seqFileResources.size() - 1; i >= 0; i--) {\n+      List<ChunkMetaData> chunkMetadata =\n+          loadSatisfiedChunkMetadata(seqFileResources.get(i), seriesPath, context);\n+      if (!chunkMetadata.isEmpty()) {\n+        ChunkMetaData lastChunkMetaData = chunkMetadata.get(chunkMetadata.size() - 1);\n+        Statistics chunkStatistics = lastChunkMetaData.getStatistics();\n+        resultPair = constructLastPair(\n+                chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+        break;\n+      }\n+    }\n+\n+    long version = 0;\n+    for (TsFileResource resource : unseqFileResources) {\n+      if (resource.getEndTimeMap().get(seriesPath.getDevice()) < resultPair.getTimestamp()) {\n+        break;\n+      }\n+      List<ChunkMetaData> chunkMetadata = loadSatisfiedChunkMetadata(resource, seriesPath, context);\n+      for (ChunkMetaData chunkMetaData : chunkMetadata) {\n+        if (chunkMetaData.getEndTime() == resultPair.getTimestamp()\n+            && chunkMetaData.getVersion() > version) {\n+          Statistics chunkStatistics = chunkMetaData.getStatistics();\n+          resultPair = constructLastPair(\n+                  chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+          version = chunkMetaData.getVersion();\n+        }\n+      }\n+    }\n+\n+    // Update cached last value with low priority\n+    ((LeafMNode)node).updateCachedLast(resultPair, false, Long.MIN_VALUE);\n+    return resultPair;\n+  }\n+\n+  private List<ChunkMetaData> loadSatisfiedChunkMetadata(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MDc3Mw=="}, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODY5OTgwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo1NzozNVrOFv0GSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQxNDo0NDowNVrOFwJj2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MDk3MQ==", "bodyText": "no need to loop, get the last one directly", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385680971", "createdAt": "2020-02-28T12:57:35Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.LeafMNode;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.QueryUtils;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet = new ListDataSet(\n+            Arrays.asList(new Path(COLUMN_TIMESERIES), new Path(COLUMN_VALUE)),\n+            Arrays.asList(TSDataType.TEXT, TSDataType.TEXT));\n+\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      TimeValuePair lastTimeValuePair =\n+          calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      if (lastTimeValuePair.getValue() != null) {\n+        RowRecord resultRecord = new RowRecord(lastTimeValuePair.getTimestamp());\n+        Field pathField = new Field(TSDataType.TEXT);\n+        pathField.setBinaryV(new Binary(selectedSeries.get(i).getFullPath()));\n+        resultRecord.addField(pathField);\n+\n+        Field valueField = new Field(TSDataType.TEXT);\n+        valueField.setBinaryV(new Binary(lastTimeValuePair.getValue().getStringValue()));\n+        resultRecord.addField(valueField);\n+\n+        dataSet.putRecord(resultRecord);\n+      }\n+    }\n+\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get last result for one series\n+   *\n+   * @param context query context\n+   * @return TimeValuePair\n+   */\n+  private TimeValuePair calculateLastPairForOneSeries(\n+      Path seriesPath, TSDataType tsDataType, QueryContext context)\n+      throws IOException, QueryProcessException, StorageEngineException {\n+\n+    // Retrieve last value from MNode\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+    } catch (MetadataException e) {\n+      throw new QueryProcessException(e);\n+    }\n+    if (((LeafMNode)node).getCachedLast() != null) {\n+      return ((LeafMNode)node).getCachedLast();\n+    }\n+\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, null);\n+\n+    List<TsFileResource> seqFileResources = dataSource.getSeqResources();\n+    List<TsFileResource> unseqFileResources = dataSource.getUnseqResources();\n+\n+    TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);\n+\n+    for (int i = seqFileResources.size() - 1; i >= 0; i--) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjYwMQ==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032601", "createdAt": "2020-02-29T14:44:05Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.LeafMNode;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.QueryUtils;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet = new ListDataSet(\n+            Arrays.asList(new Path(COLUMN_TIMESERIES), new Path(COLUMN_VALUE)),\n+            Arrays.asList(TSDataType.TEXT, TSDataType.TEXT));\n+\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      TimeValuePair lastTimeValuePair =\n+          calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      if (lastTimeValuePair.getValue() != null) {\n+        RowRecord resultRecord = new RowRecord(lastTimeValuePair.getTimestamp());\n+        Field pathField = new Field(TSDataType.TEXT);\n+        pathField.setBinaryV(new Binary(selectedSeries.get(i).getFullPath()));\n+        resultRecord.addField(pathField);\n+\n+        Field valueField = new Field(TSDataType.TEXT);\n+        valueField.setBinaryV(new Binary(lastTimeValuePair.getValue().getStringValue()));\n+        resultRecord.addField(valueField);\n+\n+        dataSet.putRecord(resultRecord);\n+      }\n+    }\n+\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get last result for one series\n+   *\n+   * @param context query context\n+   * @return TimeValuePair\n+   */\n+  private TimeValuePair calculateLastPairForOneSeries(\n+      Path seriesPath, TSDataType tsDataType, QueryContext context)\n+      throws IOException, QueryProcessException, StorageEngineException {\n+\n+    // Retrieve last value from MNode\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+    } catch (MetadataException e) {\n+      throw new QueryProcessException(e);\n+    }\n+    if (((LeafMNode)node).getCachedLast() != null) {\n+      return ((LeafMNode)node).getCachedLast();\n+    }\n+\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, null);\n+\n+    List<TsFileResource> seqFileResources = dataSource.getSeqResources();\n+    List<TsFileResource> unseqFileResources = dataSource.getUnseqResources();\n+\n+    TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);\n+\n+    for (int i = seqFileResources.size() - 1; i >= 0; i--) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MDk3MQ=="}, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODcwNTE0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo1OToyNlrOFv0JVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQxNDo0NDoxN1rOFwJj4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MTc1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                TimeValuePair lastPair = new TimeValuePair(timestamp, TsPrimitiveType.getByType(dataType, value));\n          \n          \n            \n                return lastPair;\n          \n          \n            \n                return TimeValuePair(timestamp, TsPrimitiveType.getByType(dataType, value));", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385681751", "createdAt": "2020-02-28T12:59:26Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.LeafMNode;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.QueryUtils;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet = new ListDataSet(\n+            Arrays.asList(new Path(COLUMN_TIMESERIES), new Path(COLUMN_VALUE)),\n+            Arrays.asList(TSDataType.TEXT, TSDataType.TEXT));\n+\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      TimeValuePair lastTimeValuePair =\n+          calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      if (lastTimeValuePair.getValue() != null) {\n+        RowRecord resultRecord = new RowRecord(lastTimeValuePair.getTimestamp());\n+        Field pathField = new Field(TSDataType.TEXT);\n+        pathField.setBinaryV(new Binary(selectedSeries.get(i).getFullPath()));\n+        resultRecord.addField(pathField);\n+\n+        Field valueField = new Field(TSDataType.TEXT);\n+        valueField.setBinaryV(new Binary(lastTimeValuePair.getValue().getStringValue()));\n+        resultRecord.addField(valueField);\n+\n+        dataSet.putRecord(resultRecord);\n+      }\n+    }\n+\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get last result for one series\n+   *\n+   * @param context query context\n+   * @return TimeValuePair\n+   */\n+  private TimeValuePair calculateLastPairForOneSeries(\n+      Path seriesPath, TSDataType tsDataType, QueryContext context)\n+      throws IOException, QueryProcessException, StorageEngineException {\n+\n+    // Retrieve last value from MNode\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+    } catch (MetadataException e) {\n+      throw new QueryProcessException(e);\n+    }\n+    if (((LeafMNode)node).getCachedLast() != null) {\n+      return ((LeafMNode)node).getCachedLast();\n+    }\n+\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, null);\n+\n+    List<TsFileResource> seqFileResources = dataSource.getSeqResources();\n+    List<TsFileResource> unseqFileResources = dataSource.getUnseqResources();\n+\n+    TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);\n+\n+    for (int i = seqFileResources.size() - 1; i >= 0; i--) {\n+      List<ChunkMetaData> chunkMetadata =\n+          loadSatisfiedChunkMetadata(seqFileResources.get(i), seriesPath, context);\n+      if (!chunkMetadata.isEmpty()) {\n+        ChunkMetaData lastChunkMetaData = chunkMetadata.get(chunkMetadata.size() - 1);\n+        Statistics chunkStatistics = lastChunkMetaData.getStatistics();\n+        resultPair = constructLastPair(\n+                chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+        break;\n+      }\n+    }\n+\n+    long version = 0;\n+    for (TsFileResource resource : unseqFileResources) {\n+      if (resource.getEndTimeMap().get(seriesPath.getDevice()) < resultPair.getTimestamp()) {\n+        break;\n+      }\n+      List<ChunkMetaData> chunkMetadata = loadSatisfiedChunkMetadata(resource, seriesPath, context);\n+      for (ChunkMetaData chunkMetaData : chunkMetadata) {\n+        if (chunkMetaData.getEndTime() == resultPair.getTimestamp()\n+            && chunkMetaData.getVersion() > version) {\n+          Statistics chunkStatistics = chunkMetaData.getStatistics();\n+          resultPair = constructLastPair(\n+                  chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+          version = chunkMetaData.getVersion();\n+        }\n+      }\n+    }\n+\n+    // Update cached last value with low priority\n+    ((LeafMNode)node).updateCachedLast(resultPair, false, Long.MIN_VALUE);\n+    return resultPair;\n+  }\n+\n+  private List<ChunkMetaData> loadSatisfiedChunkMetadata(\n+      TsFileResource resource, Path seriesPath, QueryContext context) throws IOException {\n+    List<ChunkMetaData> currentChunkMetaDataList;\n+    if (resource == null) {\n+      return new ArrayList<>();\n+    }\n+    if (resource.isClosed()) {\n+      currentChunkMetaDataList = DeviceMetaDataCache.getInstance().get(resource, seriesPath);\n+    } else {\n+      currentChunkMetaDataList = resource.getChunkMetaDataList();\n+    }\n+    List<Modification> pathModifications =\n+            context.getPathModifications(resource.getModFile(), seriesPath.getFullPath());\n+\n+    if (!pathModifications.isEmpty()) {\n+      QueryUtils.modifyChunkMetaData(currentChunkMetaDataList, pathModifications);\n+    }\n+\n+    for (ChunkMetaData data : currentChunkMetaDataList) {\n+      if (data.getChunkLoader() == null) {\n+        TsFileSequenceReader tsFileSequenceReader = FileReaderManager.getInstance()\n+                .get(resource, resource.isClosed());\n+        data.setChunkLoader(new DiskChunkLoader(tsFileSequenceReader));\n+      }\n+    }\n+    List<ReadOnlyMemChunk> memChunks = resource.getReadOnlyMemChunk();\n+    if (memChunks != null) {\n+      for (ReadOnlyMemChunk readOnlyMemChunk : memChunks) {\n+        if (!memChunks.isEmpty()) {\n+          currentChunkMetaDataList.add(readOnlyMemChunk.getChunkMetaData());\n+        }\n+      }\n+    }\n+    return currentChunkMetaDataList;\n+  }\n+\n+  private TimeValuePair constructLastPair(long timestamp, Object value, TSDataType dataType) {\n+    TimeValuePair lastPair = new TimeValuePair(timestamp, TsPrimitiveType.getByType(dataType, value));\n+    return lastPair;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjYwOQ==", "bodyText": "Fixed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032609", "createdAt": "2020-02-29T14:44:17Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.LeafMNode;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.QueryUtils;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet = new ListDataSet(\n+            Arrays.asList(new Path(COLUMN_TIMESERIES), new Path(COLUMN_VALUE)),\n+            Arrays.asList(TSDataType.TEXT, TSDataType.TEXT));\n+\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      TimeValuePair lastTimeValuePair =\n+          calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      if (lastTimeValuePair.getValue() != null) {\n+        RowRecord resultRecord = new RowRecord(lastTimeValuePair.getTimestamp());\n+        Field pathField = new Field(TSDataType.TEXT);\n+        pathField.setBinaryV(new Binary(selectedSeries.get(i).getFullPath()));\n+        resultRecord.addField(pathField);\n+\n+        Field valueField = new Field(TSDataType.TEXT);\n+        valueField.setBinaryV(new Binary(lastTimeValuePair.getValue().getStringValue()));\n+        resultRecord.addField(valueField);\n+\n+        dataSet.putRecord(resultRecord);\n+      }\n+    }\n+\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get last result for one series\n+   *\n+   * @param context query context\n+   * @return TimeValuePair\n+   */\n+  private TimeValuePair calculateLastPairForOneSeries(\n+      Path seriesPath, TSDataType tsDataType, QueryContext context)\n+      throws IOException, QueryProcessException, StorageEngineException {\n+\n+    // Retrieve last value from MNode\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+    } catch (MetadataException e) {\n+      throw new QueryProcessException(e);\n+    }\n+    if (((LeafMNode)node).getCachedLast() != null) {\n+      return ((LeafMNode)node).getCachedLast();\n+    }\n+\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, null);\n+\n+    List<TsFileResource> seqFileResources = dataSource.getSeqResources();\n+    List<TsFileResource> unseqFileResources = dataSource.getUnseqResources();\n+\n+    TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);\n+\n+    for (int i = seqFileResources.size() - 1; i >= 0; i--) {\n+      List<ChunkMetaData> chunkMetadata =\n+          loadSatisfiedChunkMetadata(seqFileResources.get(i), seriesPath, context);\n+      if (!chunkMetadata.isEmpty()) {\n+        ChunkMetaData lastChunkMetaData = chunkMetadata.get(chunkMetadata.size() - 1);\n+        Statistics chunkStatistics = lastChunkMetaData.getStatistics();\n+        resultPair = constructLastPair(\n+                chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+        break;\n+      }\n+    }\n+\n+    long version = 0;\n+    for (TsFileResource resource : unseqFileResources) {\n+      if (resource.getEndTimeMap().get(seriesPath.getDevice()) < resultPair.getTimestamp()) {\n+        break;\n+      }\n+      List<ChunkMetaData> chunkMetadata = loadSatisfiedChunkMetadata(resource, seriesPath, context);\n+      for (ChunkMetaData chunkMetaData : chunkMetadata) {\n+        if (chunkMetaData.getEndTime() == resultPair.getTimestamp()\n+            && chunkMetaData.getVersion() > version) {\n+          Statistics chunkStatistics = chunkMetaData.getStatistics();\n+          resultPair = constructLastPair(\n+                  chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+          version = chunkMetaData.getVersion();\n+        }\n+      }\n+    }\n+\n+    // Update cached last value with low priority\n+    ((LeafMNode)node).updateCachedLast(resultPair, false, Long.MIN_VALUE);\n+    return resultPair;\n+  }\n+\n+  private List<ChunkMetaData> loadSatisfiedChunkMetadata(\n+      TsFileResource resource, Path seriesPath, QueryContext context) throws IOException {\n+    List<ChunkMetaData> currentChunkMetaDataList;\n+    if (resource == null) {\n+      return new ArrayList<>();\n+    }\n+    if (resource.isClosed()) {\n+      currentChunkMetaDataList = DeviceMetaDataCache.getInstance().get(resource, seriesPath);\n+    } else {\n+      currentChunkMetaDataList = resource.getChunkMetaDataList();\n+    }\n+    List<Modification> pathModifications =\n+            context.getPathModifications(resource.getModFile(), seriesPath.getFullPath());\n+\n+    if (!pathModifications.isEmpty()) {\n+      QueryUtils.modifyChunkMetaData(currentChunkMetaDataList, pathModifications);\n+    }\n+\n+    for (ChunkMetaData data : currentChunkMetaDataList) {\n+      if (data.getChunkLoader() == null) {\n+        TsFileSequenceReader tsFileSequenceReader = FileReaderManager.getInstance()\n+                .get(resource, resource.isClosed());\n+        data.setChunkLoader(new DiskChunkLoader(tsFileSequenceReader));\n+      }\n+    }\n+    List<ReadOnlyMemChunk> memChunks = resource.getReadOnlyMemChunk();\n+    if (memChunks != null) {\n+      for (ReadOnlyMemChunk readOnlyMemChunk : memChunks) {\n+        if (!memChunks.isEmpty()) {\n+          currentChunkMetaDataList.add(readOnlyMemChunk.getChunkMetaData());\n+        }\n+      }\n+    }\n+    return currentChunkMetaDataList;\n+  }\n+\n+  private TimeValuePair constructLastPair(long timestamp, Object value, TSDataType dataType) {\n+    TimeValuePair lastPair = new TimeValuePair(timestamp, TsPrimitiveType.getByType(dataType, value));\n+    return lastPair;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MTc1MQ=="}, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODcwOTIxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMzowMTowNVrOFv0L5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMzowMTowNVrOFv0L5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MjQwNw==", "bodyText": "when I saw this line, I think maybe move the lastFlushTime out of the updateCachedLast mehod and check in the insertion is better", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385682407", "createdAt": "2020-02-28T13:01:05Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.LeafMNode;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.QueryUtils;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet = new ListDataSet(\n+            Arrays.asList(new Path(COLUMN_TIMESERIES), new Path(COLUMN_VALUE)),\n+            Arrays.asList(TSDataType.TEXT, TSDataType.TEXT));\n+\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      TimeValuePair lastTimeValuePair =\n+          calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      if (lastTimeValuePair.getValue() != null) {\n+        RowRecord resultRecord = new RowRecord(lastTimeValuePair.getTimestamp());\n+        Field pathField = new Field(TSDataType.TEXT);\n+        pathField.setBinaryV(new Binary(selectedSeries.get(i).getFullPath()));\n+        resultRecord.addField(pathField);\n+\n+        Field valueField = new Field(TSDataType.TEXT);\n+        valueField.setBinaryV(new Binary(lastTimeValuePair.getValue().getStringValue()));\n+        resultRecord.addField(valueField);\n+\n+        dataSet.putRecord(resultRecord);\n+      }\n+    }\n+\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get last result for one series\n+   *\n+   * @param context query context\n+   * @return TimeValuePair\n+   */\n+  private TimeValuePair calculateLastPairForOneSeries(\n+      Path seriesPath, TSDataType tsDataType, QueryContext context)\n+      throws IOException, QueryProcessException, StorageEngineException {\n+\n+    // Retrieve last value from MNode\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+    } catch (MetadataException e) {\n+      throw new QueryProcessException(e);\n+    }\n+    if (((LeafMNode)node).getCachedLast() != null) {\n+      return ((LeafMNode)node).getCachedLast();\n+    }\n+\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, null);\n+\n+    List<TsFileResource> seqFileResources = dataSource.getSeqResources();\n+    List<TsFileResource> unseqFileResources = dataSource.getUnseqResources();\n+\n+    TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);\n+\n+    for (int i = seqFileResources.size() - 1; i >= 0; i--) {\n+      List<ChunkMetaData> chunkMetadata =\n+          loadSatisfiedChunkMetadata(seqFileResources.get(i), seriesPath, context);\n+      if (!chunkMetadata.isEmpty()) {\n+        ChunkMetaData lastChunkMetaData = chunkMetadata.get(chunkMetadata.size() - 1);\n+        Statistics chunkStatistics = lastChunkMetaData.getStatistics();\n+        resultPair = constructLastPair(\n+                chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+        break;\n+      }\n+    }\n+\n+    long version = 0;\n+    for (TsFileResource resource : unseqFileResources) {\n+      if (resource.getEndTimeMap().get(seriesPath.getDevice()) < resultPair.getTimestamp()) {\n+        break;\n+      }\n+      List<ChunkMetaData> chunkMetadata = loadSatisfiedChunkMetadata(resource, seriesPath, context);\n+      for (ChunkMetaData chunkMetaData : chunkMetadata) {\n+        if (chunkMetaData.getEndTime() == resultPair.getTimestamp()\n+            && chunkMetaData.getVersion() > version) {\n+          Statistics chunkStatistics = chunkMetaData.getStatistics();\n+          resultPair = constructLastPair(\n+                  chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+          version = chunkMetaData.getVersion();\n+        }\n+      }\n+    }\n+\n+    // Update cached last value with low priority\n+    ((LeafMNode)node).updateCachedLast(resultPair, false, Long.MIN_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODcxNzY1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMzowNDoxOFrOFv0RAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMzowNDoxOFrOFv0RAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MzcxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);\n          \n          \n            \n                TimeValuePair resultPair;", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385683715", "createdAt": "2020-02-28T13:04:18Z", "author": {"login": "qiaojialin"}, "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.LeafMNode;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.QueryUtils;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet = new ListDataSet(\n+            Arrays.asList(new Path(COLUMN_TIMESERIES), new Path(COLUMN_VALUE)),\n+            Arrays.asList(TSDataType.TEXT, TSDataType.TEXT));\n+\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      TimeValuePair lastTimeValuePair =\n+          calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      if (lastTimeValuePair.getValue() != null) {\n+        RowRecord resultRecord = new RowRecord(lastTimeValuePair.getTimestamp());\n+        Field pathField = new Field(TSDataType.TEXT);\n+        pathField.setBinaryV(new Binary(selectedSeries.get(i).getFullPath()));\n+        resultRecord.addField(pathField);\n+\n+        Field valueField = new Field(TSDataType.TEXT);\n+        valueField.setBinaryV(new Binary(lastTimeValuePair.getValue().getStringValue()));\n+        resultRecord.addField(valueField);\n+\n+        dataSet.putRecord(resultRecord);\n+      }\n+    }\n+\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get last result for one series\n+   *\n+   * @param context query context\n+   * @return TimeValuePair\n+   */\n+  private TimeValuePair calculateLastPairForOneSeries(\n+      Path seriesPath, TSDataType tsDataType, QueryContext context)\n+      throws IOException, QueryProcessException, StorageEngineException {\n+\n+    // Retrieve last value from MNode\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+    } catch (MetadataException e) {\n+      throw new QueryProcessException(e);\n+    }\n+    if (((LeafMNode)node).getCachedLast() != null) {\n+      return ((LeafMNode)node).getCachedLast();\n+    }\n+\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, null);\n+\n+    List<TsFileResource> seqFileResources = dataSource.getSeqResources();\n+    List<TsFileResource> unseqFileResources = dataSource.getUnseqResources();\n+\n+    TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzE1MDY2OnYy", "diffSide": "RIGHT", "path": "docs/Documentation-CHN/SystemDesign/5-DataQuery/6-LastQuery.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMToxMTo0MlrOFwbzVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMToxMTo0MlrOFwbzVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzMTQ3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Last\u7f13\u5b58\u66f4\u65b0\u7684\u903b\u8f91\u4f4d\u4e8e`LeafNode`\u7684`updateCachedLast`\u65b9\u6cd5\u5185\uff0c\u8fd9\u91cc\u5f15\u5165\u4e24\u4e2a\u989d\u5916\u7684\u53c2\u6570`highPriorityUpdate`\u548c`latestFlushTime`\u3002`highPriorityUpdate`\u7528\u6765\u8868\u793a\u672c\u6b21\u66f4\u65b0\u662f\u5426\u662f\u9ad8\u4f18\u5148\u7ea7\u7684\uff0c\u65b0\u6570\u636e\u5199\u5165\u800c\u5bfc\u81f4\u7684\u7f13\u5b58\u66f4\u65b0\u90fd\u88ab\u8ba4\u4e3a\u662f\u9ad8\u4f18\u5148\u7ea7\u66f4\u65b0\uff0c\u800c\u67e5\u8be2\u65f6\u66f4\u65b0\u7f13\u5b58\u9ed8\u8ba4\u4e3a\u4f4e\u4f18\u5148\u7ea7\u66f4\u65b0\u3002`latestFlushTime`\u7528\u6765\u8bb0\u5f55\u5f53\u524d\u5df2\u88ab\u5199\u56de\u5230\u78c1\u76d8\u7684\u6570\u636e\u7684\u6700\u5927\u65f6\u95f4\u6233\u3002\n          \n          \n            \n            Last\u7f13\u5b58\u66f4\u65b0\u7684\u903b\u8f91\u4f4d\u4e8e`LeafMNode`\u7684`updateCachedLast`\u65b9\u6cd5\u5185\uff0c\u8fd9\u91cc\u5f15\u5165\u4e24\u4e2a\u989d\u5916\u7684\u53c2\u6570`highPriorityUpdate`\u548c`latestFlushTime`\u3002`highPriorityUpdate`\u7528\u6765\u8868\u793a\u672c\u6b21\u66f4\u65b0\u662f\u5426\u662f\u9ad8\u4f18\u5148\u7ea7\u7684\uff0c\u65b0\u6570\u636e\u5199\u5165\u800c\u5bfc\u81f4\u7684\u7f13\u5b58\u66f4\u65b0\u90fd\u88ab\u8ba4\u4e3a\u662f\u9ad8\u4f18\u5148\u7ea7\u66f4\u65b0\uff0c\u800c\u67e5\u8be2\u65f6\u66f4\u65b0\u7f13\u5b58\u9ed8\u8ba4\u4e3a\u4f4e\u4f18\u5148\u7ea7\u66f4\u65b0\u3002`latestFlushTime`\u7528\u6765\u8bb0\u5f55\u5f53\u524d\u5df2\u88ab\u5199\u56de\u5230\u78c1\u76d8\u7684\u6570\u636e\u7684\u6700\u5927\u65f6\u95f4\u6233\u3002", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386331477", "createdAt": "2020-03-02T11:11:42Z", "author": {"login": "qiaojialin"}, "path": "docs/Documentation-CHN/SystemDesign/5-DataQuery/6-LastQuery.md", "diffHunk": "@@ -0,0 +1,119 @@\n+<!--\n+\n+    Licensed to the Apache Software Foundation (ASF) under one\n+    or more contributor license agreements.  See the NOTICE file\n+    distributed with this work for additional information\n+    regarding copyright ownership.  The ASF licenses this file\n+    to you under the Apache License, Version 2.0 (the\n+    \"License\"); you may not use this file except in compliance\n+    with the License.  You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+    Unless required by applicable law or agreed to in writing,\n+    software distributed under the License is distributed on an\n+    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+    KIND, either express or implied.  See the License for the\n+    specific language governing permissions and limitations\n+    under the License.\n+\n+-->\n+\n+# \u6700\u8fd1\u65f6\u95f4\u6233 Last \u67e5\u8be2\n+\n+Last \u67e5\u8be2\u7684\u4e3b\u8981\u903b\u8f91\u5728 LastQueryExecutor\n+\n+* org.apache.iotdb.db.query.executor.LastQueryExecutor\n+\n+Last\u67e5\u8be2\u5bf9\u6bcf\u4e2a\u6307\u5b9a\u7684\u65f6\u95f4\u5e8f\u5217\u6267\u884c`calculateLastPairForOneSeries`\u65b9\u6cd5\u3002\n+\n+## \u8bfb\u53d6MNode\u7f13\u5b58\u6570\u636e\n+\n+\u6211\u4eec\u5728\u9700\u8981\u67e5\u8be2\u7684\u65f6\u95f4\u5e8f\u5217\u6240\u5bf9\u5e94\u7684MNode\u7ed3\u6784\u4e2d\u6dfb\u52a0Last\u6570\u636e\u7f13\u5b58\u3002`calculateLastPairForOneSeries`\u65b9\u6cd5\u5bf9\u4e8e\u67d0\u4e2a\u65f6\u95f4\u5e8f\u5217\u7684Last\u67e5\u8be2\uff0c\u9996\u5148\u5c1d\u8bd5\u8bfb\u53d6MNode\u4e2d\u7684\u7f13\u5b58\u6570\u636e\u3002\n+```\n+try {\n+  node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+} catch (MetadataException e) {\n+  throw new QueryProcessException(e);\n+}\n+if (((LeafMNode) node).getCachedLast() != null) {\n+  return ((LeafMNode) node).getCachedLast();\n+}\n+```\n+\u5982\u679c\u53d1\u73b0\u7f13\u5b58\u6ca1\u6709\u88ab\u5199\u5165\u8fc7\uff0c\u5219\u6267\u884c\u4e0b\u9762\u7684\u6807\u51c6\u67e5\u8be2\u6d41\u7a0b\u8bfb\u53d6TsFile\u6570\u636e\u3002\n+\n+## Last\u6807\u51c6\u67e5\u8be2\u6d41\u7a0b\n+\n+Last\u6807\u51c6\u67e5\u8be2\u6d41\u7a0b\u9700\u8981\u904d\u5386\u6240\u6709\u7684\u987a\u5e8f\u6587\u4ef6\u548c\u4e71\u5e8f\u6587\u4ef6\u5f97\u5230\u67e5\u8be2\u7ed3\u679c\uff0c\u6700\u540e\u5c06\u67e5\u8be2\u7ed3\u679c\u5199\u56de\u5230MNode\u7f13\u5b58\u3002\u7b97\u6cd5\u4e2d\u5bf9\u987a\u5e8f\u6587\u4ef6\u548c\u4e71\u5e8f\u6587\u4ef6\u5206\u522b\u8fdb\u884c\u5904\u7406\u3002\n+- \u987a\u5e8f\u6587\u4ef6\u7531\u4e8e\u662f\u5bf9\u5176\u5199\u5165\u65f6\u95f4\u5df2\u7ecf\u6392\u597d\u5e8f\uff0c\u56e0\u6b64\u76f4\u63a5\u4f7f\u7528`loadChunkMetadataFromTsFileResource`\u65b9\u6cd5\u53d6\u51fa\u6700\u540e\u4e00\u4e2a`ChunkMetadata`\uff0c\u901a\u8fc7`ChunkMetadata`\u7684\u7edf\u8ba1\u6570\u636e\u5f97\u5230\u6700\u5927\u65f6\u95f4\u6233\u548c\u5bf9\u5e94\u7684\u503c\u3002\n+    ```\n+    if (!seqFileResources.isEmpty()) {\n+      List<ChunkMetaData> chunkMetadata =\n+          FileLoaderUtils.loadChunkMetadataFromTsFileResource(\n+              seqFileResources.get(seqFileResources.size() - 1), seriesPath, context);\n+      if (!chunkMetadata.isEmpty()) {\n+        ChunkMetaData lastChunkMetaData = chunkMetadata.get(chunkMetadata.size() - 1);\n+        Statistics chunkStatistics = lastChunkMetaData.getStatistics();\n+        resultPair =\n+            constructLastPair(\n+                chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+      }\n+    }\n+    ```\n+- \u4e71\u5e8f\u6587\u4ef6\u5219\u9700\u8981\u904d\u5386\u6240\u6709\u7684`ChunkMetadata`\u7ed3\u6784\u5f97\u5230\u6700\u5927\u65f6\u95f4\u6233\u6570\u636e\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\u5f53\u591a\u4e2a`ChunkMetadata`\u62e5\u6709\u76f8\u540c\u7684\u65f6\u95f4\u6233\u65f6\uff0c\u6211\u4eec\u53d6`version`\u503c\u6700\u5927\u7684`ChunkMatadata`\u4e2d\u7684\u6570\u636e\u4f5c\u4e3aLast\u7684\u7ed3\u679c\u3002\n+\n+    ```\n+    long version = 0;\n+    for (TsFileResource resource : unseqFileResources) {\n+      if (resource.getEndTimeMap().get(seriesPath.getDevice()) < resultPair.getTimestamp()) {\n+        break;\n+      }\n+      List<ChunkMetaData> chunkMetadata =\n+          FileLoaderUtils.loadChunkMetadataFromTsFileResource(resource, seriesPath, context);\n+      for (ChunkMetaData chunkMetaData : chunkMetadata) {\n+        if (chunkMetaData.getEndTime() == resultPair.getTimestamp()\n+            && chunkMetaData.getVersion() > version) {\n+          Statistics chunkStatistics = chunkMetaData.getStatistics();\n+          resultPair =\n+              constructLastPair(\n+                  chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+          version = chunkMetaData.getVersion();\n+        }\n+      }\n+    }\n+    ```\n+ - \u6700\u540e\u5c06\u67e5\u8be2\u7ed3\u679c\u5199\u5165\u5230MNode\u7684Last\u7f13\u5b58\n+    ```\n+    ((LeafMNode) node).updateCachedLast(resultPair, false, Long.MIN_VALUE);\n+    ```\n+\n+## Last \u7f13\u5b58\u66f4\u65b0\u7b56\u7565\n+\n+Last\u7f13\u5b58\u66f4\u65b0\u7684\u903b\u8f91\u4f4d\u4e8e`LeafNode`\u7684`updateCachedLast`\u65b9\u6cd5\u5185\uff0c\u8fd9\u91cc\u5f15\u5165\u4e24\u4e2a\u989d\u5916\u7684\u53c2\u6570`highPriorityUpdate`\u548c`latestFlushTime`\u3002`highPriorityUpdate`\u7528\u6765\u8868\u793a\u672c\u6b21\u66f4\u65b0\u662f\u5426\u662f\u9ad8\u4f18\u5148\u7ea7\u7684\uff0c\u65b0\u6570\u636e\u5199\u5165\u800c\u5bfc\u81f4\u7684\u7f13\u5b58\u66f4\u65b0\u90fd\u88ab\u8ba4\u4e3a\u662f\u9ad8\u4f18\u5148\u7ea7\u66f4\u65b0\uff0c\u800c\u67e5\u8be2\u65f6\u66f4\u65b0\u7f13\u5b58\u9ed8\u8ba4\u4e3a\u4f4e\u4f18\u5148\u7ea7\u66f4\u65b0\u3002`latestFlushTime`\u7528\u6765\u8bb0\u5f55\u5f53\u524d\u5df2\u88ab\u5199\u56de\u5230\u78c1\u76d8\u7684\u6570\u636e\u7684\u6700\u5927\u65f6\u95f4\u6233\u3002", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aa9e2b608c9f6d88a3547a89f19e8229dd0486e"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzM0MDY5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/iotdb/db/utils/FileLoaderUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjoyMToxNFrOFwdlgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMzozNToxM1rOFwfqwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2MDcwNg==", "bodyText": "Remove the if judgement, it will cause the file closed null pointer exception.\nlike:\nfor (ChunkMetaData data : currentChunkMetaDataList) {\nTsFileSequenceReader tsFileSequenceReader =\nFileReaderManager.getInstance().get(resource, resource.isClosed());\ndata.setChunkLoader(new DiskChunkLoader(tsFileSequenceReader));\n}\nit's ok to do so. because tsFileSequenceReader has been cached.", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386360706", "createdAt": "2020-03-02T12:21:14Z", "author": {"login": "JackieTien97"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/FileLoaderUtils.java", "diffHunk": "@@ -64,4 +72,40 @@ public static void updateTsFileResource(TsFileMetaData metaData, TsFileSequenceR\n       }\n     }\n   }\n+\n+  public static List<ChunkMetaData> loadChunkMetadataFromTsFileResource(\n+      TsFileResource resource, Path seriesPath, QueryContext context) throws IOException {\n+    List<ChunkMetaData> currentChunkMetaDataList;\n+    if (resource == null) {\n+      return new ArrayList<>();\n+    }\n+    if (resource.isClosed()) {\n+      currentChunkMetaDataList = DeviceMetaDataCache.getInstance().get(resource, seriesPath);\n+    } else {\n+      currentChunkMetaDataList = resource.getChunkMetaDataList();\n+    }\n+    List<Modification> pathModifications =\n+        context.getPathModifications(resource.getModFile(), seriesPath.getFullPath());\n+\n+    if (!pathModifications.isEmpty()) {\n+      QueryUtils.modifyChunkMetaData(currentChunkMetaDataList, pathModifications);\n+    }\n+\n+    for (ChunkMetaData data : currentChunkMetaDataList) {\n+      if (data.getChunkLoader() == null) {\n+        TsFileSequenceReader tsFileSequenceReader =\n+            FileReaderManager.getInstance().get(resource, resource.isClosed());\n+        data.setChunkLoader(new DiskChunkLoader(tsFileSequenceReader));\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aa9e2b608c9f6d88a3547a89f19e8229dd0486e"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM5NDgxNw==", "bodyText": "removed", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386394817", "createdAt": "2020-03-02T13:35:13Z", "author": {"login": "wshao08"}, "path": "server/src/main/java/org/apache/iotdb/db/utils/FileLoaderUtils.java", "diffHunk": "@@ -64,4 +72,40 @@ public static void updateTsFileResource(TsFileMetaData metaData, TsFileSequenceR\n       }\n     }\n   }\n+\n+  public static List<ChunkMetaData> loadChunkMetadataFromTsFileResource(\n+      TsFileResource resource, Path seriesPath, QueryContext context) throws IOException {\n+    List<ChunkMetaData> currentChunkMetaDataList;\n+    if (resource == null) {\n+      return new ArrayList<>();\n+    }\n+    if (resource.isClosed()) {\n+      currentChunkMetaDataList = DeviceMetaDataCache.getInstance().get(resource, seriesPath);\n+    } else {\n+      currentChunkMetaDataList = resource.getChunkMetaDataList();\n+    }\n+    List<Modification> pathModifications =\n+        context.getPathModifications(resource.getModFile(), seriesPath.getFullPath());\n+\n+    if (!pathModifications.isEmpty()) {\n+      QueryUtils.modifyChunkMetaData(currentChunkMetaDataList, pathModifications);\n+    }\n+\n+    for (ChunkMetaData data : currentChunkMetaDataList) {\n+      if (data.getChunkLoader() == null) {\n+        TsFileSequenceReader tsFileSequenceReader =\n+            FileReaderManager.getInstance().get(resource, resource.isClosed());\n+        data.setChunkLoader(new DiskChunkLoader(tsFileSequenceReader));\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2MDcwNg=="}, "originalCommit": {"oid": "8aa9e2b608c9f6d88a3547a89f19e8229dd0486e"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 222, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}