{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1OTE0NTYw", "number": 2246, "title": "Add Unit tests for Utils module", "bodyText": "", "createdAt": "2020-12-10T12:51:37Z", "url": "https://github.com/apache/iotdb/pull/2246", "merged": true, "mergeCommit": {"oid": "f77b85131e654fd570b876fc14dd1ccff7df3265"}, "closed": true, "closedAt": "2020-12-18T14:10:28Z", "author": {"login": "wshao08"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkyzmBgH2gAyNTM1OTE0NTYwOjIzNDE3OWJjNWNlYTU0NjA2NjNmZDUxZTY4M2IyMzY2OWQ5ZmFhZmM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdnXnHCgFqTU1NTQ1OTI0OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc", "author": {"user": {"login": "wshao08", "name": null}}, "url": "https://github.com/apache/iotdb/commit/234179bc5cea5460663fd51e683b23669d9faafc", "committedDate": "2020-12-10T12:50:07Z", "message": "Add UT for Utils module"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMDQ3NjUz", "url": "https://github.com/apache/iotdb/pull/2246#pullrequestreview-550047653", "createdAt": "2020-12-11T12:15:26Z", "commit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjoxNToyNlrOID2RUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMjozNzoxOVrOID2-pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkwNTgxMQ==", "bodyText": "What about seperating this single test to two? I think it's better to keep the test atomic.", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540905811", "createdAt": "2020-12-11T12:15:26Z", "author": {"login": "Alima777"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/MemUtilsTest.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.physical.crud.InsertTabletPlan;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.write.record.TSRecord;\n+import org.apache.iotdb.tsfile.write.record.datapoint.*;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MemUtilsTest {\n+\n+  @Test\n+  public void recordSizeTest() throws IllegalPathException {\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.INT32, 10, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.INT64, 10, true));\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.FLOAT, 10.0, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.DOUBLE, 10.0, true));\n+    Assert.assertEquals(8, MemUtils.getRecordSize(TSDataType.TEXT, \"10\", false));\n+\n+    PartialPath device = new PartialPath(\"root.sg.d1\");\n+    String[] measurements = {\"s1\", \"s2\", \"s3\", \"s4\", \"s5\"};\n+    List<Integer> dataTypes = new ArrayList<>();\n+    int sizeSum = 0;\n+    dataTypes.add(TSDataType.INT32.ordinal());\n+    sizeSum += 8 + TSDataType.INT32.getDataTypeSize();\n+    dataTypes.add(TSDataType.INT64.ordinal());\n+    sizeSum += 8 + TSDataType.INT64.getDataTypeSize();\n+    dataTypes.add(TSDataType.FLOAT.ordinal());\n+    sizeSum += 8 + TSDataType.FLOAT.getDataTypeSize();\n+    dataTypes.add(TSDataType.DOUBLE.ordinal());\n+    sizeSum += 8 + TSDataType.DOUBLE.getDataTypeSize();\n+    dataTypes.add(TSDataType.TEXT.ordinal());\n+    sizeSum += TSDataType.TEXT.getDataTypeSize();\n+    InsertTabletPlan insertPlan = new InsertTabletPlan(device, measurements, dataTypes);\n+    Assert.assertEquals(sizeSum, MemUtils.getRecordSize(insertPlan, 0, 1, false));\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkwOTQ1NQ==", "bodyText": "TsRecordSizeTest -> TsRecordMemTest. And add javadoc for this test, it tests getDataPointMem() and getTsRecordMem().", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540909455", "createdAt": "2020-12-11T12:22:19Z", "author": {"login": "Alima777"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/MemUtilsTest.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.physical.crud.InsertTabletPlan;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.write.record.TSRecord;\n+import org.apache.iotdb.tsfile.write.record.datapoint.*;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MemUtilsTest {\n+\n+  @Test\n+  public void recordSizeTest() throws IllegalPathException {\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.INT32, 10, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.INT64, 10, true));\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.FLOAT, 10.0, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.DOUBLE, 10.0, true));\n+    Assert.assertEquals(8, MemUtils.getRecordSize(TSDataType.TEXT, \"10\", false));\n+\n+    PartialPath device = new PartialPath(\"root.sg.d1\");\n+    String[] measurements = {\"s1\", \"s2\", \"s3\", \"s4\", \"s5\"};\n+    List<Integer> dataTypes = new ArrayList<>();\n+    int sizeSum = 0;\n+    dataTypes.add(TSDataType.INT32.ordinal());\n+    sizeSum += 8 + TSDataType.INT32.getDataTypeSize();\n+    dataTypes.add(TSDataType.INT64.ordinal());\n+    sizeSum += 8 + TSDataType.INT64.getDataTypeSize();\n+    dataTypes.add(TSDataType.FLOAT.ordinal());\n+    sizeSum += 8 + TSDataType.FLOAT.getDataTypeSize();\n+    dataTypes.add(TSDataType.DOUBLE.ordinal());\n+    sizeSum += 8 + TSDataType.DOUBLE.getDataTypeSize();\n+    dataTypes.add(TSDataType.TEXT.ordinal());\n+    sizeSum += TSDataType.TEXT.getDataTypeSize();\n+    InsertTabletPlan insertPlan = new InsertTabletPlan(device, measurements, dataTypes);\n+    Assert.assertEquals(sizeSum, MemUtils.getRecordSize(insertPlan, 0, 1, false));\n+  }\n+\n+  @Test\n+  public void TsRecordSizeTest() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkwOTU2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                totalSize += 8 * record.dataPointList.size() + MemUtils.getStringMem(device)+ 16;\n          \n          \n            \n                totalSize += 8 * record.dataPointList.size() + MemUtils.getStringMem(device) + 16;", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540909562", "createdAt": "2020-12-11T12:22:35Z", "author": {"login": "Alima777"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/MemUtilsTest.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.physical.crud.InsertTabletPlan;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.write.record.TSRecord;\n+import org.apache.iotdb.tsfile.write.record.datapoint.*;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MemUtilsTest {\n+\n+  @Test\n+  public void recordSizeTest() throws IllegalPathException {\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.INT32, 10, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.INT64, 10, true));\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.FLOAT, 10.0, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.DOUBLE, 10.0, true));\n+    Assert.assertEquals(8, MemUtils.getRecordSize(TSDataType.TEXT, \"10\", false));\n+\n+    PartialPath device = new PartialPath(\"root.sg.d1\");\n+    String[] measurements = {\"s1\", \"s2\", \"s3\", \"s4\", \"s5\"};\n+    List<Integer> dataTypes = new ArrayList<>();\n+    int sizeSum = 0;\n+    dataTypes.add(TSDataType.INT32.ordinal());\n+    sizeSum += 8 + TSDataType.INT32.getDataTypeSize();\n+    dataTypes.add(TSDataType.INT64.ordinal());\n+    sizeSum += 8 + TSDataType.INT64.getDataTypeSize();\n+    dataTypes.add(TSDataType.FLOAT.ordinal());\n+    sizeSum += 8 + TSDataType.FLOAT.getDataTypeSize();\n+    dataTypes.add(TSDataType.DOUBLE.ordinal());\n+    sizeSum += 8 + TSDataType.DOUBLE.getDataTypeSize();\n+    dataTypes.add(TSDataType.TEXT.ordinal());\n+    sizeSum += TSDataType.TEXT.getDataTypeSize();\n+    InsertTabletPlan insertPlan = new InsertTabletPlan(device, measurements, dataTypes);\n+    Assert.assertEquals(sizeSum, MemUtils.getRecordSize(insertPlan, 0, 1, false));\n+  }\n+\n+  @Test\n+  public void TsRecordSizeTest() {\n+    int totalSize = 0;\n+    String device = \"root.sg.d1\";\n+    TSRecord record = new TSRecord(0, device);\n+\n+    DataPoint point1 = new IntDataPoint(\"s1\", 1);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s1\") + 20, MemUtils.getDataPointMem(point1));\n+    totalSize += MemUtils.getDataPointMem(point1);\n+    record.addTuple(point1);\n+\n+    DataPoint point2 = new LongDataPoint(\"s2\", 1);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s2\") + 24, MemUtils.getDataPointMem(point2));\n+    totalSize += MemUtils.getDataPointMem(point2);\n+    record.addTuple(point2);\n+\n+    DataPoint point3 = new FloatDataPoint(\"s3\", 1.0f);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s3\") + 20, MemUtils.getDataPointMem(point3));\n+    totalSize += MemUtils.getDataPointMem(point3);\n+    record.addTuple(point3);\n+\n+    DataPoint point4 = new DoubleDataPoint(\"s4\", 1.0d);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s4\") + 24, MemUtils.getDataPointMem(point4));\n+    totalSize += MemUtils.getDataPointMem(point4);\n+    record.addTuple(point4);\n+\n+    DataPoint point5 = new BooleanDataPoint(\"s5\", true);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s5\") + 17, MemUtils.getDataPointMem(point5));\n+    totalSize += MemUtils.getDataPointMem(point5);\n+    record.addTuple(point5);\n+\n+    totalSize += 8 * record.dataPointList.size() + MemUtils.getStringMem(device)+ 16;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkxMDEyNQ==", "bodyText": "Why not check StringDataPoint?", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540910125", "createdAt": "2020-12-11T12:23:40Z", "author": {"login": "Alima777"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/MemUtilsTest.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.physical.crud.InsertTabletPlan;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.write.record.TSRecord;\n+import org.apache.iotdb.tsfile.write.record.datapoint.*;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MemUtilsTest {\n+\n+  @Test\n+  public void recordSizeTest() throws IllegalPathException {\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.INT32, 10, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.INT64, 10, true));\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.FLOAT, 10.0, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.DOUBLE, 10.0, true));\n+    Assert.assertEquals(8, MemUtils.getRecordSize(TSDataType.TEXT, \"10\", false));\n+\n+    PartialPath device = new PartialPath(\"root.sg.d1\");\n+    String[] measurements = {\"s1\", \"s2\", \"s3\", \"s4\", \"s5\"};\n+    List<Integer> dataTypes = new ArrayList<>();\n+    int sizeSum = 0;\n+    dataTypes.add(TSDataType.INT32.ordinal());\n+    sizeSum += 8 + TSDataType.INT32.getDataTypeSize();\n+    dataTypes.add(TSDataType.INT64.ordinal());\n+    sizeSum += 8 + TSDataType.INT64.getDataTypeSize();\n+    dataTypes.add(TSDataType.FLOAT.ordinal());\n+    sizeSum += 8 + TSDataType.FLOAT.getDataTypeSize();\n+    dataTypes.add(TSDataType.DOUBLE.ordinal());\n+    sizeSum += 8 + TSDataType.DOUBLE.getDataTypeSize();\n+    dataTypes.add(TSDataType.TEXT.ordinal());\n+    sizeSum += TSDataType.TEXT.getDataTypeSize();\n+    InsertTabletPlan insertPlan = new InsertTabletPlan(device, measurements, dataTypes);\n+    Assert.assertEquals(sizeSum, MemUtils.getRecordSize(insertPlan, 0, 1, false));\n+  }\n+\n+  @Test\n+  public void TsRecordSizeTest() {\n+    int totalSize = 0;\n+    String device = \"root.sg.d1\";\n+    TSRecord record = new TSRecord(0, device);\n+\n+    DataPoint point1 = new IntDataPoint(\"s1\", 1);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s1\") + 20, MemUtils.getDataPointMem(point1));\n+    totalSize += MemUtils.getDataPointMem(point1);\n+    record.addTuple(point1);\n+\n+    DataPoint point2 = new LongDataPoint(\"s2\", 1);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s2\") + 24, MemUtils.getDataPointMem(point2));\n+    totalSize += MemUtils.getDataPointMem(point2);\n+    record.addTuple(point2);\n+\n+    DataPoint point3 = new FloatDataPoint(\"s3\", 1.0f);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s3\") + 20, MemUtils.getDataPointMem(point3));\n+    totalSize += MemUtils.getDataPointMem(point3);\n+    record.addTuple(point3);\n+\n+    DataPoint point4 = new DoubleDataPoint(\"s4\", 1.0d);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s4\") + 24, MemUtils.getDataPointMem(point4));\n+    totalSize += MemUtils.getDataPointMem(point4);\n+    record.addTuple(point4);\n+\n+    DataPoint point5 = new BooleanDataPoint(\"s5\", true);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s5\") + 17, MemUtils.getDataPointMem(point5));\n+    totalSize += MemUtils.getDataPointMem(point5);\n+    record.addTuple(point5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkxMTA4NQ==", "bodyText": "I don't think serdes is a good abbreviation...", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540911085", "createdAt": "2020-12-11T12:25:30Z", "author": {"login": "Alima777"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SerializeUtilsTest {\n+  @Test\n+  public void serdesStringTest() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkxMzExNA==", "bodyText": "Hi, I checked the name of this method in SerializeUtils, which called just serialize. FMP, it's better to rename it.\nserialize -> serializeIntList,  serialize -> serializeIntSet...", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540913114", "createdAt": "2020-12-11T12:29:13Z", "author": {"login": "Alima777"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SerializeUtilsTest {\n+  @Test\n+  public void serdesStringTest() {\n+    String str = \"abcd%+/123\\n\\t\";\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(str, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(str, SerializeUtils.deserializeString(buffer));\n+  }\n+\n+  @Test\n+  public void serdesStringListTest() {\n+    List<String> slist = Arrays.asList(\"abc\", \"123\", \"y87@\", \"9+&d\\n\");\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeStringList(slist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(slist, SerializeUtils.deserializeStringList(buffer));\n+  }\n+\n+  @Test\n+  public void serdesIntListTest() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkxNTQwMg==", "bodyText": "Actually, there are three types of BatchData, and two of them are subClass of BatchData. You should test them all.", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540915402", "createdAt": "2020-12-11T12:33:33Z", "author": {"login": "Alima777"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SerializeUtilsTest {\n+  @Test\n+  public void serdesStringTest() {\n+    String str = \"abcd%+/123\\n\\t\";\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(str, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(str, SerializeUtils.deserializeString(buffer));\n+  }\n+\n+  @Test\n+  public void serdesStringListTest() {\n+    List<String> slist = Arrays.asList(\"abc\", \"123\", \"y87@\", \"9+&d\\n\");\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeStringList(slist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(slist, SerializeUtils.deserializeStringList(buffer));\n+  }\n+\n+  @Test\n+  public void serdesIntListTest() {\n+    List<Integer> intlist = Arrays.asList(12, 34, 567, 8910);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(intlist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    List<Integer> anotherIntlist = new ArrayList<>();\n+    SerializeUtils.deserialize(anotherIntlist, buffer);\n+    Assert.assertEquals(intlist, anotherIntlist);\n+  }\n+\n+  @Test\n+  public void serdesIntSetTest() {\n+    List<Integer> intlist = Arrays.asList(12, 34, 567, 8910);\n+    Set<Integer> intSet = new TreeSet<>(intlist);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(intSet, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    List<Integer> anotherIntlist = new ArrayList<>();\n+    SerializeUtils.deserialize(anotherIntlist, buffer);\n+    Assert.assertEquals(intlist, anotherIntlist);\n+  }\n+\n+  @Test\n+  public void serdesNodeTest() {\n+    Node node = new Node(\"127.0.0.1\", 6667, 1, 6535, 4678);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(node, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Node anotherNode = new Node(\"127.0.0.1\", 6667, 1, 6535, 4678);\n+    SerializeUtils.deserialize(anotherNode, buffer);\n+    Assert.assertEquals(node, anotherNode);\n+  }\n+\n+  @Test\n+  public void serdesINT32BatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.INT32);\n+    int ivalue = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkxNjYzOA==", "bodyText": "Add javadoc for this and the next test.", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540916638", "createdAt": "2020-12-11T12:35:51Z", "author": {"login": "Alima777"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SerializeUtilsTest {\n+  @Test\n+  public void serdesStringTest() {\n+    String str = \"abcd%+/123\\n\\t\";\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(str, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(str, SerializeUtils.deserializeString(buffer));\n+  }\n+\n+  @Test\n+  public void serdesStringListTest() {\n+    List<String> slist = Arrays.asList(\"abc\", \"123\", \"y87@\", \"9+&d\\n\");\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeStringList(slist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(slist, SerializeUtils.deserializeStringList(buffer));\n+  }\n+\n+  @Test\n+  public void serdesIntListTest() {\n+    List<Integer> intlist = Arrays.asList(12, 34, 567, 8910);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(intlist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    List<Integer> anotherIntlist = new ArrayList<>();\n+    SerializeUtils.deserialize(anotherIntlist, buffer);\n+    Assert.assertEquals(intlist, anotherIntlist);\n+  }\n+\n+  @Test\n+  public void serdesIntSetTest() {\n+    List<Integer> intlist = Arrays.asList(12, 34, 567, 8910);\n+    Set<Integer> intSet = new TreeSet<>(intlist);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(intSet, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    List<Integer> anotherIntlist = new ArrayList<>();\n+    SerializeUtils.deserialize(anotherIntlist, buffer);\n+    Assert.assertEquals(intlist, anotherIntlist);\n+  }\n+\n+  @Test\n+  public void serdesNodeTest() {\n+    Node node = new Node(\"127.0.0.1\", 6667, 1, 6535, 4678);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(node, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Node anotherNode = new Node(\"127.0.0.1\", 6667, 1, 6535, 4678);\n+    SerializeUtils.deserialize(anotherNode, buffer);\n+    Assert.assertEquals(node, anotherNode);\n+  }\n+\n+  @Test\n+  public void serdesINT32BatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.INT32);\n+    int ivalue = 0;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, ivalue);\n+      ivalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesINT64BatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.INT64);\n+    long lvalue = 0;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, lvalue);\n+      lvalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesFLOATBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.FLOAT);\n+    float fvalue = 0f;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, fvalue);\n+      fvalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesDOUBLEBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.DOUBLE);\n+    double dvalue = 0d;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, dvalue);\n+      dvalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesBOOLEANBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.BOOLEAN);\n+    batchData.putAnObject(1, true);\n+    batchData.putAnObject(2, false);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesTEXTBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.TEXT);\n+    String svalue = \"\";\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, Binary.valueOf(svalue));\n+      svalue += String.valueOf(time);\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesTVPairTest() {\n+    List<TimeValuePair> TVPairs = new ArrayList<>();\n+    TimeValuePair p1 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.BOOLEAN, true));\n+    TVPairs.add(p1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkxNzQxMw==", "bodyText": "It's Longs here. And add javadoc.", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540917413", "createdAt": "2020-12-11T12:37:19Z", "author": {"login": "Alima777"}, "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SerializeUtilsTest {\n+  @Test\n+  public void serdesStringTest() {\n+    String str = \"abcd%+/123\\n\\t\";\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(str, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(str, SerializeUtils.deserializeString(buffer));\n+  }\n+\n+  @Test\n+  public void serdesStringListTest() {\n+    List<String> slist = Arrays.asList(\"abc\", \"123\", \"y87@\", \"9+&d\\n\");\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeStringList(slist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(slist, SerializeUtils.deserializeStringList(buffer));\n+  }\n+\n+  @Test\n+  public void serdesIntListTest() {\n+    List<Integer> intlist = Arrays.asList(12, 34, 567, 8910);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(intlist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    List<Integer> anotherIntlist = new ArrayList<>();\n+    SerializeUtils.deserialize(anotherIntlist, buffer);\n+    Assert.assertEquals(intlist, anotherIntlist);\n+  }\n+\n+  @Test\n+  public void serdesIntSetTest() {\n+    List<Integer> intlist = Arrays.asList(12, 34, 567, 8910);\n+    Set<Integer> intSet = new TreeSet<>(intlist);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(intSet, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    List<Integer> anotherIntlist = new ArrayList<>();\n+    SerializeUtils.deserialize(anotherIntlist, buffer);\n+    Assert.assertEquals(intlist, anotherIntlist);\n+  }\n+\n+  @Test\n+  public void serdesNodeTest() {\n+    Node node = new Node(\"127.0.0.1\", 6667, 1, 6535, 4678);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(node, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Node anotherNode = new Node(\"127.0.0.1\", 6667, 1, 6535, 4678);\n+    SerializeUtils.deserialize(anotherNode, buffer);\n+    Assert.assertEquals(node, anotherNode);\n+  }\n+\n+  @Test\n+  public void serdesINT32BatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.INT32);\n+    int ivalue = 0;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, ivalue);\n+      ivalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesINT64BatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.INT64);\n+    long lvalue = 0;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, lvalue);\n+      lvalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesFLOATBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.FLOAT);\n+    float fvalue = 0f;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, fvalue);\n+      fvalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesDOUBLEBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.DOUBLE);\n+    double dvalue = 0d;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, dvalue);\n+      dvalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesBOOLEANBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.BOOLEAN);\n+    batchData.putAnObject(1, true);\n+    batchData.putAnObject(2, false);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesTEXTBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.TEXT);\n+    String svalue = \"\";\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, Binary.valueOf(svalue));\n+      svalue += String.valueOf(time);\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesTVPairTest() {\n+    List<TimeValuePair> TVPairs = new ArrayList<>();\n+    TimeValuePair p1 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.BOOLEAN, true));\n+    TVPairs.add(p1);\n+    TimeValuePair p2 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.INT32, 1));\n+    TVPairs.add(p2);\n+    TimeValuePair p3 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.INT64, 1L));\n+    TVPairs.add(p3);\n+    TimeValuePair p4 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.FLOAT, 1.0f));\n+    TVPairs.add(p4);\n+    TimeValuePair p5 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.DOUBLE, 1.0d));\n+    TVPairs.add(p5);\n+    TimeValuePair p6 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.TEXT, Binary.valueOf(\"a\")));\n+    TVPairs.add(p6);\n+\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    for (TimeValuePair tv : TVPairs) {\n+      SerializeUtils.serializeTVPair(tv, outputStream);\n+      ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+      Assert.assertEquals(tv, SerializeUtils.deserializeTVPair(buffer));\n+      baos.reset();\n+    }\n+\n+  }\n+\n+  @Test\n+  public void serdesTVPairsTest() {\n+    List<List<TimeValuePair>> TVPairs = new ArrayList<>();\n+    TimeValuePair p1 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.BOOLEAN, true));\n+    TVPairs.add(Collections.singletonList(p1));\n+    TimeValuePair p2 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.INT32, 1));\n+    TVPairs.add(Collections.singletonList(p2));\n+    TimeValuePair p3 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.INT64, 1L));\n+    TVPairs.add(Collections.singletonList(p3));\n+    TimeValuePair p4 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.FLOAT, 1.0f));\n+    TVPairs.add(Collections.singletonList(p4));\n+    TimeValuePair p5 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.DOUBLE, 1.0d));\n+    TVPairs.add(Collections.singletonList(p5));\n+    TimeValuePair p6 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.TEXT, Binary.valueOf(\"a\")));\n+    TVPairs.add(Collections.singletonList(p6));\n+\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    for (List<TimeValuePair> tv : TVPairs) {\n+      SerializeUtils.serializeTVPairs(tv, outputStream);\n+      ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+      Assert.assertEquals(tv, SerializeUtils.deserializeTVPairs(buffer));\n+      baos.reset();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesObjectTest() {\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeObject(1, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(1, SerializeUtils.deserializeObject(buffer));\n+  }\n+\n+  @Test\n+  public void serdesObjectsTest() {\n+    Object[] objects = { 1, \"2\", 3d};\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeObjects(objects, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertArrayEquals(objects, SerializeUtils.deserializeObjects(buffer));\n+  }\n+\n+  @Test\n+  public void serdesLongTest() {\n+    long[] array = {1, 10, 100, 1000, 10000};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "234179bc5cea5460663fd51e683b23669d9faafc"}, "originalPosition": 292}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fc0fdcd39d87cbd5ce56c60cc8da266ec198f9a", "author": {"user": {"login": "wshao08", "name": null}}, "url": "https://github.com/apache/iotdb/commit/7fc0fdcd39d87cbd5ce56c60cc8da266ec198f9a", "committedDate": "2020-12-16T01:38:04Z", "message": "More test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9cbfaaee368cbaaae034ebfa418a55193864339", "author": {"user": {"login": "wshao08", "name": null}}, "url": "https://github.com/apache/iotdb/commit/a9cbfaaee368cbaaae034ebfa418a55193864339", "committedDate": "2020-12-17T09:58:13Z", "message": "More test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a5791d014f0113f22ad6f68034fdbddfff40b4e", "author": {"user": {"login": "wshao08", "name": null}}, "url": "https://github.com/apache/iotdb/commit/4a5791d014f0113f22ad6f68034fdbddfff40b4e", "committedDate": "2020-12-17T10:10:31Z", "message": "rename serialize methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47af65f45ecffc78b6e4f6416b0115d474418825", "author": {"user": {"login": "wshao08", "name": null}}, "url": "https://github.com/apache/iotdb/commit/47af65f45ecffc78b6e4f6416b0115d474418825", "committedDate": "2020-12-18T10:48:01Z", "message": "Merge remote-tracking branch 'upstream/master' into unittest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NDU5MjQ4", "url": "https://github.com/apache/iotdb/pull/2246#pullrequestreview-555459248", "createdAt": "2020-12-18T12:50:49Z", "commit": {"oid": "47af65f45ecffc78b6e4f6416b0115d474418825"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4098, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}