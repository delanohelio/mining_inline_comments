{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwODE0MDky", "number": 1514, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDowNDozN1rOFBsjww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzoxODo0NVrOFBxlbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MzIyOTQ3OnYy", "diffSide": "RIGHT", "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDowNDozN1rOIAe90w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNDozODoxOFrOIAp1_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM3ODI1OQ==", "bodyText": "Storing the payload in a class level variable would cause issues in multithreaded approaches.", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537378259", "createdAt": "2020-12-07T10:04:37Z", "author": {"login": "jsdjayanga"}, "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());\n+  //if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+  // if stream is not ended, stop continueing to other filters and buffer. \n+  if (!end_stream) {\n+    return Http::FilterHeadersStatus::StopIteration;\n+  }\n+  //once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n+\n+  // if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  ENVOY_LOG(trace, \"decodeData with data = {} , end_stream = {}\", data.toString(), end_stream);\n+  // if stream is not ended, stop continueing to other filters and buffer.\n+  if (!end_stream) {\n+    return Http::FilterDataStatus::StopIterationAndBuffer;\n+  }\n+  // once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+void Filter::setPayload(std::string new_payload, const Buffer::Instance* decoding_buffer,\n+                     Http::RequestHeaderMap* req_headers) {\n+  ENVOY_LOG(debug, \"Modifying payload ...\");\n+  // create a new buffer instance with new payload data.\n+  Buffer::OwnedImpl modified_body(new_payload);\n+\n+  //if we never got a payload from the downstream/ header only request.\n+  if (decoding_buffer == nullptr) {\n+    // We are not streaming back this this payload data so we set streaming_filter = false.\n+    req_callbacks_->addDecodedData(modified_body, false);\n+  }\n+  else {\n+    // Since we modifying the existing payload, we drain the data buffer and add new data.\n+    req_callbacks_->modifyDecodingBuffer([&modified_body](Buffer::Instance& data) {\n+      data.drain(data.length());\n+      data.move(modified_body);\n+    });\n+  }\n+  // Since we modified the payload, need to set new content length.\n+  decoding_buffer = req_callbacks_->decodingBuffer();\n+  req_headers->setContentLength(decoding_buffer->length());\n+  ENVOY_LOG(debug, \"payload successfully modified\");\n+}\n+\n+bool Filter::readMetadata(const envoy::config::core::v3::Metadata* metadata) {\n+  std::string jsonJWTPayload;\n+  // We read metadata under ext_authz filter and if find a key \"payload\", \n+  // then decide to modify the payload.\n+  std::string PayloadMetadataKey = \"payload\";\n+  // Reading metadata under external authorization\n+  const auto* payload = &Config::Metadata::metadataValue(\n+      metadata, HttpFilterNames::get().ExtAuthorization, PayloadMetadataKey);\n+\n+  if (payload != nullptr && (payload->kind_case() == ProtobufWkt::Value::kStringValue)) {\n+    modified_body_ = payload->string_value();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1NjQ3OA==", "bodyText": "Filter obj are initiated per request stream, this will not break multithreaded scenarios. referring https://www.envoyproxy.io/docs/envoy/latest/intro/life_of_a_request#http-filter-chain-processing", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537556478", "createdAt": "2020-12-07T14:38:18Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());\n+  //if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+  // if stream is not ended, stop continueing to other filters and buffer. \n+  if (!end_stream) {\n+    return Http::FilterHeadersStatus::StopIteration;\n+  }\n+  //once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n+\n+  // if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  ENVOY_LOG(trace, \"decodeData with data = {} , end_stream = {}\", data.toString(), end_stream);\n+  // if stream is not ended, stop continueing to other filters and buffer.\n+  if (!end_stream) {\n+    return Http::FilterDataStatus::StopIterationAndBuffer;\n+  }\n+  // once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+void Filter::setPayload(std::string new_payload, const Buffer::Instance* decoding_buffer,\n+                     Http::RequestHeaderMap* req_headers) {\n+  ENVOY_LOG(debug, \"Modifying payload ...\");\n+  // create a new buffer instance with new payload data.\n+  Buffer::OwnedImpl modified_body(new_payload);\n+\n+  //if we never got a payload from the downstream/ header only request.\n+  if (decoding_buffer == nullptr) {\n+    // We are not streaming back this this payload data so we set streaming_filter = false.\n+    req_callbacks_->addDecodedData(modified_body, false);\n+  }\n+  else {\n+    // Since we modifying the existing payload, we drain the data buffer and add new data.\n+    req_callbacks_->modifyDecodingBuffer([&modified_body](Buffer::Instance& data) {\n+      data.drain(data.length());\n+      data.move(modified_body);\n+    });\n+  }\n+  // Since we modified the payload, need to set new content length.\n+  decoding_buffer = req_callbacks_->decodingBuffer();\n+  req_headers->setContentLength(decoding_buffer->length());\n+  ENVOY_LOG(debug, \"payload successfully modified\");\n+}\n+\n+bool Filter::readMetadata(const envoy::config::core::v3::Metadata* metadata) {\n+  std::string jsonJWTPayload;\n+  // We read metadata under ext_authz filter and if find a key \"payload\", \n+  // then decide to modify the payload.\n+  std::string PayloadMetadataKey = \"payload\";\n+  // Reading metadata under external authorization\n+  const auto* payload = &Config::Metadata::metadataValue(\n+      metadata, HttpFilterNames::get().ExtAuthorization, PayloadMetadataKey);\n+\n+  if (payload != nullptr && (payload->kind_case() == ProtobufWkt::Value::kStringValue)) {\n+    modified_body_ = payload->string_value();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM3ODI1OQ=="}, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MzIzOTE1OnYy", "diffSide": "RIGHT", "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDowNjo1MVrOIAfDnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNDozODoyN1rOIAp2Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM3OTc0Mw==", "bodyText": "If method decodeHeaders() is called before setDecoderFilterCallbacks() method, code will break at this line", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537379743", "createdAt": "2020-12-07T10:06:51Z", "author": {"login": "jsdjayanga"}, "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1NjU4Mg==", "bodyText": "setDecoderFilterCallbacks is called at the filter initiation. Therefore it will be called before other decode methods. https://github.com/envoyproxy/envoy/blob/9aa5c75d6be62cda62a1e00a12b681a8377db9ca/include/envoy/http/filter.h#L620", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537556582", "createdAt": "2020-12-07T14:38:27Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM3OTc0Mw=="}, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MzI5MjU3OnYy", "diffSide": "RIGHT", "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDoxODoyMVrOIAfiUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNDo0NzoyOFrOIBG3rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4NzYwMQ==", "bodyText": "What is the usage of this variable?", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537387601", "createdAt": "2020-12-07T10:18:21Z", "author": {"login": "jsdjayanga"}, "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());\n+  //if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+  // if stream is not ended, stop continueing to other filters and buffer. \n+  if (!end_stream) {\n+    return Http::FilterHeadersStatus::StopIteration;\n+  }\n+  //once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n+\n+  // if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  ENVOY_LOG(trace, \"decodeData with data = {} , end_stream = {}\", data.toString(), end_stream);\n+  // if stream is not ended, stop continueing to other filters and buffer.\n+  if (!end_stream) {\n+    return Http::FilterDataStatus::StopIterationAndBuffer;\n+  }\n+  // once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+void Filter::setPayload(std::string new_payload, const Buffer::Instance* decoding_buffer,\n+                     Http::RequestHeaderMap* req_headers) {\n+  ENVOY_LOG(debug, \"Modifying payload ...\");\n+  // create a new buffer instance with new payload data.\n+  Buffer::OwnedImpl modified_body(new_payload);\n+\n+  //if we never got a payload from the downstream/ header only request.\n+  if (decoding_buffer == nullptr) {\n+    // We are not streaming back this this payload data so we set streaming_filter = false.\n+    req_callbacks_->addDecodedData(modified_body, false);\n+  }\n+  else {\n+    // Since we modifying the existing payload, we drain the data buffer and add new data.\n+    req_callbacks_->modifyDecodingBuffer([&modified_body](Buffer::Instance& data) {\n+      data.drain(data.length());\n+      data.move(modified_body);\n+    });\n+  }\n+  // Since we modified the payload, need to set new content length.\n+  decoding_buffer = req_callbacks_->decodingBuffer();\n+  req_headers->setContentLength(decoding_buffer->length());\n+  ENVOY_LOG(debug, \"payload successfully modified\");\n+}\n+\n+bool Filter::readMetadata(const envoy::config::core::v3::Metadata* metadata) {\n+  std::string jsonJWTPayload;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAzMjA0NQ==", "bodyText": "Thanks. fixed", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r538032045", "createdAt": "2020-12-08T04:47:28Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());\n+  //if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+  // if stream is not ended, stop continueing to other filters and buffer. \n+  if (!end_stream) {\n+    return Http::FilterHeadersStatus::StopIteration;\n+  }\n+  //once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n+\n+  // if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  ENVOY_LOG(trace, \"decodeData with data = {} , end_stream = {}\", data.toString(), end_stream);\n+  // if stream is not ended, stop continueing to other filters and buffer.\n+  if (!end_stream) {\n+    return Http::FilterDataStatus::StopIterationAndBuffer;\n+  }\n+  // once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+void Filter::setPayload(std::string new_payload, const Buffer::Instance* decoding_buffer,\n+                     Http::RequestHeaderMap* req_headers) {\n+  ENVOY_LOG(debug, \"Modifying payload ...\");\n+  // create a new buffer instance with new payload data.\n+  Buffer::OwnedImpl modified_body(new_payload);\n+\n+  //if we never got a payload from the downstream/ header only request.\n+  if (decoding_buffer == nullptr) {\n+    // We are not streaming back this this payload data so we set streaming_filter = false.\n+    req_callbacks_->addDecodedData(modified_body, false);\n+  }\n+  else {\n+    // Since we modifying the existing payload, we drain the data buffer and add new data.\n+    req_callbacks_->modifyDecodingBuffer([&modified_body](Buffer::Instance& data) {\n+      data.drain(data.length());\n+      data.move(modified_body);\n+    });\n+  }\n+  // Since we modified the payload, need to set new content length.\n+  decoding_buffer = req_callbacks_->decodingBuffer();\n+  req_headers->setContentLength(decoding_buffer->length());\n+  ENVOY_LOG(debug, \"payload successfully modified\");\n+}\n+\n+bool Filter::readMetadata(const envoy::config::core::v3::Metadata* metadata) {\n+  std::string jsonJWTPayload;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4NzYwMQ=="}, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MzI5NDE4OnYy", "diffSide": "RIGHT", "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDoxODo0MVrOIAfjTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNDo0NzoxM1rOIBG3Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4Nzg1NA==", "bodyText": "This can be a const", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537387854", "createdAt": "2020-12-07T10:18:41Z", "author": {"login": "jsdjayanga"}, "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());\n+  //if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+  // if stream is not ended, stop continueing to other filters and buffer. \n+  if (!end_stream) {\n+    return Http::FilterHeadersStatus::StopIteration;\n+  }\n+  //once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n+\n+  // if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  ENVOY_LOG(trace, \"decodeData with data = {} , end_stream = {}\", data.toString(), end_stream);\n+  // if stream is not ended, stop continueing to other filters and buffer.\n+  if (!end_stream) {\n+    return Http::FilterDataStatus::StopIterationAndBuffer;\n+  }\n+  // once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+void Filter::setPayload(std::string new_payload, const Buffer::Instance* decoding_buffer,\n+                     Http::RequestHeaderMap* req_headers) {\n+  ENVOY_LOG(debug, \"Modifying payload ...\");\n+  // create a new buffer instance with new payload data.\n+  Buffer::OwnedImpl modified_body(new_payload);\n+\n+  //if we never got a payload from the downstream/ header only request.\n+  if (decoding_buffer == nullptr) {\n+    // We are not streaming back this this payload data so we set streaming_filter = false.\n+    req_callbacks_->addDecodedData(modified_body, false);\n+  }\n+  else {\n+    // Since we modifying the existing payload, we drain the data buffer and add new data.\n+    req_callbacks_->modifyDecodingBuffer([&modified_body](Buffer::Instance& data) {\n+      data.drain(data.length());\n+      data.move(modified_body);\n+    });\n+  }\n+  // Since we modified the payload, need to set new content length.\n+  decoding_buffer = req_callbacks_->decodingBuffer();\n+  req_headers->setContentLength(decoding_buffer->length());\n+  ENVOY_LOG(debug, \"payload successfully modified\");\n+}\n+\n+bool Filter::readMetadata(const envoy::config::core::v3::Metadata* metadata) {\n+  std::string jsonJWTPayload;\n+  // We read metadata under ext_authz filter and if find a key \"payload\", \n+  // then decide to modify the payload.\n+  std::string PayloadMetadataKey = \"payload\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAzMTkzOA==", "bodyText": "Thanks. Fixed", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r538031938", "createdAt": "2020-12-08T04:47:13Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());\n+  //if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+  // if stream is not ended, stop continueing to other filters and buffer. \n+  if (!end_stream) {\n+    return Http::FilterHeadersStatus::StopIteration;\n+  }\n+  //once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n+\n+  // if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  ENVOY_LOG(trace, \"decodeData with data = {} , end_stream = {}\", data.toString(), end_stream);\n+  // if stream is not ended, stop continueing to other filters and buffer.\n+  if (!end_stream) {\n+    return Http::FilterDataStatus::StopIterationAndBuffer;\n+  }\n+  // once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+void Filter::setPayload(std::string new_payload, const Buffer::Instance* decoding_buffer,\n+                     Http::RequestHeaderMap* req_headers) {\n+  ENVOY_LOG(debug, \"Modifying payload ...\");\n+  // create a new buffer instance with new payload data.\n+  Buffer::OwnedImpl modified_body(new_payload);\n+\n+  //if we never got a payload from the downstream/ header only request.\n+  if (decoding_buffer == nullptr) {\n+    // We are not streaming back this this payload data so we set streaming_filter = false.\n+    req_callbacks_->addDecodedData(modified_body, false);\n+  }\n+  else {\n+    // Since we modifying the existing payload, we drain the data buffer and add new data.\n+    req_callbacks_->modifyDecodingBuffer([&modified_body](Buffer::Instance& data) {\n+      data.drain(data.length());\n+      data.move(modified_body);\n+    });\n+  }\n+  // Since we modified the payload, need to set new content length.\n+  decoding_buffer = req_callbacks_->decodingBuffer();\n+  req_headers->setContentLength(decoding_buffer->length());\n+  ENVOY_LOG(debug, \"payload successfully modified\");\n+}\n+\n+bool Filter::readMetadata(const envoy::config::core::v3::Metadata* metadata) {\n+  std::string jsonJWTPayload;\n+  // We read metadata under ext_authz filter and if find a key \"payload\", \n+  // then decide to modify the payload.\n+  std::string PayloadMetadataKey = \"payload\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4Nzg1NA=="}, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NDA0MjkwOnYy", "diffSide": "RIGHT", "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzoxNjoyNVrOIAmQWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzoxNjoyNVrOIAmQWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ5NzY5MQ==", "bodyText": "Refactor trace logs. avoid toString()", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537497691", "createdAt": "2020-12-07T13:16:25Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());\n+  //if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+  // if stream is not ended, stop continueing to other filters and buffer. \n+  if (!end_stream) {\n+    return Http::FilterHeadersStatus::StopIteration;\n+  }\n+  //once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n+\n+  // if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  ENVOY_LOG(trace, \"decodeData with data = {} , end_stream = {}\", data.toString(), end_stream);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NDA0ODQ4OnYy", "diffSide": "RIGHT", "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzoxNzozN1rOIAmTmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzoxNzozN1rOIAmTmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ5ODUyMQ==", "bodyText": "Let's drain the buffer since we modify the payload anyway. to avoid complications like buffer overflows.", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537498521", "createdAt": "2020-12-07T13:17:37Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());\n+  //if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+  // if stream is not ended, stop continueing to other filters and buffer. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NDA1MDU2OnYy", "diffSide": "RIGHT", "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzoxODoxMFrOIAmUyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzoxODoxMFrOIAmUyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ5ODgyNw==", "bodyText": "Check and handle if\u00a0ending stream happens in decodeTrailers.", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537498827", "createdAt": "2020-12-07T13:18:10Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NDA1Mjk0OnYy", "diffSide": "RIGHT", "path": "envoy-filters/ci/do_ci.sh", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzoxODo0NVrOIAmWLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzoxODo0NVrOIAmWLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ5OTE4MA==", "bodyText": "Need a release build script for the envoy image", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537499180", "createdAt": "2020-12-07T13:18:45Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "envoy-filters/ci/do_ci.sh", "diffHunk": "@@ -0,0 +1,35 @@\n+#!/bin/bash -e\n+\n+# TODO (amalimatharaarachchi) Write a release build script.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 3}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1177, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}