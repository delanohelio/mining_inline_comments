{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzMjE4MTcx", "number": 1368, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNzoyMzo1NFrOEVszig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNzozMzo0NVrOEVtAbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMTg5NjQyOnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/utils/throttle_util.bal", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNzoyMzo1NFrOG8mfQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNzoyMzo1NFrOG8mfQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE5ODMzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/wso2/product-microgateway/pull/1368#discussion_r466198338", "createdAt": "2020-08-06T07:23:54Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/utils/throttle_util.bal", "diffHunk": "@@ -61,6 +67,86 @@ public function isRequestThrottled(string key) returns [boolean, boolean] {\n     return [isThrottled, false];\n }\n \n+# Decide whether request details provided in arguments is throttled or not by the global traffic manager.\n+# This function is deinfed to evalute only API and Resource level throttling decisions recieved from the\n+# traffic manager.\n+#\n+# + key - throttle key of the request\n+# + info - request details required to make conditional throttle decisions\n+# + return - [is request throttled, should stop on quota]\n+public function isApiThrottledByTM(string key, ConditionalThrottleInfo? info) returns [boolean, boolean] {\n+    printDebug(KEY_THROTTLE_UTIL, \"throttle data map : \" + throttleDataMap.toString());\n+    printDebug(KEY_THROTTLE_UTIL, \"throttle data key : \" + key);\n+    boolean isThrottled = false;\n+    boolean stopOnQuota = false;\n+\n+    if (enabledGlobalTMEventPublishing == false) {\n+        return [false, false];\n+    }\n+    boolean hasThrottledCondition = conditionDataMap.hasKey(key);\n+    printDebug(KEY_THROTTLE_UTIL, \"hasThrottledCondition : \" + hasThrottledCondition.toString());\n+\n+    if (hasThrottledCondition && (info is ConditionalThrottleInfo)) {\n+        // get the condition groups for provided throttleKey\n+        map<ConditionDto[]> conditionGrps = conditionDataMap.get(key);\n+        string? conditionKey = ();\n+\n+        // iterate through all available conditions and find if the current request\n+        // attributes are eligible to be throttled by the available throttled conditions\n+        foreach var [name, dto] in conditionGrps.entries() {\n+            if (DEFAULT_THROTTLE_CONDITION != name) {\n+                boolean isPipelineThrottled = isThrottledByCondition(dto, info);\n+                if (isPipelineThrottled) {\n+                    conditionKey = name;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (conditionKey is () && conditionGrps.hasKey(DEFAULT_THROTTLE_CONDITION)) {\n+            ConditionDto[] dto = conditionGrps.get(DEFAULT_THROTTLE_CONDITION);\n+            boolean isPipelineThrottled = isThrottledByCondition(dto, info);\n+            if (!isPipelineThrottled) {\n+                conditionKey = DEFAULT_THROTTLE_CONDITION;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4449279dca17e2be3898964f46701494a5af0ac"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMTkxOTQ1OnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/utils/throttle_util.bal", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNzozMDo0MVrOG8msmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNzozMDo0MVrOG8msmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIwMTc1Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    _ = throttleDataMap.remove(key);\n          \n          \n            \n                                    _ = throttleDataMap.remove(combinedThrottleKey);", "url": "https://github.com/wso2/product-microgateway/pull/1368#discussion_r466201753", "createdAt": "2020-08-06T07:30:41Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/utils/throttle_util.bal", "diffHunk": "@@ -61,6 +67,86 @@ public function isRequestThrottled(string key) returns [boolean, boolean] {\n     return [isThrottled, false];\n }\n \n+# Decide whether request details provided in arguments is throttled or not by the global traffic manager.\n+# This function is deinfed to evalute only API and Resource level throttling decisions recieved from the\n+# traffic manager.\n+#\n+# + key - throttle key of the request\n+# + info - request details required to make conditional throttle decisions\n+# + return - [is request throttled, should stop on quota]\n+public function isApiThrottledByTM(string key, ConditionalThrottleInfo? info) returns [boolean, boolean] {\n+    printDebug(KEY_THROTTLE_UTIL, \"throttle data map : \" + throttleDataMap.toString());\n+    printDebug(KEY_THROTTLE_UTIL, \"throttle data key : \" + key);\n+    boolean isThrottled = false;\n+    boolean stopOnQuota = false;\n+\n+    if (enabledGlobalTMEventPublishing == false) {\n+        return [false, false];\n+    }\n+    boolean hasThrottledCondition = conditionDataMap.hasKey(key);\n+    printDebug(KEY_THROTTLE_UTIL, \"hasThrottledCondition : \" + hasThrottledCondition.toString());\n+\n+    if (hasThrottledCondition && (info is ConditionalThrottleInfo)) {\n+        // get the condition groups for provided throttleKey\n+        map<ConditionDto[]> conditionGrps = conditionDataMap.get(key);\n+        string? conditionKey = ();\n+\n+        // iterate through all available conditions and find if the current request\n+        // attributes are eligible to be throttled by the available throttled conditions\n+        foreach var [name, dto] in conditionGrps.entries() {\n+            if (DEFAULT_THROTTLE_CONDITION != name) {\n+                boolean isPipelineThrottled = isThrottledByCondition(dto, info);\n+                if (isPipelineThrottled) {\n+                    conditionKey = name;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (conditionKey is () && conditionGrps.hasKey(DEFAULT_THROTTLE_CONDITION)) {\n+            ConditionDto[] dto = conditionGrps.get(DEFAULT_THROTTLE_CONDITION);\n+            boolean isPipelineThrottled = isThrottledByCondition(dto, info);\n+            if (!isPipelineThrottled) {\n+                conditionKey = DEFAULT_THROTTLE_CONDITION;\n+\n+            }\n+        }\n+\n+        // if we detect the request is throttled by a condition. Then check the validity of throttle\n+        // decision from the throttle event data available in the throttleDataMap\n+        if (conditionKey is string) {\n+            printDebug(KEY_THROTTLE_UTIL, \"throttled with condition: \" + conditionKey);\n+            string combinedThrottleKey = key + \"_\" + conditionKey;\n+\n+            // if throttle data is not available for the combined key, conditional throttle decision\n+            // is no longer valid\n+            if (!throttleDataMap.hasKey(combinedThrottleKey)) {\n+                return [false, false];\n+            }\n+            var dto = throttleDataMap.get(combinedThrottleKey);\n+            if (dto is GlobalThrottleStreamDTO) {\n+                int currentTime = time:currentTime().time;\n+                int? resetTimestamp = dto.resetTimestamp;\n+                stopOnQuota = true;\n+                if (resetTimestamp is int) {\n+                    if (resetTimestamp < currentTime) {\n+                        _ = throttleDataMap.remove(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4449279dca17e2be3898964f46701494a5af0ac"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMTkyOTQxOnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/utils/throttle_util.bal", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNzozMzo0NVrOG8myow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNzozMzo0NVrOG8myow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIwMzI5OQ==", "bodyText": "check decode.customClaims.hasKey scenario", "url": "https://github.com/wso2/product-microgateway/pull/1368#discussion_r466203299", "createdAt": "2020-08-06T07:33:45Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/utils/throttle_util.bal", "diffHunk": "@@ -241,3 +351,227 @@ function modifyIpWithNumericRanges(IPRangeDTO ipRange) {\n     }\n }\n \n+\n+# Build a list of `ConditionDto`s from the provided base64 encoded condition list.\n+#\n+# + base64Conditions - A base64 encoded json string containing the list of conditions\n+# evaluated by the throttle engine to take the throttle decision.\n+# + return - A list of conditions evaluated during making the throttle decision. Incase of an\n+# error during converting the conditions, empty `ConditionDto[]` will be returned\n+function extractConditionDto(string base64Conditions) returns ConditionDto[] {\n+    ConditionDto[] conditions = [];\n+    byte[]|error base64Decoded = encoding:decodeBase64Url(base64Conditions);\n+    if (base64Decoded is byte[]) {\n+        string|error result = strings:fromBytes(base64Decoded);\n+        if (result is error) {\n+            printError(KEY_THROTTLE_UTIL, result.reason(), result);\n+        }\n+\n+        string conditionsPayload = <string>result;\n+        json[] | error jsonPayload = <json[]>conditionsPayload.fromJsonString();\n+\n+        if (jsonPayload is json[]) {\n+            printDebug(KEY_THROTTLE_UTIL, \"Decoded throttle conditions json :\" + jsonPayload.toJsonString());\n+\n+            foreach json condition in jsonPayload {\n+                ConditionDto conditionDto = {};\n+                var jIpSpecific = condition.ipspecific;\n+                var jIpRange = condition.iprange;\n+                var jHeader = condition.header;\n+                var jQuery = condition.queryparametertype;\n+                var jJwt = condition.jwtclaims;\n+\n+                // Build IP condition DTOs\n+                if (jIpSpecific is json) {\n+                    IPCondition ip = {\n+                        specificIp: jIpSpecific.specificIp.toString(),\n+                        invert: <boolean>jIpSpecific.invert\n+                    };\n+                    conditionDto.ipCondition = ip;\n+                } else if (jIpRange is json) {\n+                    IPCondition ip = {\n+                        startingIp: jIpRange.startingIp.toString(),\n+                        endingIp: jIpRange.endingIp.toString(),\n+                        invert: <boolean>jIpRange.invert\n+                    };\n+                    conditionDto.ipRangeCondition = ip;\n+                }\n+\n+                // Build header condition DTOs\n+                if (jHeader is json) {\n+                    var header = HeaderConditions.constructFrom(jHeader);\n+                    if (header is HeaderConditions) {\n+                        conditionDto.headerConditions = header;\n+                    } else {\n+                        printError(KEY_THROTTLE_UTIL, \"HeaderCondition is not in the expected format\", header);\n+                    }\n+                }\n+\n+                // Build query param condition DTOs\n+                if (jQuery is json) {\n+                    var query = QueryParamConditions.constructFrom(jQuery);\n+                    if (query is QueryParamConditions) {\n+                        conditionDto.queryParamConditions = query;\n+                    } else {\n+                        printError(KEY_THROTTLE_UTIL, \"QueryParamCondition is not in the expected format\", query);\n+                    }\n+                }\n+\n+                // Build jwt condition DTOs\n+                if (jJwt is json) {\n+                    var jwt = JwtConditions.constructFrom(jJwt);\n+                    if (jwt is JwtConditions) {\n+                        conditionDto.jwtClaimConditions = jwt;\n+                    } else {\n+                        printError(KEY_THROTTLE_UTIL, \"JwtConditions is not in the expected format\", jwt);\n+                    }\n+                }\n+\n+                conditions.push(conditionDto);\n+            }\n+        } else {\n+            printError(KEY_THROTTLE_UTIL, \"Couldn't build a valid json from the throttle conditions\", jsonPayload);\n+        }\n+    } else {\n+        printError(KEY_THROTTLE_UTIL, \"Couldn't decode throttle conditions\", base64Decoded);\n+    }\n+\n+    return conditions;\n+}\n+\n+# Check if the request is throttled by an advanced throttle condition.\n+# Such as IP, header, query param based conditions.\n+#\n+# + conditions - throttled conditions recieved from global throttle engine\n+# + info - information required to derive conditional throttle status\n+# + return - `true` if throttled by a condition, `false` otherwise\n+function isThrottledByCondition(ConditionDto[] conditions, ConditionalThrottleInfo info) returns boolean {\n+    boolean isThrottled = false;\n+\n+    foreach ConditionDto condition in conditions {\n+        // We initially set throttled flag to true. Then we move onto evaluating all conditions and\n+        // set the flag to false accordingly. This is done in this way to implement the `AND` logic\n+        // between each condition inside a condition group.\n+        isThrottled = true;\n+        HeaderConditions? headerConditions = condition?.headerConditions;\n+        IPCondition? ipCondition = condition?.ipCondition;\n+        IPCondition? ipRangeCondition = condition?.ipRangeCondition;\n+        QueryParamConditions? queryConditions = condition?.queryParamConditions;\n+        JwtConditions? claimConditions = condition?.jwtClaimConditions;\n+\n+        if (ipCondition is IPCondition) {\n+            if (!isMatchingIp(info.clientIp, ipCondition)) {\n+                isThrottled = false;\n+            }\n+        } else if (ipRangeCondition is IPCondition) {\n+            if (!isWithinIpRange(info.clientIp, ipRangeCondition)) {\n+                isThrottled = false;\n+            }\n+        }\n+        if (info.isHeaderConditionsEnabled && (headerConditions is HeaderConditions)) {\n+            if (!isHeaderPresent(info.request, headerConditions)) {\n+                isThrottled = false;\n+            }\n+        }\n+        if (info.isQueryConditionsEnabled && (queryConditions is QueryParamConditions)) {\n+            if (!isQueryParamPresent(info.request, queryConditions)) {\n+                isThrottled = false;\n+            }\n+        }\n+        if (info.isJwtConditionsEnabled && (claimConditions is JwtConditions)) {\n+            if (!isClaimPresent(info.request, claimConditions)) {\n+                isThrottled = false;\n+            }\n+        }\n+\n+        if (isThrottled) {\n+            break;\n+        }\n+    }\n+\n+    return isThrottled;\n+}\n+\n+function isMatchingIp(string clientIp, IPCondition ipCondition) returns boolean {\n+    string longIp = ipToBigInteger(clientIp);\n+    boolean isMatched = (longIp == ipCondition.specificIp);\n+\n+    if (ipCondition.invert) {\n+        return !isMatched;\n+    }\n+\n+    return isMatched;\n+}\n+\n+function isWithinIpRange(string clientIp, IPCondition ipCondition) returns boolean {\n+    boolean isMatched = isIpWithinRange(clientIp, ipCondition.startingIp, ipCondition.endingIp);\n+\n+    if (ipCondition.invert) {\n+        return !isMatched;\n+    }\n+\n+    return isMatched;\n+}\n+\n+function isHeaderPresent(http:Request req, HeaderConditions conditions) returns boolean {\n+    boolean status = true;\n+\n+    foreach var [name, value] in conditions.values.entries() {\n+        if (req.hasHeader(name)) {\n+            string headerVal = req.getHeader(name);\n+            if (headerVal != \"\") {\n+                status = status && isPatternMatched(value, headerVal);\n+            } else {\n+                status = false;\n+                break;\n+            }\n+        }\n+    }\n+\n+    status = conditions.invert ? !status : status;\n+    return status;\n+}\n+\n+function isQueryParamPresent(http:Request req, QueryParamConditions conditions) returns boolean {\n+    boolean status = true;\n+\n+    foreach var [name, value] in conditions.values.entries() {\n+        string? paramValue = req.getQueryParamValue(name);\n+        if (paramValue is string) {\n+            if (paramValue != \"\") {\n+                status = status && isPatternMatched(value, paramValue);\n+            } else {\n+                status = false;\n+                break;\n+            }\n+        }\n+    }\n+\n+    status = conditions.invert ? !status : status;\n+    return status;\n+}\n+\n+function isClaimPresent(http:Request req, QueryParamConditions conditions) returns boolean {\n+    boolean status = true;\n+    string? assertion = req.hasHeader(jwtheaderName) ? req.getHeader(jwtheaderName) : ();\n+\n+    if (assertion is string) {\n+        jwt:JwtPayload | error decoded = decodeJWTPayload(assertion);\n+        if (decoded is jwt:JwtPayload) {\n+            foreach var [name, value] in conditions.values.entries() {\n+                if (decoded.hasKey(name)) {\n+                    printInfo(\"TEST\", \"present in decoded : \" + decoded.get(name).toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4449279dca17e2be3898964f46701494a5af0ac"}, "originalPosition": 371}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1111, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}