{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzMjE4MTcx", "number": 1368, "title": "Introduce conditional throttling", "bodyText": "Purpose\n\nIntroduce conditional throttling with traffic manager. This supports Advance throttle conditions such as,\n\nHeader conditions\nQuery param conditions\nIP conditions\nJwt claim conditions\n\nTo avoid unwanted load on the gateway, header, query param and jwt claim conditions should be separately enabled using below configurations when needed. By default IP related conditions are enabled and other conditions are disabled.\n[throttlingConfig]\n  # Enable global advanced throttling based on request header conditions\n  enableHeaderConditions = false\n  # Enable global advanced throttling based on request query parameter conditions\n  enableQueryParamConditions = false\n  # Enable global advanced throttling based on jwt claim conditions\n  enableJwtClaimConditions = false\nIssues\n\nFixes #1343\nAutomation tests\n\nUnit tests added: No\nIntegration tests added: No\n\nTested environments\n\nMacOS\n\nMaintainers: Check before merge\n\n Assigned 'Type' label\n Assigned the project\n Validated respective github issues\n Assigned milestone to the github issue(s)", "createdAt": "2020-08-05T08:03:07Z", "url": "https://github.com/wso2/product-microgateway/pull/1368", "merged": true, "mergeCommit": {"oid": "e93c1045e7ade0cd634cf3f8587df85ccc179c19"}, "closed": true, "closedAt": "2020-08-07T15:42:44Z", "author": {"login": "praminda"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc72LjBAH2gAyNDYzMjE4MTcxOjFiOTNiN2I5YzBlY2FiZjc4NjMyNmVhNzIzOTE5NmRjZWQ2ODRlNDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc8mJkdgFqTQ2MzQwNDU5Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1b93b7b9c0ecabf786326ea7239196dced684e41", "author": {"user": {"login": "praminda", "name": "Praminda"}}, "url": "https://github.com/wso2/product-microgateway/commit/1b93b7b9c0ecabf786326ea7239196dced684e41", "committedDate": "2020-08-05T07:35:06Z", "message": "throttle: Publish conditional properties\n\nConfigurations are added to enable conditional data publishing.\nThis is required to prevent unneccesaray processing of conditional\nthrottle data."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b08c97259ee6b07012509215d0756cc69af4230d", "author": {"user": {"login": "praminda", "name": "Praminda"}}, "url": "https://github.com/wso2/product-microgateway/commit/b08c97259ee6b07012509215d0756cc69af4230d", "committedDate": "2020-08-05T07:35:06Z", "message": "throttle: Extract condition info from key\n\ninterop is used to get the regex functionalities missing in b7a"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2831fb891ca0322263db73b32644c428f523da6e", "author": {"user": {"login": "praminda", "name": "Praminda"}}, "url": "https://github.com/wso2/product-microgateway/commit/2831fb891ca0322263db73b32644c428f523da6e", "committedDate": "2020-08-05T07:35:06Z", "message": "throttle: Store conditions in a map"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d835af03ddfb08d4be3583b785f38096e8bde6c", "author": {"user": {"login": "praminda", "name": "Praminda"}}, "url": "https://github.com/wso2/product-microgateway/commit/4d835af03ddfb08d4be3583b785f38096e8bde6c", "committedDate": "2020-08-05T07:35:06Z", "message": "throttle: Add conditional info dto\n\nUsed to easily pass around the data required to evaluated\nconditional throttle decisions."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6c441bcec5f737b61998a4815c1003e67ab7fa6", "author": {"user": {"login": "praminda", "name": "Praminda"}}, "url": "https://github.com/wso2/product-microgateway/commit/a6c441bcec5f737b61998a4815c1003e67ab7fa6", "committedDate": "2020-08-05T07:35:06Z", "message": "throttle: Evaluate conditional decisions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97b056be2bd6a025096f3615e4c95be37dad441a", "author": {"user": {"login": "praminda", "name": "Praminda"}}, "url": "https://github.com/wso2/product-microgateway/commit/97b056be2bd6a025096f3615e4c95be37dad441a", "committedDate": "2020-08-05T07:56:41Z", "message": "throttle: Evaluate TM decisions separately\n\n(Api, resource) level decisions and other level of decisions are\nnow separately evaluated because with conditional throttling,\nlogic to check API and resource level throttling has changed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f75d2009ebdde09634ae2654a766be92b5c3255d", "author": {"user": {"login": "praminda", "name": "Praminda"}}, "url": "https://github.com/wso2/product-microgateway/commit/f75d2009ebdde09634ae2654a766be92b5c3255d", "committedDate": "2020-08-05T07:57:12Z", "message": "throttle: Publish jwt claims\n\nif jwt claim conditions and backend jwt is enabled, publish jwt\nclaims in the throttle event"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4449279dca17e2be3898964f46701494a5af0ac", "author": {"user": {"login": "praminda", "name": "Praminda"}}, "url": "https://github.com/wso2/product-microgateway/commit/d4449279dca17e2be3898964f46701494a5af0ac", "committedDate": "2020-08-05T07:57:12Z", "message": "throttle: Evaluate jwt claim decisions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyMjUwNDcx", "url": "https://github.com/wso2/product-microgateway/pull/1368#pullrequestreview-462250471", "createdAt": "2020-08-06T07:23:54Z", "commit": {"oid": "d4449279dca17e2be3898964f46701494a5af0ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNzoyMzo1NFrOG8mfQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNzoyMzo1NFrOG8mfQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE5ODMzOA==", "bodyText": "Suggested change", "url": "https://github.com/wso2/product-microgateway/pull/1368#discussion_r466198338", "createdAt": "2020-08-06T07:23:54Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/utils/throttle_util.bal", "diffHunk": "@@ -61,6 +67,86 @@ public function isRequestThrottled(string key) returns [boolean, boolean] {\n     return [isThrottled, false];\n }\n \n+# Decide whether request details provided in arguments is throttled or not by the global traffic manager.\n+# This function is deinfed to evalute only API and Resource level throttling decisions recieved from the\n+# traffic manager.\n+#\n+# + key - throttle key of the request\n+# + info - request details required to make conditional throttle decisions\n+# + return - [is request throttled, should stop on quota]\n+public function isApiThrottledByTM(string key, ConditionalThrottleInfo? info) returns [boolean, boolean] {\n+    printDebug(KEY_THROTTLE_UTIL, \"throttle data map : \" + throttleDataMap.toString());\n+    printDebug(KEY_THROTTLE_UTIL, \"throttle data key : \" + key);\n+    boolean isThrottled = false;\n+    boolean stopOnQuota = false;\n+\n+    if (enabledGlobalTMEventPublishing == false) {\n+        return [false, false];\n+    }\n+    boolean hasThrottledCondition = conditionDataMap.hasKey(key);\n+    printDebug(KEY_THROTTLE_UTIL, \"hasThrottledCondition : \" + hasThrottledCondition.toString());\n+\n+    if (hasThrottledCondition && (info is ConditionalThrottleInfo)) {\n+        // get the condition groups for provided throttleKey\n+        map<ConditionDto[]> conditionGrps = conditionDataMap.get(key);\n+        string? conditionKey = ();\n+\n+        // iterate through all available conditions and find if the current request\n+        // attributes are eligible to be throttled by the available throttled conditions\n+        foreach var [name, dto] in conditionGrps.entries() {\n+            if (DEFAULT_THROTTLE_CONDITION != name) {\n+                boolean isPipelineThrottled = isThrottledByCondition(dto, info);\n+                if (isPipelineThrottled) {\n+                    conditionKey = name;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (conditionKey is () && conditionGrps.hasKey(DEFAULT_THROTTLE_CONDITION)) {\n+            ConditionDto[] dto = conditionGrps.get(DEFAULT_THROTTLE_CONDITION);\n+            boolean isPipelineThrottled = isThrottledByCondition(dto, info);\n+            if (!isPipelineThrottled) {\n+                conditionKey = DEFAULT_THROTTLE_CONDITION;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4449279dca17e2be3898964f46701494a5af0ac"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyMjU0NzY3", "url": "https://github.com/wso2/product-microgateway/pull/1368#pullrequestreview-462254767", "createdAt": "2020-08-06T07:30:41Z", "commit": {"oid": "d4449279dca17e2be3898964f46701494a5af0ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNzozMDo0MVrOG8msmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNzozMDo0MVrOG8msmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIwMTc1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    _ = throttleDataMap.remove(key);\n          \n          \n            \n                                    _ = throttleDataMap.remove(combinedThrottleKey);", "url": "https://github.com/wso2/product-microgateway/pull/1368#discussion_r466201753", "createdAt": "2020-08-06T07:30:41Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/utils/throttle_util.bal", "diffHunk": "@@ -61,6 +67,86 @@ public function isRequestThrottled(string key) returns [boolean, boolean] {\n     return [isThrottled, false];\n }\n \n+# Decide whether request details provided in arguments is throttled or not by the global traffic manager.\n+# This function is deinfed to evalute only API and Resource level throttling decisions recieved from the\n+# traffic manager.\n+#\n+# + key - throttle key of the request\n+# + info - request details required to make conditional throttle decisions\n+# + return - [is request throttled, should stop on quota]\n+public function isApiThrottledByTM(string key, ConditionalThrottleInfo? info) returns [boolean, boolean] {\n+    printDebug(KEY_THROTTLE_UTIL, \"throttle data map : \" + throttleDataMap.toString());\n+    printDebug(KEY_THROTTLE_UTIL, \"throttle data key : \" + key);\n+    boolean isThrottled = false;\n+    boolean stopOnQuota = false;\n+\n+    if (enabledGlobalTMEventPublishing == false) {\n+        return [false, false];\n+    }\n+    boolean hasThrottledCondition = conditionDataMap.hasKey(key);\n+    printDebug(KEY_THROTTLE_UTIL, \"hasThrottledCondition : \" + hasThrottledCondition.toString());\n+\n+    if (hasThrottledCondition && (info is ConditionalThrottleInfo)) {\n+        // get the condition groups for provided throttleKey\n+        map<ConditionDto[]> conditionGrps = conditionDataMap.get(key);\n+        string? conditionKey = ();\n+\n+        // iterate through all available conditions and find if the current request\n+        // attributes are eligible to be throttled by the available throttled conditions\n+        foreach var [name, dto] in conditionGrps.entries() {\n+            if (DEFAULT_THROTTLE_CONDITION != name) {\n+                boolean isPipelineThrottled = isThrottledByCondition(dto, info);\n+                if (isPipelineThrottled) {\n+                    conditionKey = name;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (conditionKey is () && conditionGrps.hasKey(DEFAULT_THROTTLE_CONDITION)) {\n+            ConditionDto[] dto = conditionGrps.get(DEFAULT_THROTTLE_CONDITION);\n+            boolean isPipelineThrottled = isThrottledByCondition(dto, info);\n+            if (!isPipelineThrottled) {\n+                conditionKey = DEFAULT_THROTTLE_CONDITION;\n+\n+            }\n+        }\n+\n+        // if we detect the request is throttled by a condition. Then check the validity of throttle\n+        // decision from the throttle event data available in the throttleDataMap\n+        if (conditionKey is string) {\n+            printDebug(KEY_THROTTLE_UTIL, \"throttled with condition: \" + conditionKey);\n+            string combinedThrottleKey = key + \"_\" + conditionKey;\n+\n+            // if throttle data is not available for the combined key, conditional throttle decision\n+            // is no longer valid\n+            if (!throttleDataMap.hasKey(combinedThrottleKey)) {\n+                return [false, false];\n+            }\n+            var dto = throttleDataMap.get(combinedThrottleKey);\n+            if (dto is GlobalThrottleStreamDTO) {\n+                int currentTime = time:currentTime().time;\n+                int? resetTimestamp = dto.resetTimestamp;\n+                stopOnQuota = true;\n+                if (resetTimestamp is int) {\n+                    if (resetTimestamp < currentTime) {\n+                        _ = throttleDataMap.remove(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4449279dca17e2be3898964f46701494a5af0ac"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyMjU2NzI4", "url": "https://github.com/wso2/product-microgateway/pull/1368#pullrequestreview-462256728", "createdAt": "2020-08-06T07:33:45Z", "commit": {"oid": "d4449279dca17e2be3898964f46701494a5af0ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNzozMzo0NVrOG8myow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNzozMzo0NVrOG8myow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIwMzI5OQ==", "bodyText": "check decode.customClaims.hasKey scenario", "url": "https://github.com/wso2/product-microgateway/pull/1368#discussion_r466203299", "createdAt": "2020-08-06T07:33:45Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/utils/throttle_util.bal", "diffHunk": "@@ -241,3 +351,227 @@ function modifyIpWithNumericRanges(IPRangeDTO ipRange) {\n     }\n }\n \n+\n+# Build a list of `ConditionDto`s from the provided base64 encoded condition list.\n+#\n+# + base64Conditions - A base64 encoded json string containing the list of conditions\n+# evaluated by the throttle engine to take the throttle decision.\n+# + return - A list of conditions evaluated during making the throttle decision. Incase of an\n+# error during converting the conditions, empty `ConditionDto[]` will be returned\n+function extractConditionDto(string base64Conditions) returns ConditionDto[] {\n+    ConditionDto[] conditions = [];\n+    byte[]|error base64Decoded = encoding:decodeBase64Url(base64Conditions);\n+    if (base64Decoded is byte[]) {\n+        string|error result = strings:fromBytes(base64Decoded);\n+        if (result is error) {\n+            printError(KEY_THROTTLE_UTIL, result.reason(), result);\n+        }\n+\n+        string conditionsPayload = <string>result;\n+        json[] | error jsonPayload = <json[]>conditionsPayload.fromJsonString();\n+\n+        if (jsonPayload is json[]) {\n+            printDebug(KEY_THROTTLE_UTIL, \"Decoded throttle conditions json :\" + jsonPayload.toJsonString());\n+\n+            foreach json condition in jsonPayload {\n+                ConditionDto conditionDto = {};\n+                var jIpSpecific = condition.ipspecific;\n+                var jIpRange = condition.iprange;\n+                var jHeader = condition.header;\n+                var jQuery = condition.queryparametertype;\n+                var jJwt = condition.jwtclaims;\n+\n+                // Build IP condition DTOs\n+                if (jIpSpecific is json) {\n+                    IPCondition ip = {\n+                        specificIp: jIpSpecific.specificIp.toString(),\n+                        invert: <boolean>jIpSpecific.invert\n+                    };\n+                    conditionDto.ipCondition = ip;\n+                } else if (jIpRange is json) {\n+                    IPCondition ip = {\n+                        startingIp: jIpRange.startingIp.toString(),\n+                        endingIp: jIpRange.endingIp.toString(),\n+                        invert: <boolean>jIpRange.invert\n+                    };\n+                    conditionDto.ipRangeCondition = ip;\n+                }\n+\n+                // Build header condition DTOs\n+                if (jHeader is json) {\n+                    var header = HeaderConditions.constructFrom(jHeader);\n+                    if (header is HeaderConditions) {\n+                        conditionDto.headerConditions = header;\n+                    } else {\n+                        printError(KEY_THROTTLE_UTIL, \"HeaderCondition is not in the expected format\", header);\n+                    }\n+                }\n+\n+                // Build query param condition DTOs\n+                if (jQuery is json) {\n+                    var query = QueryParamConditions.constructFrom(jQuery);\n+                    if (query is QueryParamConditions) {\n+                        conditionDto.queryParamConditions = query;\n+                    } else {\n+                        printError(KEY_THROTTLE_UTIL, \"QueryParamCondition is not in the expected format\", query);\n+                    }\n+                }\n+\n+                // Build jwt condition DTOs\n+                if (jJwt is json) {\n+                    var jwt = JwtConditions.constructFrom(jJwt);\n+                    if (jwt is JwtConditions) {\n+                        conditionDto.jwtClaimConditions = jwt;\n+                    } else {\n+                        printError(KEY_THROTTLE_UTIL, \"JwtConditions is not in the expected format\", jwt);\n+                    }\n+                }\n+\n+                conditions.push(conditionDto);\n+            }\n+        } else {\n+            printError(KEY_THROTTLE_UTIL, \"Couldn't build a valid json from the throttle conditions\", jsonPayload);\n+        }\n+    } else {\n+        printError(KEY_THROTTLE_UTIL, \"Couldn't decode throttle conditions\", base64Decoded);\n+    }\n+\n+    return conditions;\n+}\n+\n+# Check if the request is throttled by an advanced throttle condition.\n+# Such as IP, header, query param based conditions.\n+#\n+# + conditions - throttled conditions recieved from global throttle engine\n+# + info - information required to derive conditional throttle status\n+# + return - `true` if throttled by a condition, `false` otherwise\n+function isThrottledByCondition(ConditionDto[] conditions, ConditionalThrottleInfo info) returns boolean {\n+    boolean isThrottled = false;\n+\n+    foreach ConditionDto condition in conditions {\n+        // We initially set throttled flag to true. Then we move onto evaluating all conditions and\n+        // set the flag to false accordingly. This is done in this way to implement the `AND` logic\n+        // between each condition inside a condition group.\n+        isThrottled = true;\n+        HeaderConditions? headerConditions = condition?.headerConditions;\n+        IPCondition? ipCondition = condition?.ipCondition;\n+        IPCondition? ipRangeCondition = condition?.ipRangeCondition;\n+        QueryParamConditions? queryConditions = condition?.queryParamConditions;\n+        JwtConditions? claimConditions = condition?.jwtClaimConditions;\n+\n+        if (ipCondition is IPCondition) {\n+            if (!isMatchingIp(info.clientIp, ipCondition)) {\n+                isThrottled = false;\n+            }\n+        } else if (ipRangeCondition is IPCondition) {\n+            if (!isWithinIpRange(info.clientIp, ipRangeCondition)) {\n+                isThrottled = false;\n+            }\n+        }\n+        if (info.isHeaderConditionsEnabled && (headerConditions is HeaderConditions)) {\n+            if (!isHeaderPresent(info.request, headerConditions)) {\n+                isThrottled = false;\n+            }\n+        }\n+        if (info.isQueryConditionsEnabled && (queryConditions is QueryParamConditions)) {\n+            if (!isQueryParamPresent(info.request, queryConditions)) {\n+                isThrottled = false;\n+            }\n+        }\n+        if (info.isJwtConditionsEnabled && (claimConditions is JwtConditions)) {\n+            if (!isClaimPresent(info.request, claimConditions)) {\n+                isThrottled = false;\n+            }\n+        }\n+\n+        if (isThrottled) {\n+            break;\n+        }\n+    }\n+\n+    return isThrottled;\n+}\n+\n+function isMatchingIp(string clientIp, IPCondition ipCondition) returns boolean {\n+    string longIp = ipToBigInteger(clientIp);\n+    boolean isMatched = (longIp == ipCondition.specificIp);\n+\n+    if (ipCondition.invert) {\n+        return !isMatched;\n+    }\n+\n+    return isMatched;\n+}\n+\n+function isWithinIpRange(string clientIp, IPCondition ipCondition) returns boolean {\n+    boolean isMatched = isIpWithinRange(clientIp, ipCondition.startingIp, ipCondition.endingIp);\n+\n+    if (ipCondition.invert) {\n+        return !isMatched;\n+    }\n+\n+    return isMatched;\n+}\n+\n+function isHeaderPresent(http:Request req, HeaderConditions conditions) returns boolean {\n+    boolean status = true;\n+\n+    foreach var [name, value] in conditions.values.entries() {\n+        if (req.hasHeader(name)) {\n+            string headerVal = req.getHeader(name);\n+            if (headerVal != \"\") {\n+                status = status && isPatternMatched(value, headerVal);\n+            } else {\n+                status = false;\n+                break;\n+            }\n+        }\n+    }\n+\n+    status = conditions.invert ? !status : status;\n+    return status;\n+}\n+\n+function isQueryParamPresent(http:Request req, QueryParamConditions conditions) returns boolean {\n+    boolean status = true;\n+\n+    foreach var [name, value] in conditions.values.entries() {\n+        string? paramValue = req.getQueryParamValue(name);\n+        if (paramValue is string) {\n+            if (paramValue != \"\") {\n+                status = status && isPatternMatched(value, paramValue);\n+            } else {\n+                status = false;\n+                break;\n+            }\n+        }\n+    }\n+\n+    status = conditions.invert ? !status : status;\n+    return status;\n+}\n+\n+function isClaimPresent(http:Request req, QueryParamConditions conditions) returns boolean {\n+    boolean status = true;\n+    string? assertion = req.hasHeader(jwtheaderName) ? req.getHeader(jwtheaderName) : ();\n+\n+    if (assertion is string) {\n+        jwt:JwtPayload | error decoded = decodeJWTPayload(assertion);\n+        if (decoded is jwt:JwtPayload) {\n+            foreach var [name, value] in conditions.values.entries() {\n+                if (decoded.hasKey(name)) {\n+                    printInfo(\"TEST\", \"present in decoded : \" + decoded.get(name).toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4449279dca17e2be3898964f46701494a5af0ac"}, "originalPosition": 371}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c01269e7436d13b3c78758837a03e60df840f37", "author": {"user": {"login": "praminda", "name": "Praminda"}}, "url": "https://github.com/wso2/product-microgateway/commit/3c01269e7436d13b3c78758837a03e60df840f37", "committedDate": "2020-08-07T14:24:09Z", "message": "throttle: Check jwt claims in customClaims"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "06fb23e7971fabc74c434fc178c45efd820eb80e", "author": {"user": {"login": "praminda", "name": "Praminda"}}, "url": "https://github.com/wso2/product-microgateway/commit/06fb23e7971fabc74c434fc178c45efd820eb80e", "committedDate": "2020-08-07T14:13:28Z", "message": "throttle: Check jwt claims in customClaims"}, "afterCommit": {"oid": "3c01269e7436d13b3c78758837a03e60df840f37", "author": {"user": {"login": "praminda", "name": "Praminda"}}, "url": "https://github.com/wso2/product-microgateway/commit/3c01269e7436d13b3c78758837a03e60df840f37", "committedDate": "2020-08-07T14:24:09Z", "message": "throttle: Check jwt claims in customClaims"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDA0NTk3", "url": "https://github.com/wso2/product-microgateway/pull/1368#pullrequestreview-463404597", "createdAt": "2020-08-07T15:28:23Z", "commit": {"oid": "3c01269e7436d13b3c78758837a03e60df840f37"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 946, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}