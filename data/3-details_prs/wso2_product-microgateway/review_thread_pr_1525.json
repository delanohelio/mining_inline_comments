{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyNDY3MTI1", "number": 1525, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTowODo0OFrOFHI74A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMzoxMToyMFrOFHLYVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDMwNzUyOnYy", "diffSide": "RIGHT", "path": "adapter/pkg/api/file_read_utils.go", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTowODo0OFrOIIesSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTowODo0OFrOIIesSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2MjM3Nw==", "bodyText": "Check if this works with windows platform.", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r545762377", "createdAt": "2020-12-18T11:08:48Z", "author": {"login": "VirajSalaka"}, "path": "adapter/pkg/api/file_read_utils.go", "diffHunk": "@@ -44,35 +57,34 @@ func ApplyAPIProject(payload []byte) error {\n \n \t// TODO: (VirajSalaka) this won't support for distributed openAPI definition\n \tfor _, file := range zipReader.File {\n-\t\tif strings.HasSuffix(file.Name, \"Meta-information/swagger.yaml\") {\n+\t\tif strings.HasSuffix(file.Name, openAPIDir+string(os.PathSeparator)+openAPIFilename) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDMyNTY4OnYy", "diffSide": "RIGHT", "path": "adapter/pkg/api/file_read_utils.go", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToxMzo1MFrOIIe27Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNzo0MToyOVrOIO0xIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NTEwMQ==", "bodyText": "Validate the content with a regex", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r545765101", "createdAt": "2020-12-18T11:13:50Z", "author": {"login": "VirajSalaka"}, "path": "adapter/pkg/api/file_read_utils.go", "diffHunk": "@@ -44,35 +57,34 @@ func ApplyAPIProject(payload []byte) error {\n \n \t// TODO: (VirajSalaka) this won't support for distributed openAPI definition\n \tfor _, file := range zipReader.File {\n-\t\tif strings.HasSuffix(file.Name, \"Meta-information/swagger.yaml\") {\n+\t\tif strings.HasSuffix(file.Name, openAPIDir+string(os.PathSeparator)+openAPIFilename) {\n \t\t\tloggers.LoggerAPI.Debugf(\"openAPI file : %v\", file.Name)\n \t\t\tunzippedFileBytes, err := readZipFile(file)\n \t\t\tif err != nil {\n \t\t\t\tloggers.LoggerAPI.Errorf(\"Error occured while reading the openapi file. %v\", err.Error())\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tapiJsn, conversionErr := utills.ToJSON(unzippedFileBytes)\n+\t\t\tapiJsn, conversionErr = utills.ToJSON(unzippedFileBytes)\n \t\t\tif conversionErr != nil {\n \t\t\t\tloggers.LoggerAPI.Errorf(\"Error converting api file to json: %v\", err.Error())\n \t\t\t\treturn conversionErr\n \t\t\t}\n-\t\t\txds.UpdateEnvoy(apiJsn)\n+\t\t} else if strings.Contains(file.Name, endpointCertDir+string(os.PathSeparator)) &&\n+\t\t\t(strings.HasSuffix(file.Name, crtExtension) || strings.HasSuffix(file.Name, pemExtension)) {\n+\t\t\t//TODO: (VirajSalaka) Validate the content of cert files", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQxNDY5OQ==", "bodyText": "fixed via 3427130", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r552414699", "createdAt": "2021-01-06T07:39:05Z", "author": {"login": "VirajSalaka"}, "path": "adapter/pkg/api/file_read_utils.go", "diffHunk": "@@ -44,35 +57,34 @@ func ApplyAPIProject(payload []byte) error {\n \n \t// TODO: (VirajSalaka) this won't support for distributed openAPI definition\n \tfor _, file := range zipReader.File {\n-\t\tif strings.HasSuffix(file.Name, \"Meta-information/swagger.yaml\") {\n+\t\tif strings.HasSuffix(file.Name, openAPIDir+string(os.PathSeparator)+openAPIFilename) {\n \t\t\tloggers.LoggerAPI.Debugf(\"openAPI file : %v\", file.Name)\n \t\t\tunzippedFileBytes, err := readZipFile(file)\n \t\t\tif err != nil {\n \t\t\t\tloggers.LoggerAPI.Errorf(\"Error occured while reading the openapi file. %v\", err.Error())\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tapiJsn, conversionErr := utills.ToJSON(unzippedFileBytes)\n+\t\t\tapiJsn, conversionErr = utills.ToJSON(unzippedFileBytes)\n \t\t\tif conversionErr != nil {\n \t\t\t\tloggers.LoggerAPI.Errorf(\"Error converting api file to json: %v\", err.Error())\n \t\t\t\treturn conversionErr\n \t\t\t}\n-\t\t\txds.UpdateEnvoy(apiJsn)\n+\t\t} else if strings.Contains(file.Name, endpointCertDir+string(os.PathSeparator)) &&\n+\t\t\t(strings.HasSuffix(file.Name, crtExtension) || strings.HasSuffix(file.Name, pemExtension)) {\n+\t\t\t//TODO: (VirajSalaka) Validate the content of cert files", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NTEwMQ=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQxNTUyMw==", "bodyText": "Please note that this check is just based on surrounding \"----BEGIN CERTIFICATE----\" and \"-----END CERTIFICATE---\" strings.", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r552415523", "createdAt": "2021-01-06T07:41:29Z", "author": {"login": "VirajSalaka"}, "path": "adapter/pkg/api/file_read_utils.go", "diffHunk": "@@ -44,35 +57,34 @@ func ApplyAPIProject(payload []byte) error {\n \n \t// TODO: (VirajSalaka) this won't support for distributed openAPI definition\n \tfor _, file := range zipReader.File {\n-\t\tif strings.HasSuffix(file.Name, \"Meta-information/swagger.yaml\") {\n+\t\tif strings.HasSuffix(file.Name, openAPIDir+string(os.PathSeparator)+openAPIFilename) {\n \t\t\tloggers.LoggerAPI.Debugf(\"openAPI file : %v\", file.Name)\n \t\t\tunzippedFileBytes, err := readZipFile(file)\n \t\t\tif err != nil {\n \t\t\t\tloggers.LoggerAPI.Errorf(\"Error occured while reading the openapi file. %v\", err.Error())\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tapiJsn, conversionErr := utills.ToJSON(unzippedFileBytes)\n+\t\t\tapiJsn, conversionErr = utills.ToJSON(unzippedFileBytes)\n \t\t\tif conversionErr != nil {\n \t\t\t\tloggers.LoggerAPI.Errorf(\"Error converting api file to json: %v\", err.Error())\n \t\t\t\treturn conversionErr\n \t\t\t}\n-\t\t\txds.UpdateEnvoy(apiJsn)\n+\t\t} else if strings.Contains(file.Name, endpointCertDir+string(os.PathSeparator)) &&\n+\t\t\t(strings.HasSuffix(file.Name, crtExtension) || strings.HasSuffix(file.Name, pemExtension)) {\n+\t\t\t//TODO: (VirajSalaka) Validate the content of cert files", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NTEwMQ=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDM1ODI1OnYy", "diffSide": "RIGHT", "path": "adapter/pkg/api/restserver/config_restapi.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToyNDoyMFrOIIfKKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNzo0MjowOFrOIO0yAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MDAyNA==", "bodyText": "Add the readme on how to generate this auto generated codes", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r545770024", "createdAt": "2020-12-18T11:24:20Z", "author": {"login": "VirajSalaka"}, "path": "adapter/pkg/api/restserver/config_restapi.go", "diffHunk": "@@ -75,14 +75,15 @@ func configureAPI(api *operations.RestapiAPI) http.Handler {\n \t\treturn &p, nil\n \t}\n \n-\tapi.APIIndividualPostImportAPIHandler = api_individual.PostImportAPIHandlerFunc(func(params api_individual.PostImportAPIParams, principal *models.Principal) middleware.Responder {\n+\tapi.APIIndividualPostApisHandler = api_individual.PostApisHandlerFunc(func(params api_individual.PostApisParams,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQxNTc0NA==", "bodyText": "added via f1442eb", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r552415744", "createdAt": "2021-01-06T07:42:08Z", "author": {"login": "VirajSalaka"}, "path": "adapter/pkg/api/restserver/config_restapi.go", "diffHunk": "@@ -75,14 +75,15 @@ func configureAPI(api *operations.RestapiAPI) http.Handler {\n \t\treturn &p, nil\n \t}\n \n-\tapi.APIIndividualPostImportAPIHandler = api_individual.PostImportAPIHandlerFunc(func(params api_individual.PostImportAPIParams, principal *models.Principal) middleware.Responder {\n+\tapi.APIIndividualPostApisHandler = api_individual.PostApisHandlerFunc(func(params api_individual.PostApisParams,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MDAyNA=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDQzNjQyOnYy", "diffSide": "RIGHT", "path": "adapter/pkg/oasparser/envoyconf/routesWithClusters.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTo0OTowM1rOIIf3qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMDoyOTo0NVrOIOmMWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc4MTY3NQ==", "bodyText": "within Ext authz, do path rewrite", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r545781675", "createdAt": "2020-12-18T11:49:03Z", "author": {"login": "VirajSalaka"}, "path": "adapter/pkg/oasparser/envoyconf/routesWithClusters.go", "diffHunk": "@@ -48,117 +49,138 @@ import (\n //\n // First set of routes, clusters, addresses represents the production endpoints related\n // configurations. Next set represents the sandbox endpoints related configurations.\n-func CreateRoutesWithClusters(mgwSwagger model.MgwSwagger) (routesP []*routev3.Route,\n-\tclustersP []*clusterv3.Cluster, addressesP []*corev3.Address,\n-\troutesS []*routev3.Route, clustersS []*clusterv3.Cluster, addressesS []*corev3.Address) {\n+func CreateRoutesWithClusters(mgwSwagger model.MgwSwagger, upstreamCerts []byte) (routesP []*routev3.Route,\n+\tclustersP []*clusterv3.Cluster, addressesP []*corev3.Address) {\n \tvar (\n-\t\troutesProd              []*routev3.Route\n-\t\tclustersProd            []*clusterv3.Cluster\n-\t\tendpointProd            []model.Endpoint\n+\t\troutesProd []*routev3.Route\n+\t\tclusters   []*clusterv3.Cluster\n+\t\tendpoints  []*corev3.Address\n+\n \t\tapiLevelEndpointProd    []model.Endpoint\n \t\tapilevelClusterProd     *clusterv3.Cluster\n \t\tapiLevelClusterNameProd string\n-\t\tendpointsProd           []*corev3.Address\n \n-\t\troutesSand              []*routev3.Route\n-\t\tclustersSand            []*clusterv3.Cluster\n-\t\tendpointSand            []model.Endpoint\n \t\tapiLevelEndpointSand    []model.Endpoint\n \t\tapilevelClusterSand     *clusterv3.Cluster\n \t\tapiLevelClusterNameSand string\n-\t\tendpointsSand           []*corev3.Address\n \t)\n-\t// check API level sandbox endpoints availble\n-\tif len(mgwSwagger.GetSandEndpoints()) > 0 {\n-\t\tapiLevelEndpointSand = mgwSwagger.GetSandEndpoints()\n-\t\tapilevelAddressSand := createAddress(apiLevelEndpointSand[0].Host, apiLevelEndpointSand[0].Port)\n-\t\tapiLevelClusterNameSand = strings.TrimSpace(sandClustersConfigNamePrefix +\n-\t\t\tstrings.Replace(mgwSwagger.GetTitle(), \" \", \"\", -1) + mgwSwagger.GetVersion())\n-\t\tapilevelClusterSand = createCluster(apilevelAddressSand, apiLevelClusterNameSand, apiLevelEndpointSand[0].URLType)\n-\t\tclustersSand = append(clustersSand, apilevelClusterSand)\n-\t\tendpointsSand = append(endpointsSand, apilevelAddressSand)\n-\t}\n+\t// To keep track of API Level production endpoint basePath\n+\tapiEndpointBasePath := \"\"\n+\n+\tapiTitle := mgwSwagger.GetTitle()\n+\tapiVersion := mgwSwagger.GetVersion()\n+\tapiBasePath := mgwSwagger.GetXWso2Basepath()\n \n \t// check API level production endpoints available\n \tif len(mgwSwagger.GetProdEndpoints()) > 0 {\n \t\tapiLevelEndpointProd = mgwSwagger.GetProdEndpoints()\n \t\tapilevelAddressP := createAddress(apiLevelEndpointProd[0].Host, apiLevelEndpointProd[0].Port)\n \t\tapiLevelClusterNameProd = strings.TrimSpace(prodClustersConfigNamePrefix +\n \t\t\tstrings.Replace(mgwSwagger.GetTitle(), \" \", \"\", -1) + mgwSwagger.GetVersion())\n-\t\tapilevelClusterProd = createCluster(apilevelAddressP, apiLevelClusterNameProd, apiLevelEndpointProd[0].URLType)\n-\t\tclustersProd = append(clustersProd, apilevelClusterProd)\n-\t\tendpointsProd = append(endpointsProd, apilevelAddressP)\n+\t\tapilevelClusterProd = createCluster(apilevelAddressP, apiLevelClusterNameProd, apiLevelEndpointProd[0].URLType,\n+\t\t\tupstreamCerts)\n+\t\tclusters = append(clusters, apilevelClusterProd)\n+\t\tendpoints = append(endpoints, apilevelAddressP)\n+\t\tapiEndpointBasePath = apiLevelEndpointProd[0].Basepath\n \n \t} else {\n \t\tlogger.LoggerOasparser.Warn(\"API level Producton endpoints are not defined\")\n \t}\n-\tfor _, resource := range mgwSwagger.GetResources() {\n-\t\tapiTitle := mgwSwagger.GetTitle()\n-\t\tapiVersion := mgwSwagger.GetVersion()\n-\t\tapiBasePath := mgwSwagger.GetXWso2Basepath()\n \n-\t\t// resource level check sandbox endpoints\n-\t\tif len(resource.GetSandEndpoints()) > 0 {\n-\t\t\tendpointSand = resource.GetSandEndpoints()\n-\t\t\taddressSand := createAddress(endpointSand[0].Host, endpointSand[0].Port)\n-\t\t\t// TODO: (VirajSalaka) 0 is hardcoded as only one endpoint is supported at the moment\n-\t\t\tclusterNameSand := strings.TrimSpace(apiLevelClusterNameSand + \"_\" + strings.Replace(resource.GetID(), \" \", \"\", -1) +\n-\t\t\t\t\"0\")\n-\t\t\tclusterSand := createCluster(addressSand, clusterNameSand, endpointSand[0].URLType)\n-\t\t\tclustersSand = append(clustersSand, clusterSand)\n-\t\t\tclusterRefSand := clusterSand.GetName()\n-\n-\t\t\t// sandbox endpoints\n-\t\t\trouteS := createRoute(apiTitle, apiBasePath, apiVersion, endpointSand[0], resource, clusterRefSand)\n-\t\t\troutesSand = append(routesSand, routeS)\n-\t\t\tendpointsSand = append(endpointsSand, addressSand)\n-\n-\t\t\t// API level check\n-\t\t} else if len(mgwSwagger.GetSandEndpoints()) > 0 {\n-\t\t\tendpointSand = apiLevelEndpointSand\n-\t\t\tclusterRefSand := apilevelClusterSand.GetName()\n+\t// check API level sandbox endpoints availble\n+\tif len(mgwSwagger.GetSandEndpoints()) > 0 {\n+\t\tapiLevelEndpointSand = mgwSwagger.GetSandEndpoints()\n+\t\tif apiEndpointBasePath != apiLevelEndpointSand[0].Basepath && len(apiLevelEndpointProd) > 0 {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE3NjcyOA==", "bodyText": "This approach has not been successful. When it is invoked, the client will always get a 404. The following log corresponds to a similar behavior where petstore v2 /pet/findbyStatus resource is called and the ext_authz filter changed that path to some random string (/aaaaa/vvvvv)\nrouter_1    | [2021-01-05 20:24:10.414][18][trace][filter] [source/extensions/filters/http/ext_authz/ext_authz.cc:69] [C1][S4670466387945752909] ext_authz filter calling authorization server\nrouter_1    | [2021-01-05 20:24:10.415][18][trace][ext_authz] [source/extensions/filters/common/ext_authz/ext_authz_grpc_impl.cc:60] Sending CheckRequest: attributes {\nrouter_1    |   source {\nrouter_1    |     address {\nrouter_1    |       socket_address {\nrouter_1    |         address: \"172.18.0.1\"\nrouter_1    |         port_value: 48154\nrouter_1    |       }\nrouter_1    |     }\nrouter_1    |   }\nrouter_1    |   destination {\nrouter_1    |     address {\nrouter_1    |       socket_address {\nrouter_1    |         address: \"172.18.0.4\"\nrouter_1    |         port_value: 9095\nrouter_1    |       }\nrouter_1    |     }\nrouter_1    |     principal: \"localhost\"\nrouter_1    |   }\nrouter_1    |   request {\nrouter_1    |     time {\nrouter_1    |       seconds: 1609878250\nrouter_1    |       nanos: 414538000\nrouter_1    |     }\nrouter_1    |     http {\nrouter_1    |       id: \"4670466387945752909\"\nrouter_1    |       method: \"GET\"\nrouter_1    |       headers {\nrouter_1    |         key: \":authority\"\nrouter_1    |         value: \"localhost:9095\"\nrouter_1    |       }\nrouter_1    |       headers {\nrouter_1    |         key: \":method\"\nrouter_1    |         value: \"GET\"\nrouter_1    |       }\nrouter_1    |       headers {\nrouter_1    |         key: \":path\"\nrouter_1    |         value: \"/v2/pet/findByStatus?status=available\"\nrouter_1    |       }\nrouter_1    |       headers {\nrouter_1    |         key: \"accept\"\nrouter_1    |         value: \"application/xml\"\nrouter_1    |       }\nrouter_1    |       headers {\nrouter_1    |         key: \"authorization\"\nrouter_1    |         value: \"bearer eyJ4NXQiOiJNell4TW1Ga09HWXdNV0kwWldObU5EY3hOR1l3WW1NNFpUQTNNV0kyTkRBelpHUXpOR00wWkdSbE5qSmtPREZrWkRSaU9URmtNV0ZoTXpVMlpHVmxOZyIsImtpZCI6Ik16WXhNbUZrT0dZd01XSTBaV05tTkRjeE5HWXdZbU00WlRBM01XSTJOREF6WkdRek5HTTBaR1JsTmpKa09ERmtaRFJpT1RGa01XRmhNelUyWkdWbE5nX1JTMjU2IiwiYWxnIjoiUlMyNTYifQ==.eyJhdWQiOiJBT2syNFF6WndRXzYyb2QyNDdXQnVtd0VFZndhIiwic3ViIjoiYWRtaW5AY2FyYm9uLnN1cGVyIiwibmJmIjoxNTk2MDA5NTU2LCJhenAiOiJBT2syNFF6WndRXzYyb2QyNDdXQnVtd0VFZndhIiwic2NvcGUiOiJhbV9hcHBsaWNhdGlvbl9zY29wZSBkZWZhdWx0IiwiaXNzIjoiaHR0cHM6Ly9sb2NhbGhvc3Q6OTQ0My9vYXV0aDIvdG9rZW4iLCJrZXl0eXBlIjoiUFJPRFVDVElPTiIsImV4cCI6MTYyNzU0NTU1NiwiaWF0IjoxNTk2MDA5NTU2LCJqdGkiOiIyN2ZkMWY4Ny01ZTI1LTQ1NjktYTJkYi04MDA3MTFlZTJjZWMifQ==.otDREOsUUmXuSbIVII7FR59HAWqtXh6WWCSX6NDylVIFfED3GbLkopo6rwCh2EX6yiP-vGTqX8sB9Zfn784cIfD3jz2hCZqOqNzSUrzamZrWui4hlYC6qt4YviMbR9LNtxxu7uQD7QMbpZQiJ5owslaASWQvFTJgBmss5t7cnurrfkatj5AkzVdKOTGxcZZPX8WrV_Mo2-rLbYMslgb2jCptgvi29VMPo9GlAFecoMsSwywL8sMyf7AJ3y4XW5Uzq7vDGxojDam7jI5W8uLVVolZPDstqqZYzxpPJ2hBFC_OZgWG3LqhUgsYNReDKKeWUIEieK7QPgjetOZ5Geb1mA==\"\nrouter_1    |       }\nrouter_1    |       headers {\nrouter_1    |         key: \"user-agent\"\nrouter_1    |         value: \"curl/7.64.1\"\nrouter_1    |       }\nrouter_1    |       headers {\nrouter_1    |         key: \"x-forwarded-proto\"\nrouter_1    |         value: \"https\"\nrouter_1    |       }\nrouter_1    |       headers {\nrouter_1    |         key: \"x-request-id\"\nrouter_1    |         value: \"0b7dbc1e-d59c-49ee-a472-b8498cc4e285\"\nrouter_1    |       }\nrouter_1    |       path: \"/v2/pet/findByStatus?status=available\"\nrouter_1    |       host: \"localhost:9095\"\nrouter_1    |       protocol: \"HTTP/1.1\"\nrouter_1    |     }\nrouter_1    |   }\nrouter_1    |   context_extensions {\nrouter_1    |     key: \"basePath\"\nrouter_1    |     value: \"/v2\"\nrouter_1    |   }\nrouter_1    |   context_extensions {\nrouter_1    |     key: \"method\"\nrouter_1    |     value: \"GET\"\nrouter_1    |   }\nrouter_1    |   context_extensions {\nrouter_1    |     key: \"name\"\nrouter_1    |     value: \"Swagger Petstore\"\nrouter_1    |   }\nrouter_1    |   context_extensions {\nrouter_1    |     key: \"path\"\nrouter_1    |     value: \"/pet/findByStatus\"\nrouter_1    |   }\nrouter_1    |   context_extensions {\nrouter_1    |     key: \"prodClusterName\"\nrouter_1    |     value: \"clusterProd_SwaggerPetstore1.0.5\"\nrouter_1    |   }\nrouter_1    |   context_extensions {\nrouter_1    |     key: \"sandClusterName\"\nrouter_1    |     value: \"clusterSand_SwaggerPetstore1.0.5\"\nrouter_1    |   }\nrouter_1    |   context_extensions {\nrouter_1    |     key: \"version\"\nrouter_1    |     value: \"1.0.5\"\nrouter_1    |   }\nrouter_1    |   metadata_context {\nrouter_1    |   }\nrouter_1    | }\nrouter_1    | \nrouter_1    | [2021-01-05 20:24:10.415][18][debug][router] [source/common/router/router.cc:429] [C0][S13498356977599373084] cluster 'ext-authz' match for URL '/envoy.service.auth.v3.Authorization/Check'\nrouter_1    | [2021-01-05 20:24:10.415][18][debug][router] [source/common/router/router.cc:586] [C0][S13498356977599373084] router decoding headers:\nrouter_1    | ':method', 'POST'\nrouter_1    | ':path', '/envoy.service.auth.v3.Authorization/Check'\nrouter_1    | ':authority', 'ext-authz'\nrouter_1    | ':scheme', 'http'\nrouter_1    | 'te', 'trailers'\nrouter_1    | 'content-type', 'application/grpc'\nrouter_1    | 'x-envoy-internal', 'true'\nrouter_1    | 'x-forwarded-for', '172.18.0.4'\nrouter_1    | \nrouter_1    | [2021-01-05 20:24:10.415][18][trace][router] [source/common/router/upstream_request.cc:211] [C0][S13498356977599373084] buffering 1680 bytes\nrouter_1    | [2021-01-05 20:24:10.416][18][debug][router] [source/common/router/upstream_request.cc:357] [C0][S13498356977599373084] pool ready\nrouter_1    | [2021-01-05 20:24:10.945][18][debug][router] [source/common/router/router.cc:1178] [C0][S13498356977599373084] upstream headers complete: end_stream=false\nrouter_1    | [2021-01-05 20:24:10.946][18][trace][ext_authz] [source/extensions/filters/common/ext_authz/ext_authz_grpc_impl.cc:67] Received CheckResponse: status {\nrouter_1    | }\nrouter_1    | ok_response {\nrouter_1    |   headers {\nrouter_1    |     header {\nrouter_1    |       key: \"x-wso2-cluster-header\"\nrouter_1    |       value: \"clusterProd_SwaggerPetstore1.0.5\"\nrouter_1    |     }\nrouter_1    |   }\nrouter_1    |   headers {\nrouter_1    |     header {\nrouter_1    |       key: \":path\"\nrouter_1    |       value: \"/aaaaa/vvvvv\"\nrouter_1    |     }\nrouter_1    |   }\nrouter_1    | }\nrouter_1    | \nrouter_1    | [2021-01-05 20:24:10.946][18][debug][filter] [source/extensions/filters/http/ext_authz/ext_authz.cc:180] [C1][S4670466387945752909] ext_authz is clearing route cache\nrouter_1    | [2021-01-05 20:24:10.946][18][trace][filter] [source/extensions/filters/http/ext_authz/ext_authz.cc:184] [C1][S4670466387945752909] ext_authz filter added header(s) to the request:\nrouter_1    | [2021-01-05 20:24:10.946][18][trace][filter] [source/extensions/filters/http/ext_authz/ext_authz.cc:186] [C1][S4670466387945752909] 'x-wso2-cluster-header':'clusterProd_SwaggerPetstore1.0.5'\nrouter_1    | [2021-01-05 20:24:10.946][18][trace][filter] [source/extensions/filters/http/ext_authz/ext_authz.cc:186] [C1][S4670466387945752909] ':path':'/aaaaa/vvvvv'\nrouter_1    | [2021-01-05 20:24:10.946][18][trace][filter] [source/extensions/filters/http/ext_authz/ext_authz.cc:212] [C1][S4670466387945752909] ext_authz filter removed header(s) from the request:\nrouter_1    | [2021-01-05 20:24:10.948][18][debug][router] [source/common/router/router.cc:364] [C1][S4670466387945752909] no cluster match for URL '/aaaaa/vvvvv'", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r552176728", "createdAt": "2021-01-05T20:29:45Z", "author": {"login": "VirajSalaka"}, "path": "adapter/pkg/oasparser/envoyconf/routesWithClusters.go", "diffHunk": "@@ -48,117 +49,138 @@ import (\n //\n // First set of routes, clusters, addresses represents the production endpoints related\n // configurations. Next set represents the sandbox endpoints related configurations.\n-func CreateRoutesWithClusters(mgwSwagger model.MgwSwagger) (routesP []*routev3.Route,\n-\tclustersP []*clusterv3.Cluster, addressesP []*corev3.Address,\n-\troutesS []*routev3.Route, clustersS []*clusterv3.Cluster, addressesS []*corev3.Address) {\n+func CreateRoutesWithClusters(mgwSwagger model.MgwSwagger, upstreamCerts []byte) (routesP []*routev3.Route,\n+\tclustersP []*clusterv3.Cluster, addressesP []*corev3.Address) {\n \tvar (\n-\t\troutesProd              []*routev3.Route\n-\t\tclustersProd            []*clusterv3.Cluster\n-\t\tendpointProd            []model.Endpoint\n+\t\troutesProd []*routev3.Route\n+\t\tclusters   []*clusterv3.Cluster\n+\t\tendpoints  []*corev3.Address\n+\n \t\tapiLevelEndpointProd    []model.Endpoint\n \t\tapilevelClusterProd     *clusterv3.Cluster\n \t\tapiLevelClusterNameProd string\n-\t\tendpointsProd           []*corev3.Address\n \n-\t\troutesSand              []*routev3.Route\n-\t\tclustersSand            []*clusterv3.Cluster\n-\t\tendpointSand            []model.Endpoint\n \t\tapiLevelEndpointSand    []model.Endpoint\n \t\tapilevelClusterSand     *clusterv3.Cluster\n \t\tapiLevelClusterNameSand string\n-\t\tendpointsSand           []*corev3.Address\n \t)\n-\t// check API level sandbox endpoints availble\n-\tif len(mgwSwagger.GetSandEndpoints()) > 0 {\n-\t\tapiLevelEndpointSand = mgwSwagger.GetSandEndpoints()\n-\t\tapilevelAddressSand := createAddress(apiLevelEndpointSand[0].Host, apiLevelEndpointSand[0].Port)\n-\t\tapiLevelClusterNameSand = strings.TrimSpace(sandClustersConfigNamePrefix +\n-\t\t\tstrings.Replace(mgwSwagger.GetTitle(), \" \", \"\", -1) + mgwSwagger.GetVersion())\n-\t\tapilevelClusterSand = createCluster(apilevelAddressSand, apiLevelClusterNameSand, apiLevelEndpointSand[0].URLType)\n-\t\tclustersSand = append(clustersSand, apilevelClusterSand)\n-\t\tendpointsSand = append(endpointsSand, apilevelAddressSand)\n-\t}\n+\t// To keep track of API Level production endpoint basePath\n+\tapiEndpointBasePath := \"\"\n+\n+\tapiTitle := mgwSwagger.GetTitle()\n+\tapiVersion := mgwSwagger.GetVersion()\n+\tapiBasePath := mgwSwagger.GetXWso2Basepath()\n \n \t// check API level production endpoints available\n \tif len(mgwSwagger.GetProdEndpoints()) > 0 {\n \t\tapiLevelEndpointProd = mgwSwagger.GetProdEndpoints()\n \t\tapilevelAddressP := createAddress(apiLevelEndpointProd[0].Host, apiLevelEndpointProd[0].Port)\n \t\tapiLevelClusterNameProd = strings.TrimSpace(prodClustersConfigNamePrefix +\n \t\t\tstrings.Replace(mgwSwagger.GetTitle(), \" \", \"\", -1) + mgwSwagger.GetVersion())\n-\t\tapilevelClusterProd = createCluster(apilevelAddressP, apiLevelClusterNameProd, apiLevelEndpointProd[0].URLType)\n-\t\tclustersProd = append(clustersProd, apilevelClusterProd)\n-\t\tendpointsProd = append(endpointsProd, apilevelAddressP)\n+\t\tapilevelClusterProd = createCluster(apilevelAddressP, apiLevelClusterNameProd, apiLevelEndpointProd[0].URLType,\n+\t\t\tupstreamCerts)\n+\t\tclusters = append(clusters, apilevelClusterProd)\n+\t\tendpoints = append(endpoints, apilevelAddressP)\n+\t\tapiEndpointBasePath = apiLevelEndpointProd[0].Basepath\n \n \t} else {\n \t\tlogger.LoggerOasparser.Warn(\"API level Producton endpoints are not defined\")\n \t}\n-\tfor _, resource := range mgwSwagger.GetResources() {\n-\t\tapiTitle := mgwSwagger.GetTitle()\n-\t\tapiVersion := mgwSwagger.GetVersion()\n-\t\tapiBasePath := mgwSwagger.GetXWso2Basepath()\n \n-\t\t// resource level check sandbox endpoints\n-\t\tif len(resource.GetSandEndpoints()) > 0 {\n-\t\t\tendpointSand = resource.GetSandEndpoints()\n-\t\t\taddressSand := createAddress(endpointSand[0].Host, endpointSand[0].Port)\n-\t\t\t// TODO: (VirajSalaka) 0 is hardcoded as only one endpoint is supported at the moment\n-\t\t\tclusterNameSand := strings.TrimSpace(apiLevelClusterNameSand + \"_\" + strings.Replace(resource.GetID(), \" \", \"\", -1) +\n-\t\t\t\t\"0\")\n-\t\t\tclusterSand := createCluster(addressSand, clusterNameSand, endpointSand[0].URLType)\n-\t\t\tclustersSand = append(clustersSand, clusterSand)\n-\t\t\tclusterRefSand := clusterSand.GetName()\n-\n-\t\t\t// sandbox endpoints\n-\t\t\trouteS := createRoute(apiTitle, apiBasePath, apiVersion, endpointSand[0], resource, clusterRefSand)\n-\t\t\troutesSand = append(routesSand, routeS)\n-\t\t\tendpointsSand = append(endpointsSand, addressSand)\n-\n-\t\t\t// API level check\n-\t\t} else if len(mgwSwagger.GetSandEndpoints()) > 0 {\n-\t\t\tendpointSand = apiLevelEndpointSand\n-\t\t\tclusterRefSand := apilevelClusterSand.GetName()\n+\t// check API level sandbox endpoints availble\n+\tif len(mgwSwagger.GetSandEndpoints()) > 0 {\n+\t\tapiLevelEndpointSand = mgwSwagger.GetSandEndpoints()\n+\t\tif apiEndpointBasePath != apiLevelEndpointSand[0].Basepath && len(apiLevelEndpointProd) > 0 {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc4MTY3NQ=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDQ3MTMwOnYy", "diffSide": "RIGHT", "path": "resources/conf/config.toml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTo1OTo0MVrOIIgMFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxOToxNDoxM1rOIOj1og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc4NjkwMA==", "bodyText": "Check against unavailable cipher suites.", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r545786900", "createdAt": "2020-12-18T11:59:41Z", "author": {"login": "VirajSalaka"}, "path": "resources/conf/config.toml", "diffHunk": "@@ -15,6 +15,16 @@ listenerTLSEnabled = true\n listenerCertPath = \"/home/wso2/security/localhost.pem\"\n listenerKeyPath = \"/home/wso2/security/localhost.key\"\n \n+[envoy.upstream]\n+[envoy.upstream.tls]\n+minimumProtocolVersion = \"TLS1_2\"\n+maximumProtocolVersion = \"TLS1_2\"\n+ciphers = \"ECDHE-ECDSA-AES128-GCM-SHA256, ECDHE-RSA-AES128-GCM-SHA256, ECDHE-ECDSA-AES128-SHA, ECDHE-RSA-AES128-SHA, AES128-GCM-SHA256, AES128-SHA, ECDHE-ECDSA-AES256-GCM-SHA384, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-ECDSA-AES256-SHA, ECDHE-RSA-AES256-SHA, AES256-GCM-SHA384, AES256-SHA\"  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEzODE0Ng==", "bodyText": "When an unavailable cipher suite is set in the server configuration (backend), the following error is received.\n< HTTP/1.1 503 Service Unavailable\n< content-length: 196\n< content-type: text/plain\n< date: Tue, 05 Jan 2021 19:13:38 GMT\n< server: envoy\n<\n* Connection #0 to host localhost left intact\nupstream connect error or disconnect/reset before headers. reset reason: connection failure, transport failure reason: TLS error: 268436536:SSL routines:OPENSSL_internal:TLSV1_ALERT_INTERNAL_ERROR* Closing connection 0", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r552138146", "createdAt": "2021-01-05T19:14:13Z", "author": {"login": "VirajSalaka"}, "path": "resources/conf/config.toml", "diffHunk": "@@ -15,6 +15,16 @@ listenerTLSEnabled = true\n listenerCertPath = \"/home/wso2/security/localhost.pem\"\n listenerKeyPath = \"/home/wso2/security/localhost.key\"\n \n+[envoy.upstream]\n+[envoy.upstream.tls]\n+minimumProtocolVersion = \"TLS1_2\"\n+maximumProtocolVersion = \"TLS1_2\"\n+ciphers = \"ECDHE-ECDSA-AES128-GCM-SHA256, ECDHE-RSA-AES128-GCM-SHA256, ECDHE-ECDSA-AES128-SHA, ECDHE-RSA-AES128-SHA, AES128-GCM-SHA256, AES128-SHA, ECDHE-ECDSA-AES256-GCM-SHA384, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-ECDSA-AES256-SHA, ECDHE-RSA-AES256-SHA, AES256-GCM-SHA384, AES256-SHA\"  ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc4NjkwMA=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDQ3NTE0OnYy", "diffSide": "RIGHT", "path": "resources/conf/config.toml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMjowMDo1NVrOIIgOWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNzo0Njo0N1rOIO04aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc4NzQ4Mw==", "bodyText": "Check with security team to change to 1.1", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r545787483", "createdAt": "2020-12-18T12:00:55Z", "author": {"login": "VirajSalaka"}, "path": "resources/conf/config.toml", "diffHunk": "@@ -15,6 +15,16 @@ listenerTLSEnabled = true\n listenerCertPath = \"/home/wso2/security/localhost.pem\"\n listenerKeyPath = \"/home/wso2/security/localhost.key\"\n \n+[envoy.upstream]\n+[envoy.upstream.tls]\n+minimumProtocolVersion = \"TLS1_2\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQxNzM4Nw==", "bodyText": "fixed via 452e70d", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r552417387", "createdAt": "2021-01-06T07:46:47Z", "author": {"login": "VirajSalaka"}, "path": "resources/conf/config.toml", "diffHunk": "@@ -15,6 +15,16 @@ listenerTLSEnabled = true\n listenerCertPath = \"/home/wso2/security/localhost.pem\"\n listenerKeyPath = \"/home/wso2/security/localhost.key\"\n \n+[envoy.upstream]\n+[envoy.upstream.tls]\n+minimumProtocolVersion = \"TLS1_2\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc4NzQ4Mw=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDQ4NzEwOnYy", "diffSide": "RIGHT", "path": "adapter/pkg/oasparser/envoyconf/routesWithClusters.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMjowNDo1MVrOIIgVKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNzo0NjozMFrOIO034A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc4OTIyNw==", "bodyText": "Remove comments", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r545789227", "createdAt": "2020-12-18T12:04:51Z", "author": {"login": "VirajSalaka"}, "path": "adapter/pkg/oasparser/envoyconf/routesWithClusters.go", "diffHunk": "@@ -258,26 +333,33 @@ func createRoute(title string, xWso2Basepath string, version string, endpoint mo\n \t\tHeaders: []*routev3.HeaderMatcher{&headerMatcherArray},\n \t}\n \n-\thostRewriteSpecifier := &routev3.RouteAction_HostRewriteLiteral{\n-\t\tHostRewriteLiteral: endpoint.Host,\n+\thostRewriteSpecifier := &routev3.RouteAction_AutoHostRewrite{\n+\t\tAutoHostRewrite: &wrapperspb.BoolValue{\n+\t\t\tValue: true,\n+\t\t},\n \t}\n+\t// var headerBasedClusterSpecifier *routev3.RouteAction_ClusterHeader", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 333}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQxNzI0OA==", "bodyText": "fixed via 452e70d", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r552417248", "createdAt": "2021-01-06T07:46:30Z", "author": {"login": "VirajSalaka"}, "path": "adapter/pkg/oasparser/envoyconf/routesWithClusters.go", "diffHunk": "@@ -258,26 +333,33 @@ func createRoute(title string, xWso2Basepath string, version string, endpoint mo\n \t\tHeaders: []*routev3.HeaderMatcher{&headerMatcherArray},\n \t}\n \n-\thostRewriteSpecifier := &routev3.RouteAction_HostRewriteLiteral{\n-\t\tHostRewriteLiteral: endpoint.Host,\n+\thostRewriteSpecifier := &routev3.RouteAction_AutoHostRewrite{\n+\t\tAutoHostRewrite: &wrapperspb.BoolValue{\n+\t\t\tValue: true,\n+\t\t},\n \t}\n+\t// var headerBasedClusterSpecifier *routev3.RouteAction_ClusterHeader", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc4OTIyNw=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 333}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDQ5NzcxOnYy", "diffSide": "RIGHT", "path": "adapter/pkg/oasparser/envoyconf/routesWithClusters.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMjowODowN1rOIIgbAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNzo0NjoyNFrOIO03yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc5MDcyMA==", "bodyText": "Simplify the boolean logic", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r545790720", "createdAt": "2020-12-18T12:08:07Z", "author": {"login": "VirajSalaka"}, "path": "adapter/pkg/oasparser/envoyconf/routesWithClusters.go", "diffHunk": "@@ -309,19 +391,38 @@ func createRoute(title string, xWso2Basepath string, version string, endpoint mo\n \t\t\t\t\t\t},\n \t\t\t\t\t\tRegex: xWso2Basepath,\n \t\t\t\t\t},\n-\t\t\t\t\tSubstitution: endpoint.Basepath,\n+\t\t\t\t\tSubstitution: endpointBasepath,\n \t\t\t\t},\n-\t\t\t\tClusterSpecifier: clusterSpecifier,\n \t\t\t},\n \t\t}\n \t} else {\n \t\taction = &routev3.Route_Route{\n \t\t\tRoute: &routev3.RouteAction{\n \t\t\t\tHostRewriteSpecifier: hostRewriteSpecifier,\n-\t\t\t\tClusterSpecifier:     clusterSpecifier,\n \t\t\t},\n \t\t}\n \t}\n+\n+\t//TODO: (VirajSalaka) Introduce a separate function\n+\tif !(prodClusterName == \"\" || sandClusterName == \"\") {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 396}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQxNzIyNw==", "bodyText": "fixed via 452e70d", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r552417227", "createdAt": "2021-01-06T07:46:24Z", "author": {"login": "VirajSalaka"}, "path": "adapter/pkg/oasparser/envoyconf/routesWithClusters.go", "diffHunk": "@@ -309,19 +391,38 @@ func createRoute(title string, xWso2Basepath string, version string, endpoint mo\n \t\t\t\t\t\t},\n \t\t\t\t\t\tRegex: xWso2Basepath,\n \t\t\t\t\t},\n-\t\t\t\t\tSubstitution: endpoint.Basepath,\n+\t\t\t\t\tSubstitution: endpointBasepath,\n \t\t\t\t},\n-\t\t\t\tClusterSpecifier: clusterSpecifier,\n \t\t\t},\n \t\t}\n \t} else {\n \t\taction = &routev3.Route_Route{\n \t\t\tRoute: &routev3.RouteAction{\n \t\t\t\tHostRewriteSpecifier: hostRewriteSpecifier,\n-\t\t\t\tClusterSpecifier:     clusterSpecifier,\n \t\t\t},\n \t\t}\n \t}\n+\n+\t//TODO: (VirajSalaka) Introduce a separate function\n+\tif !(prodClusterName == \"\" || sandClusterName == \"\") {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc5MDcyMA=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 396}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDUwMjUxOnYy", "diffSide": "RIGHT", "path": "adapter/resources/adminAPI.yaml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMjowOTozNlrOIIgdvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMjowOTozNlrOIIgdvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc5MTQyMQ==", "bodyText": "Make this mg instead of mgw", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r545791421", "createdAt": "2020-12-18T12:09:36Z", "author": {"login": "VirajSalaka"}, "path": "adapter/resources/adminAPI.yaml", "diffHunk": "@@ -14,15 +14,15 @@\n         name: \"Apache 2.0\"\n         url: \"http://www.apache.org/licenses/LICENSE-2.0.html\"\n     host: \"apis.wso2.com\"\n-    basePath: \"/mgw/1.0\"\n+    basePath: \"/api/mgw/adapter/0.1\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDUwMzcwOnYy", "diffSide": "RIGHT", "path": "adapter/test-resources/envoycodegen/certs/testcrt.crt", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMjoxMDowMFrOIIgeaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNzo0NjoxMlrOIO03iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc5MTU5Mg==", "bodyText": "new line", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r545791592", "createdAt": "2020-12-18T12:10:00Z", "author": {"login": "VirajSalaka"}, "path": "adapter/test-resources/envoycodegen/certs/testcrt.crt", "diffHunk": "@@ -0,0 +1,44 @@\n+-----BEGIN CERTIFICATE-----\n+MIIH0zCCBbugAwIBAgIIXsO3pkN/pOAwDQYJKoZIhvcNAQEFBQAwQjESMBAGA1UE\n+AwwJQUNDVlJBSVoxMRAwDgYDVQQLDAdQS0lBQ0NWMQ0wCwYDVQQKDARBQ0NWMQsw\n+CQYDVQQGEwJFUzAeFw0xMTA1MDUwOTM3MzdaFw0zMDEyMzEwOTM3MzdaMEIxEjAQ\n+BgNVBAMMCUFDQ1ZSQUlaMTEQMA4GA1UECwwHUEtJQUNDVjENMAsGA1UECgwEQUND\n+VjELMAkGA1UEBhMCRVMwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCb\n+qau/YUqXry+XZpp0X9DZlv3P4uRm7x8fRzPCRKPfmt4ftVTdFXxpNRFvu8gMjmoY\n+HtiP2Ra8EEg2XPBjs5BaXCQ316PWywlxufEBcoSwfdtNgM3802/J+Nq2DoLSRYWo\n+G2ioPej0RGy9ocLLA76MPhMAhN9KSMDjIgro6TenGEyxCQ0jVn8ETdkXhBilyNpA\n+lHPrzg5XPAOBOp0KoVdDaaxXbXmQeOW1tDvYvEyNKKGno6e6Ak4l0Squ7a4DIrhr\n+IA8wKFSVf+DuzgpmndFALW4ir50awQUZ0m/A8p/4e7MCQvtQqR0tkw8jq8bBD5L/\n+0KIV9VMJcRz/RROE5iZe+OCIHAr8Fraocwa48GOEAqDGWuzndN9wrqODJerWx5eH\n+k6fGioozl2A3ED6XPm4pFdahD9GILBKfb6qkxkLrQaLjlUPTAYVtjrs78yM2x/47\n+4KElB0iryYl0/wiPgL/AlmXz7uxLaL2diMMxs0Dx6M/2OLuc5NF/1OVYm3z61PMO\n+m3WR5LpSLhl+0fXNWhn8ugb2+1KoS5kE3fj5tItQo05iifCHJPqDQsGH+tUtKSpa\n+cXpkatcnYGMN285J9Y0fkIkyF/hzQ7jSWpOGYdbhdQrqeWZ2iE9x6wQl1gpaepPl\n+uUsXQA+xtrn13k/c4LOsOxFwYIRKQ26ZIMApcQrAZQIDAQABo4ICyzCCAscwfQYI\n+KwYBBQUHAQEEcTBvMEwGCCsGAQUFBzAChkBodHRwOi8vd3d3LmFjY3YuZXMvZmls\n+ZWFkbWluL0FyY2hpdm9zL2NlcnRpZmljYWRvcy9yYWl6YWNjdjEuY3J0MB8GCCsG\n+AQUFBzABhhNodHRwOi8vb2NzcC5hY2N2LmVzMB0GA1UdDgQWBBTSh7Tj3zcnk1X2\n+VuqB5TbMjB4/vTAPBgNVHRMBAf8EBTADAQH/MB8GA1UdIwQYMBaAFNKHtOPfNyeT\n+VfZW6oHlNsyMHj+9MIIBcwYDVR0gBIIBajCCAWYwggFiBgRVHSAAMIIBWDCCASIG\n+CCsGAQUFBwICMIIBFB6CARAAQQB1AHQAbwByAGkAZABhAGQAIABkAGUAIABDAGUA\n+cgB0AGkAZgBpAGMAYQBjAGkA8wBuACAAUgBhAO0AegAgAGQAZQAgAGwAYQAgAEEA\n+QwBDAFYAIAAoAEEAZwBlAG4AYwBpAGEAIABkAGUAIABUAGUAYwBuAG8AbABvAGcA\n+7QBhACAAeQAgAEMAZQByAHQAaQBmAGkAYwBhAGMAaQDzAG4AIABFAGwAZQBjAHQA\n+cgDzAG4AaQBjAGEALAAgAEMASQBGACAAUQA0ADYAMAAxADEANQA2AEUAKQAuACAA\n+QwBQAFMAIABlAG4AIABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBjAGMAdgAuAGUA\n+czAwBggrBgEFBQcCARYkaHR0cDovL3d3dy5hY2N2LmVzL2xlZ2lzbGFjaW9uX2Mu\n+aHRtMFUGA1UdHwROMEwwSqBIoEaGRGh0dHA6Ly93d3cuYWNjdi5lcy9maWxlYWRt\n+aW4vQXJjaGl2b3MvY2VydGlmaWNhZG9zL3JhaXphY2N2MV9kZXIuY3JsMA4GA1Ud\n+DwEB/wQEAwIBBjAXBgNVHREEEDAOgQxhY2N2QGFjY3YuZXMwDQYJKoZIhvcNAQEF\n+BQADggIBAJcxAp/n/UNnSEQU5CmH7UwoZtCPNdpNYbdKl02125DgBS4OxnnQ8pdp\n+D70ER9m+27Up2pvZrqmZ1dM8MJP1jaGo/AaNRPTKFpV8M9xii6g3+CfYCS0b78gU\n+JyCpZET/LtZ1qmxNYEAZSUNUY9rizLpm5U9EelvZaoErQNV/+QEnWCzI7UiRfD+m\n+AM/EKXMRNt6GGT6d7hmKG9Ww7Y49nCrADdg9ZuM8Db3VlFzi4qc1GwQA9j9ajepD\n+vV+JHanBsMyZ4k0ACtrJJ1vnE5Bc5PUzolVt3OAJTS+xJlsndQAJxGJ3KQhfnlms\n+tn6tn1QwIgPBHnFk/vk4CpYY3QIUrCPLBhwepH2NDd4nQeit2hW3sCPdK6jT2iWH\n+7ehVRE2I9DZ+hJp4rPcOVkkO1jMl1oRQQmwgEh0q1b688nCBpHBgvgW1m54ERL5h\n+I6zppSSMEYCUWqKiuUnSwdzRp+0xESyeGabu4VXhwOrPDYTkF7eifKXeVSUG7szA\n+h1xA2syVP1XgNce4hL60Xc16gwFy7ofmXx2utYXGJt/mwZrpHgJHnyqobalbz+xF\n+d3+YJ5oyXSrjhO7FmGYvliAd3djDJ9ew+f7Zfc3Qn48LFFhRny+Lwzgt3uiP1o2H\n+pPVWQxaZLPSkVrQ0uGE3ycJYgBugl6H8WY3pEfbRD0tVNEYqi4Y7\n+-----END CERTIFICATE-----", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQxNzE2MQ==", "bodyText": "fixed via 452e70d", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r552417161", "createdAt": "2021-01-06T07:46:12Z", "author": {"login": "VirajSalaka"}, "path": "adapter/test-resources/envoycodegen/certs/testcrt.crt", "diffHunk": "@@ -0,0 +1,44 @@\n+-----BEGIN CERTIFICATE-----\n+MIIH0zCCBbugAwIBAgIIXsO3pkN/pOAwDQYJKoZIhvcNAQEFBQAwQjESMBAGA1UE\n+AwwJQUNDVlJBSVoxMRAwDgYDVQQLDAdQS0lBQ0NWMQ0wCwYDVQQKDARBQ0NWMQsw\n+CQYDVQQGEwJFUzAeFw0xMTA1MDUwOTM3MzdaFw0zMDEyMzEwOTM3MzdaMEIxEjAQ\n+BgNVBAMMCUFDQ1ZSQUlaMTEQMA4GA1UECwwHUEtJQUNDVjENMAsGA1UECgwEQUND\n+VjELMAkGA1UEBhMCRVMwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCb\n+qau/YUqXry+XZpp0X9DZlv3P4uRm7x8fRzPCRKPfmt4ftVTdFXxpNRFvu8gMjmoY\n+HtiP2Ra8EEg2XPBjs5BaXCQ316PWywlxufEBcoSwfdtNgM3802/J+Nq2DoLSRYWo\n+G2ioPej0RGy9ocLLA76MPhMAhN9KSMDjIgro6TenGEyxCQ0jVn8ETdkXhBilyNpA\n+lHPrzg5XPAOBOp0KoVdDaaxXbXmQeOW1tDvYvEyNKKGno6e6Ak4l0Squ7a4DIrhr\n+IA8wKFSVf+DuzgpmndFALW4ir50awQUZ0m/A8p/4e7MCQvtQqR0tkw8jq8bBD5L/\n+0KIV9VMJcRz/RROE5iZe+OCIHAr8Fraocwa48GOEAqDGWuzndN9wrqODJerWx5eH\n+k6fGioozl2A3ED6XPm4pFdahD9GILBKfb6qkxkLrQaLjlUPTAYVtjrs78yM2x/47\n+4KElB0iryYl0/wiPgL/AlmXz7uxLaL2diMMxs0Dx6M/2OLuc5NF/1OVYm3z61PMO\n+m3WR5LpSLhl+0fXNWhn8ugb2+1KoS5kE3fj5tItQo05iifCHJPqDQsGH+tUtKSpa\n+cXpkatcnYGMN285J9Y0fkIkyF/hzQ7jSWpOGYdbhdQrqeWZ2iE9x6wQl1gpaepPl\n+uUsXQA+xtrn13k/c4LOsOxFwYIRKQ26ZIMApcQrAZQIDAQABo4ICyzCCAscwfQYI\n+KwYBBQUHAQEEcTBvMEwGCCsGAQUFBzAChkBodHRwOi8vd3d3LmFjY3YuZXMvZmls\n+ZWFkbWluL0FyY2hpdm9zL2NlcnRpZmljYWRvcy9yYWl6YWNjdjEuY3J0MB8GCCsG\n+AQUFBzABhhNodHRwOi8vb2NzcC5hY2N2LmVzMB0GA1UdDgQWBBTSh7Tj3zcnk1X2\n+VuqB5TbMjB4/vTAPBgNVHRMBAf8EBTADAQH/MB8GA1UdIwQYMBaAFNKHtOPfNyeT\n+VfZW6oHlNsyMHj+9MIIBcwYDVR0gBIIBajCCAWYwggFiBgRVHSAAMIIBWDCCASIG\n+CCsGAQUFBwICMIIBFB6CARAAQQB1AHQAbwByAGkAZABhAGQAIABkAGUAIABDAGUA\n+cgB0AGkAZgBpAGMAYQBjAGkA8wBuACAAUgBhAO0AegAgAGQAZQAgAGwAYQAgAEEA\n+QwBDAFYAIAAoAEEAZwBlAG4AYwBpAGEAIABkAGUAIABUAGUAYwBuAG8AbABvAGcA\n+7QBhACAAeQAgAEMAZQByAHQAaQBmAGkAYwBhAGMAaQDzAG4AIABFAGwAZQBjAHQA\n+cgDzAG4AaQBjAGEALAAgAEMASQBGACAAUQA0ADYAMAAxADEANQA2AEUAKQAuACAA\n+QwBQAFMAIABlAG4AIABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBjAGMAdgAuAGUA\n+czAwBggrBgEFBQcCARYkaHR0cDovL3d3dy5hY2N2LmVzL2xlZ2lzbGFjaW9uX2Mu\n+aHRtMFUGA1UdHwROMEwwSqBIoEaGRGh0dHA6Ly93d3cuYWNjdi5lcy9maWxlYWRt\n+aW4vQXJjaGl2b3MvY2VydGlmaWNhZG9zL3JhaXphY2N2MV9kZXIuY3JsMA4GA1Ud\n+DwEB/wQEAwIBBjAXBgNVHREEEDAOgQxhY2N2QGFjY3YuZXMwDQYJKoZIhvcNAQEF\n+BQADggIBAJcxAp/n/UNnSEQU5CmH7UwoZtCPNdpNYbdKl02125DgBS4OxnnQ8pdp\n+D70ER9m+27Up2pvZrqmZ1dM8MJP1jaGo/AaNRPTKFpV8M9xii6g3+CfYCS0b78gU\n+JyCpZET/LtZ1qmxNYEAZSUNUY9rizLpm5U9EelvZaoErQNV/+QEnWCzI7UiRfD+m\n+AM/EKXMRNt6GGT6d7hmKG9Ww7Y49nCrADdg9ZuM8Db3VlFzi4qc1GwQA9j9ajepD\n+vV+JHanBsMyZ4k0ACtrJJ1vnE5Bc5PUzolVt3OAJTS+xJlsndQAJxGJ3KQhfnlms\n+tn6tn1QwIgPBHnFk/vk4CpYY3QIUrCPLBhwepH2NDd4nQeit2hW3sCPdK6jT2iWH\n+7ehVRE2I9DZ+hJp4rPcOVkkO1jMl1oRQQmwgEh0q1b688nCBpHBgvgW1m54ERL5h\n+I6zppSSMEYCUWqKiuUnSwdzRp+0xESyeGabu4VXhwOrPDYTkF7eifKXeVSUG7szA\n+h1xA2syVP1XgNce4hL60Xc16gwFy7ofmXx2utYXGJt/mwZrpHgJHnyqobalbz+xF\n+d3+YJ5oyXSrjhO7FmGYvliAd3djDJ9ew+f7Zfc3Qn48LFFhRny+Lwzgt3uiP1o2H\n+pPVWQxaZLPSkVrQ0uGE3ycJYgBugl6H8WY3pEfbRD0tVNEYqi4Y7\n+-----END CERTIFICATE-----", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc5MTU5Mg=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDUzNDU5OnYy", "diffSide": "RIGHT", "path": "enforcer/src/main/java/org/wso2/micro/gateway/enforcer/security/AuthFilter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMjoxOTo1NFrOIIgvwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNzo0NTowN1rOIO01_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc5NjAzNA==", "bodyText": "Constants", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r545796034", "createdAt": "2020-12-18T12:19:54Z", "author": {"login": "VirajSalaka"}, "path": "enforcer/src/main/java/org/wso2/micro/gateway/enforcer/security/AuthFilter.java", "diffHunk": "@@ -46,15 +49,65 @@ public boolean handleRequest(RequestContext requestContext) {\n                 if (authenticator.canAuthenticate(requestContext)) {\n                     AuthenticationContext authenticate = authenticator.authenticate(requestContext);\n                     if (authenticate.isAuthenticated()) {\n+                        updateClusterHeaderAndCheckEnv(requestContext, authenticate);\n                         return true;\n                     }\n                 }\n             }\n         } catch (APISecurityException e) {\n-            requestContext.getProperties().put(\"code\", e.getErrorCode());\n+            //TODO: (VirajSalaka) provide the error code properly based on exception (401, 403, 429 etc)\n+            requestContext.getProperties().put(\"code\", \"401\");\n             requestContext.getProperties().put(\"error_code\", e.getErrorCode());\n             requestContext.getProperties().put(\"error_description\", e.getMessage());\n         }\n         return false;\n     }\n+\n+    /**\n+     * Update the cluster header based on the keyType and authenticate the token against its respective endpoint\n+     * environment.\n+     * \n+     * @param requestContext request Context \n+     * @param authContext authentication context\n+     * @throws APISecurityException if the environment and \n+     */\n+    private void updateClusterHeaderAndCheckEnv(RequestContext requestContext, AuthenticationContext authContext)\n+            throws APISecurityException {\n+\n+        String keyType = authContext.getKeyType();\n+        if (StringUtils.isEmpty(authContext.getKeyType())) {\n+            keyType = \"PRODUCTION\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQxNjc2Ng==", "bodyText": "fixed via a4c0595", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r552416766", "createdAt": "2021-01-06T07:45:07Z", "author": {"login": "VirajSalaka"}, "path": "enforcer/src/main/java/org/wso2/micro/gateway/enforcer/security/AuthFilter.java", "diffHunk": "@@ -46,15 +49,65 @@ public boolean handleRequest(RequestContext requestContext) {\n                 if (authenticator.canAuthenticate(requestContext)) {\n                     AuthenticationContext authenticate = authenticator.authenticate(requestContext);\n                     if (authenticate.isAuthenticated()) {\n+                        updateClusterHeaderAndCheckEnv(requestContext, authenticate);\n                         return true;\n                     }\n                 }\n             }\n         } catch (APISecurityException e) {\n-            requestContext.getProperties().put(\"code\", e.getErrorCode());\n+            //TODO: (VirajSalaka) provide the error code properly based on exception (401, 403, 429 etc)\n+            requestContext.getProperties().put(\"code\", \"401\");\n             requestContext.getProperties().put(\"error_code\", e.getErrorCode());\n             requestContext.getProperties().put(\"error_description\", e.getMessage());\n         }\n         return false;\n     }\n+\n+    /**\n+     * Update the cluster header based on the keyType and authenticate the token against its respective endpoint\n+     * environment.\n+     * \n+     * @param requestContext request Context \n+     * @param authContext authentication context\n+     * @throws APISecurityException if the environment and \n+     */\n+    private void updateClusterHeaderAndCheckEnv(RequestContext requestContext, AuthenticationContext authContext)\n+            throws APISecurityException {\n+\n+        String keyType = authContext.getKeyType();\n+        if (StringUtils.isEmpty(authContext.getKeyType())) {\n+            keyType = \"PRODUCTION\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc5NjAzNA=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDU0MTE3OnYy", "diffSide": "RIGHT", "path": "enforcer/src/main/java/org/wso2/micro/gateway/enforcer/security/AuthFilter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMjoyMTo1OFrOIIgzXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNzo0NTo1NVrOIO03CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc5Njk1OA==", "bodyText": "Remove the redundant isEmpty check", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r545796958", "createdAt": "2020-12-18T12:21:58Z", "author": {"login": "VirajSalaka"}, "path": "enforcer/src/main/java/org/wso2/micro/gateway/enforcer/security/AuthFilter.java", "diffHunk": "@@ -46,15 +49,65 @@ public boolean handleRequest(RequestContext requestContext) {\n                 if (authenticator.canAuthenticate(requestContext)) {\n                     AuthenticationContext authenticate = authenticator.authenticate(requestContext);\n                     if (authenticate.isAuthenticated()) {\n+                        updateClusterHeaderAndCheckEnv(requestContext, authenticate);\n                         return true;\n                     }\n                 }\n             }\n         } catch (APISecurityException e) {\n-            requestContext.getProperties().put(\"code\", e.getErrorCode());\n+            //TODO: (VirajSalaka) provide the error code properly based on exception (401, 403, 429 etc)\n+            requestContext.getProperties().put(\"code\", \"401\");\n             requestContext.getProperties().put(\"error_code\", e.getErrorCode());\n             requestContext.getProperties().put(\"error_description\", e.getMessage());\n         }\n         return false;\n     }\n+\n+    /**\n+     * Update the cluster header based on the keyType and authenticate the token against its respective endpoint\n+     * environment.\n+     * \n+     * @param requestContext request Context \n+     * @param authContext authentication context\n+     * @throws APISecurityException if the environment and \n+     */\n+    private void updateClusterHeaderAndCheckEnv(RequestContext requestContext, AuthenticationContext authContext)\n+            throws APISecurityException {\n+\n+        String keyType = authContext.getKeyType();\n+        if (StringUtils.isEmpty(authContext.getKeyType())) {\n+            keyType = \"PRODUCTION\";\n+        } \n+\n+        // Header needs to be set only if the relevant cluster is available for the resource and the key type is\n+        // matched.\n+        if (requestContext.isClusterHeaderEnabled()) {\n+            if (keyType.equalsIgnoreCase(\"PRODUCTION\") &&\n+                    !StringUtils.isEmpty(requestContext.getProdClusterHeader())) {\n+                requestContext.addResponseHeaders(AdapterConstants.CLUSTER_HEADER,\n+                        requestContext.getProdClusterHeader());\n+            } else if (keyType.equalsIgnoreCase(\"SANDBOX\") &&\n+                    !StringUtils.isEmpty(requestContext.getSandClusterHeader())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQxNzAzMg==", "bodyText": "fixed via 452e70d", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r552417032", "createdAt": "2021-01-06T07:45:55Z", "author": {"login": "VirajSalaka"}, "path": "enforcer/src/main/java/org/wso2/micro/gateway/enforcer/security/AuthFilter.java", "diffHunk": "@@ -46,15 +49,65 @@ public boolean handleRequest(RequestContext requestContext) {\n                 if (authenticator.canAuthenticate(requestContext)) {\n                     AuthenticationContext authenticate = authenticator.authenticate(requestContext);\n                     if (authenticate.isAuthenticated()) {\n+                        updateClusterHeaderAndCheckEnv(requestContext, authenticate);\n                         return true;\n                     }\n                 }\n             }\n         } catch (APISecurityException e) {\n-            requestContext.getProperties().put(\"code\", e.getErrorCode());\n+            //TODO: (VirajSalaka) provide the error code properly based on exception (401, 403, 429 etc)\n+            requestContext.getProperties().put(\"code\", \"401\");\n             requestContext.getProperties().put(\"error_code\", e.getErrorCode());\n             requestContext.getProperties().put(\"error_description\", e.getMessage());\n         }\n         return false;\n     }\n+\n+    /**\n+     * Update the cluster header based on the keyType and authenticate the token against its respective endpoint\n+     * environment.\n+     * \n+     * @param requestContext request Context \n+     * @param authContext authentication context\n+     * @throws APISecurityException if the environment and \n+     */\n+    private void updateClusterHeaderAndCheckEnv(RequestContext requestContext, AuthenticationContext authContext)\n+            throws APISecurityException {\n+\n+        String keyType = authContext.getKeyType();\n+        if (StringUtils.isEmpty(authContext.getKeyType())) {\n+            keyType = \"PRODUCTION\";\n+        } \n+\n+        // Header needs to be set only if the relevant cluster is available for the resource and the key type is\n+        // matched.\n+        if (requestContext.isClusterHeaderEnabled()) {\n+            if (keyType.equalsIgnoreCase(\"PRODUCTION\") &&\n+                    !StringUtils.isEmpty(requestContext.getProdClusterHeader())) {\n+                requestContext.addResponseHeaders(AdapterConstants.CLUSTER_HEADER,\n+                        requestContext.getProdClusterHeader());\n+            } else if (keyType.equalsIgnoreCase(\"SANDBOX\") &&\n+                    !StringUtils.isEmpty(requestContext.getSandClusterHeader())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc5Njk1OA=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDU0NjY5OnYy", "diffSide": "RIGHT", "path": "enforcer/src/main/java/org/wso2/micro/gateway/enforcer/security/AuthFilter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMjoyMzo0OFrOIIg2cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNzo0NDo0MFrOIO01Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc5Nzc0Nw==", "bodyText": "Error message should be as same as the one presents in API Manager", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r545797747", "createdAt": "2020-12-18T12:23:48Z", "author": {"login": "VirajSalaka"}, "path": "enforcer/src/main/java/org/wso2/micro/gateway/enforcer/security/AuthFilter.java", "diffHunk": "@@ -46,15 +49,65 @@ public boolean handleRequest(RequestContext requestContext) {\n                 if (authenticator.canAuthenticate(requestContext)) {\n                     AuthenticationContext authenticate = authenticator.authenticate(requestContext);\n                     if (authenticate.isAuthenticated()) {\n+                        updateClusterHeaderAndCheckEnv(requestContext, authenticate);\n                         return true;\n                     }\n                 }\n             }\n         } catch (APISecurityException e) {\n-            requestContext.getProperties().put(\"code\", e.getErrorCode());\n+            //TODO: (VirajSalaka) provide the error code properly based on exception (401, 403, 429 etc)\n+            requestContext.getProperties().put(\"code\", \"401\");\n             requestContext.getProperties().put(\"error_code\", e.getErrorCode());\n             requestContext.getProperties().put(\"error_description\", e.getMessage());\n         }\n         return false;\n     }\n+\n+    /**\n+     * Update the cluster header based on the keyType and authenticate the token against its respective endpoint\n+     * environment.\n+     * \n+     * @param requestContext request Context \n+     * @param authContext authentication context\n+     * @throws APISecurityException if the environment and \n+     */\n+    private void updateClusterHeaderAndCheckEnv(RequestContext requestContext, AuthenticationContext authContext)\n+            throws APISecurityException {\n+\n+        String keyType = authContext.getKeyType();\n+        if (StringUtils.isEmpty(authContext.getKeyType())) {\n+            keyType = \"PRODUCTION\";\n+        } \n+\n+        // Header needs to be set only if the relevant cluster is available for the resource and the key type is\n+        // matched.\n+        if (requestContext.isClusterHeaderEnabled()) {\n+            if (keyType.equalsIgnoreCase(\"PRODUCTION\") &&\n+                    !StringUtils.isEmpty(requestContext.getProdClusterHeader())) {\n+                requestContext.addResponseHeaders(AdapterConstants.CLUSTER_HEADER,\n+                        requestContext.getProdClusterHeader());\n+            } else if (keyType.equalsIgnoreCase(\"SANDBOX\") &&\n+                    !StringUtils.isEmpty(requestContext.getSandClusterHeader())) {\n+                requestContext.addResponseHeaders(AdapterConstants.CLUSTER_HEADER,\n+                        requestContext.getSandClusterHeader());\n+            } else {\n+                throw new APISecurityException(APISecurityConstants.API_AUTH_INVALID_CREDENTIALS,\n+                        \"Invalid Token to access production/sandbox environment.\");\n+            }\n+        } else {\n+            // Even if the header flag is false, it is required to check if the relevant resource has a defined cluster\n+            // based on environment. \n+            // If not it should provide authentication error.\n+            // Always at least one of the cluster header values should be set.\n+            if (keyType.equalsIgnoreCase(\"PRODUCTION\")\n+                    && StringUtils.isEmpty(requestContext.getProdClusterHeader())) {\n+                throw new APISecurityException(APISecurityConstants.API_AUTH_INVALID_CREDENTIALS,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQxNjU5MA==", "bodyText": "fixed via a4c0595", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r552416590", "createdAt": "2021-01-06T07:44:40Z", "author": {"login": "VirajSalaka"}, "path": "enforcer/src/main/java/org/wso2/micro/gateway/enforcer/security/AuthFilter.java", "diffHunk": "@@ -46,15 +49,65 @@ public boolean handleRequest(RequestContext requestContext) {\n                 if (authenticator.canAuthenticate(requestContext)) {\n                     AuthenticationContext authenticate = authenticator.authenticate(requestContext);\n                     if (authenticate.isAuthenticated()) {\n+                        updateClusterHeaderAndCheckEnv(requestContext, authenticate);\n                         return true;\n                     }\n                 }\n             }\n         } catch (APISecurityException e) {\n-            requestContext.getProperties().put(\"code\", e.getErrorCode());\n+            //TODO: (VirajSalaka) provide the error code properly based on exception (401, 403, 429 etc)\n+            requestContext.getProperties().put(\"code\", \"401\");\n             requestContext.getProperties().put(\"error_code\", e.getErrorCode());\n             requestContext.getProperties().put(\"error_description\", e.getMessage());\n         }\n         return false;\n     }\n+\n+    /**\n+     * Update the cluster header based on the keyType and authenticate the token against its respective endpoint\n+     * environment.\n+     * \n+     * @param requestContext request Context \n+     * @param authContext authentication context\n+     * @throws APISecurityException if the environment and \n+     */\n+    private void updateClusterHeaderAndCheckEnv(RequestContext requestContext, AuthenticationContext authContext)\n+            throws APISecurityException {\n+\n+        String keyType = authContext.getKeyType();\n+        if (StringUtils.isEmpty(authContext.getKeyType())) {\n+            keyType = \"PRODUCTION\";\n+        } \n+\n+        // Header needs to be set only if the relevant cluster is available for the resource and the key type is\n+        // matched.\n+        if (requestContext.isClusterHeaderEnabled()) {\n+            if (keyType.equalsIgnoreCase(\"PRODUCTION\") &&\n+                    !StringUtils.isEmpty(requestContext.getProdClusterHeader())) {\n+                requestContext.addResponseHeaders(AdapterConstants.CLUSTER_HEADER,\n+                        requestContext.getProdClusterHeader());\n+            } else if (keyType.equalsIgnoreCase(\"SANDBOX\") &&\n+                    !StringUtils.isEmpty(requestContext.getSandClusterHeader())) {\n+                requestContext.addResponseHeaders(AdapterConstants.CLUSTER_HEADER,\n+                        requestContext.getSandClusterHeader());\n+            } else {\n+                throw new APISecurityException(APISecurityConstants.API_AUTH_INVALID_CREDENTIALS,\n+                        \"Invalid Token to access production/sandbox environment.\");\n+            }\n+        } else {\n+            // Even if the header flag is false, it is required to check if the relevant resource has a defined cluster\n+            // based on environment. \n+            // If not it should provide authentication error.\n+            // Always at least one of the cluster header values should be set.\n+            if (keyType.equalsIgnoreCase(\"PRODUCTION\")\n+                    && StringUtils.isEmpty(requestContext.getProdClusterHeader())) {\n+                throw new APISecurityException(APISecurityConstants.API_AUTH_INVALID_CREDENTIALS,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc5Nzc0Nw=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDU2NTIyOnYy", "diffSide": "RIGHT", "path": "resources/router/security/localhost.pem", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMjoyOTowOFrOIIhAww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNzo0NzowN1rOIO045w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgwMDM4Nw==", "bodyText": "change the file name to mg.key", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r545800387", "createdAt": "2020-12-18T12:29:08Z", "author": {"login": "VirajSalaka"}, "path": "resources/router/security/localhost.pem", "diffHunk": "@@ -0,0 +1,21 @@\n+-----BEGIN CERTIFICATE-----\n+MIIDhTCCAm2gAwIBAgIJAJrwNDwLlCFQMA0GCSqGSIb3DQEBCwUAMGQxCzAJBgNV", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQxNzUxMQ==", "bodyText": "fixed via ea0fb02", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r552417511", "createdAt": "2021-01-06T07:47:07Z", "author": {"login": "VirajSalaka"}, "path": "resources/router/security/localhost.pem", "diffHunk": "@@ -0,0 +1,21 @@\n+-----BEGIN CERTIFICATE-----\n+MIIDhTCCAm2gAwIBAgIJAJrwNDwLlCFQMA0GCSqGSIb3DQEBCwUAMGQxCzAJBgNV", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgwMDM4Nw=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDU3NjIxOnYy", "diffSide": "RIGHT", "path": "test/mock-backend-server/src/main/java/org.wso2am.micro.gw.mockbackend/MockBackEndServer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMjozMjo1MVrOIIhHUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QwNzowMzo0MVrOIPhNcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgwMjA2NQ==", "bodyText": "check if an argument could be passed and start tls, mtls backends only for the required test cases.", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r545802065", "createdAt": "2020-12-18T12:32:51Z", "author": {"login": "VirajSalaka"}, "path": "test/mock-backend-server/src/main/java/org.wso2am.micro.gw.mockbackend/MockBackEndServer.java", "diffHunk": "@@ -32,35 +43,68 @@\n     private static final Logger logger = Logger.getLogger(MockBackEndServer.class.getName());\n     private HttpServer httpServer;\n     private String backEndServerUrl;\n-    private static int backEndServerPort;\n+    private int backEndServerPort;\n     private static boolean retryDone = false;\n-\n-\n+    private boolean secured = false;\n+    private boolean mtlsEnabled = false;\n \n     public static void main(String[] args) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQxNzU3NA==", "bodyText": "fixed via fa0f667", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r552417574", "createdAt": "2021-01-06T07:47:21Z", "author": {"login": "VirajSalaka"}, "path": "test/mock-backend-server/src/main/java/org.wso2am.micro.gw.mockbackend/MockBackEndServer.java", "diffHunk": "@@ -32,35 +43,68 @@\n     private static final Logger logger = Logger.getLogger(MockBackEndServer.class.getName());\n     private HttpServer httpServer;\n     private String backEndServerUrl;\n-    private static int backEndServerPort;\n+    private int backEndServerPort;\n     private static boolean retryDone = false;\n-\n-\n+    private boolean secured = false;\n+    private boolean mtlsEnabled = false;\n \n     public static void main(String[] args) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgwMjA2NQ=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE0MzY2Nw==", "bodyText": "change default backend to tls based server", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r553143667", "createdAt": "2021-01-07T07:03:41Z", "author": {"login": "VirajSalaka"}, "path": "test/mock-backend-server/src/main/java/org.wso2am.micro.gw.mockbackend/MockBackEndServer.java", "diffHunk": "@@ -32,35 +43,68 @@\n     private static final Logger logger = Logger.getLogger(MockBackEndServer.class.getName());\n     private HttpServer httpServer;\n     private String backEndServerUrl;\n-    private static int backEndServerPort;\n+    private int backEndServerPort;\n     private static boolean retryDone = false;\n-\n-\n+    private boolean secured = false;\n+    private boolean mtlsEnabled = false;\n \n     public static void main(String[] args) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgwMjA2NQ=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDcwODA3OnYy", "diffSide": "RIGHT", "path": "test/test-integration/src/test/java/org/wso2am/micro/gw/tests/endpoints/ProductionSandboxTestCase.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMzoxMToyMFrOIIiS8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QyMDozNTo0MlrOIP7ddQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgyMTQyNg==", "bodyText": "SAN validation based on verifyHostName\nGateway Types (Prod-sand, prod only, sand only)\nUnsecure https communication.", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r545821426", "createdAt": "2020-12-18T13:11:20Z", "author": {"login": "VirajSalaka"}, "path": "test/test-integration/src/test/java/org/wso2am/micro/gw/tests/endpoints/ProductionSandboxTestCase.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2am.micro.gw.tests.endpoints;\n+\n+import com.github.dockerjava.zerodep.shaded.org.apache.hc.core5.http.HttpStatus;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import org.wso2am.micro.gw.tests.common.BaseTestCase;\n+import org.wso2am.micro.gw.tests.common.model.API;\n+import org.wso2am.micro.gw.tests.common.model.ApplicationDTO;\n+import org.wso2am.micro.gw.tests.util.ApiDeployment;\n+import org.wso2am.micro.gw.tests.util.ApiProjectGenerator;\n+import org.wso2am.micro.gw.tests.util.HttpResponse;\n+import org.wso2am.micro.gw.tests.util.HttpsClientRequest;\n+import org.wso2am.micro.gw.tests.util.TestConstant;\n+import org.wso2am.micro.gw.mockbackend.ResponseConstants;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class ProductionSandboxTestCase extends BaseTestCase {\n+    protected String jwtTokenProd;\n+    protected String jwtTokenSand;\n+\n+    @BeforeClass(description = \"initialise the setup\")\n+    void start() throws Exception {\n+        super.startMGW();\n+\n+        //deploy the api\n+        //api yaml file should put to the resources/apis/openApis folder\n+        String prodSandApiZipfile = ApiProjectGenerator.createApictlProjZip(\n+                \"prod-sand/prodSandOpenAPI.yaml\");\n+        String prodOnlyApiZipfile = ApiProjectGenerator.createApictlProjZip(\n+                \"prod-sand/prodOpenAPI.yaml\");\n+        String sandOnlyApiZipfile = ApiProjectGenerator.createApictlProjZip(\n+                \"prod-sand/sandOpenAPI.yaml\");\n+        ApiDeployment.deployAPI(prodSandApiZipfile);\n+        ApiDeployment.deployAPI(prodOnlyApiZipfile);\n+        ApiDeployment.deployAPI(sandOnlyApiZipfile);\n+\n+        //TODO: (VirajSalaka) change the token\n+        //generate JWT token from APIM\n+        API api = new API();\n+        api.setName(\"PetStoreAPI\");\n+        api.setContext(\"petstore/v1\");\n+        api.setProdEndpoint(getMockServiceURLHttp(\"/echo/prod\"));\n+        api.setVersion(\"1.0.0\");\n+        api.setProvider(\"admin\");\n+\n+        //Define application info\n+        ApplicationDTO application = new ApplicationDTO();\n+        application.setName(\"jwtApp\");\n+        application.setTier(\"Unlimited\");\n+        application.setId((int) (Math.random() * 1000));\n+\n+        jwtTokenProd = getJWT(api, application, \"Unlimited\", TestConstant.KEY_TYPE_PRODUCTION, 3600);\n+        jwtTokenSand = getJWT(api, application, \"Unlimited\", TestConstant.KEY_TYPE_SANDBOX, 3600);\n+    }\n+\n+    @Test(description = \"Invoke Production and Sandbox endpoint when both endpoints provided\")\n+    public void invokeProdSandEndpoints() throws Exception {\n+        Map<String, String> prodHeaders = new HashMap<String, String>();\n+        prodHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse prodResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/pet/findByStatus\") , prodHeaders);\n+\n+        Assert.assertNotNull(prodResponse);\n+        Assert.assertEquals(prodResponse.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(prodResponse.getData(), ResponseConstants.RESPONSE_BODY,\n+                \"Response message mismatch.\");\n+\n+        Map<String, String> sandHeaders = new HashMap<String, String>();\n+        sandHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenSand);\n+        HttpResponse sandResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/pet/findByStatus\"), sandHeaders);\n+\n+        Assert.assertNotNull(sandResponse);\n+        Assert.assertEquals(sandResponse.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(sandResponse.getData(), ResponseConstants.API_SANDBOX_RESPONSE,\n+                \"Response message mismatch.\");\n+    }\n+\n+    @Test(description = \"Invoke Sandbox endpoint when sandbox endpoints provided alone\")\n+    public void invokeSandboxEndpointOnly() throws Exception {\n+        Map<String, String> sandHeaders = new HashMap<String, String>();\n+        sandHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenSand);\n+        HttpResponse sandResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/sand/pet/findByStatus\") , sandHeaders);\n+\n+        Assert.assertNotNull(sandResponse, \"Sandbox endpoint response should not be null\");\n+        Assert.assertEquals(sandResponse.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(sandResponse.getData(), ResponseConstants.API_SANDBOX_RESPONSE,\n+                \"Response message mismatch.\");\n+\n+        Map<String, String> prodHeaders = new HashMap<String, String>();\n+        prodHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse prodResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/sand/pet/findByStatus\") , prodHeaders);\n+\n+        Assert.assertNotNull(prodResponse, \"Production endoint response should not be null\");\n+        Assert.assertEquals(prodResponse.getResponseCode(), HttpStatus.SC_UNAUTHORIZED,\"Response code mismatched\");\n+    }\n+\n+    @Test(description = \"Invoke Production endpoint when production endpoints provided alone\")\n+    public void invokeProdEndpointOnly() throws Exception {\n+        Map<String, String> headers = new HashMap<String, String>();\n+        headers.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse response = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/prod/pet/findByStatus\") , headers);\n+\n+        Assert.assertNotNull(response, \"Production endpoint response should not be null\");\n+        Assert.assertEquals(response.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(response.getData(), ResponseConstants.RESPONSE_BODY,\n+                \"Response message mismatch.\");\n+\n+        Map<String, String> sandHeaders = new HashMap<String, String>();\n+        sandHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenSand);\n+        HttpResponse sandResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/prod/pet/findByStatus\"), sandHeaders);\n+\n+        Assert.assertNotNull(sandResponse, \"Sandbox endoint response should not be null\");\n+        Assert.assertEquals(sandResponse.getResponseCode(), HttpStatus.SC_UNAUTHORIZED,\"Response code mismatched\");\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQxNTkwMA==", "bodyText": "VerifyHostName is added via 5ccd375", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r552415900", "createdAt": "2021-01-06T07:42:33Z", "author": {"login": "VirajSalaka"}, "path": "test/test-integration/src/test/java/org/wso2am/micro/gw/tests/endpoints/ProductionSandboxTestCase.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2am.micro.gw.tests.endpoints;\n+\n+import com.github.dockerjava.zerodep.shaded.org.apache.hc.core5.http.HttpStatus;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import org.wso2am.micro.gw.tests.common.BaseTestCase;\n+import org.wso2am.micro.gw.tests.common.model.API;\n+import org.wso2am.micro.gw.tests.common.model.ApplicationDTO;\n+import org.wso2am.micro.gw.tests.util.ApiDeployment;\n+import org.wso2am.micro.gw.tests.util.ApiProjectGenerator;\n+import org.wso2am.micro.gw.tests.util.HttpResponse;\n+import org.wso2am.micro.gw.tests.util.HttpsClientRequest;\n+import org.wso2am.micro.gw.tests.util.TestConstant;\n+import org.wso2am.micro.gw.mockbackend.ResponseConstants;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class ProductionSandboxTestCase extends BaseTestCase {\n+    protected String jwtTokenProd;\n+    protected String jwtTokenSand;\n+\n+    @BeforeClass(description = \"initialise the setup\")\n+    void start() throws Exception {\n+        super.startMGW();\n+\n+        //deploy the api\n+        //api yaml file should put to the resources/apis/openApis folder\n+        String prodSandApiZipfile = ApiProjectGenerator.createApictlProjZip(\n+                \"prod-sand/prodSandOpenAPI.yaml\");\n+        String prodOnlyApiZipfile = ApiProjectGenerator.createApictlProjZip(\n+                \"prod-sand/prodOpenAPI.yaml\");\n+        String sandOnlyApiZipfile = ApiProjectGenerator.createApictlProjZip(\n+                \"prod-sand/sandOpenAPI.yaml\");\n+        ApiDeployment.deployAPI(prodSandApiZipfile);\n+        ApiDeployment.deployAPI(prodOnlyApiZipfile);\n+        ApiDeployment.deployAPI(sandOnlyApiZipfile);\n+\n+        //TODO: (VirajSalaka) change the token\n+        //generate JWT token from APIM\n+        API api = new API();\n+        api.setName(\"PetStoreAPI\");\n+        api.setContext(\"petstore/v1\");\n+        api.setProdEndpoint(getMockServiceURLHttp(\"/echo/prod\"));\n+        api.setVersion(\"1.0.0\");\n+        api.setProvider(\"admin\");\n+\n+        //Define application info\n+        ApplicationDTO application = new ApplicationDTO();\n+        application.setName(\"jwtApp\");\n+        application.setTier(\"Unlimited\");\n+        application.setId((int) (Math.random() * 1000));\n+\n+        jwtTokenProd = getJWT(api, application, \"Unlimited\", TestConstant.KEY_TYPE_PRODUCTION, 3600);\n+        jwtTokenSand = getJWT(api, application, \"Unlimited\", TestConstant.KEY_TYPE_SANDBOX, 3600);\n+    }\n+\n+    @Test(description = \"Invoke Production and Sandbox endpoint when both endpoints provided\")\n+    public void invokeProdSandEndpoints() throws Exception {\n+        Map<String, String> prodHeaders = new HashMap<String, String>();\n+        prodHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse prodResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/pet/findByStatus\") , prodHeaders);\n+\n+        Assert.assertNotNull(prodResponse);\n+        Assert.assertEquals(prodResponse.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(prodResponse.getData(), ResponseConstants.RESPONSE_BODY,\n+                \"Response message mismatch.\");\n+\n+        Map<String, String> sandHeaders = new HashMap<String, String>();\n+        sandHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenSand);\n+        HttpResponse sandResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/pet/findByStatus\"), sandHeaders);\n+\n+        Assert.assertNotNull(sandResponse);\n+        Assert.assertEquals(sandResponse.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(sandResponse.getData(), ResponseConstants.API_SANDBOX_RESPONSE,\n+                \"Response message mismatch.\");\n+    }\n+\n+    @Test(description = \"Invoke Sandbox endpoint when sandbox endpoints provided alone\")\n+    public void invokeSandboxEndpointOnly() throws Exception {\n+        Map<String, String> sandHeaders = new HashMap<String, String>();\n+        sandHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenSand);\n+        HttpResponse sandResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/sand/pet/findByStatus\") , sandHeaders);\n+\n+        Assert.assertNotNull(sandResponse, \"Sandbox endpoint response should not be null\");\n+        Assert.assertEquals(sandResponse.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(sandResponse.getData(), ResponseConstants.API_SANDBOX_RESPONSE,\n+                \"Response message mismatch.\");\n+\n+        Map<String, String> prodHeaders = new HashMap<String, String>();\n+        prodHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse prodResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/sand/pet/findByStatus\") , prodHeaders);\n+\n+        Assert.assertNotNull(prodResponse, \"Production endoint response should not be null\");\n+        Assert.assertEquals(prodResponse.getResponseCode(), HttpStatus.SC_UNAUTHORIZED,\"Response code mismatched\");\n+    }\n+\n+    @Test(description = \"Invoke Production endpoint when production endpoints provided alone\")\n+    public void invokeProdEndpointOnly() throws Exception {\n+        Map<String, String> headers = new HashMap<String, String>();\n+        headers.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse response = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/prod/pet/findByStatus\") , headers);\n+\n+        Assert.assertNotNull(response, \"Production endpoint response should not be null\");\n+        Assert.assertEquals(response.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(response.getData(), ResponseConstants.RESPONSE_BODY,\n+                \"Response message mismatch.\");\n+\n+        Map<String, String> sandHeaders = new HashMap<String, String>();\n+        sandHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenSand);\n+        HttpResponse sandResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/prod/pet/findByStatus\"), sandHeaders);\n+\n+        Assert.assertNotNull(sandResponse, \"Sandbox endoint response should not be null\");\n+        Assert.assertEquals(sandResponse.getResponseCode(), HttpStatus.SC_UNAUTHORIZED,\"Response code mismatched\");\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgyMTQyNg=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjY1NDU2MQ==", "bodyText": "Unsecure HTTPS Upstreams are added via c571daa", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r552654561", "createdAt": "2021-01-06T14:19:12Z", "author": {"login": "VirajSalaka"}, "path": "test/test-integration/src/test/java/org/wso2am/micro/gw/tests/endpoints/ProductionSandboxTestCase.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2am.micro.gw.tests.endpoints;\n+\n+import com.github.dockerjava.zerodep.shaded.org.apache.hc.core5.http.HttpStatus;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import org.wso2am.micro.gw.tests.common.BaseTestCase;\n+import org.wso2am.micro.gw.tests.common.model.API;\n+import org.wso2am.micro.gw.tests.common.model.ApplicationDTO;\n+import org.wso2am.micro.gw.tests.util.ApiDeployment;\n+import org.wso2am.micro.gw.tests.util.ApiProjectGenerator;\n+import org.wso2am.micro.gw.tests.util.HttpResponse;\n+import org.wso2am.micro.gw.tests.util.HttpsClientRequest;\n+import org.wso2am.micro.gw.tests.util.TestConstant;\n+import org.wso2am.micro.gw.mockbackend.ResponseConstants;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class ProductionSandboxTestCase extends BaseTestCase {\n+    protected String jwtTokenProd;\n+    protected String jwtTokenSand;\n+\n+    @BeforeClass(description = \"initialise the setup\")\n+    void start() throws Exception {\n+        super.startMGW();\n+\n+        //deploy the api\n+        //api yaml file should put to the resources/apis/openApis folder\n+        String prodSandApiZipfile = ApiProjectGenerator.createApictlProjZip(\n+                \"prod-sand/prodSandOpenAPI.yaml\");\n+        String prodOnlyApiZipfile = ApiProjectGenerator.createApictlProjZip(\n+                \"prod-sand/prodOpenAPI.yaml\");\n+        String sandOnlyApiZipfile = ApiProjectGenerator.createApictlProjZip(\n+                \"prod-sand/sandOpenAPI.yaml\");\n+        ApiDeployment.deployAPI(prodSandApiZipfile);\n+        ApiDeployment.deployAPI(prodOnlyApiZipfile);\n+        ApiDeployment.deployAPI(sandOnlyApiZipfile);\n+\n+        //TODO: (VirajSalaka) change the token\n+        //generate JWT token from APIM\n+        API api = new API();\n+        api.setName(\"PetStoreAPI\");\n+        api.setContext(\"petstore/v1\");\n+        api.setProdEndpoint(getMockServiceURLHttp(\"/echo/prod\"));\n+        api.setVersion(\"1.0.0\");\n+        api.setProvider(\"admin\");\n+\n+        //Define application info\n+        ApplicationDTO application = new ApplicationDTO();\n+        application.setName(\"jwtApp\");\n+        application.setTier(\"Unlimited\");\n+        application.setId((int) (Math.random() * 1000));\n+\n+        jwtTokenProd = getJWT(api, application, \"Unlimited\", TestConstant.KEY_TYPE_PRODUCTION, 3600);\n+        jwtTokenSand = getJWT(api, application, \"Unlimited\", TestConstant.KEY_TYPE_SANDBOX, 3600);\n+    }\n+\n+    @Test(description = \"Invoke Production and Sandbox endpoint when both endpoints provided\")\n+    public void invokeProdSandEndpoints() throws Exception {\n+        Map<String, String> prodHeaders = new HashMap<String, String>();\n+        prodHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse prodResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/pet/findByStatus\") , prodHeaders);\n+\n+        Assert.assertNotNull(prodResponse);\n+        Assert.assertEquals(prodResponse.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(prodResponse.getData(), ResponseConstants.RESPONSE_BODY,\n+                \"Response message mismatch.\");\n+\n+        Map<String, String> sandHeaders = new HashMap<String, String>();\n+        sandHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenSand);\n+        HttpResponse sandResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/pet/findByStatus\"), sandHeaders);\n+\n+        Assert.assertNotNull(sandResponse);\n+        Assert.assertEquals(sandResponse.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(sandResponse.getData(), ResponseConstants.API_SANDBOX_RESPONSE,\n+                \"Response message mismatch.\");\n+    }\n+\n+    @Test(description = \"Invoke Sandbox endpoint when sandbox endpoints provided alone\")\n+    public void invokeSandboxEndpointOnly() throws Exception {\n+        Map<String, String> sandHeaders = new HashMap<String, String>();\n+        sandHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenSand);\n+        HttpResponse sandResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/sand/pet/findByStatus\") , sandHeaders);\n+\n+        Assert.assertNotNull(sandResponse, \"Sandbox endpoint response should not be null\");\n+        Assert.assertEquals(sandResponse.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(sandResponse.getData(), ResponseConstants.API_SANDBOX_RESPONSE,\n+                \"Response message mismatch.\");\n+\n+        Map<String, String> prodHeaders = new HashMap<String, String>();\n+        prodHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse prodResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/sand/pet/findByStatus\") , prodHeaders);\n+\n+        Assert.assertNotNull(prodResponse, \"Production endoint response should not be null\");\n+        Assert.assertEquals(prodResponse.getResponseCode(), HttpStatus.SC_UNAUTHORIZED,\"Response code mismatched\");\n+    }\n+\n+    @Test(description = \"Invoke Production endpoint when production endpoints provided alone\")\n+    public void invokeProdEndpointOnly() throws Exception {\n+        Map<String, String> headers = new HashMap<String, String>();\n+        headers.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse response = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/prod/pet/findByStatus\") , headers);\n+\n+        Assert.assertNotNull(response, \"Production endpoint response should not be null\");\n+        Assert.assertEquals(response.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(response.getData(), ResponseConstants.RESPONSE_BODY,\n+                \"Response message mismatch.\");\n+\n+        Map<String, String> sandHeaders = new HashMap<String, String>();\n+        sandHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenSand);\n+        HttpResponse sandResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/prod/pet/findByStatus\"), sandHeaders);\n+\n+        Assert.assertNotNull(sandResponse, \"Sandbox endoint response should not be null\");\n+        Assert.assertEquals(sandResponse.getResponseCode(), HttpStatus.SC_UNAUTHORIZED,\"Response code mismatched\");\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgyMTQyNg=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzExNzUyOA==", "bodyText": "Created a separate issue to keep track of Prod only/ sand only gateways : #1535", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r553117528", "createdAt": "2021-01-07T05:31:48Z", "author": {"login": "VirajSalaka"}, "path": "test/test-integration/src/test/java/org/wso2am/micro/gw/tests/endpoints/ProductionSandboxTestCase.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2am.micro.gw.tests.endpoints;\n+\n+import com.github.dockerjava.zerodep.shaded.org.apache.hc.core5.http.HttpStatus;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import org.wso2am.micro.gw.tests.common.BaseTestCase;\n+import org.wso2am.micro.gw.tests.common.model.API;\n+import org.wso2am.micro.gw.tests.common.model.ApplicationDTO;\n+import org.wso2am.micro.gw.tests.util.ApiDeployment;\n+import org.wso2am.micro.gw.tests.util.ApiProjectGenerator;\n+import org.wso2am.micro.gw.tests.util.HttpResponse;\n+import org.wso2am.micro.gw.tests.util.HttpsClientRequest;\n+import org.wso2am.micro.gw.tests.util.TestConstant;\n+import org.wso2am.micro.gw.mockbackend.ResponseConstants;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class ProductionSandboxTestCase extends BaseTestCase {\n+    protected String jwtTokenProd;\n+    protected String jwtTokenSand;\n+\n+    @BeforeClass(description = \"initialise the setup\")\n+    void start() throws Exception {\n+        super.startMGW();\n+\n+        //deploy the api\n+        //api yaml file should put to the resources/apis/openApis folder\n+        String prodSandApiZipfile = ApiProjectGenerator.createApictlProjZip(\n+                \"prod-sand/prodSandOpenAPI.yaml\");\n+        String prodOnlyApiZipfile = ApiProjectGenerator.createApictlProjZip(\n+                \"prod-sand/prodOpenAPI.yaml\");\n+        String sandOnlyApiZipfile = ApiProjectGenerator.createApictlProjZip(\n+                \"prod-sand/sandOpenAPI.yaml\");\n+        ApiDeployment.deployAPI(prodSandApiZipfile);\n+        ApiDeployment.deployAPI(prodOnlyApiZipfile);\n+        ApiDeployment.deployAPI(sandOnlyApiZipfile);\n+\n+        //TODO: (VirajSalaka) change the token\n+        //generate JWT token from APIM\n+        API api = new API();\n+        api.setName(\"PetStoreAPI\");\n+        api.setContext(\"petstore/v1\");\n+        api.setProdEndpoint(getMockServiceURLHttp(\"/echo/prod\"));\n+        api.setVersion(\"1.0.0\");\n+        api.setProvider(\"admin\");\n+\n+        //Define application info\n+        ApplicationDTO application = new ApplicationDTO();\n+        application.setName(\"jwtApp\");\n+        application.setTier(\"Unlimited\");\n+        application.setId((int) (Math.random() * 1000));\n+\n+        jwtTokenProd = getJWT(api, application, \"Unlimited\", TestConstant.KEY_TYPE_PRODUCTION, 3600);\n+        jwtTokenSand = getJWT(api, application, \"Unlimited\", TestConstant.KEY_TYPE_SANDBOX, 3600);\n+    }\n+\n+    @Test(description = \"Invoke Production and Sandbox endpoint when both endpoints provided\")\n+    public void invokeProdSandEndpoints() throws Exception {\n+        Map<String, String> prodHeaders = new HashMap<String, String>();\n+        prodHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse prodResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/pet/findByStatus\") , prodHeaders);\n+\n+        Assert.assertNotNull(prodResponse);\n+        Assert.assertEquals(prodResponse.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(prodResponse.getData(), ResponseConstants.RESPONSE_BODY,\n+                \"Response message mismatch.\");\n+\n+        Map<String, String> sandHeaders = new HashMap<String, String>();\n+        sandHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenSand);\n+        HttpResponse sandResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/pet/findByStatus\"), sandHeaders);\n+\n+        Assert.assertNotNull(sandResponse);\n+        Assert.assertEquals(sandResponse.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(sandResponse.getData(), ResponseConstants.API_SANDBOX_RESPONSE,\n+                \"Response message mismatch.\");\n+    }\n+\n+    @Test(description = \"Invoke Sandbox endpoint when sandbox endpoints provided alone\")\n+    public void invokeSandboxEndpointOnly() throws Exception {\n+        Map<String, String> sandHeaders = new HashMap<String, String>();\n+        sandHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenSand);\n+        HttpResponse sandResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/sand/pet/findByStatus\") , sandHeaders);\n+\n+        Assert.assertNotNull(sandResponse, \"Sandbox endpoint response should not be null\");\n+        Assert.assertEquals(sandResponse.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(sandResponse.getData(), ResponseConstants.API_SANDBOX_RESPONSE,\n+                \"Response message mismatch.\");\n+\n+        Map<String, String> prodHeaders = new HashMap<String, String>();\n+        prodHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse prodResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/sand/pet/findByStatus\") , prodHeaders);\n+\n+        Assert.assertNotNull(prodResponse, \"Production endoint response should not be null\");\n+        Assert.assertEquals(prodResponse.getResponseCode(), HttpStatus.SC_UNAUTHORIZED,\"Response code mismatched\");\n+    }\n+\n+    @Test(description = \"Invoke Production endpoint when production endpoints provided alone\")\n+    public void invokeProdEndpointOnly() throws Exception {\n+        Map<String, String> headers = new HashMap<String, String>();\n+        headers.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse response = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/prod/pet/findByStatus\") , headers);\n+\n+        Assert.assertNotNull(response, \"Production endpoint response should not be null\");\n+        Assert.assertEquals(response.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(response.getData(), ResponseConstants.RESPONSE_BODY,\n+                \"Response message mismatch.\");\n+\n+        Map<String, String> sandHeaders = new HashMap<String, String>();\n+        sandHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenSand);\n+        HttpResponse sandResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/prod/pet/findByStatus\"), sandHeaders);\n+\n+        Assert.assertNotNull(sandResponse, \"Sandbox endoint response should not be null\");\n+        Assert.assertEquals(sandResponse.getResponseCode(), HttpStatus.SC_UNAUTHORIZED,\"Response code mismatched\");\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgyMTQyNg=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE0NDc1MQ==", "bodyText": "change verifyhostname string to regex based one rather than exact match.", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r553144751", "createdAt": "2021-01-07T07:06:56Z", "author": {"login": "VirajSalaka"}, "path": "test/test-integration/src/test/java/org/wso2am/micro/gw/tests/endpoints/ProductionSandboxTestCase.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2am.micro.gw.tests.endpoints;\n+\n+import com.github.dockerjava.zerodep.shaded.org.apache.hc.core5.http.HttpStatus;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import org.wso2am.micro.gw.tests.common.BaseTestCase;\n+import org.wso2am.micro.gw.tests.common.model.API;\n+import org.wso2am.micro.gw.tests.common.model.ApplicationDTO;\n+import org.wso2am.micro.gw.tests.util.ApiDeployment;\n+import org.wso2am.micro.gw.tests.util.ApiProjectGenerator;\n+import org.wso2am.micro.gw.tests.util.HttpResponse;\n+import org.wso2am.micro.gw.tests.util.HttpsClientRequest;\n+import org.wso2am.micro.gw.tests.util.TestConstant;\n+import org.wso2am.micro.gw.mockbackend.ResponseConstants;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class ProductionSandboxTestCase extends BaseTestCase {\n+    protected String jwtTokenProd;\n+    protected String jwtTokenSand;\n+\n+    @BeforeClass(description = \"initialise the setup\")\n+    void start() throws Exception {\n+        super.startMGW();\n+\n+        //deploy the api\n+        //api yaml file should put to the resources/apis/openApis folder\n+        String prodSandApiZipfile = ApiProjectGenerator.createApictlProjZip(\n+                \"prod-sand/prodSandOpenAPI.yaml\");\n+        String prodOnlyApiZipfile = ApiProjectGenerator.createApictlProjZip(\n+                \"prod-sand/prodOpenAPI.yaml\");\n+        String sandOnlyApiZipfile = ApiProjectGenerator.createApictlProjZip(\n+                \"prod-sand/sandOpenAPI.yaml\");\n+        ApiDeployment.deployAPI(prodSandApiZipfile);\n+        ApiDeployment.deployAPI(prodOnlyApiZipfile);\n+        ApiDeployment.deployAPI(sandOnlyApiZipfile);\n+\n+        //TODO: (VirajSalaka) change the token\n+        //generate JWT token from APIM\n+        API api = new API();\n+        api.setName(\"PetStoreAPI\");\n+        api.setContext(\"petstore/v1\");\n+        api.setProdEndpoint(getMockServiceURLHttp(\"/echo/prod\"));\n+        api.setVersion(\"1.0.0\");\n+        api.setProvider(\"admin\");\n+\n+        //Define application info\n+        ApplicationDTO application = new ApplicationDTO();\n+        application.setName(\"jwtApp\");\n+        application.setTier(\"Unlimited\");\n+        application.setId((int) (Math.random() * 1000));\n+\n+        jwtTokenProd = getJWT(api, application, \"Unlimited\", TestConstant.KEY_TYPE_PRODUCTION, 3600);\n+        jwtTokenSand = getJWT(api, application, \"Unlimited\", TestConstant.KEY_TYPE_SANDBOX, 3600);\n+    }\n+\n+    @Test(description = \"Invoke Production and Sandbox endpoint when both endpoints provided\")\n+    public void invokeProdSandEndpoints() throws Exception {\n+        Map<String, String> prodHeaders = new HashMap<String, String>();\n+        prodHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse prodResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/pet/findByStatus\") , prodHeaders);\n+\n+        Assert.assertNotNull(prodResponse);\n+        Assert.assertEquals(prodResponse.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(prodResponse.getData(), ResponseConstants.RESPONSE_BODY,\n+                \"Response message mismatch.\");\n+\n+        Map<String, String> sandHeaders = new HashMap<String, String>();\n+        sandHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenSand);\n+        HttpResponse sandResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/pet/findByStatus\"), sandHeaders);\n+\n+        Assert.assertNotNull(sandResponse);\n+        Assert.assertEquals(sandResponse.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(sandResponse.getData(), ResponseConstants.API_SANDBOX_RESPONSE,\n+                \"Response message mismatch.\");\n+    }\n+\n+    @Test(description = \"Invoke Sandbox endpoint when sandbox endpoints provided alone\")\n+    public void invokeSandboxEndpointOnly() throws Exception {\n+        Map<String, String> sandHeaders = new HashMap<String, String>();\n+        sandHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenSand);\n+        HttpResponse sandResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/sand/pet/findByStatus\") , sandHeaders);\n+\n+        Assert.assertNotNull(sandResponse, \"Sandbox endpoint response should not be null\");\n+        Assert.assertEquals(sandResponse.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(sandResponse.getData(), ResponseConstants.API_SANDBOX_RESPONSE,\n+                \"Response message mismatch.\");\n+\n+        Map<String, String> prodHeaders = new HashMap<String, String>();\n+        prodHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse prodResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/sand/pet/findByStatus\") , prodHeaders);\n+\n+        Assert.assertNotNull(prodResponse, \"Production endoint response should not be null\");\n+        Assert.assertEquals(prodResponse.getResponseCode(), HttpStatus.SC_UNAUTHORIZED,\"Response code mismatched\");\n+    }\n+\n+    @Test(description = \"Invoke Production endpoint when production endpoints provided alone\")\n+    public void invokeProdEndpointOnly() throws Exception {\n+        Map<String, String> headers = new HashMap<String, String>();\n+        headers.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse response = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/prod/pet/findByStatus\") , headers);\n+\n+        Assert.assertNotNull(response, \"Production endpoint response should not be null\");\n+        Assert.assertEquals(response.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(response.getData(), ResponseConstants.RESPONSE_BODY,\n+                \"Response message mismatch.\");\n+\n+        Map<String, String> sandHeaders = new HashMap<String, String>();\n+        sandHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenSand);\n+        HttpResponse sandResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/prod/pet/findByStatus\"), sandHeaders);\n+\n+        Assert.assertNotNull(sandResponse, \"Sandbox endoint response should not be null\");\n+        Assert.assertEquals(sandResponse.getResponseCode(), HttpStatus.SC_UNAUTHORIZED,\"Response code mismatched\");\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgyMTQyNg=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU3Mzc0OQ==", "bodyText": "https://www.envoyproxy.io/docs/envoy/v1.16.2/api-v3/extensions/transport_sockets/tls/v3/common.proto#extensions-transport-sockets-tls-v3-certificatevalidationcontext\nThe wildcard SAN is accepted when using exact keyword\nSAN : *.test.com\nHOST: abc.test.com (exact match) works\nTested and verified.", "url": "https://github.com/wso2/product-microgateway/pull/1525#discussion_r553573749", "createdAt": "2021-01-07T20:35:42Z", "author": {"login": "VirajSalaka"}, "path": "test/test-integration/src/test/java/org/wso2am/micro/gw/tests/endpoints/ProductionSandboxTestCase.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2am.micro.gw.tests.endpoints;\n+\n+import com.github.dockerjava.zerodep.shaded.org.apache.hc.core5.http.HttpStatus;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import org.wso2am.micro.gw.tests.common.BaseTestCase;\n+import org.wso2am.micro.gw.tests.common.model.API;\n+import org.wso2am.micro.gw.tests.common.model.ApplicationDTO;\n+import org.wso2am.micro.gw.tests.util.ApiDeployment;\n+import org.wso2am.micro.gw.tests.util.ApiProjectGenerator;\n+import org.wso2am.micro.gw.tests.util.HttpResponse;\n+import org.wso2am.micro.gw.tests.util.HttpsClientRequest;\n+import org.wso2am.micro.gw.tests.util.TestConstant;\n+import org.wso2am.micro.gw.mockbackend.ResponseConstants;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class ProductionSandboxTestCase extends BaseTestCase {\n+    protected String jwtTokenProd;\n+    protected String jwtTokenSand;\n+\n+    @BeforeClass(description = \"initialise the setup\")\n+    void start() throws Exception {\n+        super.startMGW();\n+\n+        //deploy the api\n+        //api yaml file should put to the resources/apis/openApis folder\n+        String prodSandApiZipfile = ApiProjectGenerator.createApictlProjZip(\n+                \"prod-sand/prodSandOpenAPI.yaml\");\n+        String prodOnlyApiZipfile = ApiProjectGenerator.createApictlProjZip(\n+                \"prod-sand/prodOpenAPI.yaml\");\n+        String sandOnlyApiZipfile = ApiProjectGenerator.createApictlProjZip(\n+                \"prod-sand/sandOpenAPI.yaml\");\n+        ApiDeployment.deployAPI(prodSandApiZipfile);\n+        ApiDeployment.deployAPI(prodOnlyApiZipfile);\n+        ApiDeployment.deployAPI(sandOnlyApiZipfile);\n+\n+        //TODO: (VirajSalaka) change the token\n+        //generate JWT token from APIM\n+        API api = new API();\n+        api.setName(\"PetStoreAPI\");\n+        api.setContext(\"petstore/v1\");\n+        api.setProdEndpoint(getMockServiceURLHttp(\"/echo/prod\"));\n+        api.setVersion(\"1.0.0\");\n+        api.setProvider(\"admin\");\n+\n+        //Define application info\n+        ApplicationDTO application = new ApplicationDTO();\n+        application.setName(\"jwtApp\");\n+        application.setTier(\"Unlimited\");\n+        application.setId((int) (Math.random() * 1000));\n+\n+        jwtTokenProd = getJWT(api, application, \"Unlimited\", TestConstant.KEY_TYPE_PRODUCTION, 3600);\n+        jwtTokenSand = getJWT(api, application, \"Unlimited\", TestConstant.KEY_TYPE_SANDBOX, 3600);\n+    }\n+\n+    @Test(description = \"Invoke Production and Sandbox endpoint when both endpoints provided\")\n+    public void invokeProdSandEndpoints() throws Exception {\n+        Map<String, String> prodHeaders = new HashMap<String, String>();\n+        prodHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse prodResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/pet/findByStatus\") , prodHeaders);\n+\n+        Assert.assertNotNull(prodResponse);\n+        Assert.assertEquals(prodResponse.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(prodResponse.getData(), ResponseConstants.RESPONSE_BODY,\n+                \"Response message mismatch.\");\n+\n+        Map<String, String> sandHeaders = new HashMap<String, String>();\n+        sandHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenSand);\n+        HttpResponse sandResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/pet/findByStatus\"), sandHeaders);\n+\n+        Assert.assertNotNull(sandResponse);\n+        Assert.assertEquals(sandResponse.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(sandResponse.getData(), ResponseConstants.API_SANDBOX_RESPONSE,\n+                \"Response message mismatch.\");\n+    }\n+\n+    @Test(description = \"Invoke Sandbox endpoint when sandbox endpoints provided alone\")\n+    public void invokeSandboxEndpointOnly() throws Exception {\n+        Map<String, String> sandHeaders = new HashMap<String, String>();\n+        sandHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenSand);\n+        HttpResponse sandResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/sand/pet/findByStatus\") , sandHeaders);\n+\n+        Assert.assertNotNull(sandResponse, \"Sandbox endpoint response should not be null\");\n+        Assert.assertEquals(sandResponse.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(sandResponse.getData(), ResponseConstants.API_SANDBOX_RESPONSE,\n+                \"Response message mismatch.\");\n+\n+        Map<String, String> prodHeaders = new HashMap<String, String>();\n+        prodHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse prodResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/sand/pet/findByStatus\") , prodHeaders);\n+\n+        Assert.assertNotNull(prodResponse, \"Production endoint response should not be null\");\n+        Assert.assertEquals(prodResponse.getResponseCode(), HttpStatus.SC_UNAUTHORIZED,\"Response code mismatched\");\n+    }\n+\n+    @Test(description = \"Invoke Production endpoint when production endpoints provided alone\")\n+    public void invokeProdEndpointOnly() throws Exception {\n+        Map<String, String> headers = new HashMap<String, String>();\n+        headers.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse response = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/prod/pet/findByStatus\") , headers);\n+\n+        Assert.assertNotNull(response, \"Production endpoint response should not be null\");\n+        Assert.assertEquals(response.getResponseCode(), HttpStatus.SC_OK,\"Response code mismatched\");\n+        Assert.assertEquals(response.getData(), ResponseConstants.RESPONSE_BODY,\n+                \"Response message mismatch.\");\n+\n+        Map<String, String> sandHeaders = new HashMap<String, String>();\n+        sandHeaders.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenSand);\n+        HttpResponse sandResponse = HttpsClientRequest.doGet(getServiceURLHttps(\n+                \"/v2/prod/pet/findByStatus\"), sandHeaders);\n+\n+        Assert.assertNotNull(sandResponse, \"Sandbox endoint response should not be null\");\n+        Assert.assertEquals(sandResponse.getResponseCode(), HttpStatus.SC_UNAUTHORIZED,\"Response code mismatched\");\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgyMTQyNg=="}, "originalCommit": {"oid": "71ab8d74e1eafe168bcc80899b931405ad98eabe"}, "originalPosition": 143}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1183, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}