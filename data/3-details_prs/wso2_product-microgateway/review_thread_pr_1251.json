{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1NDE5NjY0", "number": 1251, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNDo1NjoyOFrOEBPrMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxNjo0MjoyMVrOFYexSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzQwODQ5OnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/jwtgenerator/MGWJWTGeneratorInvoker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNDo1NjoyOFrOGc-u9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNDo1NjoyOFrOGc-u9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA0MTE0Mg==", "bodyText": "Package name should be jwt.generator", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r433041142", "createdAt": "2020-06-01T04:56:28Z", "author": {"login": "Rajith90"}, "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/jwtgenerator/MGWJWTGeneratorInvoker.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.wso2.micro.gateway.core.jwtgenerator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7233309ef1528e1f0ea5668fc4de6f3dcdf11bd5"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzQxMjA4OnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/utils/utils.bal", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNDo1OTo0NlrOGc-xVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNDo1OTo0NlrOGc-xVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA0MTc0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (timestampSkew == -1) {\n          \n          \n            \n                if (timestampSkew == DEFAULT_SERVER_TIMESTAMP_SKEW) {", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r433041748", "createdAt": "2020-06-01T04:59:46Z", "author": {"login": "Rajith90"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/utils/utils.bal", "diffHunk": "@@ -126,7 +126,13 @@ public function isAccessTokenExpired(APIKeyValidationDto apiKeyValidationDto) re\n     if (issueTime is string) {\n         issuedTime = 'int:fromString(issueTime);\n     }\n-    int timestampSkew = getConfigIntValue(KM_CONF_INSTANCE_ID, TIMESTAMP_SKEW, DEFAULT_TIMESTAMP_SKEW);\n+\n+    // provide backward compatibility for skew time\n+    int timestampSkew = getConfigIntValue(SERVER_CONF_ID, SERVER_TIMESTAMP_SKEW, DEFAULT_SERVER_TIMESTAMP_SKEW);\n+    if (timestampSkew == -1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7233309ef1528e1f0ea5668fc4de6f3dcdf11bd5"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzQxMjUxOnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/jwt_auth_handler.bal", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNTowMDowNFrOGc-xmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNTowMDowNFrOGc-xmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA0MTgxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (self.skewTime == -1) {\n          \n          \n            \n                        if (self.skewTime == DEFAULT_SERVER_TIMESTAMP_SKEW) {", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r433041816", "createdAt": "2020-06-01T05:00:04Z", "author": {"login": "Rajith90"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/jwt_auth_handler.bal", "diffHunk": "@@ -27,8 +27,97 @@ public type JWTAuthHandler object {\n \n     public JwtAuthProvider jwtAuthProvider;\n \n+    private boolean enabledJWTGenerator = false;\n+    private boolean classLoaded = false;\n+    private string generatorClass = \"\";\n+    private string dialectURI = \"\";\n+    private string signatureAlgorithm = \"\";\n+    private string certificateAlias = \"\";\n+    private string privateKeyAlias = \"\";\n+    private int tokenExpiry = 0;\n+    private any[] restrictedClaims = [];\n+    private string keyStoreLocationUnresolved = \"\";\n+    private string keyStorePassword = \"\";\n+    private string tokenIssuer = \"\";\n+    private any[] tokenAudience = [];\n+    private int skewTime = 0;\n+    private boolean enabledCaching = false;\n+    private int cacheExpiry = 0;\n+\n     public function __init(JwtAuthProvider jwtAuthProvider) {\n         self.jwtAuthProvider = jwtAuthProvider;\n+        // initiating generator class if enabled\n+        self.enabledJWTGenerator = getConfigBooleanValue(JWT_GENERATOR_ID,\n+                                                            JWT_GENERATOR_ENABLED,\n+                                                            DEFAULT_JWT_GENERATOR_ENABLED);\n+        if (self.enabledJWTGenerator) {\n+            self.generatorClass = getConfigValue(JWT_GENERATOR_ID,\n+                                                    JWT_GENERATOR_IMPLEMENTATION,\n+                                                    DEFAULT_JWT_GENERATOR_IMPLEMENTATION);\n+            self.dialectURI = getConfigValue(JWT_GENERATOR_ID,\n+                                                JWT_GENERATOR_DIALECT,\n+                                                DEFAULT_JWT_GENERATOR_DIALECT);\n+            self.signatureAlgorithm = getConfigValue(JWT_GENERATOR_ID,\n+                                                        JWT_GENERATOR_SIGN_ALGO,\n+                                                        DEFAULT_JWT_GENERATOR_SIGN_ALGO);\n+            self.certificateAlias = getConfigValue(JWT_GENERATOR_ID,\n+                                                        JWT_GENERATOR_CERTIFICATE_ALIAS,\n+                                                        DEFAULT_JWT_GENERATOR_CERTIFICATE_ALIAS);\n+            self.privateKeyAlias = getConfigValue(JWT_GENERATOR_ID,\n+                                                    JWT_GENERATOR_PRIVATE_KEY_ALIAS,\n+                                                    DEFAULT_JWT_GENERATOR_PRIVATE_KEY_ALIAS);\n+            self.tokenExpiry = getConfigIntValue(JWT_GENERATOR_ID,\n+                                                    JWT_GENERATOR_TOKEN_EXPIRY,\n+                                                    DEFAULT_JWT_GENERATOR_TOKEN_EXPIRY);\n+            self.restrictedClaims = getConfigArrayValue(JWT_GENERATOR_ID,\n+                                                        JWT_GENERATOR_RESTRICTED_CLAIMS);\n+            self.keyStoreLocationUnresolved = getConfigValue(LISTENER_CONF_INSTANCE_ID,\n+                                                                KEY_STORE_PATH,\n+                                                                DEFAULT_KEY_STORE_PATH);\n+            self.keyStorePassword = getConfigValue(LISTENER_CONF_INSTANCE_ID,\n+                                                                    KEY_STORE_PASSWORD,\n+                                                                    DEFAULT_KEY_STORE_PASSWORD);\n+            self.tokenIssuer = getConfigValue(JWT_GENERATOR_ID,\n+                                                JWT_GENERATOR_TOKEN_ISSUER,\n+                                                DEFAULT_JWT_GENERATOR_TOKEN_ISSUER);\n+            self.tokenAudience = getConfigArrayValue(JWT_GENERATOR_ID,\n+                                                        JWT_GENERATOR_TOKEN_AUDIENCE);\n+            // provide backward compatibility for skew time\n+            self.skewTime = getConfigIntValue(SERVER_CONF_ID, \n+                                                SERVER_TIMESTAMP_SKEW, \n+                                                DEFAULT_SERVER_TIMESTAMP_SKEW);\n+            if (self.skewTime == -1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7233309ef1528e1f0ea5668fc4de6f3dcdf11bd5"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzYxNzE2OnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/constants/micro_gw_conf_defaults.bal", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzowMjowNFrOGdAsIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzowMjowNFrOGdAsIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3MzE4Nw==", "bodyText": "we may able to use the above cache default variables for here as well.\nDEFAULT_TOKEN_CACHE_EXPIRY, DEFAULT_TOKEN_CACHE_CAPACITY, DEFAULT_TOKEN_CACHE_EVICTION_FACTOR, etc...", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r433073187", "createdAt": "2020-06-01T07:02:04Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/constants/micro_gw_conf_defaults.bal", "diffHunk": "@@ -121,3 +121,19 @@ public const boolean DEFAULT_VALIDATE_APIS_ENABLED = false;\n \n public const boolean DEFAULT_API_KEY_ISSUER_ENABLED = true;\n public const int DEFAULT_API_KEY_VALIDITY_TIME = -1;\n+\n+public const boolean DEFAULT_JWT_GENERATOR_ENABLED = false;\n+public const string DEFAULT_JWT_GENERATOR_DIALECT = \"http://wso2.org/claims\";\n+public const string DEFAULT_JWT_GENERATOR_SIGN_ALGO = \"SHA256withRSA\";\n+public const string DEFAULT_JWT_GENERATOR_CERTIFICATE_ALIAS = \"ballerina\";\n+public const string DEFAULT_JWT_GENERATOR_PRIVATE_KEY_ALIAS = \"ballerina\";\n+public const int DEFAULT_JWT_GENERATOR_TOKEN_EXPIRY = 900000;\n+public const string DEFAULT_JWT_GENERATOR_TOKEN_ISSUER = \"wso2.org/products/am\";\n+public const string DEFAULT_JWT_GENERATOR_IMPLEMENTATION = \"org.wso2.micro.gateway.core.jwt.generator.MGWJWTGeneratorImpl\";\n+\n+public const boolean DEFAULT_JWT_GENERATOR_TOKEN_CACHE_ENABLED = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e37528d19b38718e0809243a244128df2b82485"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzYxODExOnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/api_gateway_cache.bal", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzowMjozMVrOGdAsqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzowMjozMVrOGdAsqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3MzMyMw==", "bodyText": "it's better to limit the line length to 120 characters", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r433073323", "createdAt": "2020-06-01T07:02:31Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/api_gateway_cache.bal", "diffHunk": "@@ -20,14 +20,18 @@ import ballerina/cache;\n int cacheExpiryTime = getConfigIntValue(CACHING_ID, TOKEN_CACHE_EXPIRY, DEFAULT_TOKEN_CACHE_EXPIRY);\n int cacheSize = getConfigIntValue(CACHING_ID, TOKEN_CACHE_CAPACITY, DEFAULT_TOKEN_CACHE_CAPACITY);\n float evictionFactor = getConfigFloatValue(CACHING_ID, TOKEN_CACHE_EVICTION_FACTOR, DEFAULT_TOKEN_CACHE_EVICTION_FACTOR);\n+int jwtGeneratorCacheExpiryTime = getConfigIntValue(JWT_GENERATOR_CACHING_ID, JWT_GENERATOR_TOKEN_CACHE_EXPIRY, DEFAULT_JWT_GENERATOR_TOKEN_CACHE_EXPIRY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e37528d19b38718e0809243a244128df2b82485"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzY0MjY0OnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/jwt_auth_handler.bal", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzoxMzo1NVrOGdA7Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDoyNDoxNFrOGdFuhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NzAyMg==", "bodyText": "I remember this code is duplicated in a similar util method too. If so, can we check whether to combine them?", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r433077022", "createdAt": "2020-06-01T07:13:55Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/jwt_auth_handler.bal", "diffHunk": "@@ -62,22 +151,193 @@ public type JWTAuthHandler object {\n         string credential = headerValue.substring(6, headerValue.length()).trim();\n         var authenticationResult = self.jwtAuthProvider.authenticate(credential);\n         if (authenticationResult is boolean) {\n-            setBackendJwtHeader(credential, req);\n+            boolean generationStatus = generateAndSetBackendJwtHeader(credential,\n+                                                                        req,\n+                                                                        self.enabledJWTGenerator,\n+                                                                        self.classLoaded,\n+                                                                        self.skewTime,\n+                                                                        self.enabledCaching);\n+            if (!generationStatus) {\n+                printError(KEY_JWT_AUTH_PROVIDER, \"JWT Generation failed\");\n+            }\n             return authenticationResult;\n         } else {\n             return prepareAuthenticationError(\"Failed to authenticate with jwt bearer auth handler.\", authenticationResult);\n         }\n     }\n+\n };\n \n-public function setBackendJwtHeader(string credential, http:Request req) {\n-    (jwt:JwtPayload | error) payload = getDecodedJWTPayload(credential);\n-    if (payload is jwt:JwtPayload) {\n-        map<json>? customClaims = payload?.customClaims;\n-        // validate backend jwt claim and set it to jwt header\n-        if (customClaims is map<json> && customClaims.hasKey(BACKEND_JWT)) {\n-            printDebug(KEY_JWT_AUTH_PROVIDER, \"Set backend jwt header.\");\n-            req.setHeader(jwtheaderName, customClaims.get(BACKEND_JWT).toString());\n+# Identify the api details from the subscribed apis in the authentication token.\n+#\n+# + payload - The payload of the authentication token\n+# + apiName - name of the current API\n+# + apiVersion - version of the current API\n+# + return - Returns map<string> with the extracted details.\n+public function getAPIDetails(jwt:JwtPayload payload, string apiName, string apiVersion) returns map<string> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e37528d19b38718e0809243a244128df2b82485"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEwMjI3OA==", "bodyText": "@AmaliMatharaarachchi yes. In subscription validation what it does is, it adds some of the details to the auth context. but some of them are not added. I didn't changed it since I have to change the auth context record.", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r433102278", "createdAt": "2020-06-01T08:19:02Z", "author": {"login": "HeshanSudarshana"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/jwt_auth_handler.bal", "diffHunk": "@@ -62,22 +151,193 @@ public type JWTAuthHandler object {\n         string credential = headerValue.substring(6, headerValue.length()).trim();\n         var authenticationResult = self.jwtAuthProvider.authenticate(credential);\n         if (authenticationResult is boolean) {\n-            setBackendJwtHeader(credential, req);\n+            boolean generationStatus = generateAndSetBackendJwtHeader(credential,\n+                                                                        req,\n+                                                                        self.enabledJWTGenerator,\n+                                                                        self.classLoaded,\n+                                                                        self.skewTime,\n+                                                                        self.enabledCaching);\n+            if (!generationStatus) {\n+                printError(KEY_JWT_AUTH_PROVIDER, \"JWT Generation failed\");\n+            }\n             return authenticationResult;\n         } else {\n             return prepareAuthenticationError(\"Failed to authenticate with jwt bearer auth handler.\", authenticationResult);\n         }\n     }\n+\n };\n \n-public function setBackendJwtHeader(string credential, http:Request req) {\n-    (jwt:JwtPayload | error) payload = getDecodedJWTPayload(credential);\n-    if (payload is jwt:JwtPayload) {\n-        map<json>? customClaims = payload?.customClaims;\n-        // validate backend jwt claim and set it to jwt header\n-        if (customClaims is map<json> && customClaims.hasKey(BACKEND_JWT)) {\n-            printDebug(KEY_JWT_AUTH_PROVIDER, \"Set backend jwt header.\");\n-            req.setHeader(jwtheaderName, customClaims.get(BACKEND_JWT).toString());\n+# Identify the api details from the subscribed apis in the authentication token.\n+#\n+# + payload - The payload of the authentication token\n+# + apiName - name of the current API\n+# + apiVersion - version of the current API\n+# + return - Returns map<string> with the extracted details.\n+public function getAPIDetails(jwt:JwtPayload payload, string apiName, string apiVersion) returns map<string> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NzAyMg=="}, "originalCommit": {"oid": "6e37528d19b38718e0809243a244128df2b82485"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NTcxNw==", "bodyText": "Can't we move the value reading from token payload to a util method and use it for both subscription method and this? to avoid decoding the payload multiple times.", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r433155717", "createdAt": "2020-06-01T10:24:14Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/jwt_auth_handler.bal", "diffHunk": "@@ -62,22 +151,193 @@ public type JWTAuthHandler object {\n         string credential = headerValue.substring(6, headerValue.length()).trim();\n         var authenticationResult = self.jwtAuthProvider.authenticate(credential);\n         if (authenticationResult is boolean) {\n-            setBackendJwtHeader(credential, req);\n+            boolean generationStatus = generateAndSetBackendJwtHeader(credential,\n+                                                                        req,\n+                                                                        self.enabledJWTGenerator,\n+                                                                        self.classLoaded,\n+                                                                        self.skewTime,\n+                                                                        self.enabledCaching);\n+            if (!generationStatus) {\n+                printError(KEY_JWT_AUTH_PROVIDER, \"JWT Generation failed\");\n+            }\n             return authenticationResult;\n         } else {\n             return prepareAuthenticationError(\"Failed to authenticate with jwt bearer auth handler.\", authenticationResult);\n         }\n     }\n+\n };\n \n-public function setBackendJwtHeader(string credential, http:Request req) {\n-    (jwt:JwtPayload | error) payload = getDecodedJWTPayload(credential);\n-    if (payload is jwt:JwtPayload) {\n-        map<json>? customClaims = payload?.customClaims;\n-        // validate backend jwt claim and set it to jwt header\n-        if (customClaims is map<json> && customClaims.hasKey(BACKEND_JWT)) {\n-            printDebug(KEY_JWT_AUTH_PROVIDER, \"Set backend jwt header.\");\n-            req.setHeader(jwtheaderName, customClaims.get(BACKEND_JWT).toString());\n+# Identify the api details from the subscribed apis in the authentication token.\n+#\n+# + payload - The payload of the authentication token\n+# + apiName - name of the current API\n+# + apiVersion - version of the current API\n+# + return - Returns map<string> with the extracted details.\n+public function getAPIDetails(jwt:JwtPayload payload, string apiName, string apiVersion) returns map<string> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NzAyMg=="}, "originalCommit": {"oid": "6e37528d19b38718e0809243a244128df2b82485"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzY1NTE0OnYy", "diffSide": "RIGHT", "path": "distribution/resources/conf/default-micro-gw.conf.template", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzoxOToyOVrOGdBCqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzoxOToyOVrOGdBCqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3ODk1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              timestampSkew = 5000\n          \n          \n            \n              timestampSkew = 5000", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r433078955", "createdAt": "2020-06-01T07:19:29Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "distribution/resources/conf/default-micro-gw.conf.template", "diffHunk": "@@ -330,3 +328,42 @@\n     [[apikey.issuer.api]]\n       name=\"MyAPI\"\n       versions=\"*\"\n+\n+# JWT Generator configurations\n+[jwtGeneratorConfig]\n+  # Enable jwt generator\n+  jwtGeneratorEnabled=false\n+  # Dialect prefix that can be added to the claims\n+  claimDialect=\"http://wso2.org/claims\"\n+  # Signature algorithm used to sign the JWT token (only SHA256withRSA and NONE is supported)\n+  signingAlgorithm=\"SHA256withRSA\"\n+  # Certificate alias from the keystore\n+  certificateAlias=\"ballerina\"\n+  # Private key alias from the keystore\n+  privateKeyAlias=\"ballerina\"\n+  # JWT token expiry time - ms (valid only if the jwt generator caching mechanism is disabled)\n+  tokenExpiry=900000\n+  # Restricted claims as an array that should not be included in the backend JWT token\n+  # Example: restrictedClaims=[\"claim1\",\"claim2\",\"claim3\"]\n+  restrictedClaims=[]\n+  # Token issuer standard claim\n+  issuer=\"wso2.org/products/am\"\n+  # Token audience standard claim\n+  audience=[\"http://org.wso2.apimgt/gateway\"]\n+  # JWT token generator implementation\n+  generatorImpl=\"org.wso2.micro.gateway.core.jwt.generator.MGWJWTGeneratorImpl\"\n+  # JWT Generator cache configurations\n+  [jwtGeneratorConfig.jwtGeneratorCaching]\n+    # Enable jwt generator token caching\n+    tokenCacheEnable=true\n+    # Token cache expiry time (ms)\n+    tokenCacheExpiryTime=900000\n+    # Token cache capacity\n+    tokenCacheCapacity=10000\n+    # Token cache eviction factor\n+    tokenCacheEvictionFactor=0.25\n+\n+# server configuration\n+[server]\n+  # timestamp skew in seconds which added when checking the token validity period\n+  timestampSkew = 5000", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e37528d19b38718e0809243a244128df2b82485"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzY1NzU0OnYy", "diffSide": "RIGHT", "path": "tests/src/test/resources/confs/base.conf", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzoyMDoyN1rOGdBEJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzoyMDoyN1rOGdBEJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3OTMzNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              timestampSkew=5000\n          \n          \n            \n              timestampSkew=5000", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r433079334", "createdAt": "2020-06-01T07:20:27Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "tests/src/test/resources/confs/base.conf", "diffHunk": "@@ -138,3 +137,6 @@ name = \"jaeger\"\n \n [b7a.observability.tracing.jaeger.reporter]\n port=5775\n+\n+[server]\n+  timestampSkew=5000", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e37528d19b38718e0809243a244128df2b82485"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNjM1MjMwOnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/jwt/generator/MGWJWTGeneratorImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMjo1OTowNlrOITIiOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOFQwMzoyNDoyMVrOIhRecg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMzY4OA==", "bodyText": "I think we can put the common strings used here in a constant file and use those constants instead. If they are already defined as constants let's use that. Ex: \"customClaims\", \"sub\", \"iss\", \"tier\" etc.", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r556933688", "createdAt": "2021-01-13T22:59:06Z", "author": {"login": "tharikaGitHub"}, "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/jwt/generator/MGWJWTGeneratorImpl.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.wso2.micro.gateway.core.jwt.generator;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+/**\n+ *  Class to implement standard claims and custom claims.\n+ */\n+public class MGWJWTGeneratorImpl extends AbstractMGWJWTGenerator {\n+    private static final Log logger = LogFactory.getLog(MGWJWTGeneratorImpl.class);\n+    private static final String AUTH_APPLICATION_USER_LEVEL_TOKEN = \"Application_user\";\n+\n+    public MGWJWTGeneratorImpl(String dialectURI,\n+                               String signatureAlgorithm,\n+                               String trustStorePath,\n+                               String trustStorePassword,\n+                               String certificateAlias,\n+                               String privateKeyAlias,\n+                               int jwtExpiryTime,\n+                               String[] restrictedClaims,\n+                               boolean jwtCacheEnabled,\n+                               int jwtCacheExpiry,\n+                               String tokenIssuer,\n+                               String[] tokenAudience) {\n+        super(dialectURI, signatureAlgorithm, trustStorePath, trustStorePassword, certificateAlias, privateKeyAlias,\n+                jwtExpiryTime, restrictedClaims, jwtCacheEnabled, jwtCacheExpiry, tokenIssuer, tokenAudience);\n+    }\n+\n+    @Override\n+    public Map<String, Object> populateStandardClaims(Map<String, Object> jwtInfo) {\n+        long currentTime = System.currentTimeMillis();\n+        long expireIn = currentTime + getTTL();\n+        String dialect = this.getDialectURI();\n+        Map<String, Object> claims = new HashMap<>();\n+        HashMap<String, Object> customClaims = (HashMap<String, Object>) jwtInfo.get(\"customClaims\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0c3776a2e3096fee3a86ffccb6dc5a1cd86b332"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTc2MDI0Mg==", "bodyText": "Done with 45bcd34", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r571760242", "createdAt": "2021-02-08T03:24:21Z", "author": {"login": "HeshanSudarshana"}, "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/jwt/generator/MGWJWTGeneratorImpl.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.wso2.micro.gateway.core.jwt.generator;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+/**\n+ *  Class to implement standard claims and custom claims.\n+ */\n+public class MGWJWTGeneratorImpl extends AbstractMGWJWTGenerator {\n+    private static final Log logger = LogFactory.getLog(MGWJWTGeneratorImpl.class);\n+    private static final String AUTH_APPLICATION_USER_LEVEL_TOKEN = \"Application_user\";\n+\n+    public MGWJWTGeneratorImpl(String dialectURI,\n+                               String signatureAlgorithm,\n+                               String trustStorePath,\n+                               String trustStorePassword,\n+                               String certificateAlias,\n+                               String privateKeyAlias,\n+                               int jwtExpiryTime,\n+                               String[] restrictedClaims,\n+                               boolean jwtCacheEnabled,\n+                               int jwtCacheExpiry,\n+                               String tokenIssuer,\n+                               String[] tokenAudience) {\n+        super(dialectURI, signatureAlgorithm, trustStorePath, trustStorePassword, certificateAlias, privateKeyAlias,\n+                jwtExpiryTime, restrictedClaims, jwtCacheEnabled, jwtCacheExpiry, tokenIssuer, tokenAudience);\n+    }\n+\n+    @Override\n+    public Map<String, Object> populateStandardClaims(Map<String, Object> jwtInfo) {\n+        long currentTime = System.currentTimeMillis();\n+        long expireIn = currentTime + getTTL();\n+        String dialect = this.getDialectURI();\n+        Map<String, Object> claims = new HashMap<>();\n+        HashMap<String, Object> customClaims = (HashMap<String, Object>) jwtInfo.get(\"customClaims\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMzY4OA=="}, "originalCommit": {"oid": "a0c3776a2e3096fee3a86ffccb6dc5a1cd86b332"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYxMjE0MjgyOnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/jwt/generator/AbstractMGWJWTGenerator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxNjo0MjoyMVrOIif8qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNVQwMzo0NzowN1rOIlP3qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzA0NTkzMA==", "bodyText": "missing try resource", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r573045930", "createdAt": "2021-02-09T16:42:21Z", "author": {"login": "tharindu1st"}, "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/jwt/generator/AbstractMGWJWTGenerator.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.wso2.micro.gateway.core.jwt.generator;\n+\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import net.minidev.json.JSONArray;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+\n+import java.io.FileInputStream;\n+import java.nio.charset.Charset;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.MessageDigest;\n+import java.security.PrivateKey;\n+import java.security.Signature;\n+import java.security.cert.Certificate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ *  Abstract class for generate JWT for backend claims.\n+ */\n+public abstract class AbstractMGWJWTGenerator {\n+    private static final Log logger = LogFactory.getLog(AbstractMGWJWTGenerator.class);\n+    private static final String NONE = \"NONE\";\n+    private static final String SHA256_WITH_RSA = \"SHA256withRSA\";\n+    private String dialectURI;\n+    private String signatureAlgorithm;\n+    private String keyStorePath;\n+    private String keyStorePassword;\n+    private String certificateAlias;\n+    private String privateKeyAlias;\n+    private int jwtExpiryTime;\n+    private ArrayList<String> restrictedClaims;\n+    private boolean cacheEnabled;\n+    private int cacheExpiry;\n+    private String tokenIssuer;\n+    private String[] tokenAudience;\n+    private Map<String, Object> apiDetails;\n+    private List<String> defaultRestrictedClaims;\n+\n+    public AbstractMGWJWTGenerator(String dialectURI,\n+                                   String signatureAlgorithm,\n+                                   String keyStorePath,\n+                                   String keyStorePassword,\n+                                   String certificateAlias,\n+                                   String privateKeyAlias,\n+                                   int jwtExpiryTime,\n+                                   String[] restrictedClaims,\n+                                   boolean cacheEnabled,\n+                                   int cacheExpiry,\n+                                   String tokenIssuer,\n+                                   String[] tokenAudience) {\n+        this.keyStorePath = keyStorePath;\n+        this.keyStorePassword = keyStorePassword;\n+        this.certificateAlias = certificateAlias;\n+        this.privateKeyAlias = privateKeyAlias;\n+        this.jwtExpiryTime = jwtExpiryTime;\n+        this.dialectURI = dialectURI;\n+        this.signatureAlgorithm = signatureAlgorithm;\n+        this.cacheEnabled = cacheEnabled;\n+        this.cacheExpiry = cacheExpiry;\n+        this.tokenIssuer = tokenIssuer;\n+        this.tokenAudience = tokenAudience;\n+        this.restrictedClaims = new ArrayList<>(Arrays.asList(restrictedClaims));\n+        defaultRestrictedClaims = new ArrayList<>(Arrays.asList(\"iss\", \"sub\", \"aud\", \"exp\",\n+                \"nbf\", \"iat\", \"jti\", \"application\", \"tierInfo\", \"subscribedAPIs\", \"keytype\"));\n+        this.restrictedClaims.addAll(defaultRestrictedClaims);\n+    }\n+\n+    public String getPrivateKeyAlias() {\n+        return privateKeyAlias;\n+    }\n+\n+    public void setPrivateKeyAlias(String privateKeyAlias) {\n+        this.privateKeyAlias = privateKeyAlias;\n+    }\n+\n+    public List<String> getDefaultRestrictedClaims() {\n+        return defaultRestrictedClaims;\n+    }\n+\n+    public void setDefaultRestrictedClaims(List<String> defaultRestrictedClaims) {\n+        this.defaultRestrictedClaims = defaultRestrictedClaims;\n+    }\n+\n+    public String getCertificateAlias() {\n+        return certificateAlias;\n+    }\n+\n+    public void setCertificateAlias(String certificateAlias) {\n+        this.certificateAlias = certificateAlias;\n+    }\n+\n+    public Map<String, Object> getApiDetails() {\n+        return apiDetails;\n+    }\n+\n+    public void setApiDetails(Map<String, Object> apiDetails) {\n+        this.apiDetails = apiDetails;\n+    }\n+\n+    public String[] getTokenAudience() {\n+        return tokenAudience;\n+    }\n+\n+    public void setTokenAudience(String[] tokenAudience) {\n+        this.tokenAudience = tokenAudience;\n+    }\n+\n+    public String getTokenIssuer() {\n+        return tokenIssuer;\n+    }\n+\n+    public void setTokenIssuer(String tokenIssuer) {\n+        this.tokenIssuer = tokenIssuer;\n+    }\n+\n+    public boolean isCacheEnabled() {\n+        return cacheEnabled;\n+    }\n+\n+    public void setCacheEnabled(boolean cacheEnabled) {\n+        this.cacheEnabled = cacheEnabled;\n+    }\n+\n+    public int getCacheExpiry() {\n+        return cacheExpiry;\n+    }\n+\n+    public void setCacheExpiry(int cacheExpiry) {\n+        this.cacheExpiry = cacheExpiry;\n+    }\n+\n+    public ArrayList<String> getRestrictedClaims() {\n+        return restrictedClaims;\n+    }\n+\n+    public void setRestrictedClaims(ArrayList<String> restrictedClaims) {\n+        this.restrictedClaims = restrictedClaims;\n+    }\n+\n+    public String getKeyStorePath() {\n+        return keyStorePath;\n+    }\n+\n+    public void setKeyStorePath(String keyStorePath) {\n+        this.keyStorePath = keyStorePath;\n+    }\n+\n+    public String getKeyStorePassword() {\n+        return keyStorePassword;\n+    }\n+\n+    public void setKeyStorePassword(String keyStorePassword) {\n+        this.keyStorePassword = keyStorePassword;\n+    }\n+\n+    public String getDialectURI() {\n+        return dialectURI;\n+    }\n+\n+    public void setDialectURI(String dialectURI) {\n+        this.dialectURI = dialectURI;\n+    }\n+\n+    public String getSignatureAlgorithm() {\n+        return signatureAlgorithm;\n+    }\n+\n+    public void setSignatureAlgorithm(String signatureAlgorithm) {\n+        this.signatureAlgorithm = signatureAlgorithm;\n+    }\n+\n+    public int getJwtExpiryTime() {\n+        return jwtExpiryTime;\n+    }\n+\n+    public void setJwtExpiryTime(int jwtExpiryTime) {\n+        this.jwtExpiryTime = jwtExpiryTime;\n+    }\n+\n+    /**\n+     * Used to generate the JWT token.\n+     */\n+    public String generateToken(Map<String, Object> jwtInfo) throws Exception {\n+        String jwtHeader = buildHeader();\n+        String jwtBody = buildBody(jwtInfo);\n+        String base64UrlEncodedHeader = \"\";\n+        if (jwtHeader != null) {\n+            base64UrlEncodedHeader = encode(jwtHeader.getBytes(Charset.defaultCharset()));\n+        }\n+        String base64UrlEncodedBody = \"\";\n+        if (jwtBody != null) {\n+            base64UrlEncodedBody = encode(jwtBody.getBytes());\n+        }\n+        if (SHA256_WITH_RSA.equals(signatureAlgorithm)) {\n+            String assertion = base64UrlEncodedHeader + '.' + base64UrlEncodedBody;\n+            //get the assertion signed\n+            byte[] signedAssertion = signJWT(assertion);\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"signed assertion value : \" + new String(signedAssertion, Charset.defaultCharset()));\n+            }\n+            String base64UrlEncodedAssertion = encode(signedAssertion);\n+            return base64UrlEncodedHeader + '.' + base64UrlEncodedBody + '.' + base64UrlEncodedAssertion;\n+        } else {\n+            return base64UrlEncodedHeader + '.' + base64UrlEncodedBody + '.';\n+        }\n+    }\n+\n+    /**\n+     * Used to build the JWT header.\n+     */\n+    public String buildHeader() throws Exception {\n+        String jwtHeader = null;\n+        if (NONE.equals(signatureAlgorithm)) {\n+            StringBuilder jwtHeaderBuilder = new StringBuilder();\n+            jwtHeaderBuilder.append(\"{\\\"typ\\\":\\\"JWT\\\",\");\n+            jwtHeaderBuilder.append(\"\\\"alg\\\":\\\"\");\n+            jwtHeaderBuilder.append(\"none\");\n+            jwtHeaderBuilder.append('\\\"');\n+            jwtHeaderBuilder.append('}');\n+            jwtHeader = jwtHeaderBuilder.toString();\n+        } else if (SHA256_WITH_RSA.equals(signatureAlgorithm)) {\n+            jwtHeader = addCertToHeader();\n+        }\n+        return jwtHeader;\n+    }\n+\n+    /**\n+     * Used to sign the JWT using the keystore.\n+     */\n+    public byte[] signJWT(String assertion) throws Exception {\n+        FileInputStream is;\n+        is = new FileInputStream(keyStorePath);\n+        KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+        keystore.load(is, keyStorePassword.toCharArray());\n+        Key key = keystore.getKey(privateKeyAlias, keyStorePassword.toCharArray());\n+        Key privateKey = null;\n+        if (key instanceof PrivateKey) {\n+            privateKey = key;\n+        }\n+        //initialize signature with private key and algorithm\n+        Signature signature = Signature.getInstance(signatureAlgorithm);\n+        signature.initSign((PrivateKey) privateKey);\n+        //update signature with data to be signed\n+        byte[] dataInBytes = assertion.getBytes(Charset.defaultCharset());\n+        signature.update(dataInBytes);\n+\n+        // close the file stream\n+        is.close();\n+\n+        //sign the assertion and return the signature\n+        return signature.sign();\n+    }\n+\n+    /**\n+     * Used to get the expiration time of the token.\n+     */\n+    public long getTTL() {\n+        if (cacheEnabled) {\n+            return cacheExpiry;\n+        } else {\n+            return jwtExpiryTime;\n+        }\n+    }\n+\n+    /**\n+     * Used to add \"ballerina\"the certificate from the keystore to the header.\n+     */\n+    public String addCertToHeader() throws Exception {\n+        FileInputStream is;\n+        is = new FileInputStream(keyStorePath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0c3776a2e3096fee3a86ffccb6dc5a1cd86b332"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTkyODIzNQ==", "bodyText": "Added with #1638", "url": "https://github.com/wso2/product-microgateway/pull/1251#discussion_r575928235", "createdAt": "2021-02-15T03:47:07Z", "author": {"login": "HeshanSudarshana"}, "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/jwt/generator/AbstractMGWJWTGenerator.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.wso2.micro.gateway.core.jwt.generator;\n+\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import net.minidev.json.JSONArray;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+\n+import java.io.FileInputStream;\n+import java.nio.charset.Charset;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.MessageDigest;\n+import java.security.PrivateKey;\n+import java.security.Signature;\n+import java.security.cert.Certificate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ *  Abstract class for generate JWT for backend claims.\n+ */\n+public abstract class AbstractMGWJWTGenerator {\n+    private static final Log logger = LogFactory.getLog(AbstractMGWJWTGenerator.class);\n+    private static final String NONE = \"NONE\";\n+    private static final String SHA256_WITH_RSA = \"SHA256withRSA\";\n+    private String dialectURI;\n+    private String signatureAlgorithm;\n+    private String keyStorePath;\n+    private String keyStorePassword;\n+    private String certificateAlias;\n+    private String privateKeyAlias;\n+    private int jwtExpiryTime;\n+    private ArrayList<String> restrictedClaims;\n+    private boolean cacheEnabled;\n+    private int cacheExpiry;\n+    private String tokenIssuer;\n+    private String[] tokenAudience;\n+    private Map<String, Object> apiDetails;\n+    private List<String> defaultRestrictedClaims;\n+\n+    public AbstractMGWJWTGenerator(String dialectURI,\n+                                   String signatureAlgorithm,\n+                                   String keyStorePath,\n+                                   String keyStorePassword,\n+                                   String certificateAlias,\n+                                   String privateKeyAlias,\n+                                   int jwtExpiryTime,\n+                                   String[] restrictedClaims,\n+                                   boolean cacheEnabled,\n+                                   int cacheExpiry,\n+                                   String tokenIssuer,\n+                                   String[] tokenAudience) {\n+        this.keyStorePath = keyStorePath;\n+        this.keyStorePassword = keyStorePassword;\n+        this.certificateAlias = certificateAlias;\n+        this.privateKeyAlias = privateKeyAlias;\n+        this.jwtExpiryTime = jwtExpiryTime;\n+        this.dialectURI = dialectURI;\n+        this.signatureAlgorithm = signatureAlgorithm;\n+        this.cacheEnabled = cacheEnabled;\n+        this.cacheExpiry = cacheExpiry;\n+        this.tokenIssuer = tokenIssuer;\n+        this.tokenAudience = tokenAudience;\n+        this.restrictedClaims = new ArrayList<>(Arrays.asList(restrictedClaims));\n+        defaultRestrictedClaims = new ArrayList<>(Arrays.asList(\"iss\", \"sub\", \"aud\", \"exp\",\n+                \"nbf\", \"iat\", \"jti\", \"application\", \"tierInfo\", \"subscribedAPIs\", \"keytype\"));\n+        this.restrictedClaims.addAll(defaultRestrictedClaims);\n+    }\n+\n+    public String getPrivateKeyAlias() {\n+        return privateKeyAlias;\n+    }\n+\n+    public void setPrivateKeyAlias(String privateKeyAlias) {\n+        this.privateKeyAlias = privateKeyAlias;\n+    }\n+\n+    public List<String> getDefaultRestrictedClaims() {\n+        return defaultRestrictedClaims;\n+    }\n+\n+    public void setDefaultRestrictedClaims(List<String> defaultRestrictedClaims) {\n+        this.defaultRestrictedClaims = defaultRestrictedClaims;\n+    }\n+\n+    public String getCertificateAlias() {\n+        return certificateAlias;\n+    }\n+\n+    public void setCertificateAlias(String certificateAlias) {\n+        this.certificateAlias = certificateAlias;\n+    }\n+\n+    public Map<String, Object> getApiDetails() {\n+        return apiDetails;\n+    }\n+\n+    public void setApiDetails(Map<String, Object> apiDetails) {\n+        this.apiDetails = apiDetails;\n+    }\n+\n+    public String[] getTokenAudience() {\n+        return tokenAudience;\n+    }\n+\n+    public void setTokenAudience(String[] tokenAudience) {\n+        this.tokenAudience = tokenAudience;\n+    }\n+\n+    public String getTokenIssuer() {\n+        return tokenIssuer;\n+    }\n+\n+    public void setTokenIssuer(String tokenIssuer) {\n+        this.tokenIssuer = tokenIssuer;\n+    }\n+\n+    public boolean isCacheEnabled() {\n+        return cacheEnabled;\n+    }\n+\n+    public void setCacheEnabled(boolean cacheEnabled) {\n+        this.cacheEnabled = cacheEnabled;\n+    }\n+\n+    public int getCacheExpiry() {\n+        return cacheExpiry;\n+    }\n+\n+    public void setCacheExpiry(int cacheExpiry) {\n+        this.cacheExpiry = cacheExpiry;\n+    }\n+\n+    public ArrayList<String> getRestrictedClaims() {\n+        return restrictedClaims;\n+    }\n+\n+    public void setRestrictedClaims(ArrayList<String> restrictedClaims) {\n+        this.restrictedClaims = restrictedClaims;\n+    }\n+\n+    public String getKeyStorePath() {\n+        return keyStorePath;\n+    }\n+\n+    public void setKeyStorePath(String keyStorePath) {\n+        this.keyStorePath = keyStorePath;\n+    }\n+\n+    public String getKeyStorePassword() {\n+        return keyStorePassword;\n+    }\n+\n+    public void setKeyStorePassword(String keyStorePassword) {\n+        this.keyStorePassword = keyStorePassword;\n+    }\n+\n+    public String getDialectURI() {\n+        return dialectURI;\n+    }\n+\n+    public void setDialectURI(String dialectURI) {\n+        this.dialectURI = dialectURI;\n+    }\n+\n+    public String getSignatureAlgorithm() {\n+        return signatureAlgorithm;\n+    }\n+\n+    public void setSignatureAlgorithm(String signatureAlgorithm) {\n+        this.signatureAlgorithm = signatureAlgorithm;\n+    }\n+\n+    public int getJwtExpiryTime() {\n+        return jwtExpiryTime;\n+    }\n+\n+    public void setJwtExpiryTime(int jwtExpiryTime) {\n+        this.jwtExpiryTime = jwtExpiryTime;\n+    }\n+\n+    /**\n+     * Used to generate the JWT token.\n+     */\n+    public String generateToken(Map<String, Object> jwtInfo) throws Exception {\n+        String jwtHeader = buildHeader();\n+        String jwtBody = buildBody(jwtInfo);\n+        String base64UrlEncodedHeader = \"\";\n+        if (jwtHeader != null) {\n+            base64UrlEncodedHeader = encode(jwtHeader.getBytes(Charset.defaultCharset()));\n+        }\n+        String base64UrlEncodedBody = \"\";\n+        if (jwtBody != null) {\n+            base64UrlEncodedBody = encode(jwtBody.getBytes());\n+        }\n+        if (SHA256_WITH_RSA.equals(signatureAlgorithm)) {\n+            String assertion = base64UrlEncodedHeader + '.' + base64UrlEncodedBody;\n+            //get the assertion signed\n+            byte[] signedAssertion = signJWT(assertion);\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"signed assertion value : \" + new String(signedAssertion, Charset.defaultCharset()));\n+            }\n+            String base64UrlEncodedAssertion = encode(signedAssertion);\n+            return base64UrlEncodedHeader + '.' + base64UrlEncodedBody + '.' + base64UrlEncodedAssertion;\n+        } else {\n+            return base64UrlEncodedHeader + '.' + base64UrlEncodedBody + '.';\n+        }\n+    }\n+\n+    /**\n+     * Used to build the JWT header.\n+     */\n+    public String buildHeader() throws Exception {\n+        String jwtHeader = null;\n+        if (NONE.equals(signatureAlgorithm)) {\n+            StringBuilder jwtHeaderBuilder = new StringBuilder();\n+            jwtHeaderBuilder.append(\"{\\\"typ\\\":\\\"JWT\\\",\");\n+            jwtHeaderBuilder.append(\"\\\"alg\\\":\\\"\");\n+            jwtHeaderBuilder.append(\"none\");\n+            jwtHeaderBuilder.append('\\\"');\n+            jwtHeaderBuilder.append('}');\n+            jwtHeader = jwtHeaderBuilder.toString();\n+        } else if (SHA256_WITH_RSA.equals(signatureAlgorithm)) {\n+            jwtHeader = addCertToHeader();\n+        }\n+        return jwtHeader;\n+    }\n+\n+    /**\n+     * Used to sign the JWT using the keystore.\n+     */\n+    public byte[] signJWT(String assertion) throws Exception {\n+        FileInputStream is;\n+        is = new FileInputStream(keyStorePath);\n+        KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+        keystore.load(is, keyStorePassword.toCharArray());\n+        Key key = keystore.getKey(privateKeyAlias, keyStorePassword.toCharArray());\n+        Key privateKey = null;\n+        if (key instanceof PrivateKey) {\n+            privateKey = key;\n+        }\n+        //initialize signature with private key and algorithm\n+        Signature signature = Signature.getInstance(signatureAlgorithm);\n+        signature.initSign((PrivateKey) privateKey);\n+        //update signature with data to be signed\n+        byte[] dataInBytes = assertion.getBytes(Charset.defaultCharset());\n+        signature.update(dataInBytes);\n+\n+        // close the file stream\n+        is.close();\n+\n+        //sign the assertion and return the signature\n+        return signature.sign();\n+    }\n+\n+    /**\n+     * Used to get the expiration time of the token.\n+     */\n+    public long getTTL() {\n+        if (cacheEnabled) {\n+            return cacheExpiry;\n+        } else {\n+            return jwtExpiryTime;\n+        }\n+    }\n+\n+    /**\n+     * Used to add \"ballerina\"the certificate from the keystore to the header.\n+     */\n+    public String addCertToHeader() throws Exception {\n+        FileInputStream is;\n+        is = new FileInputStream(keyStorePath);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzA0NTkzMA=="}, "originalCommit": {"oid": "a0c3776a2e3096fee3a86ffccb6dc5a1cd86b332"}, "originalPosition": 290}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1237, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}