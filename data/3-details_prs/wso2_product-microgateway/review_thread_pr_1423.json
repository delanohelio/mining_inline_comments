{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzODQ4MDAx", "number": 1423, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNTowMjo1OFrOEn7HoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMDozNjowMlrOFVnHhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMjk4NTI4OnYy", "diffSide": "RIGHT", "path": "go-filter-chain/filters/jwt.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNTowMjo1OFrOHYuiRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNToxNjozMVrOHYut9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDMwOA==", "bodyText": "read this only once. not for each request", "url": "https://github.com/wso2/product-microgateway/pull/1423#discussion_r495690308", "createdAt": "2020-09-28T05:02:58Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "go-filter-chain/filters/jwt.go", "diffHunk": "@@ -0,0 +1,183 @@\n+package filters\n+\n+import (\n+\t\"context\"\n+\t\"crypto/rsa\"\n+\t\"errors\"\n+\t\"github.com/dgrijalva/jwt-go\"\n+\text_authz \"github.com/envoyproxy/go-control-plane/envoy/service/auth/v2\"\n+\tenvoy_type \"github.com/envoyproxy/go-control-plane/envoy/type\"\n+\t\"github.com/gogo/googleapis/google/rpc\"\n+\t\"github.com/patrickmn/go-cache\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"google.golang.org/genproto/googleapis/rpc/status\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+)\n+\n+\n+\n+type TokenData struct {\n+\tmeta_clientType        string\n+\tapplicationConsumerKey string\n+\tapplicationName        string\n+\tapplicationId          string\n+\tapplicationOwner       string\n+\tapiCreator             string\n+\tapiCreatorTenantDomain string\n+\tapiTier                string\n+\tusername               string\n+\tuserTenantDomain       string\n+\tthrottledOut           bool\n+\tserviceTime            int64\n+\tauthorized             bool\n+}\n+\n+var (\n+\tUnknown = \"__unknown__\"\n+\tonce sync.Once\n+\tonce_1 sync.Once\n+\tcaCert []byte\n+\terr error\n+\tkey *rsa.PublicKey\n+\tjwtCache = cache.New(5*time.Minute, 10*time.Minute)\n+\tUnauthorizedError = errors.New(\"Invalid access token\")\n+\tjwtToken string\n+\tisCacheEnabled bool\n+)\n+\n+\n+\n+// handle JWT token\n+func HandleJWT(validateSubscription bool, publicCert []byte, token string) (bool, TokenData, error) {\n+\n+\taccessToken := token\n+\n+\ttokenContent := strings.Split(accessToken, \".\")\n+\tvar tokenData TokenData\n+\n+\tif len(tokenContent) != 3 {\n+\t\tlog.Errorf(\"Invalid JWT token received, token must have 3 parts\")\n+\t\treturn false, tokenData, UnauthorizedError\n+\t}\n+\n+\tsignedContent := tokenContent[0] + \".\" + tokenContent[1]\n+\terr := validateSignature(publicCert, signedContent, tokenContent[2])\n+\tif err != nil {\n+\t\tlog.Errorf(\"Error in validating the signature: %v\", err)\n+\t\treturn false, tokenData, UnauthorizedError\n+\t}\n+\n+\treturn true, tokenData, nil\n+}\n+\n+// validate the signature\n+func validateSignature(publicCert []byte, signedContent string, signature string) error {\n+\n+\tonce_1.Do(func() {\n+\t\tkey, err = jwt.ParseRSAPublicKeyFromPEM(publicCert)\n+\t\tlog.Info(\"read public key once\")\n+\t})\n+\n+\tif err != nil {\n+\t\tlog.Errorf(\"Error in parsing the public key: %v\", err)\n+\t\treturn err\n+\t}\n+\n+\treturn jwt.SigningMethodRS256.Verify(signedContent, signature, key)\n+}\n+\n+//reading the secret\n+func ReadFile(fileName string) ([]byte, error) {\n+\n+\tsecretValue, err := ioutil.ReadFile(fileName)\n+\tif err != nil {\n+\t\tlog.Warnf(\"Error in reading the file %v: error - %v\", fileName, err)\n+\t}\n+\n+\treturn secretValue, err\n+}\n+\n+\n+func ValidateToken(ctx context.Context, req *ext_authz.CheckRequest) (*ext_authz.CheckResponse, error) {\n+\n+\tonce.Do(func() {\n+\t\tcaCert,_ = ReadFile(\"./artifacts/server.pem\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "734f3c99d31ca4b1cbcb2fddfd5bd1a8e6b3df08"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MzMwMw==", "bodyText": "Once.Do function execute only once", "url": "https://github.com/wso2/product-microgateway/pull/1423#discussion_r495693303", "createdAt": "2020-09-28T05:16:31Z", "author": {"login": "chashikajw"}, "path": "go-filter-chain/filters/jwt.go", "diffHunk": "@@ -0,0 +1,183 @@\n+package filters\n+\n+import (\n+\t\"context\"\n+\t\"crypto/rsa\"\n+\t\"errors\"\n+\t\"github.com/dgrijalva/jwt-go\"\n+\text_authz \"github.com/envoyproxy/go-control-plane/envoy/service/auth/v2\"\n+\tenvoy_type \"github.com/envoyproxy/go-control-plane/envoy/type\"\n+\t\"github.com/gogo/googleapis/google/rpc\"\n+\t\"github.com/patrickmn/go-cache\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"google.golang.org/genproto/googleapis/rpc/status\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+)\n+\n+\n+\n+type TokenData struct {\n+\tmeta_clientType        string\n+\tapplicationConsumerKey string\n+\tapplicationName        string\n+\tapplicationId          string\n+\tapplicationOwner       string\n+\tapiCreator             string\n+\tapiCreatorTenantDomain string\n+\tapiTier                string\n+\tusername               string\n+\tuserTenantDomain       string\n+\tthrottledOut           bool\n+\tserviceTime            int64\n+\tauthorized             bool\n+}\n+\n+var (\n+\tUnknown = \"__unknown__\"\n+\tonce sync.Once\n+\tonce_1 sync.Once\n+\tcaCert []byte\n+\terr error\n+\tkey *rsa.PublicKey\n+\tjwtCache = cache.New(5*time.Minute, 10*time.Minute)\n+\tUnauthorizedError = errors.New(\"Invalid access token\")\n+\tjwtToken string\n+\tisCacheEnabled bool\n+)\n+\n+\n+\n+// handle JWT token\n+func HandleJWT(validateSubscription bool, publicCert []byte, token string) (bool, TokenData, error) {\n+\n+\taccessToken := token\n+\n+\ttokenContent := strings.Split(accessToken, \".\")\n+\tvar tokenData TokenData\n+\n+\tif len(tokenContent) != 3 {\n+\t\tlog.Errorf(\"Invalid JWT token received, token must have 3 parts\")\n+\t\treturn false, tokenData, UnauthorizedError\n+\t}\n+\n+\tsignedContent := tokenContent[0] + \".\" + tokenContent[1]\n+\terr := validateSignature(publicCert, signedContent, tokenContent[2])\n+\tif err != nil {\n+\t\tlog.Errorf(\"Error in validating the signature: %v\", err)\n+\t\treturn false, tokenData, UnauthorizedError\n+\t}\n+\n+\treturn true, tokenData, nil\n+}\n+\n+// validate the signature\n+func validateSignature(publicCert []byte, signedContent string, signature string) error {\n+\n+\tonce_1.Do(func() {\n+\t\tkey, err = jwt.ParseRSAPublicKeyFromPEM(publicCert)\n+\t\tlog.Info(\"read public key once\")\n+\t})\n+\n+\tif err != nil {\n+\t\tlog.Errorf(\"Error in parsing the public key: %v\", err)\n+\t\treturn err\n+\t}\n+\n+\treturn jwt.SigningMethodRS256.Verify(signedContent, signature, key)\n+}\n+\n+//reading the secret\n+func ReadFile(fileName string) ([]byte, error) {\n+\n+\tsecretValue, err := ioutil.ReadFile(fileName)\n+\tif err != nil {\n+\t\tlog.Warnf(\"Error in reading the file %v: error - %v\", fileName, err)\n+\t}\n+\n+\treturn secretValue, err\n+}\n+\n+\n+func ValidateToken(ctx context.Context, req *ext_authz.CheckRequest) (*ext_authz.CheckResponse, error) {\n+\n+\tonce.Do(func() {\n+\t\tcaCert,_ = ReadFile(\"./artifacts/server.pem\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDMwOA=="}, "originalCommit": {"oid": "734f3c99d31ca4b1cbcb2fddfd5bd1a8e6b3df08"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMjk4NzEyOnYy", "diffSide": "RIGHT", "path": "go-filter-chain/filters/jwt.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNTowNDoxMFrOHYujRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNToxODo1M1rOHYuwFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDU2Ng==", "bodyText": "Let's remove any logs/prints in the testing flow for now.", "url": "https://github.com/wso2/product-microgateway/pull/1423#discussion_r495690566", "createdAt": "2020-09-28T05:04:10Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "go-filter-chain/filters/jwt.go", "diffHunk": "@@ -0,0 +1,183 @@\n+package filters\n+\n+import (\n+\t\"context\"\n+\t\"crypto/rsa\"\n+\t\"errors\"\n+\t\"github.com/dgrijalva/jwt-go\"\n+\text_authz \"github.com/envoyproxy/go-control-plane/envoy/service/auth/v2\"\n+\tenvoy_type \"github.com/envoyproxy/go-control-plane/envoy/type\"\n+\t\"github.com/gogo/googleapis/google/rpc\"\n+\t\"github.com/patrickmn/go-cache\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"google.golang.org/genproto/googleapis/rpc/status\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+)\n+\n+\n+\n+type TokenData struct {\n+\tmeta_clientType        string\n+\tapplicationConsumerKey string\n+\tapplicationName        string\n+\tapplicationId          string\n+\tapplicationOwner       string\n+\tapiCreator             string\n+\tapiCreatorTenantDomain string\n+\tapiTier                string\n+\tusername               string\n+\tuserTenantDomain       string\n+\tthrottledOut           bool\n+\tserviceTime            int64\n+\tauthorized             bool\n+}\n+\n+var (\n+\tUnknown = \"__unknown__\"\n+\tonce sync.Once\n+\tonce_1 sync.Once\n+\tcaCert []byte\n+\terr error\n+\tkey *rsa.PublicKey\n+\tjwtCache = cache.New(5*time.Minute, 10*time.Minute)\n+\tUnauthorizedError = errors.New(\"Invalid access token\")\n+\tjwtToken string\n+\tisCacheEnabled bool\n+)\n+\n+\n+\n+// handle JWT token\n+func HandleJWT(validateSubscription bool, publicCert []byte, token string) (bool, TokenData, error) {\n+\n+\taccessToken := token\n+\n+\ttokenContent := strings.Split(accessToken, \".\")\n+\tvar tokenData TokenData\n+\n+\tif len(tokenContent) != 3 {\n+\t\tlog.Errorf(\"Invalid JWT token received, token must have 3 parts\")\n+\t\treturn false, tokenData, UnauthorizedError\n+\t}\n+\n+\tsignedContent := tokenContent[0] + \".\" + tokenContent[1]\n+\terr := validateSignature(publicCert, signedContent, tokenContent[2])\n+\tif err != nil {\n+\t\tlog.Errorf(\"Error in validating the signature: %v\", err)\n+\t\treturn false, tokenData, UnauthorizedError\n+\t}\n+\n+\treturn true, tokenData, nil\n+}\n+\n+// validate the signature\n+func validateSignature(publicCert []byte, signedContent string, signature string) error {\n+\n+\tonce_1.Do(func() {\n+\t\tkey, err = jwt.ParseRSAPublicKeyFromPEM(publicCert)\n+\t\tlog.Info(\"read public key once\")\n+\t})\n+\n+\tif err != nil {\n+\t\tlog.Errorf(\"Error in parsing the public key: %v\", err)\n+\t\treturn err\n+\t}\n+\n+\treturn jwt.SigningMethodRS256.Verify(signedContent, signature, key)\n+}\n+\n+//reading the secret\n+func ReadFile(fileName string) ([]byte, error) {\n+\n+\tsecretValue, err := ioutil.ReadFile(fileName)\n+\tif err != nil {\n+\t\tlog.Warnf(\"Error in reading the file %v: error - %v\", fileName, err)\n+\t}\n+\n+\treturn secretValue, err\n+}\n+\n+\n+func ValidateToken(ctx context.Context, req *ext_authz.CheckRequest) (*ext_authz.CheckResponse, error) {\n+\n+\tonce.Do(func() {\n+\t\tcaCert,_ = ReadFile(\"./artifacts/server.pem\")\n+\t\tlog.Info(\"read server.pem file once\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "734f3c99d31ca4b1cbcb2fddfd5bd1a8e6b3df08"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5Mzg0Nw==", "bodyText": "okay btw since this execute only once, this will be not much affected", "url": "https://github.com/wso2/product-microgateway/pull/1423#discussion_r495693847", "createdAt": "2020-09-28T05:18:53Z", "author": {"login": "chashikajw"}, "path": "go-filter-chain/filters/jwt.go", "diffHunk": "@@ -0,0 +1,183 @@\n+package filters\n+\n+import (\n+\t\"context\"\n+\t\"crypto/rsa\"\n+\t\"errors\"\n+\t\"github.com/dgrijalva/jwt-go\"\n+\text_authz \"github.com/envoyproxy/go-control-plane/envoy/service/auth/v2\"\n+\tenvoy_type \"github.com/envoyproxy/go-control-plane/envoy/type\"\n+\t\"github.com/gogo/googleapis/google/rpc\"\n+\t\"github.com/patrickmn/go-cache\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"google.golang.org/genproto/googleapis/rpc/status\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+)\n+\n+\n+\n+type TokenData struct {\n+\tmeta_clientType        string\n+\tapplicationConsumerKey string\n+\tapplicationName        string\n+\tapplicationId          string\n+\tapplicationOwner       string\n+\tapiCreator             string\n+\tapiCreatorTenantDomain string\n+\tapiTier                string\n+\tusername               string\n+\tuserTenantDomain       string\n+\tthrottledOut           bool\n+\tserviceTime            int64\n+\tauthorized             bool\n+}\n+\n+var (\n+\tUnknown = \"__unknown__\"\n+\tonce sync.Once\n+\tonce_1 sync.Once\n+\tcaCert []byte\n+\terr error\n+\tkey *rsa.PublicKey\n+\tjwtCache = cache.New(5*time.Minute, 10*time.Minute)\n+\tUnauthorizedError = errors.New(\"Invalid access token\")\n+\tjwtToken string\n+\tisCacheEnabled bool\n+)\n+\n+\n+\n+// handle JWT token\n+func HandleJWT(validateSubscription bool, publicCert []byte, token string) (bool, TokenData, error) {\n+\n+\taccessToken := token\n+\n+\ttokenContent := strings.Split(accessToken, \".\")\n+\tvar tokenData TokenData\n+\n+\tif len(tokenContent) != 3 {\n+\t\tlog.Errorf(\"Invalid JWT token received, token must have 3 parts\")\n+\t\treturn false, tokenData, UnauthorizedError\n+\t}\n+\n+\tsignedContent := tokenContent[0] + \".\" + tokenContent[1]\n+\terr := validateSignature(publicCert, signedContent, tokenContent[2])\n+\tif err != nil {\n+\t\tlog.Errorf(\"Error in validating the signature: %v\", err)\n+\t\treturn false, tokenData, UnauthorizedError\n+\t}\n+\n+\treturn true, tokenData, nil\n+}\n+\n+// validate the signature\n+func validateSignature(publicCert []byte, signedContent string, signature string) error {\n+\n+\tonce_1.Do(func() {\n+\t\tkey, err = jwt.ParseRSAPublicKeyFromPEM(publicCert)\n+\t\tlog.Info(\"read public key once\")\n+\t})\n+\n+\tif err != nil {\n+\t\tlog.Errorf(\"Error in parsing the public key: %v\", err)\n+\t\treturn err\n+\t}\n+\n+\treturn jwt.SigningMethodRS256.Verify(signedContent, signature, key)\n+}\n+\n+//reading the secret\n+func ReadFile(fileName string) ([]byte, error) {\n+\n+\tsecretValue, err := ioutil.ReadFile(fileName)\n+\tif err != nil {\n+\t\tlog.Warnf(\"Error in reading the file %v: error - %v\", fileName, err)\n+\t}\n+\n+\treturn secretValue, err\n+}\n+\n+\n+func ValidateToken(ctx context.Context, req *ext_authz.CheckRequest) (*ext_authz.CheckResponse, error) {\n+\n+\tonce.Do(func() {\n+\t\tcaCert,_ = ReadFile(\"./artifacts/server.pem\")\n+\t\tlog.Info(\"read server.pem file once\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDU2Ng=="}, "originalCommit": {"oid": "734f3c99d31ca4b1cbcb2fddfd5bd1a8e6b3df08"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMjk5MTI1OnYy", "diffSide": "RIGHT", "path": "go-filter-chain/filters/jwt.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNTowNjo0OVrOHYulgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNToxOTo1NFrOHYuxEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MTEzOA==", "bodyText": "read this only once. not for each request", "url": "https://github.com/wso2/product-microgateway/pull/1423#discussion_r495691138", "createdAt": "2020-09-28T05:06:49Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "go-filter-chain/filters/jwt.go", "diffHunk": "@@ -0,0 +1,183 @@\n+package filters\n+\n+import (\n+\t\"context\"\n+\t\"crypto/rsa\"\n+\t\"errors\"\n+\t\"github.com/dgrijalva/jwt-go\"\n+\text_authz \"github.com/envoyproxy/go-control-plane/envoy/service/auth/v2\"\n+\tenvoy_type \"github.com/envoyproxy/go-control-plane/envoy/type\"\n+\t\"github.com/gogo/googleapis/google/rpc\"\n+\t\"github.com/patrickmn/go-cache\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"google.golang.org/genproto/googleapis/rpc/status\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+)\n+\n+\n+\n+type TokenData struct {\n+\tmeta_clientType        string\n+\tapplicationConsumerKey string\n+\tapplicationName        string\n+\tapplicationId          string\n+\tapplicationOwner       string\n+\tapiCreator             string\n+\tapiCreatorTenantDomain string\n+\tapiTier                string\n+\tusername               string\n+\tuserTenantDomain       string\n+\tthrottledOut           bool\n+\tserviceTime            int64\n+\tauthorized             bool\n+}\n+\n+var (\n+\tUnknown = \"__unknown__\"\n+\tonce sync.Once\n+\tonce_1 sync.Once\n+\tcaCert []byte\n+\terr error\n+\tkey *rsa.PublicKey\n+\tjwtCache = cache.New(5*time.Minute, 10*time.Minute)\n+\tUnauthorizedError = errors.New(\"Invalid access token\")\n+\tjwtToken string\n+\tisCacheEnabled bool\n+)\n+\n+\n+\n+// handle JWT token\n+func HandleJWT(validateSubscription bool, publicCert []byte, token string) (bool, TokenData, error) {\n+\n+\taccessToken := token\n+\n+\ttokenContent := strings.Split(accessToken, \".\")\n+\tvar tokenData TokenData\n+\n+\tif len(tokenContent) != 3 {\n+\t\tlog.Errorf(\"Invalid JWT token received, token must have 3 parts\")\n+\t\treturn false, tokenData, UnauthorizedError\n+\t}\n+\n+\tsignedContent := tokenContent[0] + \".\" + tokenContent[1]\n+\terr := validateSignature(publicCert, signedContent, tokenContent[2])\n+\tif err != nil {\n+\t\tlog.Errorf(\"Error in validating the signature: %v\", err)\n+\t\treturn false, tokenData, UnauthorizedError\n+\t}\n+\n+\treturn true, tokenData, nil\n+}\n+\n+// validate the signature\n+func validateSignature(publicCert []byte, signedContent string, signature string) error {\n+\n+\tonce_1.Do(func() {\n+\t\tkey, err = jwt.ParseRSAPublicKeyFromPEM(publicCert)\n+\t\tlog.Info(\"read public key once\")\n+\t})\n+\n+\tif err != nil {\n+\t\tlog.Errorf(\"Error in parsing the public key: %v\", err)\n+\t\treturn err\n+\t}\n+\n+\treturn jwt.SigningMethodRS256.Verify(signedContent, signature, key)\n+}\n+\n+//reading the secret\n+func ReadFile(fileName string) ([]byte, error) {\n+\n+\tsecretValue, err := ioutil.ReadFile(fileName)\n+\tif err != nil {\n+\t\tlog.Warnf(\"Error in reading the file %v: error - %v\", fileName, err)\n+\t}\n+\n+\treturn secretValue, err\n+}\n+\n+\n+func ValidateToken(ctx context.Context, req *ext_authz.CheckRequest) (*ext_authz.CheckResponse, error) {\n+\n+\tonce.Do(func() {\n+\t\tcaCert,_ = ReadFile(\"./artifacts/server.pem\")\n+\t\tlog.Info(\"read server.pem file once\")\n+\n+\t\tcacheEnvVar := os.Getenv(\"ENVOY_GW_CACHE_ENABLE\")\n+\t\tlog.Info(\"env variable\",cacheEnvVar )\n+\n+\t\tif cacheEnvVar != \"\" {\n+\t\t\tisCacheEnabled, err = strconv.ParseBool(cacheEnvVar)\n+\n+\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Error(\"Error reading cache env variable, err\")\n+\t\t\t\tisCacheEnabled = false\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tisCacheEnabled = false\n+\t\t}\n+\t})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "734f3c99d31ca4b1cbcb2fddfd5bd1a8e6b3df08"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5NDA5Nw==", "bodyText": "this code inside the Once. Do function. it executes only once", "url": "https://github.com/wso2/product-microgateway/pull/1423#discussion_r495694097", "createdAt": "2020-09-28T05:19:54Z", "author": {"login": "chashikajw"}, "path": "go-filter-chain/filters/jwt.go", "diffHunk": "@@ -0,0 +1,183 @@\n+package filters\n+\n+import (\n+\t\"context\"\n+\t\"crypto/rsa\"\n+\t\"errors\"\n+\t\"github.com/dgrijalva/jwt-go\"\n+\text_authz \"github.com/envoyproxy/go-control-plane/envoy/service/auth/v2\"\n+\tenvoy_type \"github.com/envoyproxy/go-control-plane/envoy/type\"\n+\t\"github.com/gogo/googleapis/google/rpc\"\n+\t\"github.com/patrickmn/go-cache\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"google.golang.org/genproto/googleapis/rpc/status\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+)\n+\n+\n+\n+type TokenData struct {\n+\tmeta_clientType        string\n+\tapplicationConsumerKey string\n+\tapplicationName        string\n+\tapplicationId          string\n+\tapplicationOwner       string\n+\tapiCreator             string\n+\tapiCreatorTenantDomain string\n+\tapiTier                string\n+\tusername               string\n+\tuserTenantDomain       string\n+\tthrottledOut           bool\n+\tserviceTime            int64\n+\tauthorized             bool\n+}\n+\n+var (\n+\tUnknown = \"__unknown__\"\n+\tonce sync.Once\n+\tonce_1 sync.Once\n+\tcaCert []byte\n+\terr error\n+\tkey *rsa.PublicKey\n+\tjwtCache = cache.New(5*time.Minute, 10*time.Minute)\n+\tUnauthorizedError = errors.New(\"Invalid access token\")\n+\tjwtToken string\n+\tisCacheEnabled bool\n+)\n+\n+\n+\n+// handle JWT token\n+func HandleJWT(validateSubscription bool, publicCert []byte, token string) (bool, TokenData, error) {\n+\n+\taccessToken := token\n+\n+\ttokenContent := strings.Split(accessToken, \".\")\n+\tvar tokenData TokenData\n+\n+\tif len(tokenContent) != 3 {\n+\t\tlog.Errorf(\"Invalid JWT token received, token must have 3 parts\")\n+\t\treturn false, tokenData, UnauthorizedError\n+\t}\n+\n+\tsignedContent := tokenContent[0] + \".\" + tokenContent[1]\n+\terr := validateSignature(publicCert, signedContent, tokenContent[2])\n+\tif err != nil {\n+\t\tlog.Errorf(\"Error in validating the signature: %v\", err)\n+\t\treturn false, tokenData, UnauthorizedError\n+\t}\n+\n+\treturn true, tokenData, nil\n+}\n+\n+// validate the signature\n+func validateSignature(publicCert []byte, signedContent string, signature string) error {\n+\n+\tonce_1.Do(func() {\n+\t\tkey, err = jwt.ParseRSAPublicKeyFromPEM(publicCert)\n+\t\tlog.Info(\"read public key once\")\n+\t})\n+\n+\tif err != nil {\n+\t\tlog.Errorf(\"Error in parsing the public key: %v\", err)\n+\t\treturn err\n+\t}\n+\n+\treturn jwt.SigningMethodRS256.Verify(signedContent, signature, key)\n+}\n+\n+//reading the secret\n+func ReadFile(fileName string) ([]byte, error) {\n+\n+\tsecretValue, err := ioutil.ReadFile(fileName)\n+\tif err != nil {\n+\t\tlog.Warnf(\"Error in reading the file %v: error - %v\", fileName, err)\n+\t}\n+\n+\treturn secretValue, err\n+}\n+\n+\n+func ValidateToken(ctx context.Context, req *ext_authz.CheckRequest) (*ext_authz.CheckResponse, error) {\n+\n+\tonce.Do(func() {\n+\t\tcaCert,_ = ReadFile(\"./artifacts/server.pem\")\n+\t\tlog.Info(\"read server.pem file once\")\n+\n+\t\tcacheEnvVar := os.Getenv(\"ENVOY_GW_CACHE_ENABLE\")\n+\t\tlog.Info(\"env variable\",cacheEnvVar )\n+\n+\t\tif cacheEnvVar != \"\" {\n+\t\t\tisCacheEnabled, err = strconv.ParseBool(cacheEnvVar)\n+\n+\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Error(\"Error reading cache env variable, err\")\n+\t\t\t\tisCacheEnabled = false\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tisCacheEnabled = false\n+\t\t}\n+\t})", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MTEzOA=="}, "originalCommit": {"oid": "734f3c99d31ca4b1cbcb2fddfd5bd1a8e6b3df08"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMjk5NTE3OnYy", "diffSide": "RIGHT", "path": "go-filter-chain/filters/jwt.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNTowOToyNVrOHYunoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNToyMTo1NlrOHYuzCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MTY4MQ==", "bodyText": "Do we need to run a for loop for this?", "url": "https://github.com/wso2/product-microgateway/pull/1423#discussion_r495691681", "createdAt": "2020-09-28T05:09:25Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "go-filter-chain/filters/jwt.go", "diffHunk": "@@ -0,0 +1,183 @@\n+package filters\n+\n+import (\n+\t\"context\"\n+\t\"crypto/rsa\"\n+\t\"errors\"\n+\t\"github.com/dgrijalva/jwt-go\"\n+\text_authz \"github.com/envoyproxy/go-control-plane/envoy/service/auth/v2\"\n+\tenvoy_type \"github.com/envoyproxy/go-control-plane/envoy/type\"\n+\t\"github.com/gogo/googleapis/google/rpc\"\n+\t\"github.com/patrickmn/go-cache\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"google.golang.org/genproto/googleapis/rpc/status\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+)\n+\n+\n+\n+type TokenData struct {\n+\tmeta_clientType        string\n+\tapplicationConsumerKey string\n+\tapplicationName        string\n+\tapplicationId          string\n+\tapplicationOwner       string\n+\tapiCreator             string\n+\tapiCreatorTenantDomain string\n+\tapiTier                string\n+\tusername               string\n+\tuserTenantDomain       string\n+\tthrottledOut           bool\n+\tserviceTime            int64\n+\tauthorized             bool\n+}\n+\n+var (\n+\tUnknown = \"__unknown__\"\n+\tonce sync.Once\n+\tonce_1 sync.Once\n+\tcaCert []byte\n+\terr error\n+\tkey *rsa.PublicKey\n+\tjwtCache = cache.New(5*time.Minute, 10*time.Minute)\n+\tUnauthorizedError = errors.New(\"Invalid access token\")\n+\tjwtToken string\n+\tisCacheEnabled bool\n+)\n+\n+\n+\n+// handle JWT token\n+func HandleJWT(validateSubscription bool, publicCert []byte, token string) (bool, TokenData, error) {\n+\n+\taccessToken := token\n+\n+\ttokenContent := strings.Split(accessToken, \".\")\n+\tvar tokenData TokenData\n+\n+\tif len(tokenContent) != 3 {\n+\t\tlog.Errorf(\"Invalid JWT token received, token must have 3 parts\")\n+\t\treturn false, tokenData, UnauthorizedError\n+\t}\n+\n+\tsignedContent := tokenContent[0] + \".\" + tokenContent[1]\n+\terr := validateSignature(publicCert, signedContent, tokenContent[2])\n+\tif err != nil {\n+\t\tlog.Errorf(\"Error in validating the signature: %v\", err)\n+\t\treturn false, tokenData, UnauthorizedError\n+\t}\n+\n+\treturn true, tokenData, nil\n+}\n+\n+// validate the signature\n+func validateSignature(publicCert []byte, signedContent string, signature string) error {\n+\n+\tonce_1.Do(func() {\n+\t\tkey, err = jwt.ParseRSAPublicKeyFromPEM(publicCert)\n+\t\tlog.Info(\"read public key once\")\n+\t})\n+\n+\tif err != nil {\n+\t\tlog.Errorf(\"Error in parsing the public key: %v\", err)\n+\t\treturn err\n+\t}\n+\n+\treturn jwt.SigningMethodRS256.Verify(signedContent, signature, key)\n+}\n+\n+//reading the secret\n+func ReadFile(fileName string) ([]byte, error) {\n+\n+\tsecretValue, err := ioutil.ReadFile(fileName)\n+\tif err != nil {\n+\t\tlog.Warnf(\"Error in reading the file %v: error - %v\", fileName, err)\n+\t}\n+\n+\treturn secretValue, err\n+}\n+\n+\n+func ValidateToken(ctx context.Context, req *ext_authz.CheckRequest) (*ext_authz.CheckResponse, error) {\n+\n+\tonce.Do(func() {\n+\t\tcaCert,_ = ReadFile(\"./artifacts/server.pem\")\n+\t\tlog.Info(\"read server.pem file once\")\n+\n+\t\tcacheEnvVar := os.Getenv(\"ENVOY_GW_CACHE_ENABLE\")\n+\t\tlog.Info(\"env variable\",cacheEnvVar )\n+\n+\t\tif cacheEnvVar != \"\" {\n+\t\t\tisCacheEnabled, err = strconv.ParseBool(cacheEnvVar)\n+\n+\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Error(\"Error reading cache env variable, err\")\n+\t\t\t\tisCacheEnabled = false\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tisCacheEnabled = false\n+\t\t}\n+\t})\n+\n+\tauth := false\n+\tjwtToken := \"\"\n+\trequestAttributes := req.Attributes.Request.Http.Headers\n+\n+\tfor k := range requestAttributes {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "734f3c99d31ca4b1cbcb2fddfd5bd1a8e6b3df08"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5NDYwMQ==", "bodyText": "yes, there is heders array in the request. So we need to use for loop. btw added a break for improving performance", "url": "https://github.com/wso2/product-microgateway/pull/1423#discussion_r495694601", "createdAt": "2020-09-28T05:21:56Z", "author": {"login": "chashikajw"}, "path": "go-filter-chain/filters/jwt.go", "diffHunk": "@@ -0,0 +1,183 @@\n+package filters\n+\n+import (\n+\t\"context\"\n+\t\"crypto/rsa\"\n+\t\"errors\"\n+\t\"github.com/dgrijalva/jwt-go\"\n+\text_authz \"github.com/envoyproxy/go-control-plane/envoy/service/auth/v2\"\n+\tenvoy_type \"github.com/envoyproxy/go-control-plane/envoy/type\"\n+\t\"github.com/gogo/googleapis/google/rpc\"\n+\t\"github.com/patrickmn/go-cache\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"google.golang.org/genproto/googleapis/rpc/status\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+)\n+\n+\n+\n+type TokenData struct {\n+\tmeta_clientType        string\n+\tapplicationConsumerKey string\n+\tapplicationName        string\n+\tapplicationId          string\n+\tapplicationOwner       string\n+\tapiCreator             string\n+\tapiCreatorTenantDomain string\n+\tapiTier                string\n+\tusername               string\n+\tuserTenantDomain       string\n+\tthrottledOut           bool\n+\tserviceTime            int64\n+\tauthorized             bool\n+}\n+\n+var (\n+\tUnknown = \"__unknown__\"\n+\tonce sync.Once\n+\tonce_1 sync.Once\n+\tcaCert []byte\n+\terr error\n+\tkey *rsa.PublicKey\n+\tjwtCache = cache.New(5*time.Minute, 10*time.Minute)\n+\tUnauthorizedError = errors.New(\"Invalid access token\")\n+\tjwtToken string\n+\tisCacheEnabled bool\n+)\n+\n+\n+\n+// handle JWT token\n+func HandleJWT(validateSubscription bool, publicCert []byte, token string) (bool, TokenData, error) {\n+\n+\taccessToken := token\n+\n+\ttokenContent := strings.Split(accessToken, \".\")\n+\tvar tokenData TokenData\n+\n+\tif len(tokenContent) != 3 {\n+\t\tlog.Errorf(\"Invalid JWT token received, token must have 3 parts\")\n+\t\treturn false, tokenData, UnauthorizedError\n+\t}\n+\n+\tsignedContent := tokenContent[0] + \".\" + tokenContent[1]\n+\terr := validateSignature(publicCert, signedContent, tokenContent[2])\n+\tif err != nil {\n+\t\tlog.Errorf(\"Error in validating the signature: %v\", err)\n+\t\treturn false, tokenData, UnauthorizedError\n+\t}\n+\n+\treturn true, tokenData, nil\n+}\n+\n+// validate the signature\n+func validateSignature(publicCert []byte, signedContent string, signature string) error {\n+\n+\tonce_1.Do(func() {\n+\t\tkey, err = jwt.ParseRSAPublicKeyFromPEM(publicCert)\n+\t\tlog.Info(\"read public key once\")\n+\t})\n+\n+\tif err != nil {\n+\t\tlog.Errorf(\"Error in parsing the public key: %v\", err)\n+\t\treturn err\n+\t}\n+\n+\treturn jwt.SigningMethodRS256.Verify(signedContent, signature, key)\n+}\n+\n+//reading the secret\n+func ReadFile(fileName string) ([]byte, error) {\n+\n+\tsecretValue, err := ioutil.ReadFile(fileName)\n+\tif err != nil {\n+\t\tlog.Warnf(\"Error in reading the file %v: error - %v\", fileName, err)\n+\t}\n+\n+\treturn secretValue, err\n+}\n+\n+\n+func ValidateToken(ctx context.Context, req *ext_authz.CheckRequest) (*ext_authz.CheckResponse, error) {\n+\n+\tonce.Do(func() {\n+\t\tcaCert,_ = ReadFile(\"./artifacts/server.pem\")\n+\t\tlog.Info(\"read server.pem file once\")\n+\n+\t\tcacheEnvVar := os.Getenv(\"ENVOY_GW_CACHE_ENABLE\")\n+\t\tlog.Info(\"env variable\",cacheEnvVar )\n+\n+\t\tif cacheEnvVar != \"\" {\n+\t\t\tisCacheEnabled, err = strconv.ParseBool(cacheEnvVar)\n+\n+\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Error(\"Error reading cache env variable, err\")\n+\t\t\t\tisCacheEnabled = false\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tisCacheEnabled = false\n+\t\t}\n+\t})\n+\n+\tauth := false\n+\tjwtToken := \"\"\n+\trequestAttributes := req.Attributes.Request.Http.Headers\n+\n+\tfor k := range requestAttributes {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MTY4MQ=="}, "originalCommit": {"oid": "734f3c99d31ca4b1cbcb2fddfd5bd1a8e6b3df08"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjA1MjQyOnYy", "diffSide": "RIGHT", "path": "go-filter-chain/main.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMDozNTo1MFrOIeKNsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMToyMToyN1rOIeL-NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODQ5NTUzNw==", "bodyText": "remove unnecessary commented code", "url": "https://github.com/wso2/product-microgateway/pull/1423#discussion_r568495537", "createdAt": "2021-02-02T10:35:50Z", "author": {"login": "fazlan-nazeem"}, "path": "go-filter-chain/main.go", "diffHunk": "@@ -0,0 +1,76 @@\n+package main\n+\n+import (\n+\t\"context\"\n+\t\"envoy-test-filter/filters\"\n+\t//filters \"envoy-test-filter/filters\"\n+\t\"fmt\"\n+\text_authz \"github.com/envoyproxy/go-control-plane/envoy/service/auth/v2\"\n+\t\"github.com/gogo/googleapis/google/rpc\"\n+\t\"google.golang.org/grpc\"\n+\t\"google.golang.org/grpc/reflection\"\n+\t\"log\"\n+\t\"net\"\n+\t\"os\"\n+\t\"os/signal\"\n+)\n+\n+type server struct {\n+\tmode string\n+}\n+\n+func main() {\n+\tc := make(chan os.Signal)\n+\tsignal.Notify(c, os.Interrupt)\n+\n+\tgo listen(\":8081\", &server{mode: \"GATEWAY\"})\n+\n+\t<-c\n+}\n+\n+func listen(address string, serverType *server) {\n+\tlis, err := net.Listen(\"tcp\", address)\n+\tif err != nil {\n+\t\tlog.Fatalf(\"failed to listen: %v\", err)\n+\t}\n+\ts := grpc.NewServer()\n+\text_authz.RegisterAuthorizationServer(s, serverType)\n+\treflection.Register(s)\n+\tfmt.Printf(\"Starting %q reciver on %q\\n\", serverType.mode, address)\n+\tif err := s.Serve(lis); err != nil {\n+\t\tlog.Fatalf(\"failed to serve: %v\", err)\n+\t}\n+}\n+\n+func (s *server) Check(ctx context.Context, req *ext_authz.CheckRequest) (*ext_authz.CheckResponse, error) {\n+\n+\t//fmt.Printf(\"======================================== %-24s ========================================\\n\", fmt.Sprintf(\"%s Start\", s.mode))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5fc826a05b4acaab27feaf42f5e7e19ded3c963"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUyNDM0MA==", "bodyText": "This was removed", "url": "https://github.com/wso2/product-microgateway/pull/1423#discussion_r568524340", "createdAt": "2021-02-02T11:21:27Z", "author": {"login": "chashikajw"}, "path": "go-filter-chain/main.go", "diffHunk": "@@ -0,0 +1,76 @@\n+package main\n+\n+import (\n+\t\"context\"\n+\t\"envoy-test-filter/filters\"\n+\t//filters \"envoy-test-filter/filters\"\n+\t\"fmt\"\n+\text_authz \"github.com/envoyproxy/go-control-plane/envoy/service/auth/v2\"\n+\t\"github.com/gogo/googleapis/google/rpc\"\n+\t\"google.golang.org/grpc\"\n+\t\"google.golang.org/grpc/reflection\"\n+\t\"log\"\n+\t\"net\"\n+\t\"os\"\n+\t\"os/signal\"\n+)\n+\n+type server struct {\n+\tmode string\n+}\n+\n+func main() {\n+\tc := make(chan os.Signal)\n+\tsignal.Notify(c, os.Interrupt)\n+\n+\tgo listen(\":8081\", &server{mode: \"GATEWAY\"})\n+\n+\t<-c\n+}\n+\n+func listen(address string, serverType *server) {\n+\tlis, err := net.Listen(\"tcp\", address)\n+\tif err != nil {\n+\t\tlog.Fatalf(\"failed to listen: %v\", err)\n+\t}\n+\ts := grpc.NewServer()\n+\text_authz.RegisterAuthorizationServer(s, serverType)\n+\treflection.Register(s)\n+\tfmt.Printf(\"Starting %q reciver on %q\\n\", serverType.mode, address)\n+\tif err := s.Serve(lis); err != nil {\n+\t\tlog.Fatalf(\"failed to serve: %v\", err)\n+\t}\n+}\n+\n+func (s *server) Check(ctx context.Context, req *ext_authz.CheckRequest) (*ext_authz.CheckResponse, error) {\n+\n+\t//fmt.Printf(\"======================================== %-24s ========================================\\n\", fmt.Sprintf(\"%s Start\", s.mode))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODQ5NTUzNw=="}, "originalCommit": {"oid": "b5fc826a05b4acaab27feaf42f5e7e19ded3c963"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjA1MzE5OnYy", "diffSide": "RIGHT", "path": "java-filter-chain/src/main/java/org/wso2/mgw/filterchain/gRPC/server/ExtAuthService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMDozNjowMlrOIeKOOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMToyMToyMlrOIeL9-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODQ5NTY3Mg==", "bodyText": "remove commented code", "url": "https://github.com/wso2/product-microgateway/pull/1423#discussion_r568495672", "createdAt": "2021-02-02T10:36:02Z", "author": {"login": "fazlan-nazeem"}, "path": "java-filter-chain/src/main/java/org/wso2/mgw/filterchain/gRPC/server/ExtAuthService.java", "diffHunk": "@@ -34,7 +34,8 @@ public void check (CheckRequest request, StreamObserver<CheckResponse> responseO\n \n         //System.out.println(\"++++++++++hit+++++++++++++++\");\n \n-        //System.out.println(request.getAttributes().getRequest().getHttp());\n+\n+        //System.out.println(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5fc826a05b4acaab27feaf42f5e7e19ded3c963"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUyNDI4MQ==", "bodyText": "This was removed", "url": "https://github.com/wso2/product-microgateway/pull/1423#discussion_r568524281", "createdAt": "2021-02-02T11:21:22Z", "author": {"login": "chashikajw"}, "path": "java-filter-chain/src/main/java/org/wso2/mgw/filterchain/gRPC/server/ExtAuthService.java", "diffHunk": "@@ -34,7 +34,8 @@ public void check (CheckRequest request, StreamObserver<CheckResponse> responseO\n \n         //System.out.println(\"++++++++++hit+++++++++++++++\");\n \n-        //System.out.println(request.getAttributes().getRequest().getHttp());\n+\n+        //System.out.println(request);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODQ5NTY3Mg=="}, "originalCommit": {"oid": "b5fc826a05b4acaab27feaf42f5e7e19ded3c963"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1133, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}