{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNDU2OTYy", "number": 1271, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwOTozNDowNVrOEEnJlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjo0MjowNlrOEE6fCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMjcxMTkwOnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwOTozNDowNVrOGiVzyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMDozMDo1OFrOGiXn2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2MjA5MQ==", "bodyText": "In conf template, it says;\n# Header name apend by the **load balancer**?\ncertificateHeadername = \"Header name given by the load balancer\"\n# **Is client certificate validation enable** ?\nisClientCertificateValidationEnabled = true\n\nI feel these comments are confusing. Better to improve there as well.", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r438662091", "createdAt": "2020-06-11T09:34:05Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY4MzI5OA==", "bodyText": "isClientCertificateValidationEnabled config is only valid when certificate is present in the header. If header is not present we always validate certificate in the context.\nWhats the confusion in the comment", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r438683298", "createdAt": "2020-06-11T10:13:31Z", "author": {"login": "Rajith90"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2MjA5MQ=="}, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY5MTgwMA==", "bodyText": "if isClientCertificateValidationEnabled is applicable for the header, can we mention about the header in the comment. Otherwise, it looks like this is intended for certificatevalidation disabling for both header and context as well", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r438691800", "createdAt": "2020-06-11T10:30:58Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2MjA5MQ=="}, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMjc3NTE1OnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwOTo1MzoxOFrOGiWcdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMDoxOTowMlrOGiXRkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY3MjUwMQ==", "bodyText": "if only mutualSSLStatus==false, is a valid scenario here, we have to set the error to the invocation context before returning false.", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r438672501", "createdAt": "2020-06-11T09:53:18Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n+                    doMTSLFilterRequest(req, invocationContext);\n                 } else {\n-                    handle|error certificateAlias = getAliasFromRequest(cert.toString());\n-                    if (certificateAlias is error) {\n-                        setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                        return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                    return mutualSSLStatus;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY4NjA5Ng==", "bodyText": "I mutualSSLStatus is auth error or false the it would come here. Before returning false or auth error type from checkCertificatePresentInContext and checkCertificatePresentInHeader methods we set the response to invocation context", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r438686096", "createdAt": "2020-06-11T10:19:02Z", "author": {"login": "Rajith90"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n+                    doMTSLFilterRequest(req, invocationContext);\n                 } else {\n-                    handle|error certificateAlias = getAliasFromRequest(cert.toString());\n-                    if (certificateAlias is error) {\n-                        setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                        return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                    return mutualSSLStatus;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY3MjUwMQ=="}, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMjc4NzQ5OnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwOTo1NzoyMVrOGiWk5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMDoxOTo1M1rOGiXS6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY3NDY2MQ==", "bodyText": "If checkCertificatePresentInContext and checkCertificatePresentInHeader have duplicate logic, moving them to a util method or so would be better.", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r438674661", "createdAt": "2020-06-11T09:57:21Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n+                    doMTSLFilterRequest(req, invocationContext);\n                 } else {\n-                    handle|error certificateAlias = getAliasFromRequest(cert.toString());\n-                    if (certificateAlias is error) {\n-                        setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                        return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                    return mutualSSLStatus;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    function checkCertificatePresentInContext(http:Request req, string apiName, string apiVersion,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY4NjQ0MA==", "bodyText": "These two methods does not have the exact logic.", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r438686440", "createdAt": "2020-06-11T10:19:53Z", "author": {"login": "Rajith90"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n+                    doMTSLFilterRequest(req, invocationContext);\n                 } else {\n-                    handle|error certificateAlias = getAliasFromRequest(cert.toString());\n-                    if (certificateAlias is error) {\n-                        setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                        return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                    return mutualSSLStatus;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    function checkCertificatePresentInContext(http:Request req, string apiName, string apiVersion,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY3NDY2MQ=="}, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMjc5ODE5OnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/mutualssl/CertificateUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMDowMDoyNVrOGiWrhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMDoxNzoyMlrOGiXOCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY3NjM1OA==", "bodyText": "If when throwing the error here will also log the error msg, then calling log.error() again may not be needed.", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r438676358", "createdAt": "2020-06-11T10:00:25Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/mutualssl/CertificateUtils.java", "diffHunk": "@@ -34,19 +37,24 @@\n  * This class is responsible for do certificate level functionalities.\n  */\n public class CertificateUtils {\n+    private static final Logger log = LogManager.getLogger(CertificateUtils.class);\n \n-    public static String getAliasFromHeaderCert(String base64EncodedCertificate) throws  KeyStoreException,\n-            java.security.cert.CertificateException, CertificateException {\n-        base64EncodedCertificate = URLDecoder.decode(base64EncodedCertificate).\n-                replaceAll(Constants.BEGIN_CERTIFICATE_STRING, \"\")\n-                .replaceAll(Constants.END_CERTIFICATE_STRING, \"\");\n-        byte[] bytes = Base64.decodeBase64(base64EncodedCertificate);\n-        InputStream inputStream = new ByteArrayInputStream(bytes);\n-        X509Certificate x509Certificate = X509Certificate.getInstance(inputStream);\n-        if (getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore) != null) {\n-            return getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore);\n-        } else {\n-            return \"\";\n+    public static String getAliasFromHeaderCert(String base64EncodedCertificate) {\n+        try {\n+            base64EncodedCertificate = URLDecoder.decode(base64EncodedCertificate).\n+                    replaceAll(Constants.BEGIN_CERTIFICATE_STRING, \"\").replaceAll(Constants.END_CERTIFICATE_STRING, \"\");\n+            byte[] bytes = Base64.decodeBase64(base64EncodedCertificate);\n+            InputStream inputStream = new ByteArrayInputStream(bytes);\n+            X509Certificate x509Certificate = X509Certificate.getInstance(inputStream);\n+            if (getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore) != null) {\n+                return getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore);\n+            } else {\n+                return \"\";\n+            }\n+        } catch (KeyStoreException | java.security.cert.CertificateException | CertificateException e) {\n+            String msg = \"Error while decoding certificate present in the header and validating with the trust store.\";\n+            log.error(msg, e);\n+            throw ErrorUtils.getBallerinaError(msg, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY4NTE5NQ==", "bodyText": "If we do not log error here, it would not log the stack trace properly. We need to log the error here properly, and pass the error to ballerina level to handle from there.", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r438685195", "createdAt": "2020-06-11T10:17:22Z", "author": {"login": "Rajith90"}, "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/mutualssl/CertificateUtils.java", "diffHunk": "@@ -34,19 +37,24 @@\n  * This class is responsible for do certificate level functionalities.\n  */\n public class CertificateUtils {\n+    private static final Logger log = LogManager.getLogger(CertificateUtils.class);\n \n-    public static String getAliasFromHeaderCert(String base64EncodedCertificate) throws  KeyStoreException,\n-            java.security.cert.CertificateException, CertificateException {\n-        base64EncodedCertificate = URLDecoder.decode(base64EncodedCertificate).\n-                replaceAll(Constants.BEGIN_CERTIFICATE_STRING, \"\")\n-                .replaceAll(Constants.END_CERTIFICATE_STRING, \"\");\n-        byte[] bytes = Base64.decodeBase64(base64EncodedCertificate);\n-        InputStream inputStream = new ByteArrayInputStream(bytes);\n-        X509Certificate x509Certificate = X509Certificate.getInstance(inputStream);\n-        if (getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore) != null) {\n-            return getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore);\n-        } else {\n-            return \"\";\n+    public static String getAliasFromHeaderCert(String base64EncodedCertificate) {\n+        try {\n+            base64EncodedCertificate = URLDecoder.decode(base64EncodedCertificate).\n+                    replaceAll(Constants.BEGIN_CERTIFICATE_STRING, \"\").replaceAll(Constants.END_CERTIFICATE_STRING, \"\");\n+            byte[] bytes = Base64.decodeBase64(base64EncodedCertificate);\n+            InputStream inputStream = new ByteArrayInputStream(bytes);\n+            X509Certificate x509Certificate = X509Certificate.getInstance(inputStream);\n+            if (getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore) != null) {\n+                return getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore);\n+            } else {\n+                return \"\";\n+            }\n+        } catch (KeyStoreException | java.security.cert.CertificateException | CertificateException e) {\n+            String msg = \"Error while decoding certificate present in the header and validating with the trust store.\";\n+            log.error(msg, e);\n+            throw ErrorUtils.getBallerinaError(msg, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY3NjM1OA=="}, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTg3MTg0OnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjozNjoxMVrOGi1KUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjozNjoxMVrOGi1KUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NTc2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if(mutualSSLStatus is boolean && mutualSSLStatus) {\n          \n          \n            \n                                    if (mutualSSLStatus is boolean && mutualSSLStatus) {", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439175763", "createdAt": "2020-06-12T02:36:11Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTg3MzEzOnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjozNzoxNFrOGi1LIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjozNzoxNFrOGi1LIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NTk2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if(mutualSSLStatus is boolean && mutualSSLStatus) {\n          \n          \n            \n                            if (mutualSSLStatus is boolean && mutualSSLStatus) {", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439175969", "createdAt": "2020-06-12T02:37:14Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTg3NDcxOnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjozODoyM1rOGi1MGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjozODoyM1rOGi1MGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NjIxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if(!isExistAlias) {\n          \n          \n            \n                                if (!isExistAlias) {", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439176216", "createdAt": "2020-06-12T02:38:23Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n+                    doMTSLFilterRequest(req, invocationContext);\n                 } else {\n-                    handle|error certificateAlias = getAliasFromRequest(cert.toString());\n-                    if (certificateAlias is error) {\n-                        setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                        return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                    return mutualSSLStatus;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    function checkCertificatePresentInContext(http:Request req, string apiName, string apiVersion,\n+                    boolean isValidateCertificateWithAPI) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request context.\");\n+        string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n+        var cacheKey = cert.toString() + apiName + apiVersion;\n+        var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n+        if (isExistCertCache is boolean)    {\n+            if (!isExistCertCache) {\n+                printError(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n+                \"Certificate validity returned as false from cache. This is due to either certificat missing in trust\" +\n+                \" store or certificate alias is missing in the config, where apis are mapped with list of aliases.\");\n+                return false;\n+            }\n+            return true;\n+        } else {\n+            handle|error certificateAlias = getAliasFromRequest(cert.toString());\n+            if (certificateAlias is error) {\n+                setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n+                return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+            }\n+            if (certificateAlias is handle) {\n+                //Only if 'isValidateCertificateWithAPI' true then certificate should be cross checked with the\n+                //alias list provided in the config. Otherwise no need to cross check with the alias list\n+                //in micro-gw.conf.\n+                boolean isExistAlias = (isValidateCertificateWithAPI) ? isExistApiAlias(apiVersion, apiName,\n+                                                        certificateAlias.toString(),self.apiCertificateList) : true;\n+                if (!isExistAlias || certificateAlias.toString() == \"\") {\n+                    if(!isExistAlias) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTg3NTgxOnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjozOToyM1rOGi1M3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwNjoxMTo1NFrOGi4MiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NjQxMg==", "bodyText": "Is the the key (KEY_AUTHN_FILTER) we want to use? not a different key for mutualssl handler?", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439176412", "createdAt": "2020-06-12T02:39:23Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n+                    doMTSLFilterRequest(req, invocationContext);\n                 } else {\n-                    handle|error certificateAlias = getAliasFromRequest(cert.toString());\n-                    if (certificateAlias is error) {\n-                        setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                        return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                    return mutualSSLStatus;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    function checkCertificatePresentInContext(http:Request req, string apiName, string apiVersion,\n+                    boolean isValidateCertificateWithAPI) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request context.\");\n+        string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n+        var cacheKey = cert.toString() + apiName + apiVersion;\n+        var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n+        if (isExistCertCache is boolean)    {\n+            if (!isExistCertCache) {\n+                printError(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n+                \"Certificate validity returned as false from cache. This is due to either certificat missing in trust\" +\n+                \" store or certificate alias is missing in the config, where apis are mapped with list of aliases.\");\n+                return false;\n+            }\n+            return true;\n+        } else {\n+            handle|error certificateAlias = getAliasFromRequest(cert.toString());\n+            if (certificateAlias is error) {\n+                setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n+                return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+            }\n+            if (certificateAlias is handle) {\n+                //Only if 'isValidateCertificateWithAPI' true then certificate should be cross checked with the\n+                //alias list provided in the config. Otherwise no need to cross check with the alias list\n+                //in micro-gw.conf.\n+                boolean isExistAlias = (isValidateCertificateWithAPI) ? isExistApiAlias(apiVersion, apiName,\n+                                                        certificateAlias.toString(),self.apiCertificateList) : true;\n+                if (!isExistAlias || certificateAlias.toString() == \"\") {\n+                    if(!isExistAlias) {\n+                        printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n+                    \"with the certificate\");\n+                    } else if (certificateAlias.toString() == \"\") {\n+                        printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. Certificate alias not \" +\n+                        \"found in the trust store\");\n                     }\n-                    if (certificateAlias is handle ) {\n-                        boolean isExistAlias = isExistApiAlias(apiVersion, apiName, certificateAlias.toString(),\n-                        self.apiCertificateList);\n-                        if (!isExistAlias || certificateAlias.toString() == \"\") {\n-                            printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                            \"with the certificate\");\n-                            self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                    self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n+                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n+                    return false;\n+                }\n+            }\n+            self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n+            printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status using request context: PASSED \");\n+            return true;\n+        }\n+    }\n+\n+    function checkCertificatePresentInHeader(http:Request req, string apiName, string apiVersion) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request header.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIyNTQ4MQ==", "bodyText": "All the authentication handlers use the same key", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439225481", "createdAt": "2020-06-12T06:11:54Z", "author": {"login": "Rajith90"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n+                    doMTSLFilterRequest(req, invocationContext);\n                 } else {\n-                    handle|error certificateAlias = getAliasFromRequest(cert.toString());\n-                    if (certificateAlias is error) {\n-                        setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                        return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                    return mutualSSLStatus;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    function checkCertificatePresentInContext(http:Request req, string apiName, string apiVersion,\n+                    boolean isValidateCertificateWithAPI) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request context.\");\n+        string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n+        var cacheKey = cert.toString() + apiName + apiVersion;\n+        var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n+        if (isExistCertCache is boolean)    {\n+            if (!isExistCertCache) {\n+                printError(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n+                \"Certificate validity returned as false from cache. This is due to either certificat missing in trust\" +\n+                \" store or certificate alias is missing in the config, where apis are mapped with list of aliases.\");\n+                return false;\n+            }\n+            return true;\n+        } else {\n+            handle|error certificateAlias = getAliasFromRequest(cert.toString());\n+            if (certificateAlias is error) {\n+                setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n+                return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+            }\n+            if (certificateAlias is handle) {\n+                //Only if 'isValidateCertificateWithAPI' true then certificate should be cross checked with the\n+                //alias list provided in the config. Otherwise no need to cross check with the alias list\n+                //in micro-gw.conf.\n+                boolean isExistAlias = (isValidateCertificateWithAPI) ? isExistApiAlias(apiVersion, apiName,\n+                                                        certificateAlias.toString(),self.apiCertificateList) : true;\n+                if (!isExistAlias || certificateAlias.toString() == \"\") {\n+                    if(!isExistAlias) {\n+                        printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n+                    \"with the certificate\");\n+                    } else if (certificateAlias.toString() == \"\") {\n+                        printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. Certificate alias not \" +\n+                        \"found in the trust store\");\n                     }\n-                    if (certificateAlias is handle ) {\n-                        boolean isExistAlias = isExistApiAlias(apiVersion, apiName, certificateAlias.toString(),\n-                        self.apiCertificateList);\n-                        if (!isExistAlias || certificateAlias.toString() == \"\") {\n-                            printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                            \"with the certificate\");\n-                            self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                    self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n+                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n+                    return false;\n+                }\n+            }\n+            self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n+            printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status using request context: PASSED \");\n+            return true;\n+        }\n+    }\n+\n+    function checkCertificatePresentInHeader(http:Request req, string apiName, string apiVersion) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request header.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NjQxMg=="}, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTg3NjI0OnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjozOTo0M1rOGi1NHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjozOTo0M1rOGi1NHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NjQ3OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            else {\n          \n          \n            \n                            } else {", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439176478", "createdAt": "2020-06-12T02:39:43Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n+                    doMTSLFilterRequest(req, invocationContext);\n                 } else {\n-                    handle|error certificateAlias = getAliasFromRequest(cert.toString());\n-                    if (certificateAlias is error) {\n-                        setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                        return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                    return mutualSSLStatus;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    function checkCertificatePresentInContext(http:Request req, string apiName, string apiVersion,\n+                    boolean isValidateCertificateWithAPI) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request context.\");\n+        string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n+        var cacheKey = cert.toString() + apiName + apiVersion;\n+        var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n+        if (isExistCertCache is boolean)    {\n+            if (!isExistCertCache) {\n+                printError(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n+                \"Certificate validity returned as false from cache. This is due to either certificat missing in trust\" +\n+                \" store or certificate alias is missing in the config, where apis are mapped with list of aliases.\");\n+                return false;\n+            }\n+            return true;\n+        } else {\n+            handle|error certificateAlias = getAliasFromRequest(cert.toString());\n+            if (certificateAlias is error) {\n+                setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n+                return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+            }\n+            if (certificateAlias is handle) {\n+                //Only if 'isValidateCertificateWithAPI' true then certificate should be cross checked with the\n+                //alias list provided in the config. Otherwise no need to cross check with the alias list\n+                //in micro-gw.conf.\n+                boolean isExistAlias = (isValidateCertificateWithAPI) ? isExistApiAlias(apiVersion, apiName,\n+                                                        certificateAlias.toString(),self.apiCertificateList) : true;\n+                if (!isExistAlias || certificateAlias.toString() == \"\") {\n+                    if(!isExistAlias) {\n+                        printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n+                    \"with the certificate\");\n+                    } else if (certificateAlias.toString() == \"\") {\n+                        printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. Certificate alias not \" +\n+                        \"found in the trust store\");\n                     }\n-                    if (certificateAlias is handle ) {\n-                        boolean isExistAlias = isExistApiAlias(apiVersion, apiName, certificateAlias.toString(),\n-                        self.apiCertificateList);\n-                        if (!isExistAlias || certificateAlias.toString() == \"\") {\n-                            printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                            \"with the certificate\");\n-                            self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                    self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n+                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n+                    return false;\n+                }\n+            }\n+            self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n+            printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status using request context: PASSED \");\n+            return true;\n+        }\n+    }\n+\n+    function checkCertificatePresentInHeader(http:Request req, string apiName, string apiVersion) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request header.\");\n+        string headerValue = req.getHeader(self.headerName);\n+        if (headerValue != \"\") {\n+            var cacheKey = headerValue + apiName + apiVersion;\n+            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n+            if (isExistCertCache is boolean) {\n+                if (!isExistCertCache) {\n+                    printError(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n+                    \"Certificate validity returned as false from cache. This is due to either certificat missing in \" +\n+                    \"trust store or certificate alias is missing in the config, where apis are mapped with list \" +\n+                    \"of aliases.\");\n+                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n+                    return false;\n+                } else {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status using request header: PASSED\");\n+                    return true;\n+                }\n+            } else {\n+                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n+                if (aliasFromHeaderCert is error) {\n+                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n+                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                }\n+                else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTg3NjYxOnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjozOTo1OVrOGi1NXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjozOTo1OVrOGi1NXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NjU0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if(!isExistAlias) {\n          \n          \n            \n                                    if (!isExistAlias) {", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439176540", "createdAt": "2020-06-12T02:39:59Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n+                    doMTSLFilterRequest(req, invocationContext);\n                 } else {\n-                    handle|error certificateAlias = getAliasFromRequest(cert.toString());\n-                    if (certificateAlias is error) {\n-                        setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                        return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                    return mutualSSLStatus;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    function checkCertificatePresentInContext(http:Request req, string apiName, string apiVersion,\n+                    boolean isValidateCertificateWithAPI) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request context.\");\n+        string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n+        var cacheKey = cert.toString() + apiName + apiVersion;\n+        var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n+        if (isExistCertCache is boolean)    {\n+            if (!isExistCertCache) {\n+                printError(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n+                \"Certificate validity returned as false from cache. This is due to either certificat missing in trust\" +\n+                \" store or certificate alias is missing in the config, where apis are mapped with list of aliases.\");\n+                return false;\n+            }\n+            return true;\n+        } else {\n+            handle|error certificateAlias = getAliasFromRequest(cert.toString());\n+            if (certificateAlias is error) {\n+                setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n+                return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+            }\n+            if (certificateAlias is handle) {\n+                //Only if 'isValidateCertificateWithAPI' true then certificate should be cross checked with the\n+                //alias list provided in the config. Otherwise no need to cross check with the alias list\n+                //in micro-gw.conf.\n+                boolean isExistAlias = (isValidateCertificateWithAPI) ? isExistApiAlias(apiVersion, apiName,\n+                                                        certificateAlias.toString(),self.apiCertificateList) : true;\n+                if (!isExistAlias || certificateAlias.toString() == \"\") {\n+                    if(!isExistAlias) {\n+                        printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n+                    \"with the certificate\");\n+                    } else if (certificateAlias.toString() == \"\") {\n+                        printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. Certificate alias not \" +\n+                        \"found in the trust store\");\n                     }\n-                    if (certificateAlias is handle ) {\n-                        boolean isExistAlias = isExistApiAlias(apiVersion, apiName, certificateAlias.toString(),\n-                        self.apiCertificateList);\n-                        if (!isExistAlias || certificateAlias.toString() == \"\") {\n-                            printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                            \"with the certificate\");\n-                            self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                    self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n+                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n+                    return false;\n+                }\n+            }\n+            self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n+            printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status using request context: PASSED \");\n+            return true;\n+        }\n+    }\n+\n+    function checkCertificatePresentInHeader(http:Request req, string apiName, string apiVersion) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request header.\");\n+        string headerValue = req.getHeader(self.headerName);\n+        if (headerValue != \"\") {\n+            var cacheKey = headerValue + apiName + apiVersion;\n+            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n+            if (isExistCertCache is boolean) {\n+                if (!isExistCertCache) {\n+                    printError(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n+                    \"Certificate validity returned as false from cache. This is due to either certificat missing in \" +\n+                    \"trust store or certificate alias is missing in the config, where apis are mapped with list \" +\n+                    \"of aliases.\");\n+                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n+                    return false;\n+                } else {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status using request header: PASSED\");\n+                    return true;\n+                }\n+            } else {\n+                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n+                if (aliasFromHeaderCert is error) {\n+                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n+                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                }\n+                else {\n+                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n+                    self.apiCertificateList);\n+                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n+                        if(!isExistAlias) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTg3NzQ3OnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjo0MDozNVrOGi1N5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjo0MDozNVrOGi1N5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NjY3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \"with the certificate\");\n          \n          \n            \n                                        \"with the certificate\");", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439176676", "createdAt": "2020-06-12T02:40:35Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n+                    doMTSLFilterRequest(req, invocationContext);\n                 } else {\n-                    handle|error certificateAlias = getAliasFromRequest(cert.toString());\n-                    if (certificateAlias is error) {\n-                        setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                        return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                    return mutualSSLStatus;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    function checkCertificatePresentInContext(http:Request req, string apiName, string apiVersion,\n+                    boolean isValidateCertificateWithAPI) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request context.\");\n+        string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n+        var cacheKey = cert.toString() + apiName + apiVersion;\n+        var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n+        if (isExistCertCache is boolean)    {\n+            if (!isExistCertCache) {\n+                printError(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n+                \"Certificate validity returned as false from cache. This is due to either certificat missing in trust\" +\n+                \" store or certificate alias is missing in the config, where apis are mapped with list of aliases.\");\n+                return false;\n+            }\n+            return true;\n+        } else {\n+            handle|error certificateAlias = getAliasFromRequest(cert.toString());\n+            if (certificateAlias is error) {\n+                setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n+                return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+            }\n+            if (certificateAlias is handle) {\n+                //Only if 'isValidateCertificateWithAPI' true then certificate should be cross checked with the\n+                //alias list provided in the config. Otherwise no need to cross check with the alias list\n+                //in micro-gw.conf.\n+                boolean isExistAlias = (isValidateCertificateWithAPI) ? isExistApiAlias(apiVersion, apiName,\n+                                                        certificateAlias.toString(),self.apiCertificateList) : true;\n+                if (!isExistAlias || certificateAlias.toString() == \"\") {\n+                    if(!isExistAlias) {\n+                        printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n+                    \"with the certificate\");\n+                    } else if (certificateAlias.toString() == \"\") {\n+                        printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. Certificate alias not \" +\n+                        \"found in the trust store\");\n                     }\n-                    if (certificateAlias is handle ) {\n-                        boolean isExistAlias = isExistApiAlias(apiVersion, apiName, certificateAlias.toString(),\n-                        self.apiCertificateList);\n-                        if (!isExistAlias || certificateAlias.toString() == \"\") {\n-                            printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                            \"with the certificate\");\n-                            self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                    self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n+                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n+                    return false;\n+                }\n+            }\n+            self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n+            printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status using request context: PASSED \");\n+            return true;\n+        }\n+    }\n+\n+    function checkCertificatePresentInHeader(http:Request req, string apiName, string apiVersion) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request header.\");\n+        string headerValue = req.getHeader(self.headerName);\n+        if (headerValue != \"\") {\n+            var cacheKey = headerValue + apiName + apiVersion;\n+            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n+            if (isExistCertCache is boolean) {\n+                if (!isExistCertCache) {\n+                    printError(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n+                    \"Certificate validity returned as false from cache. This is due to either certificat missing in \" +\n+                    \"trust store or certificate alias is missing in the config, where apis are mapped with list \" +\n+                    \"of aliases.\");\n+                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n+                    return false;\n+                } else {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status using request header: PASSED\");\n+                    return true;\n+                }\n+            } else {\n+                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n+                if (aliasFromHeaderCert is error) {\n+                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n+                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                }\n+                else {\n+                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n+                    self.apiCertificateList);\n+                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n+                        if(!isExistAlias) {\n+                            printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n+                        \"with the certificate\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTg3OTM5OnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/mutualssl/CertificateUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjo0MTo0OVrOGi1PAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjo0MTo0OVrOGi1PAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3Njk2MQ==", "bodyText": "explicit else note required", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439176961", "createdAt": "2020-06-12T02:41:49Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/mutualssl/CertificateUtils.java", "diffHunk": "@@ -69,17 +77,21 @@ public static String getAliasFromTrustStore(X509Certificate certificate, KeyStor\n     /**\n      * Used to get the certificate alias for a certificate which is get from the Request .\n      */\n-    public static String getAliasFromRequest(String certB64) throws java.security.cert.CertificateException,\n-            KeyStoreException {\n-        byte[] decoded = java.util.Base64.getDecoder().decode(certB64);\n-        java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate)\n-                CertificateFactory.getInstance(\"X.509\")\n-                .generateCertificate(new ByteArrayInputStream(decoded));\n-        String certificateAlias = LoadKeyStore.trustStore.getCertificateAlias(cert);\n-        if (certificateAlias != null) {\n-            return certificateAlias;\n-        } else {\n-            return \"\";\n+    public static String getAliasFromRequest(String certB64) {\n+        try {\n+            byte[] decoded = java.util.Base64.getDecoder().decode(certB64);\n+            java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) CertificateFactory\n+                    .getInstance(\"X.509\").generateCertificate(new ByteArrayInputStream(decoded));\n+            String certificateAlias = LoadKeyStore.trustStore.getCertificateAlias(cert);\n+            if (certificateAlias != null) {\n+                return certificateAlias;\n+            } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTg3OTc4OnYy", "diffSide": "RIGHT", "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/mutualssl/CertificateUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjo0MjowNlrOGi1POw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjo0MjowNlrOGi1POw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NzAxOQ==", "bodyText": "explicit else not required", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439177019", "createdAt": "2020-06-12T02:42:06Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/mutualssl/CertificateUtils.java", "diffHunk": "@@ -34,19 +37,24 @@\n  * This class is responsible for do certificate level functionalities.\n  */\n public class CertificateUtils {\n+    private static final Logger log = LogManager.getLogger(CertificateUtils.class);\n \n-    public static String getAliasFromHeaderCert(String base64EncodedCertificate) throws  KeyStoreException,\n-            java.security.cert.CertificateException, CertificateException {\n-        base64EncodedCertificate = URLDecoder.decode(base64EncodedCertificate).\n-                replaceAll(Constants.BEGIN_CERTIFICATE_STRING, \"\")\n-                .replaceAll(Constants.END_CERTIFICATE_STRING, \"\");\n-        byte[] bytes = Base64.decodeBase64(base64EncodedCertificate);\n-        InputStream inputStream = new ByteArrayInputStream(bytes);\n-        X509Certificate x509Certificate = X509Certificate.getInstance(inputStream);\n-        if (getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore) != null) {\n-            return getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore);\n-        } else {\n-            return \"\";\n+    public static String getAliasFromHeaderCert(String base64EncodedCertificate) {\n+        try {\n+            base64EncodedCertificate = URLDecoder.decode(base64EncodedCertificate).\n+                    replaceAll(Constants.BEGIN_CERTIFICATE_STRING, \"\").replaceAll(Constants.END_CERTIFICATE_STRING, \"\");\n+            byte[] bytes = Base64.decodeBase64(base64EncodedCertificate);\n+            InputStream inputStream = new ByteArrayInputStream(bytes);\n+            X509Certificate x509Certificate = X509Certificate.getInstance(inputStream);\n+            if (getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore) != null) {\n+                return getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore);\n+            } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1250, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}