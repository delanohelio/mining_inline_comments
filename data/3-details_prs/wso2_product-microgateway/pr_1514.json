{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwODE0MDky", "number": 1514, "title": "Init cpp filters", "bodyText": "Purpose\n\nThis PR will add the following,\nenvoy source code as a submodule\nadd a stream filter \"envoy.mgw\" with the following functionality\n\nability to modify request payload.\nwhen external authz ok response added new payload to metadata, the \"envoy.mgw\" wil modify the request body.\n\nIssues\n\nFixes #1443\nAutomation tests\n\nUnit tests added: No\nIntegration tests added: No\n\nTested environments\n\ncatalina\n\nMaintainers: Check before merge\n\n Assigned 'Type' label\n Assigned the project\n Validated respective github issues\n Assigned milestone to the github issue(s)", "createdAt": "2020-12-02T07:28:44Z", "url": "https://github.com/wso2/product-microgateway/pull/1514", "merged": true, "mergeCommit": {"oid": "5430681983902ab0ecdd7b0c71b6667c18663be1"}, "closed": true, "closedAt": "2020-12-18T13:16:52Z", "author": {"login": "AmaliMatharaarachchi"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdiJZGGgH2gAyNTMwODE0MDkyOmNmNjY5ODc0NWFlODRhOWYyYWVmM2Y5Y2IyYTg2NjhlNzFlOTRkOTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdnArmJAFqTU1NDQ1Mjc3MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "cf6698745ae84a9f2aef3f9cb2a8668e71e94d90", "author": {"user": {"login": "AmaliMatharaarachchi", "name": "Amali Matharaarachchi"}}, "url": "https://github.com/wso2/product-microgateway/commit/cf6698745ae84a9f2aef3f9cb2a8668e71e94d90", "committedDate": "2020-12-02T07:27:13Z", "message": "init mgw envoy cpp filter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a43e9830de4c129cde5d8d413a271c08ab844416", "author": {"user": {"login": "AmaliMatharaarachchi", "name": "Amali Matharaarachchi"}}, "url": "https://github.com/wso2/product-microgateway/commit/a43e9830de4c129cde5d8d413a271c08ab844416", "committedDate": "2020-12-02T07:38:23Z", "message": "Add do_ci.sh"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ac00b83aaffc3a9763f395b979d5f257ea3a7cd", "author": {"user": {"login": "AmaliMatharaarachchi", "name": "Amali Matharaarachchi"}}, "url": "https://github.com/wso2/product-microgateway/commit/2ac00b83aaffc3a9763f395b979d5f257ea3a7cd", "committedDate": "2020-12-07T06:03:31Z", "message": "Add comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868", "author": {"user": {"login": "AmaliMatharaarachchi", "name": "Amali Matharaarachchi"}}, "url": "https://github.com/wso2/product-microgateway/commit/198ffdea76c450f6f95ed46c98fa44f0afe32868", "committedDate": "2020-12-07T06:55:55Z", "message": "fix typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1OTk1MzIw", "url": "https://github.com/wso2/product-microgateway/pull/1514#pullrequestreview-545995320", "createdAt": "2020-12-07T10:04:37Z", "commit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDowNDozN1rOIAe90w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDowNDozN1rOIAe90w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM3ODI1OQ==", "bodyText": "Storing the payload in a class level variable would cause issues in multithreaded approaches.", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537378259", "createdAt": "2020-12-07T10:04:37Z", "author": {"login": "jsdjayanga"}, "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());\n+  //if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+  // if stream is not ended, stop continueing to other filters and buffer. \n+  if (!end_stream) {\n+    return Http::FilterHeadersStatus::StopIteration;\n+  }\n+  //once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n+\n+  // if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  ENVOY_LOG(trace, \"decodeData with data = {} , end_stream = {}\", data.toString(), end_stream);\n+  // if stream is not ended, stop continueing to other filters and buffer.\n+  if (!end_stream) {\n+    return Http::FilterDataStatus::StopIterationAndBuffer;\n+  }\n+  // once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+void Filter::setPayload(std::string new_payload, const Buffer::Instance* decoding_buffer,\n+                     Http::RequestHeaderMap* req_headers) {\n+  ENVOY_LOG(debug, \"Modifying payload ...\");\n+  // create a new buffer instance with new payload data.\n+  Buffer::OwnedImpl modified_body(new_payload);\n+\n+  //if we never got a payload from the downstream/ header only request.\n+  if (decoding_buffer == nullptr) {\n+    // We are not streaming back this this payload data so we set streaming_filter = false.\n+    req_callbacks_->addDecodedData(modified_body, false);\n+  }\n+  else {\n+    // Since we modifying the existing payload, we drain the data buffer and add new data.\n+    req_callbacks_->modifyDecodingBuffer([&modified_body](Buffer::Instance& data) {\n+      data.drain(data.length());\n+      data.move(modified_body);\n+    });\n+  }\n+  // Since we modified the payload, need to set new content length.\n+  decoding_buffer = req_callbacks_->decodingBuffer();\n+  req_headers->setContentLength(decoding_buffer->length());\n+  ENVOY_LOG(debug, \"payload successfully modified\");\n+}\n+\n+bool Filter::readMetadata(const envoy::config::core::v3::Metadata* metadata) {\n+  std::string jsonJWTPayload;\n+  // We read metadata under ext_authz filter and if find a key \"payload\", \n+  // then decide to modify the payload.\n+  std::string PayloadMetadataKey = \"payload\";\n+  // Reading metadata under external authorization\n+  const auto* payload = &Config::Metadata::metadataValue(\n+      metadata, HttpFilterNames::get().ExtAuthorization, PayloadMetadataKey);\n+\n+  if (payload != nullptr && (payload->kind_case() == ProtobufWkt::Value::kStringValue)) {\n+    modified_body_ = payload->string_value();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 126}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1OTk3MTc2", "url": "https://github.com/wso2/product-microgateway/pull/1514#pullrequestreview-545997176", "createdAt": "2020-12-07T10:06:51Z", "commit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDowNjo1MVrOIAfDnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDowNjo1MVrOIAfDnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM3OTc0Mw==", "bodyText": "If method decodeHeaders() is called before setDecoderFilterCallbacks() method, code will break at this line", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537379743", "createdAt": "2020-12-07T10:06:51Z", "author": {"login": "jsdjayanga"}, "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MDA2NTU2", "url": "https://github.com/wso2/product-microgateway/pull/1514#pullrequestreview-546006556", "createdAt": "2020-12-07T10:18:21Z", "commit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDoxODoyMVrOIAfiUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDoxODoyMVrOIAfiUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4NzYwMQ==", "bodyText": "What is the usage of this variable?", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537387601", "createdAt": "2020-12-07T10:18:21Z", "author": {"login": "jsdjayanga"}, "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());\n+  //if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+  // if stream is not ended, stop continueing to other filters and buffer. \n+  if (!end_stream) {\n+    return Http::FilterHeadersStatus::StopIteration;\n+  }\n+  //once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n+\n+  // if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  ENVOY_LOG(trace, \"decodeData with data = {} , end_stream = {}\", data.toString(), end_stream);\n+  // if stream is not ended, stop continueing to other filters and buffer.\n+  if (!end_stream) {\n+    return Http::FilterDataStatus::StopIterationAndBuffer;\n+  }\n+  // once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+void Filter::setPayload(std::string new_payload, const Buffer::Instance* decoding_buffer,\n+                     Http::RequestHeaderMap* req_headers) {\n+  ENVOY_LOG(debug, \"Modifying payload ...\");\n+  // create a new buffer instance with new payload data.\n+  Buffer::OwnedImpl modified_body(new_payload);\n+\n+  //if we never got a payload from the downstream/ header only request.\n+  if (decoding_buffer == nullptr) {\n+    // We are not streaming back this this payload data so we set streaming_filter = false.\n+    req_callbacks_->addDecodedData(modified_body, false);\n+  }\n+  else {\n+    // Since we modifying the existing payload, we drain the data buffer and add new data.\n+    req_callbacks_->modifyDecodingBuffer([&modified_body](Buffer::Instance& data) {\n+      data.drain(data.length());\n+      data.move(modified_body);\n+    });\n+  }\n+  // Since we modified the payload, need to set new content length.\n+  decoding_buffer = req_callbacks_->decodingBuffer();\n+  req_headers->setContentLength(decoding_buffer->length());\n+  ENVOY_LOG(debug, \"payload successfully modified\");\n+}\n+\n+bool Filter::readMetadata(const envoy::config::core::v3::Metadata* metadata) {\n+  std::string jsonJWTPayload;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 117}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MDA2ODQ2", "url": "https://github.com/wso2/product-microgateway/pull/1514#pullrequestreview-546006846", "createdAt": "2020-12-07T10:18:41Z", "commit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDoxODo0MVrOIAfjTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDoxODo0MVrOIAfjTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4Nzg1NA==", "bodyText": "This can be a const", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537387854", "createdAt": "2020-12-07T10:18:41Z", "author": {"login": "jsdjayanga"}, "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());\n+  //if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+  // if stream is not ended, stop continueing to other filters and buffer. \n+  if (!end_stream) {\n+    return Http::FilterHeadersStatus::StopIteration;\n+  }\n+  //once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n+\n+  // if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  ENVOY_LOG(trace, \"decodeData with data = {} , end_stream = {}\", data.toString(), end_stream);\n+  // if stream is not ended, stop continueing to other filters and buffer.\n+  if (!end_stream) {\n+    return Http::FilterDataStatus::StopIterationAndBuffer;\n+  }\n+  // once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+void Filter::setPayload(std::string new_payload, const Buffer::Instance* decoding_buffer,\n+                     Http::RequestHeaderMap* req_headers) {\n+  ENVOY_LOG(debug, \"Modifying payload ...\");\n+  // create a new buffer instance with new payload data.\n+  Buffer::OwnedImpl modified_body(new_payload);\n+\n+  //if we never got a payload from the downstream/ header only request.\n+  if (decoding_buffer == nullptr) {\n+    // We are not streaming back this this payload data so we set streaming_filter = false.\n+    req_callbacks_->addDecodedData(modified_body, false);\n+  }\n+  else {\n+    // Since we modifying the existing payload, we drain the data buffer and add new data.\n+    req_callbacks_->modifyDecodingBuffer([&modified_body](Buffer::Instance& data) {\n+      data.drain(data.length());\n+      data.move(modified_body);\n+    });\n+  }\n+  // Since we modified the payload, need to set new content length.\n+  decoding_buffer = req_callbacks_->decodingBuffer();\n+  req_headers->setContentLength(decoding_buffer->length());\n+  ENVOY_LOG(debug, \"payload successfully modified\");\n+}\n+\n+bool Filter::readMetadata(const envoy::config::core::v3::Metadata* metadata) {\n+  std::string jsonJWTPayload;\n+  // We read metadata under ext_authz filter and if find a key \"payload\", \n+  // then decide to modify the payload.\n+  std::string PayloadMetadataKey = \"payload\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 120}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MTM2OTAw", "url": "https://github.com/wso2/product-microgateway/pull/1514#pullrequestreview-546136900", "createdAt": "2020-12-07T13:16:25Z", "commit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzoxNjoyNVrOIAmQWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzoxODo0NVrOIAmWLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ5NzY5MQ==", "bodyText": "Refactor trace logs. avoid toString()", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537497691", "createdAt": "2020-12-07T13:16:25Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());\n+  //if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+  // if stream is not ended, stop continueing to other filters and buffer. \n+  if (!end_stream) {\n+    return Http::FilterHeadersStatus::StopIteration;\n+  }\n+  //once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n+\n+  // if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  ENVOY_LOG(trace, \"decodeData with data = {} , end_stream = {}\", data.toString(), end_stream);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ5ODUyMQ==", "bodyText": "Let's drain the buffer since we modify the payload anyway. to avoid complications like buffer overflows.", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537498521", "createdAt": "2020-12-07T13:17:37Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());\n+  //if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+  // if stream is not ended, stop continueing to other filters and buffer. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ5ODgyNw==", "bodyText": "Check and handle if\u00a0ending stream happens in decodeTrailers.", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537498827", "createdAt": "2020-12-07T13:18:10Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ5OTE4MA==", "bodyText": "Need a release build script for the envoy image", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537499180", "createdAt": "2020-12-07T13:18:45Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "envoy-filters/ci/do_ci.sh", "diffHunk": "@@ -0,0 +1,35 @@\n+#!/bin/bash -e\n+\n+# TODO (amalimatharaarachchi) Write a release build script.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868"}, "originalPosition": 3}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fade6cc81cd67c608e3bbeb6d93bdea9d7e6b047", "author": {"user": {"login": "AmaliMatharaarachchi", "name": "Amali Matharaarachchi"}}, "url": "https://github.com/wso2/product-microgateway/commit/fade6cc81cd67c608e3bbeb6d93bdea9d7e6b047", "committedDate": "2020-12-08T04:44:30Z", "message": "fix review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87ac1eec95e8895ea71024222c92383b6cad3d70", "author": {"user": {"login": "AmaliMatharaarachchi", "name": "Amali Matharaarachchi"}}, "url": "https://github.com/wso2/product-microgateway/commit/87ac1eec95e8895ea71024222c92383b6cad3d70", "committedDate": "2020-12-08T04:54:48Z", "message": "perf improvement"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0NDUyNzcw", "url": "https://github.com/wso2/product-microgateway/pull/1514#pullrequestreview-554452770", "createdAt": "2020-12-17T10:07:54Z", "commit": {"oid": "87ac1eec95e8895ea71024222c92383b6cad3d70"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1027, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}