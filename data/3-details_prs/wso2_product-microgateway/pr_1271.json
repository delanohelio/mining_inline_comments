{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNDU2OTYy", "number": 1271, "title": "Fix #1270 - Improve per API mutual ssl validation logic", "bodyText": "Purpose\nDone the following improvements\n\n\nIf isClientCertificateValidationEnabled is enabled in the config at the moment we do not validate the certificate present in the header. If certificate present in header we should always validate it. If isClientCertificateValidationEnabled config is enabled we should validate both certificate in header and certificate available in the context as well. This certificate presents in the header only if LB is fronted with mgw. So in that case we need to always verify the actual client whose certificate available in the header. The certificate available in the context will always be the LB certificate. So based on the isClientCertificateValidationEnabled config we need to verify the certificate in the context(or the certificate of LB)\n\n\nAnd also when header is present then if isClientCertificateValidationEnabled config also enabled, then when validating certificate in context we should not validate the certificate in the alias list provided in the micro-gw.conf file. This is because the certificate in the context will always be the LB certificate.\n\n\nIssues\n\nFixes #1270\nAutomation tests\n\nUnit tests added: Yes/No\nIntegration tests added: Yes/No\n\nTested environments\n\nNot Tested\n\nMaintainers: Check before merge\n\n Assigned 'Type' label\n Assigned the project\n Validated respective github issues\n Assigned milestone to the github issue(s)", "createdAt": "2020-06-10T13:30:05Z", "url": "https://github.com/wso2/product-microgateway/pull/1271", "merged": true, "mergeCommit": {"oid": "9d121801c2c26b830a3e5b17ac667f11bdc4b6b6"}, "closed": true, "closedAt": "2020-06-12T06:37:54Z", "author": {"login": "Rajith90"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcp5qkqAH2gAyNDMyNDU2OTYyOjFlOGVkODVkMTcyNWQyYjdiODBlYjhjYjc4MGI2ZjdjZjE3N2Q2NzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcqcwQSgH2gAyNDMyNDU2OTYyOjliOWE5MjhmNmNiMzQwYWE4NjFkNWE4OTQ5MGUwNjYyNDI0MDQ2ZDQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675", "author": {"user": {"login": "Rajith90", "name": "Rajith Roshan"}}, "url": "https://github.com/wso2/product-microgateway/commit/1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675", "committedDate": "2020-06-10T13:28:04Z", "message": "Fix #1270 - Improve per API mutual ssl validation logic"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NzQ3NzQ2", "url": "https://github.com/wso2/product-microgateway/pull/1271#pullrequestreview-428747746", "createdAt": "2020-06-11T09:34:05Z", "commit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwOTozNDowNVrOGiVzyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMDowMDoyNVrOGiWrhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2MjA5MQ==", "bodyText": "In conf template, it says;\n# Header name apend by the **load balancer**?\ncertificateHeadername = \"Header name given by the load balancer\"\n# **Is client certificate validation enable** ?\nisClientCertificateValidationEnabled = true\n\nI feel these comments are confusing. Better to improve there as well.", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r438662091", "createdAt": "2020-06-11T09:34:05Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY3MjUwMQ==", "bodyText": "if only mutualSSLStatus==false, is a valid scenario here, we have to set the error to the invocation context before returning false.", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r438672501", "createdAt": "2020-06-11T09:53:18Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n+                    doMTSLFilterRequest(req, invocationContext);\n                 } else {\n-                    handle|error certificateAlias = getAliasFromRequest(cert.toString());\n-                    if (certificateAlias is error) {\n-                        setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                        return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                    return mutualSSLStatus;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY3NDY2MQ==", "bodyText": "If checkCertificatePresentInContext and checkCertificatePresentInHeader have duplicate logic, moving them to a util method or so would be better.", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r438674661", "createdAt": "2020-06-11T09:57:21Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n+                    doMTSLFilterRequest(req, invocationContext);\n                 } else {\n-                    handle|error certificateAlias = getAliasFromRequest(cert.toString());\n-                    if (certificateAlias is error) {\n-                        setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                        return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                    return mutualSSLStatus;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    function checkCertificatePresentInContext(http:Request req, string apiName, string apiVersion,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY3NjM1OA==", "bodyText": "If when throwing the error here will also log the error msg, then calling log.error() again may not be needed.", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r438676358", "createdAt": "2020-06-11T10:00:25Z", "author": {"login": "AmaliMatharaarachchi"}, "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/mutualssl/CertificateUtils.java", "diffHunk": "@@ -34,19 +37,24 @@\n  * This class is responsible for do certificate level functionalities.\n  */\n public class CertificateUtils {\n+    private static final Logger log = LogManager.getLogger(CertificateUtils.class);\n \n-    public static String getAliasFromHeaderCert(String base64EncodedCertificate) throws  KeyStoreException,\n-            java.security.cert.CertificateException, CertificateException {\n-        base64EncodedCertificate = URLDecoder.decode(base64EncodedCertificate).\n-                replaceAll(Constants.BEGIN_CERTIFICATE_STRING, \"\")\n-                .replaceAll(Constants.END_CERTIFICATE_STRING, \"\");\n-        byte[] bytes = Base64.decodeBase64(base64EncodedCertificate);\n-        InputStream inputStream = new ByteArrayInputStream(bytes);\n-        X509Certificate x509Certificate = X509Certificate.getInstance(inputStream);\n-        if (getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore) != null) {\n-            return getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore);\n-        } else {\n-            return \"\";\n+    public static String getAliasFromHeaderCert(String base64EncodedCertificate) {\n+        try {\n+            base64EncodedCertificate = URLDecoder.decode(base64EncodedCertificate).\n+                    replaceAll(Constants.BEGIN_CERTIFICATE_STRING, \"\").replaceAll(Constants.END_CERTIFICATE_STRING, \"\");\n+            byte[] bytes = Base64.decodeBase64(base64EncodedCertificate);\n+            InputStream inputStream = new ByteArrayInputStream(bytes);\n+            X509Certificate x509Certificate = X509Certificate.getInstance(inputStream);\n+            if (getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore) != null) {\n+                return getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore);\n+            } else {\n+                return \"\";\n+            }\n+        } catch (KeyStoreException | java.security.cert.CertificateException | CertificateException e) {\n+            String msg = \"Error while decoding certificate present in the header and validating with the trust store.\";\n+            log.error(msg, e);\n+            throw ErrorUtils.getBallerinaError(msg, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4ODI3MDQx", "url": "https://github.com/wso2/product-microgateway/pull/1271#pullrequestreview-428827041", "createdAt": "2020-06-11T11:38:11Z", "commit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5NDI0MzM2", "url": "https://github.com/wso2/product-microgateway/pull/1271#pullrequestreview-429424336", "createdAt": "2020-06-12T02:36:11Z", "commit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjozNjoxMVrOGi1KUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjo0MjowNlrOGi1POw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NTc2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if(mutualSSLStatus is boolean && mutualSSLStatus) {\n          \n          \n            \n                                    if (mutualSSLStatus is boolean && mutualSSLStatus) {", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439175763", "createdAt": "2020-06-12T02:36:11Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NTk2OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if(mutualSSLStatus is boolean && mutualSSLStatus) {\n          \n          \n            \n                            if (mutualSSLStatus is boolean && mutualSSLStatus) {", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439175969", "createdAt": "2020-06-12T02:37:14Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NjIxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if(!isExistAlias) {\n          \n          \n            \n                                if (!isExistAlias) {", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439176216", "createdAt": "2020-06-12T02:38:23Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n+                    doMTSLFilterRequest(req, invocationContext);\n                 } else {\n-                    handle|error certificateAlias = getAliasFromRequest(cert.toString());\n-                    if (certificateAlias is error) {\n-                        setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                        return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                    return mutualSSLStatus;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    function checkCertificatePresentInContext(http:Request req, string apiName, string apiVersion,\n+                    boolean isValidateCertificateWithAPI) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request context.\");\n+        string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n+        var cacheKey = cert.toString() + apiName + apiVersion;\n+        var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n+        if (isExistCertCache is boolean)    {\n+            if (!isExistCertCache) {\n+                printError(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n+                \"Certificate validity returned as false from cache. This is due to either certificat missing in trust\" +\n+                \" store or certificate alias is missing in the config, where apis are mapped with list of aliases.\");\n+                return false;\n+            }\n+            return true;\n+        } else {\n+            handle|error certificateAlias = getAliasFromRequest(cert.toString());\n+            if (certificateAlias is error) {\n+                setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n+                return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+            }\n+            if (certificateAlias is handle) {\n+                //Only if 'isValidateCertificateWithAPI' true then certificate should be cross checked with the\n+                //alias list provided in the config. Otherwise no need to cross check with the alias list\n+                //in micro-gw.conf.\n+                boolean isExistAlias = (isValidateCertificateWithAPI) ? isExistApiAlias(apiVersion, apiName,\n+                                                        certificateAlias.toString(),self.apiCertificateList) : true;\n+                if (!isExistAlias || certificateAlias.toString() == \"\") {\n+                    if(!isExistAlias) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NjQxMg==", "bodyText": "Is the the key (KEY_AUTHN_FILTER) we want to use? not a different key for mutualssl handler?", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439176412", "createdAt": "2020-06-12T02:39:23Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n+                    doMTSLFilterRequest(req, invocationContext);\n                 } else {\n-                    handle|error certificateAlias = getAliasFromRequest(cert.toString());\n-                    if (certificateAlias is error) {\n-                        setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                        return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                    return mutualSSLStatus;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    function checkCertificatePresentInContext(http:Request req, string apiName, string apiVersion,\n+                    boolean isValidateCertificateWithAPI) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request context.\");\n+        string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n+        var cacheKey = cert.toString() + apiName + apiVersion;\n+        var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n+        if (isExistCertCache is boolean)    {\n+            if (!isExistCertCache) {\n+                printError(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n+                \"Certificate validity returned as false from cache. This is due to either certificat missing in trust\" +\n+                \" store or certificate alias is missing in the config, where apis are mapped with list of aliases.\");\n+                return false;\n+            }\n+            return true;\n+        } else {\n+            handle|error certificateAlias = getAliasFromRequest(cert.toString());\n+            if (certificateAlias is error) {\n+                setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n+                return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+            }\n+            if (certificateAlias is handle) {\n+                //Only if 'isValidateCertificateWithAPI' true then certificate should be cross checked with the\n+                //alias list provided in the config. Otherwise no need to cross check with the alias list\n+                //in micro-gw.conf.\n+                boolean isExistAlias = (isValidateCertificateWithAPI) ? isExistApiAlias(apiVersion, apiName,\n+                                                        certificateAlias.toString(),self.apiCertificateList) : true;\n+                if (!isExistAlias || certificateAlias.toString() == \"\") {\n+                    if(!isExistAlias) {\n+                        printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n+                    \"with the certificate\");\n+                    } else if (certificateAlias.toString() == \"\") {\n+                        printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. Certificate alias not \" +\n+                        \"found in the trust store\");\n                     }\n-                    if (certificateAlias is handle ) {\n-                        boolean isExistAlias = isExistApiAlias(apiVersion, apiName, certificateAlias.toString(),\n-                        self.apiCertificateList);\n-                        if (!isExistAlias || certificateAlias.toString() == \"\") {\n-                            printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                            \"with the certificate\");\n-                            self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                    self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n+                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n+                    return false;\n+                }\n+            }\n+            self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n+            printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status using request context: PASSED \");\n+            return true;\n+        }\n+    }\n+\n+    function checkCertificatePresentInHeader(http:Request req, string apiName, string apiVersion) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request header.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NjQ3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            else {\n          \n          \n            \n                            } else {", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439176478", "createdAt": "2020-06-12T02:39:43Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n+                    doMTSLFilterRequest(req, invocationContext);\n                 } else {\n-                    handle|error certificateAlias = getAliasFromRequest(cert.toString());\n-                    if (certificateAlias is error) {\n-                        setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                        return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                    return mutualSSLStatus;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    function checkCertificatePresentInContext(http:Request req, string apiName, string apiVersion,\n+                    boolean isValidateCertificateWithAPI) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request context.\");\n+        string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n+        var cacheKey = cert.toString() + apiName + apiVersion;\n+        var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n+        if (isExistCertCache is boolean)    {\n+            if (!isExistCertCache) {\n+                printError(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n+                \"Certificate validity returned as false from cache. This is due to either certificat missing in trust\" +\n+                \" store or certificate alias is missing in the config, where apis are mapped with list of aliases.\");\n+                return false;\n+            }\n+            return true;\n+        } else {\n+            handle|error certificateAlias = getAliasFromRequest(cert.toString());\n+            if (certificateAlias is error) {\n+                setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n+                return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+            }\n+            if (certificateAlias is handle) {\n+                //Only if 'isValidateCertificateWithAPI' true then certificate should be cross checked with the\n+                //alias list provided in the config. Otherwise no need to cross check with the alias list\n+                //in micro-gw.conf.\n+                boolean isExistAlias = (isValidateCertificateWithAPI) ? isExistApiAlias(apiVersion, apiName,\n+                                                        certificateAlias.toString(),self.apiCertificateList) : true;\n+                if (!isExistAlias || certificateAlias.toString() == \"\") {\n+                    if(!isExistAlias) {\n+                        printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n+                    \"with the certificate\");\n+                    } else if (certificateAlias.toString() == \"\") {\n+                        printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. Certificate alias not \" +\n+                        \"found in the trust store\");\n                     }\n-                    if (certificateAlias is handle ) {\n-                        boolean isExistAlias = isExistApiAlias(apiVersion, apiName, certificateAlias.toString(),\n-                        self.apiCertificateList);\n-                        if (!isExistAlias || certificateAlias.toString() == \"\") {\n-                            printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                            \"with the certificate\");\n-                            self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                    self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n+                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n+                    return false;\n+                }\n+            }\n+            self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n+            printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status using request context: PASSED \");\n+            return true;\n+        }\n+    }\n+\n+    function checkCertificatePresentInHeader(http:Request req, string apiName, string apiVersion) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request header.\");\n+        string headerValue = req.getHeader(self.headerName);\n+        if (headerValue != \"\") {\n+            var cacheKey = headerValue + apiName + apiVersion;\n+            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n+            if (isExistCertCache is boolean) {\n+                if (!isExistCertCache) {\n+                    printError(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n+                    \"Certificate validity returned as false from cache. This is due to either certificat missing in \" +\n+                    \"trust store or certificate alias is missing in the config, where apis are mapped with list \" +\n+                    \"of aliases.\");\n+                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n+                    return false;\n+                } else {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status using request header: PASSED\");\n+                    return true;\n+                }\n+            } else {\n+                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n+                if (aliasFromHeaderCert is error) {\n+                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n+                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                }\n+                else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NjU0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if(!isExistAlias) {\n          \n          \n            \n                                    if (!isExistAlias) {", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439176540", "createdAt": "2020-06-12T02:39:59Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n+                    doMTSLFilterRequest(req, invocationContext);\n                 } else {\n-                    handle|error certificateAlias = getAliasFromRequest(cert.toString());\n-                    if (certificateAlias is error) {\n-                        setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                        return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                    return mutualSSLStatus;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    function checkCertificatePresentInContext(http:Request req, string apiName, string apiVersion,\n+                    boolean isValidateCertificateWithAPI) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request context.\");\n+        string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n+        var cacheKey = cert.toString() + apiName + apiVersion;\n+        var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n+        if (isExistCertCache is boolean)    {\n+            if (!isExistCertCache) {\n+                printError(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n+                \"Certificate validity returned as false from cache. This is due to either certificat missing in trust\" +\n+                \" store or certificate alias is missing in the config, where apis are mapped with list of aliases.\");\n+                return false;\n+            }\n+            return true;\n+        } else {\n+            handle|error certificateAlias = getAliasFromRequest(cert.toString());\n+            if (certificateAlias is error) {\n+                setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n+                return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+            }\n+            if (certificateAlias is handle) {\n+                //Only if 'isValidateCertificateWithAPI' true then certificate should be cross checked with the\n+                //alias list provided in the config. Otherwise no need to cross check with the alias list\n+                //in micro-gw.conf.\n+                boolean isExistAlias = (isValidateCertificateWithAPI) ? isExistApiAlias(apiVersion, apiName,\n+                                                        certificateAlias.toString(),self.apiCertificateList) : true;\n+                if (!isExistAlias || certificateAlias.toString() == \"\") {\n+                    if(!isExistAlias) {\n+                        printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n+                    \"with the certificate\");\n+                    } else if (certificateAlias.toString() == \"\") {\n+                        printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. Certificate alias not \" +\n+                        \"found in the trust store\");\n                     }\n-                    if (certificateAlias is handle ) {\n-                        boolean isExistAlias = isExistApiAlias(apiVersion, apiName, certificateAlias.toString(),\n-                        self.apiCertificateList);\n-                        if (!isExistAlias || certificateAlias.toString() == \"\") {\n-                            printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                            \"with the certificate\");\n-                            self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                    self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n+                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n+                    return false;\n+                }\n+            }\n+            self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n+            printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status using request context: PASSED \");\n+            return true;\n+        }\n+    }\n+\n+    function checkCertificatePresentInHeader(http:Request req, string apiName, string apiVersion) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request header.\");\n+        string headerValue = req.getHeader(self.headerName);\n+        if (headerValue != \"\") {\n+            var cacheKey = headerValue + apiName + apiVersion;\n+            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n+            if (isExistCertCache is boolean) {\n+                if (!isExistCertCache) {\n+                    printError(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n+                    \"Certificate validity returned as false from cache. This is due to either certificat missing in \" +\n+                    \"trust store or certificate alias is missing in the config, where apis are mapped with list \" +\n+                    \"of aliases.\");\n+                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n+                    return false;\n+                } else {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status using request header: PASSED\");\n+                    return true;\n+                }\n+            } else {\n+                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n+                if (aliasFromHeaderCert is error) {\n+                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n+                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                }\n+                else {\n+                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n+                    self.apiCertificateList);\n+                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n+                        if(!isExistAlias) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NjY3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \"with the certificate\");\n          \n          \n            \n                                        \"with the certificate\");", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439176676", "createdAt": "2020-06-12T02:40:35Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/handlers/mutualSSL_handler.bal", "diffHunk": "@@ -58,98 +58,155 @@ public type MutualSSLHandler object {\n         if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient) \n                 && req.mutualSslHandshake[STATUS] != PASSED) {\n             if (req.mutualSslHandshake[STATUS] == FAILED) {\n-                printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n+                printError(KEY_AUTHN_FILTER, \"MutualSSL handshake status: FAILED\");\n             }\n             // provided more generic error code to avoid security issues.\n             setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS); \n             return prepareAuthenticationError(\"Failed to authenticate with MutualSSL handler\");            \n         }\n         if (req.mutualSslHandshake[STATUS] == PASSED) {\n+            boolean | http:AuthenticationError mutualSSLStatus = false;\n             runtime:InvocationContext invocationContext = runtime:getInvocationContext();\n             if (mutualSSLVerifyClient is string && stringutils:equalsIgnoreCase(MANDATORY, mutualSSLVerifyClient)) {\n                 string apiVersion = invocationContext.attributes[API_VERSION_PROPERTY].toString();\n                 string apiName = invocationContext.attributes[API_NAME].toString();\n                 if (self.headerName != \"\" &&  req.hasHeader(self.headerName)) {\n+                    printDebug(KEY_AUTHN_FILTER, \"Mutual ssl expected header \" + self.headerName + \" present in the request\");\n+                    //If validation is disabled for client certificate present in the context , we should always\n+                    //validate the certificate present in the header.\n+                    //This scenario represents where mtls is required between client and mgw, but mtls is not enabled\n+                    //between LB and mgw. So microgateway only validates the certificate present in the header, which\n+                    //is the client certificate not the certificate in the context which is always going to be\n+                    //LB certificate but will not be available due to no MTLS between mgw and LB.\n                     if (!self.isClientCertificateValidationEnabled) {\n-                        string headerValue = req.getHeader(self.headerName);\n-                        if (headerValue != \"\") {\n-                            var cacheKey = headerValue + apiName + apiVersion;\n-                            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                            if (isExistCertCache is boolean) {\n-                                if (!isExistCertCache) {\n-                                    printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                                    \"API is not associated with the certificate\");\n-                                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                    return false;\n-                                } else {\n-                                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                    doMTSLFilterRequest(req, invocationContext);\n-                                    return true;\n-                                }\n-                            } else {\n-                                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n-                                if (aliasFromHeaderCert is error) {\n-                                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n-                                }\n-                                if (aliasFromHeaderCert is handle) {\n-                                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n-                                    self.apiCertificateList);\n-                                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n-                                        printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                                        \"with the certificate\");\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                                        setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                                        return false;\n-                                    } else {\n-                                        printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n-                                        doMTSLFilterRequest(req, invocationContext);\n-                                        self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n-                                        return true;\n-                                    }\n-                                }\n-\n-                            }\n-                        } else {\n-                            printDebug(KEY_AUTHN_FILTER, \"Header has empty value sent by the payload\");\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                        mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n+                    } else { // if client certificate validation enabled for the certificate present in context\n+                        //and header is also present then both should be validated.\n+                        //This is the scenario where both client certificate is also should be verified and mtls is\n+                        //also enabled between mgw and LB. So both client certificate present in the header should be\n+                        //validated and the LB certificate present in the context.\n+                        // When validating the certificate in the context we do not need to validate it with the alias\n+                        //list present in the config as this would always be the LB certificate.\n+                        mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, false);\n+                        if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                            mutualSSLStatus = self.checkCertificatePresentInHeader(req, apiName, apiVersion);\n                         }\n                     }\n+                } else {\n+                //If certificate not in the header, and mutual ssl client validation config is enabled, then\n+                // checking the certificate in request context is mandatory.(This case is when there is no LB fronted.)\n+                //And also cert should be validated against with the API alias list. This is because the certificate\n+                //available via the context would be the client certificate,not the LB one Hence the\n+                //'isValidateCertificateWithAPI' value is set as true.\n+                    mutualSSLStatus =  self.checkCertificatePresentInContext(req, apiName, apiVersion, true);\n                 }\n-                string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n-                var cacheKey = cert.toString() + apiName + apiVersion;\n-                var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n-                if (isExistCertCache is boolean)    {\n-                    if (!isExistCertCache) {\n-                        printDebug(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n-                        \"API is not associated with the certificate\");\n-                        return false;\n-                     }\n+                if(mutualSSLStatus is boolean && mutualSSLStatus) {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status: PASSED\");\n+                    doMTSLFilterRequest(req, invocationContext);\n                 } else {\n-                    handle|error certificateAlias = getAliasFromRequest(cert.toString());\n-                    if (certificateAlias is error) {\n-                        setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n-                        return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                    return mutualSSLStatus;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    function checkCertificatePresentInContext(http:Request req, string apiName, string apiVersion,\n+                    boolean isValidateCertificateWithAPI) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request context.\");\n+        string? cert = req.mutualSslHandshake[\"base64EncodedCert\"];\n+        var cacheKey = cert.toString() + apiName + apiVersion;\n+        var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n+        if (isExistCertCache is boolean)    {\n+            if (!isExistCertCache) {\n+                printError(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n+                \"Certificate validity returned as false from cache. This is due to either certificat missing in trust\" +\n+                \" store or certificate alias is missing in the config, where apis are mapped with list of aliases.\");\n+                return false;\n+            }\n+            return true;\n+        } else {\n+            handle|error certificateAlias = getAliasFromRequest(cert.toString());\n+            if (certificateAlias is error) {\n+                setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n+                return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+            }\n+            if (certificateAlias is handle) {\n+                //Only if 'isValidateCertificateWithAPI' true then certificate should be cross checked with the\n+                //alias list provided in the config. Otherwise no need to cross check with the alias list\n+                //in micro-gw.conf.\n+                boolean isExistAlias = (isValidateCertificateWithAPI) ? isExistApiAlias(apiVersion, apiName,\n+                                                        certificateAlias.toString(),self.apiCertificateList) : true;\n+                if (!isExistAlias || certificateAlias.toString() == \"\") {\n+                    if(!isExistAlias) {\n+                        printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n+                    \"with the certificate\");\n+                    } else if (certificateAlias.toString() == \"\") {\n+                        printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. Certificate alias not \" +\n+                        \"found in the trust store\");\n                     }\n-                    if (certificateAlias is handle ) {\n-                        boolean isExistAlias = isExistApiAlias(apiVersion, apiName, certificateAlias.toString(),\n-                        self.apiCertificateList);\n-                        if (!isExistAlias || certificateAlias.toString() == \"\") {\n-                            printDebug(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n-                            \"with the certificate\");\n-                            self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n-                            setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n-                            return false;\n+                    self.gatewayCache.addMutualSslCertificateCache(cacheKey, false);\n+                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n+                    return false;\n+                }\n+            }\n+            self.gatewayCache.addMutualSslCertificateCache(cacheKey, true);\n+            printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status using request context: PASSED \");\n+            return true;\n+        }\n+    }\n+\n+    function checkCertificatePresentInHeader(http:Request req, string apiName, string apiVersion) returns boolean | http:AuthenticationError {\n+        printDebug(KEY_AUTHN_FILTER, \"Checking the certificate present in the request header.\");\n+        string headerValue = req.getHeader(self.headerName);\n+        if (headerValue != \"\") {\n+            var cacheKey = headerValue + apiName + apiVersion;\n+            var isExistCertCache = self.gatewayCache.retrieveFromMutualSslCertificateCache(cacheKey);\n+            if (isExistCertCache is boolean) {\n+                if (!isExistCertCache) {\n+                    printError(KEY_AUTHN_FILTER,\"Mutual SSL authentication failure. \" +\n+                    \"Certificate validity returned as false from cache. This is due to either certificat missing in \" +\n+                    \"trust store or certificate alias is missing in the config, where apis are mapped with list \" +\n+                    \"of aliases.\");\n+                    setErrorMessageToInvocationContext(API_AUTH_INVALID_CREDENTIALS);\n+                    return false;\n+                } else {\n+                    printDebug(KEY_AUTHN_FILTER, \"MutualSSL handshake status using request header: PASSED\");\n+                    return true;\n+                }\n+            } else {\n+                handle|error aliasFromHeaderCert = getAliasFromHeaderCert(headerValue);\n+                if (aliasFromHeaderCert is error) {\n+                    setErrorMessageToInvocationContext(API_AUTH_GENERAL_ERROR);\n+                    return prepareAuthenticationError(\"Unclassified Authentication Failure\");\n+                }\n+                else {\n+                    boolean isExistAlias = isExistApiAlias(apiVersion, apiName, aliasFromHeaderCert.toString(),\n+                    self.apiCertificateList);\n+                    if (!isExistAlias || aliasFromHeaderCert.toString() == \"\") {\n+                        if(!isExistAlias) {\n+                            printError(KEY_AUTHN_FILTER, \"Mutual SSL authentication failure. API is not associated \" +\n+                        \"with the certificate\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3Njk2MQ==", "bodyText": "explicit else note required", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439176961", "createdAt": "2020-06-12T02:41:49Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/mutualssl/CertificateUtils.java", "diffHunk": "@@ -69,17 +77,21 @@ public static String getAliasFromTrustStore(X509Certificate certificate, KeyStor\n     /**\n      * Used to get the certificate alias for a certificate which is get from the Request .\n      */\n-    public static String getAliasFromRequest(String certB64) throws java.security.cert.CertificateException,\n-            KeyStoreException {\n-        byte[] decoded = java.util.Base64.getDecoder().decode(certB64);\n-        java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate)\n-                CertificateFactory.getInstance(\"X.509\")\n-                .generateCertificate(new ByteArrayInputStream(decoded));\n-        String certificateAlias = LoadKeyStore.trustStore.getCertificateAlias(cert);\n-        if (certificateAlias != null) {\n-            return certificateAlias;\n-        } else {\n-            return \"\";\n+    public static String getAliasFromRequest(String certB64) {\n+        try {\n+            byte[] decoded = java.util.Base64.getDecoder().decode(certB64);\n+            java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) CertificateFactory\n+                    .getInstance(\"X.509\").generateCertificate(new ByteArrayInputStream(decoded));\n+            String certificateAlias = LoadKeyStore.trustStore.getCertificateAlias(cert);\n+            if (certificateAlias != null) {\n+                return certificateAlias;\n+            } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NzAxOQ==", "bodyText": "explicit else not required", "url": "https://github.com/wso2/product-microgateway/pull/1271#discussion_r439177019", "createdAt": "2020-06-12T02:42:06Z", "author": {"login": "praminda"}, "path": "components/micro-gateway-core/src/main/java/org/wso2/micro/gateway/core/mutualssl/CertificateUtils.java", "diffHunk": "@@ -34,19 +37,24 @@\n  * This class is responsible for do certificate level functionalities.\n  */\n public class CertificateUtils {\n+    private static final Logger log = LogManager.getLogger(CertificateUtils.class);\n \n-    public static String getAliasFromHeaderCert(String base64EncodedCertificate) throws  KeyStoreException,\n-            java.security.cert.CertificateException, CertificateException {\n-        base64EncodedCertificate = URLDecoder.decode(base64EncodedCertificate).\n-                replaceAll(Constants.BEGIN_CERTIFICATE_STRING, \"\")\n-                .replaceAll(Constants.END_CERTIFICATE_STRING, \"\");\n-        byte[] bytes = Base64.decodeBase64(base64EncodedCertificate);\n-        InputStream inputStream = new ByteArrayInputStream(bytes);\n-        X509Certificate x509Certificate = X509Certificate.getInstance(inputStream);\n-        if (getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore) != null) {\n-            return getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore);\n-        } else {\n-            return \"\";\n+    public static String getAliasFromHeaderCert(String base64EncodedCertificate) {\n+        try {\n+            base64EncodedCertificate = URLDecoder.decode(base64EncodedCertificate).\n+                    replaceAll(Constants.BEGIN_CERTIFICATE_STRING, \"\").replaceAll(Constants.END_CERTIFICATE_STRING, \"\");\n+            byte[] bytes = Base64.decodeBase64(base64EncodedCertificate);\n+            InputStream inputStream = new ByteArrayInputStream(bytes);\n+            X509Certificate x509Certificate = X509Certificate.getInstance(inputStream);\n+            if (getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore) != null) {\n+                return getAliasFromTrustStore(x509Certificate, LoadKeyStore.trustStore);\n+            } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8ed85d1725d2b7b80eb8cb780b6f7cf177d675"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b9a928f6cb340aa861d5a89490e0662424046d4", "author": {"user": {"login": "Rajith90", "name": "Rajith Roshan"}}, "url": "https://github.com/wso2/product-microgateway/commit/9b9a928f6cb340aa861d5a89490e0662424046d4", "committedDate": "2020-06-12T06:20:57Z", "message": "Fix review suggestions"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1113, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}