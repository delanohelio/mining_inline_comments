{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0MjY5NzEx", "number": 2195, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMzoyNjozMlrODla9Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMDo1NDo1N1rODojGvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTY1NTI2OnYy", "diffSide": "LEFT", "path": "app/src/org/commcare/activities/FormAndDataSyncer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMzoyNjozMlrOFyTYrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMzoyNjozMlrOFyTYrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5MDczMg==", "bodyText": "Moved to formSubmissionHelper", "url": "https://github.com/dimagi/commcare-android/pull/2195#discussion_r388290732", "createdAt": "2020-03-05T13:26:32Z", "author": {"login": "shubham1g5"}, "path": "app/src/org/commcare/activities/FormAndDataSyncer.java", "diffHunk": "@@ -36,39 +36,29 @@\n  */\n public class FormAndDataSyncer {\n \n-    public FormAndDataSyncer() {\n+    protected FormAndDataSyncer() {\n     }\n \n-    /**\n-     * @return Were forms sent to the server by this method invocation?\n-     */\n-    public boolean checkAndStartUnsentFormsTask(SyncCapableCommCareActivity activity,\n-                                                final boolean syncAfterwards,\n-                                                boolean userTriggered) {\n-        SqlStorage<FormRecord> storage = CommCareApplication.instance().getUserStorage(FormRecord.class);\n-        FormRecord[] records = StorageUtils.getUnsentRecordsForCurrentApp(storage);\n+\n+    void startUnsentFormsTask(SyncCapableCommCareActivity activity,\n+                              final boolean syncAfterwards,\n+                              boolean userTriggered) {\n \n         // We only want to update the last upload sync time when it's a blocking sync\n         if (syncAfterwards) {\n             HiddenPreferences.updateLastUploadSyncAttemptTime();\n         }\n \n-        if (records.length > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fc4466b53a74d54268d70109537c70b1e899cb3"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTY1OTU1OnYy", "diffSide": "LEFT", "path": "app/src/org/commcare/activities/FormAndDataSyncer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMzoyNzo1NlrOFyTbYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMzoyNzo1NlrOFyTbYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5MTQyNg==", "bodyText": "Moved to FormSubmissionHelper", "url": "https://github.com/dimagi/commcare-android/pull/2195#discussion_r388291426", "createdAt": "2020-03-05T13:27:56Z", "author": {"login": "shubham1g5"}, "path": "app/src/org/commcare/activities/FormAndDataSyncer.java", "diffHunk": "@@ -142,14 +132,9 @@ protected void handleCancellation(SyncCapableCommCareActivity receiver) {\n         }\n \n         processAndSendTask.connect(activity);\n-        processAndSendTask.executeParallel(records);\n+        processAndSendTask.executeParallel();\n     }\n \n-    private static String getFormPostURL(final Context context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fc4466b53a74d54268d70109537c70b1e899cb3"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTcwMTg4OnYy", "diffSide": "LEFT", "path": "app/src/org/commcare/activities/SyncCapableCommCareActivity.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMzo0MDowMlrOFyT1Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMzo0MDowMlrOFyT1Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5ODAyNg==", "bodyText": "we now return a success result from upload forms task in case the # of forms to upload is 0 which in turn triggers the data pull.", "url": "https://github.com/dimagi/commcare-android/pull/2195#discussion_r388298026", "createdAt": "2020-03-05T13:40:02Z", "author": {"login": "shubham1g5"}, "path": "app/src/org/commcare/activities/SyncCapableCommCareActivity.java", "diffHunk": "@@ -75,15 +75,12 @@ public void onAttachedToWindow() {\n      * triggered after they are submitted. If no forms are sent, triggers a sync explicitly.\n      */\n     protected void sendFormsOrSync(boolean userTriggeredSync) {\n-        boolean formsSentToServer = checkAndStartUnsentFormsTask(true, userTriggeredSync);\n-        if (!formsSentToServer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fc4466b53a74d54268d70109537c70b1e899cb3"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTk2NjYzOnYy", "diffSide": "LEFT", "path": "app/src/org/commcare/utils/FormUploadUtil.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNDo0Nzo1OVrOFyWZfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxOTo0MDowNFrOF_PxrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM0MDA5NQ==", "bodyText": "Removed this since we should not cancel upload for all forms because of an error with a single form and allow code to follow the error handling here for this case.", "url": "https://github.com/dimagi/commcare-android/pull/2195#discussion_r388340095", "createdAt": "2020-03-05T14:47:59Z", "author": {"login": "shubham1g5"}, "path": "app/src/org/commcare/utils/FormUploadUtil.java", "diffHunk": "@@ -134,13 +128,12 @@ public static FormUploadResult sendInstance(int submissionNumber, File folder,\n         // If we're listening, figure out how much (roughly) we have to send\n         long bytes = estimateUploadBytes(files);\n \n-        if (hasListener) {\n-            myListener.startSubmission(submissionNumber, bytes);\n+        if (listener != null) {\n+            listener.startSubmission(submissionNumber, bytes);\n         }\n \n         if (files.length == 0) {\n             Log.e(TAG, \"no files to upload\");\n-            listener.cancel(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5d61dec3abb5d8ffa0b9d05194dce8fca501d03"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4OTU1Ng==", "bodyText": "Hey,\nI'm a bit confused about how your comment matches up with the code it's attached to.\nSpecifically: There are lots of situations where we should cancel an upload because of an error with a single form. If there's a form we're having issues with that we don't understand, if we block submission we retain the synchronicity between the mobile and the server until we can correct it. If we let stuff through we risk letting the phone and server drift significantly.\nIf what you're saying is that for this particular error we are going to end up moving on / quarantining/ otherwise deleting the record anyway, that makes sense to me for this just not being the right place to cancel the upload (but to let that logic propagate up the stack naturally).", "url": "https://github.com/dimagi/commcare-android/pull/2195#discussion_r393389556", "createdAt": "2020-03-17T00:58:47Z", "author": {"login": "ctsims"}, "path": "app/src/org/commcare/utils/FormUploadUtil.java", "diffHunk": "@@ -134,13 +128,12 @@ public static FormUploadResult sendInstance(int submissionNumber, File folder,\n         // If we're listening, figure out how much (roughly) we have to send\n         long bytes = estimateUploadBytes(files);\n \n-        if (hasListener) {\n-            myListener.startSubmission(submissionNumber, bytes);\n+        if (listener != null) {\n+            listener.startSubmission(submissionNumber, bytes);\n         }\n \n         if (files.length == 0) {\n             Log.e(TAG, \"no files to upload\");\n-            listener.cancel(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM0MDA5NQ=="}, "originalCommit": {"oid": "a5d61dec3abb5d8ffa0b9d05194dce8fca501d03"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI4MTI0MA==", "bodyText": "Specifically: There are lots of situations where we should cancel an upload because of an error with a single form. If there's a form we're having issues with that we don't understand, if we block submission we retain the synchronicity between the mobile and the server until we can correct it. If we let stuff through we risk letting the phone and server drift significantly.\n\n@ctsims Agree that we might want to cancel the whole task in some specific error in a single form. Though talking specifically for this case, the error handling  (I put a wrong link earlier) seems more robust as it takes into account whether the FNF is due to storage not being available or not and halt/continue the form upload for all forms depending on that which seems more robust to me than cancelling the task in all cases. Would we still want to cancel the upload for all forms even if the issue is with one form for the sake of mobile server parity ?", "url": "https://github.com/dimagi/commcare-android/pull/2195#discussion_r394281240", "createdAt": "2020-03-18T11:35:26Z", "author": {"login": "shubham1g5"}, "path": "app/src/org/commcare/utils/FormUploadUtil.java", "diffHunk": "@@ -134,13 +128,12 @@ public static FormUploadResult sendInstance(int submissionNumber, File folder,\n         // If we're listening, figure out how much (roughly) we have to send\n         long bytes = estimateUploadBytes(files);\n \n-        if (hasListener) {\n-            myListener.startSubmission(submissionNumber, bytes);\n+        if (listener != null) {\n+            listener.startSubmission(submissionNumber, bytes);\n         }\n \n         if (files.length == 0) {\n             Log.e(TAG, \"no files to upload\");\n-            listener.cancel(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM0MDA5NQ=="}, "originalCommit": {"oid": "a5d61dec3abb5d8ffa0b9d05194dce8fca501d03"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkyOTk3Nw==", "bodyText": "@ctsims  bump", "url": "https://github.com/dimagi/commcare-android/pull/2195#discussion_r400929977", "createdAt": "2020-03-31T13:51:40Z", "author": {"login": "shubham1g5"}, "path": "app/src/org/commcare/utils/FormUploadUtil.java", "diffHunk": "@@ -134,13 +128,12 @@ public static FormUploadResult sendInstance(int submissionNumber, File folder,\n         // If we're listening, figure out how much (roughly) we have to send\n         long bytes = estimateUploadBytes(files);\n \n-        if (hasListener) {\n-            myListener.startSubmission(submissionNumber, bytes);\n+        if (listener != null) {\n+            listener.startSubmission(submissionNumber, bytes);\n         }\n \n         if (files.length == 0) {\n             Log.e(TAG, \"no files to upload\");\n-            listener.cancel(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM0MDA5NQ=="}, "originalCommit": {"oid": "a5d61dec3abb5d8ffa0b9d05194dce8fca501d03"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2MzA4NA==", "bodyText": "@shubham1g5 You are right that it looks like the general form processing loop will catch a FileNotfound error correctly if storage isn't available, so agreed that we can let it propagate and not catch it redundantly..", "url": "https://github.com/dimagi/commcare-android/pull/2195#discussion_r401863084", "createdAt": "2020-04-01T19:40:04Z", "author": {"login": "ctsims"}, "path": "app/src/org/commcare/utils/FormUploadUtil.java", "diffHunk": "@@ -134,13 +128,12 @@ public static FormUploadResult sendInstance(int submissionNumber, File folder,\n         // If we're listening, figure out how much (roughly) we have to send\n         long bytes = estimateUploadBytes(files);\n \n-        if (hasListener) {\n-            myListener.startSubmission(submissionNumber, bytes);\n+        if (listener != null) {\n+            listener.startSubmission(submissionNumber, bytes);\n         }\n \n         if (files.length == 0) {\n             Log.e(TAG, \"no files to upload\");\n-            listener.cancel(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM0MDA5NQ=="}, "originalCommit": {"oid": "a5d61dec3abb5d8ffa0b9d05194dce8fca501d03"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzODQ0NDYwOnYy", "diffSide": "RIGHT", "path": "app/src/org/commcare/heartbeat/HeartbeatRequester.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMDo1MjozNVrOF3KgLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxMToxODowOVrOGHqNrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4ODA3OA==", "bodyText": "How long does this last? Until the flag is reset?\nI think it might make sense for this to trigger a \"cooldown\" (IE: 1-7 day period where we don't try) rather than a permanent off switch, although I could see it working either way. Mostly it's sometimes harder than it seems for HQ to maintain state or update certain hooks, so the less we rely on them the better", "url": "https://github.com/dimagi/commcare-android/pull/2195#discussion_r393388078", "createdAt": "2020-03-17T00:52:35Z", "author": {"login": "ctsims"}, "path": "app/src/org/commcare/heartbeat/HeartbeatRequester.java", "diffHunk": "@@ -96,10 +98,20 @@ public void parseResponse(JSONObject responseAsJson) {\n             attemptApkUpdateParse(responseAsJson);\n             attemptCczUpdateParse(responseAsJson);\n             checkForForceLogs(responseAsJson);\n+            checkForDisableBackgroundWork(responseAsJson);\n         }\n         DriftHelper.clearMaxDriftSinceLastHeartbeat();\n     }\n \n+    private void checkForDisableBackgroundWork(JSONObject responseAsJson) {\n+        boolean disableBackgroundWork = responseAsJson.optBoolean(\"disable_background_work\", false);\n+        HiddenPreferences.setDisableBackgroundWork(disableBackgroundWork);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e647fe50494e70945865f0e66980b13f7844a113"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI4ODk0OQ==", "bodyText": "Right. it makes most sense then to enable these on next login in that case and then disable again if the flag in heartbeat still conveys that we should stop ?", "url": "https://github.com/dimagi/commcare-android/pull/2195#discussion_r394288949", "createdAt": "2020-03-18T11:50:13Z", "author": {"login": "shubham1g5"}, "path": "app/src/org/commcare/heartbeat/HeartbeatRequester.java", "diffHunk": "@@ -96,10 +98,20 @@ public void parseResponse(JSONObject responseAsJson) {\n             attemptApkUpdateParse(responseAsJson);\n             attemptCczUpdateParse(responseAsJson);\n             checkForForceLogs(responseAsJson);\n+            checkForDisableBackgroundWork(responseAsJson);\n         }\n         DriftHelper.clearMaxDriftSinceLastHeartbeat();\n     }\n \n+    private void checkForDisableBackgroundWork(JSONObject responseAsJson) {\n+        boolean disableBackgroundWork = responseAsJson.optBoolean(\"disable_background_work\", false);\n+        HiddenPreferences.setDisableBackgroundWork(disableBackgroundWork);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4ODA3OA=="}, "originalCommit": {"oid": "e647fe50494e70945865f0e66980b13f7844a113"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkzMDA5MA==", "bodyText": "@ctsims  bump", "url": "https://github.com/dimagi/commcare-android/pull/2195#discussion_r400930090", "createdAt": "2020-03-31T13:51:49Z", "author": {"login": "shubham1g5"}, "path": "app/src/org/commcare/heartbeat/HeartbeatRequester.java", "diffHunk": "@@ -96,10 +98,20 @@ public void parseResponse(JSONObject responseAsJson) {\n             attemptApkUpdateParse(responseAsJson);\n             attemptCczUpdateParse(responseAsJson);\n             checkForForceLogs(responseAsJson);\n+            checkForDisableBackgroundWork(responseAsJson);\n         }\n         DriftHelper.clearMaxDriftSinceLastHeartbeat();\n     }\n \n+    private void checkForDisableBackgroundWork(JSONObject responseAsJson) {\n+        boolean disableBackgroundWork = responseAsJson.optBoolean(\"disable_background_work\", false);\n+        HiddenPreferences.setDisableBackgroundWork(disableBackgroundWork);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4ODA3OA=="}, "originalCommit": {"oid": "e647fe50494e70945865f0e66980b13f7844a113"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2NDUzNA==", "bodyText": "I'm not sure how many phones successfully get a heartbeat every day (and when in the day they get it if they do, some CAS users get their heartbeat in the afternoon), so it might be worth waiting slightly longer than a day, but the pattern you describe sounds right.", "url": "https://github.com/dimagi/commcare-android/pull/2195#discussion_r401864534", "createdAt": "2020-04-01T19:42:42Z", "author": {"login": "ctsims"}, "path": "app/src/org/commcare/heartbeat/HeartbeatRequester.java", "diffHunk": "@@ -96,10 +98,20 @@ public void parseResponse(JSONObject responseAsJson) {\n             attemptApkUpdateParse(responseAsJson);\n             attemptCczUpdateParse(responseAsJson);\n             checkForForceLogs(responseAsJson);\n+            checkForDisableBackgroundWork(responseAsJson);\n         }\n         DriftHelper.clearMaxDriftSinceLastHeartbeat();\n     }\n \n+    private void checkForDisableBackgroundWork(JSONObject responseAsJson) {\n+        boolean disableBackgroundWork = responseAsJson.optBoolean(\"disable_background_work\", false);\n+        HiddenPreferences.setDisableBackgroundWork(disableBackgroundWork);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4ODA3OA=="}, "originalCommit": {"oid": "e647fe50494e70945865f0e66980b13f7844a113"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY4NDg0NA==", "bodyText": "@ctsims Changed the behaviour for work to be disabled for 36 hours since the phone encounters the heartbeat flag to disable background work.", "url": "https://github.com/dimagi/commcare-android/pull/2195#discussion_r410684844", "createdAt": "2020-04-18T11:18:09Z", "author": {"login": "shubham1g5"}, "path": "app/src/org/commcare/heartbeat/HeartbeatRequester.java", "diffHunk": "@@ -96,10 +98,20 @@ public void parseResponse(JSONObject responseAsJson) {\n             attemptApkUpdateParse(responseAsJson);\n             attemptCczUpdateParse(responseAsJson);\n             checkForForceLogs(responseAsJson);\n+            checkForDisableBackgroundWork(responseAsJson);\n         }\n         DriftHelper.clearMaxDriftSinceLastHeartbeat();\n     }\n \n+    private void checkForDisableBackgroundWork(JSONObject responseAsJson) {\n+        boolean disableBackgroundWork = responseAsJson.optBoolean(\"disable_background_work\", false);\n+        HiddenPreferences.setDisableBackgroundWork(disableBackgroundWork);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4ODA3OA=="}, "originalCommit": {"oid": "e647fe50494e70945865f0e66980b13f7844a113"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzODQ0Nzk4OnYy", "diffSide": "RIGHT", "path": "app/src/org/commcare/sync/FormSubmissionHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMDo1NDo1N1rOF3KiSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMDo1NDo1N1rOF3KiSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4ODYxNg==", "bodyText": "Increasingly it does seem like there's a lot of value to us splitting out the logic / workflow part of these async jobs from the actual async executor (the worker or the task), great job iterating and piloting that in the previous work. It's a good pattern for just o build on.\nCan you make sure to provide Javadocs for these classes spelling out those delegations of responsibility?", "url": "https://github.com/dimagi/commcare-android/pull/2195#discussion_r393388616", "createdAt": "2020-03-17T00:54:57Z", "author": {"login": "ctsims"}, "path": "app/src/org/commcare/sync/FormSubmissionHelper.java", "diffHunk": "@@ -1,628 +1,572 @@\n-package org.commcare.tasks;\r\n-\r\n-import android.content.Context;\r\n-import android.os.AsyncTask;\r\n-\r\n-import net.sqlcipher.database.SQLiteDatabase;\r\n-\r\n-import org.apache.commons.lang3.StringUtils;\r\n-import org.commcare.CommCareApplication;\r\n-import org.commcare.activities.SyncCapableCommCareActivity;\r\n-import org.commcare.android.database.user.models.FormRecord;\r\n-import org.commcare.models.FormRecordProcessor;\r\n-import org.commcare.suite.model.Profile;\r\n-import org.commcare.tasks.templates.CommCareTask;\r\n-import org.commcare.tasks.templates.CommCareTaskConnector;\r\n-import org.commcare.util.LogTypes;\r\n-import org.commcare.utils.FormUploadResult;\r\n-import org.commcare.utils.FormUploadUtil;\r\n-import org.commcare.utils.QuarantineUtil;\r\n-import org.commcare.utils.SessionUnavailableException;\r\n-import org.commcare.views.notifications.NotificationMessage;\r\n-import org.commcare.views.notifications.NotificationMessageFactory;\r\n-import org.commcare.views.notifications.ProcessIssues;\r\n-import org.javarosa.core.model.User;\r\n-import org.javarosa.core.services.Logger;\r\n-import org.javarosa.core.services.locale.Localization;\r\n-import org.javarosa.xml.util.InvalidStructureException;\r\n-import org.javarosa.xml.util.UnfullfilledRequirementsException;\r\n-import org.xmlpull.v1.XmlPullParserException;\r\n-\r\n-import java.io.ByteArrayOutputStream;\r\n-import java.io.File;\r\n-import java.io.FileNotFoundException;\r\n-import java.io.IOException;\r\n-import java.io.PrintStream;\r\n-import java.util.ArrayList;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import java.util.Queue;\r\n-\r\n-import javax.crypto.spec.SecretKeySpec;\r\n-\r\n-/**\r\n- * @author ctsims\r\n- */\r\n-public abstract class ProcessAndSendTask<R> extends CommCareTask<FormRecord, Long, FormUploadResult, R> implements DataSubmissionListener {\r\n-\r\n-    private String url;\r\n-    private FormUploadResult[] results;\r\n-\r\n-    private final int sendTaskId;\r\n-\r\n-    public static final int PROCESSING_PHASE_ID = 8;\r\n-    public static final int SEND_PHASE_ID = 9;\r\n-    public static final int PROCESSING_PHASE_ID_NO_DIALOG = -8;\r\n-    public static final int SEND_PHASE_ID_NO_DIALOG = -9;\r\n-\r\n-    public static final long PROGRESS_ALL_PROCESSED = 8;\r\n-\r\n-    public static final long SUBMISSION_BEGIN = 16;\r\n-    public static final long SUBMISSION_START = 32;\r\n-    public static final long SUBMISSION_NOTIFY = 64;\r\n-    public static final long SUBMISSION_DONE = 128;\r\n-\r\n-    private static final long SUBMISSION_SUCCESS = 1;\r\n-    private static final long SUBMISSION_FAIL = 0;\r\n-\r\n-    private FormSubmissionProgressBarListener progressBarListener;\r\n-    private List<DataSubmissionListener> formSubmissionListeners;\r\n-    private final FormRecordProcessor processor;\r\n-\r\n-    private static final int SUBMISSION_ATTEMPTS = 2;\r\n-\r\n-    private static final Queue<ProcessAndSendTask> processTasks = new LinkedList<>();\r\n-\r\n-    public ProcessAndSendTask(Context c, String url) {\r\n-        this(c, url, true);\r\n-    }\r\n-\r\n-    /**\r\n-     * @param inSyncMode blocks the user with a sync dialog\r\n-     */\r\n-    public ProcessAndSendTask(Context c, String url, boolean inSyncMode) {\r\n-        this.url = url;\r\n-        this.processor = new FormRecordProcessor(c);\r\n-        this.formSubmissionListeners = new ArrayList<>();\r\n-        if (inSyncMode) {\r\n-            this.sendTaskId = SEND_PHASE_ID;\r\n-            this.taskId = PROCESSING_PHASE_ID;\r\n-        } else {\r\n-            this.sendTaskId = SEND_PHASE_ID_NO_DIALOG;\r\n-            this.taskId = PROCESSING_PHASE_ID_NO_DIALOG;\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    protected FormUploadResult doTaskBackground(FormRecord... records) {\r\n-        boolean wroteErrorToLogs = false;\r\n-        try {\r\n-            results = new FormUploadResult[records.length];\r\n-            for (int i = 0; i < records.length; ++i) {\r\n-                //Assume failure\r\n-                results[i] = FormUploadResult.FAILURE;\r\n-            }\r\n-            //The first thing we need to do is make sure everything is processed,\r\n-            //we can't actually proceed before that.\r\n-            try {\r\n-                wroteErrorToLogs = checkFormRecordStatus(records);\r\n-            } catch (FileNotFoundException e) {\r\n-                return FormUploadResult.PROGRESS_SDCARD_REMOVED;\r\n-            } catch (TaskCancelledException e) {\r\n-                return FormUploadResult.FAILURE;\r\n-            }\r\n-\r\n-\r\n-            this.publishProgress(PROGRESS_ALL_PROCESSED);\r\n-\r\n-            //Put us on the queue!\r\n-            synchronized (processTasks) {\r\n-                processTasks.add(this);\r\n-            }\r\n-            boolean needToRefresh;\r\n-            try {\r\n-                needToRefresh = blockUntilTopOfQueue();\r\n-            } catch (TaskCancelledException e) {\r\n-                return FormUploadResult.FAILURE;\r\n-            }\r\n-\r\n-\r\n-            if (needToRefresh) {\r\n-                //There was another activity before this one. Refresh our models in case\r\n-                //they were updated\r\n-                for (int i = 0; i < records.length; ++i) {\r\n-                    int dbId = records[i].getID();\r\n-                    records[i] = processor.getRecord(dbId);\r\n-                }\r\n-            }\r\n-\r\n-            // Ok, all forms are now processed. Time to focus on sending\r\n-            dispatchBeginSubmissionProcessToListeners(records.length);\r\n-\r\n-            try {\r\n-                sendForms(records);\r\n-            } catch (TaskCancelledException e) {\r\n-                return FormUploadResult.FAILURE;\r\n-            }\r\n-\r\n-            return FormUploadResult.getWorstResult(results);\r\n-        } catch (SessionUnavailableException sue) {\r\n-            this.cancel(false);\r\n-            return FormUploadResult.PROGRESS_LOGGED_OUT;\r\n-        } finally {\r\n-            boolean success =\r\n-                    FormUploadResult.FULL_SUCCESS.equals(FormUploadResult.getWorstResult(results));\r\n-            this.endSubmissionProcess(success);\r\n-\r\n-            synchronized (processTasks) {\r\n-                processTasks.remove(this);\r\n-            }\r\n-\r\n-            if (success || wroteErrorToLogs) {\r\n-                // Try to send logs if we either know we have a good connection, or know we wrote\r\n-                // an error to the logs during form submission attempt\r\n-                CommCareApplication.instance().notifyLogsPending();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private boolean checkFormRecordStatus(FormRecord[] records)\r\n-            throws FileNotFoundException, TaskCancelledException {\r\n-        boolean wroteErrorToLogs = false;\r\n-        processor.beginBulkSubmit();\r\n-        for (int i = 0; i < records.length; ++i) {\r\n-            if (isCancelled()) {\r\n-                throw new TaskCancelledException();\r\n-            }\r\n-            FormRecord record = records[i];\r\n-\r\n-            //If the form is complete, but unprocessed, process it.\r\n-            if (FormRecord.STATUS_COMPLETE.equals(record.getStatus())) {\r\n-                SQLiteDatabase userDb =\r\n-                        CommCareApplication.instance().getUserDbHandle();\r\n-                try {\r\n-                    userDb.beginTransaction();\r\n-                    try {\r\n-                        records[i] = processor.process(record);\r\n-                        userDb.setTransactionSuccessful();\r\n-                    } finally {\r\n-                        userDb.endTransaction();\r\n-                    }\r\n-                } catch (InvalidStructureException | XmlPullParserException |\r\n-                        UnfullfilledRequirementsException e) {\r\n-                    records[i] = handleExceptionFromFormProcessing(record, e);\r\n-                    wroteErrorToLogs = true;\r\n-                } catch (FileNotFoundException e) {\r\n-                    if (CommCareApplication.instance().isStorageAvailable()) {\r\n-                        //If storage is available generally, this is a bug in the app design\r\n-                        Logger.log(LogTypes.TYPE_ERROR_DESIGN,\r\n-                                \"Removing form record because file was missing|\" + getExceptionText(e));\r\n-                        record.logPendingDeletion(TAG,\r\n-                                \"the xml submission file associated with the record could not be found\");\r\n-                        FormRecordCleanupTask.wipeRecord(record);\r\n-                        records[i] = FormRecord.StandInForDeletedRecord();\r\n-                        wroteErrorToLogs = true;\r\n-                    } else {\r\n-                        CommCareApplication.notificationManager().reportNotificationMessage(\r\n-                                NotificationMessageFactory.message(ProcessIssues.StorageRemoved), true);\r\n-                        //Otherwise, the SD card just got removed, and we need to bail anyway.\r\n-                        throw e;\r\n-                    }\r\n-                } catch (IOException e) {\r\n-                    Logger.log(LogTypes.TYPE_ERROR_WORKFLOW, \"IO Issues processing a form. \" +\r\n-                            \"Tentatively not removing in case they are resolvable|\" + getExceptionText(e));\r\n-                    wroteErrorToLogs = true;\r\n-                }\r\n-            }\r\n-        }\r\n-        processor.closeBulkSubmit();\r\n-        return wroteErrorToLogs;\r\n-    }\r\n-\r\n-    private FormRecord handleExceptionFromFormProcessing(FormRecord record, Exception e) {\r\n-        String logMessage = \"\";\r\n-        if (e instanceof InvalidStructureException) {\r\n-            logMessage =\r\n-                    String.format(\"Quarantining form record with ID %s due to transaction data|\",\r\n-                            record.getInstanceID());\r\n-        } else if (e instanceof XmlPullParserException) {\r\n-            logMessage =\r\n-                    String.format(\"Quarantining form record with ID %s due to bad xml|\",\r\n-                            record.getInstanceID());\r\n-        } else if (e instanceof UnfullfilledRequirementsException) {\r\n-            logMessage =\r\n-                    String.format(\"Quarantining form record with ID %s due to bad requirements|\",\r\n-                            record.getInstanceID());\r\n-        }\r\n-        logMessage = logMessage + getExceptionText(e);\r\n-\r\n-        CommCareApplication.notificationManager().reportNotificationMessage(\r\n-                NotificationMessageFactory.message(ProcessIssues.BadTransactions), true);\r\n-        Logger.log(LogTypes.TYPE_ERROR_DESIGN, logMessage);\r\n-\r\n-        return quarantineRecord(record, FormRecord.QuarantineReason_LOCAL_PROCESSING_ERROR);\r\n-    }\r\n-\r\n-    private boolean blockUntilTopOfQueue() throws TaskCancelledException {\r\n-        boolean needToRefresh = false;\r\n-        while (true) {\r\n-            //See if it's our turn to go\r\n-            synchronized (processTasks) {\r\n-                if (isCancelled()) {\r\n-                    processTasks.remove(this);\r\n-                    throw new TaskCancelledException();\r\n-                }\r\n-                //Are we at the head of the queue?\r\n-                ProcessAndSendTask head = processTasks.peek();\r\n-                if (head == this) {\r\n-                    break;\r\n-                }\r\n-                //Otherwise, is the head of the queue busted?\r\n-                //*sigh*. Apparently Cancelled doesn't result in the task status being set\r\n-                //to !Running for reasons which baffle me.\r\n-                if (head.getStatus() != AsyncTask.Status.RUNNING || head.isCancelled()) {\r\n-                    //If so, get rid of it\r\n-                    processTasks.poll();\r\n-                }\r\n-            }\r\n-            //If it's not yet quite our turn, take a nap\r\n-            try {\r\n-                needToRefresh = true;\r\n-                Thread.sleep(500);\r\n-            } catch (InterruptedException e) {\r\n-                e.printStackTrace();\r\n-            }\r\n-        }\r\n-        return needToRefresh;\r\n-    }\r\n-\r\n-    private void sendForms(FormRecord[] records) throws TaskCancelledException {\r\n-        for (int i = 0; i < records.length; ++i) {\r\n-\r\n-            if (previousFailurePredictsFutureFailures(results, i)) {\r\n-                Logger.log(LogTypes.TYPE_WARNING_NETWORK,\r\n-                        \"Cancelling submission due to network errors. \" + (i - 1) + \" forms successfully sent.\");\r\n-                break;\r\n-            }\r\n-\r\n-            if (isCancelled()) {\r\n-                Logger.log(LogTypes.TYPE_USER, \"Cancelling submission due to a manual stop. \" + (i - 1) + \" forms succesfully sent.\");\r\n-                throw new TaskCancelledException();\r\n-            }\r\n-\r\n-            FormRecord record = records[i];\r\n-            try {\r\n-                if (FormRecord.STATUS_UNSENT.equals(record.getStatus())) {\r\n-                    File folder;\r\n-\r\n-                    //Good!\r\n-                    //Time to Send!\r\n-                    try {\r\n-                        try {\r\n-                            if (StringUtils.isEmpty(record.getFilePath())) {\r\n-                                throw new FileNotFoundException(\"File path empty for formrecord \" +\r\n-                                        record.getID() + \" with xmlns \" + record.getFormNamespace());\r\n-                            }\r\n-                            folder = new File(record.getFilePath()).getCanonicalFile().getParentFile();\r\n-                        } catch (FileNotFoundException e) {\r\n-                            //This will put us in the same \"Missing Form\" handling path as below\r\n-                            throw e;\r\n-                        } catch (IOException e) {\r\n-                            // Unexpected/Unknown IO Error path from cannonical file\r\n-                            Logger.log(LogTypes.TYPE_ERROR_WORKFLOW, \"Bizarre. Exception just getting the file reference. Not removing.\" + getExceptionText(e));\r\n-                            continue;\r\n-                        }\r\n-\r\n-                        User user = CommCareApplication.instance().getSession().getLoggedInUser();\r\n-                        int attemptsMade = 0;\r\n-                        logSubmissionAttempt(record);\r\n-                        while (attemptsMade < SUBMISSION_ATTEMPTS) {\r\n-\r\n-                            if (isCancelled()) {\r\n-                                Logger.log(LogTypes.TYPE_USER, \"Cancelling submission due to a manual stop. \" + (i - 1) + \" forms succesfully sent.\");\r\n-                                throw new TaskCancelledException();\r\n-                            }\r\n-\r\n-                            results[i] = FormUploadUtil.sendInstance(i, folder,\r\n-                                    new SecretKeySpec(record.getAesKey(), \"AES\"), url, this, user);\r\n-                            if (results[i] == FormUploadResult.FULL_SUCCESS) {\r\n-                                logSubmissionSuccess(record);\r\n-                                break;\r\n-                            } else if (results[i] == FormUploadResult.PROCESSING_FAILURE) {\r\n-                                // A processing failure indicates that there there is no point in\r\n-                                // trying that submission again immediately\r\n-                                break;\r\n-                            } else if (results[i] == FormUploadResult.RATE_LIMITED) {\r\n-                                // Don't keep retrying, the server is rate limiting submissions\r\n-                                break;\r\n-                            } else {\r\n-                                attemptsMade++;\r\n-                            }\r\n-                        }\r\n-                        if (results[i] == FormUploadResult.RECORD_FAILURE ||\r\n-                                results[i] == FormUploadResult.PROCESSING_FAILURE) {\r\n-                            quarantineRecord(record, results[i]);\r\n-                        }\r\n-                    } catch (FileNotFoundException e) {\r\n-                        if (CommCareApplication.instance().isStorageAvailable()) {\r\n-                            // If storage is available generally, this is a bug in the app design\r\n-                            // Log with multiple tags so we can track more easily\r\n-                            Logger.log(LogTypes.SOFT_ASSERT, String.format(\r\n-                                    \"Removed form record with id %s because file was missing| %s\",\r\n-                                    record.getInstanceID(), getExceptionText(e)));\r\n-                            Logger.log(LogTypes.TYPE_FORM_SUBMISSION, String.format(\r\n-                                    \"Removed form record with id %s because file was missing| %s\",\r\n-                                    record.getInstanceID(), getExceptionText(e)));\r\n-                            record.logPendingDeletion(TAG,\r\n-                                    \"the xml submission file associated with the record was missing\");\r\n-                            quarantineRecord(record,\r\n-                                    FormRecord.QuarantineReason_FILE_NOT_FOUND);\r\n-                            results[i] = FormUploadResult.RECORD_FAILURE;\r\n-                        } else {\r\n-                            // Otherwise, the SD card just got removed, and we need to bail anyway.\r\n-                            CommCareApplication.notificationManager().reportNotificationMessage(\r\n-                                    NotificationMessageFactory.message(ProcessIssues.StorageRemoved), true);\r\n-                            break;\r\n-                        }\r\n-                        continue;\r\n-                    }\r\n-\r\n-                    Profile p = CommCareApplication.instance().getCommCarePlatform().getCurrentProfile();\r\n-                    // Check for success\r\n-                    if (results[i] == FormUploadResult.FULL_SUCCESS) {\r\n-                        // Only delete if this device isn't set up to review.\r\n-                        if (p == null || !p.isFeatureActive(Profile.FEATURE_REVIEW)) {\r\n-                            FormRecordCleanupTask.wipeRecord(record);\r\n-                        } else {\r\n-                            // Otherwise save and move appropriately\r\n-                            processor.updateRecordStatus(record, FormRecord.STATUS_SAVED);\r\n-                        }\r\n-                    }\r\n-                } else if (FormRecord.STATUS_QUARANTINED.equals(record.getStatus()) ||\r\n-                        FormRecord.STATUS_JUST_DELETED.equals(record.getStatus())) {\r\n-                    // This record was either quarantined or deleted due to an error during the\r\n-                    // pre-processing phase\r\n-                    results[i] = FormUploadResult.RECORD_FAILURE;\r\n-                } else {\r\n-                    results[i] = FormUploadResult.FULL_SUCCESS;\r\n-                }\r\n-            } catch (SessionUnavailableException sue) {\r\n-                throw sue;\r\n-            } catch (Exception e) {\r\n-                //Just try to skip for now. Hopefully this doesn't wreck the model :/\r\n-                Logger.exception(\"Totally Unexpected Error during form submission: \" + getExceptionText(e), e);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @param results      the array of submission results\r\n-     * @param currentIndex - the index of the submission we are about to attempt\r\n-     * @return true if there was a failure in submitting the previous form that indicates future\r\n-     * submission attempts will also fail. (We permit proceeding if there was a local problem with\r\n-     * a specific record, or a processing error with a specific record, since that is unrelated to\r\n-     * how future submissions will fair).\r\n-     */\r\n-    private boolean previousFailurePredictsFutureFailures(FormUploadResult[] results, int currentIndex) {\r\n-        if (currentIndex > 0) {\r\n-            FormUploadResult lastResult = results[currentIndex - 1];\r\n-            return !(lastResult == FormUploadResult.FULL_SUCCESS ||\r\n-                    lastResult == FormUploadResult.RECORD_FAILURE ||\r\n-                    lastResult == FormUploadResult.PROCESSING_FAILURE);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    private FormRecord quarantineRecord(FormRecord record, FormUploadResult uploadResult) {\r\n-        String reasonType =\r\n-                (uploadResult == FormUploadResult.RECORD_FAILURE) ?\r\n-                        FormRecord.QuarantineReason_RECORD_ERROR :\r\n-                        FormRecord.QuarantineReason_SERVER_PROCESSING_ERROR;\r\n-        record = processor.quarantineRecord(record, reasonType, uploadResult.getErrorMessage());\r\n-        logAndNotifyQuarantine(record);\r\n-        return record;\r\n-    }\r\n-\r\n-    private FormRecord quarantineRecord(FormRecord record, String quarantineReasonType) {\r\n-        record = processor.quarantineRecord(record, quarantineReasonType);\r\n-        logAndNotifyQuarantine(record);\r\n-        return record;\r\n-    }\r\n-\r\n-    private static void logAndNotifyQuarantine(FormRecord record) {\r\n-        Logger.log(LogTypes.TYPE_ERROR_STORAGE,\r\n-                String.format(\"Quarantining Form Record with id %s because: %s\",\r\n-                        record.getInstanceID(),\r\n-                        QuarantineUtil.getQuarantineReasonDisplayString(record, true)));\r\n-\r\n-        NotificationMessage m = QuarantineUtil.getQuarantineNotificationMessage(record);\r\n-        if (m != null) {\r\n-            CommCareApplication.notificationManager().reportNotificationMessage(m, true);\r\n-        }\r\n-    }\r\n-\r\n-    private static void logSubmissionAttempt(FormRecord record) {\r\n-        String attemptMesssage = String.format(\r\n-                \"Attempting to submit form with id %1$s and submission ordering number %2$s\",\r\n-                record.getInstanceID(),\r\n-                record.getSubmissionOrderingNumber());\r\n-        Logger.log(LogTypes.TYPE_FORM_SUBMISSION, attemptMesssage);\r\n-    }\r\n-\r\n-    private static void logSubmissionSuccess(FormRecord record) {\r\n-        String successMessage = String.format(\r\n-                \"Successfully submitted form with id %1$s and submission ordering number %2$s\",\r\n-                record.getInstanceID(),\r\n-                record.getSubmissionOrderingNumber());\r\n-        Logger.log(LogTypes.TYPE_FORM_SUBMISSION, successMessage);\r\n-    }\r\n-\r\n-    public static int pending() {\r\n-        synchronized (processTasks) {\r\n-            return processTasks.size();\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    protected void onProgressUpdate(Long... values) {\r\n-        if (values.length == 1 && values[0] == PROGRESS_ALL_PROCESSED) {\r\n-            this.transitionPhase(sendTaskId);\r\n-        }\r\n-\r\n-        super.onProgressUpdate(values);\r\n-\r\n-        if (values.length > 0) {\r\n-            if (values[0] == SUBMISSION_BEGIN) {\r\n-                dispatchBeginSubmissionProcessToListeners(values[1].intValue());\r\n-            } else if (values[0] == SUBMISSION_START) {\r\n-                int item = values[1].intValue();\r\n-                long size = values[2];\r\n-                dispatchStartSubmissionToListeners(item, size);\r\n-            } else if (values[0] == SUBMISSION_NOTIFY) {\r\n-                int item = values[1].intValue();\r\n-                long progress = values[2];\r\n-                dispatchNotifyProgressToListeners(item, progress);\r\n-            } else if (values[0] == SUBMISSION_DONE) {\r\n-                dispatchEndSubmissionProcessToListeners(values[1] == SUBMISSION_SUCCESS);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void addProgressBarSubmissionListener(FormSubmissionProgressBarListener listener) {\r\n-        this.progressBarListener = listener;\r\n-        addSubmissionListener(listener);\r\n-    }\r\n-\r\n-    public void addSubmissionListener(DataSubmissionListener submissionListener) {\r\n-        formSubmissionListeners.add(submissionListener);\r\n-    }\r\n-\r\n-    private void dispatchBeginSubmissionProcessToListeners(int totalItems) {\r\n-        for (DataSubmissionListener listener : formSubmissionListeners) {\r\n-            listener.beginSubmissionProcess(totalItems);\r\n-        }\r\n-    }\r\n-\r\n-    private void dispatchStartSubmissionToListeners(int itemNumber, long length) {\r\n-        for (DataSubmissionListener listener : formSubmissionListeners) {\r\n-            listener.startSubmission(itemNumber, length);\r\n-        }\r\n-    }\r\n-\r\n-    private void dispatchNotifyProgressToListeners(int itemNumber, long progress) {\r\n-        for (DataSubmissionListener listener : formSubmissionListeners) {\r\n-            listener.notifyProgress(itemNumber, progress);\r\n-        }\r\n-    }\r\n-\r\n-    private void dispatchEndSubmissionProcessToListeners(boolean success) {\r\n-        for (DataSubmissionListener listener : formSubmissionListeners) {\r\n-            listener.endSubmissionProcess(success);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    protected void onPostExecute(FormUploadResult result) {\r\n-        super.onPostExecute(result);\r\n-\r\n-        clearState();\r\n-    }\r\n-\r\n-    private void clearState() {\r\n-        url = null;\r\n-        results = null;\r\n-    }\r\n-\r\n-    protected int getSuccessfulSends() {\r\n-        int successes = 0;\r\n-        if (results != null) {\r\n-            for (FormUploadResult formResult : results) {\r\n-                if (formResult != null && FormUploadResult.FULL_SUCCESS == formResult) {\r\n-                    successes++;\r\n-                }\r\n-            }\r\n-        }\r\n-        return successes;\r\n-    }\r\n-\r\n-    protected String getLabelForFormsSent() {\r\n-        int successfulSends = getSuccessfulSends();\r\n-        String label;\r\n-        switch (successfulSends) {\r\n-            case 0:\r\n-                label = Localization.get(\"sync.success.sent.none\");\r\n-                break;\r\n-            case 1:\r\n-                label = Localization.get(\"sync.success.sent.singular\");\r\n-                break;\r\n-            default:\r\n-                label = Localization.get(\"sync.success.sent\",\r\n-                        new String[]{String.valueOf(successfulSends)});\r\n-        }\r\n-        return label;\r\n-    }\r\n-\r\n-\r\n-    //Wrappers for the internal stuff\r\n-    @Override\r\n-    public void beginSubmissionProcess(int totalItems) {\r\n-        this.publishProgress(SUBMISSION_BEGIN, (long)totalItems);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void startSubmission(int itemNumber, long sizeOfItem) {\r\n-        this.publishProgress(SUBMISSION_START, (long)itemNumber, sizeOfItem);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void notifyProgress(int itemNumber, long progress) {\r\n-        this.publishProgress(SUBMISSION_NOTIFY, (long)itemNumber, progress);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void endSubmissionProcess(boolean success) {\r\n-        if (success) {\r\n-            this.publishProgress(SUBMISSION_DONE, SUBMISSION_SUCCESS);\r\n-        } else {\r\n-            this.publishProgress(SUBMISSION_DONE, SUBMISSION_FAIL);\r\n-        }\r\n-    }\r\n-\r\n-    private String getExceptionText(Exception e) {\r\n-        try {\r\n-            ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n-            e.printStackTrace(new PrintStream(bos));\r\n-            return new String(bos.toByteArray());\r\n-        } catch (Exception ex) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    protected void onCancelled() {\r\n-        super.onCancelled();\r\n-\r\n-        dispatchEndSubmissionProcessToListeners(false);\r\n-\r\n-        // If cancellation happened due to logout, notify user\r\n-        try {\r\n-            CommCareApplication.instance().getSession().getLoggedInUser();\r\n-        } catch (SessionUnavailableException e) {\r\n-            CommCareApplication.notificationManager().reportNotificationMessage(NotificationMessageFactory.message(ProcessIssues.LoggedOut));\r\n-        }\r\n-\r\n-        clearState();\r\n-    }\r\n-\r\n-    @Override\r\n-    public void connect(CommCareTaskConnector<R> connector) {\r\n-        super.connect(connector);\r\n-        if (progressBarListener != null) {\r\n-            progressBarListener.attachToNewActivity(\r\n-                    (SyncCapableCommCareActivity)connector.getReceiver());\r\n-        }\r\n-    }\r\n-\r\n-    private static class TaskCancelledException extends Exception {\r\n-    }\r\n-}\r\n+package org.commcare.sync;\n+\n+import android.content.Context;\n+import android.content.SharedPreferences;\n+\n+import net.sqlcipher.database.SQLiteDatabase;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.commcare.CommCareApplication;\n+import org.commcare.android.database.user.models.FormRecord;\n+import org.commcare.dalvik.R;\n+import org.commcare.models.FormRecordProcessor;\n+import org.commcare.preferences.ServerUrls;\n+import org.commcare.suite.model.Profile;\n+import org.commcare.tasks.DataSubmissionListener;\n+import org.commcare.tasks.FormRecordCleanupTask;\n+import org.commcare.util.LogTypes;\n+import org.commcare.utils.FormUploadResult;\n+import org.commcare.utils.FormUploadUtil;\n+import org.commcare.utils.QuarantineUtil;\n+import org.commcare.utils.SessionUnavailableException;\n+import org.commcare.utils.StorageUtils;\n+import org.commcare.views.notifications.NotificationMessage;\n+import org.commcare.views.notifications.NotificationMessageFactory;\n+import org.commcare.views.notifications.ProcessIssues;\n+import org.javarosa.core.model.User;\n+import org.javarosa.core.services.Logger;\n+import org.javarosa.xml.util.InvalidStructureException;\n+import org.javarosa.xml.util.UnfullfilledRequirementsException;\n+import org.xmlpull.v1.XmlPullParserException;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+\n+import javax.crypto.spec.SecretKeySpec;\n+\n+public class FormSubmissionHelper implements DataSubmissionListener {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e647fe50494e70945865f0e66980b13f7844a113"}, "originalPosition": 671}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3336, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}