{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY5MDQxNjM1", "number": 2180, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMDo0NzowNFrODeJYMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMToxNDozMVrODeJyTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTM3NTIyOnYy", "diffSide": "RIGHT", "path": "app/assets/locales/android_translatable_strings.txt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMDo0NzowNFrOFnJ1AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMDo0NzowNFrOFnJ1AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU5OTgwOQ==", "bodyText": "This error message is pretty confusing. Can we shift it to just say something like \"An app update event was cancelled before it completed\"?", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r376599809", "createdAt": "2020-02-07T20:47:04Z", "author": {"login": "ctsims"}, "path": "app/assets/locales/android_translatable_strings.txt", "diffHunk": "@@ -543,6 +543,10 @@ notification.install.badcert.title=Bad Certificate\n notification.install.badcert.detail=The certificate you received from the server was invalid. This can be casued by many things, but is often do to a mis-set clock on your phone.\r\n notification.install.badcert.action=This is often due to your phone's internal clock being incorrect.\r\n \r\n+notification.install.cancel.title=Update Cancelled\r\n+notification.install.cancel.detail=This update was aborted either by CommCare or you.\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTM4NzQ5OnYy", "diffSide": "RIGHT", "path": "app/src/org/commcare/CommCareApplication.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMDo1MTo1M1rOFnJ8oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMDo1MTo1M1rOFnJ8oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwMTc2MA==", "bodyText": "Should areAutomatedActionsInvalid() still apply to this line?", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r376601760", "createdAt": "2020-02-07T20:51:53Z", "author": {"login": "ctsims"}, "path": "app/src/org/commcare/CommCareApplication.java", "diffHunk": "@@ -702,9 +708,8 @@ public void onServiceConnected(ComponentName className, IBinder service) {\n                             CommCareApplication.this.sessionWrapper = new AndroidSessionWrapper(CommCareApplication.this.getCommCarePlatform());\r\n                         }\r\n \r\n-                        if (shouldAutoUpdate()) {\r\n-                            startAutoUpdate();\r\n-                        }\r\n+                        scheduleAppUpdate();\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTM5NDI5OnYy", "diffSide": "RIGHT", "path": "app/src/org/commcare/activities/LoginActivity.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMDo1NToxMFrOFnKBLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMToyNDoxNFrOFoq--A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwMjkyNA==", "bodyText": "Since this comes after the commit change, this should actually be cancelling the lastSeatedId above, right?", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r376602924", "createdAt": "2020-02-07T20:55:10Z", "author": {"login": "ctsims"}, "path": "app/src/org/commcare/activities/LoginActivity.java", "diffHunk": "@@ -238,11 +238,22 @@ protected boolean checkForSeatedAppChange() {\n         String currentSeatedId = CommCareApplication.instance().getCurrentApp().getUniqueId();\r\n         if (!lastSeatedId.equals(currentSeatedId)) {\r\n             prefs.edit().putString(KEY_LAST_APP, currentSeatedId).commit();\r\n+            disableWorkForLastSeatedApp();\r\n             return true;\r\n         }\r\n         return false;\r\n     }\r\n \r\n+\r\n+    // cancels all worker tasks for previously seated app\r\n+    private static void disableWorkForLastSeatedApp() {\r\n+        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(CommCareApplication.instance());\r\n+        String lastSeatedId = prefs.getString(KEY_LAST_APP, \"\");\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE5MTYwOA==", "bodyText": "Moved it up here.", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r378191608", "createdAt": "2020-02-12T11:24:14Z", "author": {"login": "shubham1g5"}, "path": "app/src/org/commcare/activities/LoginActivity.java", "diffHunk": "@@ -238,11 +238,22 @@ protected boolean checkForSeatedAppChange() {\n         String currentSeatedId = CommCareApplication.instance().getCurrentApp().getUniqueId();\r\n         if (!lastSeatedId.equals(currentSeatedId)) {\r\n             prefs.edit().putString(KEY_LAST_APP, currentSeatedId).commit();\r\n+            disableWorkForLastSeatedApp();\r\n             return true;\r\n         }\r\n         return false;\r\n     }\r\n \r\n+\r\n+    // cancels all worker tasks for previously seated app\r\n+    private static void disableWorkForLastSeatedApp() {\r\n+        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(CommCareApplication.instance());\r\n+        String lastSeatedId = prefs.getString(KEY_LAST_APP, \"\");\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwMjkyNA=="}, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTQwMTgxOnYy", "diffSide": "RIGHT", "path": "app/src/org/commcare/activities/UpdateActivity.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMDo1Nzo0NlrOFnKFkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo1NjoxNVrOFoan_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwNDA0OA==", "bodyText": "Maybe I'm a bit confused but does this all imply that there's both an UpdateTask and an Update Worker now, and both can be running the process?", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r376604048", "createdAt": "2020-02-07T20:57:46Z", "author": {"login": "ctsims"}, "path": "app/src/org/commcare/activities/UpdateActivity.java", "diffHunk": "@@ -128,22 +135,61 @@ private void loadSavedInstanceState(Bundle savedInstanceState) {\n     }\n \n     private void setupUpdateTask(boolean isRotation) {\n-        updateTask = UpdateTask.getRunningInstance();\n-\n-        if (updateTask != null) {\n-            try {\n-                updateTask.registerTaskListener(this);\n-            } catch (TaskListenerRegistrationException e) {\n-                Log.e(TAG, \"Attempting to register a TaskListener to an already \" +\n-                        \"registered task.\");\n-                uiController.errorUiState();\n+        if (isAutoUpdateInProgress()) {\n+            connectToUpdateWorker();\n+        } else {\n+            updateTask = UpdateTask.getRunningInstance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg3OTg5MQ==", "bodyText": "Right with the difference being UpdateTask is the reliable mechanism for foreground updates while UpdateWorker is only used for background ones. WorkManager is the replacement for traditional Android services kind of work and is not recommended for doing one off forground task that needs to happen on a user trigger as there is no way we can schedule a WorkManager task immediately.", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r376879891", "createdAt": "2020-02-10T06:02:37Z", "author": {"login": "shubham1g5"}, "path": "app/src/org/commcare/activities/UpdateActivity.java", "diffHunk": "@@ -128,22 +135,61 @@ private void loadSavedInstanceState(Bundle savedInstanceState) {\n     }\n \n     private void setupUpdateTask(boolean isRotation) {\n-        updateTask = UpdateTask.getRunningInstance();\n-\n-        if (updateTask != null) {\n-            try {\n-                updateTask.registerTaskListener(this);\n-            } catch (TaskListenerRegistrationException e) {\n-                Log.e(TAG, \"Attempting to register a TaskListener to an already \" +\n-                        \"registered task.\");\n-                uiController.errorUiState();\n+        if (isAutoUpdateInProgress()) {\n+            connectToUpdateWorker();\n+        } else {\n+            updateTask = UpdateTask.getRunningInstance();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwNDA0OA=="}, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMzU4Mw==", "bodyText": "Got it, that's frustrating in terms of the framework (especially since they have different reporting mechanisms back to the UI layer). The design makes sense given those constraints", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r377923583", "createdAt": "2020-02-11T21:56:15Z", "author": {"login": "ctsims"}, "path": "app/src/org/commcare/activities/UpdateActivity.java", "diffHunk": "@@ -128,22 +135,61 @@ private void loadSavedInstanceState(Bundle savedInstanceState) {\n     }\n \n     private void setupUpdateTask(boolean isRotation) {\n-        updateTask = UpdateTask.getRunningInstance();\n-\n-        if (updateTask != null) {\n-            try {\n-                updateTask.registerTaskListener(this);\n-            } catch (TaskListenerRegistrationException e) {\n-                Log.e(TAG, \"Attempting to register a TaskListener to an already \" +\n-                        \"registered task.\");\n-                uiController.errorUiState();\n+        if (isAutoUpdateInProgress()) {\n+            connectToUpdateWorker();\n+        } else {\n+            updateTask = UpdateTask.getRunningInstance();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwNDA0OA=="}, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTQyNDA4OnYy", "diffSide": "RIGHT", "path": "app/src/org/commcare/utils/AppLifecycleUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTowNjozN1rOFnKTZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTowNjozN1rOFnKTZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwNzU4OA==", "bodyText": "This needs to occur before line 45 above, since once the instance is unseated we would start to experience issues if the worker continued until line 56.\nI'd actually recommend that we add this \"cancelAllWorkByTag\" action directly to the CCInstance.unseat()method in general", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r376607588", "createdAt": "2020-02-07T21:06:37Z", "author": {"login": "ctsims"}, "path": "app/src/org/commcare/utils/AppLifecycleUtils.java", "diffHunk": "@@ -50,6 +52,9 @@ public static void uninstall(ApplicationRecord record) {\n         record.setStatus(ApplicationRecord.STATUS_DELETE_REQUESTED);\n         ccInstance.getGlobalStorage(ApplicationRecord.class).write(record);\n \n+        // cancel all Workmanager tasks for this app\n+        WorkManager.getInstance(CommCareApplication.instance()).cancelAllWorkByTag(record.getApplicationId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTQyNjg0OnYy", "diffSide": "LEFT", "path": "app/unit-tests/src/org/commcare/android/tests/application/AutoUpdateTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTowNzo0MVrOFnKVDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwODo1ODozMVrOFpvglg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwODAxMw==", "bodyText": "Is there a reason we aren't replicating a similar test?\nI think in general we should consider it a poor outcome to replace one process that was tested with another that had no tests.", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r376608013", "createdAt": "2020-02-07T21:07:41Z", "author": {"login": "ctsims"}, "path": "app/unit-tests/src/org/commcare/android/tests/application/AutoUpdateTest.java", "diffHunk": "@@ -38,92 +26,6 @@\n @Config(application = CommCareTestApplication.class)\n @RunWith(CommCareTestRunner.class)\n public class AutoUpdateTest {\n-    private final static String REF_BASE_DIR = \"jr://resource/commcare-apps/update_tests/\";\n-    private final static String username = \"test\";\n-    private final static String password = \"123\";\n-\n-    /**\n-     * Check that logging out after an auto-update check failed once should\n-     * trigger the auto-update to resume.\n-     */\n-    @Test\n-    public void testAppAutoUpdateLogoutRetry() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAwNTc5MQ==", "bodyText": "this test checks whether a failed update resumes after the logout. Though since we are currently not cancelling the UpdateWorker on logout but seat change, I don't think this test serves any purpose. Plus earlier we were using our own code to schedule the app updates which made sense to test. Though now since WorkManager takes care of scheduling, it's not guaranteed for an update to resume right away after login.", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r377005791", "createdAt": "2020-02-10T11:25:36Z", "author": {"login": "shubham1g5"}, "path": "app/unit-tests/src/org/commcare/android/tests/application/AutoUpdateTest.java", "diffHunk": "@@ -38,92 +26,6 @@\n @Config(application = CommCareTestApplication.class)\n @RunWith(CommCareTestRunner.class)\n public class AutoUpdateTest {\n-    private final static String REF_BASE_DIR = \"jr://resource/commcare-apps/update_tests/\";\n-    private final static String username = \"test\";\n-    private final static String password = \"123\";\n-\n-    /**\n-     * Check that logging out after an auto-update check failed once should\n-     * trigger the auto-update to resume.\n-     */\n-    @Test\n-    public void testAppAutoUpdateLogoutRetry() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwODAxMw=="}, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNjI5OQ==", "bodyText": "Is there a best practice for how people test WorkManager related behaviors that Google advises?\nI agree that this wasn't a great test, but it did result in some code coverage of execution, so I'm a bit gun shy about that shift", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r377936299", "createdAt": "2020-02-11T22:24:51Z", "author": {"login": "ctsims"}, "path": "app/unit-tests/src/org/commcare/android/tests/application/AutoUpdateTest.java", "diffHunk": "@@ -38,92 +26,6 @@\n @Config(application = CommCareTestApplication.class)\n @RunWith(CommCareTestRunner.class)\n public class AutoUpdateTest {\n-    private final static String REF_BASE_DIR = \"jr://resource/commcare-apps/update_tests/\";\n-    private final static String username = \"test\";\n-    private final static String password = \"123\";\n-\n-    /**\n-     * Check that logging out after an auto-update check failed once should\n-     * trigger the auto-update to resume.\n-     */\n-    @Test\n-    public void testAppAutoUpdateLogoutRetry() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwODAxMw=="}, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxNDMyNg==", "bodyText": "@ctsims In terms of code coverage of our update code we do have AppUpdateTest that runs through most update scenarios.\nFor testing WorkManager itself, Android has some instrumentation tests APIs . I am trying to currently figure out how to use them with Roblectric but facing an issue described here.", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r379314326", "createdAt": "2020-02-14T08:58:31Z", "author": {"login": "shubham1g5"}, "path": "app/unit-tests/src/org/commcare/android/tests/application/AutoUpdateTest.java", "diffHunk": "@@ -38,92 +26,6 @@\n @Config(application = CommCareTestApplication.class)\n @RunWith(CommCareTestRunner.class)\n public class AutoUpdateTest {\n-    private final static String REF_BASE_DIR = \"jr://resource/commcare-apps/update_tests/\";\n-    private final static String username = \"test\";\n-    private final static String password = \"123\";\n-\n-    /**\n-     * Check that logging out after an auto-update check failed once should\n-     * trigger the auto-update to resume.\n-     */\n-    @Test\n-    public void testAppAutoUpdateLogoutRetry() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwODAxMw=="}, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTQzMDMwOnYy", "diffSide": "RIGHT", "path": "app/src/org/commcare/CommCareApplication.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTowOToxMFrOFnKXLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMzo0MzoyNlrOF03b0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwODU1OA==", "bodyText": "It looks like this more or less takes us to a context where we retry auto update every 2 hours, right?\nServer load-wise I think that's quite often if we're presuming that we tried to contact the server, succeeded, and saw there was no update.", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r376608558", "createdAt": "2020-02-07T21:09:10Z", "author": {"login": "ctsims"}, "path": "app/src/org/commcare/CommCareApplication.java", "diffHunk": "@@ -755,6 +761,30 @@ public void onServiceDisconnected(ComponentName className) {\n         sessionServiceIsBinding = true;\r\n     }\r\n \r\n+    // Hand off an app update task to the Android WorkManager\r\n+    private void scheduleAppUpdate() {\r\n+        Constraints constraints = new Constraints.Builder()\r\n+                .setRequiredNetworkType(NetworkType.CONNECTED)\r\n+                .setRequiresBatteryNotLow(true)\r\n+                .build();\r\n+\r\n+        PeriodicWorkRequest updateRequest =\r\n+                new PeriodicWorkRequest.Builder(UpdateWorker.class, PERIODICITY_FOR_UPDATE_IN_HOURS, TimeUnit.HOURS)\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg5NDIwMg==", "bodyText": "So the internal UpdateWorker check here  will still respect the auto update frequency set for the app which should take care of server getting hit too often.", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r376894202", "createdAt": "2020-02-10T07:07:15Z", "author": {"login": "shubham1g5"}, "path": "app/src/org/commcare/CommCareApplication.java", "diffHunk": "@@ -755,6 +761,30 @@ public void onServiceDisconnected(ComponentName className) {\n         sessionServiceIsBinding = true;\r\n     }\r\n \r\n+    // Hand off an app update task to the Android WorkManager\r\n+    private void scheduleAppUpdate() {\r\n+        Constraints constraints = new Constraints.Builder()\r\n+                .setRequiredNetworkType(NetworkType.CONNECTED)\r\n+                .setRequiresBatteryNotLow(true)\r\n+                .build();\r\n+\r\n+        PeriodicWorkRequest updateRequest =\r\n+                new PeriodicWorkRequest.Builder(UpdateWorker.class, PERIODICITY_FOR_UPDATE_IN_HOURS, TimeUnit.HOURS)\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwODU1OA=="}, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk3ODUxMg==", "bodyText": "@ctsims  Wondering if we should still respect the update frequency set in app properties for triggering the background update  worker. We might derive more value in terms of update uptake from ignoring this flag and instead have a more liberal frequency for update check that doesn't cause the server load to spike too much.", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r390978512", "createdAt": "2020-03-11T13:43:26Z", "author": {"login": "shubham1g5"}, "path": "app/src/org/commcare/CommCareApplication.java", "diffHunk": "@@ -755,6 +761,30 @@ public void onServiceDisconnected(ComponentName className) {\n         sessionServiceIsBinding = true;\r\n     }\r\n \r\n+    // Hand off an app update task to the Android WorkManager\r\n+    private void scheduleAppUpdate() {\r\n+        Constraints constraints = new Constraints.Builder()\r\n+                .setRequiredNetworkType(NetworkType.CONNECTED)\r\n+                .setRequiresBatteryNotLow(true)\r\n+                .build();\r\n+\r\n+        PeriodicWorkRequest updateRequest =\r\n+                new PeriodicWorkRequest.Builder(UpdateWorker.class, PERIODICITY_FOR_UPDATE_IN_HOURS, TimeUnit.HOURS)\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwODU1OA=="}, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTQzODgzOnYy", "diffSide": "RIGHT", "path": "app/src/org/commcare/update/UpdateWorker.kt", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMToxMzoxMFrOFnKcrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoyMToyMVrOFobTiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwOTk2Nw==", "bodyText": "I'm not sure this resonates with me.\nI think we only want to be applying the backoff-controlled-retries if there was a network reason for the update to fail. The UnknownError state, for example, doesn't feel like it should necessarily be triggering up to (5 min, 25 min, 10 hr) 3 retries over the course of the day before the user is logged out.", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r376609967", "createdAt": "2020-02-07T21:13:10Z", "author": {"login": "ctsims"}, "path": "app/src/org/commcare/update/UpdateWorker.kt", "diffHunk": "@@ -0,0 +1,105 @@\n+package org.commcare.update\n+\n+import android.content.Context\n+import androidx.work.CoroutineWorker\n+import androidx.work.WorkerParameters\n+import androidx.work.workDataOf\n+import kotlinx.coroutines.CancellationException\n+import kotlinx.coroutines.async\n+import kotlinx.coroutines.coroutineScope\n+import org.commcare.CommCareApplication\n+import org.commcare.engine.resource.AppInstallStatus\n+import org.commcare.engine.resource.ResourceInstallUtils\n+import org.commcare.resources.model.InstallCancelled\n+import org.commcare.tasks.ResultAndError\n+\n+/**\n+ * Used to stage an update for the seated app in the background. Does not perform\n+ * actual update.\n+ *\n+ */\n+class UpdateWorker(appContext: Context, workerParams: WorkerParameters)\n+    : CoroutineWorker(appContext, workerParams), InstallCancelled, UpdateProgressListener {\n+\n+    companion object {\n+        const val Progress_Complete = \"complete\"\n+        const val Progress_Total = \"total\"\n+    }\n+\n+    private lateinit var updateHelper: UpdateHelper\n+\n+    override suspend fun doWork(): Result {\n+\n+        updateHelper = UpdateHelper.getNewInstance(true, this, this)\n+\n+        return coroutineScope {\n+            val job = async {\n+                doUpdateWork()\n+            }\n+\n+            job.invokeOnCompletion { exception: Throwable? ->\n+                when (exception) {\n+                    is CancellationException -> {\n+                        handleUpdateResult(ResultAndError(AppInstallStatus.Cancelled))\n+                    }\n+                    else -> {\n+                        handleUpdateResult(ResultAndError(AppInstallStatus.UnknownFailure))\n+                    }\n+                }\n+            }\n+\n+            job.await()\n+        }\n+\n+    }\n+\n+    private fun doUpdateWork(): Result {\n+        var updateResult: ResultAndError<AppInstallStatus>\n+\n+        // skip if - An update task is already running | no app is seated | user session is not active\n+        if (UpdateTask.getRunningInstance() == null &&\n+                CommCareApplication.instance().getCurrentApp() != null &&\n+                CommCareApplication.instance().getSession().isActive() &&\n+                UpdateHelper.shouldAutoUpdate()) {\n+\n+            updateHelper.startPinnedNotification(CommCareApplication.instance())\n+            updateResult = updateHelper.update(ResourceInstallUtils.getDefaultProfileRef())\n+        } else {\n+            return Result.success()\n+        }\n+        return handleUpdateResult(updateResult)\n+    }\n+\n+    private fun handleUpdateResult(updateResult: ResultAndError<AppInstallStatus>): Result {\n+\n+        if (updateResult.data == AppInstallStatus.Cancelled) {\n+            updateHelper.OnUpdateCancelled()\n+        }\n+\n+        updateHelper.OnUpdateComplete(updateResult)\n+\n+        cleanUp()\n+\n+        return when (updateResult.data.isUpdateInCompletedState) {\n+            true -> Result.success()\n+            else -> Result.retry()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1NzQwOQ==", "bodyText": "Makes sense. I was trying to immitate the earlier behaviour but agree that we should only retry on network errors.", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r376957409", "createdAt": "2020-02-10T09:49:18Z", "author": {"login": "shubham1g5"}, "path": "app/src/org/commcare/update/UpdateWorker.kt", "diffHunk": "@@ -0,0 +1,105 @@\n+package org.commcare.update\n+\n+import android.content.Context\n+import androidx.work.CoroutineWorker\n+import androidx.work.WorkerParameters\n+import androidx.work.workDataOf\n+import kotlinx.coroutines.CancellationException\n+import kotlinx.coroutines.async\n+import kotlinx.coroutines.coroutineScope\n+import org.commcare.CommCareApplication\n+import org.commcare.engine.resource.AppInstallStatus\n+import org.commcare.engine.resource.ResourceInstallUtils\n+import org.commcare.resources.model.InstallCancelled\n+import org.commcare.tasks.ResultAndError\n+\n+/**\n+ * Used to stage an update for the seated app in the background. Does not perform\n+ * actual update.\n+ *\n+ */\n+class UpdateWorker(appContext: Context, workerParams: WorkerParameters)\n+    : CoroutineWorker(appContext, workerParams), InstallCancelled, UpdateProgressListener {\n+\n+    companion object {\n+        const val Progress_Complete = \"complete\"\n+        const val Progress_Total = \"total\"\n+    }\n+\n+    private lateinit var updateHelper: UpdateHelper\n+\n+    override suspend fun doWork(): Result {\n+\n+        updateHelper = UpdateHelper.getNewInstance(true, this, this)\n+\n+        return coroutineScope {\n+            val job = async {\n+                doUpdateWork()\n+            }\n+\n+            job.invokeOnCompletion { exception: Throwable? ->\n+                when (exception) {\n+                    is CancellationException -> {\n+                        handleUpdateResult(ResultAndError(AppInstallStatus.Cancelled))\n+                    }\n+                    else -> {\n+                        handleUpdateResult(ResultAndError(AppInstallStatus.UnknownFailure))\n+                    }\n+                }\n+            }\n+\n+            job.await()\n+        }\n+\n+    }\n+\n+    private fun doUpdateWork(): Result {\n+        var updateResult: ResultAndError<AppInstallStatus>\n+\n+        // skip if - An update task is already running | no app is seated | user session is not active\n+        if (UpdateTask.getRunningInstance() == null &&\n+                CommCareApplication.instance().getCurrentApp() != null &&\n+                CommCareApplication.instance().getSession().isActive() &&\n+                UpdateHelper.shouldAutoUpdate()) {\n+\n+            updateHelper.startPinnedNotification(CommCareApplication.instance())\n+            updateResult = updateHelper.update(ResourceInstallUtils.getDefaultProfileRef())\n+        } else {\n+            return Result.success()\n+        }\n+        return handleUpdateResult(updateResult)\n+    }\n+\n+    private fun handleUpdateResult(updateResult: ResultAndError<AppInstallStatus>): Result {\n+\n+        if (updateResult.data == AppInstallStatus.Cancelled) {\n+            updateHelper.OnUpdateCancelled()\n+        }\n+\n+        updateHelper.OnUpdateComplete(updateResult)\n+\n+        cleanUp()\n+\n+        return when (updateResult.data.isUpdateInCompletedState) {\n+            true -> Result.success()\n+            else -> Result.retry()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwOTk2Nw=="}, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNDcyOQ==", "bodyText": "Got it, that makes sense. Thanks for the revision.", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r377934729", "createdAt": "2020-02-11T22:21:21Z", "author": {"login": "ctsims"}, "path": "app/src/org/commcare/update/UpdateWorker.kt", "diffHunk": "@@ -0,0 +1,105 @@\n+package org.commcare.update\n+\n+import android.content.Context\n+import androidx.work.CoroutineWorker\n+import androidx.work.WorkerParameters\n+import androidx.work.workDataOf\n+import kotlinx.coroutines.CancellationException\n+import kotlinx.coroutines.async\n+import kotlinx.coroutines.coroutineScope\n+import org.commcare.CommCareApplication\n+import org.commcare.engine.resource.AppInstallStatus\n+import org.commcare.engine.resource.ResourceInstallUtils\n+import org.commcare.resources.model.InstallCancelled\n+import org.commcare.tasks.ResultAndError\n+\n+/**\n+ * Used to stage an update for the seated app in the background. Does not perform\n+ * actual update.\n+ *\n+ */\n+class UpdateWorker(appContext: Context, workerParams: WorkerParameters)\n+    : CoroutineWorker(appContext, workerParams), InstallCancelled, UpdateProgressListener {\n+\n+    companion object {\n+        const val Progress_Complete = \"complete\"\n+        const val Progress_Total = \"total\"\n+    }\n+\n+    private lateinit var updateHelper: UpdateHelper\n+\n+    override suspend fun doWork(): Result {\n+\n+        updateHelper = UpdateHelper.getNewInstance(true, this, this)\n+\n+        return coroutineScope {\n+            val job = async {\n+                doUpdateWork()\n+            }\n+\n+            job.invokeOnCompletion { exception: Throwable? ->\n+                when (exception) {\n+                    is CancellationException -> {\n+                        handleUpdateResult(ResultAndError(AppInstallStatus.Cancelled))\n+                    }\n+                    else -> {\n+                        handleUpdateResult(ResultAndError(AppInstallStatus.UnknownFailure))\n+                    }\n+                }\n+            }\n+\n+            job.await()\n+        }\n+\n+    }\n+\n+    private fun doUpdateWork(): Result {\n+        var updateResult: ResultAndError<AppInstallStatus>\n+\n+        // skip if - An update task is already running | no app is seated | user session is not active\n+        if (UpdateTask.getRunningInstance() == null &&\n+                CommCareApplication.instance().getCurrentApp() != null &&\n+                CommCareApplication.instance().getSession().isActive() &&\n+                UpdateHelper.shouldAutoUpdate()) {\n+\n+            updateHelper.startPinnedNotification(CommCareApplication.instance())\n+            updateResult = updateHelper.update(ResourceInstallUtils.getDefaultProfileRef())\n+        } else {\n+            return Result.success()\n+        }\n+        return handleUpdateResult(updateResult)\n+    }\n+\n+    private fun handleUpdateResult(updateResult: ResultAndError<AppInstallStatus>): Result {\n+\n+        if (updateResult.data == AppInstallStatus.Cancelled) {\n+            updateHelper.OnUpdateCancelled()\n+        }\n+\n+        updateHelper.OnUpdateComplete(updateResult)\n+\n+        cleanUp()\n+\n+        return when (updateResult.data.isUpdateInCompletedState) {\n+            true -> Result.success()\n+            else -> Result.retry()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwOTk2Nw=="}, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTQ0MjA2OnYy", "diffSide": "RIGHT", "path": "app/src/org/commcare/activities/LoginActivity.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMToxNDozMVrOFnKeuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwNjo1OTo1NFrOFnbsNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxMDQ5MQ==", "bodyText": "Quick note that this request isn't synchronous. I'm not sure how killing the update tasks worked when we unseated apps, but if you haven't checked it would be worth confirming that the semantics are the same.", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r376610491", "createdAt": "2020-02-07T21:14:31Z", "author": {"login": "ctsims"}, "path": "app/src/org/commcare/activities/LoginActivity.java", "diffHunk": "@@ -238,11 +238,22 @@ protected boolean checkForSeatedAppChange() {\n         String currentSeatedId = CommCareApplication.instance().getCurrentApp().getUniqueId();\r\n         if (!lastSeatedId.equals(currentSeatedId)) {\r\n             prefs.edit().putString(KEY_LAST_APP, currentSeatedId).commit();\r\n+            disableWorkForLastSeatedApp();\r\n             return true;\r\n         }\r\n         return false;\r\n     }\r\n \r\n+\r\n+    // cancels all worker tasks for previously seated app\r\n+    private static void disableWorkForLastSeatedApp() {\r\n+        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(CommCareApplication.instance());\r\n+        String lastSeatedId = prefs.getString(KEY_LAST_APP, \"\");\r\n+        if(!lastSeatedId.isEmpty()) {\r\n+            WorkManager.getInstance(CommCareApplication.instance()).cancelAllWorkByTag(lastSeatedId);\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg5MjQ3MQ==", "bodyText": "From the note here, it looks like instead of cancelling the auto update for previous app, we were just firing the update request for the new seated app during the auto update process. We cancel all running tasks today on logout which takes care of update request getting cancelled on logout and then when the user logins, we reinititate the task for the current app. We can follow the same semantics for cancelling the WorkManager tasks though since app updates can work fine even when the user is logged out, we can choose to just cancel work on app seating changes to keep the last update downloads running even when user is logged out.", "url": "https://github.com/dimagi/commcare-android/pull/2180#discussion_r376892471", "createdAt": "2020-02-10T06:59:54Z", "author": {"login": "shubham1g5"}, "path": "app/src/org/commcare/activities/LoginActivity.java", "diffHunk": "@@ -238,11 +238,22 @@ protected boolean checkForSeatedAppChange() {\n         String currentSeatedId = CommCareApplication.instance().getCurrentApp().getUniqueId();\r\n         if (!lastSeatedId.equals(currentSeatedId)) {\r\n             prefs.edit().putString(KEY_LAST_APP, currentSeatedId).commit();\r\n+            disableWorkForLastSeatedApp();\r\n             return true;\r\n         }\r\n         return false;\r\n     }\r\n \r\n+\r\n+    // cancels all worker tasks for previously seated app\r\n+    private static void disableWorkForLastSeatedApp() {\r\n+        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(CommCareApplication.instance());\r\n+        String lastSeatedId = prefs.getString(KEY_LAST_APP, \"\");\r\n+        if(!lastSeatedId.isEmpty()) {\r\n+            WorkManager.getInstance(CommCareApplication.instance()).cancelAllWorkByTag(lastSeatedId);\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxMDQ5MQ=="}, "originalCommit": {"oid": "902179a7ac968aebe78a09f14f6eba446cdc5eb5"}, "originalPosition": 70}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3324, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}