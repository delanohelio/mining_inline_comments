{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxMzI4Mjg5", "number": 9624, "title": "Add returning for insert to storage engine", "bodyText": "Summary of the changes / Why this improves CrateDB\nThis adds support for the returning clause for the insert-from-values as well as the insert-from-subqueries usecase e.g.:\ninsert into t (id) values (1) returning id as foo\ninsert into t (id)  select '1' as id returning id as foo\nChecklist\n\n User relevant changes are recorded in CHANGES.txt\n Touched code is covered by tests\n Documentation has been updated if necessary\n CLA is signed\n This does not contain breaking changes, or if it does:\n\nIt is released within a major release\nIt is recorded in CHANGES.txt\nIt was marked as deprecated in an earlier release if possible\nYou've thought about the consequences and other components are adapted\n(E.g. AdminUI)", "createdAt": "2020-02-05T11:43:38Z", "url": "https://github.com/crate/crate/pull/9624", "merged": true, "mergeCommit": {"oid": "3bbd6bdc29359c6930d2548188d4e04d4ab8c866"}, "closed": true, "closedAt": "2020-02-12T13:12:11Z", "author": {"login": "mkleen"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBrxnVgBqjMwMTQxMzUwMzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcDkULwgBqjMwMzAzNTMzODc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "55c269686babca2121f63270dd956941a77e80a9", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/55c269686babca2121f63270dd956941a77e80a9", "committedDate": "2020-02-06T13:10:19Z", "message": "Add isEmpty to update compressed reesults"}, "afterCommit": {"oid": "954ebedd1f94ae51d05695ba002472cd1963816b", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/954ebedd1f94ae51d05695ba002472cd1963816b", "committedDate": "2020-02-06T14:18:34Z", "message": "Adapt InsertSourceGen to get all tests working (inefficient change)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MDU5NzUz", "url": "https://github.com/crate/crate/pull/9624#pullrequestreview-355059753", "createdAt": "2020-02-07T10:22:21Z", "commit": {"oid": "d09063532acaa7dc407a01fdc8406b2f289e935f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMDoyMjoyMlrOFm4kEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMDoyMjoyMlrOFm4kEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMxNjk0NA==", "bodyText": "I am not sure if the ShardResponse.CompressedResult should have resultValues, it works, but seems to me semantically questionable.\nSo we could consider using the full ShardResponse when using return values instead or an own dedicated datastructure.", "url": "https://github.com/crate/crate/pull/9624#discussion_r376316944", "createdAt": "2020-02-07T10:22:22Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/execution/dml/ShardResponse.java", "diffHunk": "@@ -257,6 +257,7 @@ public void writeTo(StreamOutput out) throws IOException {\n \n         private final BitSet successfulWrites = new BitSet();\n         private final BitSet failureLocations = new BitSet();\n+        private final List<Object[]> resultValues = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d09063532acaa7dc407a01fdc8406b2f289e935f"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e843bd2640719d019b70a9ef1c7fe842032cfa44", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/e843bd2640719d019b70a9ef1c7fe842032cfa44", "committedDate": "2020-02-07T16:00:56Z", "message": "Simplify TransportShardUpsertAction"}, "afterCommit": {"oid": "38591ccf274e4998028e771d0389bb9ab368d218", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/38591ccf274e4998028e771d0389bb9ab368d218", "committedDate": "2020-02-07T17:21:26Z", "message": "Simplify TransportShardUpsertAction"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "38591ccf274e4998028e771d0389bb9ab368d218", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/38591ccf274e4998028e771d0389bb9ab368d218", "committedDate": "2020-02-07T17:21:26Z", "message": "Simplify TransportShardUpsertAction"}, "afterCommit": {"oid": "cfb7667fb8a4bad1eb75b13d16d3401640bfb788", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/cfb7667fb8a4bad1eb75b13d16d3401640bfb788", "committedDate": "2020-02-07T17:28:05Z", "message": "Simplify TransportShardUpsertAction"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NzE2NTgy", "url": "https://github.com/crate/crate/pull/9624#pullrequestreview-355716582", "createdAt": "2020-02-10T06:46:45Z", "commit": {"oid": "b5722a66711ce84783d1311fc496bc44aebaa012"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwNjo0Njo0NlrOFnbgFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwNjo0Njo0NlrOFnbgFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg4OTM2Nw==", "bodyText": "According to @mfussenegger this case should never happen since the source would be only null if it is created from a FromRawInsertSource which only applies to the COPY statement, which does not have a returning clause. However, this make sure values are only converted back from BytesReference to Map<String, Object if result values are requested.", "url": "https://github.com/crate/crate/pull/9624#discussion_r376889367", "createdAt": "2020-02-10T06:46:46Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +308,103 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        final BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = insertSourceGen.toBytesReference(source);\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        final long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        final long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        final long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            if (source == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5722a66711ce84783d1311fc496bc44aebaa012"}, "originalPosition": 142}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NzE5MDY3", "url": "https://github.com/crate/crate/pull/9624#pullrequestreview-355719067", "createdAt": "2020-02-10T06:55:31Z", "commit": {"oid": "b5722a66711ce84783d1311fc496bc44aebaa012"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwNjo1NTozMVrOFnboIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwNjo1NTozMVrOFnboIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg5MTQyNQ==", "bodyText": "This change is needed to be able to retrieve the result as Map<String, Object>. In all cases except the one in FromRawInsertSource the data is already in the form of Map<String, Object> which is needed for the returnvalue evaluation. Otherwise the values would need to converted again from BytesReference, which is unnecessary and expensive.", "url": "https://github.com/crate/crate/pull/9624#discussion_r376891425", "createdAt": "2020-02-10T06:55:31Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/InsertSourceGen.java", "diffHunk": "@@ -28,13 +28,17 @@\n import io.crate.metadata.doc.DocSysColumns;\n import io.crate.metadata.doc.DocTableInfo;\n import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n \n import java.io.IOException;\n import java.util.List;\n+import java.util.Map;\n \n public interface InsertSourceGen {\n \n-    BytesReference generateSourceAndCheckConstraints(Object[] values) throws IOException;\n+    BytesReference generateSourceAndCheckConstraintsAsBytesReference(Object[] values) throws IOException;\n+\n+    Map<String, Object> generateSourceAndCheckConstraints(Object[] values) throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5722a66711ce84783d1311fc496bc44aebaa012"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NzIxMzIx", "url": "https://github.com/crate/crate/pull/9624#pullrequestreview-355721321", "createdAt": "2020-02-10T07:03:08Z", "commit": {"oid": "555d0f64189e50104ceb5cab3ee4d4fa39d2ad32"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwNzowMzowOVrOFnbvOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwNzowMzowOVrOFnbvOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg5MzI0MQ==", "bodyText": "Minor: The type of outputs is defined in multiple ways over the codebase, sometimes it is List<Symbol> sometimes it is List<? extends Symbol> and sometimes it is List<Field>. Are there any cases where the output is not a Field  ?", "url": "https://github.com/crate/crate/pull/9624#discussion_r376893241", "createdAt": "2020-02-10T07:03:09Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/planner/operators/Insert.java", "diffHunk": "@@ -95,7 +95,7 @@ ColumnIndexWriterProjection columnIndexWriterProjection() {\n \n     @Override\n     public List<Symbol> outputs() {\n-        return MergeCountProjection.OUTPUTS;\n+        return (List<Symbol>) writeToTable.outputs();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "555d0f64189e50104ceb5cab3ee4d4fa39d2ad32"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1ODU0MjM1", "url": "https://github.com/crate/crate/pull/9624#pullrequestreview-355854235", "createdAt": "2020-02-10T11:09:10Z", "commit": {"oid": "e02cf964077f497226dcbdfc19642540f67a92a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMTowOToxMFrOFniLuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMTowOToxMFrOFniLuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5ODg0Mw==", "bodyText": "This optimizes for the case where to insert value is already string-based.", "url": "https://github.com/crate/crate/pull/9624#discussion_r376998843", "createdAt": "2020-02-10T11:09:10Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +308,103 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        final BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            if (insertSourceGen instanceof FromRawInsertSource) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02cf964077f497226dcbdfc19642540f67a92a0"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NzI0NDA3", "url": "https://github.com/crate/crate/pull/9624#pullrequestreview-356724407", "createdAt": "2020-02-11T14:57:23Z", "commit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNDo1NzoyM1rOFoMKnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNToxNTozM1rOFoM5wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4NjY4NQ==", "bodyText": "Looks like this file was added by accident.", "url": "https://github.com/crate/crate/pull/9624#discussion_r377686685", "createdAt": "2020-02-11T14:57:23Z", "author": {"login": "mfussenegger"}, "path": "hs_err_pid15742.log", "diffHunk": "@@ -0,0 +1,629 @@\n+#", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4Nzc0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private final ArrayList<Object[]> resultValues = new ArrayList<>();\n          \n          \n            \n                    private final ArrayList<Object[]> resultRows= new ArrayList<>();\n          \n      \n    \n    \n  \n\nI think rows would be less vague than values.", "url": "https://github.com/crate/crate/pull/9624#discussion_r377687740", "createdAt": "2020-02-11T14:58:50Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dml/ShardResponse.java", "diffHunk": "@@ -257,6 +257,7 @@ public void writeTo(StreamOutput out) throws IOException {\n \n         private final BitSet successfulWrites = new BitSet();\n         private final BitSet failureLocations = new BitSet();\n+        private final ArrayList<Object[]> resultValues = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4ODQyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public List<Object[]> resultValues() {\n          \n          \n            \n                    public List<Object[]> resultRows() {", "url": "https://github.com/crate/crate/pull/9624#discussion_r377688426", "createdAt": "2020-02-11T14:59:51Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dml/ShardResponse.java", "diffHunk": "@@ -280,6 +285,10 @@ public boolean failed(int location) {\n             return failureLocations.get(location);\n         }\n \n+        public List<Object[]> resultValues() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4OTk4Nw==", "bodyText": "Would it be possible to add the default implementation to generateSourceAndCheckConstraintsAsBytesReference instead of adding an additional method?", "url": "https://github.com/crate/crate/pull/9624#discussion_r377689987", "createdAt": "2020-02-11T15:02:16Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/InsertSourceGen.java", "diffHunk": "@@ -51,4 +55,8 @@ static InsertSourceGen of(TransactionContext txnCtx,\n         }\n         return new InsertSourceFromCells(txnCtx, functions, table, indexName, validation, targets);\n     }\n+\n+    default BytesReference toBytesReference(Map<String, Object> source) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5MTQ3MQ==", "bodyText": "I think it would be worth adding the information that this is primarily a performance optimization as inline comment.", "url": "https://github.com/crate/crate/pull/9624#discussion_r377691471", "createdAt": "2020-02-11T15:04:41Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +308,103 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        final BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            if (insertSourceGen instanceof FromRawInsertSource) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5ODg0Mw=="}, "originalCommit": {"oid": "e02cf964077f497226dcbdfc19642540f67a92a0"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5MjA5Ng==", "bodyText": "I think I was wrong. a INSERT INTO tbl (_raw) ... could probably also trigger this case.", "url": "https://github.com/crate/crate/pull/9624#discussion_r377692096", "createdAt": "2020-02-11T15:05:36Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +308,103 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        final BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = insertSourceGen.toBytesReference(source);\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        final long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        final long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        final long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            if (source == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg4OTM2Nw=="}, "originalCommit": {"oid": "b5722a66711ce84783d1311fc496bc44aebaa012"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5MjY4OA==", "bodyText": "The other parameters have a different indentation than the last one. I'm surprised that checkstyle doesn't complain aobut this.", "url": "https://github.com/crate/crate/pull/9624#discussion_r377692688", "createdAt": "2020-02-11T15:06:33Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,103 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = insertSourceGen.toBytesReference(source);\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                new Doc(-1,\n+                        indexShard.shardId().getIndexName(),\n+                        item.id(),\n+                        indexResult.getVersion(),\n+                        indexResult.getSeqNo(),\n+                        primaryTerm,\n+                        source,\n+                    () -> \"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5MzE1Nw==", "bodyText": "I think it would also be worth adding a comment about why the -1 is okay.", "url": "https://github.com/crate/crate/pull/9624#discussion_r377693157", "createdAt": "2020-02-11T15:07:15Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,103 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = insertSourceGen.toBytesReference(source);\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                new Doc(-1,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5Mzk0OQ==", "bodyText": "Nodes running 4.1 or earlier won't send this, so we need to add some BWC handling here.", "url": "https://github.com/crate/crate/pull/9624#discussion_r377693949", "createdAt": "2020-02-11T15:08:24Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dsl/projection/ColumnIndexWriterProjection.java", "diffHunk": "@@ -115,9 +124,41 @@ public ColumnIndexWriterProjection(RelationName relationName,\n             for (int i = 0; i < mapSize; i++) {\n                 allTargetColumns.add(Reference.fromStream(in));\n             }\n+\n+            int outputSize = in.readVInt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5NDg5OA==", "bodyText": "What is the difference between returnValues and outputs? Isn't it redundant to have both?", "url": "https://github.com/crate/crate/pull/9624#discussion_r377694898", "createdAt": "2020-02-11T15:09:48Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/execution/dsl/projection/ColumnIndexWriterProjection.java", "diffHunk": "@@ -115,9 +124,41 @@ public ColumnIndexWriterProjection(RelationName relationName,\n             for (int i = 0; i < mapSize; i++) {\n                 allTargetColumns.add(Reference.fromStream(in));\n             }\n+\n+            int outputSize = in.readVInt();\n+            if (outputSize > 0) {\n+                var result = new ArrayList<Symbol>(outputSize);\n+                for (int i = 0; i < outputSize; i++) {\n+                    result.add(Symbols.fromStream(in));\n+                }\n+                outputs = result;\n+            } else {\n+                outputs = List.of();\n+            }\n+\n+            int returnValueSize = in.readVInt();\n+            if (returnValueSize > 0) {\n+                returnValues = new ArrayList<>(returnValueSize);\n+                for (int i = 0; i < returnValueSize; i++) {\n+                    returnValues.add(Symbols.fromStream(in));\n+                }\n+            } else {\n+                returnValues = List.of();\n+            }\n         } else {\n+            returnValues = List.of();\n+            outputs = List.of();\n             allTargetColumns = List.of();\n         }\n+\n+    }\n+\n+    public List<? extends Symbol> outputs() {\n+        return outputs;\n+    }\n+\n+    public List<Symbol> returnValues() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5NjUyMQ==", "bodyText": "Yes, there can be function symbols or Reference symbols as well.", "url": "https://github.com/crate/crate/pull/9624#discussion_r377696521", "createdAt": "2020-02-11T15:12:11Z", "author": {"login": "mfussenegger"}, "path": "sql/src/main/java/io/crate/planner/operators/Insert.java", "diffHunk": "@@ -95,7 +95,7 @@ ColumnIndexWriterProjection columnIndexWriterProjection() {\n \n     @Override\n     public List<Symbol> outputs() {\n-        return MergeCountProjection.OUTPUTS;\n+        return (List<Symbol>) writeToTable.outputs();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg5MzI0MQ=="}, "originalCommit": {"oid": "555d0f64189e50104ceb5cab3ee4d4fa39d2ad32"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5ODc1NA==", "bodyText": "Maybe limit this to only the one table that is used in the tests.\nWastes some CPU cycles and makes it more difficult to have an overview what schemas are in use in this file.", "url": "https://github.com/crate/crate/pull/9624#discussion_r377698754", "createdAt": "2020-02-11T15:15:33Z", "author": {"login": "mfussenegger"}, "path": "sql/src/test/java/io/crate/planner/consumer/InsertFromSubQueryPlannerTest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.consumer;\n+\n+import com.carrotsearch.randomizedtesting.RandomizedTest;\n+import io.crate.analyze.TableDefinitions;\n+import io.crate.exceptions.UnsupportedFeatureException;\n+import io.crate.metadata.CoordinatorTxnCtx;\n+import io.crate.metadata.PartitionName;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.test.integration.CrateDummyClusterServiceUnitTest;\n+import io.crate.testing.SQLExecutor;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+\n+import static java.util.Collections.singletonList;\n+\n+public class InsertFromSubQueryPlannerTest extends CrateDummyClusterServiceUnitTest {\n+\n+    private SQLExecutor e;\n+    private TransactionContext txnCtx = CoordinatorTxnCtx.systemTransactionContext();\n+\n+    @Before\n+    public void prepare() throws IOException {\n+        e = buildExecutor(clusterService);\n+    }\n+\n+    private static SQLExecutor buildExecutor(ClusterService clusterService) throws IOException {\n+        return SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom())\n+            .enableDefaultTables()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "720b84a7c13191c2fddac716de4e7e49ed70f603"}, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MjU4NTEx", "url": "https://github.com/crate/crate/pull/9624#pullrequestreview-357258511", "createdAt": "2020-02-12T08:22:46Z", "commit": {"oid": "a411e5152b95add7f9ea58590e5823e1fbf4f5d1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwODoyMjo0N1rOFolOiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwODoyMjo0N1rOFolOiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA5NzI4OQ==", "bodyText": "Checkstyle lambda oddity again, see comment before.", "url": "https://github.com/crate/crate/pull/9624#discussion_r378097289", "createdAt": "2020-02-12T08:22:47Z", "author": {"login": "mkleen"}, "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,108 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            // This optimizes for the case where the insert value is already string-based.\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            // This optimizes for the case where the insert value is already string-based, so only parse the source\n+            // when return values are requested\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                // return -1 as docId, the docId can only be retrieved by fetching the inserted document again, which\n+                // we want to avoid. The docId is anyway just valid with the lifetime of a searcher and can change afterwards.\n+                new Doc(-1,\n+                        indexShard.shardId().getIndexName(),\n+                        item.id(),\n+                        indexResult.getVersion(),\n+                        indexResult.getSeqNo(),\n+                        primaryTerm,\n+                        source,\n+                    () -> \"\"\n+                )\n+            );\n+        }\n+        return new IndexItemResponse(indexResult.getTranslogLocation(), returnvalues);\n+    }\n \n-            item.source(BytesReference.bytes(XContentFactory.jsonBuilder().map(updatedSource)));\n-            seqNo = item.seqNo();\n-            primaryTerm = item.primaryTerm();\n-            version = Versions.MATCH_ANY;\n+    protected IndexItemResponse update(ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable UpdateSourceGen updateSourceGen) throws Exception {\n+        assert updateSourceGen != null : \"UpdateSourceGen must not be null\";\n+        Doc fetchedDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n+        Map<String, Object> source = updateSourceGen.generateSource(\n+            fetchedDoc,\n+            item.updateAssignments(),\n+            item.insertValues()\n+        );\n+        BytesReference rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n+        item.source(rawSource);\n+        long seqNo = item.seqNo();\n+        long primaryTerm = item.primaryTerm();\n+        long version = Versions.MATCH_ANY;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            returnvalues = returnGen.generateReturnValues(\n+                new Doc(fetchedDoc.docId(),\n+                        fetchedDoc.getIndex(),\n+                        fetchedDoc.getId(),\n+                        indexResult.getVersion(),\n+                        indexResult.getSeqNo(),\n+                        indexResult.getTerm(),\n+                        source,\n+                    () -> \"\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a411e5152b95add7f9ea58590e5823e1fbf4f5d1"}, "originalPosition": 188}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MzUyNjM1", "url": "https://github.com/crate/crate/pull/9624#pullrequestreview-357352635", "createdAt": "2020-02-12T10:45:40Z", "commit": {"oid": "c4828cd306c733f69df30eefde60aaec9c0775af"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a61e6d581a99439b9e806c3993c064efcc1781ce", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/a61e6d581a99439b9e806c3993c064efcc1781ce", "committedDate": "2020-02-12T11:02:03Z", "message": "Add returning clause for insert to storage engine"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c4828cd306c733f69df30eefde60aaec9c0775af", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/c4828cd306c733f69df30eefde60aaec9c0775af", "committedDate": "2020-02-12T09:03:03Z", "message": "Adapt formatting for lambda for docs for return values"}, "afterCommit": {"oid": "a61e6d581a99439b9e806c3993c064efcc1781ce", "author": {"user": {"login": "mkleen", "name": "Michael Kleen"}}, "url": "https://github.com/crate/crate/commit/a61e6d581a99439b9e806c3993c064efcc1781ce", "committedDate": "2020-02-12T11:02:03Z", "message": "Add returning clause for insert to storage engine"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3822, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}